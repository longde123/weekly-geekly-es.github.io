<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ô£Ô∏è üï¥üèº üé• Tipos dependentes - o futuro das linguagens de programa√ß√£o üîÄ ü§æüèΩ ü§∞üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! 

 Apesar da estranheza e de alguma abstra√ß√£o do t√≥pico considerado hoje - esperamos que ele possa diversificar seu fim de semana. No fin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipos dependentes - o futuro das linguagens de programa√ß√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/432416/">  Ol√° pessoal! <br><br>  Apesar da estranheza e de alguma abstra√ß√£o do t√≥pico considerado hoje - esperamos que ele possa diversificar seu fim de semana.  No final do post, colocamos tr√™s links do autor, permitindo que voc√™ se familiarize com a digita√ß√£o dependente de Idris, F * e JavaScript <br><a name="habracut"></a><br>  √Äs vezes, parece que as linguagens de programa√ß√£o n√£o mudaram muito desde os anos 60.  Quando eles me falam sobre isso, lembro-me com frequ√™ncia de quantas ferramentas e recursos interessantes temos agora √† nossa disposi√ß√£o e como eles simplificam nossas vidas.  Prontamente: trata-se de depuradores integrados, testes de unidade e analisadores est√°ticos e IDEs legais, bem como matrizes digitadas e muito mais.  O desenvolvimento de idiomas √© um processo longo e progressivo, e n√£o existem ‚Äúbalas de prata‚Äù com as quais o desenvolvimento de idiomas mudaria de uma vez por todas. <br><br>  Hoje, quero falar sobre uma das √∫ltimas etapas deste processo em andamento.  A tecnologia de que estamos falando ainda est√° sendo explorada ativamente, mas tudo indica que em breve se enraizar√° nos principais idiomas.  E nossa hist√≥ria come√ßa com um dos conceitos mais fundamentais em ci√™ncia da computa√ß√£o: com <b>tipos</b> . <br><br><h2>  Mundo dos tipos </h2><br>  Digitar √© uma daquelas coisas t√£o insepar√°veis ‚Äã‚Äãdo nosso pensamento que quase nem pensamos no conceito de tipos como tal?  Por que 1 √© um <code>int</code> , mas se voc√™ apenas colocar esse valor entre aspas - e ele se transformar em uma <code>string</code> ?  O que √© um "tipo" em ess√™ncia?  Como costuma acontecer na programa√ß√£o, a resposta depende da reda√ß√£o da pergunta. <br><br>  Os tipos s√£o diversos.  Em alguns sistemas de tipos, existem limites muito claros entre tipos e valores.  Portanto, 3, 2 e 1 s√£o valores <code>integer</code> , mas <code>integer</code> n√£o √© um valor.  Esse construto √© "incorporado" na linguagem e fundamentalmente diferente do significado.  Mas, de fato, essa diferen√ßa n√£o √© necess√°ria e pode apenas nos limitar. <br><br>  Se voc√™ liberar os tipos e transform√°-los em outra categoria de valores, v√°rias possibilidades surpreendentes se abrir√£o.  Os valores podem ser armazenados, convertidos e passados ‚Äã‚Äãpara fun√ß√µes.  Assim, seria poss√≠vel criar uma fun√ß√£o que toma um tipo como par√¢metro, criando fun√ß√µes generalizadas: aquelas que podem trabalhar com muitos tipos sem sobrecargas.  Voc√™ pode ter uma matriz de valores de um determinado tipo, em vez de fazer aritm√©tica e tipografia de ponteiros estranhos, como √© necess√°rio em C. Voc√™ tamb√©m pode coletar novos tipos √† medida que o programa √© executado e fornecer recursos como desserializa√ß√£o autom√°tica de JSON.  Mas, mesmo se voc√™ tratar os tipos como valores, ainda n√£o poder√° fazer tudo o que os tipos podem fazer com valores.  Portanto, operando com inst√¢ncias de usu√°rio, voc√™ pode, por exemplo, comparar seus nomes, verificar sua idade ou identificador etc. <br><br><pre> <code class="plaintext hljs">if user.name == "Marin" &amp;&amp; user.age &lt; 65 { print("You can't retire yet!") }</code> </pre> <br>  No entanto, quando voc√™ tenta fazer o mesmo com o tipo de <code>User</code> , voc√™ pode comparar apenas nomes de tipos e possivelmente nomes de propriedades.  Como esse √© um tipo, n√£o uma inst√¢ncia, voc√™ n√£o pode verificar os valores de suas propriedades. <br><br><pre> <code class="plaintext hljs">if typeof(user) == User { print("Well, it's a user. That's all I know") }</code> </pre> <br>  Qu√£o legal seria se tiv√©ssemos uma fun√ß√£o capaz de receber apenas uma lista n√£o vazia de usu√°rios?  Ou uma fun√ß√£o que aceitaria um endere√ßo de email apenas se ele estivesse gravado no formato correto?  Para esses fins, voc√™ precisaria dos tipos "matriz n√£o vazia" ou "endere√ßo de email".  Nesse caso, √© um tipo dependente de valor, ou seja,  sobre o <b>tipo dependente</b> .  Nos idiomas comuns, isso n√£o √© poss√≠vel. <br><br>  Para que tipos possam ser usados, o compilador deve verific√°-los.  Se voc√™ afirmar que a vari√°vel cont√©m um n√∫mero inteiro, seria melhor se n√£o houvesse uma <code>string</code> , caso contr√°rio, o compilador jurar√°.  Em princ√≠pio, isso √© bom, porque n√£o nos permite cortejar.  A verifica√ß√£o de tipos √© bastante simples: se uma fun√ß√£o retorna um <code>integer</code> e tentamos retornar <code>"Marin"</code> nela, isso √© um erro. <br><br>  No entanto, com tipos dependentes, as coisas ficam mais complicadas.  O problema √© quando exatamente o compilador verifica os tipos.  Como ele pode ter certeza de que existem exatamente tr√™s valores na matriz, se o programa ainda nem est√° em execu√ß√£o?  Como garantir que um n√∫mero inteiro seja maior que 3, se ainda nem foi atribu√≠do?  H√° <i>m√°gica</i> nisso ... ou, em outras palavras, <i>matem√°tica</i> .  Se for poss√≠vel provar matematicamente que o conjunto de n√∫meros √© sempre maior que 3, o compilador pode verificar isso. <br><br><h2>  Matem√°tica no est√∫dio! </h2><br>  <b>A indu√ß√£o matem√°tica</b> √© usada para formular evid√™ncias.  A indu√ß√£o permite confirmar incondicionalmente a verdade de uma afirma√ß√£o.  Por exemplo, queremos provar que a seguinte f√≥rmula matem√°tica vale para qualquer n√∫mero positivo: <br><br><pre> <code class="plaintext hljs">1 + 2 + 3 + ... + x = x * (x + 1) / 2</code> </pre> <br>  H√° um n√∫mero infinito de poss√≠veis x, por isso levaria muito tempo para verificar todos os n√∫meros manualmente.  Felizmente, isso n√£o √© necess√°rio.  S√≥ precisamos provar duas coisas: <br><br><ol><li>  Esta afirma√ß√£o √© observada no primeiro dia.  (Geralmente √© 0 ou 1) </li><li>  Se esta afirma√ß√£o for verdadeira para o n√∫mero <code>n</code> , ser√° verdadeira para o pr√≥ximo n√∫mero <code>n + 1</code> </li></ol><br>  Como a instru√ß√£o √© observada para o primeiro n√∫mero e para todos os n√∫meros a seguir, sabemos que √© verdadeira para todos os n√∫meros poss√≠veis. <br><br>  Para provar isso n√£o √© dif√≠cil: <br><br><pre> <code class="plaintext hljs">1 = 1 * (1 + 1) / 2 1 = 1</code> </pre> <br>  Agora tamb√©m temos que provar que a afirma√ß√£o vale para todos os outros n√∫meros.  Para fazer isso, suponha que funcione para algum n√∫mero n e verifique se tamb√©m funciona para n + 1. <br><br>  Supondo que a seguinte express√£o seja verdadeira: <br><br><pre> <code class="plaintext hljs">1 + 2 + 3 + ... + n = n * (n + 1) / 2</code> </pre> <br>  Confira <code>n + 1</code> : <br><br><pre> <code class="plaintext hljs">(1 + 2 + 3 + ... + n) + (n + 1) = (n + 1) * ((n + 1) + 1) / 2</code> </pre> <br>  Assim, podemos substituir <code>"(1 + 2 + 3 + ... + n)"</code> igualdade acima: <br><br><pre> <code class="plaintext hljs">(n * (n + 1) / 2) + (n + 1) = (n + 1) * ((n + 2) / 2)</code> </pre> <br>  e simplifique para <br><br><pre> <code class="plaintext hljs">(n + 1) * (n/2 + 1) = (n + 1) * (n/2 + 1)</code> </pre> <br>  Como as duas partes da express√£o s√£o iguais, garantimos que essa afirma√ß√£o seja verdadeira.  Essa √© uma das maneiras pelas quais voc√™ pode verificar a verdade das declara√ß√µes sem calcular manualmente cada caso, e √© com base nesse princ√≠pio que os tipos dependentes funcionam.  Voc√™ escreve uma declara√ß√£o matem√°tica para garantir que a tese do tipo seja verdadeira. <br><br>  A beleza dessa abordagem reside no fato de que qualquer prova matem√°tica pode ser emitida na forma de um programa de computador - e √© disso que precisamos! <br><br><h2>  Voltar √† programa√ß√£o </h2><br>  Ent√£o, descobrimos que algumas coisas podem ser provadas primeiro e depois passar para valores espec√≠ficos.  Para fazer isso em uma linguagem de programa√ß√£o, voc√™ precisa de uma maneira de expressar essas instru√ß√µes no c√≥digo que ser√° gravado no pr√≥prio sistema de tipos, ou seja, o sistema de tipos precisa ser aprimorado. <br><br>  Considere um exemplo.  Aqui temos uma fun√ß√£o de acr√©scimo que pega duas matrizes e as combina.  Como regra, a assinatura de uma fun√ß√£o ser√° semelhante a esta: <br><br><pre> <code class="plaintext hljs">append: (arr1: Array, arr2: Array) -&gt; Array</code> </pre> <br>  No entanto, apenas olhando a assinatura, n√£o podemos ter certeza da implementa√ß√£o correta.  O fato de a fun√ß√£o retornar uma matriz n√£o significa que ela fez alguma coisa.  Uma maneira de verificar o resultado √© garantir que o comprimento da matriz resultante seja igual √† soma dos comprimentos das matrizes de par√¢metros. <br><br><pre> <code class="plaintext hljs">newArray = append([1], [2, 3]) assert(length(newArray) == 3)</code> </pre> <br>  Mas por que verificar isso em tempo de execu√ß√£o, se voc√™ pode criar uma restri√ß√£o que ser√° verificada em tempo de compila√ß√£o: <br><br><pre> <code class="plaintext hljs">append: (arr1: Array, arr2: Array) -&gt; newArray: Array where length(newArray) == length(arr1) + length(arr2)</code> </pre> <br>  Declaramos que <code>append</code> √© uma fun√ß√£o que recebe dois argumentos de <code>Array</code> e retorna um novo argumento de <code>Array</code> , que chamamos de <code>newArray</code> .  S√≥ que desta vez adicionamos uma ressalva de que o comprimento da nova matriz deve ser igual √† soma dos comprimentos de todos os argumentos da fun√ß√£o.  A declara√ß√£o que t√≠nhamos acima no tempo de execu√ß√£o √© convertida para o tipo em tempo de compila√ß√£o. <br><br>  O c√≥digo acima refere-se ao mundo dos tipos, n√£o dos valores, ou seja, o sinal <code>==</code> indica uma compara√ß√£o do <code>length</code> tipo retornado, e n√£o do seu valor.  Para que esse mecanismo funcione, o comprimento do tipo retornado deve nos fornecer algumas informa√ß√µes sobre o n√∫mero real. <br><br>  Para garantir a opera√ß√£o de um mecanismo desse tipo, voc√™ precisa garantir que cada n√∫mero seja de um tipo separado.  Um tipo pode conter apenas um valor: 1. O mesmo se aplica a Dois, Tr√™s e todos os outros n√∫meros.  Naturalmente, esse trabalho √© muito cansativo, mas √© para esse trabalho que temos programa√ß√£o.  Voc√™ pode escrever um compilador que far√° isso por n√≥s. <br><br>  Feito isso, √© poss√≠vel criar tipos separados para matrizes contendo 1, 2, 3 e um n√∫mero diferente de elementos.  <code>ArrayOfOne</code> , <code>ArrayOfTwo</code> , etc. <br><br>  Assim, √© poss√≠vel definir um comprimento de fun√ß√£o que ter√° um dos tipos de matriz acima e tenha um tipo de retorno dependente de <code>One</code> for <code>ArrayOfOne</code> , <code>Two</code> for <code>ArrayOfTwo</code> , etc.  para cada n√∫mero. <br><br>  Agora que temos um tipo separado para qualquer comprimento espec√≠fico da matriz, podemos verificar (em tempo de compila√ß√£o) que ambas as matrizes t√™m o mesmo comprimento.  Para fazer isso, compare seus tipos.  E como os tipos t√™m os mesmos valores que qualquer outro, voc√™ pode atribuir opera√ß√µes a eles.  Voc√™ pode determinar a adi√ß√£o de dois tipos espec√≠ficos, especificando que a soma de <code>ArrayOfOne</code> e <code>ArrayOfTwo</code> √© igual a <code>ArrayOfThree</code> . <br><br>  Essas s√£o todas as informa√ß√µes que o compilador precisa para garantir que o c√≥digo que voc√™ escreveu esteja correto. <br><br>  Suponha que desejemos criar uma vari√°vel do tipo <code>ArrayOfThree</code> : <br><br><pre> <code class="plaintext hljs">result: ArrayOfThree = append([1], [2, 3])</code> </pre> <br>  O compilador pode determinar que [1] possui apenas um valor, para que voc√™ possa atribuir o tipo <code>ArrayOfOne</code> .  Tamb√©m pode atribuir <code>ArrayOfTwo</code> a [2, 3]. <br><br>  O compilador sabe que o tipo de resultado deve ser igual √† soma dos tipos do primeiro e do segundo argumento.  Ele tamb√©m sabe que ArrayOfOne + ArrayOfTwo √© igual a ArrayOfThree, ou seja, ele sabe que toda a express√£o no lado direito da identidade √© do tipo ArrayOfThree.  Corresponde √† express√£o √† esquerda e o compilador est√° satisfeito. <br><br>  Se escrevemos o seguinte: <br><br><pre> <code class="plaintext hljs">result: ArrayOfTwo = append([1], [2, 3])</code> </pre> <br>  o compilador ficaria completamente insatisfeito, pois saberia que o tipo est√° incorreto. <br><br><h2>  Digitar dependente √© muito legal </h2><br>  Nesse caso, √© imposs√≠vel permitir um grande n√∫mero de erros.  Com a digita√ß√£o dependente, erros por unidade, acessos a √≠ndices de matriz inexistentes, exce√ß√µes de ponteiro nulo, loops infinitos e c√≥digo quebrado podem ser evitados. <br><br>  Usando tipos dependentes, voc√™ pode expressar quase tudo.  A fun√ß√£o fatorial aceita apenas n√∫meros naturais, a fun√ß√£o de <code>login</code> n√£o aceita linhas vazias, a fun√ß√£o <code>removeLast</code> aceita apenas matrizes n√£o vazias.  Al√©m disso, tudo isso √© verificado antes de voc√™ iniciar o programa. <br><br>  O problema com as verifica√ß√µes de tempo de execu√ß√£o √© que elas falham se o programa j√° estiver em execu√ß√£o.  Isso √© normal se o programa for executado apenas por voc√™, mas n√£o pelo usu√°rio.  Os tipos dependentes permitem que voc√™ leve essas verifica√ß√µes ao n√≠vel dos tipos, portanto, falhas desse tipo durante a execu√ß√£o do programa se tornam imposs√≠veis. <br><br>  Acho que a digita√ß√£o dependente √© o futuro das linguagens de programa√ß√£o convencionais, e mal posso esperar para esperar por isso! <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Idris</a> <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">F *</a> <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Adicionando tipos dependentes ao JavaScript</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt432416/">https://habr.com/ru/post/pt432416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt432404/index.html">O backup para Linux n√£o escreve letras</a></li>
<li><a href="../pt432408/index.html">Resumo da Fintech: prepara√ß√£o para desconectar pequenos bancos da Visa e Mastercard, uma calculadora de pens√µes e n√£o apenas</a></li>
<li><a href="../pt432410/index.html">Entidades no estilo DDD com Entity Framework Core</a></li>
<li><a href="../pt432412/index.html">Highload ++: Como ajudar o sistema ERP a lidar com 500.000 solicita√ß√µes por segundo</a></li>
<li><a href="../pt432414/index.html">Segredos antigos para depura√ß√£o r√°pida: Animando c√≥digo fonte</a></li>
<li><a href="../pt432418/index.html">Analisando Express√µes Lambda em Java</a></li>
<li><a href="../pt432420/index.html">Introdu√ß√£o ao Git Merge e Git Rebase: Por que e quando us√°-los</a></li>
<li><a href="../pt432422/index.html">Modo offline no iOS e recursos de sua implementa√ß√£o no Realm</a></li>
<li><a href="../pt432424/index.html">Infraestrutura certificada HyperFlex para SAP HANA</a></li>
<li><a href="../pt432426/index.html">Depurando um bug que n√£o √© reproduzido</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>