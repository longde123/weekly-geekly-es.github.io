<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÑ üì¥ üßùüèª Dagaz: Um novo come√ßo üëáüèΩ üë∫ üí±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Corre para o sul e circula para o norte, circulando, circulando para correr com o vento 
 E de acordo com seus circuitos, o vento retorna; 
 Todos os ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dagaz: Um novo come√ßo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481868/"><img align="left" src="https://habrastorage.org/webt/4i/sc/k4/4isck4toxbws20hsk3nrqghdkoy.png">  <b><i>Corre para o sul e circula para o norte, circulando, circulando para correr com o vento</i></b> <b><i><br></i></b>  <b><i>E de acordo com seus circuitos, o vento retorna;</i></b> <b><i><br></i></b>  <b><i>Todos os rios correm para o mar - e o mar n√£o transborda,</i></b> <b><i><br></i></b>  <b><i>Para o lugar onde os rios correm, - L√° eles continuam correndo;</i></b> <b><i><br><br></i></b>  <b><i><a href="https://www.biblegateway.com/passage/%3Fsearch%3DEcclesiastes%2B1" rel="nofollow">O livro de Eclesiastes</a></i></b> <br><br>  Em 1998, foi desenvolvida uma aplica√ß√£o completamente √∫nica, para a √©poca, que permite reduzir o processo de desenvolvimento de um jogo de tabuleiro abstrato (ou quebra-cabe√ßa) para uma linguagem de descri√ß√£o de texto pequena, que lembra vagamente o <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)" rel="nofollow">Lisp</a> .  Este projeto foi chamado de <a href="http://www.zillions-of-games.com/" rel="nofollow">Zilh√µes de Jogos</a> .  Isso criou um furor entre os f√£s de jogos de tabuleiro.  Atualmente, mais de 2.000 aplicativos foram criados usando essa tecnologia. <br><a name="habracut"></a><br>  Logo ficou claro que o ZoG tem muitas desvantagens.  Eu j√° <a href="https://habr.com/ru/post/221779/">escrevi</a> sobre isso em Habr e n√£o vou me repetir.  Permitam-me apenas dizer que os desenvolvedores n√£o levaram em conta os recursos de um grande n√∫mero de jogos existentes e algumas op√ß√µes importantes foram codificadas, de modo que suas altera√ß√µes se tornaram extremamente problem√°ticas.  Greg Schmidt, em 2007, tentou corrigir a situa√ß√£o lan√ßando o <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1452" rel="nofollow">Axiom Development Kit</a> , mas sua forte integra√ß√£o com o ZoG n√£o permite resolver todos os problemas. <br><br>  O Projeto <a href="http://cambolbro.com/cv/publications/ciaig-browne-maire-19.pdf" rel="nofollow">Ludi</a> apontou novas fronteiras, usando o ‚Äúmecanismo‚Äù universal de jogos e <a href="https://en.wikipedia.org/wiki/Genetic_algorithm" rel="nofollow">algoritmos gen√©ticos</a> para automatizar o processo de desenvolvimento de novos jogos de tabuleiro.  Infelizmente, essa abordagem foi inicialmente vista como uma simplifica√ß√£o deliberada da mec√¢nica do jogo e do n√≠vel da IA ‚Äã‚Äãempregada.  A discuss√£o dos objetivos deste projeto est√° al√©m do escopo deste artigo, mas algumas de suas solu√ß√µes t√©cnicas, sem d√∫vida, serviram como ponto de partida para meu pr√≥prio desenvolvimento. <br><br>  Meu objetivo √© o desenvolvimento de um "mecanismo" mais vers√°til e f√°cil de usar para a cria√ß√£o de jogos de tabuleiro abstratos.  Por quase um ano, estudei a possibilidade do ZoG e do Axiom e aprendi bastante sobre suas limita√ß√µes.  Penso que posso resolver os problemas criando uma solu√ß√£o mais universal e multiplataforma.  Sobre o andamento dos trabalhos deste projeto, apresentarei um relat√≥rio. <br><br><h2>  Abertura e modularidade </h2><br>  Talvez a principal desvantagem do ZoG seja o seu fechamento.  O produto foi montado "de uma vez para sempre" em uma √∫nica plataforma - Windows.  Se fosse c√≥digo de c√≥digo aberto, poderia-se tentar port√°-lo no Linux, Android, iOS ... Outro problema √© o seu monol√≠tico. <br><br>  No ZoG, h√° o in√≠cio da modularidade, permitindo a conex√£o com a DLL dos jogos, incluindo implementa√ß√µes personalizadas da IA.  O Axiom vai um pouco mais longe, permitindo que voc√™ execute aplicativos no modo de reprodu√ß√£o autom√°tica, sem usar o kernel ZoG.  N√£o obstante a s√©ria limita√ß√£o desta solu√ß√£o (suportando aplicativos apenas para dois players), este exemplo demonstra como a modularidade seria √∫til!  A oportunidade de organizar um jogo com dois bots (usando diferentes configura√ß√µes de IA) e coletar estat√≠sticas sobre um grande n√∫mero de jogos n√£o pode ser superestimada.  Mas qu√£o melhor seria se o produto fosse totalmente modular! <br><br><ul><li>  Mover m√≥dulo de gera√ß√£o </li><li>  Mover m√≥dulo de execu√ß√£o </li><li>  M√≥dulo de controle </li><li>  M√≥dulo AI </li><li>  M√≥dulo de visualiza√ß√£o </li></ul><br>  Todo o trabalho que descreve os jogos deve ser realizado pelo m√≥dulo de gera√ß√£o de movimento.  Este √© o "cora√ß√£o" do projeto.  A transfer√™ncia de todas as tarefas n√£o conectadas a esta fun√ß√£o para outros m√≥dulos tornar√° a tarefa mais simples poss√≠vel.  Voc√™ pode melhorar este m√≥dulo, sem examinar os problemas de IA e a intera√ß√£o do usu√°rio.  Voc√™ pode alterar completamente o formato da descri√ß√£o dos jogos ou adicionar suporte para as descri√ß√µes no formato ZoG, Axiom e Ludi.  A modularidade √© a base da flexibilidade da solu√ß√£o! <br><br>  O m√≥dulo de execu√ß√£o de movimenta√ß√£o √© o guardi√£o do estado do jogo.  As informa√ß√µes sobre o estado atual do jogo s√£o transferidas para todos os outros m√≥dulos sob demanda.  Pelas raz√µes que apresentarei abaixo, o progresso da execu√ß√£o deve passar pelo m√≥dulo de gera√ß√£o, cuja tarefa √© a forma√ß√£o de um comando em termos de execu√ß√£o do m√≥dulo.  Al√©m disso, a tarefa do m√≥dulo de gera√ß√£o de movimento √© a configura√ß√£o principal do espa√ßo do jogo, com base na descri√ß√£o do jogo. <br><br>  O m√≥dulo de controle √©, de fato, o pr√≥prio aplicativo.  Ele solicita ao m√≥dulo de gera√ß√£o de movimentos uma lista de movimentos poss√≠veis e altera o estado do jogo, passando o movimento selecionado para o m√≥dulo de execu√ß√£o de movimentos.  O m√≥dulo de controle pode ser conectado para reproduzir um ou mais bots de IA.  Quantas voc√™ precisar (e possivelmente diferente)!  O tipo de unidade de controle √© determinado pela divis√£o de tarefas.  Pode ser uma reprodu√ß√£o autom√°tica para coletar estat√≠sticas de jogos, servidor de jogos (ele pode controlar v√°rias lojas de estado, liderando um grande n√∫mero de sess√µes de jogos) ou aplicativos individuais para jogar offline. <br><br>  A capacidade de conectar diferentes implementa√ß√µes de IA melhorar√° a qualidade do jogo.  Entende-se que os m√≥dulos para o jogo de xadrez e Go devem usar abordagens diferentes.  Jogos com informa√ß√µes incompletas e jogos usando dados aleat√≥rios tamb√©m exigem uma abordagem individual.  A implementa√ß√£o universal da IA ‚Äã‚Äãser√° igualmente ruim em todos os jogos!  A conex√£o modular AI permitir√° comparar a "for√ßa" dos algoritmos, incluindo um modo de jogo "entre si". Como a arquitetura da AI √© separada do estado de armazenamento do jogo, uma inst√¢ncia do bot de jogo pode suportar um n√∫mero ilimitado de sess√µes de jogos simultaneamente. <br><br>  A visualiza√ß√£o do processo do jogo tamb√©m pode variar.  A primeira coisa que vem √† mente s√£o implementa√ß√µes 2D e 3D.  A plataforma para a qual o aplicativo est√° sendo desenvolvido tamb√©m √© importante.  Menos √≥bvio √© que a visualiza√ß√£o pode ser uma parte importante do jogo!  Por exemplo, no jogo <a href="https://glukkazan.github.io/elimination/surakarta.htm" rel="nofollow">Surakarta</a> , pegar pe√ßas ser√° completamente n√£o √≥bvio na aus√™ncia de anima√ß√£o adequada dos movimentos. <br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/elimination/surakarta.htm" rel="nofollow"><img src="https://habrastorage.org/files/9ad/1cd/c7c/9ad1cdc7c76041dc8776c5f4cb1a086a.jpg"></a> </div><br>  Em geral, a modularidade parece uma boa id√©ia para esse projeto, e o c√≥digo-fonte aberto permitir√° a todos que desejam participar do projeto.  No momento, n√£o me proponho fins comerciais, mas acho que, se desejado, encontrarei uma maneira de ganhar dinheiro sem fechar o c√≥digo-fonte. <br><br><h2>  O espa√ßo do jogo </h2><br>  Antes de iniciar o show, voc√™ precisa definir o cen√°rio.  O tabuleiro n√£o √© apenas um lugar onde as pe√ßas s√£o organizadas.  Al√©m disso, a dire√ß√£o do movimento das pe√ßas pode ser determinada (de fato, as conex√µes entre as posi√ß√µes do tabuleiro) √°reas de jogo (por exemplo, √°reas de convers√£o de pe√ßas) campos proibidos, etc.  Aqui est√° como a defini√ß√£o do tabuleiro de xadrez se parece na implementa√ß√£o do ZoG: <br><br><div class="spoiler">  <b class="spoiler_title">Definindo o quadro no ZoG</b> <div class="spoiler_text"><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> Board-Definitions (<span class="hljs-name"><span class="hljs-name">image</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\Chess8x8.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\Chess8x8.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">grid</span></span> (<span class="hljs-name"><span class="hljs-name">start-rectangle</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">53</span></span> <span class="hljs-number"><span class="hljs-number">53</span></span>) (<span class="hljs-name"><span class="hljs-name">dimensions</span></span> (<span class="hljs-string"><span class="hljs-string">"a/b/c/d/e/f/g/h"</span></span> (<span class="hljs-number"><span class="hljs-number">49</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-comment"><span class="hljs-comment">; files ("8/7/6/5/4/3/2/1" (0 49)) ; ranks ) (directions (n 0 -1) (e 1 0) (s 0 1) (w -1 0) (ne 1 -1) (nw -1 -1) (se 1 1) (sw -1 1) ) ) (symmetry Black (ns)(sn) (nw sw)(sw nw) (ne se)(se ne)) (zone (name promotion-zone) (players White) (positions a8 b8 c8 d8 e8 f8 g8 h8) ) (zone (name promotion-zone) (players Black) (positions a1 b1 c1 d1 e1 f1 g1 h1) ) (zone (name third-rank) (players White) (positions a3 b3 c3 d3 e3 f3 g3 h3) ) (zone (name third-rank) (players Black) (positions a6 b6 c6 d6 e6 f6 g6 h6) ) )</span></span></code> </pre> </div></div><br>  Voc√™ pode perceber que, al√©m das configura√ß√µes do jogo, aqui est√£o as configura√ß√µes associadas √† visualiza√ß√£o.  Estou firmemente convencido de que essas configura√ß√µes n√£o pertencem aqui.  Na implementa√ß√£o de um m√≥dulo de visualiza√ß√£o, v√°rias configura√ß√µes podem ser usadas e diferentes configura√ß√µes podem ser necess√°rias.  Al√©m disso, jogos de simula√ß√£o podem funcionar sem qualquer m√≥dulo de visualiza√ß√£o (como a reprodu√ß√£o autom√°tica no Axiom).  De fato, como o Axiom √© usado para visualizar o ZoG, a defini√ß√£o n√£o cont√©m nada de sup√©rfluo: <br><br><div class="spoiler">  <b class="spoiler_title">Definindo o quadro no Axiom</b> <div class="spoiler_text"><pre> <code class="perl hljs">{board <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-string"><span class="hljs-string">{grid}</span></span> board} {directions -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> n <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">s</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> e <span class="hljs-number"><span class="hljs-number">0</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> w -<span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> nw <span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> sw -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> se directions} {symmetries Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> ns Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> nw sw Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> se symmetries}</code> </pre></div></div><br>  Infelizmente, o Axiom tamb√©m n√£o tem como determinar as zonas de jogo (o local das zonas de jogo deve ser determinado manualmente no c√≥digo).  Esta n√£o √© a √∫nica simplifica√ß√£o do Axiom.  A defini√ß√£o do quadro neste projeto n√£o pode conter mais de uma grade e essa grade deve ser bidimensional.  A placa, assim definida, √© uma matriz unidimensional, mas para a conveni√™ncia do programador, sin√¥nimos s√£o definidos para cada um dos espa√ßos da seguinte maneira: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4d2/76d/a04/4d276da04e6542a385c3c30deeb6872f.PNG"></div><br>  Comparadas com o esquema mais flex√≠vel de defini√ß√£o de grade no ZoG, essas restri√ß√µes s√£o bastante desconfort√°veis ‚Äã‚Äã(especialmente devido ao fato de o esquema de nomea√ß√£o imposto ter usado esses campos para o pr√≥prio objetivo de visualiza√ß√£o).  Felizmente, √© poss√≠vel definir um quadro de forma arbitr√°ria.  Tanto o Axiom quanto o ZoG oferecem uma oportunidade para identificar elementos em cada posi√ß√£o no quadro, al√©m da capacidade de determinar os v√≠nculos entre pares arbitr√°rios de posi√ß√µes.  Usando essa abordagem, podemos definir uma placa de qualquer topologia.  Sua √∫nica desvantagem √© a extrema verbosidade e complexidade da descri√ß√£o. <br><br>  Al√©m da localiza√ß√£o das pe√ßas no tabuleiro e na reserva, o sistema deve ter a capacidade de armazenar atributos para pe√ßas individuais e para os espa√ßos no tabuleiro.  Um bom exemplo da necessidade de usar os atributos de uma regra de " <a href="https://en.wikipedia.org/wiki/Castling" rel="nofollow">rolar</a> " no <a href="https://en.wikipedia.org/wiki/Chess" rel="nofollow">xadrez</a> .  √â uma jogada dif√≠cil, que inclui o movimento simult√¢neo do rei e uma torre permitida, desde que nenhuma dessas pe√ßas tenha se movido antes de executar essa jogada.  Um atributo pode ser usado para armazenar uma tag booleana mostrando se a pe√ßa j√° foi movida.  Os atributos do campo tamb√©m podem encontrar algumas aplica√ß√µes interessantes. <br><br>  Deve-se notar que os atributos n√£o s√£o apenas vari√°veis, mas parte do estado do jogo.  Um valor de atributo pode ser alterado pela execu√ß√£o de um turno (inclusive pelo m√≥dulo AI) e deve estar dispon√≠vel para todos os turnos subsequentes, mas n√£o para turnos realizados em outro ramo do jogo.  Atualmente, o ZoG suporta o armazenamento de atributos booleanos de pe√ßas.  Os atributos de armazenamento do axioma n√£o s√£o suportados, mas voc√™ pode adicionar √† defini√ß√£o do quadro uma descri√ß√£o das vari√°veis ‚Äã‚Äãe matrizes.  Essas vari√°veis ‚Äã‚Äãpodem ser usadas, como contadores da quantidade de pe√ßas capturadas: <br><br><pre> <code class="perl hljs">{board <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> <span class="hljs-string"><span class="hljs-string">{grid}</span></span> <span class="hljs-string"><span class="hljs-string">{variable}</span></span> WhitePieces <span class="hljs-string"><span class="hljs-string">{variable}</span></span> BlackPieces board}</code> </pre> <br>  Outra limita√ß√£o do ZoG e do Axiom √© a regra de que cada posi√ß√£o do conselho n√£o pode conter mais do que uma pe√ßa.  Se qualquer pe√ßa concluir um movimento para uma posi√ß√£o ocupada por outra pe√ßa, a pe√ßa que anteriormente ocupava a posi√ß√£o √© automaticamente considerada como "comida".  Essa regra vai bem com o princ√≠pio do "xadrez" de pegar pe√ßas e serve para simplificar a descri√ß√£o desse jogo, mas complica a implementa√ß√£o de jogos como " <a href="http://www.iggamecenter.com/info/en/bashni.html" rel="nofollow">bashni checkers</a> " e " <a href="http://www.iggamecenter.com/info/en/tavreli.html" rel="nofollow">tavreli</a> ". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/455/804/146/45580414699f406281745176b1d91d9b.JPG"></div><br><br>  Nestes jogos, as pe√ßas podem ser organizadas em "colunas".  Essa "coluna" pode ser movida todos juntos, como uma √∫nica pe√ßa.  Ap√≥s algumas reflex√µes, decidi que era melhor n√£o abandonar a implementa√ß√£o autom√°tica da captura ‚ÄúXadrez‚Äù, mas melhorar os mecanismos de movimenta√ß√£o de grupos de pe√ßas.  De fato, para a implementa√ß√£o dos ‚Äúpilares‚Äù, voc√™ sempre pode adicionar para abordar outra dimens√£o (isso √© especialmente f√°cil, desde que o m√≥dulo de visualiza√ß√£o esteja separado do m√≥dulo de gera√ß√£o de movimento e da IA, voc√™ pode usar qualquer l√≥gica que seja para renderizar a placa tridimensional em sua visualiza√ß√£o bidimensional).  Um argumento adicional a favor dessa decis√£o foi que o movimento de pe√ßas ‚Äúcom muita pilha‚Äù n√£o √© o √∫nico tipo de viagem em grupo.  Por exemplo, no cart√£o ‚Äú <a href="https://s3-eu-west-1.amazonaws.com/mosigra.product.other/522/067/pentago.pdf" rel="nofollow">Pentago</a> ‚Äù, os fragmentos podem ser girados juntos com as pe√ßas montadas no mesmo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3f9/8db/7ba/3f98db7ba32042ec8dff2eb42878fa2e.jpg"></div><br>  Resumindo, posso dizer que, para minha estrutura de jogos, decidi pegar o melhor que foi pensado em ZoG, Axiom e Ludi, e acrescentar o que, na minha opini√£o, n√£o tiver. <br><br><h2>  Mover gera√ß√£o </h2><br>  A gera√ß√£o de movimento √© semelhante √† programa√ß√£o <a href="https://en.wikipedia.org/wiki/Nondeterministic_programming" rel="nofollow">n√£o determin√≠stica</a> .  A tarefa do gerador de movimentos √© fornecer, mediante solicita√ß√£o, uma lista de todos os movimentos poss√≠veis da posi√ß√£o atual.  Qual movimento dessa lista ser√° selecionado por um jogador ou a IA n√£o √© sua fun√ß√£o.  Vamos ver como a gera√ß√£o de movimentos √© feita no ZoG.  Como exemplo, usamos a macro de gera√ß√£o de movimento para uma pe√ßa de longo alcance (uma rainha ou bispo).  √â assim que √© usado na determina√ß√£o de movimentos para essas pe√ßas: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Bishop) (<span class="hljs-name"><span class="hljs-name">image</span></span> White <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\wbishop.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\wbishop.bmp"</span></span> Black <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\bbishop.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\bbishop.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">slide</span></span> ne) (<span class="hljs-name"><span class="hljs-name">slide</span></span> nw) (<span class="hljs-name"><span class="hljs-name">slide</span></span> se) (<span class="hljs-name"><span class="hljs-name">slide</span></span> sw) ) )</code> </pre> <br>  Como par√¢metro, uma macro √© passada na dire√ß√£o do movimento no quadro.  Se voc√™ n√£o considerar a possibilidade de instalar novas pe√ßas no quadro, a gera√ß√£o de uma mudan√ßa parecer√° simples.  Para cada uma das pe√ßas no tabuleiro, todos os movimentos poss√≠veis de acordo com as regras s√£o calculados.  Ent√£o a m√°gica come√ßa ... <br><br>  Cada uma das defini√ß√µes pode adicionar √† lista uma s√©rie de movimentos poss√≠veis!  A adi√ß√£o de uma jogada √† lista √© feita com o comando add (ao mesmo tempo, posicionando cada pe√ßa em movimento no quadro).  Eu j√° <a href="https://habr.com/ru/post/221779/">escrevi</a> sobre como essa solu√ß√£o arquitet√¥nica √© extremamente ruim.  O comando para a forma√ß√£o do movimento deve ser separado dos comandos que manipulam as pe√ßas (como foi feito no Axiom).  Vamos ver como a macro funciona: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> slide ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? add $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-friend?) add ))</code> </pre> <br><br>  Primeiro, o deslocamento √© realizado por uma c√©lula, na dire√ß√£o especificada, depois, em um ciclo, o espa√ßo atingido √© verificado quanto √† aus√™ncia de pe√ßas, um movimento √© formado e o arranjo prossegue para outra c√©lula na mesma dire√ß√£o.  Se voc√™ parar por aqui, a pe√ßa pode "deslizar" pelas c√©lulas vazias, mas como voc√™ pode pegar as pe√ßas inimigas? <br><br>  Muito simples!  Depois de executar o comando check, a verifica√ß√£o de que o campo n√£o √© ocupado por uma pe√ßa amig√°vel, formamos outro comando add, concluindo a movimenta√ß√£o.  Se nesta c√©lula estiver localizada uma pe√ßa inimiga, ela ser√° capturada automaticamente (como em um espa√ßo do tabuleiro, ao mesmo tempo, voc√™ n√£o poder√° ter mais de uma pe√ßa).  Se a pe√ßa foi amig√°vel, o c√°lculo da movimenta√ß√£o ser√° interrompido com o comando verificar (a viola√ß√£o das condi√ß√µes especificadas neste comando termina imediatamente o c√°lculo da movimenta√ß√£o atual). <br><br>  No ZoG e no Axiom, √© poss√≠vel mover apenas as pr√≥prias pe√ßas (ou melhor, √© poss√≠vel mover as pe√ßas do oponente, mas somente se especificado no modo de c√°lculo de um movimento de uma das pe√ßas).  Considero isso uma restri√ß√£o extremamente inconveniente, porque existem muitos jogos em que voc√™ pode mover diretamente a pe√ßa do oponente (em " <a href="https://glukkazan.github.io/checkers/stavropol-checkers.htm" rel="nofollow">Stavropol Chequers</a> ", por exemplo).  Seria mais consistente executar o c√°lculo da movimenta√ß√£o de todas as pe√ßas, independentemente de sua afilia√ß√£o.  Na macro que determina a movimenta√ß√£o, seria necess√°rio adicionar apenas uma verifica√ß√£o para permitir mover apenas as pr√≥prias pe√ßas: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> slide ( (<span class="hljs-name"><span class="hljs-name">verify</span></span> friend?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? add $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-friend?) add ))</code> </pre> <br><br>  Importante √© a capacidade de executar um movimento que consiste em v√°rios movimentos "parciais".  Nas implementa√ß√µes de rascunhos, essa capacidade √© usada para realizar capturas em "cadeia": <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> checker-jump ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">not-in-zone</span></span>? promotion-zone) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) else (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> King jumptype) ) ) )</code> </pre> <br><br>  O comando de movimenta√ß√£o parcial √© formado com add-parcial (para este comando, assim como para o comando add, h√° uma varia√ß√£o da movimenta√ß√£o, com ‚Äútransforma√ß√£o‚Äù das pe√ßas).  Esse movimento √© sempre parte de um movimento maior e "composto".  Como regra, para movimentos subsequentes, √© definido um "modo", que a continua√ß√£o deve implementar.  Portanto, nas damas, uma captura pode continuar apenas com as seguintes capturas, mas n√£o com um movimento "suave" (sem captura). <br><br><div class="spoiler">  <b class="spoiler_title">Nota</b> <div class="spoiler_text">  No ZoG, a implementa√ß√£o de movimentos parciais √© ruim.  Tentar executar o comando adicionar parcial em um ciclo causa um erro.  Como resultado, a captura realizada por um rei verificador pode ser realizada apenas da seguinte maneira muito embara√ßosa: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump-1 ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump-2 ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) ) )</code> </pre> <br>  E assim por diante, at√© king-jump-7!  Deixe-me lembr√°-lo que, na maioria das variedades de damas com um rei de "longo alcance", o rei, ap√≥s cada captura, pode parar em qualquer espa√ßo de uma cadeia cont√≠nua de espa√ßos vazios ap√≥s a pe√ßa capturada.  Ali√°s, existe uma variante desse jogo em que a regra de captura da "cadeia" √© formulada de maneira diferente.  √â exatamente isso que eu gosto nas damas - todos podem encontrar uma variante do seu gosto. <br></div></div><br>  Esse sistema de descri√ß√£o das regras √© muito flex√≠vel, mas √†s vezes √© necess√°ria uma l√≥gica mais complexa.  Por exemplo, se a pe√ßa, durante o progresso "parcial", n√£o deve passar novamente por um campo atravessado anteriormente, √© l√≥gico usar as bandeiras associadas √†s posi√ß√µes no quadro.  Depois de visitar um espa√ßo, definimos uma bandeira, para que posteriormente n√£o volte a esse espa√ßo: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">not-position-flag</span></span>? my-flag)) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> my-flag true)</code> </pre> <br>  Al√©m de sinalizadores "posicionais", no ZoG voc√™ pode usar sinalizadores globais.  Esses recursos n√£o devem ser confundidos com os atributos das pe√ßas.  Ao contr√°rio do √∫ltimo, estes n√£o fazem parte do estado do jogo.  Infelizmente, os atributos de pe√ßas e sinalizadores no ZoG podem ser apenas booleanos (no Axiom, os atributos nem s√£o suportados).  Essa limita√ß√£o dificulta a execu√ß√£o de opera√ß√µes associadas aos v√°rios tipos de contagem.  Por exemplo, <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2233" rel="nofollow">neste</a> pequeno quebra-cabe√ßa, eu tive que usar para "contar" pe√ßas, presas em um "garfo", um par de bandeiras booleanas (o n√∫mero exato de que eu n√£o precisava, desde que as pe√ßas fossem mais de uma). <br><br>  Outra coisa a corrigir √© a falta de um "ciclo de vida" claro na execu√ß√£o da mudan√ßa.  Todos os sinalizadores s√£o redefinidos automaticamente antes de iniciar a movimenta√ß√£o, mas seria mais f√°cil identificar claramente a fase de inicializa√ß√£o.  Na minha opini√£o, no c√°lculo da mudan√ßa, devem ocorrer as seguintes fases: <br><br><ol><li>  Inicializa√ß√£o de vari√°veis ‚Äã‚Äãe verifica√ß√£o de pr√©-condi√ß√µes para a movimenta√ß√£o composta </li><li>  Inicializa√ß√£o de vari√°veis ‚Äã‚Äãe verifica√ß√£o de pr√©-condi√ß√µes para a movimenta√ß√£o parcial </li><li>  Gera√ß√£o do movimento parcial </li><li>  Verificando p√≥s-condi√ß√µes da movimenta√ß√£o parcial </li><li>  Gerando, concluindo e verificando p√≥s-condi√ß√µes da movimenta√ß√£o composta </li><li>  Verificando as condi√ß√µes de t√©rmino do jogo </li></ol><br>  O grupo de etapas do segundo ao quarto, no movimento composto completo, pode ser repetido v√°rias vezes.  A ideia de pr√© e p√≥s-condi√ß√µes, que chamo de invariantes, tirei do projeto Ludi.  Falo mais sobre o uso de invariantes posteriormente. <br><br><h2>  Sobre a import√¢ncia da nota√ß√£o </h2><br>  A gera√ß√£o de todos os movimentos poss√≠veis a partir da posi√ß√£o √© apenas metade da hist√≥ria.  Controlar o estado do jogo requer uma apresenta√ß√£o compacta dos movimentos gerados.  No ZoG, para esse fim, a nota√ß√£o ZSG √© usada.  Aqui est√° uma descri√ß√£o de um poss√≠vel in√≠cio de um jogo de xadrez desta forma: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. Pawn e2 - e4 <span class="hljs-number"><span class="hljs-number">1</span></span>. Pawn e7 - e5 <span class="hljs-number"><span class="hljs-number">2</span></span>. Knight g1 - f3 <span class="hljs-number"><span class="hljs-number">2</span></span>. Knight b8 - c6 <span class="hljs-number"><span class="hljs-number">3</span></span>. Bishop f1 - c4 <span class="hljs-number"><span class="hljs-number">3</span></span>. Knight g8 - f6 <span class="hljs-number"><span class="hljs-number">4</span></span>. King e1 - g1 Rook h1 - f1 @ f1 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> @ g1 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>. Pawn d7 - d5 <span class="hljs-number"><span class="hljs-number">5</span></span>. Pawn e4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 <span class="hljs-number"><span class="hljs-number">5</span></span>. Knight f6 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5</code> </pre> <br>  Este script √© pr√≥ximo √† <a href="https://en.wikipedia.org/wiki/Chess_notation" rel="nofollow">nota√ß√£o</a> usual de <a href="https://en.wikipedia.org/wiki/Chess_notation" rel="nofollow">xadrez</a> e geralmente amig√°vel ao usu√°rio.  Apenas o quarto movimento das brancas pode causar alguma confus√£o.  Assim, no ZSG, parece um <a href="https://en.wikipedia.org/wiki/Castling" rel="nofollow">roque</a> .  A parte da descri√ß√£o do movimento antes do caractere '@' √© bastante clara;  √© o movimento simult√¢neo da torre e do rei, mas o que se segue?  Assim, no ZSG, parece que √© necess√°rio redefinir os atributos das pe√ßas para evitar a possibilidade de repeti√ß√£o do enrolamento. <br><br><div class="spoiler">  <b class="spoiler_title">Nota</b> <div class="spoiler_text">  O ZoG usa sua nota√ß√£o ZSG particularmente para mostrar o curso do jogo de uma forma compreens√≠vel para o jogador.  √Ä direita do quadro, uma sub-janela "Moves List" pode ser aberta.  Esta lista pode ser usada para navegar pelo jogo gravado.  Esta lista n√£o √© muito conveniente, porque n√£o h√° suporte para uma visualiza√ß√£o em √°rvore ramificada de jogos alternativos.  A parte das voltas gravadas associadas √†s altera√ß√µes nos atributos das pe√ßas n√£o √© exibida ao usu√°rio. <br></div></div><br>  A grava√ß√£o de um movimento na nota√ß√£o ZSG deve conter informa√ß√µes completas suficientes para alterar corretamente o estado do jogo.  Se as informa√ß√µes sobre uma mudan√ßa de atributos forem perdidas, em um jogo de acordo com esse registro, uma jogada pode ser repetida incorretamente (por exemplo, o jogador teria a oportunidade de executar novamente o jogo).  Infelizmente, nas extens√µes DLL (como Axiom), informa√ß√µes estendidas n√£o podem ser transmitidas. <br><br>  Trabalhando com extens√µes DLL, o ZoG √© for√ßado a fazer uma manipula√ß√£o bastante esperta ao se posicionar em um movimento selecionado (por exemplo, quando voc√™ reverte um movimento).  A partir de [cada] posi√ß√£o anterior [trabalhando desde o in√≠cio do jogo], todos os movimentos poss√≠veis s√£o gerados e, nessa lista, √© preciso procurar um movimento com a representa√ß√£o ZSG [correspondente].  Os [efeitos colaterais de cada] movimento gerado s√£o aplicados a [cada sucessivo] jogo, pois √© poss√≠vel executar efeitos colaterais n√£o refletidos na representa√ß√£o ZSG do movimento. <br><br>  A situa√ß√£o √© agravada pelo fato de que a √∫nica maneira de chegar ao estado do jogo no momento de uma jogada no passado, √© a aplica√ß√£o consistente de todas as jogadas desde o in√≠cio do jogo at√© o estado inicial do tabuleiro.  Em <a href="https://habr.com/ru/post/234587/">casos</a> realmente <a href="https://habr.com/ru/post/234587/">complexos</a> , esse tipo de navega√ß√£o n√£o ocorre rapidamente.  Outra desvantagem da nota√ß√£o ZSG pode ser ilustrada pela grava√ß√£o da seguinte jogada no jogo <a href="https://en.wikipedia.org/wiki/Go_(game)" rel="nofollow">Go</a> : <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. White Stone G19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> A19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> B19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> C19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> D19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> E19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> F19</code> </pre> <br>  Aqui, na posi√ß√£o G19, √© colocada uma pedra branca que captura um grupo de pedras negras.  Como todas as pe√ßas envolvidas no desempenho da coloca√ß√£o devem ser mencionadas no desempenho do ZSG, o registro do turno pode parecer muito longo (em Go, uma queda pode capturar at√© 360 pedras).  Para o que isso pode levar, escrevi <a href="https://habr.com/ru/post/235483/">anteriormente</a> .  O tamanho do buffer alocado para gravar a movimenta√ß√£o do ZoG pode n√£o ser suficiente.  Al√©m disso, se por algum motivo a ordem de remo√ß√£o das pedras mudar (no processo de desenvolvimento do jogo acontece), uma tentativa de aplicar uma jogada, de uma antiga ordem de capturas, falhar√°. <br><br>  Felizmente, existe uma maneira simples de lidar com todos esses problemas.  Vejamos como definir movimentos de pe√ßas no ZRF: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Pawn) (<span class="hljs-name"><span class="hljs-name">image</span></span> White <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\wpawn.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\wpawn.bmp"</span></span> Black <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\bpawn.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\bpawn.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">Pawn-capture</span></span> nw) (<span class="hljs-name"><span class="hljs-name">Pawn-capture</span></span> ne) (<span class="hljs-name"><span class="hljs-name">Pawn-move</span></span>) (<span class="hljs-name"><span class="hljs-name">En-Passant</span></span> e) (<span class="hljs-name"><span class="hljs-name">En-Passant</span></span> w) ) )</code> </pre> <br>  Os nomes de movimentos, definidos nas macros do ZoG, s√£o inacess√≠veis como um gerador de movimentos.  Mas o que nos impede de desistir de macros e fazer descri√ß√µes dos movimentos com seus nomes?  Aqui est√° como o registro pareceria um jogo de xadrez: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. e2 - e4 Pawn-move <span class="hljs-number"><span class="hljs-number">1</span></span>. e7 - e5 Pawn-move <span class="hljs-number"><span class="hljs-number">2</span></span>. g1 - f3 leap2 n nw <span class="hljs-number"><span class="hljs-number">2</span></span>. b8 - c6 leap2 n <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>. f1 - c4 slide nw <span class="hljs-number"><span class="hljs-number">3</span></span>. g8 - f6 leap2 n nw <span class="hljs-number"><span class="hljs-number">4</span></span>. e1 - g1 OO <span class="hljs-number"><span class="hljs-number">4</span></span>. d7 - d5 Pawn-move <span class="hljs-number"><span class="hljs-number">5</span></span>. e4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 Pawn-capture nw <span class="hljs-number"><span class="hljs-number">5</span></span>. f6 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 leap2 w nw</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Nota</b> <div class="spoiler_text">  Os leitores astutos podem perceber que, nas jogadas para ‚Äúpreto‚Äù, usei instru√ß√µes n√£o apropriadas √†s instru√ß√µes reais no tabuleiro de xadrez.  Isso est√° relacionado ao fato de que "simetrias" s√£o definidas para preto: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">symmetry</span></span> Black (<span class="hljs-name"><span class="hljs-name">ns</span></span>)(<span class="hljs-name"><span class="hljs-name">sn</span></span>) (<span class="hljs-name"><span class="hljs-name">nw</span></span> sw)(<span class="hljs-name"><span class="hljs-name">sw</span></span> nw) (<span class="hljs-name"><span class="hljs-name">ne</span></span> se)(<span class="hljs-name"><span class="hljs-name">se</span></span> ne))</code> </pre> <br>  Grosso modo, ent√£o, o que para branco √© "norte", para preto √© "sul" e vice-versa. <br></div></div><br>  Os benef√≠cios desse registro n√£o s√£o √≥bvios, mas t√™m uma vantagem importante.  Todas as jogadas s√£o descritas de maneira uniforme e essas descri√ß√µes n√£o cont√™m nada extra (os nomes das descri√ß√µes das jogadas, √© claro, poderiam ser mais "descritivos").  Na descri√ß√£o do castling, conseguiu-se se livrar das mudan√ßas de atributos e da descri√ß√£o da jogada da torre (essa descri√ß√£o n√£o depende mais dos detalhes de implementa√ß√£o da jogada).  Uma utilidade ainda mais clara de tais registros existe no caso do jogo Go: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. G19 drop-to-empty White Stone</code> </pre> <br>  E √© isso a√≠!  Se as pedras do oponente forem retiradas de acordo com as regras do jogo, n√£o h√° necessidade de list√°-las todas na descri√ß√£o do movimento.  √â suficiente indicar o espa√ßo inicial e final do deslocamento (possivelmente com um sinal a ser utilizado), o nome do movimento em execu√ß√£o e a linha de par√¢metros passados ‚Äã‚Äãa ele.  Obviamente, para executar um movimento de acordo com esta descri√ß√£o, para decodificar, √© necess√°rio acessar o m√≥dulo de gera√ß√£o de movimento, mas o ZoG faz isso! <br><br>  Outra possibilidade, a qual se deve apoiar, aparece na funcionalidade dos movimentos "parciais".  Aqui est√° um exemplo de " <a href="https://glukkazan.github.io/checkers/russian-checkers.htm" rel="nofollow">damas russas</a> ": <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. Checker g3 - f4 <span class="hljs-number"><span class="hljs-number">1</span></span>. Checker f6 - g5 <span class="hljs-number"><span class="hljs-number">2</span></span>. Checker e3 - d4 <span class="hljs-number"><span class="hljs-number">2</span></span>. partial <span class="hljs-number"><span class="hljs-number">2</span></span> Checker g5 - e3 = XChecker on f4 <span class="hljs-number"><span class="hljs-number">2</span></span>. Checker e3 - c5 = XChecker on d4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> f4</code> </pre><br>  Aqui os negros, em seu segundo movimento, pegam duas pe√ßas em d4 e f4.  Uma "transforma√ß√£o" preliminar dessas pe√ßas no XChecker √© um recurso desta implementa√ß√£o e serve para impedir a retomada de pe√ßas "derrotadas" na mesma jogada.  A frase "parcial 2" descreve o in√≠cio do curso "composto", que consiste em dois movimentos "parciais".  Essa forma de descri√ß√£o √© inconveniente, porque no momento da gera√ß√£o do primeiro movimento, o comprimento da sequ√™ncia de movimentos "parciais" pode n√£o ser conhecido.  Veja como esta descri√ß√£o ficar√° em um novo formato: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. g3 - f4 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> nw <span class="hljs-number"><span class="hljs-number">1</span></span>. f6 - g5 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>. e3 - d4 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> nw <span class="hljs-number"><span class="hljs-number">2</span></span>. + g5 - e3 checker-jump nw <span class="hljs-number"><span class="hljs-number">2</span></span>. + e3 - c5 checker-jump sw <span class="hljs-number"><span class="hljs-number">2</span></span>. +</code> </pre><br>  Detalhes de implementa√ß√£o relacionados √† "transforma√ß√£o" de pe√ßas s√£o irrelevantes.  A captura de pe√ßas tamb√©m n√£o √© especificada, pois em damas, a captura ocorre como um "efeito colateral" do movimento da pe√ßa e n√£o de acordo com o "princ√≠pio do xadrez". O progresso parcial ser√° codificado com o s√≠mbolo "+" no in√≠cio da linha.  Um "+" isolado indica a conclus√£o de um "movimento composto" (na verdade, este √© o movimento "parcial" usual, contendo um movimento ausente, uma sequ√™ncia vazia). <br><br>  Assim, usando regras nomeadas para a implementa√ß√£o de movimentos, conseguiu-se criar uma nota√ß√£o universal, satisfazendo totalmente nossos requisitos.  Obviamente, isso n√£o tem nada a ver com o xadrez padr√£o ou com qualquer outra nota√ß√£o, mas acontece que a nota√ß√£o convencional para xadrez, damas e outros jogos tamb√©m n√£o tem nada a ver uma com a outra.  O m√≥dulo de visualiza√ß√£o sempre pode converter o registro de movimenta√ß√£o em uma forma mais familiar aceita em um jogo espec√≠fico.  A convers√£o tamb√©m pode ter alguma forma universal, como <a href="https://en.wikipedia.org/wiki/Smart_Game_Format" rel="nofollow">SGF (Smart Game Format)</a> . <br><br><h2>  O ciclo de vida do jogo </h2><br>  Al√©m das informa√ß√µes sobre como colocar as pe√ßas no tabuleiro, a sequ√™ncia de turnos √© uma parte importante do estado do jogo, uma vari√°vel no processo do jogo.  No caso mais simples (e mais comum), para armazenar essas informa√ß√µes, um bit ser√° suficiente, mas o ZoG oferece mais algumas oportunidades para implementar casos mais complexos.  Aqui est√° como uma descri√ß√£o de uma sequ√™ncia de movimentos poderia procurar o jogo <a href="http://www.iggamecenter.com/info/en/splut.html" rel="nofollow">Splut!</a>  : <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South West North East) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> South West West repeat North North North East East East South South South West West West )</code> </pre> <br>  Nesse jogo, cada jogador faz tr√™s jogadas de cada vez, mas se voc√™ der ao primeiro jogador a oportunidade de fazer tr√™s jogadas da posi√ß√£o inicial, ele poder√° destruir uma das pe√ßas do advers√°rio, o que lhe daria uma vantagem significativa.  Por esse motivo, o primeiro jogador deve fazer apenas um movimento (d√° a oportunidade de se preparar para atacar um jogador advers√°rio, mas n√£o o atacar), o segundo - dois movimentos (isso tamb√©m n√£o √© suficiente para atacar um jogador advers√°rio), depois onde cada jogador sempre faz tr√™s movimentos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f78/6b5/862/f786b5862708474184d805653c2fe9fc.jpg"></div><br>  A repeti√ß√£o do r√≥tulo indica o in√≠cio de uma sequ√™ncia de movimentos repetidos ciclicamente.  Se n√£o aparecer, a descri√ß√£o inteira ser√° repetida ciclicamente.  O ZoG n√£o permite o uso do r√≥tulo repetir mais de uma vez.  Outra caracter√≠stica importante √© a especifica√ß√£o da ordem dos turnos.  Aqui est√° como uma descri√ß√£o da sequ√™ncia de turnos de um jogo em que cada jogador executa dois turnos (o primeiro movimento - pe√ßas em movimento, o segundo - capturando as pe√ßas do oponente): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> White Black) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">White</span></span> normal-move) (<span class="hljs-name"><span class="hljs-name">White</span></span> capture-move) (<span class="hljs-name"><span class="hljs-name">Black</span></span> normal-move) (<span class="hljs-name"><span class="hljs-name">Black</span></span> capture-move) )</code> </pre> <br>  H√° mais um recurso associado √† descri√ß√£o de mover as pe√ßas de outra pessoa, mas √© muito inconveniente de usar.  O problema √© que essa descri√ß√£o n√£o tem alternativa.  Se a descri√ß√£o indicar que o movimento deve ser feito por uma pe√ßa inimiga, o jogador deve executar esse movimento!  No ZoG, √© imposs√≠vel descrever uma escolha de mudar a pe√ßa dele ou de outra pessoa.  Se tal capacidade for necess√°ria em um jogo (como em " <a href="https://glukkazan.github.io/checkers/stavropol-checkers.htm" rel="nofollow">Stavropol Chequers</a> "), √© necess√°rio tornar todas as pe√ßas neutras (criando para esse fim um jogador que n√£o participe do jogo) e determinar para todos os jogadores a oportunidade para mover uma pe√ßa neutra.  Eu disse acima que, por padr√£o, √© muito mais f√°cil permitir que todos os jogadores movam quaisquer pe√ßas (tanto as suas quanto as do seu oponente) adicionando as verifica√ß√µes necess√°rias nos algoritmos de gera√ß√£o de movimento. <br><br>  Como voc√™ pode ver, o leque de op√ß√µes fornecidas pelo ZoG para descri√ß√£o da sequ√™ncia de voltas √© extremamente limitado.  O Axiom tamb√©m falha ao adicionar novos recursos, porque (geralmente) √© executado no ZoG.  Ludi, a esse respeito, √© ainda mais pobre.  Para maximizar a unifica√ß√£o das regras do jogo (necess√°ria para a possibilidade de usar algoritmos gen√©ricos), neste projeto, todas as capacidades descritivas foram deliberadamente simplificadas, o que provocou a elimina√ß√£o de camadas inteiras de jogos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/52b/c1e/8a3/52bc1e8a3f374c8386884241a1571a18.jpg"></div><br>  " <a href="https://en.wikipedia.org/wiki/Bao_(game)" rel="nofollow">Bao Swahili</a> " √© um bom exemplo de um jogo com um ciclo de vida complexo. Neste jogo, existem duas fases com regras para execu√ß√£o de movimentos que diferem significativamente. No in√≠cio do jogo, parte das pedras est√° "na m√£o" "De cada jogador. Enquanto ainda h√° pedras" na m√£o ", pedras s√£o colocadas em po√ßos, uma pedra de cada vez. Quando as pedras" na m√£o "acabam, a segunda fase do jogo come√ßa, com a distribui√ß√£o dos N√£o se pode dizer que este jogo n√£o pode ser descrito no ZRF (a linguagem de descri√ß√£o do ZoG), mas devido √†s limita√ß√µes do ZoG, essa implementa√ß√£o seria extremamente confusa (o que certamente n√£o √© o melhor para a qualidade do trabalho de IA). Vamos ver como a descri√ß√£o de um jogo desse tipo ficaria em um "mundo ideal": <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> pi-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> pi-move) ) (<span class="hljs-name"><span class="hljs-name">label</span></span> phase-ii) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> p-ii-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> p-ii-move) ) )</code> </pre> <br>  Aqui, cada lista de ordem de turno determina sua sequ√™ncia repetida de movimentos (distinguindo-se pelo modo de execu√ß√£o dos movimentos).  O r√≥tulo da palavra-chave define um r√≥tulo para o qual uma transi√ß√£o pode ser feita durante a gera√ß√£o da √∫ltima jogada.  Voc√™ pode notar que aqui procedemos da suposi√ß√£o impl√≠cita de que essa transi√ß√£o sempre ocorre ap√≥s a jogada do segundo jogador (caso contr√°rio, isso violaria a sequ√™ncia de jogadas).  Como fazer a transi√ß√£o para a pr√≥xima fase em um momento arbitr√°rio? <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> pi-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> pi-move) ) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">labels</span></span> - phase-ii) (<span class="hljs-name"><span class="hljs-name">South</span></span> p-ii-move) (<span class="hljs-name"><span class="hljs-name">labels</span></span> phase-ii -) (<span class="hljs-name"><span class="hljs-name">North</span></span> p-ii-move) ) )</code> </pre> <br>  Aqui, os r√≥tulos s√£o transportados no corpo do loop e compreendem dois nomes.  Os nomes de marcadores nas listas de marcadores aparecem na ordem de transfer√™ncia de jogadores na lista de jogadores.  O nome usado para a transi√ß√£o √© determinado pelo jogador que fez a √∫ltima jogada.  Se esse foi o norte, ele far√° a transi√ß√£o para o primeiro r√≥tulo, caso contr√°rio, para o segundo.  Se algum dos nomes nos r√≥tulos n√£o for usado, a posi√ß√£o correspondente poder√° ser preenchida por um tra√ßo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/060/833/75d/06083375de8a4b97b7cffb138b3d5b9f.jpg"></div><br>  Um aspecto importante no gerenciamento de movimentos alternados √© a capacidade de executar um turno repetido.  Em jogos da <a href="https://en.wikipedia.org/wiki/Tables_(board_game)" rel="nofollow">fam√≠lia Tables</a> , como <a href="https://en.wikipedia.org/wiki/Tables_(board_game)" rel="nofollow">Nard</a> , <a href="https://glukkazan.github.io/races/backgammon.htm" rel="nofollow">Gam√£o</a> ou <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2262" rel="nofollow">Ur</a> , por exemplo, a capacidade de executar turnos repetidos √© um elemento importante das t√°ticas de jogo.  No ZoG, pode-se usar a passagem de um turno para imitar esse recurso, mas essa abordagem complica significativamente a descri√ß√£o do jogo (especialmente com mais jogadores).  Seria muito mais l√≥gico usar um r√≥tulo para repetir uma vez: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">label</span></span> repeat) South (<span class="hljs-name"><span class="hljs-name">label</span></span> repeat) North )</code> </pre> <br>  Ap√≥s o jogo ter saltado para a repeti√ß√£o do marcador, o jogador jogar√° novamente o seu turno (o marcador mais pr√≥ximo da posi√ß√£o atual na lista de turnos entrar√° em vigor).  Eu gosto da abordagem do <a href="https://en.wikipedia.org/wiki/Perl" rel="nofollow">Perl</a> em suas defini√ß√µes impl√≠citas.  A gera√ß√£o impl√≠cita de estruturas de controle pode simplificar significativamente a descri√ß√£o do jogo.  Como movimentos repetidos podem ser usados ‚Äã‚Äãem muitos jogos, os r√≥tulos se repetem, antecipando a poss√≠vel repeti√ß√£o de qualquer turno. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> South North )</code> </pre> <br>  Al√©m disso, como a sequ√™ncia de turnos √© totalmente consistente com a ordem por escrito dos jogadores na constru√ß√£o dos jogadores, voc√™ pode gerar automaticamente toda a frase da ordem dos turnos: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North)</code> </pre> <br>  Quanto mais f√°cil a descri√ß√£o for escrita, melhor. <br><br><h2>  Invari√°vel quebr√°vel </h2><br>  A principal coisa que eu n√£o gosto no ZoG pode ser expressa com uma palavra - xadrez.  √Ä primeira vista, √© apenas uma condi√ß√£o (muito comum em jogos da <a href="https://en.wikipedia.org/wiki/Checkmate" rel="nofollow">fam√≠lia</a> do <a href="https://en.wikipedia.org/wiki/Checkmate" rel="nofollow">xadrez</a> ) que liga o final do jogo √† forma√ß√£o de uma situa√ß√£o de companheiro.  Infelizmente, em uma an√°lise mais aprofundada, a simplicidade mostra-se enganosa.  O uso dessa palavra-chave significa n√£o apenas o desempenho, ap√≥s cada jogada, de uma verifica√ß√£o para a conclus√£o do jogo, mas tamb√©m imp√µe ao jogador certo "comportamento". <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OR74gUlfQNY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Do <a href="https://en.wikipedia.org/wiki/Shogi" rel="nofollow">Shogi</a> habitual, este jogo difere apenas no n√∫mero de jogadores.  Infelizmente, essa diferen√ßa √© suficiente para tornar o trabalho de determinar o xeque-mate (e tudo associado a essa palavra "m√°gica") incorreto.  A verifica√ß√£o do cheque √© realizada apenas em rela√ß√£o a um dos jogadores.  Como resultado, o rei pode estar sob ataque e ser comido [por uma combina√ß√£o de turnos dos oponentes, mesmo quando n√£o for deixado em "check"]!  O fato de isso n√£o ser o ideal ser√° refletido no trabalho da IA. <br><br>  Se esse problema parece insignificante, vale lembrar que as coaliz√µes geralmente s√£o formadas em jogos de quatro jogadores "par contra par".  No caso da forma√ß√£o de coaliz√µes, devemos considerar que pe√ßas amig√°veis ‚Äã‚Äãao rei n√£o o amea√ßam!  Assim, por exemplo, dois reis amigos podem muito bem residir em espa√ßos vizinhos do tabuleiro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b00/77d/949/b0077d949f2d472da9e12d64099d924d.jpg"></div><br>  Torna-se mais complicado do que nunca se um jogador pode ter v√°rios reis.  No " <a href="http://history.chess.free.fr/tamerlane-full.htm" rel="nofollow">xadrez Tamerlane</a> ", o pe√£o real se transforma em um pr√≠ncipe (na verdade, um segundo rei).  Se isso acontecer, voc√™ poder√° vencer apenas capturando o primeiro rei (um dos dois) e acasalando o segundo.  Neste jogo, voc√™ pode ganhar at√© um terceiro rei, o dobro de gastos com a transforma√ß√£o do "pe√£o ‚Äã‚Äãde pe√µes"!  As capacidades expressivas de "xadrez" n√£o s√£o suficientes para descrever adequadamente essa situa√ß√£o. <br><br>  Outra dificuldade pode ser o pr√≥prio processo de dar companheira.  Assim, no xadrez mongol ( <a href="https://en.wikipedia.org/wiki/Shatar" rel="nofollow">Shatar</a> ), o resultado da tentativa de acasalamento depende da ordem em que as pe√ßas executam o "teste" seq√ºencial.  O resultado pode ser uma vit√≥ria ou um empate (como companheiro por pe√£o) ou at√© mesmo uma derrota (companheiro de cavalo proibido, mas voc√™ pode dar um cheque).  Um pouco menos ex√≥tico, a esse respeito, √© o shogi japon√™s.  Neste jogo, √© proibido dar companheiro com um pe√£o ca√≠do, mas voc√™ pode dar check com um pe√£o ca√≠do e dar check mate com um pe√£o movido. <br><br><div class="spoiler">  <b class="spoiler_title">Nota</b> <div class="spoiler_text">  H√° mais um ponto importante que vale a pena mencionar.  Em alguns jogos, como o Rhythmomagic, pode haver v√°rias maneiras diferentes de terminar o jogo.  A maneira mais √≥bvia de vencer, envolvendo a destrui√ß√£o das pe√ßas do advers√°rio, tamb√©m √© a menos preferida.  Para uma vit√≥ria mais significativa, √© preciso organizar as pe√ßas no territ√≥rio inimigo em um determinado padr√£o. <br><br>  Deve-se distinguir entre os tipos de vit√≥rias (e derrotas e empates) no n√≠vel da descri√ß√£o do jogo, j√° que o tipo de final do jogo pode ser importante para o jogador.  Al√©m disso, deve ser poss√≠vel atribuir prioridades num√©ricas aos v√°rios finais do jogo.  Ap√≥s o cumprimento simult√¢neo de v√°rias condi√ß√µes de conclus√£o, a que tiver a maior prioridade deve contar. <br></div></div><br>  Obviamente, √© preciso separar a l√≥gica da verifica√ß√£o do final do jogo do teste, para que o rei tenha ca√≠do em xeque, que √© uma <a href="https://en.wikipedia.org/wiki/Invariant_(mathematics)" rel="nofollow">regra invari√°vel</a> que √© checada ap√≥s cada turno.  A viola√ß√£o da regra torna imposs√≠vel executar a movimenta√ß√£o (a movimenta√ß√£o √© removida da lista de movimenta√ß√µes dispon√≠veis).  Portanto, um teste (simplificado) para um rei estar sob controle pode ser assim para o "xadrez Tamerlane": <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King))) <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King) is-attacked?)) <span class="hljs-number"><span class="hljs-number">0</span></span>) ) )</code> </pre> <br>  √â importante entender que esse teste deve ser realizado apenas para os pr√≥prios reis (usei o predicado my?, Porque o predicado amigo ?, com apoio √†s coaliz√µes, ser√° satisfeito n√£o apenas pelas pr√≥prias pe√ßas, mas tamb√©m pelas pe√ßas de todos os jogadores amig√°veis).  Aceit√°vel (e desej√°vel, [se houver v√°rios reis amigos]) √© a situa√ß√£o em que o rei inimigo fica sob controle, ap√≥s um movimento, mas pelo pr√≥prio rei.  Esta situa√ß√£o deve ser imposs√≠vel [a menos que haja v√°rios reis amigos]!  Tendo fornecido suporte para verificar essas regras, verificar a conclus√£o do jogo pelo xeque-mate se torna trivial.  Se n√£o houver movimentos poss√≠veis e o [√∫nico] rei estiver em xeque, o jogo terminar√° [se esse rei pertencer ao √∫ltimo jogador sobrevivente da segunda √∫ltima coaliz√£o sobrevivente]: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">loss-condition</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> moves) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King)) <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King) is-attacked?)) <span class="hljs-number"><span class="hljs-number">0</span></span>) ) )</code> </pre> <br>  A capacidade de determinar invariantes ser√° √∫til em outros jogos, como em <a href="https://glukkazan.github.io/checkers/international-checkers.htm" rel="nofollow">damas</a> .  A maior dificuldade na implementa√ß√£o de jogos dessa fam√≠lia est√° ligada √† implementa√ß√£o da ‚Äúregra da maioria‚Äù.  Em quase todos os jogos de rascunho, a captura √© obrigat√≥ria.  Al√©m disso, na maioria dos jogos desta fam√≠lia, h√° uma conclus√£o caracter√≠stica de ‚Äúcapturas em cadeia‚Äù em um √∫nico turno.  O verificador, tendo capturado, continua a pegar outras pe√ßas, se poss√≠vel.  Na maioria dos jogos, o jogador √© obrigado a realizar capturas em cadeia at√© o fim, mas h√° exce√ß√µes a essa regra, por exemplo, <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm" rel="nofollow">Fanorona</a> . <br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm" rel="nofollow"><img src="https://habrastorage.org/files/a4a/f83/3d8/a4af833d85d445b5ba17aca59056b741.jpg"></a> </div><br>  Usando o mecanismo de movimentos parciais, implementar uma ‚Äúcaptura de cadeia‚Äù √© bastante simples.  Dificuldades surgem quando, al√©m disso, imp√µe-se uma condi√ß√£o sob a qual, de todas as op√ß√µes poss√≠veis, √© preciso escolher uma cadeia na qual um n√∫mero m√°ximo de pe√ßas √© capturado.  No ZoG, essa l√≥gica deve ser implementada do zero no n√≠vel de "codifica√ß√£o": <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> true)</code> </pre> <br>  Essa configura√ß√£o √© adequada para " <a href="https://glukkazan.github.io/checkers/international-checkers.htm" rel="nofollow">damas internacionais</a> ", mas nas " <a href="https://glukkazan.github.io/checkers/italian-checkers.htm" rel="nofollow">damas italianas</a> " a regra da maioria √© formulada de maneira diferente.  Nesta vers√£o do jogo, se houver v√°rias op√ß√µes para o mesmo n√∫mero de capturas, voc√™ dever√° selecionar uma op√ß√£o que capture o maior n√∫mero de damas transformadas (reis).  Os desenvolvedores do ZoG forneceram isso.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voc√™ insere a seguinte configura√ß√£o: </font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta configura√ß√£o, conta-se n√£o apenas o n√∫mero de pe√ßas capturadas, mas tamb√©m seu tipo. </font><font style="vertical-align: inherit;">Infelizmente, nem tudo pode ser previsto. </font><font style="vertical-align: inherit;">Veja como a "regra da maioria" √© formulada em "damas francesas antigas":</font></font><br><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se por uma s√©rie de capturas for poss√≠vel capturar o mesmo n√∫mero de damas com um homem simples ou com um rei, o jogador deve usar o rei. </font><font style="vertical-align: inherit;">No entanto, se o n√∫mero de damas for o mesmo em ambos os casos, mas em um houver um rei inimigo (ou houver mais), o jogador dever√° escolher esta op√ß√£o, mesmo que a captura seja feita usando o verificador simples, e n√£o usando o rei.</font></font></i> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â claro que, atualmente, quase ningu√©m joga essa vers√£o de damas, mas sua pr√≥pria exist√™ncia demonstra claramente as defici√™ncias da implementa√ß√£o "codificada". </font><font style="vertical-align: inherit;">O uso do mecanismo de invariantes permite todas as op√ß√µes poss√≠veis para a ‚Äúregra da maioria‚Äù de maneira universal. </font><font style="vertical-align: inherit;">Para a </font><font style="vertical-align: inherit;">implementa√ß√£o </font><font style="vertical-align: inherit;">das " </font></font><a href="http://www.checkerschest.com/checkers-games/french-checkers.htm" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antigas damas francesas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", seria a seguinte:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> capturing-count max-capturing-count) ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> capturing-count max-capturing-count) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-count capturing-count) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-sum capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value) ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> capturing-sum max-capturing-sum) ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> capturing-sum max-capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-sum capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value) ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> attacking-value max-attacking-value) ) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui, assumimos que as regras para gera√ß√£o de captura preenchem corretamente [as seguintes] vari√°veis ‚Äã‚Äãlocais: </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contagem de captura</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - total de pe√ßas capturadas</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soma de captura</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - n√∫mero de reis capturados</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor de ataque</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - valor da captura da pe√ßa</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Associado a cada uma dessas vari√°veis ‚Äã‚Äãest√° um acumulador de valores, armazenado em uma vari√°vel com o prefixo max. As tr√™s verifica√ß√µes s√£o executadas em s√©rie. A viola√ß√£o de qualquer uma das condi√ß√µes de verifica√ß√£o interrompe imediatamente a gera√ß√£o da pr√≥xima op√ß√£o de turno (a captura n√£o √© armazenada na lista de turnos poss√≠veis). Como as verifica√ß√µes executadas est√£o associadas a valores vari√°veis, n√£o √© suficiente [testar apenas a nova op√ß√£o de captura atual]. Cada teste gera uma "regra flex√≠vel" associada √† captura gerada [que pode revisar o valor m√°ximo acumulado]. Ap√≥s cada altera√ß√£o em qualquer acumulador, todas as regras associadas devem ser verificadas novamente [para todas as op√ß√µes na lista]. Se alguma das condi√ß√µes for violada para uma op√ß√£o gerada anteriormente, essa op√ß√£o dever√° ser removida da lista de poss√≠veis op√ß√µes de turno.</font></font><br><br><h2>  Conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta √© a tradu√ß√£o do meu artigo de 2014 ano. </font><font style="vertical-align: inherit;">Desde ent√£o, repensei muito e o </font></font><a href="https://glukkazan.github.io/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projeto Dagaz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se tornou realidade, mas n√£o mudei quase nada no texto. </font><font style="vertical-align: inherit;">Este artigo foi traduzido por meu amigo </font></font><a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fsearchauthor%3D505" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Howard McCay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e sou grato a ele pelo trabalho realizado.</font></font><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt481868/">https://habr.com/ru/post/pt481868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt481854/index.html">Testando id√©ias atrav√©s da cria√ß√£o de prot√≥tipos no painel</a></li>
<li><a href="../pt481858/index.html">Anivers√°rios no Google Agenda com idade</a></li>
<li><a href="../pt481860/index.html">O que a TI deve fazer em 2020?</a></li>
<li><a href="../pt481862/index.html">Sistemas de aprendizado de m√°quina embarcados Nvidia Jetson</a></li>
<li><a href="../pt481866/index.html">DBA: quando o VACUUM passa - limpamos a mesa manualmente</a></li>
<li><a href="../pt481874/index.html">M√©tricas - indicadores de integridade do projeto</a></li>
<li><a href="../pt481880/index.html">F√≠sica para um shooter PvP m√≥vel e como fizemos amizade com a ECS</a></li>
<li><a href="../pt481882/index.html">4. Introdu√ß√£o ao Fortinet v6.0. Pol√≠ticas de firewall</a></li>
<li><a href="../pt481884/index.html">Encruzilhada para idosos: para onde ir?</a></li>
<li><a href="../pt481886/index.html">Como criar rapidamente um di√°rio de presen√ßa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>