<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§‘ğŸ¾â€ğŸ¤â€ğŸ§‘ğŸ¼ ğŸ‘ ğŸ‘©ğŸ¾â€ğŸ­ Neuer Pfadfinder-Algorithmus in Factorio ğŸ§¢ ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘©ğŸ¾ ğŸ’š</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Letzte Woche haben wir in unserem Blog Ã¼ber Ã„nderungen gesprochen, die es Feinden (Bitern) ermÃ¶glichen wÃ¼rden, nicht ineinander zu laufen, aber dies w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Neuer Pfadfinder-Algorithmus in Factorio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472366/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/l5/gr/ba/l5grba862hfltsqu-mpyjafuui0.gif"></div><br>  Letzte Woche haben wir in unserem Blog Ã¼ber Ã„nderungen gesprochen, die es Feinden (Bitern) ermÃ¶glichen wÃ¼rden, nicht ineinander zu laufen, aber dies war nicht das einzige Update im Zusammenhang mit Bitern.  ZufÃ¤lligerweise enthielten die Aktualisierungen dieser Woche das, woran wir in den letzten Wochen gearbeitet haben - die Aktualisierung des Suchsystems fÃ¼r Feinde. <br><br><h4>  Suche nach einem Weg </h4><br>  Wenn eine Einheit irgendwohin ziehen mÃ¶chte, muss sie zuerst verstehen, wie sie dorthin gelangt.  Im einfachsten Fall kÃ¶nnen Sie direkt zum Ziel gelangen, aber manchmal treten unterwegs Hindernisse auf - Steine, BÃ¤ume, feindliche Nester (Spawner), Spielereinheiten.  Um den Weg zu ebnen, mÃ¼ssen wir der Pfadfinderfunktion die aktuelle und endgÃ¼ltige Position mitteilen, und der Pfadfinder gibt uns (mÃ¶glicherweise nach vielen MaÃŸnahmen) einen <i>Pfad zurÃ¼ck</i> , der einfach eine Reihe von Wegpunkten ist, zu denen sich das GerÃ¤t bewegen muss, um zu gelangen Ziel <br><br>  Um seine Arbeit zu erledigen, verwendet Pathfinder einen Algorithmus namens A * (ausgesprochen "A star").  Ein einfaches Beispiel fÃ¼r das Finden eines Pfades mit A * wird im Video gezeigt: BeiÃŸer mÃ¶chte einen Pfad um Felsen finden.  Die Pfadfindungsfunktion beginnt, die Karte um den BeiÃŸer herum zu erkunden (die Studie wird durch weiÃŸe Punkte dargestellt).  Zuerst versucht sie, direkt zum Ziel zu gelangen, aber sobald sie die Klippen erreicht, â€verschÃ¼ttetâ€œ sie sich in beide Richtungen und versucht, eine Position zu finden, von der aus es wieder mÃ¶glich ist, zum Ziel zu gelangen. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/9URl7E2OYjw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Der Algorithmus in diesem Video ist verlangsamt, damit Sie besser sehen kÃ¶nnen, wie es funktioniert.</i> <br><br>  Jeder Punkt in der Animation reprÃ¤sentiert einen <i>Knoten</i> .  Jeder Knoten merkt sich die Entfernung vom Beginn der Suche und eine SchÃ¤tzung der Entfernung von diesem Knoten zum Ziel (diese SchÃ¤tzung wird durch die <i>heuristische Funktion</i> berechnet).  Dank der heuristischen Funktion funktioniert A * - es lenkt den Algorithmus in die richtige Richtung. <br><br>  Im einfachsten Fall berechnet diese Funktion einfach den Abstand in einer geraden Linie vom Knoten zur Zielposition - dies ist der Ansatz, den wir in Factorio von Beginn der Entwicklung an verwendet haben, und dank dessen bewegt sich der Algorithmus zunÃ¤chst in einer geraden Linie.  Dies ist jedoch nicht die einzige Option. Wenn die heuristische Funktion einige der Hindernisse kennt, kann sie den Algorithmus um sie herum lenken, was die Suche beschleunigen wÃ¼rde, da Sie die zusÃ¤tzlichen Knoten nicht untersuchen mÃ¼ssten.  Je intelligenter die Heuristik ist, desto schwieriger ist es natÃ¼rlich, sie umzusetzen. <br><br>  Eine einfache heuristische geradlinige EntfernungsschÃ¤tzfunktion ist gut geeignet, um Pfade Ã¼ber relativ kurze Entfernungen zu finden.  Es passte zu uns in frÃ¼heren Versionen von Factorio - fast immer bewegten sich BeiÃŸer Ã¼ber groÃŸe Entfernungen, nur weil sie durch Verschmutzung wÃ¼tend wurden, und dies geschah nicht sehr oft.  Wir haben jetzt jedoch Artillerie.  Artillerie kann leicht auf eine groÃŸe Anzahl von BeiÃŸern auf der anderen Seite eines groÃŸen Sees schieÃŸen (und sie "bewirtschaften"), wonach sie versuchen, den Weg um den See herum zu ebnen.  Das folgende Video zeigt, wie der einfache A * -Algorithmus, den wir zuvor verwendet haben, versucht, den See zu umgehen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/giqW-sdGbhY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Dieses Video zeigt die Geschwindigkeit des Algorithmus in der RealitÃ¤t;</i>  <i>er wird nicht verlangsamt.</i> <br><br><h4>  Blockreduzierung </h4><br>  Das Finden eines Pfades ist eine lange Geschichte, und es gibt viele Techniken, um ihn zu verbessern.  Einige dieser Techniken gehÃ¶ren zur Kategorie der <i>hierarchischen Pfadsuche</i> : In diesem Fall wird die Karte zunÃ¤chst vereinfacht, der Pfad befindet sich auf dieser vereinfachten Karte, die dann zum Auffinden des realen Pfades verwendet wird.  Ich wiederhole, es gibt mehrere spezifische Implementierungen einer solchen Technik, aber alle erfordern eine Vereinfachung des Suchraums. <br><br>  Wie kÃ¶nnen Sie die Welt von Factorio vereinfachen?  Unsere Karten werden zufÃ¤llig generiert und Ã¤ndern sich stÃ¤ndig: Das Platzieren und LÃ¶schen von Objekten (z. B. Sammlern, WÃ¤nden oder TÃ¼rmen) ist wahrscheinlich die grundlegendste Mechanik des gesamten Spiels.  Wir mÃ¶chten nicht jedes Mal, wenn wir eine EntitÃ¤t hinzufÃ¼gen oder entfernen, die gesamte vereinfachte Karte neu erzÃ¤hlen.  Wenn wir die Karte jedes Mal neu vereinfachen, wenn wir einen Weg finden mÃ¼ssen, kÃ¶nnen wir gleichzeitig leicht den gesamten Leistungsgewinn verlieren. <br><br>  Eine der Personen mit Zugriff auf den Quellcode des Spiels (Allaizn) hatte eine Idee.  was ich als Ergebnis implementiert habe.  Nun scheint diese Idee offensichtlich. <br><br>  Das Spiel basiert auf BlÃ¶cken von 32x32 PlÃ¤ttchen.  Der Vereinfachungsprozess ersetzt jeden Block durch einen oder mehrere <i>abstrakte Knoten</i> .  Da unser Ziel darin besteht, die Suche nach einem Pfad um die Seen herum zu verbessern, kÃ¶nnen wir alle EntitÃ¤ten ignorieren und nur Kacheln berÃ¼cksichtigen: Sie kÃ¶nnen sich nicht auf dem Wasser bewegen, an Land kÃ¶nnen Sie.  Wir trennen jeden Block in separate <i>Komponenten</i> .  Eine Komponente ist ein Kachelbereich, in dem eine Einheit von einer Kachel innerhalb einer Komponente zu einer anderen Kachel derselben Komponente gelangen kann.  In der Abbildung unten ist der Block in zwei separate Komponenten unterteilt: Rot und GrÃ¼n.  Jede dieser Komponenten wird zu einem abstrakten Knoten - tatsÃ¤chlich wird der gesamte Block auf zwei â€Punkteâ€œ reduziert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/584/afe/ca9/584afeca9174cd544118ac41ea737c33.png"></div><br>  Der wichtigste Gedanke von Allaizn war, dass wir nicht fÃ¼r jede Kartenkachel eine Komponente speichern mÃ¼ssen - denken Sie nur an die Kachelkomponenten entlang des Umfangs jedes Blocks, da wir nur daran interessiert sind, mit welchen anderen Komponenten (in benachbarten BlÃ¶cken) jeder Komponente verbunden ist, und dies hÃ¤ngt nur von den Kacheln ab, die sich am Rand des Blocks befinden. <br><br><h4>  Hierarchische Pfadsuche </h4><br>  Wir haben also herausgefunden, wie man die Karte vereinfacht, aber wie man damit Pfade findet.  Wie gesagt, es gibt viele hierarchische Pfadsuchtechniken.  Die einfachste Idee ist, den Pfad mithilfe abstrakter Knoten vom Anfang bis zum Ziel zu finden. Das heiÃŸt, der Pfad ist eine Liste der Blockkomponenten, die Sie besuchen mÃ¼ssen.  Dann verwenden wir die Reihe guter alter SuchvorgÃ¤nge A *, um genau herauszufinden, wie man von einer Komponente des Blocks zu einer anderen wechselt. <br><br>  Das Problem hierbei ist, dass wir die Karte zu stark vereinfacht haben: Was ist, wenn ein Wechsel von einem Block zum anderen nicht mÃ¶glich ist, weil einige Objekte (z. B. Felsen) den Pfad blockieren?  Beim Reduzieren von BlÃ¶cken ignorieren wir alle EntitÃ¤ten, daher wissen wir nur, dass die Kacheln zwischen den BlÃ¶cken irgendwie miteinander verbunden sind, aber wir wissen absolut nichts darÃ¼ber, ob es mÃ¶glich ist, von einem zum anderen zu wechseln. <br><br>  Die LÃ¶sung besteht darin, die Vereinfachung einfach als â€Empfehlungâ€œ fÃ¼r eine echte Suche zu verwenden.  Insbesondere werden wir damit eine intelligente Version der heuristischen Suchfunktion erstellen. <br><br>  Als Ergebnis haben wir das folgende Schema erhalten: Wir haben zwei Pfadfinder: den <i>Basispfadfinder</i> , der den realen Pfad findet, und den <i>abstrakten Pfadfinder</i> , der die heuristische Funktion fÃ¼r den Basispfadfinder bereitstellt.  Jedes Mal, wenn der Basispfadfinder einen neuen Basisknoten erstellt, ruft er einen abstrakten Pfadfinder auf, um eine SchÃ¤tzung der Entfernung zum Ziel zu erhalten.  Der abstrakte Pfadfinder verhÃ¤lt sich in umgekehrter Reihenfolge - er beginnt mit dem Suchziel und ebnet den Weg zum Anfang, wobei er sich von einer Komponente des Blocks zur anderen bewegt.  Wenn eine abstrakte Suche den Block und die Komponente findet, in denen ein neuer Basisknoten erstellt wird, verwendet sie die Entfernung vom Beginn der abstrakten Suche (die, wie gesagt, die Zielposition der gesamten Suche ist), um eine SchÃ¤tzung der Entfernung vom neuen Basisknoten zum allgemeinen Ziel zu berechnen. <br><br>  Die AusfÃ¼hrung des gesamten Pfadfinders fÃ¼r jeden einzelnen Knoten ist jedoch alles andere als schnell, selbst wenn sich der abstrakte Pfadfinder von einem Block zum anderen bewegt.  Daher verwenden wir stattdessen ein Schema namens "Reverse Resumable A *".  "Umkehren" bedeutet, dass es, wie ich oben sagte, vom Ziel bis zum Anfang ausgefÃ¼hrt wird.  "Erneuerbar" bedeutet, dass wir nach dem Auffinden eines Blocks, der fÃ¼r den Basispfadfinder interessant ist, alle seine Knoten im Speicher speichern.  Wenn der Basispfadfinder das nÃ¤chste Mal einen neuen Knoten erstellt und eine EntfernungsschÃ¤tzung benÃ¶tigt, sehen wir uns nur die abstrakten Knoten an, die bei der vorherigen Suche gespeichert wurden.  Gleichzeitig besteht eine hohe Wahrscheinlichkeit, dass sich der erforderliche abstrakte Knoten noch im Speicher befindet (am Ende deckt ein abstrakter Knoten den grÃ¶ÃŸten Teil des Blocks und hÃ¤ufig den gesamten Block ab). <br><br>  Selbst wenn der Basispfadfinder einen Knoten erstellt, der sich in einem Block befindet, der von keinem der abstrakten Knoten abgedeckt wird, mÃ¼ssen wir nicht die gesamte abstrakte Suche erneut durchfÃ¼hren.  Ein praktisches Merkmal des A * -Algorithmus ist, dass er die AusfÃ¼hrung fortsetzt, selbst nachdem er die Arbeit beendet und einen Pfad gefunden hat, und die Knoten um die bereits untersuchten Knoten herum untersucht.  Und genau das tun wir, wenn wir eine EntfernungsschÃ¤tzung fÃ¼r einen Basisknoten benÃ¶tigen, der sich in einem Block befindet, der noch nicht von der abstrakten Suche abgedeckt wird: Wir setzen die abstrakte Suche von den im Speicher gespeicherten Knoten fort, bis sie zu dem von uns benÃ¶tigten Knoten erweitert wird. <br><br>  Das folgende Video zeigt ein neues Pfadfindungssystem in Aktion.  Blaue Kreise sind abstrakte Knoten;  weiÃŸe Punkte - einfache Suche.  Der Pfadfinder im Video ist viel langsamer als das Spiel, um zu zeigen, wie es funktioniert.  Bei normaler Geschwindigkeit dauert die gesamte Suche nur wenige Ticks.  Beachten Sie, dass die einfache Suche, die immer noch den alten Algorithmus verwendet, den wir immer verwendet haben, einfach auf magische Weise â€weiÃŸâ€œ, wie man sich um den See bewegt. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/YHfoatMhvA0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Da der abstrakte Pfadfinder nur zum Erhalten einer heuristischen SchÃ¤tzung der Entfernung verwendet wird, kann die Basissuche leicht von dem von der abstrakten Suche vorgeschlagenen Pfad abweichen.  Dies bedeutet, dass das Blockreduktionsschema zwar alle EntitÃ¤ten ignoriert, der grundlegende Pfadfinder sie jedoch fast problemlos umgehen kann.  Da EntitÃ¤ten bei der Vereinfachung der Karte ignoriert werden, mÃ¼ssen wir sie nicht jedes Mal wiederholen, wenn eine EntitÃ¤t hinzugefÃ¼gt oder entfernt wird. Es reicht aus, nur die Kacheln abzudecken, die geÃ¤ndert wurden (z. B. bei einer MÃ¼lldeponie), was viel seltener vorkommt als beim Platzieren von EntitÃ¤ten. <br><br>  DarÃ¼ber hinaus bedeutet dies, dass wir im Wesentlichen denselben Pfadfinder verwenden, den wir seit Jahren verwenden. Nur die heuristische Funktion wurde aktualisiert.  Das heiÃŸt, diese Ã„nderung wirkt sich nicht auf viele andere Systeme aus und wirkt sich nur auf die Suchgeschwindigkeit aus. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472366/">https://habr.com/ru/post/de472366/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472356/index.html">Microsoft vs IBM: Wichtige Ã„nderungen in der Java-UnterstÃ¼tzung</a></li>
<li><a href="../de472358/index.html">30. Oktober um 17:00 Uhr Webinar â€Bereitstellen des Kubernetes-Clusters in einer Stunde in der CROC-Cloudâ€œ</a></li>
<li><a href="../de472360/index.html">Scannen des Codes von Orchard CMS auf Fehler</a></li>
<li><a href="../de472362/index.html">Wir suchen und analysieren Fehler im Orchard CMS-Code</a></li>
<li><a href="../de472364/index.html">PostgreSQL- und Datensatzkonsistenzeinstellungen fÃ¼r jede bestimmte Verbindung</a></li>
<li><a href="../de472368/index.html">Sprachfischen: Wir analysieren Angriffsmethoden und Schutzmethoden gegen sie</a></li>
<li><a href="../de472372/index.html">Android-Automatisierung Super einfache Anleitung zum Erstellen Ihres ersten Espresso-Tests</a></li>
<li><a href="../de472374/index.html">Warum wir Server nach Island verlegt haben</a></li>
<li><a href="../de472378/index.html">Flash-ZuverlÃ¤ssigkeit: erwartet und unerwartet. Teil 2. XIV. Konferenz der USENIX Association. Dateispeichertechnologien</a></li>
<li><a href="../de472380/index.html">MIRO - eine offene Indoor-Roboterplattform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>