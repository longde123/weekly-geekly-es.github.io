<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏼 🐑 👩🏾‍🏭 Neuer Pfadfinder-Algorithmus in Factorio 🧢 👩🏿‍🤝‍👩🏾 💚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Letzte Woche haben wir in unserem Blog über Änderungen gesprochen, die es Feinden (Bitern) ermöglichen würden, nicht ineinander zu laufen, aber dies w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Neuer Pfadfinder-Algorithmus in Factorio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472366/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/l5/gr/ba/l5grba862hfltsqu-mpyjafuui0.gif"></div><br>  Letzte Woche haben wir in unserem Blog über Änderungen gesprochen, die es Feinden (Bitern) ermöglichen würden, nicht ineinander zu laufen, aber dies war nicht das einzige Update im Zusammenhang mit Bitern.  Zufälligerweise enthielten die Aktualisierungen dieser Woche das, woran wir in den letzten Wochen gearbeitet haben - die Aktualisierung des Suchsystems für Feinde. <br><br><h4>  Suche nach einem Weg </h4><br>  Wenn eine Einheit irgendwohin ziehen möchte, muss sie zuerst verstehen, wie sie dorthin gelangt.  Im einfachsten Fall können Sie direkt zum Ziel gelangen, aber manchmal treten unterwegs Hindernisse auf - Steine, Bäume, feindliche Nester (Spawner), Spielereinheiten.  Um den Weg zu ebnen, müssen wir der Pfadfinderfunktion die aktuelle und endgültige Position mitteilen, und der Pfadfinder gibt uns (möglicherweise nach vielen Maßnahmen) einen <i>Pfad zurück</i> , der einfach eine Reihe von Wegpunkten ist, zu denen sich das Gerät bewegen muss, um zu gelangen Ziel <br><br>  Um seine Arbeit zu erledigen, verwendet Pathfinder einen Algorithmus namens A * (ausgesprochen "A star").  Ein einfaches Beispiel für das Finden eines Pfades mit A * wird im Video gezeigt: Beißer möchte einen Pfad um Felsen finden.  Die Pfadfindungsfunktion beginnt, die Karte um den Beißer herum zu erkunden (die Studie wird durch weiße Punkte dargestellt).  Zuerst versucht sie, direkt zum Ziel zu gelangen, aber sobald sie die Klippen erreicht, „verschüttet“ sie sich in beide Richtungen und versucht, eine Position zu finden, von der aus es wieder möglich ist, zum Ziel zu gelangen. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/9URl7E2OYjw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Der Algorithmus in diesem Video ist verlangsamt, damit Sie besser sehen können, wie es funktioniert.</i> <br><br>  Jeder Punkt in der Animation repräsentiert einen <i>Knoten</i> .  Jeder Knoten merkt sich die Entfernung vom Beginn der Suche und eine Schätzung der Entfernung von diesem Knoten zum Ziel (diese Schätzung wird durch die <i>heuristische Funktion</i> berechnet).  Dank der heuristischen Funktion funktioniert A * - es lenkt den Algorithmus in die richtige Richtung. <br><br>  Im einfachsten Fall berechnet diese Funktion einfach den Abstand in einer geraden Linie vom Knoten zur Zielposition - dies ist der Ansatz, den wir in Factorio von Beginn der Entwicklung an verwendet haben, und dank dessen bewegt sich der Algorithmus zunächst in einer geraden Linie.  Dies ist jedoch nicht die einzige Option. Wenn die heuristische Funktion einige der Hindernisse kennt, kann sie den Algorithmus um sie herum lenken, was die Suche beschleunigen würde, da Sie die zusätzlichen Knoten nicht untersuchen müssten.  Je intelligenter die Heuristik ist, desto schwieriger ist es natürlich, sie umzusetzen. <br><br>  Eine einfache heuristische geradlinige Entfernungsschätzfunktion ist gut geeignet, um Pfade über relativ kurze Entfernungen zu finden.  Es passte zu uns in früheren Versionen von Factorio - fast immer bewegten sich Beißer über große Entfernungen, nur weil sie durch Verschmutzung wütend wurden, und dies geschah nicht sehr oft.  Wir haben jetzt jedoch Artillerie.  Artillerie kann leicht auf eine große Anzahl von Beißern auf der anderen Seite eines großen Sees schießen (und sie "bewirtschaften"), wonach sie versuchen, den Weg um den See herum zu ebnen.  Das folgende Video zeigt, wie der einfache A * -Algorithmus, den wir zuvor verwendet haben, versucht, den See zu umgehen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/giqW-sdGbhY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Dieses Video zeigt die Geschwindigkeit des Algorithmus in der Realität;</i>  <i>er wird nicht verlangsamt.</i> <br><br><h4>  Blockreduzierung </h4><br>  Das Finden eines Pfades ist eine lange Geschichte, und es gibt viele Techniken, um ihn zu verbessern.  Einige dieser Techniken gehören zur Kategorie der <i>hierarchischen Pfadsuche</i> : In diesem Fall wird die Karte zunächst vereinfacht, der Pfad befindet sich auf dieser vereinfachten Karte, die dann zum Auffinden des realen Pfades verwendet wird.  Ich wiederhole, es gibt mehrere spezifische Implementierungen einer solchen Technik, aber alle erfordern eine Vereinfachung des Suchraums. <br><br>  Wie können Sie die Welt von Factorio vereinfachen?  Unsere Karten werden zufällig generiert und ändern sich ständig: Das Platzieren und Löschen von Objekten (z. B. Sammlern, Wänden oder Türmen) ist wahrscheinlich die grundlegendste Mechanik des gesamten Spiels.  Wir möchten nicht jedes Mal, wenn wir eine Entität hinzufügen oder entfernen, die gesamte vereinfachte Karte neu erzählen.  Wenn wir die Karte jedes Mal neu vereinfachen, wenn wir einen Weg finden müssen, können wir gleichzeitig leicht den gesamten Leistungsgewinn verlieren. <br><br>  Eine der Personen mit Zugriff auf den Quellcode des Spiels (Allaizn) hatte eine Idee.  was ich als Ergebnis implementiert habe.  Nun scheint diese Idee offensichtlich. <br><br>  Das Spiel basiert auf Blöcken von 32x32 Plättchen.  Der Vereinfachungsprozess ersetzt jeden Block durch einen oder mehrere <i>abstrakte Knoten</i> .  Da unser Ziel darin besteht, die Suche nach einem Pfad um die Seen herum zu verbessern, können wir alle Entitäten ignorieren und nur Kacheln berücksichtigen: Sie können sich nicht auf dem Wasser bewegen, an Land können Sie.  Wir trennen jeden Block in separate <i>Komponenten</i> .  Eine Komponente ist ein Kachelbereich, in dem eine Einheit von einer Kachel innerhalb einer Komponente zu einer anderen Kachel derselben Komponente gelangen kann.  In der Abbildung unten ist der Block in zwei separate Komponenten unterteilt: Rot und Grün.  Jede dieser Komponenten wird zu einem abstrakten Knoten - tatsächlich wird der gesamte Block auf zwei „Punkte“ reduziert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/584/afe/ca9/584afeca9174cd544118ac41ea737c33.png"></div><br>  Der wichtigste Gedanke von Allaizn war, dass wir nicht für jede Kartenkachel eine Komponente speichern müssen - denken Sie nur an die Kachelkomponenten entlang des Umfangs jedes Blocks, da wir nur daran interessiert sind, mit welchen anderen Komponenten (in benachbarten Blöcken) jeder Komponente verbunden ist, und dies hängt nur von den Kacheln ab, die sich am Rand des Blocks befinden. <br><br><h4>  Hierarchische Pfadsuche </h4><br>  Wir haben also herausgefunden, wie man die Karte vereinfacht, aber wie man damit Pfade findet.  Wie gesagt, es gibt viele hierarchische Pfadsuchtechniken.  Die einfachste Idee ist, den Pfad mithilfe abstrakter Knoten vom Anfang bis zum Ziel zu finden. Das heißt, der Pfad ist eine Liste der Blockkomponenten, die Sie besuchen müssen.  Dann verwenden wir die Reihe guter alter Suchvorgänge A *, um genau herauszufinden, wie man von einer Komponente des Blocks zu einer anderen wechselt. <br><br>  Das Problem hierbei ist, dass wir die Karte zu stark vereinfacht haben: Was ist, wenn ein Wechsel von einem Block zum anderen nicht möglich ist, weil einige Objekte (z. B. Felsen) den Pfad blockieren?  Beim Reduzieren von Blöcken ignorieren wir alle Entitäten, daher wissen wir nur, dass die Kacheln zwischen den Blöcken irgendwie miteinander verbunden sind, aber wir wissen absolut nichts darüber, ob es möglich ist, von einem zum anderen zu wechseln. <br><br>  Die Lösung besteht darin, die Vereinfachung einfach als „Empfehlung“ für eine echte Suche zu verwenden.  Insbesondere werden wir damit eine intelligente Version der heuristischen Suchfunktion erstellen. <br><br>  Als Ergebnis haben wir das folgende Schema erhalten: Wir haben zwei Pfadfinder: den <i>Basispfadfinder</i> , der den realen Pfad findet, und den <i>abstrakten Pfadfinder</i> , der die heuristische Funktion für den Basispfadfinder bereitstellt.  Jedes Mal, wenn der Basispfadfinder einen neuen Basisknoten erstellt, ruft er einen abstrakten Pfadfinder auf, um eine Schätzung der Entfernung zum Ziel zu erhalten.  Der abstrakte Pfadfinder verhält sich in umgekehrter Reihenfolge - er beginnt mit dem Suchziel und ebnet den Weg zum Anfang, wobei er sich von einer Komponente des Blocks zur anderen bewegt.  Wenn eine abstrakte Suche den Block und die Komponente findet, in denen ein neuer Basisknoten erstellt wird, verwendet sie die Entfernung vom Beginn der abstrakten Suche (die, wie gesagt, die Zielposition der gesamten Suche ist), um eine Schätzung der Entfernung vom neuen Basisknoten zum allgemeinen Ziel zu berechnen. <br><br>  Die Ausführung des gesamten Pfadfinders für jeden einzelnen Knoten ist jedoch alles andere als schnell, selbst wenn sich der abstrakte Pfadfinder von einem Block zum anderen bewegt.  Daher verwenden wir stattdessen ein Schema namens "Reverse Resumable A *".  "Umkehren" bedeutet, dass es, wie ich oben sagte, vom Ziel bis zum Anfang ausgeführt wird.  "Erneuerbar" bedeutet, dass wir nach dem Auffinden eines Blocks, der für den Basispfadfinder interessant ist, alle seine Knoten im Speicher speichern.  Wenn der Basispfadfinder das nächste Mal einen neuen Knoten erstellt und eine Entfernungsschätzung benötigt, sehen wir uns nur die abstrakten Knoten an, die bei der vorherigen Suche gespeichert wurden.  Gleichzeitig besteht eine hohe Wahrscheinlichkeit, dass sich der erforderliche abstrakte Knoten noch im Speicher befindet (am Ende deckt ein abstrakter Knoten den größten Teil des Blocks und häufig den gesamten Block ab). <br><br>  Selbst wenn der Basispfadfinder einen Knoten erstellt, der sich in einem Block befindet, der von keinem der abstrakten Knoten abgedeckt wird, müssen wir nicht die gesamte abstrakte Suche erneut durchführen.  Ein praktisches Merkmal des A * -Algorithmus ist, dass er die Ausführung fortsetzt, selbst nachdem er die Arbeit beendet und einen Pfad gefunden hat, und die Knoten um die bereits untersuchten Knoten herum untersucht.  Und genau das tun wir, wenn wir eine Entfernungsschätzung für einen Basisknoten benötigen, der sich in einem Block befindet, der noch nicht von der abstrakten Suche abgedeckt wird: Wir setzen die abstrakte Suche von den im Speicher gespeicherten Knoten fort, bis sie zu dem von uns benötigten Knoten erweitert wird. <br><br>  Das folgende Video zeigt ein neues Pfadfindungssystem in Aktion.  Blaue Kreise sind abstrakte Knoten;  weiße Punkte - einfache Suche.  Der Pfadfinder im Video ist viel langsamer als das Spiel, um zu zeigen, wie es funktioniert.  Bei normaler Geschwindigkeit dauert die gesamte Suche nur wenige Ticks.  Beachten Sie, dass die einfache Suche, die immer noch den alten Algorithmus verwendet, den wir immer verwendet haben, einfach auf magische Weise „weiß“, wie man sich um den See bewegt. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/YHfoatMhvA0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Da der abstrakte Pfadfinder nur zum Erhalten einer heuristischen Schätzung der Entfernung verwendet wird, kann die Basissuche leicht von dem von der abstrakten Suche vorgeschlagenen Pfad abweichen.  Dies bedeutet, dass das Blockreduktionsschema zwar alle Entitäten ignoriert, der grundlegende Pfadfinder sie jedoch fast problemlos umgehen kann.  Da Entitäten bei der Vereinfachung der Karte ignoriert werden, müssen wir sie nicht jedes Mal wiederholen, wenn eine Entität hinzugefügt oder entfernt wird. Es reicht aus, nur die Kacheln abzudecken, die geändert wurden (z. B. bei einer Mülldeponie), was viel seltener vorkommt als beim Platzieren von Entitäten. <br><br>  Darüber hinaus bedeutet dies, dass wir im Wesentlichen denselben Pfadfinder verwenden, den wir seit Jahren verwenden. Nur die heuristische Funktion wurde aktualisiert.  Das heißt, diese Änderung wirkt sich nicht auf viele andere Systeme aus und wirkt sich nur auf die Suchgeschwindigkeit aus. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472366/">https://habr.com/ru/post/de472366/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472356/index.html">Microsoft vs IBM: Wichtige Änderungen in der Java-Unterstützung</a></li>
<li><a href="../de472358/index.html">30. Oktober um 17:00 Uhr Webinar „Bereitstellen des Kubernetes-Clusters in einer Stunde in der CROC-Cloud“</a></li>
<li><a href="../de472360/index.html">Scannen des Codes von Orchard CMS auf Fehler</a></li>
<li><a href="../de472362/index.html">Wir suchen und analysieren Fehler im Orchard CMS-Code</a></li>
<li><a href="../de472364/index.html">PostgreSQL- und Datensatzkonsistenzeinstellungen für jede bestimmte Verbindung</a></li>
<li><a href="../de472368/index.html">Sprachfischen: Wir analysieren Angriffsmethoden und Schutzmethoden gegen sie</a></li>
<li><a href="../de472372/index.html">Android-Automatisierung Super einfache Anleitung zum Erstellen Ihres ersten Espresso-Tests</a></li>
<li><a href="../de472374/index.html">Warum wir Server nach Island verlegt haben</a></li>
<li><a href="../de472378/index.html">Flash-Zuverlässigkeit: erwartet und unerwartet. Teil 2. XIV. Konferenz der USENIX Association. Dateispeichertechnologien</a></li>
<li><a href="../de472380/index.html">MIRO - eine offene Indoor-Roboterplattform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>