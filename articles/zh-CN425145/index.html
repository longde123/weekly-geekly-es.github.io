<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏻 🕺🏻 👩🏾‍🎓 如此出色 🛷 🧚🏾 🔛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Go 2中新的错误处理设计草案已于最近发布，令人欣喜的是，该语言并没有站在一起-它不断发展，并且每年都有突飞猛进的发展。 


 只有在这里，直到只有2走的是看到在地平线上，并等待它是非常痛苦和伤心。 因此，我们将事情掌握在自己手中。 一点点的代码生成，一点点的ast工作，随着手部恐慌的轻微移动，恐...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如此出色</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425145/"><p>  Go 2中新的错误处理设计草案已于最近发布，令人欣喜的是，该语言并没有站在一起-它不断发展，并且每年都有突飞猛进的发展。 </p><br><p> 只有在这里，直到只有2走的是看到在地平线上，并等待它是非常痛苦和伤心。 因此，我们将事情掌握在自己手中。 一点点的代码生成，一点点的ast工作，随着手部恐慌的轻微移动，恐慌就变成了优雅的异常！ </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0u/sd/fx/0usdfxkuqp9qtfe9biignfxdzxo.jpeg"></div><a name="habracut"></a><br><blockquote> 我想立即发表一个非常重要且绝对认真的声明。 <br> 该决定本质上是娱乐性和教学性的。 <br> 我的意思是只有4个乐趣。 实际上，这通常是概念证明。 我警告过：） </blockquote><br><h2 id="tak-chto-zhe-vyshlo"> 那么发生了什么 </h2><br><p> 结果是一个很小的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">库代码生成器</a> 。 众所周知，代码生成器内部包含善良和优雅。 实际上不是，但是在Go世界中，它们非常受欢迎。 </p><br><p>我们在原始环境中设置了这样的代码生成器。 他在标准<code>go/ast</code>模块的帮助下进行了解析，做了一些 <del> 不 </del> 狡猾的转换，结果写在文件旁边，并添加后缀<code>_jex.go</code> 。 生成的文件需要一个很小的运行时。 </p><br><p> 通过这种简单的方式，我们向Go添加了异常。 </p><br><h2 id="polzuem"> 我们用 </h2><br><p> 我们将生成器连接到文件，在文件头（在<code>package</code>之前）中编写 </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//+build jex //go:generate jex</span></span></code> </pre> <br><p> 如果现在运行命令<code>go generate -tags jex</code> ，则将执行<code>jex</code>实用程序。 她从<code>os.Getenv("GOFILE")</code>获取文件名，将其吃掉，消化并写入<code>{file}_jex.go</code> 。 新生文件的头中已经有<code>//+build !jex</code> （标记是反向的），因此<code>go build</code> ，并在其隔室中使用其他命令（例如<code>go test</code>或<code>go install</code>仅考虑<em>新的</em>正确文件。  Lepota ... </p><br><p> 现在点导入<code>github.com/anjensan/jex</code> 。 <br> 是的，虽然必须通过点导入。 将来计划保持不变。 </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/anjensan/jex"</span></span></code> </pre> <br><p> 太好了，现在您可以在代码中插入对存根函数<code>TRY</code> ， <code>THROW</code> ， <code>EX</code>调用。 出于所有这些原因，该代码在语法上仍然有效，甚至可以未经处理的形式进行编译（这根本行不通），因此可以使用自动补全<em>功能，</em>而lint <em>也不会真正</em>发誓。 如果这些功能只有一个，编辑者还将显示这些功能的文档。 </p><br><p> 引发异常 </p><br><pre> <code class="go hljs">THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"error name"</span></span>))</code> </pre> <br><p> 捕捉异常 </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { <span class="hljs-comment"><span class="hljs-comment">//   } else { fmt.Println(EX()) }</span></span></code> </pre> <br><p> 在后台生成一个匿名函数。 并且<code>defer</code> 。 它还有一个功能。 并且在<code>recover</code> ...好吧，仍然有一些不可思议的事情来处理<code>return</code>和<code>defer</code> 。 </p><br><p> 是的，顺便说一下，它们得到了支持！ </p><br><p> 此外，还有一个特殊的宏变量<code>ERR</code> 。 如果您为其分配错误，则会引发异常。 调用仍旧返回<code>error</code>函数会更容易 </p><br><pre> <code class="go hljs">file, ERR := os.Open(filename)</code> </pre> <br><p> 此外，有两个<code>ex</code>和<code>must</code>的小工具袋，但没什么可谈的。 </p><br><h2 id="primery"> 例子 </h2><br><p> 这是正确的，惯用的Go代码的示例 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src, dst </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { r, err := os.Open(src) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> r.Close() w, err := os.Create(dst) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, err := io.Copy(w, r); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { w.Close() os.Remove(dst) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := w.Close(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { os.Remove(dst) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } }</code> </pre> <br><p> 这段代码不是那么优雅。 顺便说一句，这不仅是我的意见！ <br> 但是<code>jex</code>将帮助我们改进它。 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src, dst </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> ex.Logf(<span class="hljs-string"><span class="hljs-string">"copy %s %s"</span></span>, src, dst) r, ERR := os.Open(src) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> r.Close() w, ERR := os.Create(dst) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { ERR := io.Copy(w, r) ERR := w.Close() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { w.Close() os.Remove(dst) THROW() } }</code> </pre> <br><p> 但是例如下面的程序 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { hex, err := ioutil.ReadAll(os.Stdin) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } data, err := parseHexdump(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(hex)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } os.Stdout.Write(data) }</code> </pre> <br><p> 可以改写成 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { hex, ERR := ioutil.ReadAll(os.Stdin) data, ERR := parseHexdump(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(hex)) os.Stdout.Write(data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { log.Fatal(EX()) } }</code> </pre> <br><p> 这是另一个示例，目的是更好地理解所提出的想法。 原始码 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { x, err := strconv.Atoi(a) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } y, err := strconv.Atoi(b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } fmt.Println(<span class="hljs-string"><span class="hljs-string">"result:"</span></span>, x + y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p> 可以改写成 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { x, ERR := strconv.Atoi(a) y, ERR := strconv.Atoi(b) fmt.Println(<span class="hljs-string"><span class="hljs-string">"result:"</span></span>, x + y) }</code> </pre> <br><p> 甚至那个 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"result:"</span></span>, must.Int_(strconv.Atoi(a)) + must.Int_(strconv.Atoi(b))) }</code> </pre> <br><h2 id="isklyuchenie"> 例外情况 </h2><br><p> 底线是<code>error</code>实例上的简单包装器结构。 </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> exception <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,   err error //  ^W , ,    log []interface{} //      ,    suppress []*exception }</span></span></code> </pre> <br><p> 重要的一点是，普通的紧急攻击不会被视为例外。 因此，所有标准错误（例如<code>runtime.TypeAssertionError</code>也不例外。 这符合Go中公认的最佳实践-如果我们有nil-dereference，那么我们会乐于乐意放弃整个过程。 可靠且可预测。 尽管我不确定，但也许值得回顾一下并找出此类错误。 也许是可选的？ </p><br><p> 这是一个异常链的例子 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">one_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"one"</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">two_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"two"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">three</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { one_() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { two_() } }</code> </pre> <br><p> 在这里，我们冷静地处理异常<code>one</code> ，因为突然坏了……并抛出了异常<code>two</code> 。 因此，源<code>one</code>在<code>suppress</code>字段中<code>suppress</code>附加到它。 什么都不会丢失，一切都会进入日志。 因此，不需要特别使用非常流行的<code>fmt.Errorf("blabla: %v", err)</code>模式<code>fmt.Errorf("blabla: %v", err)</code>将整个错误链直接推入消息文本中。 当然，如果您愿意，当然也没有人禁止在这里使用它。 </p><br><h2 id="kogda-zabyli-otlovit"> 什么时候忘了 </h2><br><p> 啊，另一个很重要的一点。 为了提高可读性，还有一个额外的检查：如果一个函数可以引发异常，则其名称必须以<code>_</code>结尾。 一个故意歪曲的名字会告诉程序员“尊敬的先生，在您的程序中这可能会出问题，请小心谨慎！” </p><br><p> 自动检查已转换的文件，也可以使用<code>jex-check</code>命令在项目中手动启动<code>jex-check</code> 。 将它与其他linter一起作为构建过程的一部分来运行也许是有意义的。 </p><br><p>  <code>//jex:nocheck</code>评论被<code>//jex:nocheck</code> 。 顺便说一下，这是从匿名函数引发异常的唯一方法。 </p><br><p> 当然，这并不是解决所有问题的灵丹妙药。  Checker会错过这个 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"ups"</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { f := bad_ f() }</code> </pre> <br><p> 另一方面，它并不比<code>err declared and not used</code>的标准检查差很多，这很容易规避。 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a, err := foo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } b, err := bar() <span class="hljs-comment"><span class="hljs-comment">//  ,    ok... go vet, ? }</span></span></code> </pre> <br><p> 总的来说，这个问题是很哲学的，当您忘记处理错误时最好做什么-安静地忽略它，或者引发恐慌...顺便说一句，可以通过在编译器中实现异常支持来达到测试的最佳结果，但这远远超出了本文的范围。 。 </p><br><p> 有人可能会说，尽管这是一个很棒的解决方案，但它不再是一个例外，因为现在例外意味着非常具体的实现。 好吧，那里是因为堆栈跟踪没有附加到异常，或者有一个单独的linter用于检查函数名称，或者该函数可以以<code>_</code>结尾但不引发异常，或者在语法上没有直接支持，或者确实很慌张，并且恐慌一点也不例外，因为唐蒲……孢子可能像毫无价值的毫无意义的一样热。 因此，我将把它们留在本文的框架之外，并且我将继续将所描述的解决方案称为“例外”。 </p><br><h2 id="po-povodu-stektreysov"> 关于Stackrace </h2><br><p> 通常，为了简化调试，开发人员会将堆栈跟踪粘贴到自定义<code>error</code>实现上。 甚至有几个流行的库。 但是，幸运的是，由于Go的一项有趣功能，除例外情况外，此操作不需要任何其他操作-在出现紧急情况时，在引发紧急情况的代码的堆栈上下文<code>defer</code>执行<code>defer</code>块。 因此在这里 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"ups"</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { foo_() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { debug.PrintStack() } }</code> </pre> <br><p> 将显示完整的堆栈跟踪，尽管有些冗长（我剪切了文件名） </p><br><pre> <code class="go hljs"> runtime/debug.Stack runtime/debug.PrintStack main.bar.func2 github.com/anjensan/jex/runtime.TryCatch.func1 <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span> main.foo_ main.bar.func1 github.com/anjensan/jex/runtime.TryCatch main.bar main.main</code> </pre> <br><p> 考虑到代理功能并隐藏它们以提高可读性，使您自己的帮助程序格式化/打印堆栈跟踪记录不会有什么坏处。 我认为这是个好主意。 </p><br><p> 或者，您可以使用<code>ex.Log()</code>抓住堆栈并将其附加到异常。 然后，将这样的异常转移到另一个horoutin中-strextrace不丢失。 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobar_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { e := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> error, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(e) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { checkZero_() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { EX().Log(debug.Stack()) <span class="hljs-comment"><span class="hljs-comment">//   e &lt;- EX().Wrap() //     } }() ex.Must_(&lt;-e) //  ,  ,  }</span></span></code> </pre> <br><h2 id="k-sozhaleniyu"> 不幸的是 </h2><br><p> 嗯...当然，这样的东西看起来会好得多 </p><br><pre> <code class="go hljs"> try { throw io.EOF, <span class="hljs-string"><span class="hljs-string">"some comment"</span></span> } catch e { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"exception: %v"</span></span>, e) }</code> </pre> <br><p> 但是，，Go的语法不可扩展。 <br>  [深思熟虑]尽管可能会变得更好... </p><br><p> 无论如何，你都必须变态。 另一种想法是使 </p><br><pre> <code class="go hljs"> TRY; { THROW(io.EOF, <span class="hljs-string"><span class="hljs-string">"some comment"</span></span>) }; CATCH; { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"exception: %v"</span></span>, EX) }</code> </pre> <br><p> 但是在<code>go fmt</code>之后，这样的代码显得有些愚蠢。 并且当编译器在两个分支中都看到<code>return</code>时发誓。  <code>if-TRY</code>没有这样的问题。 </p><br><p> 用<code>MUST</code>函数替换<code>ERR</code>宏是很酷的（不止于此）。 为了写 </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MUST(strconv.Atoi(a)) + MUST(strconv.Atoi(b))</code> </pre> <br><p> 原则上，这仍然可行，当分析as​​t时，您可以派生表达式的类型，因为所有类型的类型都会生成一个简单的包装函数，例如<code>must</code>包中声明的那些包装函数，然后将<code>MUST</code>替换为相应的替代函数的名称。 这不是完全无关紧要的，而是完全可能的。只有编辑器/ ide无法理解这样的代码。 毕竟， <code>MUST</code>存根函数的签名无法在Go类型系统中表达。 因此没有自动完成功能。 </p><br><h2 id="pod-kapotom"> 引擎盖下 </h2><br><p> 新导入将添加到所有处理的文件中。 </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _jex <span class="hljs-string"><span class="hljs-string">"github.com/anjensan/jex/runtime"</span></span></code> </pre> <br><p>  <code>panic(_jex.NewException(...))</code>调用<code>THROW</code>替换为<code>panic(_jex.NewException(...))</code> 。  <code>EX()</code>也将替换为包含捕获的异常的局部变量的名称。 </p><br><p> 但是， <code>if TRY() {..} else {..}</code>处理要复杂一些。 首先，对所有<code>return</code>和<code>defer</code>进行特殊处理。 然后将处理后的if分支放置在匿名函数中。 然后将这些函数传递给<code>_jex.TryCatch(..)</code> 。 这是 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"before"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a == <span class="hljs-number"><span class="hljs-number">0</span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"a == 0"</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> fmt.Printf(<span class="hljs-string"><span class="hljs-string">"a = %d\n"</span></span>, a) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ok"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"fail"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"hmm"</span></span> }</code> </pre> <br><p> 变成这样（我删除了<code>//line</code>注释）： </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_jex_r0 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, _jex_r1 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _jex_ret <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"before"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _jex_md2502 _jex.MultiDefer <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> _jex_md2502.Run() _jex.TryCatch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(_jex.NewException(errors.New(<span class="hljs-string"><span class="hljs-string">"a == 0"</span></span>))) } { _f, _p0, _p1 := fmt.Printf, <span class="hljs-string"><span class="hljs-string">"a = %d\n"</span></span>, a _jex_md2502.Defer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _f(_p0, _p1) }) } _jex_ret, _jex_r0, _jex_r1 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, a+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ok"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_jex_ex _jex.Exception)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> _jex.Suppress(_jex_ex) fmt.Println(<span class="hljs-string"><span class="hljs-string">"fail"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _jex_ret { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"hmm"</span></span> }</code> </pre><br><p> 很多，不是很漂亮，但是很有效。 好吧，不是全部，而且并非总是如此。 例如，您不能在TRY内进行<code>defer-recover</code> ，因为函数调用会变成一个额外的lambda。 </p><br><p> 另外，在显示ast树时，将显示选项“保存注释”。 因此，从理论上讲， <code>go/printer</code>应该打印它们。...老实说，事实是非常非常歪曲=）我不会举任何例子，只是歪曲。 原则上，如果您仔细指定所有ast节点的位置（现在它们为空），则可以完全解决此问题，但这绝对不包括在原型必需的清单中。 </p><br><h2 id="probuem"> 试一下 </h2><br><p> 出于好奇，我写了一个小<a href="">基准</a> 。 </p><br><p> 我们有一个木制的qsort实现，可以检查负载中的重复项。 发现-一个错误。 一个版本只是通过<code>return err</code>抛出它，另一个版本通过调用<code>fmt.Errorf</code>澄清错误。 还有一个使用异常。 我们对不同大小的切片进行排序，要么根本没有重复（没有错误，切片被完全排序），要么进行一次重复（排序中断大约一半，可以通过计时看到）。 </p><br><div class="spoiler">  <b class="spoiler_title">结果</b> <div class="spoiler_text"><pre> <code class="hljs powershell">~ &gt; cat /proc/cpuinfo | grep <span class="hljs-string"><span class="hljs-string">'model name'</span></span> | head <span class="hljs-literal"><span class="hljs-literal">-1</span></span> model name : Intel(R) Core(TM) i7<span class="hljs-literal"><span class="hljs-literal">-6700K</span></span> CPU <span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span> <span class="hljs-number"><span class="hljs-number">4.00</span></span>GHz ~ &gt; go version go version go1.<span class="hljs-number"><span class="hljs-number">11</span></span> linux/amd64 ~ &gt; go test <span class="hljs-literal"><span class="hljs-literal">-bench</span></span>=. github.com/anjensan/jex/demo goos: linux goarch: amd64 pkg: github.com/anjensan/jex/demo BenchmarkNoErrors/_____10/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">10000000</span></span> <span class="hljs-number"><span class="hljs-number">236</span></span> ns/op BenchmarkNoErrors/_____10/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000000</span></span> <span class="hljs-number"><span class="hljs-number">255</span></span> ns/op BenchmarkNoErrors/_____10/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000000</span></span> <span class="hljs-number"><span class="hljs-number">287</span></span> ns/op BenchmarkNoErrors/____100/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">3119</span></span> ns/op BenchmarkNoErrors/____100/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">3194</span></span> ns/op BenchmarkNoErrors/____100/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">3533</span></span> ns/op BenchmarkNoErrors/___1000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">30000</span></span> <span class="hljs-number"><span class="hljs-number">42356</span></span> ns/op BenchmarkNoErrors/___1000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">30000</span></span> <span class="hljs-number"><span class="hljs-number">42204</span></span> ns/op BenchmarkNoErrors/___1000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">30000</span></span> <span class="hljs-number"><span class="hljs-number">44465</span></span> ns/op BenchmarkNoErrors/__10000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-number"><span class="hljs-number">525864</span></span> ns/op BenchmarkNoErrors/__10000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-number"><span class="hljs-number">524781</span></span> ns/op BenchmarkNoErrors/__10000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-number"><span class="hljs-number">561256</span></span> ns/op BenchmarkNoErrors/_100000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">6309181</span></span> ns/op BenchmarkNoErrors/_100000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">6335135</span></span> ns/op BenchmarkNoErrors/_100000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">6687197</span></span> ns/op BenchmarkNoErrors/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">76274341</span></span> ns/op BenchmarkNoErrors/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">77806506</span></span> ns/op BenchmarkNoErrors/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">78019041</span></span> ns/op BenchmarkOneError/_____10/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2000000</span></span> <span class="hljs-number"><span class="hljs-number">712</span></span> ns/op BenchmarkOneError/_____10/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000000</span></span> <span class="hljs-number"><span class="hljs-number">268</span></span> ns/op BenchmarkOneError/_____10/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2000000</span></span> <span class="hljs-number"><span class="hljs-number">799</span></span> ns/op BenchmarkOneError/____100/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">2296</span></span> ns/op BenchmarkOneError/____100/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span> <span class="hljs-number"><span class="hljs-number">1809</span></span> ns/op BenchmarkOneError/____100/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">3529</span></span> ns/op BenchmarkOneError/___1000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">100000</span></span> <span class="hljs-number"><span class="hljs-number">21168</span></span> ns/op BenchmarkOneError/___1000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">100000</span></span> <span class="hljs-number"><span class="hljs-number">20747</span></span> ns/op BenchmarkOneError/___1000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50000</span></span> <span class="hljs-number"><span class="hljs-number">24560</span></span> ns/op BenchmarkOneError/__10000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-number"><span class="hljs-number">242077</span></span> ns/op BenchmarkOneError/__10000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-number"><span class="hljs-number">242376</span></span> ns/op BenchmarkOneError/__10000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-number"><span class="hljs-number">251043</span></span> ns/op BenchmarkOneError/_100000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">2753692</span></span> ns/op BenchmarkOneError/_100000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">2824116</span></span> ns/op BenchmarkOneError/_100000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">2845701</span></span> ns/op BenchmarkOneError/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">33452819</span></span> ns/op BenchmarkOneError/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">33374000</span></span> ns/op BenchmarkOneError/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">33705994</span></span> ns/op PASS ok github.com/anjensan/jex/demo <span class="hljs-number"><span class="hljs-number">64.008</span></span>s</code> </pre> </div></div><br><p> 如果尚未引发错误（代码稳定且经过具体处理），则带有异常引发的保证与<code>return err</code>和<code>fmt.Errorf</code>大致相当。 有时会快一点。 但是，如果引发了错误，则异常将排在第二位。 但这全都取决于“有用的工作/错误”的比率和堆栈的深度。 对于小片， <code>return err</code>领先于差距；对于大片和大片，异常已经等同于手动转发。 </p><br><p> 简而言之，如果错误极少发生，则异常甚至可以稍微加快代码的速度。 如果像其他所有人一样，那将是类似的事情。 但是，如果经常出现……则缓慢的例外远非最重要的问题，这值得担心。 </p><br><p> 作为测试，我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">迁移了一个</a>真正的gosh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">库</a>来排除异常。 </p><br><div class="spoiler">  <b class="spoiler_title">令我深感遗憾的是，重写1合1无效</b> <div class="spoiler_text"><p> 更确切地说，它本来可以证明，但是必须打扰。 </p><br><p> 因此，例如， <a href=""><code>rpc2XML</code></a>函数似乎返回<code>error</code> ……是的，它永远不会返回错误。 如果您尝试序列化不支持的数据类型-没有错误，则输出为空。 也许这就是原意吗？..不，良心不允许这样。 添加者 </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: THROW(fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"unsupported type %T"</span></span>, value))</code> </pre> <br><p> 但是事实证明，此功能是以特殊方式使用的 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rpcParams2XML</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rpc </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error buffer := <span class="hljs-string"><span class="hljs-string">"&lt;params&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; reflect.ValueOf(rpc).Elem().NumField(); i++ { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xml <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> buffer += <span class="hljs-string"><span class="hljs-string">"&lt;param&gt;"</span></span> xml, err = rpc2XML(reflect.ValueOf(rpc).Elem().Field(i).Interface()) buffer += xml buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/param&gt;"</span></span> } buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/params&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer, err }</code> </pre> <br><p> 在这里，我们遍历参数列表，将它们全部序列化，但<em>仅</em>针对后者返回错误。 其余错误将被忽略。 奇怪的行为变得更容易 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rpcParams2XML_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rpc </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { buffer := <span class="hljs-string"><span class="hljs-string">"&lt;params&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; reflect.ValueOf(rpc).Elem().NumField(); i++ { buffer += <span class="hljs-string"><span class="hljs-string">"&lt;param&gt;"</span></span> buffer += rpc2XML_(reflect.ValueOf(rpc).Elem().Field(i).Interface()) buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/param&gt;"</span></span> } buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/params&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer }</code> </pre> <br><p> 如果至少一个字段无法序列化-这是一个错误。 好吧，那更好。 但是事实证明，此功能也以<a href="">特殊</a>方式使用。 </p><br><pre> <code class="go hljs">xmlstr, _ = rpcResponse2XML(response)</code> </pre> <br><p> 同样，对于源代码来说，它并不是那么重要，因为会忽略错误。 我开始猜测为什么有些程序员<em>如此</em>喜欢通过<code>if err != nil</code>进行显式错误处理……但是除了例外，转发或处理都比忽略起来更容易 </p><br><pre> <code class="go hljs">xmlstr = rpcResponse2XML_(response)</code> </pre> <br><p> 而且我还没有开始删除“错误链”。 这是原始代码 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeClientResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader, reply </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { rawxml, err := ioutil.ReadAll(r) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FaultSystemError } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xml2RPC(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(rawxml), reply) }</code> </pre> <br><p> 这是改写的 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeClientResponse_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader, reply </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rawxml []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { rawxml, ERR = ioutil.ReadAll(r) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { THROW(FaultSystemError) } xml2RPC_(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(rawxml), reply) }</code> </pre> <br><p> 在这里，原始错误（ <code>ioutil.ReadAll</code>返回的错误）将不会丢失，它将附加到<code>suppress</code>字段中的异常中。 同样，它可以像原始版本一样进行，但是必须特别混淆... </p><br><p> 我重写了测试，将<code>if err != nil { log.Error(..) }</code>替换为简单的异常抛出。 不利的一面是-测试落在了第一个错误上，“至少在某种程度上”没有继续起作用。 根据思想，有必要将它们划分为子测试...总的来说，在任何情况下都值得做。 但是，获得正确的堆栈竞价非常容易 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorReporter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t testing.TB)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e error)</span></span></span></span> { t.Log(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(debug.Stack())) t.Fatal(e) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestRPC2XMLConverter_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> ex.Catch(errorReporter(t)) <span class="hljs-comment"><span class="hljs-comment">// ... xml := rpcRequest2XML_("Some.Method", req) }</span></span></code> </pre> <br><p> 通常，错误很容易忽略。 在原始代码中 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fault2XML</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fault Fault)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { buffer := <span class="hljs-string"><span class="hljs-string">"&lt;methodResponse&gt;&lt;fault&gt;"</span></span> xml, _ := rpc2XML(fault) buffer += xml buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/fault&gt;&lt;/methodResponse&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer }</code> </pre> <br><p> 在这里，来自<code>rpc2XML</code>的错误再次被<code>rpc2XML</code>忽略。 变成了这样 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fault2XML</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fault Fault)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { buffer := <span class="hljs-string"><span class="hljs-string">"&lt;methodResponse&gt;&lt;fault&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { buffer += rpc2XML_(fault) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"ERR: %v"</span></span>, EX()) buffer += <span class="hljs-string"><span class="hljs-string">"&lt;nil/&gt;"</span></span> } buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/fault&gt;&lt;/methodResponse&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer }</code> </pre> </div></div><br><p> 根据我个人的感觉，返回带有错误的“半成品”结果会更容易。 <br> 例如，半构建的响应。 异常更为复杂，因为该函数要么返回成功的结果，要么什么都不返回。 一种原子性。 另一方面，异常更难忽略或丢失异常链中的根本原因。 毕竟，您仍然必须专门尝试执行此操作。 出现错误时，这很容易自然发生。 </p><br><h2 id="vmesto-zaklyucheniya"> 而不是结论 </h2><br><p> 在<em>撰写</em>本文时，没有地鼠受伤。 </p><br><p> 感谢您提供的去夫酒的照片<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://migranov.ru</a> </p><br><p> 我无法在“编程”和“异常编程”中心之间进行选择。 <br> 两者都增加了一个非常困难的选择。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425145/">https://habr.com/ru/post/zh-CN425145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425135/index.html">为什么VoIP在美国被公认为信息服务，这对电信行业和用户意味着什么</a></li>
<li><a href="../zh-CN425137/index.html">我们在控制台中快速高效地工作</a></li>
<li><a href="../zh-CN425139/index.html">人工智能镜头下的流行歌星</a></li>
<li><a href="../zh-CN425141/index.html">“面对Guido您所说的话”或与Bobuk的Python对话</a></li>
<li><a href="../zh-CN425143/index.html">经济高等学校拒绝举办有利于在线课程的讲座</a></li>
<li><a href="../zh-CN425149/index.html">在天地之间</a></li>
<li><a href="../zh-CN425151/index.html">使用您的客户端窃听电报聊天</a></li>
<li><a href="../zh-CN425153/index.html">情感计算中三种最流行的情感误解</a></li>
<li><a href="../zh-CN425155/index.html">迷人的密码学或PHP中可逆加密的研究</a></li>
<li><a href="../zh-CN425157/index.html">在线与CLRium＃4 +上的.Net社区会面。 CoreCLR和C＃的去向。 邀请所有人</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>