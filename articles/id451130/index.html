<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âºï¸ ğŸš¸ ğŸš Swift: ARC dan manajemen memori ğŸ§‘ğŸ¼â€ğŸ¤â€ğŸ§‘ğŸ¼ ğŸ›ŒğŸ¿ ğŸ‘²ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menjadi bahasa tingkat tinggi modern, Swift pada dasarnya menangani manajemen memori dalam aplikasi Anda, mengalokasikan dan membebaskan memori. Ini k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift: ARC dan manajemen memori</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451130/"> Menjadi bahasa tingkat tinggi modern, <b>Swift</b> pada dasarnya menangani manajemen memori dalam aplikasi Anda, mengalokasikan dan membebaskan memori.  Ini karena mekanisme yang disebut <b>Penghitungan Referensi Otomatis</b> , atau <b>ARC</b> .  Dalam panduan ini, Anda akan mempelajari cara kerja ARC dan cara mengelola memori dengan benar di Swift.  Memahami mekanisme ini, Anda bisa memengaruhi umur objek yang terletak di heap ( <b>heap</b> ). <br><br>  Dalam panduan ini, Anda akan membangun pengetahuan Anda tentang Swift dan ARC dengan mempelajari yang berikut: <br><br><ul><li>  bagaimana ARC bekerja </li><li>  apa itu <b>siklus referensi</b> dan bagaimana cara memperbaikinya dengan benar </li><li>  cara membuat loop tautan contoh </li><li>  Cara menemukan loop tautan menggunakan alat visual yang ditawarkan oleh Xcode </li><li>  bagaimana menangani jenis referensi dan tipe nilai </li></ul><a name="habracut"></a><br><h2>  Memulai </h2><br>  Unduh <a href="" rel="nofollow">bahan sumbernya.</a>  Buka proyek di folder <b>Siklus / Pemula</b> .  Pada bagian pertama panduan kami, memahami konsep-konsep utama, kami akan menangani secara eksklusif file t <b>MainViewController.swif</b> . <br><br>  Tambahkan kelas ini di bagian bawah MainViewController.swift: <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"User \(name) was initialized"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Deallocating user named: \(name)"</span></span>) } }</code> </pre> <br>  Kelas <b>Pengguna</b> didefinisikan di sini, yang, dengan bantuan pernyataan <b>cetak</b> , memberi sinyal kepada kami tentang inisialisasi dan rilis instance kelas. <br><br>  Sekarang buat instance kelas Pengguna di bagian atas MainViewController. <br><br>  Tempatkan kode ini sebelum metode <b>viewDidLoad ()</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-type"><span class="hljs-type">User</span></span>(name: <span class="hljs-string"><span class="hljs-string">"John"</span></span>)</code> </pre> <br>  Luncurkan aplikasi.  Buat konsol Xcode terlihat dengan <b>Command-Shift-Y</b> untuk melihat output dari pernyataan cetak. <br><br>  Perhatikan bahwa <b>User John diinisialisasi</b> muncul di konsol, tetapi pernyataan cetak di dalam <b>deinit</b> tidak dieksekusi.  Ini berarti bahwa objek ini tidak dirilis, karena tidak keluar dari <b>ruang lingkup</b> . <br><br>  Dengan kata lain, hingga view controller yang berisi objek ini keluar dari cakupan, objek tidak akan pernah dibebaskan. <br><br><h2>  Apakah dia dalam ruang lingkup? </h2><br>  Dengan membungkus instance dari kelas Pengguna dalam suatu metode, kami akan mengizinkannya keluar dari ruang lingkup, sehingga memungkinkan ARC untuk membebaskannya. <br><br>  Mari kita buat metode <b>runScenario ()</b> di dalam kelas MainViewController dan pindahkan inisialisasi instance kelas Pengguna di dalamnya. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runScenario</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-type"><span class="hljs-type">User</span></span>(name: <span class="hljs-string"><span class="hljs-string">"John"</span></span>) }</code> </pre><br>  runScenario () mendefinisikan ruang lingkup instance Pengguna.  Saat keluar dari zona ini, <b>pengguna</b> harus dibebaskan. <br><br>  Sekarang panggil runScenario () menambahkan ini di akhir viewDidLoad (): <br><br><pre> <code class="swift hljs">runScenario()</code> </pre> <br>  Luncurkan aplikasi.  Output konsol sekarang terlihat seperti ini: <br><br>  Pengguna John diinisialisasi <br>  Deallocating pengguna bernama: John <br><br>  Ini berarti bahwa Anda telah merilis objek yang telah meninggalkan bidang tampilan. <br><br><h2>  Seumur hidup objek </h2><br><br>  Keberadaan objek dibagi menjadi lima tahap: <br><br><ul><li>  alokasi memori: dari tumpukan atau dari tumpukan </li><li>  inisialisasi: kode dieksekusi di dalam init </li><li>  penggunaan </li><li>  deinitialization: kode dieksekusi di dalam deinit </li><li>  memori bebas: memori yang dialokasikan dikembalikan ke tumpukan atau tumpukan </li></ul><br>  Tidak ada cara langsung untuk melacak langkah-langkah mengalokasikan dan membebaskan memori, tetapi Anda dapat menggunakan kode di dalam init dan deinit. <br><br>  <b>Jumlah referensi</b> , juga dikenal sebagai <b>jumlah penggunaan</b> , menentukan kapan suatu objek tidak lagi dibutuhkan.  Penghitung ini menunjukkan jumlah mereka yang "menggunakan" objek ini.  Objek menjadi tidak perlu saat penghitung penggunaan nol.  Kemudian objek tersebut diinisialisasi dan dirilis. <br><br><img src="https://habrastorage.org/webt/b5/oo/78/b5oo78ealf173ey0ayz7rngnszk.png"><br><br>  Ketika objek Pengguna diinisialisasi, jumlah referensi adalah 1, karena konstanta <b>pengguna</b> merujuk ke objek ini. <br><br>  Pada akhir runScenario (), pengguna keluar dari ruang lingkup dan jumlah referensi dikurangi menjadi 0. Akibatnya, pengguna tidak diinisialisasi dan kemudian dibebaskan. <br><br><h2>  Siklus Referensi </h2><br>  Dalam kebanyakan kasus, ARC berfungsi sebagaimana mestinya.  Pengembang biasanya tidak perlu khawatir tentang kebocoran memori ketika benda yang tidak digunakan tetap tidak terisi tanpa batas. <br><br>  Tapi tidak selalu!  Kemungkinan memori bocor. <br><br>  Bagaimana ini bisa terjadi?  Bayangkan sebuah situasi di mana dua benda tidak lagi digunakan, tetapi masing-masing merujuk pada yang lain.  Karena setiap jumlah referensi bukan 0, tidak satupun dari mereka akan dibebaskan. <br><br><img src="https://habrastorage.org/webt/hd/zp/ff/hdzpffk1eh3rug0fgmgnlghnb3q.png"><br><br>  Ini adalah <b>siklus referensi yang kuat</b> .  Situasi ini membingungkan ARC dan tidak memungkinkannya untuk menghapus memori. <br><br>  Seperti yang Anda lihat, jumlah referensi di akhir bukan 0, dan meskipun tidak diperlukan lagi objek, object1 dan object2 tidak akan dibebaskan. <br><br><h2>  Lihat tautan kami </h2><br>  Untuk menguji semua ini dalam tindakan, tambahkan kode ini setelah kelas Pengguna di MainViewController.swift: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phone</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> model: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> owner: <span class="hljs-type"><span class="hljs-type">User?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(model: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.model = model <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Phone \(model) was initialized"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Deallocating phone named: \(model)"</span></span>) } }</code> </pre> <br>  Kode ini menambahkan kelas <b>Telepon</b> baru dengan dua properti, satu untuk model dan satu untuk pemilik, serta metode init dan deinit.  Properti pemilik adalah opsional, karena ponsel mungkin tidak memiliki pemilik. <br><br>  Sekarang tambahkan baris ini ke runScenario (): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iPhone = <span class="hljs-type"><span class="hljs-type">Phone</span></span>(model: <span class="hljs-string"><span class="hljs-string">"iPhone Xs"</span></span>)</code> </pre><br>  Ini akan membuat instance kelas Phone. <br><br><h2>  Pegang ponsel </h2><br>  Sekarang tambahkan kode ini ke kelas Pengguna, segera setelah properti nama: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> phones: [<span class="hljs-type"><span class="hljs-type">Phone</span></span>] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(phone: Phone)</span></span></span></span> { phones.append(phone) phone.owner = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> }</code> </pre><br>  Tambahkan array ponsel yang dimiliki oleh pengguna.  Setter ditandai sebagai pribadi, jadi tambahkan (telepon :) harus digunakan. <br><br>  Luncurkan aplikasi.  Seperti yang Anda lihat, turunan dari objek Telepon dan objek Pengguna dibebaskan sesuai kebutuhan. <br><br>  Pengguna John diinisialisasi <br>  Telepon iPhone XS diinisialisasi <br>  Deallocating phone bernama: iPhone Xs <br>  Deallocating pengguna bernama: John <br><br>  Sekarang tambahkan ini di akhir runScenario (): <br><pre> <code class="swift hljs">user.add(phone: iPhone)</code> </pre> <br><br>  Di sini kami menambahkan iPhone kami ke daftar ponsel yang dimiliki oleh <b>pengguna</b> , dan juga mengatur properti <b>pemilik</b> ponsel ke ' <b>pengguna</b> '. <br><br>  Jalankan aplikasi lagi.  Anda akan melihat bahwa objek pengguna dan iPhone tidak dirilis.  Siklus hubungan yang kuat di antara mereka mencegah ARC untuk melepaskannya. <br><br><img src="https://habrastorage.org/webt/lo/az/mu/loazmuamyoww2ttr7wnwcd8_n4w.png"><br><br><h2>  Tautan Lemah </h2><br>  Untuk memutus siklus tautan kuat, Anda dapat menetapkan hubungan antara objek sebagai lemah. <br><br>  Secara default, semua tautan kuat dan penugasan mengarah ke peningkatan jumlah referensi.  Saat menggunakan referensi yang lemah, jumlah referensi tidak bertambah. <br><br>  Dengan kata lain, <b>tautan lemah tidak memengaruhi manajemen kehidupan suatu objek</b> .  Tautan lemah selalu dinyatakan <b>opsional</b> .  Dengan begitu, saat jumlah tautan menjadi 0, tautan dapat disetel ke nol. <br><br><img src="https://habrastorage.org/webt/ti/qd/kc/tiqdkcyfstrndd8xswpf8zfebfo.png"><br><br>  Dalam ilustrasi ini, garis putus-putus menunjukkan tautan lemah.  Perhatikan bahwa jumlah referensi objek1 adalah 1, karena variabel1 merujuknya.  Jumlah referensi objek2 adalah 2, karena direferensikan oleh variabel2 dan objek1. <br><br>  object2 juga mereferensikan object1, tetapi <b>WEAK</b> , yang artinya tidak mempengaruhi jumlah referensi dari object1. <br><br>  Ketika variabel1 dan variabel2 dibebaskan, object1 memiliki jumlah referensi 0, yang membebaskannya.  Ini, pada gilirannya, melepaskan referensi kuat ke object2, yang sudah mengarah ke rilisnya. <br><br>  Di kelas Telepon, ubah deklarasi properti pemilik sebagai berikut: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> owner: <span class="hljs-type"><span class="hljs-type">User?</span></span></code> </pre> <br>  Dengan mendeklarasikan referensi properti pemilik sebagai 'lemah', kami memutus loop tautan kuat antara kelas Pengguna dan Telepon. <br><br><img src="https://habrastorage.org/webt/ym/ax/_m/ymax_mv9cvlpi8xqwnxmb14vr2g.png"><br><br>  Luncurkan aplikasi.  Sekarang pengguna dan ponsel dilepaskan dengan benar. <br><br><h2>  Tautan yang Tidak Dimiliki </h2><br>  Ada juga pengubah tautan lain yang tidak menambah jumlah referensi: <b>tidak dimiliki</b> . <br><br>  Apa perbedaan antara yang <b>tidak dimiliki</b> dan yang <b>lemah</b> ?  Referensi yang lemah selalu opsional dan secara otomatis menjadi nol ketika objek yang direferensikan dirilis. <br><br>  Inilah sebabnya mengapa kita harus mendeklarasikan properti lemah sebagai variabel opsional tipe: properti ini harus berubah. <br><br>  Tautan yang tidak dimiliki, sebaliknya, tidak pernah opsional.  Jika Anda mencoba mengakses properti yang tidak dimiliki yang merujuk ke objek yang dibebaskan, Anda mendapatkan kesalahan yang terlihat seperti gaya membuka bungkus yang berisi variabel nil (paksaan membuka bungkus). <br><br><img src="https://habrastorage.org/webt/i9/hf/bc/i9hfbcizzk2eg38s_hidjq3evju.png"><br><br>  Ayo coba terapkan yang <b>tidak dimiliki</b> . <br><br>  Tambahkan kelas <b>CarrierSubscription</b> baru di akhir MainViewController.swift: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarrierSubscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> countryCode: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user: <span class="hljs-type"><span class="hljs-type">User</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>, countryCode: <span class="hljs-type"><span class="hljs-type">String</span></span>, number: <span class="hljs-type"><span class="hljs-type">String</span></span>, user: <span class="hljs-type"><span class="hljs-type">User</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.countryCode = countryCode <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.number = number <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.user = user <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"CarrierSubscription \(name) is initialized"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Deallocating CarrierSubscription named: \(name)"</span></span>) } }</code> </pre> <br>  CarrierSubscription memiliki empat properti: <br><br>  Nama: nama penyedia. <br>  CountryCode: kode negara. <br>  Nomor: nomor telepon. <br>  Pengguna: tautan ke pengguna. <br><br><h2>  Siapa penyedia Anda? </h2><br>  Sekarang tambahkan ini ke kelas Pengguna setelah properti nama: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscriptions: [<span class="hljs-type"><span class="hljs-type">CarrierSubscription</span></span>] = []</code> </pre> <br>  Di sini kami menyimpan berbagai penyedia pengguna. <br><br>  Sekarang tambahkan ini ke kelas Phone, setelah properti pemilik: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> carrierSubscription: <span class="hljs-type"><span class="hljs-type">CarrierSubscription?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(carrierSubscription: CarrierSubscription)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.carrierSubscription = carrierSubscription } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decommission</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { carrierSubscription = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Ini menambahkan properti CarrierSubscription opsional dan dua metode untuk mendaftarkan dan membatalkan pendaftaran ponsel dengan penyedia. <br><br>  Sekarang tambahkan kelas CarrierSubscription di dalam metode init, tepat sebelum pernyataan cetak: <br><br><pre> <code class="swift hljs">user.subscriptions.append(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre> <br>  Kami menambahkan CarrierSubscription ke array penyedia pengguna. <br><br>  Terakhir, tambahkan ini di akhir metode runScenario (): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscription = <span class="hljs-type"><span class="hljs-type">CarrierSubscription</span></span>( name: <span class="hljs-string"><span class="hljs-string">"TelBel"</span></span>, countryCode: <span class="hljs-string"><span class="hljs-string">"0032"</span></span>, number: <span class="hljs-string"><span class="hljs-string">"31415926"</span></span>, user: user) iPhone.provision(carrierSubscription: subscription)</code> </pre> <br>  Kami membuat langganan ke penyedia untuk pengguna dan menghubungkan telepon ke sana. <br><br>  Luncurkan aplikasi.  Di konsol Anda akan melihat: <br><br>  Pengguna John diinisialisasi <br>  Telepon iPhone X diinisialisasi <br>  CarrierSubscription TelBel diinisialisasi <br><br>  Dan lagi siklus tautan!  pengguna, iPhone, dan berlangganan tidak gratis pada akhirnya. <br><br>  Bisakah Anda menemukan masalah? <br><br><img src="https://habrastorage.org/webt/uu/fg/eq/uufgeqkvqa31jwwlsnlikc-iob8.png"><br><br><h2>  Memutuskan rantai </h2><br>  Tautan dari pengguna ke langganan atau tautan dari langganan ke pengguna harus tidak dimiliki untuk memutus perulangan.  Pertanyaannya adalah opsi mana yang harus dipilih.  Mari kita lihat strukturnya. <br><br>  Pengguna memiliki langganan ke penyedia, tetapi sebaliknya - tidak, langganan ke penyedia tidak memiliki pengguna. <br><br>  Selain itu, tidak ada gunanya keberadaan CarrierSubscription tanpa referensi ke pengguna yang memilikinya. <br><br>  Karena itu, tautan pengguna harus tidak dimiliki. <br><br>  Ubah deklarasi pengguna di CarrierSubscription: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user: <span class="hljs-type"><span class="hljs-type">User</span></span></code> </pre><br>  Sekarang pengguna tidak dimiliki, yang memecah loop tautan dan memungkinkan Anda untuk membebaskan semua objek. <br><br><img src="https://habrastorage.org/webt/en/vx/cu/envxcuihbevfcfqv1cyg-kc3lo4.png"><br><br><h2>  Loop link dalam penutupan </h2><br>  Tautan siklus untuk objek terjadi ketika objek memiliki properti yang saling referensi.  Seperti objek, penutupan adalah tipe referensi, dan dapat menyebabkan loop referensi.  Penutupan menangkap objek yang mereka gunakan. <br><br>  Misalnya, jika Anda menetapkan penutupan ke properti kelas, dan penutupan ini menggunakan properti dari kelas yang sama, maka kami mendapatkan loop tautan.  Dengan kata lain, objek memegang tautan ke penutupan melalui properti.  Penutupan berisi referensi ke objek melalui nilai diri yang ditangkap. <br><br><img src="https://habrastorage.org/webt/z-/lh/ow/z-lhowlkfyvy4ycusafxhygjisw.png"><br><br>  Tambahkan kode ini ke CarrierSubscription segera setelah properti pengguna: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completePhoneNumber: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.countryCode + <span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.number }</code> </pre><br>  Penutupan ini menghitung dan mengembalikan nomor telepon lengkap.  Properti dinyatakan <b>malas</b> , properti akan ditetapkan pada penggunaan pertama. <br><br>  Ini diperlukan karena menggunakan self.countryCode dan self.number, yang tidak akan tersedia sampai kode initializer dijalankan. <br><br>  Tambahkan runScenario () ke akhir: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(subscription.completePhoneNumber())</code> </pre> <br>  Memanggil completePhoneNumber () akan menjalankan penutupan. <br><br>  Luncurkan aplikasi dan Anda akan melihat bahwa pengguna dan iPhone dilepaskan, tetapi CarrierSubscription tidak, karena siklus tautan yang kuat antara objek dan penutupan. <br><br><img src="https://habrastorage.org/webt/7t/rb/ax/7trbaxtrrhtadtm29-dvqwehzo4.png"><br><br><h2>  Daftar Tangkapan </h2><br>  Swift menyediakan cara sederhana dan elegan untuk memutus perulangan tautan yang kuat dalam penutupan.  Anda mendeklarasikan daftar tangkap di mana Anda menentukan hubungan antara penutupan dan objek yang ditangkapnya. <br><br>  Untuk mendemonstrasikan daftar penangkapan, pertimbangkan kode berikut: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> someClosure = { [x] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(x), \(y)"</span></span>) } x = <span class="hljs-number"><span class="hljs-number">6</span></span> y = <span class="hljs-number"><span class="hljs-number">6</span></span> someClosure() <span class="hljs-comment"><span class="hljs-comment">// Prints 5, 6 print("\(x), \(y)") // Prints 6, 6</span></span></code> </pre> <br>  x ada dalam daftar capture penutupan, sehingga nilai x disalin ke definisi penutupan.  Itu ditangkap oleh nilai. <br><br>  y tidak ada dalam daftar tangkap, ia ditangkap dengan referensi.  Ini berarti bahwa nilai y akan seperti apa pada saat rangkaian itu dipanggil. <br><br>  Daftar kunci membantu mengidentifikasi interaksi yang lemah atau tidak dimiliki sehubungan dengan objek yang ditangkap dalam loop.  Dalam kasus kami, pilihan yang sesuai tidak dimiliki, karena penutupan tidak dapat terjadi jika turunan CarrierSubscription dilepaskan. <br><br><h2>  Pegang dirimu </h2><br>  Ganti definisi CompletePhoneNumber dengan CarrierSubscription :: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completePhoneNumber: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.countryCode + <span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.number }</code> </pre> <br>  Kami menambahkan <b>[diri yang tidak dimiliki]</b> ke daftar penangkapan penutupan.  Ini berarti bahwa kami menangkap <b>diri</b> sebagai tautan yang <b>tidak dimiliki</b> alih-alih yang kuat. <br><br>  Luncurkan aplikasi dan Anda akan melihat bahwa CarrierSubscription sekarang dirilis. <br><br>  Faktanya, sintaksis di atas adalah bentuk pendek yang lebih panjang dan lebih lengkap di mana variabel baru muncul: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closure = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> newID = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">// Use unowned newID here... }</span></span></code> </pre> <br>  Di sini newID adalah salinan diri yang tidak dimiliki.  Di luar penutupan, diri tetap ada.  Dalam formulir singkat yang diberikan sebelumnya, kami <b>membuat variabel diri baru</b> yang mengaburkan diri yang ada di dalam penutupan. <br><br><h2>  Gunakan yang tidak dimiliki dengan hati-hati </h2><br>  Dalam kode Anda, hubungan antara diri dan completePhoneNumber ditetapkan sebagai tidak dimiliki. <br><br>  Jika Anda yakin bahwa objek yang digunakan dalam penutupan tidak akan dirilis, Anda dapat menggunakan yang tidak dimiliki.  Jika ya, Anda dalam masalah! <br><br>  Tambahkan kode ini di akhir MainViewController.swift: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WWDCGreeting</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> who: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(who: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.who = who } <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello \(self.who)."</span></span> } }</code> </pre><br>  Sekarang inilah akhir dari runScenario (): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mermaid = <span class="hljs-type"><span class="hljs-type">WWDCGreeting</span></span>(who: <span class="hljs-string"><span class="hljs-string">"caffeinated mermaid"</span></span>) greetingMaker = mermaid.greetingMaker } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(greetingMaker()) <span class="hljs-comment"><span class="hljs-comment">// !</span></span></code> </pre> <br>  Buka aplikasi dan Anda akan melihat crash dan sesuatu seperti itu di konsol: <br><br>  Pengguna John diinisialisasi <br>  Telepon iPhone XS diinisialisasi <br>  CarrierSubscription TelBel diinisialisasi <br>  0032 31415926 <br>  Kesalahan fatal: Mencoba membaca referensi yang tidak dimiliki tetapi objek 0x600000f0de30 sudah dibatalkan alokasi2019-02-24 12: 29: 40.744248-0600 Siklus [33489: 5926466] Kesalahan fatal: Mencoba membaca referensi yang tidak dikenal tetapi objek 0x600000f0de30 sudah dibatalkan alokasinya <br><br>  Pengecualian terjadi karena penutupan menunggu untuk diri sendiri. Siapa yang ada, tetapi itu dirilis segera setelah putri duyung keluar dari ruang lingkup pada akhir blok do. <br><br>  Contoh ini mungkin terlihat tersedot dari jari, tetapi hal-hal seperti itu terjadi.  Misalnya, ketika kita menggunakan penutupan untuk memulai sesuatu nanti, katakanlah, setelah panggilan asinkron di jaringan berakhir. <br><br><h2>  Meredakan perangkap </h2><br>  Ganti pembuat ucapan di kelas WWDCGreeting dengan ini: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello \(self?.who)."</span></span> }</code> </pre> <br>  Kami melakukan dua hal: pertama, kami mengganti yang tidak dimiliki dengan yang lemah.  Kedua, karena diri telah menjadi lemah, kita mengakses milik siapa melalui diri?  Abaikan peringatan Xcode, kami akan segera memperbaikinya. <br><br>  Aplikasi tidak lagi macet, tetapi jika Anda menjalankannya, kami mendapatkan hasil yang lucu: "Halo nil." <br><br>  Mungkin hasilnya cukup dapat diterima, tetapi seringkali kita perlu melakukan sesuatu jika objek itu dibebaskan.  Ini bisa dilakukan dengan menggunakan pernyataan penjaga. <br><br>  Ganti teks penutup dengan ini: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"No greeting available."</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello \(self.who)."</span></span> }</code> </pre><br>  Pernyataan penjaga menetapkan diri yang diambil dari diri yang lemah.  Jika diri nihil, penutupan kembali "Tidak ada salam."  Kalau tidak, diri menjadi referensi yang kuat, sehingga objek dijamin hidup sampai akhir penutupan. <br><br><h2>  Mencari loop tautan di Xcode 10 </h2><br>  Sekarang setelah Anda memahami cara kerja ARC, apa itu loop tautan dan bagaimana cara memecahnya, inilah saatnya untuk melihat contoh aplikasi nyata. <br><br>  Buka proyek Starter yang terletak di folder Kontak. <br><br>  Luncurkan aplikasi. <br><br><img src="https://habrastorage.org/webt/a8/ce/l1/a8cel1rgbdkm_fel_d880f2swf4.png"><br><br>  Ini adalah pengelola kontak paling sederhana.  Coba klik pada kontak, tambahkan beberapa yang baru. <br><br>  Penugasan File: <br><br>  ContactsTableViewController: menampilkan semua kontak. <br>  DetailViewController: menampilkan informasi terperinci dari kontak yang dipilih. <br>  NewContactViewController: memungkinkan Anda untuk menambahkan kontak baru. <br>  ContactTableViewCell: sel tabel menampilkan detail kontak. <br>  Kontak: model kontak. <br>  Nomor: model nomor telepon. <br><br>  Namun, dengan proyek ini, semuanya buruk: ada siklus tautan.  Pada awalnya, pengguna tidak akan melihat masalah karena ukuran kecil dari memori yang bocor, untuk alasan yang sama sulit untuk menemukan kebocoran. <br><br>  Untungnya, Xcode 10 memiliki alat bawaan untuk menemukan kebocoran memori terkecil. <br><br>  Luncurkan aplikasi lagi.  Hapus 3-4 kontak menggunakan gesek ke kiri dan tombol hapus.  Sepertinya mereka benar-benar menghilang, kan? <br><br><img src="https://habrastorage.org/webt/xu/d9/qf/xud9qf3rcyaf5ot_08l8vauizto.png"><br><br><h2>  Di mana itu mengalir? </h2><br>  Ketika aplikasi sedang berjalan, klik tombol Debug Memory Graph: <br><br><img src="https://habrastorage.org/webt/la/na/km/lanakmzc0d2ousrcf5jwkpu-ova.png"><br><br>  Amati Masalah Runtime di navigator Debug.  Mereka ditandai dengan kotak ungu dengan tanda seru putih di dalamnya: <br><br><img src="https://habrastorage.org/webt/uc/ko/vj/uckovjp_eqoplopih79xuz1jl7e.png"><br><br>  Pilih salah satu objek Kontak yang bermasalah di navigator.  Siklusnya terlihat jelas: Kontak dan objek Nomor, merujuk satu sama lain, tahan. <br><br><img src="https://habrastorage.org/webt/7f/wi/os/7fwios8n7zdk4ww7bj81p4kvgle.png"><br><br>  Sepertinya Anda harus melihat ke dalam kode.  Perlu diingat bahwa kontak dapat ada tanpa nomor, tetapi tidak sebaliknya. <br><br>  Bagaimana Anda menyelesaikan loop ini?  Tautan dari Kontak ke Nomor atau dari Nomor ke Kontak?  lemah atau tidak dimiliki?  Coba sendiri dulu! <br><br><div class="spoiler">  <b class="spoiler_title">Jika Anda membutuhkan bantuan ...</b> <div class="spoiler_text">  Ada 2 solusi yang mungkin: membuat tautan dari Kontak ke Nomor lemah, atau dari Nomor ke Kontak tidak dimiliki. <br><br>  Dokumentasi Apple merekomendasikan bahwa objek induk memiliki referensi yang kuat untuk "anak" - bukan sebaliknya.  Ini berarti bahwa kami memberikan Kontak referensi kuat ke Nomor, dan Nomor - tautan yang tidak dimiliki ke Kontak: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contact: <span class="hljs-type"><span class="hljs-type">Contact</span></span> <span class="hljs-comment"><span class="hljs-comment">// Other code... } class Contact { var number: Number? // Other code... }</span></span></code> </pre> <br></div></div><br><h2>  Bonus: loop dengan tipe referensi dan tipe nilai. </h2><br>  Swift memiliki tipe referensi (kelas dan penutupan) dan tipe nilai (struktur, enumerasi).  Jenis nilai disalin ketika diteruskan, dan tipe referensi berbagi nilai yang sama menggunakan tautan. <br><br>  Ini berarti bahwa dalam hal tipe nilai, tidak ada siklus.  Agar perulangan dapat terjadi, kita membutuhkan setidaknya 2 jenis referensi. <br><br>  Mari kita kembali ke proyek Cycles dan menambahkan kode ini di akhir MainViewController.swift: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Error var payload = 0 var next: Node? }</span></span></code> </pre><br>  Tidak akan bekerja!  Struktur adalah tipe nilai dan tidak dapat memiliki rekursi pada instance itu sendiri.  Kalau tidak, struktur seperti itu akan memiliki ukuran yang tak terbatas. <br><br>  Ubah struktur ke kelas. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> payload = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> next: <span class="hljs-type"><span class="hljs-type">Node?</span></span> }</code> </pre> <br>  Referensi itu sendiri cukup dapat diterima untuk kelas (tipe referensi), sehingga kompiler tidak memiliki masalah. <br><br>  Sekarang tambahkan ini di akhir MainViewController.swift: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> friends: [<span class="hljs-type"><span class="hljs-type">Person</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"New person instance: \(name)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Person instance \(name) is being deallocated"</span></span>) } }</code> </pre> <br>  Dan ini di akhir runScenario (): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ernie = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Ernie"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bert = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Bert"</span></span>) ernie.friends.append(bert) <span class="hljs-comment"><span class="hljs-comment">// Not deallocated bert.friends.append(ernie) // Not deallocated }</span></span></code> </pre><br>  Luncurkan aplikasi.  Harap dicatat: ernie atau bert tidak dirilis. <br><br><h2>  Tautan dan makna </h2><br>  Ini adalah contoh kombinasi tipe referensi dan tipe nilai yang mengarah ke loop tautan. <br><br>  ernie dan bert tetap tidak dirilis, memegang satu sama lain di array teman mereka, meskipun array itu sendiri adalah tipe nilai. <br><br>  Cobalah untuk membuat arsip teman sebagai tidak dimiliki, dan Xcode akan menunjukkan kesalahan: tidak dimiliki hanya berlaku untuk kelas. <br><br>  Untuk memperbaiki loop ini, kita harus membuat objek wrapper dan menggunakannya untuk menambahkan instance ke array. <br><br>  Tambahkan definisi berikut sebelum kelas Person: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unowned</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyObject</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> (<span class="hljs-number"><span class="hljs-number">_</span></span> value: <span class="hljs-type"><span class="hljs-type">T</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value = value } }</code> </pre><br>  Kemudian ubah definisi teman di kelas Person: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> friends: [<span class="hljs-type"><span class="hljs-type">Unowned</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Person</span></span>&gt;] = []</code> </pre> <br>  Akhirnya, ganti konten blok do di runScenario (): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ernie = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Ernie"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bert = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Bert"</span></span>) ernie.friends.append(<span class="hljs-type"><span class="hljs-type">Unowned</span></span>(bert)) bert.friends.append(<span class="hljs-type"><span class="hljs-type">Unowned</span></span>(ernie)) }</code> </pre> <br>  Luncurkan aplikasi, sekarang ernie dan bert dirilis dengan benar! <br><br>  Array teman tidak lagi merupakan kumpulan objek Orang.  Ini sekarang adalah <b>kumpulan objek yang tidak</b> dimiliki yang berfungsi sebagai pembungkus untuk instance Person. <br><br>  Untuk mendapatkan objek Orang dari Tidak Dimiliki, gunakan properti nilai: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstFriend = bert.friends.first?.value <span class="hljs-comment"><span class="hljs-comment">// get ernie</span></span></code> </pre> <br><h2>  Kesimpulan </h2><br>  Anda sekarang memiliki pemahaman yang baik tentang manajemen memori di Swift dan Anda tahu cara kerja ARC.  Saya harap publikasi ini bermanfaat bagi Anda. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Apple: Penghitungan Referensi Otomatis</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451130/">https://habr.com/ru/post/id451130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451116/index.html">Bagaimana saya bergumul dengan Transisi Elemen Bersama dan menulis perpustakaan opensource pertama saya</a></li>
<li><a href="../id451118/index.html">Pengujian bukan untuk pemula</a></li>
<li><a href="../id451120/index.html">Tentang tantangan memindahkan Sel Mati ke platform seluler</a></li>
<li><a href="../id451124/index.html">Pengembangan protein di cloud menggunakan Python dan Transcriptic atau Cara membuat protein apa saja seharga $ 360</a></li>
<li><a href="../id451126/index.html">Kotak Alat untuk Peneliti - Edisi Satu: Organisasi Mandiri dan Visualisasi Data</a></li>
<li><a href="../id451132/index.html">Kontrak yang Didorong oleh Konsumen atau otomatisasi tes QA bermata Gitlab CI</a></li>
<li><a href="../id451136/index.html">Diperkenalkan oleh .NET 5</a></li>
<li><a href="../id451138/index.html">Symfony CLI - Alat Pengembangan Lokal Baru</a></li>
<li><a href="../id451140/index.html">Berapa Biayanya Untuk Membuat Solusi IoT?</a></li>
<li><a href="../id451144/index.html">Antiquities: Teknik dalam Iklan TV</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>