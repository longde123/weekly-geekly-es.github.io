<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏻 👨🏼‍🤝‍👨🏻 💂 Mengumumkan TypeScript 3.4 RC 💂 🚴🏽 👩🏽‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa hari yang lalu kami mengumumkan ketersediaan kandidat rilis kami (RC) dari TypeScript 3.4. Harapan kami adalah untuk mengumpulkan umpan balik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengumumkan TypeScript 3.4 RC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/443996/"><p>  Beberapa hari yang lalu kami mengumumkan ketersediaan kandidat rilis kami (RC) dari TypeScript 3.4.  Harapan kami adalah untuk mengumpulkan umpan balik dan masalah awal untuk memastikan rilis akhir kami mudah untuk diambil dan digunakan segera. </p><br><p>  Untuk mulai menggunakan RC, Anda bisa mendapatkannya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">melalui NuGet</a> , atau menggunakan npm dengan perintah berikut: </p><br><pre><code class="javascript hljs">npm install -g typescript@rc</code> </pre> <br><p>  Anda juga dapat memperoleh dukungan editor dengan </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Mengunduh untuk Visual Studio 2017</a> (untuk versi 15.2 atau lebih baru) </li><li>  Mengikuti arahan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Visual Studio Code</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sublime Text</a> . </li></ul><br><p>  Mari menjelajahi apa yang baru dalam 3.4! </p><br><img src="https://habrastorage.org/webt/rh/0u/3d/rh0u3dh_1qkmnyia12ksyuuozso.jpeg"><a name="habracut"></a><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel ini di blog kami.</a> <br><br><h2>  <code>--incremental</code> selanjutnya yang lebih cepat dengan bendera <code>--incremental</code> </h2><br><p>  Karena file TypeScript dikompilasi, itu memperkenalkan langkah menengah antara menulis dan menjalankan kode Anda.  Salah satu tujuan kami adalah untuk meminimalkan waktu yang dibuat mengingat perubahan apa pun pada program Anda.  Salah satu cara untuk melakukannya adalah dengan menjalankan TypeScript dalam mode <code>--watch</code> .  Ketika file berubah dalam mode <code>--watch</code> , TypeScript dapat menggunakan grafik dependensi proyek Anda yang telah dibangun sebelumnya untuk menentukan file mana yang berpotensi terpengaruh dan perlu diperiksa ulang dan berpotensi dipancarkan kembali.  Ini dapat menghindari pengecekan tipe-penuh dan memancarkan kembali yang bisa mahal. </p><br><p>  Tapi itu tidak realistis untuk mengharapkan <em>semua</em> pengguna untuk menjaga <code>tsc --watch</code> proses <code>tsc --watch</code> berjalan semalam hanya untuk membangun lebih cepat besok pagi.  Bagaimana dengan cold build?  Selama beberapa bulan terakhir, kami telah berupaya untuk melihat apakah ada cara untuk menyimpan informasi yang sesuai dari mode <code>--watch</code> ke file dan menggunakannya dari build hingga build. </p><br><p>  TypeScript 3.4 memperkenalkan flag baru bernama <code>--incremental</code> yang memberitahu TypeScript untuk menyimpan informasi tentang grafik proyek dari kompilasi terakhir.  Saat berikutnya TypeScript dipanggil dengan <code>--incremental</code> , itu akan menggunakan informasi itu untuk mendeteksi cara paling murah untuk mengetik-periksa dan memancarkan perubahan pada proyek Anda. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tsconfig.json { "compilerOptions": { "incremental": true, "outDir": "./lib" }, "include": ["./src"] }</span></span></code> </pre> <br><p>  Secara default dengan pengaturan ini, ketika kita menjalankan <code>tsc</code> , TypeScript akan mencari file bernama <code>.tsbuildinfo</code> di direktori output kami ( <code>./lib</code> ).  Jika <code>./lib/.tsbuildinfo</code> tidak ada, itu akan dihasilkan.  Tetapi jika ya, <code>tsc</code> akan mencoba menggunakan file itu untuk secara bertahap mengetikkan dan memperbarui file output kami. </p><br><p>  File <code>.tsbuildinfo</code> ini dapat dihapus dengan aman dan tidak berdampak pada kode kami saat runtime - mereka murni digunakan untuk membuat kompilasi lebih cepat.  Kita juga dapat memberi nama mereka apa pun yang kita inginkan, dan menempatkannya di mana saja yang kita inginkan menggunakan flag <code>--tsBuildInfoFile</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// front-end.tsconfig.json { "compilerOptions": { "incremental": true, "tsBuildInfoFile": "./buildcache/front-end", "outDir": "./lib" }, "include": ["./src"] }</span></span></code> </pre> <br><p>  Selama tidak ada orang lain yang mencoba menulis ke file cache yang sama, kita harus dapat menikmati build dingin inkremental yang lebih cepat. </p><br><h3>  Proyek komposit </h3><br><p>  Bagian dari maksud dengan proyek komposit ( <code>tsconfig.json</code> 's dengan set <code>composite</code> ke <code>true</code> ) adalah bahwa referensi antara proyek yang berbeda dapat dibangun secara bertahap.  Dengan demikian, proyek komposit akan <strong>selalu</strong> menghasilkan file <code>.tsbuildinfo</code> . </p><br><h3> <code>outFile</code> </h3> <br><p>  Ketika <code>outFile</code> digunakan, nama file informasi build akan didasarkan pada nama file output.  Sebagai contoh, jika file JavaScript output kami adalah <code>./output/foo.js</code> , maka di bawah flag --incremental, TypeScript akan menghasilkan file <code>./output/foo.tsbuildinfo</code> .  Seperti di atas, ini dapat dikontrol dengan flag <code>--tsBuildInfoFile</code> . </p><br><h3>  Format file dan versi - <code>--incremental</code> </h3><br><p>  Meskipun file yang dihasilkan oleh <code>--incremental</code> adalah JSON, file tersebut tidak berarti dikonsumsi oleh alat lain.  Kami tidak dapat memberikan jaminan stabilitas untuk isinya, dan pada kenyataannya, kebijakan kami saat ini adalah bahwa salah satu versi dari TypeScript tidak akan mengerti file <code>.tsbuildinfo</code> dihasilkan dari versi lain. </p><br><h2>  Perbaikan untuk <code>ReadonlyArray</code> dan <code>readonly</code> tuple </h2><br><p>  TypeScript 3.4 membuatnya sedikit lebih mudah untuk menggunakan tipe read-only array-like. </p><br><h3>  Sintaks baru untuk <code>ReadonlyArray</code> </h3><br><p>  Tipe <code>ReadonlyArray</code> menggambarkan <code>Array</code> s yang hanya dapat dibaca.  Variabel apa pun dengan pegangan ke <code>ReadonlyArray</code> tidak dapat menambah, menghapus, atau mengganti elemen array apa pun. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr: ReadonlyArray&lt;string&gt;</span></span></span><span class="hljs-function">) </span></span>{ arr.slice(); <span class="hljs-comment"><span class="hljs-comment">// okay arr.push("hello!"); // error! }</span></span></code> </pre> <br><p>  Meskipun sering kali merupakan praktik yang baik untuk menggunakan <code>ReadonlyArray</code> atas <code>Array</code> untuk tujuan maksud, sering kali terasa menyakitkan karena array memiliki sintaks yang lebih bagus.  Secara khusus, <code>number[]</code> adalah versi singkatan dari <code>Array&lt;number&gt;</code> , sama seperti <code>Date[]</code> adalah singkatan untuk <code>Array&lt;Date&gt;</code> . </p><br><p>  TypeScript 3.4 memperkenalkan sintaks baru untuk <code>ReadonlyArray</code> menggunakan pengubah <code>readonly</code> baru untuk tipe array. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr: readonly string[]</span></span></span><span class="hljs-function">) </span></span>{ arr.slice(); <span class="hljs-comment"><span class="hljs-comment">// okay arr.push("hello!"); // error! }</span></span></code> </pre> <br><h3>  tuple <code>readonly</code> </h3><br><p>  TypeScript 3.4 juga memperkenalkan dukungan baru untuk tuple <code>readonly</code> .  Kita dapat mengawali setiap jenis tuple dengan kata kunci <code>readonly</code> untuk menjadikannya tuple <code>readonly</code> , seperti halnya kita sekarang dapat dengan sintaksis array shorthand.  Seperti yang Anda duga, tidak seperti tuple biasa yang slotnya dapat ditulis, tuple <code>readonly</code> hanya mengizinkan pembacaan dari posisi itu. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pair: readonly [string, string]</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(pair[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// okay pair[1] = "hello!"; // error }</span></span></code> </pre> <br><p>  Cara yang sama dengan tupel biasa adalah tipe yang memanjang dari <code>Array</code> - tuple dengan elemen tipe <code>T</code> <sub><code>1</code></sub> , <code>T</code> <sub><code>2</code></sub> , ... <code>T</code> <sub><code>n</code></sub> memanjang dari <code>Array&lt;</code> <code>T</code> <sub><code>1</code></sub> |  <code>T</code> <sub><code>2</code></sub> |  ... <code>T</code> <sub><code>n</code></sub> <code>&gt;</code> - <code>readonly</code> tuple adalah tipe yang diperluas dari <code>ReadonlyArray</code> .  Jadi tuple <code>readonly</code> dengan elemen <code>T</code> <sub><code>1</code></sub> , <code>T</code> <sub><code>2</code></sub> , ... <code>T</code> <sub><code>n</code></sub> memanjang dari <code>ReadonlyArray&lt;</code> <code>T</code> <sub><code>1</code></sub> |  <code>T</code> <sub><code>2</code></sub> |  ... <code>T</code> <sub><code>n</code></sub> <code>&gt;</code> . </p><br><h3>  pengubah tipe <code>readonly</code> dipetakan dan array <code>readonly</code> </h3><br><p>  Dalam versi sebelumnya dari TypeScript, kami menggeneralisasi tipe yang dipetakan untuk beroperasi secara berbeda pada tipe array-like.  Ini berarti bahwa tipe yang dipetakan seperti <code>Boxify</code> dapat bekerja pada array dan tuple. </p><br><pre> <code class="javascript hljs">interface Box&lt;T&gt; { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: T } type Boxify&lt;T&gt; = { [K <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> keyof T]: Box&lt;T[K]&gt; } <span class="hljs-comment"><span class="hljs-comment">// { a: Box&lt;string&gt;, b: Box&lt;number&gt; } type A = Boxify&lt;{ a: string, b: number }&gt;; // Array&lt;Box&lt;number&gt;&gt; type B = Boxify&lt;number[]&gt;; // [Box&lt;string&gt;, Box&lt;number&gt;] type C = Boxify&lt;[string, boolean]&gt;;</span></span></code> </pre> <br><p>  Sayangnya, tipe yang dipetakan seperti tipe utilitas <code>Readonly</code> secara efektif no-ops pada tipe array dan tuple. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// lib.d.ts type Readonly&lt;T&gt; = { readonly [K in keyof T]: T[K] } // How code acted *before* TypeScript 3.4 // { readonly a: string, readonly b: number } type A = Readonly&lt;{ a: string, b: number }&gt;; // number[] type B = Readonly&lt;number[]&gt;; // [string, boolean] type C = Readonly&lt;[string, boolean]&gt;;</span></span></code> </pre> <br><p>  Dalam TypeScript 3.4, pengubah <code>readonly</code> dalam tipe yang dipetakan akan secara otomatis mengkonversi tipe seperti array ke rekan <code>readonly</code> sesuai. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// How code acts now *with* TypeScript 3.4 // { readonly a: string, readonly b: number } type A = Readonly&lt;{ a: string, b: number }&gt;; // readonly number[] type B = Readonly&lt;number[]&gt;; // readonly [string, boolean] type C = Readonly&lt;[string, boolean]&gt;;</span></span></code> </pre> <br><p>  Demikian pula, Anda dapat menulis jenis utilitas seperti jenis dipetakan <code>Writable</code> yang menghapus readness -ness, dan yang akan mengkonversi wadah array <code>readonly</code> kembali ke setara mereka yang bisa berubah. </p><br><pre> <code class="javascript hljs">type Writable&lt;T&gt; = { -readonly [K <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> keyof T]: T[K] } <span class="hljs-comment"><span class="hljs-comment">// { a: string, b: number } type A = Writable&lt;{ readonly a: string; readonly b: number }&gt;; // number[] type B = Writable&lt;readonly number[]&gt;; // [string, boolean] type C = Writable&lt;readonly [string, boolean]&gt;;</span></span></code> </pre> <br><h3>  Peringatan </h3><br><p>  Terlepas dari kemunculannya, pengubah tipe hanya- <code>readonly</code> hanya dapat digunakan untuk sintaks pada tipe array dan tipe tuple.  Ini bukan tipe operator tujuan umum. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> err1: readonly <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>&lt;number&gt;; <span class="hljs-comment"><span class="hljs-comment">// error! let err2: readonly Array&lt;boolean&gt;; // error! let okay: readonly boolean[]; // works fine</span></span></code> </pre> <br><h2>  pernyataan <code>const</code> </h2><br><p>  Ketika mendeklarasikan variabel atau properti yang bisa berubah, TypeScript sering <em>memperluas</em> nilai untuk memastikan bahwa kita dapat menetapkan hal-hal nanti tanpa menulis tipe eksplisit. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// hurray! we can assign to 'x' later on! x = "world";</span></span></code> </pre> <br><p>  Secara teknis, setiap nilai literal memiliki tipe literal.  Di atas, tipe <code>"hello"</code> diperlebar ke <code>string</code> tipe sebelum menyimpulkan tipe untuk <code>x</code> . </p><br><p>  Salah satu pandangan alternatif mungkin mengatakan bahwa <code>x</code> memiliki tipe literal asli <code>"hello"</code> dan bahwa kita tidak dapat menetapkan <code>"world"</code> nanti seperti: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x: <span class="hljs-string"><span class="hljs-string">"hello"</span></span> = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// error! x = "world";</span></span></code> </pre> <br><p>  Dalam hal ini, itu tampak ekstrem, tetapi dapat berguna dalam situasi lain.  Sebagai contoh, TypeScripters sering membuat objek yang dimaksudkan untuk digunakan dalam serikat yang didiskriminasi. </p><br><pre> <code class="javascript hljs">type Shape = | { <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">"circle"</span></span>, <span class="hljs-attr"><span class="hljs-attr">radius</span></span>: number } | { <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">"square"</span></span>, <span class="hljs-attr"><span class="hljs-attr">sideLength</span></span>: number } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShapes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readonly</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shape</span></span></span><span class="hljs-function">[] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = [ { <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">"circle"</span></span>, <span class="hljs-attr"><span class="hljs-attr">radius</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">"square"</span></span>, <span class="hljs-attr"><span class="hljs-attr">sideLength</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span>, }, ]; <span class="hljs-comment"><span class="hljs-comment">// Some terrible error message because TypeScript inferred // 'kind' to have the type 'string' instead of // either '"circle"' or '"square"'. return result; }</span></span></code> </pre> <br><p>  Mutability adalah salah satu heuristik niat terbaik yang TypeScript dapat gunakan untuk menentukan kapan harus melebar (daripada menganalisis seluruh program kami). </p><br><p>  Sayangnya, seperti yang kita lihat pada contoh terakhir, dalam properti JavaScript bisa berubah secara default.  Ini berarti bahwa bahasa tersebut akan sering memperluas jenis yang tidak diinginkan, membutuhkan jenis eksplisit di tempat-tempat tertentu. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShapes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readonly</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shape</span></span></span><span class="hljs-function">[] </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// This explicit annotation gives a hint // to avoid widening in the first place. let result: readonly Shape[] = [ { kind: "circle", radius: 100, }, { kind: "square", sideLength: 50, }, ]; return result; }</span></span></code> </pre> <br><p>  Sampai pada titik tertentu ini tidak apa-apa, tetapi karena struktur data kami menjadi semakin kompleks, ini menjadi rumit. </p><br><p>  Untuk mengatasi ini, TypeScript 3.4 memperkenalkan konstruksi baru untuk nilai-nilai literal yang disebut pernyataan <em><code>const</code></em> .  Sintaksnya adalah pernyataan tipe dengan <code>const</code> menggantikan nama tipe (mis. <code>123 as const</code> ).  Ketika kita membangun ekspresi literal baru dengan pernyataan <code>const</code> , kita dapat memberi sinyal ke bahasa itu </p><br><ul><li>  tidak ada tipe literal dalam ekspresi yang harus diperlebar (mis. tidak beralih dari <code>"hello"</code> ke <code>string</code> ) </li><li>  objek literal mendapatkan properti hanya <code>readonly</code> </li><li>  array literal menjadi tupel hanya <code>readonly</code> </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Type '10' let x = 10 as const; // Type 'readonly [10, 20]' let y = [10, 20] as const; // Type '{ readonly text: "hello" }' let z = { text: "hello" } as const;</span></span></code> </pre> <br><p>  Di luar file <code>.tsx</code> , sintaks pernyataan braket sudut juga dapat digunakan. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Type '10' let x = &lt;const&gt;10; // Type 'readonly [10, 20]' let y = &lt;const&gt;[10, 20]; // Type '{ readonly text: "hello" }' let z = &lt;const&gt;{ text: "hello" };</span></span></code> </pre> <br><p>  Fitur ini sering berarti bahwa tipe-tipe yang seharusnya digunakan hanya untuk mengisyaratkan ketidakberubahan pada kompiler seringkali dapat dihilangkan. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Works with no types referenced or declared. // We only needed a single const assertion. function getShapes() { let result = [ { kind: "circle", radius: 100, }, { kind: "square", sideLength: 50, }, ] as const; return result; } for (const shape of getShapes()) { // Narrows perfectly! if (shape.kind === "circle") { console.log("Circle radius", shape.radius); } else { console.log("Square side length", shape.sideLength); } }</span></span></code> </pre> <br><p>  Perhatikan penjelasan di atas tidak diperlukan jenis.  Pernyataan <code>const</code> memungkinkan TypeScript untuk mengambil tipe ekspresi yang paling spesifik. </p><br><h3>  Peringatan </h3><br><p>  Satu hal yang perlu diperhatikan adalah bahwa pernyataan <code>const</code> hanya dapat diterapkan segera pada ekspresi literal sederhana. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Error! // A 'const' assertion can only be applied to a string, number, boolean, array, or object literal. let a = (Math.random() &lt; 0.5 ? 0 : 1) as const; // Works! let b = Math.random() &lt; 0.5 ? 0 as const : 1 as const;</span></span></code> </pre> <br><p>  Hal lain yang perlu diingat adalah bahwa konteks <code>const</code> tidak segera mengubah ekspresi menjadi tidak berubah sepenuhnya. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> foo = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, <span class="hljs-attr"><span class="hljs-attr">contents</span></span>: arr, }; foo.name = <span class="hljs-string"><span class="hljs-string">"bar"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// error! foo.contents = []; // error! foo.contents.push(5); // ...works!</span></span></code> </pre> <br><h2>  Ketik-periksa untuk <code>globalThis</code> </h2><br><p>  Bisa jadi sangat sulit untuk mengakses atau mendeklarasikan nilai dalam lingkup global, mungkin karena kita sedang menulis kode kita dalam modul (yang deklarasi lokalnya tidak bocor secara default), atau karena kita mungkin memiliki variabel lokal yang membayangi nama nilai global.  Di lingkungan yang berbeda, ada berbagai cara untuk mengakses apa yang secara efektif ruang lingkup global - <code>global</code> di Node, <code>window</code> , <code>self</code> , atau <code>frames</code> di browser, atau <code>this</code> di lokasi tertentu di luar mode ketat.  Tidak ada yang jelas, dan sering membuat pengguna merasa tidak yakin apakah mereka menulis kode yang benar. </p><br><p>  TypeScript 3.4 memperkenalkan dukungan untuk pengecekan tipe-global ECMAScript baru ini - variabel global yang mengacu pada cakupan global.  Berbeda dengan solusi di atas, <code>globalThis</code> memberikan cara standar untuk mengakses ruang lingkup global yang dapat digunakan di berbagai lingkungan. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// in a global file: let abc = 100; // Refers to 'abc' from above. globalThis.abc = 200;</span></span></code> </pre> <br><p>  <code>globalThis</code> juga dapat mencerminkan apakah variabel global dideklarasikan sebagai <code>const</code> dengan memperlakukannya sebagai properti hanya <code>readonly</code> saat diakses. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> answer = <span class="hljs-number"><span class="hljs-number">42</span></span>; globalThis.answer = <span class="hljs-number"><span class="hljs-number">333333</span></span>; <span class="hljs-comment"><span class="hljs-comment">// error!</span></span></code> </pre> <br><p>  Penting untuk dicatat bahwa TypeScript tidak mengubah referensi ke <code>globalThis</code> ketika mengkompilasi ke versi ECMAScript yang lebih lama.  Dengan demikian, kecuali Anda menargetkan browser yang selalu hijau (yang sudah mendukung <code>globalThis</code> ), Anda mungkin ingin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan polyfill yang sesuai</a> sebagai gantinya. </p><br><h2>  Konversikan ke parameter bernama </h2><br><p>  Terkadang, daftar parameter mulai menjadi berat. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateOptions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> hue?: number, saturation?: number, brightness?: number, positionX?: number, positionY?: number positionZ?: number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// .... }</span></span></code> </pre> <br><p>  Dalam contoh di atas, terlalu mudah bagi penelepon untuk mencampur urutan argumen yang diberikan.  Pola JavaScript yang umum adalah sebagai gantinya menggunakan "objek opsi", sehingga setiap opsi secara eksplisit diberi nama dan urutan tidak pernah masalah.  Ini mengemulasi fitur yang oleh bahasa lain disebut "parameter bernama". </p><br><pre> <code class="javascript hljs">interface Options { hue?: number, saturation?: number, brightness?: number, positionX?: number, positionY?: number positionZ?: number } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateOptions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options: Options = {}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// .... }</span></span></code> </pre> <br><p>  Tim TypeScript tidak hanya bekerja pada kompiler - kami juga menyediakan fungsionalitas yang editor gunakan untuk fitur yang kaya seperti penyelesaian, pergi ke definisi, dan refactor.  Dalam TypeScript 3.4, staf magang kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gabriela Britto</a> telah menerapkan refactoring baru untuk mengonversi fungsi yang ada untuk menggunakan pola "bernama parameter" ini. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer"><img src="https://habrastorage.org/getpro/habr/post_images/f33/305/761/f3330576172c94151d7e13408c82a418.gif" alt="Refactoring sedang diterapkan ke fungsi untuk membuatnya mengambil parameter bernama."></a> </p><br><p>  Meskipun kami dapat mengubah nama fitur dengan rilis final 3.4 kami dan kami percaya mungkin ada ruang untuk beberapa ergonomi, kami akan senang bagi Anda untuk mencoba fitur tersebut dan memberi kami umpan balik Anda. </p><br><h2>  Memecah perubahan </h2><br><h3>  Level <code>this</code> ini sekarang diketik </h3><br><p>  Jenis tingkat <code>this</code> ini sekarang diketik sebagai jenis <code>typeof globalThis</code> bukan <code>any</code> .  Sebagai konsekuensinya, Anda mungkin menerima kesalahan untuk mengakses nilai yang tidak diketahui pada <code>this</code> bawah <code>noImplicitAny</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// previously okay in noImplicitAny, now an error this.whargarbl = 10;</span></span></code> </pre> <br><p>  Perhatikan bahwa kode yang dikompilasi di bawah <code>noImplicitThis</code> tidak akan mengalami perubahan apa pun di sini. </p><br><h3>  Argumen tipe umum yang disarankan </h3><br><p>  Dalam kasus-kasus tertentu, inferensi TypeScript 3.4 yang ditingkatkan mungkin menghasilkan fungsi yang generik, bukan yang mengambil dan mengembalikan kendala mereka (biasanya <code>{}</code> ). </p><br><pre> <code class="javascript hljs">declare <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">U</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">V</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f: (arg: T</span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">U</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-function">: (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg: U</span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">V</span></span></span><span class="hljs-function">): (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg: T</span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">V</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x: T</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [x]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">box</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value: T</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { value }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f = compose(list, box); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = f(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-comment"><span class="hljs-comment">// In TypeScript 3.4, 'x.value' has the type // // number[] // // but it previously had the type // // {}[] // // So it's now an error to push in a string. x.value.push("hello");</span></span></code> </pre> <br><p>  Anotasi jenis eksplisit pada <code>x</code> dapat menghilangkan kesalahan. </p><br><h2>  Apa selanjutnya </h2><br><p>  TypeScript 3.4 adalah rilis pertama kami yang memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rencana iterasi yang</a> menguraikan rencana kami untuk rilis ini, yang dimaksudkan untuk menyelaraskan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peta jalan 6 bulan kami</a> .  Anda dapat mengawasi keduanya, dan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman roadmap fitur</a> bergulir kami untuk pekerjaan yang akan datang. </p><br><p>  Saat ini kami sedang menantikan untuk mendengar tentang pengalaman Anda dengan RC, jadi cobalah sekarang dan beri tahu kami pendapat Anda! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443996/">https://habr.com/ru/post/id443996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443986/index.html">Seperti tupai di roda atau sedikit tentang penelitian pengguna dalam pengaturan cacat</a></li>
<li><a href="../id443988/index.html">Arsitektur Microservice = Komputasi Terdistribusi</a></li>
<li><a href="../id443990/index.html">13 game baru diperkenalkan sebagai bagian dari program ID @ Xbox</a></li>
<li><a href="../id443992/index.html">Membangun Game dengan MonoGame</a></li>
<li><a href="../id443994/index.html">Kandidat presiden AS mengusulkan untuk memecah bisnis Amazon, Google, dan Facebook untuk mendorong persaingan</a></li>
<li><a href="../id443998/index.html">Rekor dunia baru untuk menghitung jumlah pi: 31,4 triliun karakter</a></li>
<li><a href="../id444000/index.html">Mulai dari mana saat mempekerjakan staf untuk pertama kalinya</a></li>
<li><a href="../id444002/index.html">Asisten suara "netral-jender" pertama di dunia disajikan di SXSW IT Festival</a></li>
<li><a href="../id444004/index.html">CLRium # 5: All-All-All tentang GC dan banyak lagi. Peter dan Moskow</a></li>
<li><a href="../id444006/index.html">Konsol permainan DIY do-it-yourself</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>