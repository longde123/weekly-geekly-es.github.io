<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê∫ üíÇ üë∏üèæ Indizes in PostgreSQL - 10 (Bloom) üî∞ üôÜ ‚è∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den vorherigen Artikeln haben wir die PostgreSQL- Indizierungs-Engine und die Schnittstelle von Zugriffsmethoden sowie Hash-Indizes , B-B√§ume , GiS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indizes in PostgreSQL - 10 (Bloom)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452968/">  In den vorherigen Artikeln haben wir die PostgreSQL- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indizierungs-Engine</a> und die Schnittstelle von Zugriffsmethoden sowie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash-Indizes</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-B√§ume</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SP-GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GIN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RUM</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BRIN er√∂rtert</a> .  Aber wir m√ºssen uns noch die Bloom-Indizes ansehen. <br><br><h1>  Bl√ºte </h1><br><h2>  Allgemeines Konzept </h2><br>  Ein klassischer Bloom-Filter ist eine Datenstruktur, mit der wir die Zugeh√∂rigkeit eines Elements zu einer Menge schnell √ºberpr√ºfen k√∂nnen.  Der Filter ist sehr kompakt, l√§sst jedoch falsch positive Ergebnisse zu: Er kann f√§lschlicherweise ein Element als Mitglied einer Menge betrachten (falsch positiv), aber es ist nicht zul√§ssig, ein Element einer Menge nicht als Mitglied zu betrachten (falsch negativ). . <br><br>  Der Filter ist ein Array von <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-1"> m </script>  Bits (auch als <em>Signatur bezeichnet</em> ), die anf√§nglich mit Nullen gef√ºllt sind. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-2"> k </script>  Es werden verschiedene Hash-Funktionen ausgew√§hlt, die ein beliebiges Element der Menge zuordnen <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-3"> k </script>  Bits der Signatur.  Um der Menge ein Element hinzuzuf√ºgen, m√ºssen wir jedes dieser Bits in der Signatur auf eins setzen.  Wenn folglich alle einem Element entsprechenden Bits auf eins gesetzt sind, kann das Element ein Mitglied der Menge sein, aber wenn mindestens ein Bit gleich Null ist, ist das Element nicht sicher in der Menge. <br><br>  Im Falle eines DBMS haben wir tats√§chlich <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-4"> N </script>  F√ºr jede Indexzeile werden separate Filter erstellt.  In der Regel sind mehrere Felder im Index enthalten, und die Werte dieser Felder bilden die Elementmenge f√ºr jede Zeile. <br><br>  Durch Auswahl der L√§nge der Signatur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> m </script>  k√∂nnen wir einen Kompromiss zwischen der Indexgr√∂√üe und der Wahrscheinlichkeit von falsch positiven Ergebnissen finden.  Der Anwendungsbereich f√ºr den Bloom-Index besteht aus gro√üen, erheblich "breiten" Tabellen, die mithilfe von Filtern f√ºr jedes der Felder abgefragt werden m√ºssen.  Diese Zugriffsmethode kann wie BRIN als Beschleuniger des sequentiellen Scans betrachtet werden: Alle vom Index gefundenen √úbereinstimmungen m√ºssen mit der Tabelle erneut √ºberpr√ºft werden, es besteht jedoch die M√∂glichkeit, die meisten Zeilen √ºberhaupt nicht zu ber√ºcksichtigen. <br><a name="habracut"></a><br><h2>  Struktur </h2><br>  Wir haben bereits Signaturb√§ume im Zusammenhang mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GiST-</a> Zugriffsmethode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">er√∂rtert</a> .  Im Gegensatz zu diesen B√§umen ist der Bloom-Index eine flache Struktur.  Es besteht aus einer Metapage, gefolgt von regul√§ren Seiten mit Indexzeilen.  Jede Indexzeile enth√§lt eine Signatur und einen Verweis auf eine Tabellenzeile (TID), wie in der Abbildung schematisch dargestellt. <br><br><img src="https://habrastorage.org/webt/tl/v3/xp/tlv3xpdlc4iw25iuma6yurx8wto.png"><br><br><h3>  Erstellung und Auswahl von Parameterwerten </h3><br>  Beim Erstellen des Bloom-Index wird eine Gesamtgr√∂√üe der Signatur ("L√§nge") sowie die Anzahl der Bits angegeben, die <em>f√ºr jedes einzelne</em> im Index enthaltene <em>Feld festgelegt</em> werden m√ºssen ("col1" - "col32"): <br><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> bloom(...) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (length=..., col1=..., col2=..., ...);</code> </pre> <br>  Die Art und Weise, wie die Anzahl der Bits angegeben wird, sieht seltsam aus: Diese Zahlen m√ºssen Parameter einer Operatorklasse und nicht des Index sein.  Die Sache ist, dass Operatorklassen derzeit nicht parametrisiert werden k√∂nnen, obwohl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">daran gearbeitet</a> wird. <br><br><blockquote>  Leider gibt es hier keine weiteren Fortschritte. <br></blockquote><br>  Wie k√∂nnen wir geeignete Werte ausw√§hlen?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Theorie</a> besagt, dass angesichts der Wahrscheinlichkeit <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> p </script>  eines Filters, um ein falsch positives Ergebnis zur√ºckzugeben, kann die optimale Anzahl von Signaturbits als gesch√§tzt werden <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">m</span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-16" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17">n</span><span class="MJXp-mtext" id="MJXp-Span-18">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20">o</span><span class="MJXp-msubsup" id="MJXp-Span-21"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22" style="margin-right: 0.05em;">g</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-23" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">p</span><span class="MJXp-mrow" id="MJXp-Span-25"><span class="MJXp-mo" id="MJXp-Span-26" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mtext" id="MJXp-Span-27">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29">n</span><span class="MJXp-mn" id="MJXp-Span-30">2</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> m = ‚àín \ log_2 p / \ ln 2 </script>  , wo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-31"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> n </script>  ist die Anzahl der Felder im Index und die Anzahl der zu setzenden Bits <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">k</span><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-36" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mtext" id="MJXp-Span-37">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">o</span><span class="MJXp-msubsup" id="MJXp-Span-40"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41" style="margin-right: 0.05em;">g</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-42" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> k = - \ log_2 p </script>  . <br><br>  Die Signatur wird im Index als Array von Zwei-Byte-Ganzzahlen gespeichert, also der Wert von <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-44"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> m </script>  kann sicher aufgerundet werden <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-46"><span class="MJXp-mn" id="MJXp-Span-47">16</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> 16 </script>  . <br><br>  Bei der Auswahl der Wahrscheinlichkeit <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-48"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> p </script>  m√ºssen wir die Gr√∂√üe des Index ber√ºcksichtigen, die ungef√§hr gleich ist <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-50"><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">m</span><span class="MJXp-mrow" id="MJXp-Span-53"><span class="MJXp-mo" id="MJXp-Span-54" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-55">8</span><span class="MJXp-mo" id="MJXp-Span-56" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-57">6</span><span class="MJXp-mo" id="MJXp-Span-58" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> (m / 8 + 6) N </script>  , wo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> N </script>  ist die Anzahl der Zeilen in der Tabelle und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-62"><span class="MJXp-mn" id="MJXp-Span-63">6</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> 6 </script>  ist die Gr√∂√üe des TID-Zeigers in Bytes. <br><br>  Einige Punkte zu beachten: <br><br><ul><li>  Die Wahrscheinlichkeit <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-64"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> p </script>  eines falsch positiven bezieht sich auf einen Filter, daher erwarten wir zu bekommen <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-66"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67">N</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-68">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> Np </script>  False Positives w√§hrend des Tabellenscans (nat√ºrlich f√ºr eine Abfrage, die nur wenige Zeilen zur√ºckgibt).  Beispielsweise k√∂nnen wir f√ºr eine Tabelle mit einer Million Zeilen und einer Wahrscheinlichkeit von 0,01 im Abfrageplan im Durchschnitt "Durch Index√ºberpr√ºfung entfernte Zeilen: 10000" erwarten. </li><li>  Bloom Filter ist eine probabilistische Struktur.  Es ist sinnvoll, nur dann von bestimmten Zahlen zu sprechen, wenn ziemlich viele Werte gemittelt werden, w√§hrend wir in jedem einzelnen Fall alles bekommen k√∂nnen, was wir uns vorstellen k√∂nnen. </li><li>  Die obigen Sch√§tzungen basieren auf einem idealisierten mathematischen Modell und einigen Annahmen.  In der Praxis ist das Ergebnis wahrscheinlich schlechter.  √úbersch√§tzen Sie also nicht die Formeln: Sie sind nur ein Mittel, um Anfangswerte f√ºr zuk√ºnftige Experimente zu w√§hlen. </li><li>  Mit der Zugriffsmethode k√∂nnen wir f√ºr jedes Feld einzeln die Anzahl der zu setzenden Bits ausw√§hlen.  Es besteht die begr√ºndete Annahme, dass die optimale Anzahl tats√§chlich von der Verteilung der Werte in der Spalte abh√§ngt.  Um tiefer zu tauchen, k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Artikel</a> lesen (Verweise auf andere Forschungen sind willkommen).  Lesen Sie jedoch zuerst den vorherigen Artikel erneut. </li></ul><br><h3>  Aktualisieren </h3><br>  Wenn eine neue Zeile in eine Tabelle eingef√ºgt wird, wird eine Signatur erstellt: F√ºr die Werte aller indizierten Felder werden alle entsprechenden Bits auf eins gesetzt.  Theoretisch m√ºssen wir k verschiedene Hash-Funktionen haben, w√§hrend in der Praxis der Pseudozufallszahlengenerator ausreicht, dessen Startwert jedes Mal mit Hilfe der einzigen Hash-Funktion ausgew√§hlt wird. <br><br>  Ein regul√§rer Bloom-Filter unterst√ºtzt das L√∂schen von Elementen nicht, dies ist jedoch f√ºr den Bloom-Index nicht erforderlich: Wenn eine Tabellenzeile gel√∂scht wird, wird die gesamte Signatur zusammen mit der Indexzeile gel√∂scht. <br><br>  Wie √ºblich besteht ein Update aus dem L√∂schen der veralteten Zeilenversion und dem Einf√ºgen der neuen (die Signatur wird von Grund auf neu berechnet). <br><br><h3>  Scannen </h3><br>  Da der Bloom-Filter nur die Mitgliedschaft eines Elements in einer Gruppe √ºberpr√ºfen kann, ist die einzige vom Bloom-Index unterst√ºtzte Operation eine Gleichheitspr√ºfung (wie im Hash-Index). <br><br>  Wie bereits erw√§hnt, ist der Bloom-Index flach, sodass er im Verlauf des Indexzugriffs immer nacheinander und vollst√§ndig gelesen wird.  W√§hrend des Lesens wird eine Bitmap erstellt, die dann f√ºr den Zugriff auf die Tabelle verwendet wird. <br><br>  Bei einem regul√§ren Indexzugriff wird davon ausgegangen, dass nur wenige Indexzeilen gelesen werden m√ºssen und au√üerdem bald wieder ben√∂tigt werden k√∂nnen. Daher werden sie in einem Puffercache gespeichert.  Das Lesen des Bloom-Index ist jedoch tats√§chlich ein sequentieller Scan.  Um zu verhindern, dass n√ºtzliche Informationen aus dem Cache entfernt werden, erfolgt das Lesen √ºber einen kleinen Pufferring, genau wie beim sequentiellen Scannen von Tabellen. <br><br>  Wir sollten ber√ºcksichtigen, dass je gr√∂√üer der Bloom-Index ist, desto weniger attraktiv erscheint er dem Planer.  Diese Abh√§ngigkeit ist im Gegensatz zu baumartigen Indizes linear. <br><br><h2>  Beispiel </h2><br><h3>  Tabelle </h3><br>  Schauen wir uns den Bloom-Index anhand eines Beispiels einer gro√üen "flights_bi" -Tabelle aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem vorherigen Artikel an</a> .  Zur Erinnerung: Die Gr√∂√üe dieser Tabelle betr√§gt 4 GB mit ungef√§hr 30 Millionen Zeilen.  Definition der Tabelle: <br><br><pre> <code class="pgsql hljs">demo=# \d flights_bi</code> </pre><pre> <code class="plaintext hljs"> Table "bookings.flights_bi" Column | Type | Collation | Nullable | Default --------------------+--------------------------+-----------+----------+--------- airport_code | character(3) | | | airport_coord | point | | | airport_utc_offset | interval | | | flight_no | character(6) | | | flight_type | text | | | scheduled_time | timestamp with time zone | | | actual_time | timestamp with time zone | | | aircraft_code | character(3) | | | seat_no | character varying(4) | | | fare_conditions | character varying(10) | | | passenger_id | character varying(20) | | | passenger_name | text | | |</code> </pre><br>  Lassen Sie uns zun√§chst die Erweiterung erstellen: Obwohl der Bloom-Index in einer Standardlieferung ab Version 9.6 enthalten ist, ist er standardm√§√üig nicht verf√ºgbar. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> bloom;</code> </pre><br>  Das letzte Mal konnten wir drei Felder mit BRIN indizieren ("Scheduled_time", "Actual_time", "Airport_utc_offset").  Da Bloom-Indizes nicht von der physischen Reihenfolge der Daten abh√§ngen, versuchen wir, fast alle Felder der Tabelle in den Index aufzunehmen.  Lassen Sie uns jedoch die Zeitfelder ("geplante_Zeit" und "tats√§chliche_Zeit") ausschlie√üen: Die Methode unterst√ºtzt nur den Vergleich auf Gleichheit, aber eine Abfrage nach der genauen Zeit ist f√ºr niemanden interessant (wir k√∂nnten den Index jedoch auf einem Ausdruck aufbauen und den runden Zeit bis zu einem Tag, aber wir werden das nicht tun).  Wir m√ºssen auch die geografischen Koordinaten von Flugh√§fen ausschlie√üen ("Airport_Coord"): Mit Blick auf die Zukunft wird der Typ "Punkt" nicht unterst√ºtzt. <br><br>  Um die Parameterwerte auszuw√§hlen, setzen wir die Wahrscheinlichkeit eines falsch positiven Ergebnisses auf 0,01 (wobei zu ber√ºcksichtigen ist, dass wir tats√§chlich mehr erhalten).  Die obigen Formeln f√ºr <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70">n</span><span class="MJXp-mo" id="MJXp-Span-71" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-72">9</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> n = 9 </script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-73"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">N</span><span class="MJXp-mo" id="MJXp-Span-75" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-76">30</span><span class="MJXp-mspace" id="MJXp-Span-77" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-78">000</span><span class="MJXp-mspace" id="MJXp-Span-79" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-80"><span class="MJXp-mo" id="MJXp-Span-81" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-82">00</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> N = 30 \, 000 \, $ 00</script>  Geben Sie die Signaturgr√∂√üe von 96 Bit an und schlagen Sie vor, 7 Bit pro Element festzulegen.  Die gesch√§tzte Gr√∂√üe des Index betr√§gt 515 MB (ungef√§hr ein Achtel der Tabelle). <br><br>  (Bei einer minimalen Signaturgr√∂√üe von 16 Bit versprechen die Formeln eine Indexgr√∂√üe, die doppelt so klein ist, erlauben jedoch, sich nur auf die Wahrscheinlichkeit von 0,5 zu verlassen, was sehr schlecht ist.) <br><br><h3>  Operatorklassen </h3><br>  Versuchen wir also, den Index zu erstellen. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_bi_bloom <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> bloom(airport_code, airport_utc_offset, flight_no, flight_type, aircraft_code, seat_no, fare_conditions, passenger_id, passenger_name) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (length=<span class="hljs-number"><span class="hljs-number">96</span></span>, col1=<span class="hljs-number"><span class="hljs-number">7</span></span>, col2=<span class="hljs-number"><span class="hljs-number">7</span></span>, col3=<span class="hljs-number"><span class="hljs-number">7</span></span>, col4=<span class="hljs-number"><span class="hljs-number">7</span></span>, col5=<span class="hljs-number"><span class="hljs-number">7</span></span>, col6=<span class="hljs-number"><span class="hljs-number">7</span></span>, col7=<span class="hljs-number"><span class="hljs-number">7</span></span>, col8=<span class="hljs-number"><span class="hljs-number">7</span></span>, col9=<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type character has no default operator class for access method "bloom" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  Leider bietet uns die Erweiterung nur zwei Operatorklassen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opcname, opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opcmethod = (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> amname = <span class="hljs-string"><span class="hljs-string">'bloom'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>;</code> </pre><pre> <code class="plaintext hljs"> opcname | opcintype ----------+----------- int4_ops | integer text_ops | text (2 rows)</code> </pre><br>  Gl√ºcklicherweise ist es ziemlich einfach, √§hnliche Klassen auch f√ºr andere Datentypen zu erstellen.  Eine Operatorklasse f√ºr die Bloom-Zugriffsmethode muss genau einen Operator - Gleichheit - und genau ein Hilfsfunktions-Hashing enthalten.  Der einfachste Weg, die ben√∂tigten Operatoren und Funktionen f√ºr einen beliebigen Typ zu finden, besteht darin, im Systemkatalog nach Operatorklassen der "Hash" -Methode zu suchen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> opc.opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>, amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, ampr.amproc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opclass opc, pg_amop amop, pg_amproc ampr <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'hash'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opc.opcmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoprighttype = opc.opcintype <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ampr.amprocfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ampr.amproclefttype = opc.opcintype <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opc.opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>;</code> </pre><pre> <code class="plaintext hljs"> opcintype | amopopr | amproc -----------+----------------------+-------------- abstime | =(abstime,abstime) | hashint4 aclitem | =(aclitem,aclitem) | hash_aclitem anyarray | =(anyarray,anyarray) | hash_array anyenum | =(anyenum,anyenum) | hashenum anyrange | =(anyrange,anyrange) | hash_range ...</code> </pre><br>  Mit diesen Informationen erstellen wir zwei fehlende Klassen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLASS</span></span> character_ops <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> <span class="hljs-type"><span class="hljs-type">character</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> bloom <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> =(<span class="hljs-type"><span class="hljs-type">character</span></span>,<span class="hljs-type"><span class="hljs-type">character</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> hashbpchar; demo=# <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLASS</span></span> interval_ops <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> bloom <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> =(<span class="hljs-type"><span class="hljs-type">interval</span></span>,<span class="hljs-type"><span class="hljs-type">interval</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> interval_hash;</code> </pre><br>  Eine Hash-Funktion ist f√ºr Punkte nicht definiert (Typ "Punkt"). Aus diesem Grund k√∂nnen wir keinen Bloom-Index f√ºr ein solches Feld erstellen (genau wie wir keinen Hash-Join f√ºr Felder dieses Typs durchf√ºhren k√∂nnen). <br><br>  Ich versuche es noch einmal: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_bi_bloom <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> bloom(airport_code, airport_utc_offset, flight_no, flight_type, aircraft_code, seat_no, fare_conditions, passenger_id, passenger_name) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (length=<span class="hljs-number"><span class="hljs-number">96</span></span>, col1=<span class="hljs-number"><span class="hljs-number">7</span></span>, col2=<span class="hljs-number"><span class="hljs-number">7</span></span>, col3=<span class="hljs-number"><span class="hljs-number">7</span></span>, col4=<span class="hljs-number"><span class="hljs-number">7</span></span>, col5=<span class="hljs-number"><span class="hljs-number">7</span></span>, col6=<span class="hljs-number"><span class="hljs-number">7</span></span>, col7=<span class="hljs-number"><span class="hljs-number">7</span></span>, col8=<span class="hljs-number"><span class="hljs-number">7</span></span>, col9=<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre><pre> <code class="plaintext hljs">CREATE INDEX</code> </pre><br>  Die Gr√∂√üe des Index betr√§gt 526 MB, was etwas gr√∂√üer als erwartet ist.  Dies liegt daran, dass die Formel den Seitenaufwand nicht ber√ºcksichtigt. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_bloom'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 526 MB (1 row)</code> </pre><br><h3>  Abfragen </h3><br>  Wir k√∂nnen jetzt die Suche nach verschiedenen Kriterien durchf√ºhren, und der Index wird dies unterst√ºtzen. <br><br>  Wie bereits erw√§hnt, ist der Bloom-Filter eine probabilistische Struktur, daher h√§ngt die Effizienz stark von jedem Einzelfall ab.  Schauen wir uns zum Beispiel die Zeilen an, die sich auf zwei Passagiere beziehen, Miroslav Sidorov: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_name=<span class="hljs-string"><span class="hljs-string">'MIROSLAV SIDOROV'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=2639.010..3010.692 rows=2 loops=1) Recheck Cond: (passenger_name = 'MIROSLAV SIDOROV'::text) Rows Removed by Index Recheck: 38562 Heap Blocks: exact=21726 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=1065.191..1065.191 rows=38564 loops=1) Index Cond: (passenger_name = 'MIROSLAV SIDOROV'::text) Planning time: 0.109 ms Execution time: 3010.736 ms</code> </pre><br>  und Marfa Soloveva: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_name=<span class="hljs-string"><span class="hljs-string">'MARFA SOLOVEVA'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=9980.884..10142.684 rows=2 loops=1) Recheck Cond: (passenger_name = 'MARFA SOLOVEVA'::text) Rows Removed by Index Recheck: 3950168 Heap Blocks: exact=45757 lossy=67332 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=1037.588..1037.588 rows=212972 loops=1) Index Cond: (passenger_name = 'MARFA SOLOVEVA'::text) Planning time: 0.157 ms Execution time: 10142.730 ms</code> </pre><br>  In einem Fall erlaubte der Filter nur 40.000 Fehlalarme und bis zu 4 Millionen davon im anderen Fall ("Durch Index√ºberpr√ºfung entfernte Zeilen").  Die Ausf√ºhrungszeiten der Abfragen unterscheiden sich entsprechend. <br><br>  Das Folgende sind die Ergebnisse der Suche in denselben Zeilen nach der Passagier-ID und nicht nach dem Namen.  Miroslav: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) demo-# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_id=<span class="hljs-string"><span class="hljs-string">'5864 006033'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=13747.305..16907.387 rows=2 loops=1) Recheck Cond: ((passenger_id)::text = '5864 006033'::text) Rows Removed by Index Recheck: 9620258 Heap Blocks: exact=50510 lossy=165722 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=937.202..937.202 rows=426474 loops=1) Index Cond: ((passenger_id)::text = '5864 006033'::text) Planning time: 0.110 ms Execution time: 16907.423 ms</code> </pre><br>  Und Marfa: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_id=<span class="hljs-string"><span class="hljs-string">'2461 559238'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=3881.615..3934.481 rows=2 loops=1) Recheck Cond: ((passenger_id)::text = '2461 559238'::text) Rows Removed by Index Recheck: 30669 Heap Blocks: exact=27513 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=1084.391..1084.391 rows=30671 loops=1) Index Cond: ((passenger_id)::text = '2461 559238'::text) Planning time: 0.120 ms Execution time: 3934.517 ms</code> </pre><br>  Die Wirkungsgrade sind wieder sehr unterschiedlich, und diesmal hatte Marfa mehr Gl√ºck. <br><br>  Beachten Sie, dass die Suche nach zwei Feldern gleichzeitig wesentlich effizienter ist, da die Wahrscheinlichkeit eines falschen Positivs besteht <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-83"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> p </script>  verwandelt sich in <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-85"><span class="MJXp-msubsup" id="MJXp-Span-86"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-88" style="vertical-align: 0.5em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> p ^ 2 </script>  :: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_name=<span class="hljs-string"><span class="hljs-string">'MIROSLAV SIDOROV'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> passenger_id=<span class="hljs-string"><span class="hljs-string">'5864 006033'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=872.593..877.915 rows=2 loops=1) Recheck Cond: (((passenger_id)::text = '5864 006033'::text) AND (passenger_name = 'MIROSLAV SIDOROV'::text)) Rows Removed by Index Recheck: 357 Heap Blocks: exact=356 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=832.041..832.041 rows=359 loops=1) Index Cond: (((passenger_id)::text = '5864 006033'::text) AND (passenger_name = 'MIROSLAV SIDOROV'::text)) Planning time: 0.524 ms Execution time: 877.967 ms</code> </pre><br>  Die Suche mit Booleschem "oder" wird jedoch √ºberhaupt nicht unterst√ºtzt.  Dies ist eher eine Einschr√§nkung eines Planers als der Zugriffsmethode.  Nat√ºrlich bleibt eine Option, den Index zweimal zu lesen, zwei Bitmaps zu erstellen und diese zu verbinden, aber dies ist h√∂chstwahrscheinlich zu kostspielig, um diesen Plan auszuw√§hlen. <br><br><h2>  Vergleich mit BRIN und Hash </h2><br>  Die Anwendungsbereiche der Bloom- und BRIN-Indizes √ºberschneiden sich offensichtlich.  Dies sind gro√üe Tabellen, f√ºr die es w√ºnschenswert ist, die Suche nach verschiedenen Feldern sicherzustellen, wobei die Suchgenauigkeit der Kompaktheit geopfert wird. <br><br>  BRIN-Indizes sind kompakter (in unserem Beispiel beispielsweise um bis zu Dutzende Megabyte) und k√∂nnen die Suche nach Bereich unterst√ºtzen, weisen jedoch eine starke Einschr√§nkung in Bezug auf die physische Reihenfolge der Daten in einer Datei auf.  Bloom-Indizes sind gr√∂√üer (Hunderte von Megabyte), haben jedoch keine Einschr√§nkungen, au√üer der Verf√ºgbarkeit einer geeigneten Hash-Funktion. <br><br>  Wie Bloom-Indizes unterst√ºtzen Hash-Indizes die einzige Operation der Gleichheitspr√ºfung.  Der Hash-Index stellt die Suchgenauigkeit sicher, auf die Bloom nicht zugreifen kann, die Indexgr√∂√üe ist jedoch viel gr√∂√üer (in unserem Beispiel ein Gigabyte f√ºr nur ein Feld, und der Hash-Index kann nicht f√ºr mehrere Felder erstellt werden). <br><br><h2>  Eigenschaften </h2><br>  Schauen wir uns wie gewohnt die Eigenschaften von Bloom an (Abfragen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurden bereits bereitgestellt</a> ). <br><br>  Im Folgenden sind die Eigenschaften der Zugriffsmethode aufgef√ºhrt: <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- bloom | can_order | f bloom | can_unique | f bloom | can_multi_col | t bloom | can_exclude | f</code> </pre><br>  Offensichtlich erm√∂glicht uns die Zugriffsmethode, einen Index f√ºr mehrere Spalten zu erstellen.  Es ist kaum sinnvoll, einen Bloom-Index f√ºr eine Spalte zu erstellen. <br><br>  Die folgenden Indexschicht-Eigenschaften sind verf√ºgbar: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | f bitmap_scan | t backward_scan | f</code> </pre><br>  Die einzige verf√ºgbare Scan-Technik ist der Bitmap-Scan.  Da der Index immer vollst√§ndig gescannt wird, ist es nicht sinnvoll, einen regul√§ren Indexzugriff zu implementieren, der Zeilen TID f√ºr TID zur√ºckgibt. <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | f</code> </pre><br>  Hier sind nur Striche;  Die Methode kann nicht einmal NULL-Werte manipulieren. <br><br><h2>  Und zum Schluss: </h2><br>  Es ist nicht unm√∂glich, dass diese Artikelserie in Zukunft fortgesetzt wird, wenn neue interessante Indexarten auftauchen, aber es ist Zeit, jetzt aufzuh√∂ren. <br><br>  Ich m√∂chte meinen Kollegen von Postgres Professional (einige von ihnen sind die Autoren vieler besprochener Zugriffsmethoden) daf√ºr danken, dass sie die Entw√ºrfe gelesen und ihre Kommentare abgegeben haben.  Und ich bin Ihnen nat√ºrlich dankbar f√ºr Ihre Geduld und Ihre wertvollen Kommentare.  Ihre Aufmerksamkeit hat mich ermutigt, diesen Punkt zu erreichen.  Danke! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452968/">https://habr.com/ru/post/de452968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452958/index.html">JMAP - Ein offenes Protokoll ersetzt IMAP beim Austausch von E-Mails</a></li>
<li><a href="../de452960/index.html">Sie werden f√ºr alles antworten! Verbrauchergesteuerte Vertr√§ge mit den Augen des Entwicklers</a></li>
<li><a href="../de452962/index.html">Die Hauptursache f√ºr Unf√§lle in Rechenzentren ist das Verlegen zwischen Computer und Stuhl</a></li>
<li><a href="../de452964/index.html">Eine erschwingliche Erkl√§rung der Riemannschen Hypothese</a></li>
<li><a href="../de452966/index.html">Der Mythos der Achtsamkeit: eine ‚Äûneurozentrische‚Äú Sicht der Meditation</a></li>
<li><a href="../de452974/index.html">Asynchrone Programmierung (vollst√§ndiger Kurs)</a></li>
<li><a href="../de452978/index.html">ok.tech: Daten erkl√§rt</a></li>
<li><a href="../de452980/index.html">AWP KBR-N - Tag X wird bald kommen, der sich nicht darauf vorbereitet hat, die Schuld zu geben</a></li>
<li><a href="../de452982/index.html">Einfache Integration von MS Project und Redmine</a></li>
<li><a href="../de452984/index.html">Arduino und Himbeere verboten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>