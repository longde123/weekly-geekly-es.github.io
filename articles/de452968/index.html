<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐺 💂 👸🏾 Indizes in PostgreSQL - 10 (Bloom) 🔰 🙆 ⏰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den vorherigen Artikeln haben wir die PostgreSQL- Indizierungs-Engine und die Schnittstelle von Zugriffsmethoden sowie Hash-Indizes , B-Bäume , GiS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indizes in PostgreSQL - 10 (Bloom)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452968/">  In den vorherigen Artikeln haben wir die PostgreSQL- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indizierungs-Engine</a> und die Schnittstelle von Zugriffsmethoden sowie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash-Indizes</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-Bäume</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SP-GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GIN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RUM</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BRIN erörtert</a> .  Aber wir müssen uns noch die Bloom-Indizes ansehen. <br><br><h1>  Blüte </h1><br><h2>  Allgemeines Konzept </h2><br>  Ein klassischer Bloom-Filter ist eine Datenstruktur, mit der wir die Zugehörigkeit eines Elements zu einer Menge schnell überprüfen können.  Der Filter ist sehr kompakt, lässt jedoch falsch positive Ergebnisse zu: Er kann fälschlicherweise ein Element als Mitglied einer Menge betrachten (falsch positiv), aber es ist nicht zulässig, ein Element einer Menge nicht als Mitglied zu betrachten (falsch negativ). . <br><br>  Der Filter ist ein Array von <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-1"> m </script>  Bits (auch als <em>Signatur bezeichnet</em> ), die anfänglich mit Nullen gefüllt sind. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-2"> k </script>  Es werden verschiedene Hash-Funktionen ausgewählt, die ein beliebiges Element der Menge zuordnen <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-3"> k </script>  Bits der Signatur.  Um der Menge ein Element hinzuzufügen, müssen wir jedes dieser Bits in der Signatur auf eins setzen.  Wenn folglich alle einem Element entsprechenden Bits auf eins gesetzt sind, kann das Element ein Mitglied der Menge sein, aber wenn mindestens ein Bit gleich Null ist, ist das Element nicht sicher in der Menge. <br><br>  Im Falle eines DBMS haben wir tatsächlich <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-4"> N </script>  Für jede Indexzeile werden separate Filter erstellt.  In der Regel sind mehrere Felder im Index enthalten, und die Werte dieser Felder bilden die Elementmenge für jede Zeile. <br><br>  Durch Auswahl der Länge der Signatur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> m </script>  können wir einen Kompromiss zwischen der Indexgröße und der Wahrscheinlichkeit von falsch positiven Ergebnissen finden.  Der Anwendungsbereich für den Bloom-Index besteht aus großen, erheblich "breiten" Tabellen, die mithilfe von Filtern für jedes der Felder abgefragt werden müssen.  Diese Zugriffsmethode kann wie BRIN als Beschleuniger des sequentiellen Scans betrachtet werden: Alle vom Index gefundenen Übereinstimmungen müssen mit der Tabelle erneut überprüft werden, es besteht jedoch die Möglichkeit, die meisten Zeilen überhaupt nicht zu berücksichtigen. <br><a name="habracut"></a><br><h2>  Struktur </h2><br>  Wir haben bereits Signaturbäume im Zusammenhang mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GiST-</a> Zugriffsmethode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erörtert</a> .  Im Gegensatz zu diesen Bäumen ist der Bloom-Index eine flache Struktur.  Es besteht aus einer Metapage, gefolgt von regulären Seiten mit Indexzeilen.  Jede Indexzeile enthält eine Signatur und einen Verweis auf eine Tabellenzeile (TID), wie in der Abbildung schematisch dargestellt. <br><br><img src="https://habrastorage.org/webt/tl/v3/xp/tlv3xpdlc4iw25iuma6yurx8wto.png"><br><br><h3>  Erstellung und Auswahl von Parameterwerten </h3><br>  Beim Erstellen des Bloom-Index wird eine Gesamtgröße der Signatur ("Länge") sowie die Anzahl der Bits angegeben, die <em>für jedes einzelne</em> im Index enthaltene <em>Feld festgelegt</em> werden müssen ("col1" - "col32"): <br><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> bloom(...) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (length=..., col1=..., col2=..., ...);</code> </pre> <br>  Die Art und Weise, wie die Anzahl der Bits angegeben wird, sieht seltsam aus: Diese Zahlen müssen Parameter einer Operatorklasse und nicht des Index sein.  Die Sache ist, dass Operatorklassen derzeit nicht parametrisiert werden können, obwohl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">daran gearbeitet</a> wird. <br><br><blockquote>  Leider gibt es hier keine weiteren Fortschritte. <br></blockquote><br>  Wie können wir geeignete Werte auswählen?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Theorie</a> besagt, dass angesichts der Wahrscheinlichkeit <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> p </script>  eines Filters, um ein falsch positives Ergebnis zurückzugeben, kann die optimale Anzahl von Signaturbits als geschätzt werden <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">m</span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-16" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17">n</span><span class="MJXp-mtext" id="MJXp-Span-18">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20">o</span><span class="MJXp-msubsup" id="MJXp-Span-21"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22" style="margin-right: 0.05em;">g</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-23" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">p</span><span class="MJXp-mrow" id="MJXp-Span-25"><span class="MJXp-mo" id="MJXp-Span-26" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mtext" id="MJXp-Span-27">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29">n</span><span class="MJXp-mn" id="MJXp-Span-30">2</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> m = −n \ log_2 p / \ ln 2 </script>  , wo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-31"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> n </script>  ist die Anzahl der Felder im Index und die Anzahl der zu setzenden Bits <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">k</span><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-36" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mtext" id="MJXp-Span-37">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">o</span><span class="MJXp-msubsup" id="MJXp-Span-40"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41" style="margin-right: 0.05em;">g</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-42" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> k = - \ log_2 p </script>  . <br><br>  Die Signatur wird im Index als Array von Zwei-Byte-Ganzzahlen gespeichert, also der Wert von <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-44"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> m </script>  kann sicher aufgerundet werden <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-46"><span class="MJXp-mn" id="MJXp-Span-47">16</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> 16 </script>  . <br><br>  Bei der Auswahl der Wahrscheinlichkeit <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-48"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> p </script>  müssen wir die Größe des Index berücksichtigen, die ungefähr gleich ist <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-50"><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">m</span><span class="MJXp-mrow" id="MJXp-Span-53"><span class="MJXp-mo" id="MJXp-Span-54" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-55">8</span><span class="MJXp-mo" id="MJXp-Span-56" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-57">6</span><span class="MJXp-mo" id="MJXp-Span-58" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> (m / 8 + 6) N </script>  , wo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> N </script>  ist die Anzahl der Zeilen in der Tabelle und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-62"><span class="MJXp-mn" id="MJXp-Span-63">6</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> 6 </script>  ist die Größe des TID-Zeigers in Bytes. <br><br>  Einige Punkte zu beachten: <br><br><ul><li>  Die Wahrscheinlichkeit <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-64"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> p </script>  eines falsch positiven bezieht sich auf einen Filter, daher erwarten wir zu bekommen <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-66"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67">N</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-68">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> Np </script>  False Positives während des Tabellenscans (natürlich für eine Abfrage, die nur wenige Zeilen zurückgibt).  Beispielsweise können wir für eine Tabelle mit einer Million Zeilen und einer Wahrscheinlichkeit von 0,01 im Abfrageplan im Durchschnitt "Durch Indexüberprüfung entfernte Zeilen: 10000" erwarten. </li><li>  Bloom Filter ist eine probabilistische Struktur.  Es ist sinnvoll, nur dann von bestimmten Zahlen zu sprechen, wenn ziemlich viele Werte gemittelt werden, während wir in jedem einzelnen Fall alles bekommen können, was wir uns vorstellen können. </li><li>  Die obigen Schätzungen basieren auf einem idealisierten mathematischen Modell und einigen Annahmen.  In der Praxis ist das Ergebnis wahrscheinlich schlechter.  Überschätzen Sie also nicht die Formeln: Sie sind nur ein Mittel, um Anfangswerte für zukünftige Experimente zu wählen. </li><li>  Mit der Zugriffsmethode können wir für jedes Feld einzeln die Anzahl der zu setzenden Bits auswählen.  Es besteht die begründete Annahme, dass die optimale Anzahl tatsächlich von der Verteilung der Werte in der Spalte abhängt.  Um tiefer zu tauchen, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Artikel</a> lesen (Verweise auf andere Forschungen sind willkommen).  Lesen Sie jedoch zuerst den vorherigen Artikel erneut. </li></ul><br><h3>  Aktualisieren </h3><br>  Wenn eine neue Zeile in eine Tabelle eingefügt wird, wird eine Signatur erstellt: Für die Werte aller indizierten Felder werden alle entsprechenden Bits auf eins gesetzt.  Theoretisch müssen wir k verschiedene Hash-Funktionen haben, während in der Praxis der Pseudozufallszahlengenerator ausreicht, dessen Startwert jedes Mal mit Hilfe der einzigen Hash-Funktion ausgewählt wird. <br><br>  Ein regulärer Bloom-Filter unterstützt das Löschen von Elementen nicht, dies ist jedoch für den Bloom-Index nicht erforderlich: Wenn eine Tabellenzeile gelöscht wird, wird die gesamte Signatur zusammen mit der Indexzeile gelöscht. <br><br>  Wie üblich besteht ein Update aus dem Löschen der veralteten Zeilenversion und dem Einfügen der neuen (die Signatur wird von Grund auf neu berechnet). <br><br><h3>  Scannen </h3><br>  Da der Bloom-Filter nur die Mitgliedschaft eines Elements in einer Gruppe überprüfen kann, ist die einzige vom Bloom-Index unterstützte Operation eine Gleichheitsprüfung (wie im Hash-Index). <br><br>  Wie bereits erwähnt, ist der Bloom-Index flach, sodass er im Verlauf des Indexzugriffs immer nacheinander und vollständig gelesen wird.  Während des Lesens wird eine Bitmap erstellt, die dann für den Zugriff auf die Tabelle verwendet wird. <br><br>  Bei einem regulären Indexzugriff wird davon ausgegangen, dass nur wenige Indexzeilen gelesen werden müssen und außerdem bald wieder benötigt werden können. Daher werden sie in einem Puffercache gespeichert.  Das Lesen des Bloom-Index ist jedoch tatsächlich ein sequentieller Scan.  Um zu verhindern, dass nützliche Informationen aus dem Cache entfernt werden, erfolgt das Lesen über einen kleinen Pufferring, genau wie beim sequentiellen Scannen von Tabellen. <br><br>  Wir sollten berücksichtigen, dass je größer der Bloom-Index ist, desto weniger attraktiv erscheint er dem Planer.  Diese Abhängigkeit ist im Gegensatz zu baumartigen Indizes linear. <br><br><h2>  Beispiel </h2><br><h3>  Tabelle </h3><br>  Schauen wir uns den Bloom-Index anhand eines Beispiels einer großen "flights_bi" -Tabelle aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem vorherigen Artikel an</a> .  Zur Erinnerung: Die Größe dieser Tabelle beträgt 4 GB mit ungefähr 30 Millionen Zeilen.  Definition der Tabelle: <br><br><pre> <code class="pgsql hljs">demo=# \d flights_bi</code> </pre><pre> <code class="plaintext hljs"> Table "bookings.flights_bi" Column | Type | Collation | Nullable | Default --------------------+--------------------------+-----------+----------+--------- airport_code | character(3) | | | airport_coord | point | | | airport_utc_offset | interval | | | flight_no | character(6) | | | flight_type | text | | | scheduled_time | timestamp with time zone | | | actual_time | timestamp with time zone | | | aircraft_code | character(3) | | | seat_no | character varying(4) | | | fare_conditions | character varying(10) | | | passenger_id | character varying(20) | | | passenger_name | text | | |</code> </pre><br>  Lassen Sie uns zunächst die Erweiterung erstellen: Obwohl der Bloom-Index in einer Standardlieferung ab Version 9.6 enthalten ist, ist er standardmäßig nicht verfügbar. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> bloom;</code> </pre><br>  Das letzte Mal konnten wir drei Felder mit BRIN indizieren ("Scheduled_time", "Actual_time", "Airport_utc_offset").  Da Bloom-Indizes nicht von der physischen Reihenfolge der Daten abhängen, versuchen wir, fast alle Felder der Tabelle in den Index aufzunehmen.  Lassen Sie uns jedoch die Zeitfelder ("geplante_Zeit" und "tatsächliche_Zeit") ausschließen: Die Methode unterstützt nur den Vergleich auf Gleichheit, aber eine Abfrage nach der genauen Zeit ist für niemanden interessant (wir könnten den Index jedoch auf einem Ausdruck aufbauen und den runden Zeit bis zu einem Tag, aber wir werden das nicht tun).  Wir müssen auch die geografischen Koordinaten von Flughäfen ausschließen ("Airport_Coord"): Mit Blick auf die Zukunft wird der Typ "Punkt" nicht unterstützt. <br><br>  Um die Parameterwerte auszuwählen, setzen wir die Wahrscheinlichkeit eines falsch positiven Ergebnisses auf 0,01 (wobei zu berücksichtigen ist, dass wir tatsächlich mehr erhalten).  Die obigen Formeln für <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70">n</span><span class="MJXp-mo" id="MJXp-Span-71" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-72">9</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> n = 9 </script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-73"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">N</span><span class="MJXp-mo" id="MJXp-Span-75" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-76">30</span><span class="MJXp-mspace" id="MJXp-Span-77" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-78">000</span><span class="MJXp-mspace" id="MJXp-Span-79" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-80"><span class="MJXp-mo" id="MJXp-Span-81" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-82">00</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> N = 30 \, 000 \, $ 00</script>  Geben Sie die Signaturgröße von 96 Bit an und schlagen Sie vor, 7 Bit pro Element festzulegen.  Die geschätzte Größe des Index beträgt 515 MB (ungefähr ein Achtel der Tabelle). <br><br>  (Bei einer minimalen Signaturgröße von 16 Bit versprechen die Formeln eine Indexgröße, die doppelt so klein ist, erlauben jedoch, sich nur auf die Wahrscheinlichkeit von 0,5 zu verlassen, was sehr schlecht ist.) <br><br><h3>  Operatorklassen </h3><br>  Versuchen wir also, den Index zu erstellen. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_bi_bloom <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> bloom(airport_code, airport_utc_offset, flight_no, flight_type, aircraft_code, seat_no, fare_conditions, passenger_id, passenger_name) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (length=<span class="hljs-number"><span class="hljs-number">96</span></span>, col1=<span class="hljs-number"><span class="hljs-number">7</span></span>, col2=<span class="hljs-number"><span class="hljs-number">7</span></span>, col3=<span class="hljs-number"><span class="hljs-number">7</span></span>, col4=<span class="hljs-number"><span class="hljs-number">7</span></span>, col5=<span class="hljs-number"><span class="hljs-number">7</span></span>, col6=<span class="hljs-number"><span class="hljs-number">7</span></span>, col7=<span class="hljs-number"><span class="hljs-number">7</span></span>, col8=<span class="hljs-number"><span class="hljs-number">7</span></span>, col9=<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type character has no default operator class for access method "bloom" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  Leider bietet uns die Erweiterung nur zwei Operatorklassen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opcname, opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opcmethod = (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> amname = <span class="hljs-string"><span class="hljs-string">'bloom'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>;</code> </pre><pre> <code class="plaintext hljs"> opcname | opcintype ----------+----------- int4_ops | integer text_ops | text (2 rows)</code> </pre><br>  Glücklicherweise ist es ziemlich einfach, ähnliche Klassen auch für andere Datentypen zu erstellen.  Eine Operatorklasse für die Bloom-Zugriffsmethode muss genau einen Operator - Gleichheit - und genau ein Hilfsfunktions-Hashing enthalten.  Der einfachste Weg, die benötigten Operatoren und Funktionen für einen beliebigen Typ zu finden, besteht darin, im Systemkatalog nach Operatorklassen der "Hash" -Methode zu suchen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> opc.opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>, amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, ampr.amproc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opclass opc, pg_amop amop, pg_amproc ampr <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'hash'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opc.opcmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoprighttype = opc.opcintype <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ampr.amprocfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ampr.amproclefttype = opc.opcintype <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opc.opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>;</code> </pre><pre> <code class="plaintext hljs"> opcintype | amopopr | amproc -----------+----------------------+-------------- abstime | =(abstime,abstime) | hashint4 aclitem | =(aclitem,aclitem) | hash_aclitem anyarray | =(anyarray,anyarray) | hash_array anyenum | =(anyenum,anyenum) | hashenum anyrange | =(anyrange,anyrange) | hash_range ...</code> </pre><br>  Mit diesen Informationen erstellen wir zwei fehlende Klassen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLASS</span></span> character_ops <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> <span class="hljs-type"><span class="hljs-type">character</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> bloom <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> =(<span class="hljs-type"><span class="hljs-type">character</span></span>,<span class="hljs-type"><span class="hljs-type">character</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> hashbpchar; demo=# <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLASS</span></span> interval_ops <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> bloom <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> =(<span class="hljs-type"><span class="hljs-type">interval</span></span>,<span class="hljs-type"><span class="hljs-type">interval</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> interval_hash;</code> </pre><br>  Eine Hash-Funktion ist für Punkte nicht definiert (Typ "Punkt"). Aus diesem Grund können wir keinen Bloom-Index für ein solches Feld erstellen (genau wie wir keinen Hash-Join für Felder dieses Typs durchführen können). <br><br>  Ich versuche es noch einmal: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_bi_bloom <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> bloom(airport_code, airport_utc_offset, flight_no, flight_type, aircraft_code, seat_no, fare_conditions, passenger_id, passenger_name) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (length=<span class="hljs-number"><span class="hljs-number">96</span></span>, col1=<span class="hljs-number"><span class="hljs-number">7</span></span>, col2=<span class="hljs-number"><span class="hljs-number">7</span></span>, col3=<span class="hljs-number"><span class="hljs-number">7</span></span>, col4=<span class="hljs-number"><span class="hljs-number">7</span></span>, col5=<span class="hljs-number"><span class="hljs-number">7</span></span>, col6=<span class="hljs-number"><span class="hljs-number">7</span></span>, col7=<span class="hljs-number"><span class="hljs-number">7</span></span>, col8=<span class="hljs-number"><span class="hljs-number">7</span></span>, col9=<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre><pre> <code class="plaintext hljs">CREATE INDEX</code> </pre><br>  Die Größe des Index beträgt 526 MB, was etwas größer als erwartet ist.  Dies liegt daran, dass die Formel den Seitenaufwand nicht berücksichtigt. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_bloom'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 526 MB (1 row)</code> </pre><br><h3>  Abfragen </h3><br>  Wir können jetzt die Suche nach verschiedenen Kriterien durchführen, und der Index wird dies unterstützen. <br><br>  Wie bereits erwähnt, ist der Bloom-Filter eine probabilistische Struktur, daher hängt die Effizienz stark von jedem Einzelfall ab.  Schauen wir uns zum Beispiel die Zeilen an, die sich auf zwei Passagiere beziehen, Miroslav Sidorov: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_name=<span class="hljs-string"><span class="hljs-string">'MIROSLAV SIDOROV'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=2639.010..3010.692 rows=2 loops=1) Recheck Cond: (passenger_name = 'MIROSLAV SIDOROV'::text) Rows Removed by Index Recheck: 38562 Heap Blocks: exact=21726 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=1065.191..1065.191 rows=38564 loops=1) Index Cond: (passenger_name = 'MIROSLAV SIDOROV'::text) Planning time: 0.109 ms Execution time: 3010.736 ms</code> </pre><br>  und Marfa Soloveva: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_name=<span class="hljs-string"><span class="hljs-string">'MARFA SOLOVEVA'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=9980.884..10142.684 rows=2 loops=1) Recheck Cond: (passenger_name = 'MARFA SOLOVEVA'::text) Rows Removed by Index Recheck: 3950168 Heap Blocks: exact=45757 lossy=67332 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=1037.588..1037.588 rows=212972 loops=1) Index Cond: (passenger_name = 'MARFA SOLOVEVA'::text) Planning time: 0.157 ms Execution time: 10142.730 ms</code> </pre><br>  In einem Fall erlaubte der Filter nur 40.000 Fehlalarme und bis zu 4 Millionen davon im anderen Fall ("Durch Indexüberprüfung entfernte Zeilen").  Die Ausführungszeiten der Abfragen unterscheiden sich entsprechend. <br><br>  Das Folgende sind die Ergebnisse der Suche in denselben Zeilen nach der Passagier-ID und nicht nach dem Namen.  Miroslav: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) demo-# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_id=<span class="hljs-string"><span class="hljs-string">'5864 006033'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=13747.305..16907.387 rows=2 loops=1) Recheck Cond: ((passenger_id)::text = '5864 006033'::text) Rows Removed by Index Recheck: 9620258 Heap Blocks: exact=50510 lossy=165722 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=937.202..937.202 rows=426474 loops=1) Index Cond: ((passenger_id)::text = '5864 006033'::text) Planning time: 0.110 ms Execution time: 16907.423 ms</code> </pre><br>  Und Marfa: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_id=<span class="hljs-string"><span class="hljs-string">'2461 559238'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=3881.615..3934.481 rows=2 loops=1) Recheck Cond: ((passenger_id)::text = '2461 559238'::text) Rows Removed by Index Recheck: 30669 Heap Blocks: exact=27513 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=1084.391..1084.391 rows=30671 loops=1) Index Cond: ((passenger_id)::text = '2461 559238'::text) Planning time: 0.120 ms Execution time: 3934.517 ms</code> </pre><br>  Die Wirkungsgrade sind wieder sehr unterschiedlich, und diesmal hatte Marfa mehr Glück. <br><br>  Beachten Sie, dass die Suche nach zwei Feldern gleichzeitig wesentlich effizienter ist, da die Wahrscheinlichkeit eines falschen Positivs besteht <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-83"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> p </script>  verwandelt sich in <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-85"><span class="MJXp-msubsup" id="MJXp-Span-86"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-88" style="vertical-align: 0.5em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> p ^ 2 </script>  :: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_name=<span class="hljs-string"><span class="hljs-string">'MIROSLAV SIDOROV'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> passenger_id=<span class="hljs-string"><span class="hljs-string">'5864 006033'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=872.593..877.915 rows=2 loops=1) Recheck Cond: (((passenger_id)::text = '5864 006033'::text) AND (passenger_name = 'MIROSLAV SIDOROV'::text)) Rows Removed by Index Recheck: 357 Heap Blocks: exact=356 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=832.041..832.041 rows=359 loops=1) Index Cond: (((passenger_id)::text = '5864 006033'::text) AND (passenger_name = 'MIROSLAV SIDOROV'::text)) Planning time: 0.524 ms Execution time: 877.967 ms</code> </pre><br>  Die Suche mit Booleschem "oder" wird jedoch überhaupt nicht unterstützt.  Dies ist eher eine Einschränkung eines Planers als der Zugriffsmethode.  Natürlich bleibt eine Option, den Index zweimal zu lesen, zwei Bitmaps zu erstellen und diese zu verbinden, aber dies ist höchstwahrscheinlich zu kostspielig, um diesen Plan auszuwählen. <br><br><h2>  Vergleich mit BRIN und Hash </h2><br>  Die Anwendungsbereiche der Bloom- und BRIN-Indizes überschneiden sich offensichtlich.  Dies sind große Tabellen, für die es wünschenswert ist, die Suche nach verschiedenen Feldern sicherzustellen, wobei die Suchgenauigkeit der Kompaktheit geopfert wird. <br><br>  BRIN-Indizes sind kompakter (in unserem Beispiel beispielsweise um bis zu Dutzende Megabyte) und können die Suche nach Bereich unterstützen, weisen jedoch eine starke Einschränkung in Bezug auf die physische Reihenfolge der Daten in einer Datei auf.  Bloom-Indizes sind größer (Hunderte von Megabyte), haben jedoch keine Einschränkungen, außer der Verfügbarkeit einer geeigneten Hash-Funktion. <br><br>  Wie Bloom-Indizes unterstützen Hash-Indizes die einzige Operation der Gleichheitsprüfung.  Der Hash-Index stellt die Suchgenauigkeit sicher, auf die Bloom nicht zugreifen kann, die Indexgröße ist jedoch viel größer (in unserem Beispiel ein Gigabyte für nur ein Feld, und der Hash-Index kann nicht für mehrere Felder erstellt werden). <br><br><h2>  Eigenschaften </h2><br>  Schauen wir uns wie gewohnt die Eigenschaften von Bloom an (Abfragen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurden bereits bereitgestellt</a> ). <br><br>  Im Folgenden sind die Eigenschaften der Zugriffsmethode aufgeführt: <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- bloom | can_order | f bloom | can_unique | f bloom | can_multi_col | t bloom | can_exclude | f</code> </pre><br>  Offensichtlich ermöglicht uns die Zugriffsmethode, einen Index für mehrere Spalten zu erstellen.  Es ist kaum sinnvoll, einen Bloom-Index für eine Spalte zu erstellen. <br><br>  Die folgenden Indexschicht-Eigenschaften sind verfügbar: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | f bitmap_scan | t backward_scan | f</code> </pre><br>  Die einzige verfügbare Scan-Technik ist der Bitmap-Scan.  Da der Index immer vollständig gescannt wird, ist es nicht sinnvoll, einen regulären Indexzugriff zu implementieren, der Zeilen TID für TID zurückgibt. <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | f</code> </pre><br>  Hier sind nur Striche;  Die Methode kann nicht einmal NULL-Werte manipulieren. <br><br><h2>  Und zum Schluss: </h2><br>  Es ist nicht unmöglich, dass diese Artikelserie in Zukunft fortgesetzt wird, wenn neue interessante Indexarten auftauchen, aber es ist Zeit, jetzt aufzuhören. <br><br>  Ich möchte meinen Kollegen von Postgres Professional (einige von ihnen sind die Autoren vieler besprochener Zugriffsmethoden) dafür danken, dass sie die Entwürfe gelesen und ihre Kommentare abgegeben haben.  Und ich bin Ihnen natürlich dankbar für Ihre Geduld und Ihre wertvollen Kommentare.  Ihre Aufmerksamkeit hat mich ermutigt, diesen Punkt zu erreichen.  Danke! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452968/">https://habr.com/ru/post/de452968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452958/index.html">JMAP - Ein offenes Protokoll ersetzt IMAP beim Austausch von E-Mails</a></li>
<li><a href="../de452960/index.html">Sie werden für alles antworten! Verbrauchergesteuerte Verträge mit den Augen des Entwicklers</a></li>
<li><a href="../de452962/index.html">Die Hauptursache für Unfälle in Rechenzentren ist das Verlegen zwischen Computer und Stuhl</a></li>
<li><a href="../de452964/index.html">Eine erschwingliche Erklärung der Riemannschen Hypothese</a></li>
<li><a href="../de452966/index.html">Der Mythos der Achtsamkeit: eine „neurozentrische“ Sicht der Meditation</a></li>
<li><a href="../de452974/index.html">Asynchrone Programmierung (vollständiger Kurs)</a></li>
<li><a href="../de452978/index.html">ok.tech: Daten erklärt</a></li>
<li><a href="../de452980/index.html">AWP KBR-N - Tag X wird bald kommen, der sich nicht darauf vorbereitet hat, die Schuld zu geben</a></li>
<li><a href="../de452982/index.html">Einfache Integration von MS Project und Redmine</a></li>
<li><a href="../de452984/index.html">Arduino und Himbeere verboten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>