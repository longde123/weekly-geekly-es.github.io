<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤗 💃🏻 🧗🏿 路径查找算法和A *的简单说明 📦 ⏹️ 😳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="第1部分。通用搜索算法 
 引言 
 寻找路径是游戏开发人员通常最困难的主题之一。 尤其是，人们对A *算法的理解很差，许多人认为这是某种不可理解的魔术。 

 本文的目的是以一种非常容易理解和可访问的方式来解释对路径的一般搜索，尤其是对A *的搜索，从而消除了人们普遍认为该主题很复杂的误解。 有了...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>路径查找算法和A *的简单说明</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444828/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif" alt="图片"></div><br><h2> 第1部分。通用搜索算法 </h2><br><h2> 引言 </h2><br> 寻找路径是游戏开发人员通常最困难的主题之一。 尤其是，人们对<strong>A *</strong>算法的理解很差，许多人认为这是某种不可理解的魔术。 <br><br> 本文的目的是以一种非常容易理解和可访问的方式来解释对路径的一般搜索，尤其是对<strong>A *</strong>的搜索，从而消除了人们普遍认为该主题很复杂的误解。 有了正确的解释，一切都很简单。 <br><br> 请注意，在本文中，我们将考虑寻找一种<em>游戏方式</em> ； 与其他学术文章不同，我们将省略深度优先或广度优先之类的搜索算法。 相反，我们将尝试尽快从零到<strong>A *</strong> 。 <br><a name="habracut"></a><br> 在第一部分中，我们将解释找到路径的最简单概念。 通过理解这些基本概念，您将意识到<strong>A *</strong>非常明显。 <br><br><h2> 简单电路 </h2><br> 尽管您可以将这些概念应用于任意复杂的3D环境，但让我们从一个非常简单的方案开始：一个5 x 5的正方形网格，为方便起见，我用大写字母标记了每个单元格。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2d/66c/ed8/e2d66ced82a4c1d4ed739583bd782245.png"></div><br>  <i>简单的网格。</i> <br><br> 我们要做的第一件事就是将这个环境想象成一个图形。 我不会详细解释什么是图形。 简而言之，这是一组由箭头连接的圆圈。 圆圈称为<em>“结”</em> ，箭头<em>称为“边缘”</em> 。 <br><br> 每个节点表示字符可能处于的<em>“状态”</em> 。 在本例中，角色的状态就是他的位置，因此我们为每个网格单元创建一个节点： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68a/d4b/4db/68ad4b4db470c1ce34434e6489a5a986.png"></div><br>  <i>表示网格单元的节点。</i> <br><br> 现在添加肋骨。 它们指示可以从每个给定状态<em>“到达”的</em>状态。 在我们的情况下，我们可以从任何一个单元进入下一个单元，但被阻止的单元除外： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f73/56c/9be/f7356c9be0171d61c31e3e4c21bf9385.png"></div><br>  <i>弧表示网格单元之间的允许移动。</i> <br><br> 如果我们可以从<strong>A</strong>到达<strong>B</strong> ，那么我们说<strong>B</strong>是<strong>A</strong>节点的<em>“邻居”</em> 。 <br><br> 值得注意的是肋骨有<em>方向</em> ; 我们需要从<strong>A</strong>到<strong>B</strong>以及从<strong>B</strong>到<strong>A的边。</strong> 这似乎是多余的，但是当可能出现更复杂的“条件”时却不是。 例如，角色可能会从屋顶掉到地板上，但不能从地板跳到屋顶。 您可以从“活动”状态转到“死”状态，反之则不行。 依此类推。 <br><br><h2> 例子 </h2><br> 假设我们要从<strong>A</strong>移到<strong>T。</strong> 我们从<strong>A</strong>开始<strong>。</strong> 您可以执行两个操作：转到<strong>B</strong>或转到<strong>F。</strong> <br><br> 假设我们搬到了<strong>B。</strong> 现在我们可以做两件事：返回<strong>A</strong>或转到<strong>C。</strong> 我们记得我们已经进入<strong>A</strong>并考虑了那里的选项，因此再做一次是没有意义的（否则我们可以整日移动<strong>A</strong> → <strong>B</strong> → <strong>A</strong> → <strong>B</strong> ...）。 因此，我们将转到<strong>C。</strong> <br><br> 在<strong>C语言中</strong> ，我们无处可去。 返回<strong>B是</strong>没有意义的，也就是说，这是一个死胡同。 当我们在<strong>A中</strong>时，选择过渡到<strong>B</strong>是一个坏主意； 也许您应该改用<strong>F</strong> ？ <br><br> 我们只是不断重复这个过程，直到我们进入<strong>T。</strong> 此刻，我们仅从<strong>A</strong>重新创建路径，返回步骤即可。 我们在<strong>T</strong> ; 我们怎么到达那里？ 来自<strong>o</strong>吗？ 也就是说，路径的末端具有<strong>O</strong> → <strong>T</strong>的形式<strong>。</strong> 我们怎么到<strong>O的</strong> ？ 依此类推。 <br><br> 请记住，我们并没有真正<em>动起来</em> ； 所有这一切只是一个思考过程。 我们将继续站在<strong>A内</strong> ，直到找到完整的路径，我们才会离开它。 当我说“移至<strong>B</strong> ”时，是指“想象我们移至<strong>B</strong> ”。 <br><br><h2> 通用算法 </h2><br>  <strong>这部分是整篇文章中最重要的部分</strong> 。 您绝对<em>必须</em>理解它才能实现搜索的方式； 其余的（包括<strong>A *</strong> ）只是细节。 在本节中，您将了解直到<em>理解其中的含义</em> 。 <br><br> 此外，本节非常简单。 <br><br> 让我们尝试形式化我们的示例，将其转换为伪代码。 <br><br> 我们需要跟踪我们知道如何从起始节点到达的节点。 在开始时，这只是起始节点，但是在“探索”网格的过程中，我们将学习如何到达其他节点。 让我们将此节点称为<code>reachable</code>列表： <br><br><pre> <code class="python hljs">reachable = [start_node]</code> </pre> <br> 我们还需要跟踪已经检查过的节点，以免再次考虑它们。  <code>explored</code>称他们为<code>explored</code> ： <br><br><pre> <code class="python hljs">explored = []</code> </pre> <br>  <strong>接下来，我将概述算法的核心</strong> ：在搜索的每个步骤中，我们选择一个知道如何到达的节点之一，并查看可以从中获得哪些新节点。 如果我们确定如何到达最终（目标）节点，那么问题就解决了！ 否则，我们将继续搜索。 <br><br> 如此简单，什至令人失望？ 这是真的。 但这就是整个算法。 让我们用伪代码逐步记录下来。 <br><br> 我们继续搜索，直到到达最终节点（在这种情况下，我们找到从初始节点到最终节点的路径），或者直到用尽了可以搜索的节点为止（在这种情况下，开始节点和结束节点之间没有办法） 。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty:</code> </pre> <br> 我们选择一个我们知道如何获得并且尚未进行调查的节点之一： <br><br><pre> <code class="python hljs"> node = choose_node(reachable)</code> </pre> <br> 如果我们只是学习了如何到达最终节点，那么任务就完成了！ 我们只需要通过遵循<code>previous</code>链接回到起始节点来构建路径： <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == goal_node: path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(node) node = node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br> 多次检查该节点没有任何意义，因此我们将跟踪此情况： <br><br><pre> <code class="python hljs"> reachable.remove(node) explored.add(node)</code> </pre> <br> 我们确定无法从此处到达的节点。 我们从与当前节点相邻的节点列表开始，然后删除已经检查过的节点： <br><br><pre> <code class="python hljs"> new_reachable = get_adjacent_nodes(node) - explored</code> </pre> <br> 我们将它们中的每一个： <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_reachable:</code> </pre> <br> 如果我们已经知道如何到达该节点，请忽略它。 否则，将其添加到<code>reachable</code>列表，跟踪其进入方式： <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br> 查找结束节点是退出循环的一种方法。 第二个是<code>reachable</code>变为空：我们已经用完了可以探索的节点，而我们还没有到达最终节点，也就是说，从初始节点到最终节点没有办法： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br> 而且...就是这样。 这是整个算法，并且路径构造代码是通过单独的方法分配的： <br><br><pre> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: if adjacent not in reachable adjacent.previous = node # Remember how we got there. reachable.add(adjacent) # If we get here, no path was found :( return None</span></span></code> </pre> <br> 这是构建路径的功能，它遵循<code>previous</code>链接回到起始节点： <br><br><pre> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br> 仅此而已。  <em>这是</em> <em>每个</em>路径搜索算法<em>的</em>伪代码，包括<strong>A *</strong> 。 <br><br> 重新阅读本节，直到您了解一切正常工作，更重要的是， <em>为什么</em>一切正常。 最好在纸上手工绘制一个示例，但您也可以观看一个交互式演示： <br><br><h2> 互动演示 </h2><br> 这是上述算法的演示和实现示例（您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在原始文章</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">页面</a>上运行它）。  <code>choose_node</code>只是选择一个随机节点。 您可以逐步启动算法，并查看<code>reachable</code>和<code>explored</code>的列表，以及<code>previous</code>链接指向的位置。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vt/jk/cb/vtjkcb4tflduq7zu5p-oph2i73s.gif"></div><br> 请注意，一旦检测到路径，搜索就会结束； 有可能甚至没有考虑某些节点。 <br><br><h2> 结论 </h2><br> 这里介绍的算法是<em>任何</em>路径搜索算法的通用算法。 <br><br> 但是，每种算法之间的区别是什么，为什么<strong>A *</strong>是<strong>A *</strong> ？ <br><br> 提示：如果在演示中多次运行搜索，您会发现该算法实际上并不总是找到相同的路径。 他找到<em>了</em>一条路，而这条路不一定是<em>最短的</em> 。 怎么了 <br><br><h2> 第2部分。搜索策略 </h2><br> 如果您没有完全理解上一节中描述的算法，请返回并重新阅读，因为这是理解更多信息的必要条件。 当您弄清楚时， <strong>A *</strong>对您而言似乎是完全自然和合乎逻辑的。 <br><br><h2> 秘密成分 </h2><br> 在上一部分的结尾，我留下了两个问题：如果每种搜索算法使用相同的代码，为什么<strong>A *的</strong>行为类似于<strong>A *</strong> ？ 为什么演示有时会找到不同的路径？ <br><br> 这两个问题的答案都是相互关联的。 尽管算法定义明确，但我仍未解决一个方面，事实证明，这是解释搜索算法行为的关键： <br><br><pre> <code class="python hljs">node = choose_node(reachable)</code> </pre> <br> 正是这个看起来很天真的字符串将所有搜索算法区分开来。  <code>choose_node</code>取决于<code>choose_node</code>的实现方法。 <br><br> 那么，为什么演示会找到不同的路径？ 因为它的<code>choose_node</code>方法会随机选择一个节点。 <br><br><h2> 长度很重要 </h2><br> 在深入研究<code>choose_node</code>函数的行为差异之前，我们需要对上述算法进行小的监督。 <br><br> 当我们考虑与当前节点相邻的节点时，我们忽略了那些已经知道如何实现的节点： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br> 这是一个错误：如果我们只是发现实现这一目标的<em>最佳</em>方法该怎么办？ 在这种情况下，必须更改<code>previous</code>节点链接以反映此较短的路径。 <br><br> 为此，我们需要知道从起始节点到任何可达节点的路径长度。 我们将其称为路径成本。 现在，我们假设从一个节点移动到相邻节点之一的成本为<code>1</code> 。 <br><br> 开始搜索之前，我们将每个节点的<code>cost</code>值分配给<code>infinity</code> ； 因此， <em>任何</em>路径都会比这更短。 我们还将<code>start_node</code>节点的<code>cost</code>设置为<code>0</code> 。 <br><br> 然后是以下代码： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: reachable.add(adjacent) <span class="hljs-comment"><span class="hljs-comment"># If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1</span></span></code> </pre> <br><h2> 相同的搜寻费用 </h2><br> 现在让我们看一下<code>choose_node</code>方法。 如果我们努力寻找最短的路径，那么随机选择一个节点不是一个好主意。 <br><br> 最好选择一个我们可以从最短路径的初始节点到达的节点。 因此，我们通常更喜欢较短的路径而不是较长的路径。 这并不意味着完全不会考虑较长的路径，而是意味着首先会考虑较短的路径。 由于算法在找到合适的路径后立即终止，因此这应该使我们能够找到较短的路径。 <br><br> 这是<code>choose_node</code>函数的可能示例： <br><br><pre> <code class="python hljs">function choose_node (reachable): best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> best_node == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> best_node.cost &gt; node.cost: best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br> 直观地，对该算法的搜索从起始节点开始“径向”扩展，直到到达终止节点为止。 这是此行为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的交互式演示</a> ： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nh/fn/jd/nhfnjd_ztdx3fbuqy5v5_am5hxw.gif"></div><br><h2> 结论 </h2><br> 下面考虑的选择节点的方法进行了简单的更改，使我们获得了一个相当不错的算法：它找到了从起点到终点的最短路径。 <br><br> 但是这种算法在某种程度上仍然是“愚蠢的”。 他继续到处搜索，直到偶然发现一个终端节点。 例如，如果很明显我们正在远离末端节点，那么上面显示的示例在<strong>A</strong>方向上搜索的意义是什么？ <br><br> 是否可以使<code>choose_node</code>更智能？ 我们是否可以使<em>搜索直接指向终端节点</em> ，甚至无需事先知道正确的路径？ <br><br> 事实证明，我们可以-在接下来的部分中，我们终于到达<code>choose_node</code> ，它使我们可以将常规路径搜索算法转换为<strong>A *</strong> 。 <br><br><h2> 第3部分。从A *中删除秘密的面纱 </h2><br> 在上一部分中获得的算法非常好：它找到了从起始节点到最终节点的最短路径。 但是，他浪费了精力：他考虑了一个人明显地称之为错误的方式-他们通常<em>会偏离</em>目标。 如何避免这种情况？ <br><br><h2> 魔术算法 </h2><br> 想象一下，我们在一台特殊的计算机上运行搜索算法，该计算机具有可以执行<em>魔术</em>的芯片。 得益于这款出色的芯片，我们可以<code>choose_node</code>非常简单的方式来表达<code>choose_node</code> ，从而确保创建最短路径，而不会浪费时间探索毫无结果的部分路径： <br><br><pre> <code class="python hljs">function choose_node (reachable): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> magic(reachable, <span class="hljs-string"><span class="hljs-string">" ,     "</span></span>)</code> </pre> <br> 听起来很诱人，但是魔术芯片仍然需要某种低级代码。 这是一个很好的近似值： <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = magic(node, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br> 这是选择下一个节点的好方法：选择一个节点，该节点使我们拥有从起点到终点的最短路径，这正是我们所需要的。 <br><br> 我们还最小化了魔术的使用量：我们确切知道从起始节点移动到每个节点的成本（这是<code>node.cost</code> ），并且我们仅使用魔术来预测从节点移动到最终节点的成本。 <br><br><h2> 不是魔法，而是很棒的A * </h2><br> 不幸的是，魔术芯片是新的，我们需要过时的设备的支持。 除了以下这一行外，大多数代码都适合我们： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Throws MuggleProcessorException cost_node_to_goal = magic(node, "   ")</span></span></code> </pre> <br> 也就是说，我们不能使用魔术来找出未探索路径的成本。 好吧，让我们做个预测。 我们将保持乐观，并假设当前节点与最终节点之间没有任何关系，我们可以直接移动： <br><br><pre> <code class="python hljs">cost_node_to_goal = distance(node, goal_node)</code> </pre> <br> 请注意， <em>最短路径</em>和<em>最小距离是</em>不同的：最小距离表示当前节点与最终节点之间绝对没有障碍。 <br><br> 该估计非常容易获得。 在我们的网格示例中，这是两个节点之间<em>的城市街区距离</em> （即<code>abs(Ax - Bx) + abs(Ay - By)</code> ）。 如果我们可以沿对角线移动，则该值将为<code>sqrt( (Ax - Bx)^2 + (Ay - By)^2 )</code> ，依此类推。 最重要的是，我们永远不会获得<em>过高</em>的价值估算。 <br><br> 因此，这是<code>choose_node</code>的非<code>choose_node</code>版本： <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br> 估计从当前节点到最终节点的距离的函数称为<em>启发式</em> ，此搜索算法（女士和先生们）称为... <strong>A *</strong> 。 <br><br><h2> 互动演示 </h2><br> 当您从意识到神秘的<strong>A *</strong>实际上<em>如此简单</em>而引起的震惊中恢复过来时，您可以查看演示（或在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始文章中</a>运行它）。 您会注意到，与前面的示例不同，搜索花费很少的时间沿错误的方向移动。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif"></div><br><h2> 结论 </h2><br> 最后，我们得到了<strong>A *</strong>算法，它仅是本文第一部分中描述的常规搜索算法，而第二部分中描述了一些改进，并使用<code>choose_node</code>函数，该函数选择了我们估计与我们更接近的节点。终端节点。 仅此而已。 <br><br> 这是main方法的完整伪代码供您参考： <br><br><pre> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here that we haven't explored before? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: # First time we see this node? if adjacent not in reachable: reachable.add(adjacent) # If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1 # If we get here, no path was found :( return None</span></span></code> </pre> <br>  <code>build_path</code>方法： <br><br><pre> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br> 这是<code>choose_node</code>方法，将其转换为<strong>A *</strong> ： <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br> 仅此而已。 <br><br> 但是为什么我们需要<strong>第4部分</strong> ？ <br><br> 既然您已经了解了<strong>A *的</strong>工作原理，那么我想谈谈其应用中的一些令人惊奇的领域，这些领域不仅限于在单元格中查找路径。 <br><br><h2> 第4部分。 </h2><br> 本文的前三部分从路径搜索算法的基础开始，到对<strong>A *</strong>算法的清晰描述结束。 从理论上讲，所有这些都是很棒的，但是了解这在实践中如何适用是完全不同的主题。 <br><br> 例如，如果我们的世界不是网格，会发生什么？ <br><br> 如果角色无法立即旋转90度怎么办？ <br><br> 如果世界是无尽的，如何建立图表？ <br><br> 如果我们不在乎路径的长度，但是我们依赖太阳能，并且我们需要尽可能地处于阳光下怎么办？ <br><br> 如何找到到达两个末端节点中任何一个的最短路径？ <br><br><h2> 成本函数 </h2><br> 在第一个示例中，我们寻找起点和终点之间的最短路径。 但是，我们没有将部分路径长度存储为可变<code>length</code> ，而是将其称为<code>cost</code> 。 怎么了 <br><br> 我们可以使<strong>A *</strong>不仅寻找<em>最短的路径</em> ，而且寻找<em>最佳的</em>路径，并且可以根据我们的目标选择“最佳”的定义。 当我们需要最短的路径时，成本就是路径的长度，但是，例如，如果要最小化燃料消耗，则需要使用它作为成本。 如果我们想最大化“在阳光下度过的时间”，那么成本就是没有阳光的时间。 依此类推。 <br><br> 在一般情况下，这意味着相应的成本与图形的每个边相关联。 在上面显示的示例中，该值是隐式设置的，并且始终被视为等于<code>1</code> ，因为我们计算了整个过程中的步骤。 但是我们可以根据我们要最小化的成本来更改肋骨的成本。 <br><br><h2> 标准函数 </h2><br> 假设我们的对象是一辆汽车，而他需要到达加油站。 任何加油将适合我们。 它以最短的路线到最近的加油站。 <br><br> 天真的方法是依次计算出每次加油的最短路径，并选择最短的路径。 这将起作用，但是这将是一个非常昂贵的过程。 <br><br> 如果我们可以用一种方法来替换一个<code>goal_node</code> ，该方法可以在给定节点上判断其是否有限。 因此，我们可以同时搜索多个目标。 我们还需要修改启发式方法，以使其返回所有可能的终端节点的最小估计成本。 <br><br> 根据情况的具体情况，我们可能无法<em>完美地</em>实现目标，否则可能会花费太多（如果通过半<code>is_goal_node</code>地图发送角色，那么一英寸的差异重要吗？），所以当我们使用<code>is_goal_node</code>方法时，它可以返回<code>true</code>我们“足够亲密”。 <br><br><h2> 不需要完全确定。 </h2><br> 将世界表示为离散的网格可能不足以用于许多游戏。 以第一人称射击游戏或赛车游戏为例。 世界是离散的，但不能表示为网格。 <br><br> 但是，还有一个更严重的问题：如果世界是无止境的呢？ 在这种情况下，即使我们能够以网格的形式呈现它，我们也将无法构造与网格相对应的图形，因为它必须是无限的。 <br><br> 但是，并非一切都丢失了。 当然，对于图搜索算法，我们肯定需要一个图。 但是没有人说图表应该是<em>全面的</em> ！ <br><br> 如果仔细看一下算法，您会发现我们对整个图没有做任何事情； 我们在本地检查该图，从而获得可以从相关节点到达的节点。 从演示<strong>A *</strong>可以看出，图的某些节点根本没有被研究。 <br><br> 那么，为什么不在研究过程中建立图表呢？ <br><br> 我们将角色的当前位置作为起始节点。 调用<code>get_adjacent_nodes</code>它可以确定角色从给定节点移动并动态创建相邻节点的可能方式。 <br><br><h2> 超越三个维度 </h2><br> 即使您的世界是<i>真正</i>的2D网格，也需要考虑其他方面。 例如，如果角色通常不能立即旋转90或180度怎么办？ <br><br> 每个搜索节点表示<em>的状态</em>不必只是一个<em>位置</em> ; 相反，它可能包含任意复杂的值集。 例如，如果从一个单元格过渡到另一个单元格所需的时间为90度，则可以将角色的状态设置为<code>[position, heading]</code> 。 每个节点不仅可以代表角色的位置，还可以代表他的注视方向； 图的新边缘（显式或间接）反映了这一点。 <br><br> 如果返回到原始的5x5网格，则初始搜索位置现在可以为<code>[A, East]</code> 。 现在，相邻节点为<code>[B, East]</code>和<code>[A, South]</code> -如果要到达<strong>F</strong> ，我们首先需要调整方向，以使路径采用<code>[A, East]</code> ， <code>[A, South]</code> ， <code>[F, South]</code> 。 <br><br> 第一人称射击游戏？ 至少四个维度： <code>[X, Y, Z, Heading]</code> 。 甚至<code>[X, Y, Z, Heading, Health, Ammo]</code> 。 <br><br> 注意，状态越​​复杂，启发式函数应该越复杂。  <strong>*本身</strong>很简单； 艺术通常源于良好的启发式方法。 <br><br><h2> 结论 </h2><br> 本文的目的是彻底消除神话，即<strong>A *</strong>是无法解密的神秘算法。 相反，我表明其中没有任何神秘之处，实际上，可以很简单地从头开始推论得出。 <br><br><h3> 进一步阅读 </h3><br> 阿米特·帕特尔（Amit Patel）有出色的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ A *算法简介”</a> （关于哈布雷的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">翻译</a> ）（他关于其他主题的其他文章也很出色！）。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444828/">https://habr.com/ru/post/zh-CN444828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444816/index.html">DIY木工：期望与现实</a></li>
<li><a href="../zh-CN444818/index.html">Citymobil-创业公司在增长中提高稳定性的指南。 第一部分</a></li>
<li><a href="../zh-CN444820/index.html">Mockdown：创建线框的最快方法</a></li>
<li><a href="../zh-CN444822/index.html">JDK 9 / JEP 280：字符串连接将不再相同</a></li>
<li><a href="../zh-CN444824/index.html">首先看亚马逊和FedEx Courier机器人</a></li>
<li><a href="../zh-CN444830/index.html">俄罗斯和全世界的云电子签名</a></li>
<li><a href="../zh-CN444832/index.html">“周五不部署”和另外三个潜规则</a></li>
<li><a href="../zh-CN444836/index.html">他们说，无需考虑内存问题。CLRium研讨会5：垃圾收集器</a></li>
<li><a href="../zh-CN444838/index.html">OWASP俄罗斯聚会</a></li>
<li><a href="../zh-CN444840/index.html">3. Check Point入门R80.20。 布局准备</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>