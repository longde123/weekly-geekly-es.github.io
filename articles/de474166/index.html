<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíó üñïüèæ üò¶ Titelindizes f√ºr GiST üë®‚Äçüë¶ ‚ö°Ô∏è ü§¶üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Deckungsindex ist nicht nur eine weitere n√ºtzliche Funktion. Dieses Ding ist rein praktisch. Ohne sie kann Index Only Scan m√∂glicherweise keinen G...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Titelindizes f√ºr GiST</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/474166/"> Der Deckungsindex ist nicht nur eine weitere n√ºtzliche Funktion.  Dieses Ding ist rein praktisch.  Ohne sie kann Index Only Scan m√∂glicherweise keinen Gewinn bringen.  Obwohl der Deckungsindex in verschiedenen Situationen auf unterschiedliche Weise wirksam ist. <br><br>  Hier geht es nicht wirklich darum, Indizes abzudecken: Genau genommen sind in Postgres die sogenannten Inklusivindizes erschienen.  Aber in der Reihenfolge: Ein Deckungsindex ist ein Index, der alle f√ºr die Abfrage erforderlichen Spaltenwerte enth√§lt.  Der Zugriff auf die Tabelle selbst ist jedoch nicht mehr erforderlich.  Fast.  In einem Artikel von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yegor Rogov</a> , der in seiner Indexreihe mit 10 (!) Teilen enthalten ist, k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> √ºber ‚Äûfast‚Äú und andere Nuancen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen</a> .  Der <b>Inklusivindex</b> wurde speziell f√ºr die Suche in typischen Abfragen erstellt: Die Werte von Feldern, die nicht durchsucht werden k√∂nnen, werden dem Suchindex hinzugef√ºgt. Sie werden nur ben√∂tigt, um nicht erneut auf die Tabelle zu verweisen.  Solche Indizes werden mit dem Schl√ºsselwort INCLUDE gebildet. <br><br>  Anastasia Lubennikova (Postgres Professional) hat die btree-Methode fertiggestellt, damit zus√§tzliche Spalten in den Index aufgenommen werden k√∂nnen.  Dieser Patch war in PostgreSQL 11 enthalten. Die Patches f√ºr die GiST / SP-GiST-Zugriffsmethoden hatten jedoch vor der Ver√∂ffentlichung dieser Version keine Zeit zum Reifen.  Bis zum 12. GiST reifte. <br><a name="habracut"></a><br>  Der konstruktive Wunsch nach integrativen Indizes f√ºr GiST entstand vor langer Zeit: Mitte April 2018 wurde <a href="">der</a> Community ein Test-Patch von Andrey Borodin <a href="">angeboten</a> .  Er hat alle grundlegenden, sehr schwierigen Arbeiten erledigt. <br><br>  Anfang August 2019 f√ºgte Alexander Korotkov kosmetische Verbesserungen hinzu und verpflichtete den Patch. <br><br>  Zur Demonstration und f√ºr einige Nachforschungen werden wir einen Satz von 3 Millionen Rechtecken generieren.  Gleichzeitig ein paar Worte zum Box-Typ, da nicht alle Manipulationen damit intuitiv sind. <br><br>  Die Art der Box - das hei√üt das Rechteck - ist seit langem in Postgres vorhanden. Sie wird durch 2 Punkte (den geometrischen Typpunkt) definiert - die entgegengesetzten Eckpunkte des Rechtecks ‚Äã‚Äã(dh das Rechteck kann nicht schr√§g und seitlich verstreut sein).  Wir lesen in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> : ‚ÄûWerte vom Typ box werden in einer der folgenden Formen geschrieben: <br><br><pre><code class="plaintext hljs">( ( x1 , y1 ) , ( x2 , y2 ) ) ( x1 , y1 ) , ( x2 , y2 ) x1 , y1 , x2 , y2</code> </pre> <br>  In der Praxis muss man beispielsweise so schreiben: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> box(<span class="hljs-string"><span class="hljs-string">'1,2'</span></span>, <span class="hljs-string"><span class="hljs-string">'3,4'</span></span>); <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-comment"><span class="hljs-comment">------------- (3,4),(1,2) (1 row)</span></span></code> </pre> <br>  Zuerst zeigt uns Postgres den oberen rechten Scheitelpunkt, dann den unteren linken.  Wenn wir so schreiben, <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> box(<span class="hljs-string"><span class="hljs-string">'5,2'</span></span>, <span class="hljs-string"><span class="hljs-string">'3,4'</span></span>); <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-comment"><span class="hljs-comment">------------- (5,4),(3,2) (1 row)</span></span></code> </pre> <br>  dann werden wir sicherstellen, dass Postgres nicht die Spitzen gab, die sie ihm gaben.  Er berechnete die obere rechte und untere linke von unserer oberen linken und unteren rechten.  Dies ist eine praktische Eigenschaft, wenn die Position der Scheitelpunkte nicht im Voraus bekannt ist - beispielsweise bei zuf√§lliger Erzeugung.  Die Notation '1,2', '3,4' entspricht Punkt (1,2), Punkt (3,4).  Diese Form ist manchmal bequemer. <br><br><br><h3>  F√ºr Unternehmen: Suchen Sie in 3 Millionen Rechtecken </h3><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> boxes(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, thebox <span class="hljs-type"><span class="hljs-type">box</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">text</span></span>);</code> </pre><br>  Wir werden 3 Millionen zuf√§llige Rechtecke erzeugen.  Wir wollen eine Normalverteilung, aber um die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tablefunc-</a> Erweiterung nicht zu verwenden, verwenden wir den ‚Äûschlechten‚Äú Ansatz: Wir verwenden random () - random (), was auch ein sch√∂nes Bild ergibt (siehe Abb.). Bei Rechtecken sind sie umso n√§her an der Mitte, je gr√∂√üer sie sind.  Ihre Schwerpunkte sind ebenfalls zuf√§llig.  Solche Verteilungen sind charakteristisch f√ºr einige Arten von realen Stadtdaten.  Und wer sich mit den Gesetzen der Statistik befassen oder Erinnerungen auffrischen m√∂chte, kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> zum Beispiel √ºber den Unterschied von Zufallsvariablen lesen. <br><br><img src="https://habrastorage.org/webt/2p/df/j4/2pdfj4sxnjja1ztiikvrkzrdniw.jpeg"><br><br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> boxes(thebox, <span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> box( <span class="hljs-type"><span class="hljs-type">point</span></span>( random()-random(), random()-random() ), <span class="hljs-type"><span class="hljs-type">point</span></span>( random()-random(), random()-random() ) ), <span class="hljs-string"><span class="hljs-string">'box no.'</span></span> || x <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(x);</code> </pre> <br><br>  Die Gr√∂√üe der Tabelle mit <code>\dt+</code> betr√§gt 242 MB.  Jetzt k√∂nnen Sie die Suche starten. <br><br>  Wir suchen ohne Index: <br><br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thebox, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> thebox @&gt; box(<span class="hljs-string"><span class="hljs-string">'0.5, 0.4'</span></span>,<span class="hljs-string"><span class="hljs-string">'0.3, 0.2'</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------- Gather (cost=1000.00..47853.00 rows=3000 width=46) (actual time=0.140..246.998 rows=139189 loops=1) Workers Planned: 2 Workers Launched: 2 -&gt; Parallel Seq Scan on boxes (cost=0.00..46553.00 rows=1250 width=46) (actual time=0.011..106.708 rows=46396 loops=3) Filter: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Rows Removed by Filter: 953604 Planning Time: 0.040 ms Execution Time: 259.262 ms (8 rows)</span></span></code> </pre> <br>  Wir sehen, dass es einen parallelen Seq-Scan gibt - einen sequentiellen Scan (wenn auch parallelisiert). <br><br>  Erstellen Sie einen regul√§ren, nicht inklusiven Index: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gist(thebox);</code> </pre> <br>  Die Gr√∂√üe des Index <code>boxes_thebox_idx</code> , der <code>\di+</code> anzeigt, 262 MB.  Als Antwort auf dieselbe Anfrage erhalten wir: <br><br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thebox, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> thebox @&gt; box(<span class="hljs-string"><span class="hljs-string">'0.5, 0.4'</span></span>,<span class="hljs-string"><span class="hljs-string">'0.3, 0.2'</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------- Bitmap Heap Scan on boxes (cost=159.66..9033.30 rows=3000 width=46) (actual time=29.101..80.283 rows=139189 loops=1) Recheck Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Heap Blocks: exact=30629 -&gt; Bitmap Index Scan on boxes_thebox_idx (cost=0.00..158.91 rows=3000 width=0) (actual time=25.029..25.029 rows=139189 loops=1) Index Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Planning Time: 0.053 ms Execution Time: 86.206 ms (7 rows)</span></span></code> </pre><br>  Die Suchzeit wurde um den Faktor drei reduziert, und anstelle des parallelen Seq-Scans erhielten sie einen Bitmap-Index-Scan.  Es parallelisiert nicht, arbeitet aber schneller. <br><br>  T√∂te nun den alten Index und erstelle einen inklusiven: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> spgist(thebox) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>);</code> </pre> <br>  Index der <code>boxes_thebox_name_idx</code> fetteren: 356MB.  Lass uns gehen: <br><br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thebox, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> thebox @&gt; box(<span class="hljs-string"><span class="hljs-string">'0.5, 0.4'</span></span>,<span class="hljs-string"><span class="hljs-string">'0.3, 0.2'</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------ Bitmap Heap Scan on boxes (cost=207.66..9081.30 rows=3000 width=46) (actual time=86.822..152.014 rows=139189 loops=1) Recheck Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Heap Blocks: exact=30629 -&gt; Bitmap Index Scan on boxes_thebox_name_idx (cost=0.00..206.91 rows=3000 width=0) (actual time=83.044..83.044 rows=139189 loops=1) Index Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Planning Time: 3.807 ms Execution Time: 157.997 ms (7 rows)</span></span></code> </pre> <br><br>  Nur Index-Scan wird verwendet, aber das Bild ist traurig: Die Zeit ist fast zweimal l√§nger als ohne.  Wir lesen das Handbuch des Erstellers der Indizes in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil I</a> : <br><br>  ‚ÄπRang PostgreSQL-Indizes enthalten keine Informationen, mit denen Sie die Sichtbarkeit von Zeilen beurteilen k√∂nnen.  Daher gibt die Zugriffsmethode alle Versionen von Zeilen zur√ºck, die unter die Suchbedingung fallen, unabh√§ngig davon, ob sie f√ºr die aktuelle Transaktion sichtbar sind oder nicht.  Wenn der Indizierungsmechanismus jedoch jedes Mal in die Tabelle schauen m√ºsste, um die Sichtbarkeit zu bestimmen, w√ºrde sich diese Scanmethode nicht von der normalen Indexscanung unterscheiden.  Das Problem wird durch die Tatsache gel√∂st, dass PostgreSQL die sogenannte Sichtbarkeitskarte f√ºr Tabellen unterst√ºtzt, in der der Vakuumprozess Seiten markiert, auf denen sich Daten nicht lange genug ge√§ndert haben, damit alle Transaktionen sie sehen k√∂nnen, unabh√§ngig von Startzeit und Isolationsstufe.  Wenn sich die Kennung der vom Index zur√ºckgegebenen Zeile auf eine solche Seite bezieht, kann die Sichtbarkeit nicht √ºberpr√ºft werden. ‚Ä∫‚Ä∫ <br><br>  Wir machen VAKUUM.  Wiederholen: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thebox, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> thebox @&gt; box(<span class="hljs-string"><span class="hljs-string">'0.5, 0.4'</span></span>,<span class="hljs-string"><span class="hljs-string">'0.3, 0.2'</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------- Index Only Scan using boxes_thebox_name_idx on boxes (cost=0.41..236.91 rows=3000 width=46) (actual time=0.104..38.651 rows=139189 loops=1) Index Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Heap Fetches: 0 Planning Time: 0.052 ms Execution Time: 44.337 ms (5 rows)</span></span></code> </pre> <br>  Eine ganz andere Sache!  Zweimal so viel Gewinn wie im Non-Inclusive-Index. <br><br><br><h3>  Selektivit√§t und Gewinn </h3><br>  Die Leistung inklusiver Indizes h√§ngt stark von der Selektivit√§t der Bedingungen in Abfragen ab.  Um diese Abh√§ngigkeit ein wenig zu untersuchen, werden wir das umgekehrte Problem l√∂sen: Wir werden eine Beschriftung mit einem Index vom Typ Punkt generieren und wir werden suchen, wie viele Punkte in das gegebene Feld fallen.  Verteilen Sie die Punkte gleichm√§√üig im Quadrat. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> test_covergist(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, tochka <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">text</span></span>);</code> </pre> <br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> test_covergist(tochka, <span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">point</span></span>(trunc(<span class="hljs-number"><span class="hljs-number">1000000</span></span>*random()), trunc(<span class="hljs-number"><span class="hljs-number">1000000</span></span>*random())), <span class="hljs-string"><span class="hljs-string">'point no.'</span></span> || gx <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(x);</code> </pre> <br>  Die Gr√∂√üe der Tabelle betr√§gt 211 MB. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gist(tochka);</code> </pre> <br>  Gr√∂√üe 213 MB. <br><br>  Wir werden nat√ºrlich alle verf√ºgbaren Punkte auf ein Quadrat setzen: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'3000000,3000000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist (cost=135.66..8778.83 rows=3000 width=32) (actual time=1087.964..1864.059 rows=3000000 loops=1) Recheck Cond: ('(3000000,3000000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=27025 Buffers: shared read=54287 -&gt; Bitmap Index Scan on test_covergist_tochka_idx (cost=0.00..134.91 rows=3000 width=0) (actual time=1084.949..1084.949 rows=3000000 loops=1) Index Cond: (tochka &lt;@ '(3000000,3000000),(0,0)'::box) Buffers: shared read=27262 Planning Time: 0.102 ms Execution Time: 2029.501 ms (9 rows)</span></span></code> </pre> <br>  Wir haben EXPLAIN gebeten, die Puffer anzuzeigen.  Es wird n√ºtzlich sein.  Jetzt betr√§gt die Ausf√ºhrungszeit der Anforderung mehr als 2 Sekunden. Es ist ersichtlich, dass Puffer: gemeinsam gelesen = 54287.  In einer anderen Situation konnte eine Mischung aus gemeinsamem Lesen und gemeinsamem Treffer angezeigt werden. Das hei√üt, einige Puffer werden von der Festplatte (oder aus dem Betriebssystem-Cache) und andere aus dem Puffer-Cache gelesen.  Wir kennen die ungef√§hre Gr√∂√üe der Tabelle und der Indizes und sch√ºtzen uns daher, indem wir gemeinsam genutzte Puffer so einstellen, dass alles passt. Starten Sie Postgres mit der Option neu <br><br><pre> <code class="plaintext hljs">-o "-c shared_buffers=1GB"</code> </pre> <br>  Jetzt: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'3000000,3000000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist (cost=135.66..8778.83 rows=3000 width=32) (actual time=231.032..613.326 rows=3000000 loops=1) Recheck Cond: ('(3000000,3000000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=27025 Buffers: shared hit=54248 -&gt; Bitmap Index Scan on test_covergist_tochka_idx (cost=0.00..134.91 rows=3000 width=0) (actual time=228.068..228.068 rows=3000000 loops=1) Index Cond: (tochka &lt;@ '(3000000,3000000),(0,0)'::box) Buffers: shared hit=27223 Planning Time: 0.070 ms Execution Time: 755.915 ms (9 rows)</span></span></code> </pre> <br>  Das hei√üt, das gemeinsame Lesen wurde zu einem gemeinsamen Treffer, und die Zeit wurde dreimal reduziert. <br><br>  Ein weiteres wichtiges Detail in EXPLAIN: 3 Millionen Punkte werden zur√ºckgegeben, und die Prognose f√ºr die zur√ºckgegebene Anzahl von Datens√§tzen betr√§gt 3.000. Spoiler: Diese Anzahl √§ndert sich bei keiner Selektivit√§t.  Der Optimierer wei√ü nicht, wie die Kardinalit√§t bei der Arbeit mit Box- oder Punkttypen bewertet werden soll.  Und der Plan wird sich nicht √§ndern: F√ºr jede Gr√∂√üe des Rechtecks ‚Äã‚Äãwird ein Bitmap-Index-Scan f√ºr test_covergist_tochka_idx durchgef√ºhrt. <br><br>  Hier sind zwei weitere Messungen mit der Anzahl der ausgegebenen Datens√§tze, die sich um Gr√∂√üenordnungen unterscheiden: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'300000,300000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist (cost=135.66..8778.83 rows=3000 width=32) (actual time=27.889..134.054 rows=269882 loops=1) Recheck Cond: ('(300000,300000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=27024 Buffers: shared hit=29534 -&gt; Bitmap Index Scan on test_covergist_tochka_idx (cost=0.00..134.91 rows=3000 width=0) (actual time=24.847..24.847 rows=269882 loops=1) Index Cond: (tochka &lt;@ '(300000,300000),(0,0)'::box) Buffers: shared hit=2510 Planning Time: 0.074 ms Execution Time: 151.269 ms (9 rows)</span></span></code> </pre> <br>  Es werden 10-mal weniger Datens√§tze zur√ºckgegeben (tats√§chliche ... Zeilen = 269882), die Zeit hat sich um etwa das 5-fache verringert. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'30000,30000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist (cost=135.66..8778.83 rows=3000 width=32) (actual time=1.882..16.095 rows=2780 loops=1) Recheck Cond: ('(30000,30000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=2624 Buffers: shared hit=2655 -&gt; Bitmap Index Scan on test_covergist_tochka_idx (cost=0.00..134.91 rows=3000 width=0) (actual time=1.035..1.035 rows=2780 loops=1) Index Cond: (tochka &lt;@ '(30000,30000),(0,0)'::box) Buffers: shared hit=31 Planning Time: 0.154 ms Execution Time: 16.702 ms (9 rows)</span></span></code> </pre> <br>  Der Inhalt eines 30K √ó 30K-Quadrats (2780) wird in nur 16 ms gez√§hlt.  Und wenn es Dutzende von Datens√§tzen gibt, werden sie bereits in Bruchteilen von ms extrahiert, und solche Messungen sind nicht sehr zuverl√§ssig. <br><br>  Messen Sie schlie√ülich dasselbe mit dem Inklusivindex: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gist(tochka) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>);</code> </pre> <br>  Gr√∂√üe 316 MB. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'3000000,3000000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------- Index Only Scan using test_covergist_tochka_name_idx on test_covergist (cost=0.41..216.91 rows=3000 width=32) (actual time=0.160..568.707 rows=3000000 loops=1) Index Cond: (tochka &lt;@ '(3000000,3000000),(0,0)'::box) Heap Fetches: 0 Buffers: shared hit=40492 Planning Time: 0.090 ms Execution Time: 709.837 ms (6 rows)</span></span></code> </pre> <br>  Die Zeit ist fast dieselbe wie bei einem herk√∂mmlichen Index, obwohl nur Index scannen. <br><br>  Aber: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'300000,300000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------------- Index Only Scan using test_covergist_tochka_name_idx on test_covergist (cost=0.41..216.91 rows=3000 width=32) (actual time=0.083..53.277 rows=269882 loops=1) Index Cond: (tochka &lt;@ '(300000,300000),(0,0)'::box) Heap Fetches: 0 Buffers: shared hit=3735 Planning Time: 0.077 ms Execution Time: 66.162 ms (6 rows)</span></span></code> </pre> <br>  Und es war 151 ms.  Und dementsprechend: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'300000,300000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------------- Index Only Scan using test_covergist_tochka_name_idx on test_covergist (cost=0.41..216.91 rows=3000 width=32) (actual time=0.043..0.639 rows=2780 loops=1) Index Cond: (tochka &lt;@ '(30000,30000),(0,0)'::box) Heap Fetches: 0 Buffers: shared hit=52 Planning Time: 0.053 ms Execution Time: 0.791 ms (6 rows)</span></span></code> </pre><br>  Dies ist bereits ein Bruchteil von ms f√ºr dieselben 2780-Punkt-Datens√§tze. <br><br><h3>  Puffer wie Waffen </h3><br>  Eine Erkl√§rung kann in einer Schrotflinte gesucht und gefunden werden, die noch nicht geschossen hat, aber an der Wand hing: die Anzahl der gelesenen Bl√∂cke.  Bei einem inklusiven Index werden nur Bl√∂cke des Index selbst gelesen (Heap Fetches: 0).  In drei F√§llen waren dies die Nummern 40492, 3735 und 52. Bei Verwendung des regul√§ren Index bestehen die gelesenen Bl√∂cke jedoch aus der Summe der im Bitmap-Heap-Scan-Index (54248 mit 3 Millionen Datens√§tzen) gelesenen Bits und derjenigen, die aus dem Heap gelesen werden mussten (27223). , da das Namensfeld nicht aus einem regul√§ren Index extrahiert werden kann.  54248 + 27223 = 81471.  Das Exklusive war 40492. F√ºr zwei andere F√§lle: 29534 + 2510 = 31044 und 2655 + 31 = 2686.  Im Fall eines regul√§ren Index werden ohnehin mehr Bl√∂cke gelesen, aber mit einer Verbesserung der Selektivit√§t beginnt sich die Anzahl der gelesenen Bl√∂cke eher um Gr√∂√üenordnungen als um das Zweifache zu unterscheiden, da die Anzahl der erforderlichen Bl√∂cke aus einem Heap langsamer abnimmt als das Lesen von Indexbl√∂cken. <br><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Gesamtzahl der zur√ºckgegebenen Datens√§tze</b> (Tausend) </td><td>  <b>3000</b> </td><td>  <b>270</b> </td><td>  <b>2.7</b> </td></tr><tr><td>  <b>Lesebl√∂cke</b> (normal / inklusive) </td><td>  81471/40492 </td><td>  31044/3735 </td><td>  2686/52 </td></tr><tr><td>  <b>Zeit</b> </td><td>  755/710 </td><td>  151/66 </td><td>  16 / 0,7 </td></tr></tbody></table></div><br><br>  Aber vielleicht geht es √ºberhaupt nicht um Selektivit√§t, sondern einfach um die Gr√∂√üe der Tabelle?  F√ºr alle F√§lle wiederholen wir dieselben Schritte und generieren eine Tabelle mit 300.000 und nicht 3 Millionen Datens√§tzen: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> test_covergist_small(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, tochka <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">text</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> test_covergist_small(tochka, <span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">point</span></span>(trunc(<span class="hljs-number"><span class="hljs-number">1000000</span></span>*random()), trunc(<span class="hljs-number"><span class="hljs-number">1000000</span></span>*random())), <span class="hljs-string"><span class="hljs-string">'point no.'</span></span> || gx <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">300000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(x); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> test_covergist_small <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gist(tochka); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist_small <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'3000000,3000000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist_small (cost=14.61..867.19 rows=300 width=31) (actual time=36.115..130.435 rows=300000 loops=1) Recheck Cond: ('(3000000,3000000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=2500 Buffers: shared hit=5225 -&gt; Bitmap Index Scan on test_covergist_small_tochka_idx (cost=0.00..14.53 rows=300 width=0) (actual time=35.894..35.895 rows=300000 loops=1) Index Cond: (tochka &lt;@ '(3000000,3000000),(0,0)'::box) Buffers: shared hit=2725 Planning Time: 0.060 ms Execution Time: 158.580 (9 rows)</span></span></code> </pre><br>  Wiederholen Sie dies als N√§chstes f√ºr den Inklusivindex.  Hier sind die Ergebnisse: <br><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Gesamtzahl der zur√ºckgegebenen Datens√§tze</b> (Tausend) </td><td>  <b>300</b> </td><td>  <b>27</b> </td><td>  <b>0,25</b> </td></tr><tr><td>  <b>Lesebl√∂cke</b> (normal / inklusive) </td><td>  5225/3726 </td><td>  3026/352 </td><td>  270/8 </td></tr><tr><td>  <b>Zeit</b> </td><td>  158/178 </td><td>  20/13 </td><td>  0,4 / 0,2 </td></tr></tbody></table></div><br><br>  Bei einer 100% igen Punktabdeckung war die Abfrage sogar etwas langsamer als mit dem √ºblichen Index.  Weiter, wie im Fall von 3 Millionen, passte alles zusammen.  Das hei√üt, Selektivit√§t ist wichtig. <br><br>  Unser Unternehmen testete inklusive GiST-Indizes an realen Daten - ein Satz mit mehreren Millionen Rechtecken auf einer Karte von Moskau.  Die Schlussfolgerung ist dieselbe: In vielen Situationen beschleunigen solche Indizes Abfragen sp√ºrbar.  Der Artikel kann jedoch nicht mit Bildern und Testzahlen illustriert werden: Diese Daten sind nicht gemeinfrei. <br><br><h3>  Anstelle einer Schlussfolgerung </h3><br>  Kehren wir f√ºr einen Moment zu zuf√§lligen Rechtecken zur√ºck.  Versuchen wir, dasselbe mit spgist zu tun.  Sie k√∂nnen sich daran erinnern oder herausfinden, was es hei√üt, die Unterschiede zwischen SP-GiST und GiST zu verstehen, indem Sie den Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indizes in PostgreSQL - 6</a> lesen.  Erstellen Sie einen Inklusivindex: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> spgist(thebox) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>); ERROR: <span class="hljs-keyword"><span class="hljs-keyword">access</span></span> <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> "spgist" does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support included <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span></code> </pre> <br>  Leider sind f√ºr SP-GiST inklusive Indizes noch nicht implementiert. <br>  Es gibt also Raum f√ºr Verbesserungen! <br><br><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474166/">https://habr.com/ru/post/de474166/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474144/index.html">So erstellen Sie ein Startup: IoT-Projekt von der Idee bis zur Produktion</a></li>
<li><a href="../de474146/index.html">Erh√∂hte Sicherungsgeschwindigkeit und die M√∂glichkeit, das Komprimierungsverh√§ltnis in der neuen Version von Zextras Backup zu w√§hlen</a></li>
<li><a href="../de474150/index.html">Ableitung eines Modells eines dynamischen Systems eines diskreten Kalman-Filters f√ºr ein beliebiges lineares System</a></li>
<li><a href="../de474154/index.html">Vitrektomie - wir pfl√ºgen die offenen R√§ume der Welt, die von der Augenh√∂hle begrenzt werden</a></li>
<li><a href="../de474164/index.html">Zimbra ist unser Alles</a></li>
<li><a href="../de474170/index.html">Design Confession - 15. November, Moskau, DI Telegraph</a></li>
<li><a href="../de474172/index.html">Eine Geldstrafe von 30.000 Euro f√ºr die illegale Verwendung von Cookies</a></li>
<li><a href="../de474176/index.html">11 Videos vom ersten Tag des DevFest 2019 in Kaliningrad</a></li>
<li><a href="../de474178/index.html">IVR auf Webhook</a></li>
<li><a href="../de474180/index.html">Wie fehlertolerante Webarchitektur in der Mail.ru Cloud Solutions-Plattform implementiert wird</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>