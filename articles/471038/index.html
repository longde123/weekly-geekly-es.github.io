<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüè≠ ü§µ üåï Archivo descriptor de Linux con ejemplos üë®üèº‚Äçüíª ‚åöÔ∏è üî≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una vez, en una entrevista, me preguntaron qu√© har√≠as si encuentras un servicio que no funciona porque el disco se ha quedado sin espacio. 

 Por supu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Archivo descriptor de Linux con ejemplos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471038/"> Una vez, en una entrevista, me preguntaron qu√© har√≠as si encuentras un servicio que no funciona porque el disco se ha quedado sin espacio. <br><br>  Por supuesto, respond√≠ que ver√≠a qu√© ocupaba este lugar y, si era posible, limpiar√≠a el lugar. <br>  Luego, el entrevistador pregunt√≥: ¬øqu√© pasa si no hay espacio libre en la secci√≥n, pero tampoco ve los archivos que ocupar√≠an todo el lugar? <br><br>  A esto, le dije que siempre puede mirar los descriptores de archivos abiertos, por ejemplo con el comando lsof y comprender qu√© aplicaci√≥n ocupaba todo el espacio disponible, y luego puede proceder de acuerdo con las circunstancias, dependiendo de si se necesitan los datos. <br><br>  El entrevistador me interrumpi√≥ en la √∫ltima palabra y agreg√≥ mi pregunta: "Supongamos que no necesitamos los datos, es solo un registro de depuraci√≥n, pero la aplicaci√≥n no funciona porque no puede grabar la depuraci√≥n". <br><br>  "Est√° bien", respond√≠, "podemos desactivar la depuraci√≥n en la configuraci√≥n de la aplicaci√≥n y reiniciarla". <br>  El entrevistador objet√≥: "No, no podemos reiniciar la aplicaci√≥n, los datos importantes a√∫n se almacenan en nuestra memoria y los clientes importantes est√°n conectados al servicio en s√≠, que no podemos obligar a volver a conectar". <br><br>  "Bueno", le dije, "si no podemos reiniciar la aplicaci√≥n y los datos no son importantes para nosotros, entonces simplemente podemos borrar este archivo abierto a trav√©s del descriptor de archivos, incluso si no lo vemos en el comando ls en el sistema de archivos". <br><br>  El entrevistador estaba contento, pero yo no. <br><br>  Entonces pens√©, ¬øpor qu√© la persona que prueba mi conocimiento no profundiza?  Pero, ¬øy si los datos siguen siendo importantes?  ¬øQu√© sucede si no podemos reiniciar el proceso y, al mismo tiempo, este proceso escribe en el sistema de archivos en una secci√≥n en la que no hay espacio libre?  ¬øQu√© sucede si no podemos perder no solo los datos ya grabados, sino tambi√©n los datos que este proceso escribe o intenta grabar? <br><a name="habracut"></a><br><h3>  Tuzik </h3><br>  Al comienzo de mi carrera intent√© crear una peque√±a aplicaci√≥n en la que era necesario almacenar informaci√≥n sobre los usuarios.  Y luego pens√©, ¬øc√≥mo puedo asignar el usuario a sus datos?  Por ejemplo, tengo a Ivan Ivanov Ivanich, y √©l tiene algunos datos, pero ¬øc√≥mo hacer amistad con ellos?  Puedo indicar directamente que el perro llamado "Tuzik" pertenece a este mismo Ivan.  Pero, ¬øqu√© pasa si cambia su nombre y en lugar de Ivan se convierte, por ejemplo, en Olya?  Entonces resulta que nuestra Olya Ivanovna Ivanova ya no tendr√° un perro, y nuestro Tuzik seguir√° perteneciendo al Iv√°n inexistente.  Esta base de datos fue ayudada por una base de datos que le dio a cada usuario un identificador √∫nico (ID), y mi Tuzik se adjunt√≥ a esta ID, que, de hecho, era solo un n√∫mero ordinal.  Por lo tanto, el propietario del tuzik ten√≠a el n√∫mero de identificaci√≥n 2 y, en alg√∫n momento, Ivan ten√≠a esta identificaci√≥n, y luego Olya se convirti√≥ en la misma identificaci√≥n.  El problema de la humanidad y la cr√≠a de animales ha sido pr√°cticamente resuelto. <br><br><h3>  Descriptor de archivo </h3><br>  El problema del archivo y el programa que trabaja con este archivo es casi el mismo que el de nuestro perro y nuestra persona.  Supongamos que abr√≠ un archivo con el nombre ivan.txt y comenc√© a escribir la palabra tuzik en √©l, pero logr√© escribir solo la primera letra "t" en el archivo, y alguien cambi√≥ el nombre de este archivo, por ejemplo, olya.txt.  Pero el archivo segu√≠a siendo el mismo, y todav√≠a quiero escribir mi as en √©l.  Cada vez que abro un archivo con la llamada al sistema abierto en cualquier lenguaje de programaci√≥n, obtengo una ID √∫nica que me se√±ala un archivo, esta ID es un descriptor de archivo.  Y no importa lo que alguien haga a continuaci√≥n con este archivo, pueden eliminarlo, cambiarle el nombre, cambiar el propietario o quitar los permisos de lectura y escritura, todav√≠a tendr√© acceso a √©l, porque en el momento en que se abra el archivo, Ten√≠a derecho a leerlo y / o escribirlo, y logr√© comenzar a trabajar con √©l, lo que significa que debo seguir haci√©ndolo. <br><br>  En Linux, la biblioteca libc se abre para cada archivo descriptor de la aplicaci√≥n (proceso) 3 en ejecuci√≥n, con n√∫meros 0,1,2.  Puede encontrar m√°s informaci√≥n en los enlaces <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">man stdio</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">man stdout</a> <br><br><ul><li>  El descriptor de archivo 0 se llama STDIN y est√° asociado con la entrada de datos desde la aplicaci√≥n </li><li>  El descriptor de archivo 1 se llama STDOUT y las aplicaciones lo utilizan para generar datos, por ejemplo, comandos de impresi√≥n </li><li>  El descriptor de archivo 2 se llama STDERR y las aplicaciones lo utilizan para generar datos de informes de errores. </li></ul><br>  Si en su programa abre un archivo para leer o escribir, lo m√°s probable es que obtenga la primera identificaci√≥n gratuita y esta ser√° la n√∫mero 3. <br><br>  Se puede ver una lista de archivos descriptores desde cualquier proceso si conoce su PID. <br><br>  Por ejemplo, abra una consola con bash y vea el PID de nuestro proceso <br><br><pre><code class="bash hljs">[user@localhost ]$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ 15771</code> </pre> <br>  En la segunda consola, ejecute <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -lah /proc/15771/fd/ total 0 dr-x------ 2 user user 0 Oct 7 15:42 . dr-xr-xr-x 9 user user 0 Oct 7 15:42 .. lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21</code> </pre><br>  Puede ignorar de manera segura el n√∫mero de descriptor de archivo 255 en el marco de este art√≠culo; bash lo abri√≥ para sus necesidades y no una biblioteca vinculada. <br><br>  Ahora los 3 archivos descriptores est√°n asociados con el dispositivo pseudo-terminal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">/ dev / pts</a> , pero a√∫n podemos manipularlos, por ejemplo, ejecutarlos en la segunda consola <br><br><pre> <code class="bash hljs">[user@localhost ]$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello world"</span></span> &gt; /proc/15771/fd/0</code> </pre><br>  Y en la primera consola veremos <br><br><pre> <code class="bash hljs">[user@localhost ]$ hello world</code> </pre><br><h3>  Redirigir y canalizar </h3><br>  Puede anular f√°cilmente estos 3 archivos descriptores en cualquier proceso, incluso en bash, por ejemplo, a trav√©s de una tuber√≠a que conecta dos procesos, consulte <br><br><pre> <code class="bash hljs">[user@localhost ]$ cat /dev/zero | sleep 10000</code> </pre><br>  Puede ejecutar este comando usted mismo con <i>strace -f</i> y ver qu√© sucede dentro, pero le contar√© brevemente. <br><br>  Nuestro proceso principal bash con PID 15771 analiza nuestro comando y comprende exactamente cu√°ntos comandos queremos ejecutar, en nuestro caso hay dos de ellos: cat y sleep.  Bash sabe que necesita crear dos procesos secundarios y combinarlos con una tuber√≠a.  Total bash necesitar√° 2 procesos secundarios y una tuber√≠a. <br><br>  Antes de crear procesos secundarios, bash inicia la llamada al sistema de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tuber√≠as</a> y recibe nuevos descriptores de archivo para el b√∫fer de tuber√≠a temporal, pero este b√∫fer a√∫n no une nuestros dos procesos secundarios. <br><br>  Para el proceso padre, parece que la tuber√≠a ya existe, y todav√≠a no hay procesos hijos: <br><br><pre> <code class="bash hljs">PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 15771 bash lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21</code> </pre><br>  Luego, usando una llamada al sistema, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clone</a> bash crea dos procesos secundarios, y nuestros tres procesos se ver√°n as√≠: <br><br><pre> <code class="bash hljs">PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 15771 bash lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21 PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 9004 bash lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 255 -&gt; /dev/pts/21 PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 9005 bash lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 255 -&gt; /dev/pts/21</code> </pre><br>  No olvide que clonar clona el proceso junto con todos los descriptores de archivo, por lo que ser√°n los mismos en el proceso primario y en los secundarios.  La tarea del proceso principal con PID 15771 es monitorear los procesos secundarios, por lo que solo espera una respuesta de los procesos secundarios. <br><br>  Por lo tanto, no necesita tuber√≠a, y cierra los descriptores de archivo con los n√∫meros 3 y 4. <br><br>  En el primer proceso secundario de bash con PID 9004, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llamada del</a> sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dup2</a> cambia nuestro descriptor de archivo STDOUT con el n√∫mero 1 a un descriptor de archivo que apunta a pipe, en nuestro caso es el n√∫mero 3. Por lo tanto, todo lo que el primer proceso secundario con PID 9004 escribir√° en STDOUT caer√° autom√°ticamente en el buffer de la tuber√≠a. <br><br>  En el segundo proceso secundario con PID 9005, bash cambia el descriptor de archivo STDIN con el n√∫mero 0 usando dup2. Ahora todo lo que leer√° nuestro segundo bash con PID 9005 se leer√° desde la tuber√≠a. <br><br>  Despu√©s de eso, los descriptores con los n√∫meros 3 y 4 tambi√©n se cierran en los procesos secundarios, ya que ya no se usan. <br><br>  Ignoro deliberadamente el descriptor de archivo 255, usa bash para necesidades internas y tambi√©n se cerrar√° en procesos secundarios. <br><br>  Luego, en el primer proceso secundario con PID 9004, bash inicia el archivo ejecutable que especificamos en la l√≠nea de comando con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">exec de la</a> llamada al sistema, en nuestro caso es / usr / bin / cat. <br><br>  En el segundo proceso secundario con PID 9005, bash inicia el segundo archivo ejecutable que especificamos, en nuestro caso es / usr / bin / sleep. <br><br>  La llamada al sistema ejecutivo no cierra los descriptores de archivo si no se abrieron con el indicador O_CLOEXEC durante la llamada abierta.  En nuestro caso, despu√©s de ejecutar los archivos ejecutables, se guardar√°n todos los descriptores de archivos actuales. <br><br>  Compruebe en la consola: <br><br><pre> <code class="bash hljs">[user@localhost ]$ pgrep -P 15771 9004 9005 [user@localhost ]$ ls -lah /proc/15771/fd/ total 0 dr-x------ 2 user user 0 Oct 7 15:42 . dr-xr-xr-x 9 user user 0 Oct 7 15:42 .. lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21 [user@localhost ]$ ls -lah /proc/9004/fd total 0 dr-x------ 2 user user 0 Oct 7 15:57 . dr-xr-xr-x 9 user user 0 Oct 7 15:57 .. lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 l-wx------ 1 user user 64 Oct 7 15:57 1 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lr-x------ 1 user user 64 Oct 7 15:57 3 -&gt; /dev/zero [user@localhost ]$ ls -lah /proc/9005/fd total 0 dr-x------ 2 user user 0 Oct 7 15:57 . dr-xr-xr-x 9 user user 0 Oct 7 15:57 .. lr-x------ 1 user user 64 Oct 7 15:57 0 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 [user@localhost ]$ ps -up 9004 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND user 9004 0.0 0.0 107972 620 pts/21 S+ 15:57 0:00 cat /dev/zero [user@localhost ]$ ps -up 9005 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND user 9005 0.0 0.0 107952 360 pts/21 S+ 15:57 0:00 sleep 10000</code> </pre><br>  Como puede ver, el n√∫mero √∫nico de nuestra tuber√≠a es el mismo en ambos procesos.  Entonces tenemos una conexi√≥n entre dos procesos diferentes con un padre. <br><br>  Para aquellos que no est√°n familiarizados con las llamadas al sistema que usa bash, les recomiendo ejecutar los comandos a trav√©s de strace y ver qu√© sucede dentro, por ejemplo, as√≠: <br><br><pre> <code class="bash hljs">strace -s 1024 -f bash -c <span class="hljs-string"><span class="hljs-string">"ls | grep hello"</span></span></code> </pre><br>  Volvamos a nuestro problema de quedarse sin espacio en disco e intentar guardar datos sin reiniciar el proceso.  Escribamos un peque√±o programa que escribir√° en el disco aproximadamente 1 megabyte por segundo.  Adem√°s, si por alguna raz√≥n no pudi√©ramos escribir datos en el disco, simplemente lo ignoraremos e intentaremos escribir datos nuevamente despu√©s de un segundo.  En el ejemplo que uso Python, puedes usar cualquier otro lenguaje de programaci√≥n. <br><br><pre> <code class="python hljs">[user@localhost ]$ cat openforwrite.py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time mystr=<span class="hljs-string"><span class="hljs-string">"a"</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>+<span class="hljs-string"><span class="hljs-string">"\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: f.write(str(datetime.datetime.now())) f.write(mystr) f.flush() time.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  Ejecute el programa y mire los descriptores de archivo <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py &amp; [1] 3762 [user@localhost ]$ ps axuf | grep [o]penforwrite user 3762 0.0 0.0 128600 5744 pts/22 S+ 16:28 0:00 | \_ python openforwrite.py [user@localhost ]$ ls -la /proc/3762/fd total 0 dr-x------ 2 user user 0 Oct 7 16:29 . dr-xr-xr-x 9 user user 0 Oct 7 16:29 .. lrwx------ 1 user user 64 Oct 7 16:29 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 7 16:29 3 -&gt; /home/user/123.txt</code> </pre><br>  Como puede ver, tenemos nuestros 3 descriptores de archivo est√°ndar y otro que abrimos.  Verifique el tama√±o del archivo: <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 user user 117M Oct 7 16:30 123.txt</code> </pre><br>  se est√°n escribiendo datos, intente cambiar los permisos del archivo: <br><br><pre> <code class="bash hljs">[user@localhost ]$ sudo chown root: 123.txt [user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 root root 168M Oct 7 16:31 123.txt [user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 root root 172M Oct 7 16:31 123.txt</code> </pre><br>  Vemos que los datos a√∫n se est√°n escribiendo, aunque nuestro usuario no tiene derecho a escribir en el archivo.  Intentemos eliminarlo: <br><br><pre> <code class="bash hljs">[user@localhost ]$ sudo rm 123.txt [user@localhost ]$ ls 123.txt ls: cannot access 123.txt: No such file or directory</code> </pre><br>  ¬øD√≥nde se escriben los datos?  ¬øY est√°n escritos en absoluto?  Comprobamos: <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -la /proc/3762/fd total 0 dr-x------ 2 user user 0 Oct 7 16:29 . dr-xr-xr-x 9 user user 0 Oct 7 16:29 .. lrwx------ 1 user user 64 Oct 7 16:29 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 7 16:29 3 -&gt; /home/user/123.txt (deleted)</code> </pre><br>  S√≠, nuestro archivo descriptor todav√≠a existe, y podemos trabajar con este archivo descriptor como con nuestro archivo anterior, podemos leerlo, limpiarlo y copiarlo. <br><br>  Nos fijamos en el tama√±o del archivo: <br><br><pre> <code class="bash hljs">[user@localhost ]$ lsof | grep 123.txt python 31083 user 3w REG 8,5 19923457 2621522 /home/user/123.txt</code> </pre><br>  Tama√±o de archivo 19923457. Intentando borrar el archivo: <br><br><pre> <code class="bash hljs">[user@localhost ]$ truncate -s 0 /proc/31083/fd/3 [user@localhost ]$ lsof | grep 123.txt python 31083 user 3w REG 8,5 136318390 2621522 /home/user/123.txt</code> </pre><br>  Como puede ver, el tama√±o del archivo solo est√° aumentando y nuestro trankate no funcion√≥.  Consulte la documentaci√≥n de la llamada al sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">abierto</a> .  Si usamos el indicador O_APPEND al abrir un archivo, cada vez que el sistema operativo verifica el tama√±o del archivo y escribe datos hasta el final del archivo, lo hace at√≥micamente.  Esto permite que m√∫ltiples hilos o procesos escriban en el mismo archivo.  Pero en nuestro c√≥digo no usamos esta bandera.  Podemos ver un tama√±o de archivo diferente en lsof despu√©s de la conversi√≥n solo si abrimos el archivo para una grabaci√≥n adicional, lo que significa que en lugar de en nuestro c√≥digo <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br>  tenemos que poner <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"a"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br>  Comprobando con la bandera "w" <br><br><pre> <code class="bash hljs">[user@localhost ]$ strace -e trace=open python openforwrite.py 2&gt;&amp;1| grep 123.txt open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3</code> </pre><br>  y con la bandera "a" <br><br><pre> <code class="bash hljs">[user@localhost ]$ strace -e trace=open python openforwrite.py 2&gt;&amp;1| grep 123.txt open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, O_WRONLY|O_CREAT|O_APPEND, 0666) = 3</code> </pre><br><h3>  Programar un proceso ya en ejecuci√≥n </h3><br>  A menudo, los programadores usan depuradores (por ejemplo, GDB) o varios niveles de inicio de sesi√≥n en la aplicaci√≥n al crear y probar programas.  Linux proporciona la capacidad de escribir y cambiar un programa que ya se est√° ejecutando, por ejemplo, cambiar los valores de las variables, establecer puntos de interrupci√≥n, etc., etc. <br><br>  Volviendo a la pregunta original sin suficiente espacio en disco para escribir el archivo, intentaremos emular el problema. <br><br>  Cree un archivo para nuestra partici√≥n, que montaremos como un disco separado: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=~/tempfile_for_article.dd bs=1M count=10 10+0 records <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 10+0 records out 10485760 bytes (10 MB) copied, 0.00525929 s, 2.0 GB/s [user@localhost ~]$</code> </pre><br>  Crea un sistema de archivos: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ mkfs.ext4 ~/tempfile_for_article.dd mke2fs 1.42.9 (28-Dec-2013) /home/user/tempfile_for_article.dd is not a block special device. Proceed anyway? (y,n) y ... Writing superblocks and filesystem accounting information: <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> [user@localhost ~]$</code> </pre><br>  Montar el sistema de archivos: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ sudo mount ~/tempfile_for_article.dd /mnt/ [sudo] password <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> user: [user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 172K 7.9M 3% /mnt</code> </pre><br>  Crea un directorio con nuestro propietario: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ sudo mkdir /mnt/logs [user@localhost ~]$ sudo chown user: /mnt/logs</code> </pre><br>  Abrimos el archivo para escribir solo en nuestro programa: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"/mnt/logs/123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br>  Lanzamos <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py</code> </pre><br>  Esperando unos segundos <br><br><pre> <code class="bash hljs">[user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 8.0M 0 100% /mnt</code> </pre><br>  Entonces, tenemos el problema descrito al comienzo de este art√≠culo.  Espacio libre 0, ocupado 100%. <br><br>  Recordamos que de acuerdo con las condiciones de la tarea, estamos tratando de registrar datos muy importantes que no se pueden perder.  Y al mismo tiempo, necesitamos reparar el servicio sin reiniciar el proceso. <br><br>  Supongamos que todav√≠a tenemos espacio en disco, pero en una partici√≥n diferente, por ejemplo en / home. <br><br>  Intentemos "reprogramar sobre la marcha" nuestro c√≥digo. <br><br>  Observamos el PID de nuestro proceso, que se comi√≥ todo el espacio en disco: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ps axuf | grep [o]penfor user 10078 27.2 0.0 128600 5744 pts/22 R+ 11:06 0:02 | \_ python openforwrite.py</code> </pre><br>  Nos conectamos al proceso a trav√©s de gdb <br><br><pre> <code class="bash hljs">[user@localhost ~]$ gdb -p 10078 ... (gdb)</code> </pre><br>  Nos fijamos en los descriptores de archivos abiertos: <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /mnt/logs/123.txt</code> </pre><br>  Observamos la informaci√≥n sobre el descriptor de archivo con el n√∫mero 3, que nos interesa <br><br><pre> <code class="bash hljs">(gdb) shell cat /proc/10078/fdinfo/3 pos: 8189952 flags: 0100001 mnt_id: 482</code> </pre><br>  Recordando qu√© tipo de llamada al sistema hace Python (ver arriba, d√≥nde ejecutamos strace y encontramos la llamada abierta), procesando nuestro c√≥digo para abrir el archivo, hacemos lo mismo en nuestro propio nombre, pero necesitamos los bits O_WRONLY | O_CREAT | O_TRUNC reemplazar con un valor num√©rico.  Para hacer esto, abra las fuentes del n√∫cleo, por ejemplo, <a href="">aqu√≠</a> y vea qu√© indicadores son responsables de qu√© <br><br>  #define O_WRONLY 00000001 <br>  #define O_CREAT 00000100 <br>  #define O_TRUNC 00001000 <br><br>  Combinamos todos los valores en uno, obtenemos 00001101 <br><br>  Ejecute nuestra llamada desde gdb <br><br><pre> <code class="bash hljs">(gdb) call open(<span class="hljs-string"><span class="hljs-string">"/home/user/123.txt"</span></span>, 00001101,0666) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 4</code> </pre><br>  Entonces obtuvimos un nuevo archivo descriptor con el n√∫mero 4 y un nuevo archivo abierto en otra secci√≥n, verifique: <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /mnt/logs/123.txt l-wx------ 1 user user 64 Oct 8 11:15 4 -&gt; /home/user/123.txt</code> </pre><br>  Recordamos el ejemplo de la tuber√≠a: c√≥mo bash cambia los descriptores de archivo y ya hemos aprendido la llamada al sistema dup2. <br><br>  Intentamos reemplazar un descriptor de archivo por otro <br><br><pre> <code class="bash hljs">(gdb) call dup2(4,3) <span class="hljs-variable"><span class="hljs-variable">$2</span></span> = 3</code> </pre><br>  Comprobamos: <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /home/user/123.txt l-wx------ 1 user user 64 Oct 8 11:15 4 -&gt; /home/user/123.txt</code> </pre><br>  Cerramos el descriptor de archivo 4, ya que no lo necesitamos: <br><br><pre> <code class="bash hljs">(gdb) call close (4) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 0</code> </pre><br>  Y salir de gdb <br><br><pre> <code class="bash hljs">(gdb) quit A debugging session is active. Inferior 1 [process 10078] will be detached. Quit anyway? (y or n) y Detaching from program: /usr/bin/python2.7, process 10078</code> </pre><br>  Verifique el nuevo archivo: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /home/user/123.txt -rw-rw-r-- 1 user user 5.1M Oct 8 11:18 /home/user/123.txt [user@localhost ~]$ ls -lah /home/user/123.txt -rw-rw-r-- 1 user user 7.1M Oct 8 11:18 /home/user/123.txt</code> </pre><br>  Como puede ver, los datos se escriben en un nuevo archivo, verificamos el anterior: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /mnt/logs/123.txt -rw-rw-r-- 1 user user 7.9M Oct 8 11:08 /mnt/logs/123.txt</code> </pre><br>  Los datos no se pierden, la aplicaci√≥n funciona, los registros se escriben en un nuevo lugar. <br><br><h3>  Vamos a complicar un poco la tarea </h3><br>  Imagine que los datos son importantes para nosotros, pero no tenemos espacio en disco en ninguna de las secciones y no podemos conectar el disco. <br><br>  Lo que podemos hacer es redirigir nuestros datos en alg√∫n lugar, por ejemplo, a la tuber√≠a, y los datos de la tuber√≠a, a su vez, redirigen a la red a trav√©s de alg√∫n programa, como netcat. <br>  Podemos crear una tuber√≠a con nombre con el comando mkfifo.  Crear√° un pseudo archivo en el sistema de archivos, incluso si no hay espacio libre en √©l. <br><br>  Reiniciamos la aplicaci√≥n y verificamos: <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py [user@localhost ~]$ ps axuf | grep [o]pen user 5946 72.9 0.0 128600 5744 pts/22 R+ 11:27 0:20 | \_ python openforwrite.py [user@localhost ~]$ ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt [user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 8.0M 0 100% /mnt</code> </pre><br>  No hay espacio en disco, pero creamos con √©xito una tuber√≠a con nombre all√≠: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ mkfifo /mnt/logs/megapipe [user@localhost ~]$ ls -lah /mnt/logs/megapipe prw-rw-r-- 1 user user 0 Oct 8 11:28 /mnt/logs/megapipe</code> </pre><br>  Ahora necesitamos envolver de alguna manera todos los datos que ingresan en esta tuber√≠a a otro servidor a trav√©s de la red, para esto har√° lo mismo netcat. <br><br>  En el servidor remote-server.example.com, ejecute <br><br><pre> <code class="bash hljs">[user@localhost ~]$ nc -l 7777 &gt; 123.txt</code> </pre><br>  En nuestro servidor problem√°tico, ejecute en una terminal separada <br><br><pre> <code class="bash hljs">[user@localhost ~]$ nc remote-server.example.com 7777 &lt; /mnt/logs/megapipe</code> </pre><br>  Ahora todos los datos que ingresan a la tuber√≠a ir√°n autom√°ticamente a stdin en netcat, que los enviar√° a la red en el puerto 7777. <br><br>  Todo lo que tenemos que hacer es comenzar a escribir nuestros datos en esta tuber√≠a con nombre. <br><br>  Ya tenemos una aplicaci√≥n en ejecuci√≥n: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ps axuf | grep [o]pen user 5946 99.8 0.0 128600 5744 pts/22 R+ 11:27 169:27 | \_ python openforwrite.py [user@localhost ~]$ ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt</code> </pre><br>  De todas las banderas, solo necesitamos O_WRONLY ya que el archivo ya existe y no necesitamos borrarlo <br><br><pre> <code class="bash hljs">[user@localhost ~]$ gdb -p 5946 ... (gdb) call open(<span class="hljs-string"><span class="hljs-string">"/mnt/logs/megapipe"</span></span>, 00000001,0666) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 4 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt l-wx------ 1 user user 64 Oct 8 14:20 4 -&gt; /mnt/logs/megapipe (gdb) call dup2(4,3) <span class="hljs-variable"><span class="hljs-variable">$2</span></span> = 3 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/megapipe l-wx------ 1 user user 64 Oct 8 14:20 4 -&gt; /mnt/logs/megapipe (gdb) call close(4) <span class="hljs-variable"><span class="hljs-variable">$3</span></span> = 0 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/megapipe (gdb) quit A debugging session is active. Inferior 1 [process 5946] will be detached. Quit anyway? (y or n) y Detaching from program: /usr/bin/python2.7, process 5946</code> </pre><br>  Comprobaci√≥n del servidor remoto remote-server.example.com <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah 123.txt -rw-rw-r-- 1 user user 38M Oct 8 14:21 123.txt</code> </pre><br>  Los datos van, verificamos un servidor problem√°tico <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /mnt/logs/ total 7.9M drwxr-xr-x 2 user user 1.0K Oct 8 11:28 . drwxr-xr-x 4 root root 1.0K Oct 8 10:55 .. -rw-rw-r-- 1 user user 7.9M Oct 8 14:17 123.txt prw-rw-r-- 1 user user 0 Oct 8 14:22 megapipe</code> </pre><br>  Datos guardados, problema resuelto. <br><br>  Aprovecho esta oportunidad para transmitir mis saludos a mis colegas de Degiro. <br>  Escuche los podcasts de Radio T. <br><br>  Bueno para todos <br><br>  Como tarea, me propongo pensar en lo que habr√° en los descriptores de archivo del proceso gato y sue√±o si ejecuta este comando: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ cat /dev/zero 2&gt;/dev/null| sleep 10000</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471038/">https://habr.com/ru/post/471038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471026/index.html">TypeScript Poder nunca</a></li>
<li><a href="../471028/index.html">Carro para camiones ROS. Parte 6. Odometr√≠a con codificadores de rueda, mapa de habitaci√≥n, lidar</a></li>
<li><a href="../471032/index.html">Foto invisible</a></li>
<li><a href="../471034/index.html">Entrevista con el desarrollador web de Pornhub</a></li>
<li><a href="../471036/index.html">Vive y aprende. Parte 5. Autoeducaci√≥n: recuperarse</a></li>
<li><a href="../471040/index.html">[marcador] Versi√≥n PDF y ePUB del manual React</a></li>
<li><a href="../471042/index.html">Resoluci√≥n de problemas con pwnable.kr 25 - otp. L√≠mite de tama√±o de archivo de Linux</a></li>
<li><a href="../471044/index.html">Sass MediaScreen: definici√≥n de dispositivos CSS</a></li>
<li><a href="../471046/index.html">Avalonia con estilo</a></li>
<li><a href="../471048/index.html">Reaccionar + Mobx: ¬øcu√°l es el punto?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>