<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí° üåì üì≥ Regardez-moi en entier: tirez le meilleur parti de la vid√©o en direct sur les plateformes mobiles üññüèº üçî üëàüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La fa√ßon la plus simple de lire une vid√©o sur un appareil mobile est d'ouvrir le lien avec un lecteur existant sur le syst√®me, mais ce n'est pas toujo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Regardez-moi en entier: tirez le meilleur parti de la vid√©o en direct sur les plateformes mobiles</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/467669/"><img src="https://habrastorage.org/webt/3z/wx/89/3zwx89x0wbx0euzwj3a_f8vttwo.jpeg"><br><br>  La fa√ßon la plus simple de lire une vid√©o sur un appareil mobile est d'ouvrir le lien avec un lecteur existant sur le syst√®me, mais ce n'est pas toujours efficace. <br><br>  Vous pouvez prendre ExoPlayer et l'optimiser, ou vous pouvez m√™me √©crire votre propre lecteur vid√©o en utilisant uniquement des codecs et des sockets.  L'article parlera du travail de streaming et de lecture vid√©o, et comment r√©duire le d√©lai de d√©marrage de la vid√©o, r√©duire le temps de r√©ponse entre le streamer et le spectateur, et optimiser la consommation d'√©nergie et la charge de fer. <br><br>  Nous analyserons cela en utilisant des applications sp√©cifiques √† titre d'exemple: le client mobile Odnoklassniki (o√π les vid√©os sont lues) et OK Live (o√π les √©missions sont diffus√©es du t√©l√©phone en 1080p).  Il n'y aura pas de master classes sur la fa√ßon de lire une vid√©o par r√©f√©rence, avec des exemples de code.  L'histoire se concentrera sur l'apparence de la vid√©o de l'int√©rieur et comment, connaissant l'architecture g√©n√©rale des lecteurs vid√©o et du streaming vid√©o, vous pouvez comprendre n'importe quel syst√®me et l'am√©liorer. <br><br>  Le mat√©riel est bas√© sur la transcription du rapport d' <b>Alexander Tobol</b> ( <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@alatobol</a></b> ) et <b>Ivan Grigoriev</b> ( <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@ivan_a</a></b> ) de la conf√©rence <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mobius</a></b> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/e1JYFRwHzkQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><a name="habracut"></a><br><h2>  Entr√©e </h2><br>  Pour commencer - quelques chiffres sur la vid√©o √† Odnoklassniki. <br><br>  Le trafic quotidien moyen de pointe en VOD (vid√©o √† la demande) est de plus d'un t√©rabits et demi par seconde, et pour les diffusions en direct - de plus de 3 t√©rabits par seconde. <br><br>  Maintenant, il y a plus de 870 millions de vues vid√©o par jour dans OK, dont plus de la moiti√© proviennent d'appareils mobiles. <br><br><img src="https://habrastorage.org/webt/xt/nl/ij/xtnlijaizuntzzpkihtkpi-juws.jpeg"><br><br>  Si vous regardez l'histoire du streaming, une vid√©o mobile est apparue sur YouTube en 2007.  Nous avons saut√© dans ce train plus tard, mais en 2014-2015, nous avions d√©j√† une lecture vid√©o 4K sur des appareils mobiles, et ces derni√®res ann√©es, nous avons activement d√©velopp√© nos joueurs.  √Ä ce sujet et la conversation se poursuivra. <br><br>  La deuxi√®me tendance qui est apparue avec Periscope en 2015 √©tait la diffusion √† partir de t√©l√©phones.  Nous avons lanc√© notre application OK Live, qui vous permet de diffuser m√™me des vid√©os Full HD sur les r√©seaux mobiles.  Dans la seconde moiti√© du mat√©riel, nous parlerons √©galement de streaming. <br><br>  Nous ne nous attarderons pas sur l'API pour travailler avec la vid√©o, mais pour l'instant plonger profond√©ment et essayer de d√©couvrir ce qui se passe √† l'int√©rieur. <br><br><img src="https://habrastorage.org/webt/4d/ne/-v/4dne-vlspxhbv3rm3wxixirrc8o.jpeg"><br><br>  Lorsque vous filmez une vid√©o sur un appareil photo, elle parvient au codec, de l√† √† la prise, puis au serveur (que ce soit en VOD ou en direct).  Et puis le serveur dans l'ordre inverse le distribue au public. <br><br>  Commen√ßons par le lecteur KPI.  Que voulons-nous de lui? <br><br><ul><li>  Premi√®re image rapide.  Les utilisateurs ne veulent pas attendre le d√©but de la lecture. </li><li>  Manque de mise en m√©moire tampon.  Personne n'aime se heurter au torse. </li><li>  De haute qualit√©.  Lorsqu'il n'y avait presque pas encore de contenu 4K, nous avons d√©j√† rendu la prise en charge 4K ¬´d√©pass√©e¬ª: si vous √©teignez le lecteur pour cela et d√©terminez les performances, alors 1080p jouera parfaitement m√™me sur des appareils faibles. </li><li>  Exigences UX.  Nous avons besoin que la vid√©o soit lue dans la bande pendant le d√©filement, et pour la bande, nous devons pr√©-extraire la vid√©o. </li></ul><br><br>  Il existe de nombreux probl√®mes de cette mani√®re.  Le flux de vid√©o 4K est important et nous travaillons sur des appareils mobiles o√π il y a des probl√®mes avec le r√©seau, il existe diverses fonctionnalit√©s de formats vid√©o et de conteneurs sur diff√©rents appareils, et les appareils eux-m√™mes peuvent √©galement devenir un probl√®me. <br><br>  O√π pensez-vous que la vid√©o d√©marre plus rapidement, sur iOS ou Android? <br><br>  En fait, toute r√©ponse est correcte: cela d√©pend de quoi, o√π et comment jouer.  Si nous prenons une r√©gion de la Russie avec un r√©seau moins bon, nous verrons que AVPlayer d√©marre √† environ 800 millisecondes.  Mais avec le m√™me r√©seau, ExoPlayer sur Android, jouant un format diff√©rent, le lancera en 660 ms.  Et si vous cr√©ez votre lecteur sur iOS, il pourra fonctionner encore plus rapidement. <br><br><img src="https://habrastorage.org/webt/eb/jl/ao/ebjlao75uhegqjpd6mn-nfjuakk.jpeg"><br><br>  Il y a une nuance dans la mesure o√π nous mesurons la moyenne pour les utilisateurs, et la puissance moyenne des appareils iOS est plus √©lev√©e que sur Android. <br><br>  La premi√®re partie du mat√©riel sera th√©orique: nous apprendrons ce qu'est la vid√©o et √† quoi ressemble l'architecture de n'importe quel lecteur Live.  Et dans la deuxi√®me partie, comparons les joueurs et parlons du moment d'√©crire le v√¥tre. <br><br><h2>  Premi√®re partie </h2><br><h3>  Qu'est-ce que la vid√©o </h3><br>  Commen√ßons par le plus basique.  La vid√©o est de 60 ou 24 images par seconde. <br><br>  √âvidemment, le stocker avec un ensemble complet d'images est assez cher.  Par cons√©quent, ils sont stock√©s de cette mani√®re: certaines trames sont appel√©es trames de r√©f√©rence (trames I), tandis que d'autres (trames B et trames P) sont appel√©es ¬´diffs¬ª.  En fait, vous avez un fichier jpg et un ensemble sp√©cifique de modifications. <br><br><img src="https://habrastorage.org/webt/lf/rk/nt/lfrknthpx0phqp5u7psr0if5j78.jpeg"><br><br>  Il y a aussi le concept de GOP (groupe d'images) - c'est un ensemble ind√©pendant d'images, qui commence par une image de r√©f√©rence et continue avec un ensemble de diffs.  Il peut √™tre jou√© ind√©pendamment, d√©ball√© et ainsi de suite.  Dans le m√™me temps, si vous avez perdu un opornik dans le groupe, les images restantes ne sont plus pertinentes. <br><br>  Il existe de nombreux algorithmes de codage, matrices de transformation, recherche de mouvement, etc. - c'est en cela que les codecs diff√®rent. <br><br><h3>  Performances du codec </h3><br><br><img src="https://habrastorage.org/webt/q7/mj/ts/q7mjtslvjdqlperjccv0etipmgk.jpeg"><br><br>  Le H.264 classique est connu depuis 2003 et s'est bien d√©velopp√©.  Nous prendrons son efficacit√© comme base.  Il travaille et joue partout.  Il a un support mat√©riel pour CPU / GPU (√† la fois sur iOS, sur Android).  Cela signifie qu'il existe soit une sorte de coprocesseur sp√©cial qui peut le coder, soit des jeux d'instructions int√©gr√©s qui vous permettent de le faire rapidement.  En moyenne, le support mat√©riel offre des performances jusqu'√† 10 fois plus rapides et √©conomise la dur√©e de vie de la batterie. <br><br>  En 2010, VP8 de Google est apparu.  En termes d'efficacit√©, il ne diff√®re pas du H.264.  Eh bien, en fait, l'efficacit√© du codec est une chose tr√®s controvers√©e.  Dans le front, il est mesur√© comme le rapport de la vid√©o originale sur la vid√©o compress√©e, mais il est clair qu'il existe diff√©rents artefacts vid√©o.  Par cons√©quent, nous fournissons un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> vers des comparaisons d√©taill√©es de codecs de l'Universit√© d'√âtat de Moscou.  Mais ici, nous nous limitons au fait que VP8 se concentre sur une organisation logicielle, vous pouvez le faire glisser avec vous n'importe o√π, et il est g√©n√©ralement utilis√© comme solution de rechange s'il n'y a pas de support H.264 natif. <br><br>  En 2013, une nouvelle g√©n√©ration de codecs est apparue - H.265 (HEVC) et VP9.  Le codec H.265 donne une augmentation de l'efficacit√© de 50%, mais sur la vid√©o Android, ils ne peuvent pas √™tre encod√©s, le d√©codeur est apparu uniquement avec Android 5.0+.  Mais sur iOS, il existe un support. <br><br>  Il existe une alternative √† H.265 - VP9.  Tout de m√™me, mais pris en charge par Google.  Eh bien, V9 est YouTube et H.265 est Netflix.  Ainsi, chacun a ses propres particularit√©s: l'un ne fonctionnera pas sur iOS, l'autre aura des probl√®mes sur Android.  Au final, beaucoup restent sur H.264. <br><br>  √Ä l'avenir, on nous promet le codec AV1, il a d√©j√† une impl√©mentation logicielle, et son efficacit√© est 35% sup√©rieure √† celle des codecs 2013.  D√©sormais disponible dans Chrome et Firefox, et en 2020, Google promet une prise en charge mat√©rielle - je pense que, tr√®s probablement, nous y passerons tous. <br><br>  Enfin, ils ont r√©cemment annonc√© le codec H.266 / JVEC, affirmant que tout sera meilleur et plus rapide. <br><br>  Le sch√©ma principal: plus l'efficacit√© du codec est √©lev√©e, plus il n√©cessite de ressources informatiques des appareils. <br><br>  En g√©n√©ral, par d√©faut, tout le monde prend H.264, puis pour des appareils sp√©cifiques, cela peut √™tre compliqu√©. <br><br><h3>  Qualit√©, r√©solution et bitrate </h3><br>  En 2019, vous ne surprendrez personne avec une qualit√© adaptative: les utilisateurs t√©l√©chargent ou diffusent des vid√©os en une seule qualit√©, et nous coupons une ligne de diff√©rentes qualit√©s et envoyons le plus adapt√© aux appareils. <br><br>  Dans ce cas, il est n√©cessaire que la r√©solution vid√©o soit en corr√©lation avec le d√©bit binaire.  Si la r√©solution est doubl√©e, le d√©bit binaire doit √©galement doubler: <br><br><img src="https://habrastorage.org/webt/vg/f0/y_/vgf0y_ve9h6r_0r-bvioww1qivw.jpeg"><br><br>  √âvidemment, si vous compressez une grande r√©solution avec un faible d√©bit binaire ou vice versa, il y aura soit des artefacts, soit une gravure inutile du d√©bit binaire. <br><br>  Comment le d√©bit binaire de la vid√©o encod√©e se compare-t-il √† la quantit√© d'informations d'origine?  Sur un √©cran 4K, nous pouvons lire pr√®s de 6 Gb / s d'informations (si vous comptez tous les pixels et leur fr√©quence √† 60 images par seconde), tandis que le d√©bit binaire du codec peut √™tre de 50 Mb / s.  Autrement dit, le codec comprime la vid√©o jusqu'√† 100 fois. <br><br><h3>  Technologie de livraison </h3><br>  Vous avez de l'audio et de la vid√©o emball√©s avec certains codecs.  Si vous le gardez √† la maison, vous pouvez ajouter tout l'audio et la vid√©o en ajoutant un petit index qui vous indique √† quelle seconde commence l'audio et la vid√©o.  Mais la vid√©o ne peut pas √™tre livr√©e au t√©l√©phone, et pour le streaming vers le spectateur en ligne, il existe deux classes principales de protocoles: le streaming et le segment. <br><br><img src="https://habrastorage.org/webt/yd/mn/bp/ydmnbpqbfq8p19nbq2wmdx4ktzi.jpeg"><br><br>  Le protocole de streaming implique que vous avez une sorte d'√©tat sur le serveur, le client aussi, et qu'il envoie des donn√©es.  Le serveur peut ajuster, par exemple, la qualit√©.  Il s'agit tr√®s souvent d'une connexion UDP. <br><br>  De tels protocoles sont tr√®s complexes pour le serveur et difficiles √† fournir.  Pour les traductions lourdement charg√©es, nous utilisons des protocoles segment√©s qui fonctionnent au-dessus de HTTP, peuvent √™tre mis en cache par nginx et CDN, et ils sont beaucoup plus faciles √† distribuer.  Et le serveur n'est responsable de rien et, dans ce cas, apatride. <br><br>  √Ä quoi ressemble la livraison des segments: nous d√©coupons la vid√©o existante en segments, les accompagnons d'un en-t√™te pour l'audio et la vid√©o, MPEG-TS et MP4 comme exemple de transport.  Au t√©l√©phone, nous donnons un manifeste avec des informations sur o√π et pour quelle qualit√© se trouve le segment, et ce manifeste peut √™tre mis √† jour p√©riodiquement. <br><br>  Historiquement, Apple fournit via HLS et Android via DASH.  Voyons comment ils diff√®rent. <br><br>  Commen√ßons par l'ancien HLS, il a un manifeste qui d√©crit toutes les qualit√©s disponibles - faible, moyen, √©lev√©, etc.  Il existe des d√©bits binaires de ces qualit√©s afin que le joueur puisse imm√©diatement choisir la bonne.  Il choisit la qualit√© et obtient un manifeste imbriqu√© avec une liste de liens vers des segments.  La dur√©e de ces segments est √©galement indiqu√©e. <br><br><img src="https://habrastorage.org/webt/v5/xw/1r/v5xw1rnetgtu4wzdg7zmxsy2dqa.jpeg"><br><br>  Il y a une fonctionnalit√© int√©ressante ici: pour commencer √† jouer la premi√®re image, vous devrez faire deux allers-retours suppl√©mentaires.  La premi√®re demande, vous obtenez le manifeste principal, les manifestes second imbriqu√©s, et ensuite seulement acc√©der aux donn√©es elles-m√™mes, ce qui n'est pas tr√®s bon. <br><br><img src="https://habrastorage.org/webt/hy/2u/af/hy2uafqbmeujkyq9ishlykfqppc.jpeg"><br><br>  Deuxi√®me difficult√©: HLS a √©t√© con√ßu pour fonctionner sur Internet via HTTP, mais le flux de transport MPEG-2 h√©rit√© a √©t√© choisi comme conteneur pour les donn√©es vid√©o, qui a √©t√© d√©velopp√© √† des fins compl√®tement diff√©rentes: transmettre un signal d'un satellite dans des canaux bruyants.  En cons√©quence, nous obtenons des en-t√™tes suppl√©mentaires, qui dans le cas de HLS sont compl√®tement inutiles et ne font qu'ajouter des frais g√©n√©raux. <br><br><img src="https://habrastorage.org/webt/tm/ks/hs/tmkshszo_5atstyrbip1r64qs84.jpeg"><br><br>  Ajoutez une surcharge r√©seau et une complexit√© d'analyse: si vous essayez de lire 4K en DASH et HLS en Chrome, vous sentirez la diff√©rence lorsque votre ordinateur "d√©collera" avec des paquets HLS. <br><br>  Apple essaie de r√©soudre ce probl√®me.  En 2016, ils ont annonc√© la possibilit√© d'utiliser le MPEG-4 fragment√©, il y avait un certain support pour DASH dans HLS, mais le RTT suppl√©mentaire et ses fonctionnalit√©s n'ont pas disparu. <br><br><img src="https://habrastorage.org/webt/xa/zy/ai/xazyaila94udoix88ia0vvea0yq.jpeg"><br><br>  DASH semble un peu plus simple: vous avez un manifeste avec toutes les qualit√©s √† l'int√©rieur, et chaque qualit√© est un ensemble de segments.  Vous pouvez jouer un segment pour jouer dans une qualit√©, puis comprendre que la vitesse a augment√©, du segment suivant pour passer √† un autre.  Tous les segments commencent toujours par des cadres de r√©f√©rence, ce qui permet de basculer. <br><br>  Voici une petite assiette sur laquelle choisir: <br><br><img src="https://habrastorage.org/webt/mq/n1/pk/mqn1pkjswjel-yxavreufexrrjm.jpeg"><br><br>  En HLS, les codecs vid√©o historiquement pris en charge ne sont que H.264, en MPEG-DASH, vous pouvez pousser n'importe qui.  Le principal probl√®me de HLS est un aller-retour suppl√©mentaire au d√©but, il fonctionne bien sur iOS et Android avec 4.0.  Et DASH est principalement pris en charge par Google (Chrome et Android) et ne peut pas √™tre lu sur iOS. <br><br><h3>  Architecture du joueur </h3><br>  Nous avons tri√© la vid√©o plus ou moins, voyons maintenant √† quoi ressemble un joueur. <br><br><img src="https://habrastorage.org/webt/li/uj/ra/liujrart9xshdsg8d1ffcgztm6g.jpeg"><br><br>  Commen√ßons par la partie r√©seau: lors du d√©marrage d'une vid√©o, le lecteur suit le manifeste, s√©lectionne en quelque sorte la qualit√©, puis suit le segment, le t√©l√©charge, puis il doit d√©coder les images, comprendre qu'il y a suffisamment d'images dans le tampon pour la lecture, puis d√©marrer la lecture. <br><br>  L'architecture g√©n√©rale du joueur: <br><br><img src="https://habrastorage.org/webt/-z/n2/1q/-zn21q-9ufwdrtdwgongpnk9bcg.jpeg"><br><br>  Il y a une partie r√©seau, une socket, d'o√π proviennent les donn√©es. <br><br>  Apr√®s cela - un d√©multiplexeur ou une sorte de chose qui obtient les flux audio et vid√©o d'un transport (HLS / DASH).  Elle les envoie aux codecs appropri√©s. <br><br>  Les codecs d√©codent la vid√©o et l'audio, puis la chose la plus int√©ressante se produit: ils doivent √™tre synchronis√©s pour que votre vid√©o et votre audio soient lus simultan√©ment.  Il existe diff√©rents m√©canismes bas√©s sur des horodatages pour cela. <br><br>  Ensuite, vous devez le rendre quelque part - dans Texture, Surface, GL ou Metal, n'importe o√π. <br><br>  Et √† l'entr√©e, il y a un contr√¥le de charge, qui charge les donn√©es et contr√¥le le tampon. <br><br>  √Ä quoi ressemble le contr√¥le de charge sur tous les joueurs?  Il y a une certaine quantit√© de donn√©es √† t√©l√©charger.  Le joueur attend qu'ils soient t√©l√©charg√©s, puis commence √† jouer, et nous t√©l√©chargeons plus loin.  Nous avons la limite maximale de m√©moire tampon, lorsque le t√©l√©chargement s'arr√™te.  Apr√®s cela, pendant la lecture, la quantit√© de donn√©es dans le tampon diminue - et il y a une bordure minimale √† laquelle il commence √† se charger.  Donc tout cela vit aussi: <br><br><img src="https://habrastorage.org/webt/4z/qj/rr/4zqjrrvsfqngzhxe9dx6h_kncfw.jpeg"><br><br>  √Ä quoi ressemble le fil de boucle principal?  Les joueurs sont familiers avec le concept de ¬´tick tick¬ª, il semble √™tre l√†.  Il y a une partie responsable du r√©seau qui empile tout dans un seul tampon.  Il y a un extracteur qui d√©compresse et l'envoie aux codecs, o√π son tampon interm√©diaire, puis il ira pour le rendu.  Et vous avez une coche qui les d√©cale et les contr√¥le, traite de la synchronisation. <br><br><img src="https://habrastorage.org/webt/1e/1f/g6/1e1fg6x4ncbeslmzch3timofmfs.jpeg"><br><br>  √Ä l'ext√©rieur, vous disposez d'une application qui envoie certaines commandes via une file d'attente de messages et re√ßoit des informations via des √©couteurs.  Et parfois, une contre-pression peut appara√Ætre, ce qui r√©duit la qualit√© - par exemple, dans une situation o√π votre tampon est √©puis√© ou le rendu est incapable de faire face (par exemple, des images perdues apparaissent). <br><br><h3>  Estimateur </h3><br>  Lors de l'adaptation, le lecteur s'appuie sur 2 param√®tres principaux: la vitesse du r√©seau et le tampon de donn√©es. <br><br>  √Ä quoi cela ressemble: tout d'abord, une certaine qualit√© est reproduite, par exemple, 720p.  Vous avez un tampon croissant, de plus en plus en cache.  Ensuite, la vitesse augmente, vous comprenez que vous pouvez t√©l√©charger encore plus, le tampon augmente.  Et √† ce moment, vous comprenez que vous franchissez certaines limites du tampon minimum lorsque vous pouvez essayer la qualit√© suivante. <br><br><img src="https://habrastorage.org/webt/ef/ti/ch/eftichq4decehj34b_ekowarlmi.jpeg"><br><br>  Il est clair que vous devez l'essayer avec soin: il existe √©galement un estimateur qui indique si vous pouvez atteindre cette qualit√© en termes de vitesse du r√©seau.  Si vous vous situez dans cette √©valuation et que le stock tampon le permet, vous passez, par exemple, en 1080p et continuez √† jouer. <br><br><h3>  Protection contre la surpression </h3><br>  Avec nous, elle est apparue au fil du temps par essais et erreurs.  Le besoin s'en fait sentir lorsque vous surchargez l√©g√®rement votre √©quipement. <br><br>  Il y a une situation o√π le r√©seau s'√©mousse pendant la lecture ou les ressources s'√©puisent sur le backend.  Lorsque le lecteur reprend la lecture, il commence √† rattraper son retard. <br><br>  Un √©norme ensemble de segments s'est accumul√© dans le manifeste du joueur √† ce moment, il les t√©l√©charge rapidement tous en m√™me temps, et nous obtenons un "coup de trafic".  La situation peut √™tre aggrav√©e si un d√©lai d'attente se produit sur les clients et que le joueur commence √† interroger √† nouveau les donn√©es.  Par cons√©quent, il est n√©cessaire de pr√©voir une contre-pression dans le syst√®me. <br><br>  Le premier moyen simple que nous utilisons, bien s√ªr, est l'acc√©l√©rateur sur le serveur.  Il comprend que le trafic se termine, r√©duit la qualit√© et ralentit d√©lib√©r√©ment les clients afin de ne pas recevoir ce coup m√™me. <br><br><img src="https://habrastorage.org/webt/bn/ed/nz/bnednzqso81wrz0doypdlaa2phq.jpeg"><br><br>  Mais cela n'affecte pas tr√®s bien les estimateurs.  Ils peuvent g√©n√©rer les m√™mes ¬´rebondissements¬ª.  Par cons√©quent, si possible, soutenez la suppression de la qualit√© du manifeste.  Pour ce faire, vous devez soit mettre √† jour p√©riodiquement le manifeste, ou s'il y a un canal de r√©troaction, donner la commande pour supprimer la qualit√©, et le joueur passera automatiquement √† un autre, plus bas. <br><br><h3>  Joueurs </h3><br>  Dans iOS, il n'y a que AVPlayer natif, mais sur Android, il y a un choix.  Il existe un MediaPlayer natif, mais il existe un ExoPlayer bas√© sur Java open source que les applications ¬´apportent avec eux¬ª.  Quels sont leurs avantages et leurs inconv√©nients? <br><br>  Comparez les trois: <br><br><img src="https://habrastorage.org/webt/tf/cr/lg/tfcrlg3alc4srbn9r3plynsxqna.jpeg"><br><br>  Dans le cas du streaming adaptatif, ExoPlayer joue DASH / HLS et dispose de nombreux modules extensibles pour d'autres protocoles, tandis que AVPlayer s'aggrave. <br><br>  La prise en charge des versions de syst√®me d'exploitation convient en principe √† tout le monde partout. <br><br>  La pr√©r√©cup√©ration, c'est quand vous savez qu'apr√®s la fin d'une vid√©o, vous voulez lire ce qui suit dans la bande et la pr√©charger. <br><br>  Il y a un probl√®me avec les corrections de bugs des joueurs natifs.  Dans le cas d'ExoPlayer, vous le faites simplement rouler dans une nouvelle version de votre application, mais dans AVPlayer et MediaPlayer natif, le bogue ne sera corrig√© que dans la prochaine version du syst√®me d'exploitation.  Nous sommes tomb√©s sur cela douloureusement: dans iOS 8.01, notre vid√©o commen√ßait √† mal jouer, dans iOS 8.02 le portail entier cessait de fonctionner, dans 8.03 tout fonctionnait √† nouveau.  Et rien ne d√©pendait de nous dans ce cas, nous nous sommes juste assis et avons attendu qu'Apple lance la prochaine version. <br><br>  L'√©quipe ExoPlayer parle de l'inefficacit√© de la consommation d'√©nergie dans le cas de l'audio.  Il existe des recommandations g√©n√©rales de Google: pour lire de l'audio, utilisez MediaPlayer, pour tout le reste Exo. <br><br>  Compris, nous utiliserons ExoPLayer avec DASH pour la vid√©o sur Android et AVPlayer avec HLS sur iOS. <br><br><h3>  Premi√®re image rapide </h3><br>  Encore une fois, rappelez-vous le temps jusqu'√† la premi√®re image.  √Ä quoi cela ressemble-t-il sur iOS HLS: d'abord RTT derri√®re le manifeste, puis un autre RTT derri√®re le manifeste imbriqu√©, alors seulement - obtenir le segment et jouer.  Sous Android, un RTT c'est moins, √ßa d√©marre un peu mieux. <br><br><img src="https://habrastorage.org/webt/gu/b7/hx/gub7hxr1ex5bhq6vanms80ht7x0.jpeg"><br><br><h3>  Taille du tampon </h3><br>  Voyons maintenant les tampons.  Nous avons un minimum de donn√©es √† t√©l√©charger avant de commencer √† jouer.  Dans AVPlayer, cette valeur est configur√©e √† l'aide d'AVPlayerItem PreferredForwardBufferDuration. <br><br><img src="https://habrastorage.org/webt/lm/cs/mg/lmcsmgwqpuukx1lsowi_xuneiba.jpeg"><br><br>  Sur Android, ExoPlayer a beaucoup plus de m√©canismes de configuration.  Il y a le m√™me tampon minimum qui est n√©cessaire pour d√©marrer.  Mais il existe √©galement un param√®tre distinct pour le r√©amor√ßage (si votre r√©seau est tomb√© en panne, les donn√©es du tampon se sont √©puis√©es, puis elles sont revenues): <br><br><img src="https://habrastorage.org/webt/bs/wn/gj/bswngj3l6icqyk3detrxe82ve2s.jpeg"><br><br>  Quel est le profit?  Si vous avez un bon r√©seau, vous commencez rapidement et vous battez pour une premi√®re image rapide, pour la premi√®re fois vous pouvez essayer de tenter votre chance.  Mais si le r√©seau tombe en panne pendant la lecture, il est √©vident que vous devez demander plus de mise en m√©moire tampon pour jouer pendant le rebuffing afin qu'il n'y ait pas de probl√®me r√©p√©t√©. <br><br><h3>  Qualit√© d'origine </h3><br><br><img src="https://habrastorage.org/webt/ec/1r/ns/ec1rnsjfbh1yk0cxiusj5x06w7g.jpeg"><br><br>  HLS sur iOS a un probl√®me sympa: il commence toujours √† jouer √† partir de la premi√®re qualit√© dans le manifeste m3u8.  Ce que vous lui rendrez commencera.  Et seulement alors, il mesurera la vitesse de t√©l√©chargement et commencera √† jouer en qualit√© normale.  Il est clair que cela ne devrait pas √™tre autoris√©. <br><br>  Optimisation logique - qualit√© de tri.  Soit sur le serveur (en ajoutant un param√®tre suppl√©mentaire √† la qualit√© pr√©f√©r√©e, il trie √† nouveau le manifeste), soit sur le client (cr√©ez un proxy qui le fera pour vous). <br><br>  Et sur Android, il existe un param√®tre DefaultBandwidthMeter pour cela.  Il donne une valeur qu'il consid√®re comme la bande passante par d√©faut de votre bande. <br><br><img src="https://habrastorage.org/webt/vs/b3/m8/vsb3m8lvbwp3kwuc2mi9btg3im4.jpeg"><br><br>  Comment √ßa marche: il y a une √©norme table de constantes dans le code, et les param√®tres sont simples - le pays (r√©gion) et le type de connexion (wi-fi, 2G, 3G, 4G).  Quelles sont les significations?  Par exemple, si vous disposez du Wi-Fi et que vous vous trouvez aux √âtats-Unis, votre bande passante initiale est de 5,6 Mbps.  Et si la 3G est √† 700 kbps. <br><br>  On peut voir que, selon les estimations de Google, la 4G en Russie est 2 √† 3 fois plus rapide qu'en Am√©rique. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est clair que la Russie est un grand pays, et une telle configuration ne nous convenait pas du tout. </font><font style="vertical-align: inherit;">Par cons√©quent, si vous voulez le faire simplement, souvenez-vous de la valeur pr√©c√©dente pour le r√©seau actuel, soustrayez une unit√© au cas o√π, et d√©marrez-la. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et si vous avez une grande application qui lit des vid√©os dans le monde entier, collectez des statistiques sur les sous-r√©seaux et recommandez au serveur la qualit√© √† partir de laquelle commencer. </font><font style="vertical-align: inherit;">Gardez √† l'esprit qu'apr√®s la mise en m√©moire tampon, il est conseill√© d'augmenter la valeur de la m√©moire tampon (sur Android, cela est facilement autoris√©).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comment acc√©l√©rer le rembobinage </font></font></h3><br>         (seek),       ,   . , ,       ,    . <br><br><img src="https://habrastorage.org/webt/ay/be/50/aybe50r6ymkweqtj9wygtuhdxga.jpeg"><br><br>   ,     ,  -     .   iOS,    ,       ,        ,    (  ,     ,   ). <br><br>  ExoPlayer   2.7.0   ,    ,    ¬´  ¬ª.                .  ,    . <br><br><img src="https://habrastorage.org/webt/3j/3a/i_/3j3ai__smnqi_oytag8ny1rico0.jpeg"><br><br>       (     ,        ),     - ,     Android  prepare(mediaSource),   seekTo().   ,   ,     ,   .     ‚Äî     : <br><br><img src="https://habrastorage.org/webt/pe/oy/d_/peoyd_g_aartazc_lofykbivmn0.jpeg"><br><br> ,     (  ,  ),    .     ( 100 ),            ,     . <br><br><img src="https://habrastorage.org/webt/0l/uh/7s/0luh7sbufo5x4qmxbscuzvd-xwk.jpeg"><br><br><h3>  </h3><br>  iOS   ,    Android    legacy-. <br>    TextureView.   ,     ,    ,   ,   UI.    ‚Äî      . <br><br>  SurfaceView.    ,       .     Android-        . YouTube       ,    . <br><br>    GLSurfaceView ‚Äî     .     ,         . <br><br><img src="https://habrastorage.org/webt/yx/tw/wg/yxtwwgajtkdlsclcsyadebja9cg.jpeg"><br><br>   :  ,     ExoPlayer,       23%.  ¬´¬ª   10%.        4% .     4% ‚Äî  ,   . <br><br><h3> :   Android </h3><br><ul><li>  MediaPlayer  ,     ExoPlayer </li><li>  start, seek, swap </li><li>   ,    </li><li>   view   </li></ul><br><h3> :   iOS </h3><br>  iOS  : <br><br><ul><li>     RTT  HLS  AVPlayer </li><li>   </li><li>     AVPlayer#pause </li><li>  ‚Äî  ,     iOS </li></ul><br><br>       DASH-,    ¬´  live-¬ª.  : <br><br><ul><li> cURL  GCDAsyncSocket </li><li> AVAssetReader,     </li><li> CADisplayLink </li><li> AVSampleBufferDisplayLayer </li></ul><br><br>  ,     .       28%, ¬´¬ª   6%.   ,     HLS  DASH       100 /,     6%. <br><br>    iOS  : <br><br><ul><li>  start  seek </li><li>  HLS over Fragmented mp4 </li><li>   DASH- </li></ul><br><br> ,        . <br><br><h3>    : </h3><br>    ,   ,    . <br><br><ul><li>     (  mp4) </li><li>    (ExoPlayer, AVPlayer) </li><li>    firstFrame, seek, emptyBuffer </li><li>       </li><li>    (      ) </li><li>    - ,  .     4,    :  performance,  ,  . </li></ul><br><br>   ‚Äî  . <br><br><h2>  :     </h2><br>  ,        ? <br><br><img src="https://habrastorage.org/webt/ji/0p/pk/ji0ppk9wacev99cddvsw0alqjj0.jpeg"><br><br>  API      .  API         iOS  Android,    ‚Äî    ,  . <br><br> :   - wrapper    ,    POSIX-,    ,        . <br><br> <b>     ?</b> <br><br><ul><li>   </li><li>    </li><li>     </li><li>  D√©marrage rapide </li></ul><br><br> <b>    ?</b> <br><br><ul><li>  bandwidth </li><li>  </li><li>     </li><li>   (N x RTT,       RTT) </li></ul><br><br><h3>     </h3><br><br><img src="https://habrastorage.org/webt/-b/ae/va/-baevaqjpxvp9nnr2ecdrjmgqr4.jpeg"><br><br>   ‚Äî   .     ,       ,    . <br><br>       :        ,      ,      .       ‚Äî  low latency. <br><br> ,     ‚Äî    .           . <br><br>   ‚Äî    4K. ,          ,        .      ,     30  ,           .     ,    . <br><br><h3>  </h3><br>   , , ,     .         (       100 ). <br><br> -    ,  ,         . <br><br>       .       100      ,  . ,        300 kbps  FullHD-  480p,     FullHD   .     ,  :  ,       ,   overhead-.      . <br><br>      : <br><br><img src="https://habrastorage.org/webt/kk/xs/xu/kkxsxux2cegqqdg5w9cuny-wzps.jpeg"><br><br>     ,      ,   .     ,     -     ,       ,   . <br><br>       MediaCodec  VideoToolbox (   ).      Server Transcoder. <br><br>   ‚Äî   ,       . <br><br><h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous commen√ßons √† nous plonger dans le streaming, nous rencontrons un certain nombre de compromis. </font><font style="vertical-align: inherit;">En particulier, il y a un triangle dans les coins dont la fiabilit√© est la fiabilit√© (pas de gouttes), le d√©bit est la bande passante (combien nous utilisons le r√©seau) et une faible latence est une faible latence (obtenons-nous une faible latence). </font></font><br><br><img src="https://habrastorage.org/webt/zz/pc/xm/zzpcxmj1krgbg9qpfgxbb2q32wi.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous commen√ßons √† optimiser l'un de ces param√®tres, les autres √©choueront in√©vitablement. </font><font style="vertical-align: inherit;">Nous ne pouvons pas tout obtenir en m√™me temps, nous devons sacrifier quelque chose.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Protocoles </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les protocoles que nous verrons aujourd'hui: RTMP et WebRTC sont des protocoles standard, OKMP est notre protocole personnalis√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient de mentionner que RTMP fonctionne sur TCP et les deux autres sur UDP.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RTMP </font></font></h3><br>  Que donne-t-il?  D'une certaine mani√®re, il s'agit d'une norme prise en charge par tous les services - YouTube, Twitch, Flash, OK.  Ils l'utilisent pour que les utilisateurs puissent t√©l√©charger des flux en direct.  Si vous souhaitez diffuser un flux en direct vers un service tiers, vous devrez probablement travailler avec RTMP. <br><br>  Le d√©lai minimum que nous avons r√©ussi √† atteindre d'un lecteur de bande √† un lecteur est de 300 ms, mais c'est dans un r√©seau id√©al par beau temps.  Lorsque nous avons un vrai r√©seau, le d√©lai passe g√©n√©ralement √† 2-3 secondes, et si tout va mal avec le r√©seau, il peut atteindre des dizaines de secondes. <br><br>  RTMP prend en charge la modification de la r√©solution et du d√©bit binaire √† la vol√©e (les autres protocoles mentionn√©s sont les m√™mes, mais il y a des informations erron√©es sur RTMP qu'il n'y a pas de changement √† la vol√©e). <br><br>  Parmi les inconv√©nients: construit sur TCP (nous expliquerons plus tard pourquoi c'est mauvais), le retard n'est pas contr√¥l√©. <br><br>  Si vous regardez le triangle, RTMP ne pourra pas donner une faible latence.  Il peut √™tre obtenu, mais pas du tout garanti. <br><br>  De plus, RTMP est un peu merdique: il ne prend pas en charge les nouveaux codecs, car Adobe ne le fait pas, et la documentation est assez ancienne et tordue. <br><br><img src="https://habrastorage.org/webt/e_/p6/sm/e_p6sm4qifhwi6ftl0hgl-aiodk.jpeg"><br><br>  Pourquoi TCP ne convient-il pas aux diffusions en direct?  TCP donne une garantie de livraison: les donn√©es que vous mettez sur le socket seront livr√©es exactement dans l'ordre et sous la forme dans laquelle vous les avez plac√©es.  Rien ne sera supprim√© ou r√©organis√©.  TCP le fera ou mourra.  Mais cela signifie qu'une garantie de retard est exclue - il ne pourra pas supprimer les anciennes donn√©es, qui n'ont peut-√™tre d√©j√† pas besoin d'√™tre envoy√©es.  Le tampon, les arri√©r√©s et ainsi de suite commencent √† augmenter. <br><br><img src="https://habrastorage.org/webt/nt/vw/tb/ntvwtb4fybykxeul4gf9cmhlnva.jpeg"><br><br>  A titre d'illustration, le probl√®me de blocage de Head of Line.  On le trouve non seulement dans le streaming, mais aussi dans de nombreux autres cas. <br><br>  Qu'est ce que c'est  Nous avons un tampon r√©cepteur initialement vide.  Nous recevons des donn√©es de quelque part: beaucoup de donn√©es et beaucoup de paquets IP.  Nous avons re√ßu le premier paquet IP, et sur le r√©cepteur en utilisant la m√©thode recv (), nous pouvons soustraire ce paquet, obtenir des donn√©es, perdre, rendre.  Mais soudain, le deuxi√®me paquet a √©t√© perdu.  Que se passe-t-il ensuite? <br><br>  Pour r√©cup√©rer un paquet IP perdu, TCP doit retransmettre.  Pour que cela se produise, vous devez d√©penser RTT, tandis que la retransmission peut √©galement √™tre perdue, et nous allons proc√©der par cycles.  S'il existe de nombreux packages, cela se produira certainement. <br><br>  Apr√®s cela, beaucoup de donn√©es que nous ne pouvons pas lire, car nous attendons le deuxi√®me paquet.  Bien qu'il ait montr√© une trame de diffusion qui s'est produite il y a cinq minutes et n'est plus n√©cessaire. <br><br>  Pour comprendre un autre probl√®me, regardons l'adaptation RTMP.  Nous faisons l'adaptation c√¥t√© exp√©diteur.  Si le r√©seau ne peut pas cramper les donn√©es √† la vitesse √† laquelle elles sont plac√©es dans le socket, le tampon est rempli et le socket dit EWOULDBLOCK ou est bloqu√© si le blocage est utilis√© √† ce moment. <br><br><img src="https://habrastorage.org/webt/oy/6z/uy/oy6zuyjliks8epvjx4g83uq5d_m.jpeg"><br><br>  Ce n'est qu'√† ce moment que nous comprenons que nous avons des probl√®mes et que nous devons r√©duire la qualit√©. <br><br>  Disons que nous avons un r√©seau avec une vitesse sp√©cifique de 4 Mbps.  Nous avons choisi une taille de socket de 250 Ko (correspondant √† 0,5 seconde √† notre vitesse).  Soudain, le r√©seau a √©chou√© 10 fois - c'est une situation normale.  Nous avons 400 kbps.  Le tampon s'est rapidement rempli en une demi-seconde et ce n'est qu'√† ce moment-l√† que nous comprenons que nous devons arr√™ter. <br><br><img src="https://habrastorage.org/webt/te/7l/0p/te7l0pkef3gz8ntjm7gq27yvxnm.jpeg"><br><br>  Mais maintenant, le probl√®me est que nous avons un tampon de 250 Ko qui sera transmis pendant 5 secondes.  Nous sommes d√©j√† compl√®tement √† la tra√Æne: nous devons d'abord pousser les anciennes donn√©es, et ce n'est qu'alors que les nouvelles et les adapt√©es iront rattraper le temps r√©el. <br><br>  Que faire  Ici, notre ¬´triangle de compromis¬ª est juste pertinent. <br><br><img src="https://habrastorage.org/webt/s2/0k/fa/s20kfaykbgel7si5vtpcjiwla1w.jpeg"><br><br><ul><li>  Nous pouvons r√©duire le tampon de l'exp√©diteur, mis au lieu de 0,5 sec - 0,1 sec.  Mais nous perdons de la bande passante, car nous allons souvent ¬´paniquer¬ª et basculer vers le bas.  De plus, TCP fonctionne de telle mani√®re que si vous mettez un tampon √©metteur plus petit que RTT, vous ne pouvez pas utiliser toute la bande passante du canal, il diminuera de plusieurs fois. </li><li>  Nous pouvons augmenter la m√©moire tampon du r√©cepteur.  Avec un grand tampon, les donn√©es arrivent, nous pouvons aplanir certaines irr√©gularit√©s au sein du tampon.  Mais, bien s√ªr, nous perdons une faible latence, car nous avons imm√©diatement mis en place un tampon de 5 secondes. </li><li>  Nous pouvons supprimer de mani√®re agressive les anciennes donn√©es.  Dans TCP, la seule option pour cela est de rompre la connexion et de la recr√©er.  Nous perdons en fiabilit√©, car pour le moment le joueur n'a rien √† montrer. </li></ul><br><br><h3>  WebRTC </h3><br>  Il s'agit d'une biblioth√®que C ++ qui prend d√©j√† en compte l'exp√©rience et s'ex√©cute sur UDP.  Builds sous iOS, Android, est int√©gr√© dans les navigateurs, prend en charge HTML5.  Puisqu'il est emprisonn√© pour les appels P2P, le d√©lai est de 0,1 √† 1 seconde. <br><br><img src="https://habrastorage.org/webt/gu/jv/co/gujvcogf5z-3szbr4b3fqxcs38m.jpeg"><br><br>  Parmi les inconv√©nients: il s'agit d'une biblioth√®que monolithique avec une abondance d'h√©ritage qui ne peut pas √™tre supprim√©e.  De plus, en raison de sa concentration sur les appels P2P, il priorise une faible latence.  Il semblerait que nous voulions cela, mais pour cela, elle sacrifie d'autres param√®tres.  Et il n'y a pas de param√®tres pour changer les priorit√©s. <br><br>  Il convient √©galement de garder √† l'esprit que la biblioth√®que est orient√©e client pour une conversation entre deux clients sans serveur.  Le serveur doit √™tre recherch√© par un tiers ou √©crire le v√¥tre. <br><br>  Que choisir - RTMP ou WebRTC?  Nous avons impl√©ment√© les deux protocoles et les avons test√©s dans diff√©rents sc√©narios.  Sur le graphique, WebRTC a un faible retard, mais un faible d√©bit, tandis que RTMP a le contraire.  Et entre eux, il y a un trou. <br><br>  Et nous voulions faire un protocole qui couvre compl√®tement ce trou et peut fonctionner √† la fois en WebRTC et en mode RTMP.  Ils l'ont fait et l'ont nomm√© OKMP. <br><br><img src="https://habrastorage.org/webt/xq/8y/p1/xq8yp1lyi_jxdqc8h-tyzw0grgi.jpeg"><br><h3>  Okmp </h3><br>  Il s'agit d'un protocole flexible pour UDP. <br><br>  Prend en charge le multiplexage.  Qu'est-ce que cela signifie: il y a plusieurs canaux √† l'int√©rieur de la session (dans le cas de OK Live - le gestionnaire, audio et vid√©o).  Au sein de chaque canal, les donn√©es sont garanties d'√™tre livr√©es dans un certain ordre (mais elles ne sont pas elles-m√™mes garanties d'√™tre livr√©es), et l'ordre entre les canaux n'est pas garanti, car ce n'est pas important. <br><br>  Qu'est-ce que √ßa donne?  Tout d'abord, cela nous a permis de prioriser les cha√Ænes.  Nous pouvons dire que le canal de contr√¥le a une priorit√© √©lev√©e, le son est moyen et la vid√©o est faible.  La gigue vid√©o et la diffusion vid√©o in√©gale sont plus faciles √† masquer, et l'utilisateur a moins de probl√®mes de probl√®mes vid√©o que de b√©gaiement d√©sagr√©able de l'audio. <br><br><img src="https://habrastorage.org/webt/vd/nq/pp/vdnqppsvt33b7j82m2hxdgnf1ag.jpeg"><br><br>  De plus, notre protocole dispose d'une garantie de livraison optionnelle.  Nous pouvons dire que sur un certain canal, nous travaillons en mode TCP, avec une livraison garantie, et sur le reste, nous autorisons quelques baisses. <br><br>  Gr√¢ce √† cela, une garantie de retard peut √™tre faite: il n'y a aucune garantie de retard sur le canal TCP, mais sur les autres o√π les suppressions sont autoris√©es, un seuil est fix√©, apr√®s quoi les donn√©es commencent √† chuter et nous arr√™tons de livrer les anciennes donn√©es. <br><br>  Par exemple, pour l'audio, cela repr√©sente 1 seconde et pour la vid√©o, 0,5 seconde.  Pourquoi le seuil est-il diff√©rent?  Il s'agit d'un autre m√©canisme de priorisation.  Puisqu'il est plus important pour nous que l'audio soit fluide, nous commen√ßons par supprimer la vid√©o. <br><br>  Notre protocole est configur√© de mani√®re flexible: il n'y a pas de mode de fonctionnement unique, nous modifions les param√®tres √† la vol√©e pour passer au mode souhait√© sans effets visibles pour l'utilisateur.  Pourquoi?  Par exemple, pour les m√™mes appels vid√©o: si un appel vid√©o d√©marre dans un flux, nous le transf√©rons tranquillement en mode faible latence.  Et puis revenez en mode d√©bit pour une qualit√© maximale. <br>  Difficult√©s de mise en ≈ìuvre <br><br><img src="https://habrastorage.org/webt/zv/jl/wk/zvjlwkvrqjhldwib10ocewpc7iu.jpeg"><br><br>  Bien s√ªr, si vous d√©cidez d'√©crire votre protocole en UDP, vous rencontrerez des probl√®mes.  En utilisant TCP, nous obtenons des m√©canismes que nous devrons √©crire nous-m√™mes sur UDP: <br><br><ul><li>  Mise en paquets / d√©packetisation.  Vous devez d√©couper les donn√©es en paquets d'une taille d'environ 1,5 Ko afin qu'ils s'int√®grent dans le r√©seau MTU. </li><li>  R√©organisation.  Vous envoyez des paquets dans un ordre, et ils sont r√©organis√©s en cours de route et arrivent dans un autre.  Pour surmonter cela, vous devez d√©finir la s√©quence avec le num√©ro de package et les r√©organiser sur le r√©cepteur. </li><li>  Pertes.  Bien s√ªr, il y a des pertes.  Lorsqu'une perte se produit, le r√©cepteur doit dire s√©par√©ment √† l'exp√©diteur que "J'ai re√ßu ces paquets, mais je ne les ai pas re√ßus", et l'exp√©diteur doit retransmettre les paquets manquants.  Ou laissez-les tomber. </li><li>  Contr√¥le de flux  Si le r√©cepteur ne re√ßoit pas de donn√©es, ne suit pas la vitesse √† laquelle nous le poussons, les donn√©es peuvent commencer √† se perdre, nous devons traiter cette situation.  Dans le cas de TCP, le socket d'envoi sera bloqu√© et dans le cas d'UDP, il ne sera pas bloqu√©, vous devez vous comprendre que le r√©cepteur ne re√ßoit pas de donn√©es et r√©duire la quantit√© de donn√©es envoy√©es. </li><li>  Contr√¥le de la congestion.  Une chose similaire, seulement dans ce cas, le r√©seau est mort.  Si nous envoyons des paquets au r√©seau d√©c√©d√©, nous d√©truirons non seulement notre connexion, mais aussi les voisins. </li><li>  Cryptage  Besoin de prendre soin du cryptage </li><li>  ... et bien plus </li></ul><br><br><h3>  OKMP vs RTMP </h3><br>  Qu'avons-nous obtenu lorsque nous avons commenc√© √† utiliser OKMP au lieu de RTMP? <br><br><ul><li>  L'augmentation moyenne du d√©bit binaire OKLive est de 30%. </li><li>  Gigue (mesure de l'arriv√©e in√©gale de paquets) - 0% (en moyenne la m√™me). </li><li>  Audio Jitter - -25% </li><li>  Vid√©o de gigue - 40% </li></ul><br><br>  Changements audio et vid√©o - d√©monstration des priorit√©s dans notre protocole.  L'audio nous donne une priorit√© plus √©lev√©e, et il a commenc√© √† venir plus facilement gr√¢ce √† la vid√©o. <br><br><h3>  Comment choisir un protocole pour le streaming </h3><br><br><img src="https://habrastorage.org/webt/_l/g3/vs/_lg3vsf20spfixqon5z0m4fwa0w.jpeg"><br><br>  Si vous avez besoin d'une faible latence - WebRTC. <br><br>  Si vous souhaitez travailler avec des services externes, publier des vid√©os sur des services tiers, vous devrez utiliser RTMP. <br><br>  Si vous voulez un protocole adapt√© √† vos scripts, impl√©mentez le v√¥tre. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467669/">https://habr.com/ru/post/fr467669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467659/index.html">Acc√©l√®re consid√©rablement l'ex√©cution des t√¢ches gr√¢ce √† l'exemple de configuration suppl√©mentaire de la m√©moire HyperX FURY DDR4 mise √† jour</a></li>
<li><a href="../fr467661/index.html">Dosim√®tre pour Seryozha. Partie I. Polimaster - Chasseurs de nucl√©ides</a></li>
<li><a href="../fr467663/index.html">Prise en charge des instructions sp√©cifiques au mat√©riel dans .NET Core (d√©sormais non seulement SIMD)</a></li>
<li><a href="../fr467665/index.html">Chariot de camion ROS. Partie 5. Travailler dans rviz et gazebo: xacro, nouveaux capteurs</a></li>
<li><a href="../fr467667/index.html">Planification de projet d'organisation (partie 4)</a></li>
<li><a href="../fr467671/index.html">NLX Retro Computer</a></li>
<li><a href="../fr467673/index.html">Fonctionnalit√©s Go int√©gr√©es</a></li>
<li><a href="../fr467675/index.html">Mod√©lisation de l'√©tat de l'application √† l'aide d'objets Store dans SwiftUI</a></li>
<li><a href="../fr467677/index.html">Tests ou types</a></li>
<li><a href="../fr467679/index.html">PyCrunch - Ex√©cution intelligente des tests et couverture visuelle du code dans l'IDE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>