<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüîß ‚úäüèΩ üëó Registro r√°pido üç° üë®üèª‚Äçüî¨ ‚ò¶Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo he colocado puntos de referencia de las llamadas m√°s privadas de los madereros. Realic√© todos los experimentos en log4net y NLog, en ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Registro r√°pido</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456488/"><p>  En este art√≠culo he colocado puntos de referencia de las llamadas m√°s privadas de los madereros.  Realic√© todos los experimentos en log4net y NLog, en Intel Windows 10 x64 con M.2 SSD. </p><br><p>  Los resultados sin procesar se pueden ver en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> .  El c√≥digo est√° en el mismo repositorio (para ejecutar, necesitar√° .Net 4.7.2 + Microsoft Visual Studio 2017+). </p><br><p>  Qu√©, c√≥mo y por qu√©, debajo del corte. </p><a name="habracut"></a><br><p>  Para no leer durante mucho tiempo, la tabla de resultados: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = true </td><td>  1.144,677 ns </td><td>  26.3805 ns </td><td>  77.7835 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Async = true </td><td>  1,106.691 ns </td><td>  31.4041 ns </td><td>  87.5421 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Async = true </td><td>  4,804.426 ns </td><td>  110.3406 ns </td><td>  103.2126 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Async = true </td><td>  5,303.602 ns </td><td>  104.3022 ns </td><td>  102.4387 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = false </td><td>  5,642.301 ns </td><td>  73,2291 ns </td><td>  68.4986 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Async = false </td><td>  11,834.892 ns </td><td>  82.7578 ns </td><td>  77,4117 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Async = false </td><td>  731,250.539 ns </td><td>  14,612.0117 ns </td><td>  27,444.8998 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Async = false </td><td>  730,271.927 ns </td><td>  11,330.0172 ns </td><td>  10,598.1051 ns </td></tr><tr><td>  CreateLog4NetFromString </td><td>  1,470.662 ns </td><td>  19.9492 ns </td><td>  18.6605 ns </td></tr><tr><td>  CreateNLogFromString </td><td>  228.774 ns </td><td>  2.1315 ns </td><td>  1.8895 ns </td></tr><tr><td>  CreateLog4NetLogger </td><td>  21,046.294 ns </td><td>  284.1171 ns </td><td>  265.7633 ns </td></tr><tr><td>  CreateNLogTypeOfLogger </td><td> 164,487.931 ns </td><td>  3,240.4372 ns </td><td>  3,031.1070 ns </td></tr><tr><td>  CreateNLogDynamicLogger </td><td>  134,459.092 ns </td><td>  1,882.8663 ns </td><td>  1,761.2344 ns </td></tr><tr><td>  FileLoggingLog4NetNoParams </td><td>  8.251.032 ns </td><td>  109.3075 ns </td><td>  102.2463 ns </td></tr><tr><td>  FileLoggingLog4NetSingleReferenceParam </td><td>  8.260.452 ns </td><td>  145.9028 ns </td><td>  136.4776 ns </td></tr><tr><td>  FileLoggingLog4NetSingleValueParam </td><td>  8.378.693 ns </td><td>  121.3003 ns </td><td>  113.4643 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleReferencesParam </td><td>  9.133.136 ns </td><td>  89.7420 ns </td><td>  79.5539 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleValuesParam </td><td>  9.393.989 ns </td><td>  166.0347 ns </td><td>  155.3089 ns </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  6.061.837 ns </td><td>  69.5666 ns </td><td>  65.0726 ns </td></tr><tr><td>  FileLoggingNLogNetSingleReferenceParam </td><td>  6.458.201 ns </td><td>  94.5617 ns </td><td>  88.4530 ns </td></tr><tr><td>  FileLoggingNLogNetSingleValueParam </td><td>  6.460.859 ns </td><td>  95.5435 ns </td><td>  84,6969 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleReferencesParam </td><td>  7.236.886 ns </td><td>  89.7334 ns </td><td>  83,9367 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleValuesParam </td><td>  7.524.876 ns </td><td>  82.8979 ns </td><td>  77,5427 ns </td></tr><tr><td>  NoOpLog4NetNoParams </td><td>  12.684 ns </td><td>  0.0795 ns </td><td>  0,0743 ns </td></tr><tr><td>  NoOpLog4NetSingleReferenceParam </td><td>  10.506 ns </td><td>  0,0571 ns </td><td>  0,0506 ns </td></tr><tr><td>  NoOpLog4NetSingleValueParam </td><td>  12.608 ns </td><td>  0.1012 ns </td><td>  0.0946 ns </td></tr><tr><td>  NoOpLog4NetMultipleReferencesParam </td><td>  48.858 ns </td><td>  0.3988 ns </td><td>  0.3730 ns </td></tr><tr><td>  NoOpLog4NetMultipleValuesParam </td><td>  69,463 ns </td><td>  0.9444 ns </td><td>  0.8834 ns </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  2.073 ns </td><td>  0,0253 ns </td><td>  0.0225 ns </td></tr><tr><td>  NoOpNLogNetSingleReferenceParam </td><td>  2.625 ns </td><td>  0,0364 ns </td><td>  0.0340 ns </td></tr><tr><td>  NoOpNLogNetSingleValueParam </td><td>  2.281 ns </td><td>  0,0222 ns </td><td>  0.0208 ns </td></tr><tr><td>  NoOpNLogNetMultipleReferencesParam </td><td>  41.525 ns </td><td>  0.4481 ns </td><td>  0.4191 ns </td></tr><tr><td>  NoOpNLogNetMultipleValuesParam </td><td>  57.622 ns </td><td>  0.5341 ns </td><td>  0.4996 ns </td></tr></tbody></table></div><br><h1 id="nooplogging">  NoOpLogging </h1><br><p>  Primero, calculemos cu√°nto tiempo pasamos llamando a un m√©todo para iniciar sesi√≥n, que al final no conducir√° a nada.  En la mayor√≠a de los casos (en mi experiencia), la depuraci√≥n detallada est√° deshabilitada en los servidores de batalla, pero nadie elimina las llamadas. </p><br><p>  Primero, el resultado: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th></tr></thead><tbody><tr><td>  NoOpLog4NetNoParams </td><td>  12.684 ns </td><td>  0.0795 ns </td><td>  0,0743 ns </td></tr><tr><td>  NoOpLog4NetSingleReferenceParam </td><td>  10.506 ns </td><td>  0,0571 ns </td><td>  0,0506 ns </td></tr><tr><td>  NoOpLog4NetSingleValueParam </td><td>  12.608 ns </td><td>  0.1012 ns </td><td>  0.0946 ns </td></tr><tr><td>  NoOpLog4NetMultipleReferencesParam </td><td>  48.858 ns </td><td>  0.3988 ns </td><td>  0.3730 ns </td></tr><tr><td>  NoOpLog4NetMultipleValuesParam </td><td>  69,463 ns </td><td>  0.9444 ns </td><td>  0.8834 ns </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  2.073 ns </td><td>  0,0253 ns </td><td>  0.0225 ns </td></tr><tr><td>  NoOpNLogNetSingleReferenceParam </td><td>  2.625 ns </td><td>  0,0364 ns </td><td>  0.0340 ns </td></tr><tr><td>  NoOpNLogNetSingleValueParam </td><td>  2.281 ns </td><td>  0,0222 ns </td><td>  0.0208 ns </td></tr><tr><td>  NoOpNLogNetMultipleReferencesParam </td><td>  41.525 ns </td><td>  0.4481 ns </td><td>  0.4191 ns </td></tr><tr><td>  NoOpNLogNetMultipleValuesParam </td><td>  57.622 ns </td><td>  0.5341 ns </td><td>  0.4996 ns </td></tr></tbody></table></div><br><p>  Y el c√≥digo: </p><br><pre><code class="plaintext hljs">void Log4NetNoParams() =&gt; _log4Net.Debug("test"); void Log4NetSingleReferenceParam() =&gt; _log4Net.DebugFormat("test {0}", _stringArgument); void Log4NetSingleValueParam() =&gt; _log4Net.DebugFormat("test {0}", _intArgument); void Log4NetMultipleReferencesParam() =&gt; _log4Net.DebugFormat( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument); void Log4NetMultipleValuesParam() =&gt; _log4Net.DebugFormat( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument); void NLogNetNoParams() =&gt; _nlog.Debug("test"); void NLogNetSingleReferenceParam() =&gt; _nlog.Debug("test {0}", _stringArgument); void NLogNetSingleValueParam() =&gt; _nlog.Debug("test {0}", _intArgument); void NLogNetMultipleReferencesParam() =&gt; _nlog.Debug( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument); void NLogNetMultipleValuesParam() =&gt; _nlog.Debug( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument);</code> </pre> <br><p>  Primero, determinemos por qu√© se eligieron tales pruebas: </p><br><ul><li>  Los experimentos se realizaron en las bibliotecas m√°s populares. </li><li><p>  NLog y log4net tienen diferentes firmas de funci√≥n para una peque√±a cantidad de argumentos: </p><br><ul><li>  log4net: </li></ul><br><pre> <code class="plaintext hljs">void DebugFormat(string format, object arg0)</code> </pre> <br><ul><li>  Nlog: </li></ul><br><pre> <code class="plaintext hljs">void Debug(string message, string argument) void Debug&lt;TArgument&gt;(string message, TArgument argument)</code> </pre> <br><ul><li>  Teor√≠a: cuando se transfiere un tipo significativo a log4net, debe producirse un boxeo, que simplemente pasa el tiempo del procesador y no conduce a nada.  En el caso de NLog, no existe tal comportamiento, por lo que este √∫ltimo deber√≠a funcionar m√°s r√°pido. </li></ul><br></li><li>  Las firmas para una gran cantidad de argumentos en las bibliotecas son aproximadamente las mismas, por lo que me gustar√≠a saber: <br><ul><li>  ¬øCu√°nto m√°s eficiente es invocar m√©todos con un peque√±o n√∫mero de par√°metros? </li><li>  ¬øHay alguna diferencia en la velocidad de llamar al m√©todo "Est√° ... habilitado" entre las dos bibliotecas </li></ul></li></ul><br><p>  Y ahora el an√°lisis de los resultados: </p><br><ul><li>  Debido al uso de argumentos gen√©ricos en NLog, funciona m√°s r√°pido para el caso cuando el registro directo no es necesario.  Es decir, en el caso de que en su programa de depuraci√≥n el nivel est√© habilitado solo en el sistema de prueba, solo cambiar la biblioteca puede acelerar el software (y mejorar la vida de los usuarios). </li><li>  Si tiene el registro desactivado y desea llamar a un m√©todo con una gran cantidad de argumentos, es m√°s eficiente dividirlo en dos.  Debido a esto, las llamadas a m√©todos anteriores funcionar√°n diez veces m√°s r√°pido. </li><li>  Cuando escribe una funci√≥n que puede tomar cualquier objeto, a menudo es m√°s efectivo confundirse y hacer una funci√≥n gen√©rica.  Debido a una optimizaci√≥n tan simple, el c√≥digo funcionar√° m√°s r√°pido (esto se ve claramente en la diferencia de tiempo entre las llamadas a <code>Log4NetSingleReferenceParam</code> y <code>Log4NetSingleValueParam</code> ) </li></ul><br><h1 id="filelogging">  Registro de archivos </h1><br><p>  La mayor√≠a de los programas (de acuerdo con mis observaciones) todav√≠a registran los resultados en un archivo, por lo que para la comparaci√≥n elegimos esta operaci√≥n.  Para simplificar, simplemente tomamos la configuraci√≥n de los registradores cuando un archivo se escribe en el archivo sin almacenamiento en b√∫fer, sin bloqueos adicionales, etc. </p><br><p>  Resultados: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th></tr></thead><tbody><tr><td>  FileLoggingLog4NetNoParams </td><td>  8.251.032 ns </td><td>  109.3075 ns </td><td>  102.2463 ns </td></tr><tr><td>  FileLoggingLog4NetSingleReferenceParam </td><td>  8.260.452 ns </td><td>  145.9028 ns </td><td>  136.4776 ns </td></tr><tr><td>  FileLoggingLog4NetSingleValueParam </td><td>  8.378.693 ns </td><td>  121.3003 ns </td><td>  113.4643 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleReferencesParam </td><td>  9.133.136 ns </td><td>  89.7420 ns </td><td>  79.5539 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleValuesParam </td><td>  9.393.989 ns </td><td>  166.0347 ns </td><td>  155.3089 ns </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  6.061.837 ns </td><td>  69.5666 ns </td><td>  65.0726 ns </td></tr><tr><td>  FileLoggingNLogNetSingleReferenceParam </td><td>  6.458.201 ns </td><td>  94.5617 ns </td><td>  88.4530 ns </td></tr><tr><td>  FileLoggingNLogNetSingleValueParam </td><td>  6.460.859 ns </td><td>  95.5435 ns </td><td>  84,6969 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleReferencesParam </td><td>  7.236.886 ns </td><td>  89.7334 ns </td><td>  83,9367 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleValuesParam </td><td>  7.524.876 ns </td><td>  82.8979 ns </td><td>  77,5427 ns </td></tr></tbody></table></div><br><p>  C√≥digo utilizado: </p><br><ul><li>  log4net: </li></ul><br><pre> <code class="plaintext hljs">var roller = new RollingFileAppender(); roller.ImmediateFlush = true; roller.RollingStyle = RollingFileAppender.RollingMode.Once; roller.MaxFileSize = 128 * 1000 * 1000;</code> </pre> <br><ul><li>  Nlog: </li></ul><br><pre> <code class="plaintext hljs">new FileTarget($"target_{_logIndex++}") { ArchiveAboveSize = 128 * 1000 * 1000, MaxArchiveFiles = 16, AutoFlush = true, ConcurrentWrites = false, KeepFileOpen = false };</code> </pre><br><p>  Como puede ver, la configuraci√≥n de los registradores es m√°s o menos similar y seg√∫n los resultados: </p><br><ul><li>  NLog es un poco m√°s r√°pido que log4net, en alg√∫n lugar alrededor del 15%. </li><li>  Seg√∫n las pruebas, result√≥ que es m√°s eficiente registrar menos par√°metros.  Sin embargo, no se debe olvidar que con un mayor n√∫mero de par√°metros, la cadena resultante tambi√©n se expandi√≥.  Por lo tanto, la tabla solo compara correctamente NLog con log4net. </li></ul><br><h1 id="nlog---raznye-sposoby-blokirovok">  NLog - diferentes tipos de cerraduras </h1><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = false </td><td>  5,642.301 ns </td><td>  73,2291 ns </td><td>  68.4986 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Async = false </td><td>  11,834.892 ns </td><td>  82.7578 ns </td><td>  77,4117 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Async = false </td><td>  731,250.539 ns </td><td>  14,612.0117 ns </td><td>  27,444.8998 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Async = false </td><td>  730,271.927 ns </td><td>  11,330.0172 ns </td><td>  10,598.1051 ns </td></tr></tbody></table></div><br><p>  C√≥digo fuente: </p><br><pre> <code class="plaintext hljs">new FileTarget($"target_{_logIndex++}") { ArchiveAboveSize = 128 * 1000 * 1000, MaxArchiveFiles = 16, AutoFlush = true, ConcurrentWrites = XXXXX, KeepFileOpen = YYYYY };</code> </pre><br><p>  Si ponemos todas las combinaciones posibles en lugar de XXXXX y AAAA, obtenemos la prueba de la tabla. </p><br><p>  Los resultados son bastante predecibles: </p><br><ul><li>  Si habilita ConcurrentWrites, entonces el sistema tomar√° constantemente y le dar√° Mutex, que no es gratuito.  Pero, como vemos, escribir una l√≠nea en un archivo es aproximadamente equivalente a un bloqueo del sistema. </li><li>  Cerrar y abrir un archivo, como vemos, afecta a√∫n m√°s el rendimiento del sistema.  En los ejemplos con <code>KeepFileOpen=true</code> para cada operaci√≥n de registro, creamos un archivo (junto con Handle), escribimos en el disco, llamado Flush, devolvimos Handle y tambi√©n realizamos muchas operaciones de cap√≥ del motor.  Como resultado, la velocidad cae cientos de veces. </li></ul><br><h1 id="asinhronnoe-loggirovanie-i-raznye-sposoby-blokirovok">  Registro asincr√≥nico y diferentes m√©todos de bloqueo. </h1><br><p>  La biblioteca NLog tambi√©n puede realizar todas las operaciones de E / S en otro subproceso, liberando inmediatamente el actual.  Y lo hace de manera competente, preservando el orden de los eventos, colocando todos los datos en bloques, y en cada bloque un n√∫mero entero es un n√∫mero de evento (para que no se obtengan l√≠neas recortadas), y as√≠ sucesivamente. </p><br><p>  Los resultados de diferentes m√©todos sin bloqueo: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = true </td><td>  1.144,677 ns </td><td>  26.3805 ns </td><td>  77.7835 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Async = true </td><td>  1,106.691 ns </td><td>  31.4041 ns </td><td>  87.5421 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Async = true </td><td>  4,804.426 ns </td><td>  110.3406 ns </td><td>  103.2126 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Async = true </td><td>  5,303.602 ns </td><td>  104.3022 ns </td><td>  102.4387 ns </td></tr></tbody></table></div><br><p>  La comparaci√≥n de los enfoques de bloqueo y asincr√≥nicos ser√° m√°s profunda, pero aqu√≠, solo la √∫ltima. </p><br><p>  C√≥digo <code>AsyncTargetWrapper</code> : </p><br><pre> <code class="plaintext hljs">new AsyncTargetWrapper(fileTargetWithConcurrentWritesAndCloseFileAsync) { OverflowAction = AsyncTargetWrapperOverflowAction.Block, QueueLimit = 10000 }</code> </pre> <br><p>  Como puede ver, la configuraci√≥n del contenedor es tal que un volcado directo al archivo no lleva bastante tiempo.  Por lo tanto, se acumula un b√∫fer grande, lo que significa que todas las operaciones intensivas en recursos, como "abrir archivo", se realizan una vez para todo el bloque.  Sin embargo, dicho algoritmo requiere memoria adicional (y mucha). </p><br><p>  Conclusiones: </p><br><ul><li>  Si se utiliza una salida asincr√≥nica, no importa qu√© tipo de configuraci√≥n de salida se use con el archivo.  Puede abrir y cerrar el archivo cada vez, con un b√∫fer grande ser√° casi imperceptible. </li><li>  Todas las mediciones son verdaderas solo para el caso en que los datos se descargan en el disco a aproximadamente la misma velocidad que el llenado de las memorias intermedias (lo hice debido al sistema de archivos r√°pido + pausas naturales entre mediciones). </li></ul><br><h1 id="sinhronnoe-i-asinhronnoe-loggirovanie">  Registro s√≠ncrono y as√≠ncrono </h1><br><div class="scrollable-table"><table><thead><tr><th>  Resultados: </th><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Mediana </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = true </td><td>  1,835.730 ns </td><td>  55,3980 ns </td><td>  163,3422 ns </td><td>  1,791.901 ns </td></tr><tr><td>  FileLoggingLog4NetNoParams </td><td>  7,076.251 ns </td><td>  41.5518 ns </td><td>  38.8676 ns </td><td>  7,075.394 ns </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  5.438.306 ns </td><td>  42.0170 ns </td><td>  37,2470 ns </td><td>  5.427.805 ns </td></tr><tr><td>  NoOpLog4NetNoParams </td><td>  11.063 ns </td><td>  0,0141 ns </td><td>  0,0125 ns </td><td>  11.065 ns </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  1.045 ns </td><td>  0.0037 ns </td><td>  0.0033 ns </td><td>  1.045 ns </td></tr></tbody></table></div><br><p>  Conclusiones: </p><br><ul><li>  A pesar del disco r√°pido (en mi caso, SSD M.2), escribir en un archivo en otra secuencia acelera el trabajo varias veces.  Si su aplicaci√≥n escribe en discos HDD e incluso se ejecuta en una m√°quina virtual, la ganancia ser√° a√∫n mayor. </li><li>  Sin embargo, a pesar de la operaci√≥n incluso r√°pida del c√≥digo asincr√≥nico, la falta de registro proporciona una ganancia a√∫n mayor (aunque ligeramente diferente, dependiendo de la biblioteca). </li></ul><br><h1 id="sozdanie-loggerov">  Crear registradores </h1><br><p>  Resultados: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th></tr></thead><tbody><tr><td>  CreateLog4NetFromString </td><td>  1,470.662 ns </td><td>  19.9492 ns </td><td>  18.6605 ns </td></tr><tr><td>  CreateNLogFromString </td><td>  228.774 ns </td><td>  2.1315 ns </td><td>  1.8895 ns </td></tr><tr><td>  CreateLog4NetLogger </td><td>  21,046.294 ns </td><td>  284.1171 ns </td><td>  265.7633 ns </td></tr><tr><td>  CreateNLogTypeOfLogger </td><td>  164,487.931 ns </td><td>  3,240.4372 ns </td><td>  3,031.1070 ns </td></tr><tr><td>  CreateNLogDynamicLogger </td><td>  134,459.092 ns </td><td>  1,882.8663 ns </td><td>  1,761.2344 ns </td></tr></tbody></table></div><br><p>  Lo que fue probado: </p><br><pre> <code class="plaintext hljs">[Benchmark] public object CreateLog4NetFromString() { return LogManager.GetLogger("my-logger_" + (Interlocked.Increment(ref _log4NetStringLogIndex) % 1000)); } [Benchmark] public object CreateNLogFromString() { return NLog.LogManager.GetLogger("my-logger_" + (Interlocked.Increment(ref _nLogStringLogIndex) % 1000)); } [Benchmark] public object CreateLog4NetLogger() { return new [] { LogManager.GetLogger(typeof(BaseTest)), // x16 times }; } [Benchmark] public object CreateNLogTypeOfLogger() { return new[] { NLog.LogManager.GetCurrentClassLogger(typeof(BaseTest)), // x16 times }; } [Benchmark] public object CreateNLogDynamicLogger() { return new[] { NLog.LogManager.GetCurrentClassLogger(), // x16 times }; }</code> </pre> <br><p>  Comentario importante: desafortunadamente, fue dif√≠cil para m√≠ hacer un punto de referencia reproducible que no condujera a la falta de memoria, pero que crear√≠a diferentes registradores (es decir, para diferentes tipos, para diferentes l√≠neas, etc.). </p><br><p>  Sin embargo, despu√©s de estudiar el trabajo de las bibliotecas, descubr√≠ que se realizan casi las operaciones m√°s dif√≠ciles para crear una clave de registro (es decir, determinar un nombre, borrar argumentos gen√©ricos, etc.). <br>  Adem√°s, para estabilizar el punto de referencia para crear un registrador para log4net, fue necesario realizar no una operaci√≥n, sino 16 (es decir, se devuelve una matriz de 16 objetos id√©nticos).  Si no devuelve nada, .Net optimiz√≥ la ejecuci√≥n para m√≠ (aparentemente, simplemente no devolvi√≥ el resultado), lo que condujo a resultados incorrectos. </p><br><p>  Y conclusiones: </p><br><ul><li>  Los registradores se crean m√°s r√°pidamente a partir de cadenas (NLog es m√°s r√°pido nuevamente, sin embargo, la diferencia entre las bibliotecas es peque√±a, teniendo en cuenta que los registradores se crean no solo as√≠, sino para el trabajo posterior con ellos). </li><li>  log4net es m√°s r√°pido que NLog al inicializar un proyecto.  Quiz√°s esto se deba al almacenamiento en cach√© adicional en el lado NLog, que ayuda a acelerar las llamadas directas a <code>Debug</code> , <code>Info</code> , etc.  De hecho, cada <code>ILogger</code> conoce la respuesta a s√≠ mismo: si debe llamar a los siguientes m√©todos o no (y esto requiere al menos alg√∫n tipo de enlace a la configuraci√≥n general).  Debido a este esquema de trabajo, Out of Memory fue utilizado por m√≠ en la mayor√≠a de las pruebas (si uso diferentes l√≠neas, etc.). </li><li>  <code>LogManager.GetCurrentClassLogger()</code> es incluso m√°s lento que <code>LogManager.GetLogget(typeof(XXX))</code> .  Esto es l√≥gico, incluso los desarrolladores de NLog no recomiendan llamar al primer m√©todo en un bucle. </li><li>  Y lo m√°s importante: la velocidad de todos estos m√©todos a menudo afecta solo el inicio en fr√≠o de la aplicaci√≥n cuando <code>private static readonly ILogger Log = LogManager.GetCurrentClassLogger()</code> campos de la forma <code>private static readonly ILogger Log = LogManager.GetCurrentClassLogger()</code> .  Es decir, no afecta directamente el rendimiento del sistema. </li></ul><br><h1 id="vyvod">  Conclusi√≥n </h1><br><p>  ¬øCu√°l es la mejor manera de manejar los registros? </p><br><ul><li>  Si es posible no iniciar sesi√≥n en absoluto, este ser√° el m√°s r√°pido (lo cual es obvio hasta ahora). </li><li>  Si el proyecto tiene muchas llamadas de registrador que no vuelcan datos a un archivo (a la consola, etc.), entonces NLog es m√°s r√°pido.  Adem√°s, asigna menos objetos en el mont√≥n. </li><li>  Si a√∫n necesita escribir en un archivo, NLog funciona de forma as√≠ncrona con la mayor rapidez.  S√≠, consume m√°s memoria (en comparaci√≥n con NLog en modo s√≠ncrono, ya que de acuerdo con mis mediciones anteriores, log4net ni siquiera intenta reutilizar las matrices y <code>Stream</code> 's).  Sin embargo, el programa podr√° ejecutarse m√°s r√°pido. </li><li>  Crear un registrador no es una operaci√≥n gratuita, por lo que a menudo es mejor crearlo con un campo est√°tico.  Esto no se aplica a la creaci√≥n de una cadena, es decir, algo as√≠ como <code>LogManager.GetLogger("123")</code> .  Estas llamadas funcionan m√°s r√°pido, lo que significa que se puede crear un registrador para grandes instancias de objetos (por ejemplo, "un registrador para el contexto de la consulta"). </li><li>  Si desea generar muchos par√°metros en el registro, pero en la mayor√≠a de los casos no habr√° volcado directo de datos en el archivo, entonces es mejor hacer varias llamadas.  Por lo tanto, NLog no crear√° objetos adicionales en el mont√≥n si no se necesitan all√≠. </li></ul><br><p>  Conclusiones para su c√≥digo: </p><br><ul><li>  Si su m√©todo acepta un objeto arbitrario (es decir, un <code>object</code> ) y en la mayor√≠a de los casos no hace nada (lo cual es cierto para los contratos / validadores), entonces es m√°s correcto ajustar las llamadas en una forma gen√©rica (es decir, hacer m√©todos de la forma <code>Something&lt;TArg&gt;(TArg arg)</code> ).  Esto funcionar√° realmente m√°s r√°pido. </li><li>  Si en su c√≥digo se permite un restablecimiento de datos de archivo y al mismo tiempo funciona con otra cosa, es mejor confundirse y respaldar esto.  S√≠, parece obvio que la ejecuci√≥n paralela puede acelerar el trabajo, sin embargo, en el caso de las operaciones de E / S, este enfoque tambi√©n brinda un aumento de rendimiento adicional en m√°quinas con discos lentos. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456488/">https://habr.com/ru/post/456488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456470/index.html">Errores del editor de paquetes WSUS</a></li>
<li><a href="../456474/index.html">Tic Tac Toe Parte 0: Comparar Svelte y React</a></li>
<li><a href="../456476/index.html">Modificaciones de pila Bluetooth para mejorar la calidad de audio en auriculares sin c√≥decs AAC, aptX o LDAC</a></li>
<li><a href="../456482/index.html">Atr√°pame si puedes. King Version</a></li>
<li><a href="../456486/index.html">Interfaz y elecci√≥n (2014)</a></li>
<li><a href="../456490/index.html">Conferencias sobre el cerebro, parte 1. La evoluci√≥n del cerebro humano. El cerebro funciona en cada etapa de su desarrollo.</a></li>
<li><a href="../456492/index.html">Ej√©rcito troll</a></li>
<li><a href="../456498/index.html">Administrador de dispositivos Extienda MIS a dispositivos</a></li>
<li><a href="../456500/index.html">C√≥mo ense√±ar a superar dificultades y al mismo tiempo escribir ciclos</a></li>
<li><a href="../456502/index.html">Los art√≠culos cient√≠ficos m√°s cortos.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>