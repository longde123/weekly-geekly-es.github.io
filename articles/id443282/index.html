<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚏 🤞🏾 🚣🏻 Apa yang harus kita bangun dengan blockchain? 👇 👋 🎚️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seluruh sejarah umat manusia adalah pembebasan berkelanjutan dari rantai dan penciptaan yang baru, bahkan lebih kuat. (Penulis anonim) 

 Menganalisis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang harus kita bangun dengan blockchain?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443282/"> <i>Seluruh sejarah umat manusia adalah pembebasan berkelanjutan dari rantai dan penciptaan yang baru, bahkan lebih kuat.</i>  <i>(Penulis anonim)</i> <br><br>  Menganalisis berbagai proyek blockchain (Bitshares, Hyperledger, Exonum, Ethereum, Bitcoin, dll.), Saya mengerti bahwa dari sudut pandang teknis, semuanya dibangun di atas prinsip yang sama.  Blockchain menyerupai rumah yang, untuk semua ragam desain, dekorasi, dan sebutannya, memiliki fondasi, dinding, atap, jendela, pintu, yang terhubung satu sama lain dengan cara tertentu.  Dan jika Anda memahami prinsip dasar desain bangunan, mengetahui sifat-sifat bahan yang digunakan, maka Anda bisa menentukan tujuan rumah tertentu.  Saat ini, sebuah situasi muncul dengan blockchain yang semua orang telah mendengarnya, tetapi hanya sedikit yang memahami arsitektur dan prinsip kerja.  Oleh karena itu, kesalahpahaman muncul untuk apa dan bagaimana masuk akal untuk menggunakan teknologi blockchain. <br><br>  Pada artikel ini, kami akan menganalisis sifat dan prinsip yang umum untuk semua blockchain.  Selanjutnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kita melihat tugas-tugas</a> yang dapat diselesaikan dengan menggunakan blockchain dan untuk mengkonsolidasikan materi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kita akan membangun</a> blockchain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kecil</a> , tetapi nyata di situs virtual kami! <br><br>  Jadi, mari kita ingat masalah apa yang awalnya dipecahkan oleh blockchain. <br><a name="habracut"></a><br>  Saya yakin banyak yang akan mengatakan tentang database yang terdistribusi, terdesentralisasi, publik dan tidak berubah.  Tetapi mengapa semua ini dibutuhkan? <br><br>  Saya lebih suka mulai mempelajari teknologi apa pun dengan membaca standar, karena semua artikel dan buku tentang topik yang diteliti didasarkan pada mereka.  Tetapi standar blockchain saat ini kurang, hanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komite yang</a> telah dibuat dalam ISO untuk pengembangan mereka.  Saat ini, setiap proyek blockchain publik memiliki Buku Putih sendiri, yang pada dasarnya adalah tugas teknis.  Proyek blockchain pertama yang terkenal adalah jaringan Bitcoin.  Kami pergi ke situs web resmi jaringan dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melihat</a> bagaimana semuanya dimulai. <br><br><h2>  Tantangan Blockchain </h2><br>  Jadi, tugas yang dipecahkan oleh blockchain dalam jaringan perintis Bitcoin adalah melakukan transfer kepercayaan kepemilikan aset digital di lingkungan yang tidak terpercaya tanpa perantara.  Misalnya, pada jaringan Bitcoin, aset digital adalah koin bitcoin digital.  Dan semua solusi teknis Bitcoin dan blockchains lainnya hadir untuk menyelesaikan masalah ini. <br><br><h3>  Masalah blockchain </h3><br>  Misalkan organisasi keuangan tertentu mengatakan bahwa ia telah membangun jaringan di seluruh dunia yang dengannya Anda dapat mentransfer uang kepada siapa pun.  Apakah Anda percaya padanya?  Jika organisasi ini Visa atau MasterCard, kemungkinan besar, percayalah, tetapi jika, secara relatif, AnonymousWorldMoney, mungkin tidak.  Kenapa begitu?  Tetapi karena kita tahu betul bagaimana sistem terdistribusi dibuat oleh perusahaan swasta, untuk tujuan apa, dan apa yang dapat menyebabkan hal ini.  Mari kita pertimbangkan secara lebih rinci masalah sistem tersebut, dan bagaimana mereka dapat dipecahkan dengan menggunakan teknologi blockchain. <br><br>  Misalkan, di AnonymousWorldMoney bersyarat ada server dengan database, dan ada baiknya jika akan ada beberapa dari mereka di pusat data yang berbeda.  Ketika pengirim mentransfer uang, transaksi dicatat yang direplikasi ke semua server, dan uang mencapai penerima. <br><br><img src="https://habrastorage.org/webt/o7/co/fj/o7cofjk0-shjouhh3w_-heydohm.png" alt="gambar"><br><br>  Dalam dunia yang ideal, skema semacam itu bekerja dengan baik, tetapi di dunia kita sendiri, masalah-masalah berikut muncul: <br><br><ol><li>  Masalah mengidentifikasi peserta di satu sisi dan kebutuhan untuk anonimitas transaksi di sisi lain.  Yaitu  perlu untuk mentransfer uang ke penerima tertentu dan agar tidak ada yang tahu tentang transaksi ini, kecuali untuk peserta dalam transaksi.  Bank memiliki nomor rekening dan kartu bank yang ditautkan dengan individu atau badan hukum tertentu, dan kerahasiaan bank melindungi informasi transaksi.  Dan siapa yang menjamin bahwa AnonymousWorldMoney bersyarat tidak menggunakan data pribadi dan informasi transaksi untuk tujuannya sendiri? <br></li><li>  Bagaimana cara memastikan bahwa penerima menerima persis jumlah yang ditransfer kepadanya?  Secara relatif, pengirim mengirim $ 100, dan penerima menerima $ 10.  Pengirim tiba di kantor AnonymousWorldMoney dengan tanda terima, dan petugas menunjukkan versinya, yang mengatakan bahwa pengirim hanya ditransfer $ 10. <br></li><li>  Masalah lingkungan yang tidak dipercaya, seperti penipuan yang disebut pengeluaran ganda.  Peserta yang tidak bermoral dapat menghabiskan saldo beberapa kali sampai pembayaran direplikasi ke semua server.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tentu</a> saja, tidak ada yang membatalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teorema CAP</a> , dan koherensi pada akhirnya akan tercapai, tetapi seseorang tidak akan menerima uang untuk layanan atau barang yang diberikan.  Oleh karena itu, jika tidak ada kepercayaan penuh pada organisasi pembayaran atau peserta dalam transaksi, maka perlu untuk membangun jaringan berdasarkan bukan pada kepercayaan, tetapi pada kriptografi. <br></li><li>  AnonymousWorldMoney bersyarat memiliki sejumlah server terbatas yang mungkin menjadi tidak tersedia secara tidak sengaja atau dengan niat jahat. <br></li><li>  AnonymousWorldMoney akan mengambil komisi nyata. <br></li><li>  Kemampuan untuk mengendalikan.  Dalam proses mengeksploitasi Bitcoin, ternyata orang-orang ingin tidak hanya mentransfer koin satu sama lain, tetapi juga memeriksa berbagai kondisi transaksi, skenario kerja program, secara otomatis melakukan tindakan tergantung pada kondisi, dll. <br></li></ol><br><h3>  Bagaimana blockchain memecahkan masalah ini </h3><br><ol><li>  Peserta diidentifikasi menggunakan pasangan kunci: privat dan publik, dan algoritma tanda tangan digital secara unik mengidentifikasi pengirim dan penerima, meninggalkan identitas mereka anonim. <br></li><li>  Transaksi dikumpulkan dalam blok, hash blok dihitung, yang dicatat di blok berikutnya.  Urutan penulisan hash ini dalam blok memberi nama teknologi blockchain, dan itu juga membuat mustahil untuk secara diam-diam mengubah / menghapus blok atau transaksi individu dari blok.  Dengan demikian, jika suatu transaksi jatuh ke dalam blockchain, Anda dapat yakin bahwa datanya akan tetap tidak berubah. <br></li><li>  Penipuan pengeluaran ganda dicegah dengan mencapai konsensus di jaringan mana data harus dianggap benar dan yang harus dibuang.  Di jaringan Bitcoin, konsensus dicapai dengan bukti PoW (Proof-of-Work). <br></li><li>  Keandalan fungsi jaringan dicapai oleh fakta bahwa blockchain bersifat publik, di mana setiap peserta dapat meluncurkan node sendiri, mendapatkan salinan penuh blockchain dan, apalagi, secara mandiri mulai memeriksa transaksi untuk kebenaran.  Perlu dicatat bahwa blockchain modern memungkinkan Anda untuk membangun tidak hanya blockchain publik (terbuka), tetapi juga privat (tertutup), serta menggunakan skema gabungan. <br></li><li>  Saya tidak akan sepenuhnya menghilangkan komisi di blockchain, karena  Anda harus membayar orang yang mendukung jaringan, tetapi di blockchain, kebutuhan komisi terbukti sangat meyakinkan sehingga tidak ada keraguan tentang perlunya. <br></li><li>  Blockchain modern memiliki kemampuan untuk mengimplementasikan logika bisnis, yang disebut Kontrak Cerdas dalam blockchain.  Logika kontrak pintar diterapkan dalam berbagai bahasa tingkat tinggi. <br></li></ol><br>  Selanjutnya, kami mempertimbangkan solusi ini secara lebih rinci. <br><br><h2>  Arsitektur Blockchain </h2><br><h3>  Komponen blockchain </h3><br>  Setiap peserta dapat menjalankan node-nya dengan salinan penuh blockchain (full node).  Node lengkap yang dapat mencatat transaksi pada blockchain disebut <b>nonsensus</b> (saksi) atau penambang.  Node penuh yang hanya memverifikasi kebenaran transaksi disebut <b>node audit</b> .  <b>Klien ringan</b> tidak menyimpan salinan penuh blockchain, tetapi berinteraksi dengan jaringan menggunakan node penuh. <br>  Sebagian besar pengguna menggunakan klien ringan atau dompet web untuk menyelesaikan transaksi.  Semua node terhubung satu sama lain.  Dengan serangkaian elemen ini, arsitektur jaringan menjadi lebih stabil: <br><br><img src="https://habrastorage.org/webt/5p/yy/vw/5pyyvwl9naev2qgbgitlfda2i3m.png" alt="gambar"><br><br><h3>  Siklus Hidup Transaksi </h3><br>  Mari kita lihat siklus hidup transaksi dan menganalisisnya dalam beberapa bagian: <br><br><img src="https://habrastorage.org/webt/wy/9s/ot/wy9sotn6sgtl0kpw9532yvpelcw.png" alt="gambar"><br><br><h2>  Teknologi blockchain </h2><br>  Mari kita membahas lebih dalam tentang solusi teknis dan hubungan mereka satu sama lain. <br><br><h3>  Identifikasi </h3><br>  Setiap transaksi blockchain harus ditandatangani secara digital.  Oleh karena itu, untuk menyelesaikan transaksi, setiap peserta harus memiliki pasangan kunci: pribadi / publik.  Kadang sepasang kunci disebut dompet, karena  kunci secara unik dikaitkan dengan alamat digital unik dan keseimbangan peserta.  Pada kenyataannya, kunci dan alamat hanyalah serangkaian angka dalam sistem angka yang berbeda.  Contoh kunci dan alamat dompet: <br><br><pre><code class="plaintext hljs">Private key: 0a78194a8a893b8baac7c09b6a4a4b4b161b2f80a126cbb79bde231a4567420f Public key: 0579b478952214d7cddac32ac9dc522c821a4489bc10aac3a81b9d1cd7a92e57ba Address: 0x3814JnJpGnt5tB2GD1qfKP709W3KbRdfb27V</code> </pre> <br>  Untuk membuat tanda tangan digital pada blockchains, digunakan algoritma berdasarkan kurva eliptik: Elliptic Curve Digital Signature Algorithm (ECDSA).  Untuk operasinya, kunci pribadi (nomor 256 bit) biasanya diambil secara acak.  Jumlah opsi kunci adalah 2 pangkat 256, sehingga kita dapat berbicara tentang ketidakmungkinan praktis untuk mencocokkan nilai-nilai kunci pribadi. <br><br>  Lebih lanjut, kunci publik diperoleh dari kunci privat dengan mengalikan nilainya dengan koordinat titik yang terletak pada kurva eliptik, sehingga diperoleh koordinat titik baru dari kurva yang sama.  Tindakan ini memastikan bahwa Anda menerima pasangan kunci yang cocok untuk transaksi yang ditandatangani secara digital.  Akhirnya, alamat dompet dihitung secara unik dari kunci publik. <br><br>  Ada banyak artikel dengan perincian tentang kriptografi yang digunakan dalam blockchain, misalnya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bitcoin secara singkat - Kriptografi</a> <br><br>  Kunci pribadi harus dirahasiakan dan disimpan dengan aman.  Kunci publik diketahui semua orang.  Jika kunci pribadi hilang, akses ke aset (koin) tidak dapat dipulihkan dan uang akan hilang selamanya.  Oleh karena itu, tugas penyimpanan kunci pribadi yang andal sangat relevan, karena  ini bukan bank tempat Anda selalu bisa membawa paspor dan mengembalikan akun Anda.  Ada seluruh industri untuk memproduksi apa yang disebut dompet crypto dingin, mirip dengan flash drive: <br><br><img src="https://habrastorage.org/webt/_q/ya/ou/_qyaoutie6y86ynxzp3ozoqy0ge.jpeg" alt="gambar"><br><br>  atau Anda dapat menggunakan metode yang lebih andal, sebagai contoh, untuk menghilangkan nilai kunci pribadi pada token: <br><br><img src="https://habrastorage.org/webt/es/oa/xn/esoaxnlhazwwy93gzhuinavo56m.jpeg" alt="gambar"><br><br><h3>  Transaksi </h3><br>  Untuk informasi lebih lanjut tentang struktur transaksi, lihat artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bitcoin secara singkat - Transaksi</a> .  Penting bagi kita untuk memahami bahwa setiap transaksi setidaknya memiliki data berikut: <br><br><pre> <code class="plaintext hljs">From: 0x48C89c341C5960Ca2Bf3732D6D8a0F4f89Cc4368 -    To: 0x367adb7894334678b90fe7882a5b06f7fbc783a -    Value: 0.0001 -   Transaction Hash: 0x617ede331e8a99f46a363b32b239542bb4006e4fa9a2727a6636ffe3eb095cef -  </code> </pre> <br>  Selanjutnya, transaksi ditandatangani dengan kunci pribadi dan dikirim (lihat detail tentang operasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bitcoin secara singkat-Protokol</a> ) ke semua node di blockchain yang memverifikasi transaksi untuk validitas.  Algoritma verifikasi transaksi adalah nontrivial dan mencakup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua lusin langkah</a> . <br><br><h3>  Blok transaksi </h3><br>  Setelah memeriksa validitas transaksi, node membentuk blok darinya.  Selain transaksi, hash dari blok sebelumnya, angka (penghitung Nonce) ditulis ke blok, dan hash dari blok saat ini dihitung menggunakan algoritma SHA-256.  Hash harus memiliki kondisi kompleksitas yang ditetapkan.  Misalnya, pada jaringan Bitcoin, kompleksitas hash secara otomatis berubah setiap 2 minggu tergantung pada kapasitas jaringan sehingga blok dihasilkan kira-kira setiap 10 menit.  Kompleksitas ditentukan oleh kondisi berikut: hash yang ditemukan harus kurang dari angka yang telah ditentukan.  Jika kondisi ini tidak terpenuhi, maka 1 ditambahkan ke Nonce, dan perhitungan hash diulang.  Untuk memilih hash, bidang Nonce digunakan, karena  ini adalah satu-satunya data di blok yang dapat diubah, sisanya harus tetap tidak berubah.  Hash yang benar harus memiliki sejumlah nol di awal, misalnya, salah satu hash nyata: <br><br><pre> <code class="plaintext hljs">000000000000000000000bf03212e7dd1176f52f816fa395fc9b93c44bc11f91</code> </pre> <br>  Berhasil menemukan hash adalah bukti dari pekerjaan yang dilakukan (Proof-of-Work, PoW) untuk jaringan Bitcoin atau Ethereum.  Proses menemukan hash disebut penambangan, dengan analogi dengan penambangan emas.  Nama menentukan esensi proses secara akurat, karena  ada enumerasi pilihan sederhana, dan jika seseorang menemukan hash yang cocok, maka ini benar-benar keberuntungan.  Inilah cara menemukan nugget emas asli dalam berton-ton gangue.  Hadiah untuk blok sekarang adalah 12,5 BTC dan jika Anda kalikan $ 3900 dengan nilai tukar bitcoin saat ini, Anda mendapatkan lebih dari satu kilogram emas murni.  Ada sesuatu untuk diperjuangkan! <br><br>  Setelah berhasil menemukan hash, blok dan hash yang ditemukan itu sendiri ditulis ke blockchain oleh blok berikutnya.  Rincian lebih lanjut tentang struktur blok dapat ditemukan dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bitcoin di singkatnya-Blockchain</a> , dan di bawah ini saya akan memberikan diagram yang disederhanakan: <br><br><img src="https://habrastorage.org/webt/dp/4i/xp/dp4ixppxs4f1j7kquawo80l7s68.png" alt="gambar"><br><br>  Blockchain dimulai dengan blok yang belum memiliki hash dari blok sebelumnya.  Hanya ada satu blok seperti itu di blockchain dan memiliki namanya sendiri blok Genesis.  Blok yang tersisa memiliki struktur yang sama dan mereka hanya berbeda dalam jumlah transaksi.  Transaksi dan blok nyata yang saat ini sedang dibuat dalam Bitcoin atau Ethereum dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Block Explorer</a> . <br><br>  Ukuran blok dalam Bitcoin terbatas hingga 1MB dan dengan jumlah minimum informasi dalam transaksi sekitar 200 byte, maksimum dalam satu blok bisa sekitar 6.000 transaksi.  Dari sini, omong-omong, adalah kinerja Bitcoin, yang ditertawakan semua orang: satu blok dihasilkan kira-kira setiap 10 menit * 60 detik = 600 detik, yang memberikan kinerja formal sekitar 10 TPS.  Meskipun dalam kenyataannya - ini bukan kinerja, tetapi algoritma kerja yang diimplementasikan secara sadar.  Ethereum baru saja membuat waktu pembuatan blok 15 detik untuk kompetisi.  dan produktivitas secara resmi meningkat.  Oleh karena itu, dalam blockchains menggunakan PoW sebagai konsensus, umumnya tidak ada gunanya untuk membandingkan kinerja, karena  secara langsung tergantung pada kompleksitas penghitungan cache, yang dapat ditugaskan untuk apa saja. <br><br><h3>  Garpu </h3><br>  Dan apa yang terjadi jika, misalnya, beberapa node menemukan hash yang memenuhi kondisi kompleksitas, tetapi memiliki makna yang berbeda (dengan kata lain, mencapai konsensus yang berbeda) dan menulis blok ke blockchain?  Mari kita lihat bagaimana blockchain melindungi dirinya dari situasi ini.  Dalam hal ini, yang disebut fork ('fork') terjadi, dan blockchain memiliki dua versi rantai: <br><br><img src="https://habrastorage.org/webt/71/ts/s9/71tss9efxoawbjgyokdk15ws3dg.png" alt="gambar"><br><br>  Apa yang terjadi selanjutnya?  Selanjutnya, bagian dari jaringan mulai bekerja pada blok N + 2 dari satu rantai, dan sebagian dari yang lain: <br><br><img src="https://habrastorage.org/webt/ts/z2/w2/tsz2w2ab-t7loh0_8udrlcy88e0.png" alt="gambar"><br><br>  Beberapa dari blok ini akan ditemukan lebih awal dan dikirim ke blockchain, dan kemudian, sesuai aturan, blockchain harus beralih ke rantai yang lebih panjang dan membatalkan semua transaksi dari blok alternatif: <br><br><img src="https://habrastorage.org/webt/gw/yf/md/gwyfmdl5t7gp7g_8gg1fal88u40.png" alt="gambar"><br><br>  Pada saat yang sama, sebuah situasi dapat muncul ketika transaksi peserta hanya di salah satu blok garpu, yang dibatalkan.  Oleh karena itu, untuk memastikan bahwa transaksi yang diinginkan dicatat di blockchain, ada rekomendasi umum - sebelum mempercayai transaksi, Anda harus menunggu sampai beberapa blok berikutnya ditambahkan ke blockchain.  Rekomendasi tentang berapa banyak blok untuk menunggu berbagai blokir berbeda.  Misalnya, untuk jaringan Bitcoin, minimum adalah 2 blok, maksimum adalah 6. <br><br>  Gambaran yang sama dengan garpu blok juga akan diamati dengan apa yang disebut serangan 51% - ini adalah ketika sekelompok penambang akan mencoba menumbuhkan rantai blok alternatif, berusaha untuk membatalkan rantai dengan transaksi penipuan mereka.  Meskipun saat ini, alih-alih penipuan, lebih baik menghabiskan daya Anda untuk penambangan yang jujur. <br><br><h3>  Konsensus </h3><br>  Untuk menulis blok ke blockchain, jaringan harus mencapai konsensus.  Mari kita ingat tugas untuk mencapai konsensus dalam jaringan komunikasi komputer.  Masalahnya dirumuskan sebagai tugas para jenderal Bizantium BFT ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">toleransi kesalahan Bizantium</a> ).  Menghilangkan deskripsi bergambar tentang masalah pasukan Bizantium, masalahnya dapat dirumuskan sebagai berikut: bagaimana node jaringan sampai pada hasil yang umum, jika bagian dari node jaringan secara sadar dapat mengubah mereka.  Algoritma yang ada untuk menyelesaikan masalah BFT menunjukkan bahwa jaringan dapat berfungsi dengan benar jika penipu kurang dari 1/3.  Mengapa konsensus BFT tidak diterapkan pada jaringan Bitcoin?  Mengapa menggunakan PoW?  Ada beberapa alasan: <br><br><ul><li>  BFT bekerja dengan baik dengan set kecil node tetap, dan di blockchain publik, jumlah node tidak dapat diprediksi dan, lebih lanjut, node dapat dihidupkan dan dimatikan secara sewenang-wenang. </li><li>  Kita perlu memotivasi orang untuk meluncurkan node blockchain.  Untuk ini, orang harus menerima hadiah.  Di BFT, secara formal tidak ada apa pun yang dapat menerima hadiah, tetapi imbalan untuk PoW dapat dipahami oleh semua orang pada tingkat intuitif: untuk listrik yang dikonsumsi oleh prosesor dalam proses menemukan hash blok. </li></ul><br>  Selain PoW, ada beberapa masalah konsensus yang digunakan dalam blockchain modern, misalnya: <br><br><ul><li>  PoS (Proof-of-Stake) - di blockchain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hyperledger</a> </li><li>  DPoS (Delegated Proof-of-Stake) - di blockchain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BitShares</a> </li><li>  Modifikasi BFT: SBFT (BFT Sederhana) dan PBFT (Praktis BFT), misalnya, dalam blockchain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Exonum</a> </li></ul><br>  Mari kita memikirkan konsensus PoS, karena  itu adalah PoS dan variannya yang paling banyak digunakan di blockchains pribadi.  Kenapa diam-diam?  Di satu sisi, karakteristik PoS lebih baik daripada PoW, karena  Untuk mencapai konsensus, dibutuhkan lebih sedikit sumber daya komputasi, yang berarti bahwa kecepatan penulisan data ke blockchain meningkat.  Tetapi di sisi lain, PoS memiliki lebih banyak peluang untuk penipuan, oleh karena itu, untuk menetralisir ini, semua peserta dalam blockchain harus diketahui. <br><br>  Konsensus PoS didasarkan pada pilihan node yang dapat menulis blok dengan transaksi di blockchain tergantung pada jumlah dana dalam akun, atau lebih tepatnya, tidak di akun, tetapi dalam janji, yaitu.  semakin banyak uang yang Anda miliki dalam janji, semakin besar kemungkinan jaringan akan memilih simpul Anda untuk merekam blok.  Setoran tidak akan dikembalikan jika unit tidak valid.  Dengan demikian, perlindungan terhadap penipuan diterapkan.  Variasi PoS berikut tersedia: <br><br><ul><li>  Konsensus Delegated PoS (DPoS) membagi peserta menjadi “memilih” dan “memvalidasi”.  Pemegang koin (peserta pemungutan suara) mendelegasikan hak mereka untuk memverifikasi dan mencatat transaksi pada blockchain ke peserta lain.  Dengan demikian, validator melakukan semua pekerjaan komputasi dan mendapatkan imbalan untuk ini, dan kehadiran peserta pemungutan suara menjamin kejujuran para validator, karena  mereka dapat diubah kapan saja. </li><li>  Konsensus LPoS (Sewa Bukti-Stake) memungkinkan Anda untuk menyewakan dana Anda ke node lain sehingga mereka memiliki kesempatan lebih baik untuk memeriksa blok.  T.O.  Anda bisa mendapatkan komisi untuk transaksi, sambil tidak berpartisipasi dalam verifikasi transaksi itu sendiri dan memblokir penambangan. </li></ul><br>  Masih ada sejumlah konsensus yang belum tersebar luas, saya hanya akan mencantumkannya di sini untuk mendapatkan informasi, dan gambaran umum algoritma konsensus itu sendiri dapat ditemukan, misalnya, dalam artikel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Algoritma Konsensus di Blockchain</a> . <br><br><ul><li>  Penyair (Proof-of-Elapsed Time) </li><li>  PoC (Bukti Kapasitas) </li><li>  PoB (Bukti Bakar) </li><li>  PoWeight (Proof-of-Weight) </li><li>  PoA (Bukti Aktivitas) - PoW + PoS </li><li>  PoI (Bukti-Pentingnya Impor) </li></ul><br><h3>  Keandalan dan model penyebaran blockchain </h3><br>  <b>Blockchain publik</b> <br><br>  Stabilitas <b>Publik</b> atau nama lain untuk <b>blockchain Tanpa Izin</b> dicapai oleh fakta bahwa setiap orang dapat terhubung dan melihat informasi atau bahkan menghubungkan node mereka sendiri, dan kepercayaan dibangun berdasarkan konsensus PoW. <br><br>  <b>Blockchain pribadi</b> <br><br>  <b>Blockchain</b> <b>Pribadi</b> atau <b>Privat</b> .  Dalam blockchain ini, hanya sekelompok peserta tertentu (organisasi atau orang) yang memiliki akses ke informasi.  Blokir semacam itu dibangun oleh organisasi untuk meningkatkan laba atau efisiensi secara keseluruhan.  Keandalan mereka dijamin oleh tujuan bersama para peserta dan algoritma konsensus dari PoS dan BFT. <br><br>  <b>Konsorsium Blockchain</b> <br><br>  Ada <b>Konsorsium</b> atau <b>blockchain Izin Publik</b> .  Ini adalah blockchains sehingga setiap orang dapat terhubung untuk melihat, tetapi seorang peserta dapat menambahkan informasi atau menghubungkan situsnya hanya dengan izin dari peserta lain.  Blokade semacam itu dibangun oleh organisasi untuk meningkatkan kepercayaan pada pelanggan atau konsumen produk atau masyarakat secara keseluruhan.  Di sini, reliabilitas juga dicapai dengan adanya kepercayaan antara peserta dan algoritma konsensus PoS dan BFT yang sama. <br><br><h3>  Kontrak yang cerdas </h3><br>  Blockchain diimplementasikan setelah Bitcoin, sedikit banyak, menambahkan kemampuan untuk mengeksekusi kontrak pintar.  Intinya, kontrak pintar adalah transaksi di mana kode program ditempatkan untuk dieksekusi.  Kontrak pintar pada jaringan Ethereum dijalankan dalam EVM (Ethereum Virtual Machine).  Untuk memulai pelaksanaan kontrak pintar, itu harus diluncurkan secara eksplisit oleh transaksi lain, atau prasyarat untuk eksekusi harus dipenuhi.  Hasil penerapan kontrak pintar juga dicatat di blockchain.  Mendapatkan data dari luar blockchain dimungkinkan, tetapi sangat terbatas. <br><br>  Logika bisnis apa yang dapat diimplementasikan menggunakan kontrak pintar?  Kenyataannya, tidak banyak, misalnya, memeriksa kondisi berdasarkan data dari blockchain, mengubah pemilik aset digital tergantung pada kondisi ini, menulis data ke penyimpanan permanen di dalam blockchain.  Logikanya diimplementasikan dalam bahasa tingkat tinggi khusus, Soliditas. <br><br>  Contoh klasik fungsionalitas yang diterapkan menggunakan kontrak pintar adalah masalah token untuk ICO.  Sebagai contoh, saya menerapkan kontrak pintar untuk merilis 500 juta AlexToken yang sederhana.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan di Etherscan</a> adalah <br><br><div class="spoiler">  <b class="spoiler_title">Kode sumber kontrak pintar soliditas</b> <div class="spoiler_text"><pre> <code class="cpp hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span>; library SafeMath { <span class="hljs-comment"><span class="hljs-comment">/** * @dev Multiplies two numbers, throws on overflow. **/</span></span> <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 a, uint256 b)</span></span></span><span class="hljs-function"> internal pure </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } c = a * b; assert(c / a == b); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; } <span class="hljs-comment"><span class="hljs-comment">/** * @dev Integer division of two numbers, truncating the quotient. **/</span></span> <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 a, uint256 b)</span></span></span><span class="hljs-function"> internal pure </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// assert(b &gt; 0); // Solidity automatically throws when dividing by 0 /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (ie if subtrahend is greater than minuend). **/ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b &lt;= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. **/ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c &gt;= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of "user permissions". **/ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender account. **/ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. **/ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. **/ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title ERC20Basic interface * @dev Basic ERC20 interface **/ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 **/ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. **/ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address =&gt; uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence **/ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. **/ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value &lt;= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. **/ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred **/ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value &lt;= balances[_from]); require(_value &lt;= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. **/ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. **/ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. **/ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. **/ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue &gt; oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Configurable * @dev Configurable varriables of the contract **/ contract Configurable { uint256 public constant cap = 1000000000*10**18; uint256 public constant basePrice = 100*10**18; // tokens per 1 ether uint256 public tokensSold = 0; uint256 public constant tokenReserve = 500000000*10**18; uint256 public remainingTokens = 0; } /** * @title CrowdsaleToken * @dev Contract to preform crowd sale with token **/ contract CrowdsaleToken is StandardToken, Configurable, Ownable { /** * @dev enum of current crowd sale state **/ enum Stages { none, icoStart, icoEnd } Stages currentStage; /** * @dev constructor of CrowdsaleToken **/ constructor() public { currentStage = Stages.none; balances[owner] = balances[owner].add(tokenReserve); totalSupply_ = totalSupply_.add(tokenReserve); remainingTokens = cap; emit Transfer(address(this), owner, tokenReserve); } /** * @dev fallback function to send ether to for Crowd sale **/ function () public payable { require(currentStage == Stages.icoStart); require(msg.value &gt; 0); require(remainingTokens &gt; 0); uint256 weiAmount = msg.value; // Calculate tokens to sell uint256 tokens = weiAmount.mul(basePrice).div(1 ether); uint256 returnWei = 0; if(tokensSold.add(tokens) &gt; cap){ uint256 newTokens = cap.sub(tokensSold); uint256 newWei = newTokens.div(basePrice).mul(1 ether); returnWei = weiAmount.sub(newWei); weiAmount = newWei; tokens = newTokens; } tokensSold = tokensSold.add(tokens); // Increment raised amount remainingTokens = cap.sub(tokensSold); if(returnWei &gt; 0){ msg.sender.transfer(returnWei); emit Transfer(address(this), msg.sender, returnWei); } balances[msg.sender] = balances[msg.sender].add(tokens); emit Transfer(address(this), msg.sender, tokens); totalSupply_ = totalSupply_.add(tokens); owner.transfer(weiAmount);// Send money to owner } /** * @dev startIco starts the public ICO **/ function startIco() public onlyOwner { require(currentStage != Stages.icoEnd); currentStage = Stages.icoStart; } /** * @dev endIco closes down the ICO **/ function endIco() internal { currentStage = Stages.icoEnd; // Transfer any remaining tokens if(remainingTokens &gt; 0) balances[owner] = balances[owner].add(remainingTokens); // transfer any remaining ETH balance in the contract to the owner owner.transfer(address(this).balance); } /** * @dev finalizeIco closes down the ICO and sets needed varriables **/ function finalizeIco() public onlyOwner { require(currentStage != Stages.icoEnd); endIco(); } } /** * @title LavevelToken * @dev Contract to create the Lavevel Token **/ contract AlexToken is CrowdsaleToken { string public constant name = "AlexToken"; string public constant symbol = "ALT"; uint32 public constant decimals = 18; }</span></span></code> </pre> <br></div></div><div class="spoiler">  <b class="spoiler_title">dan representasi biner tentang bagaimana jaringan melihatnya</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">60806040526000600355600060045533600560006101000</span></span>a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000600560146101000a81548160ff021916908360028111156200006f57fe5b0217905550620001036b019d971e4fe8401e74000000600080600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546200024a6401000000000262000b1d179091906401000000009004565b600080600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550620001986b019d971e4fe8401e740000006001546200024a6401000000000262000b1d179091906401000000009004565b6001819055506b033b2e3c9fd0803ce8000000600481905550600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef6b019d971e4fe8401e740000006040518082815260200191505060405180910390a362000267565b600081830190508281101515156200025e57fe5b80905092915050565b611cb880620002776000396000f300608060405260043610610112576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146104c7578063095ea7b31461055757806318160ddd146105bc57806323b872dd146105e7578063313ce5671461066c578063355274ea146106a3578063518ab2a8146106ce57806366188463146106f957806370a082311461075e57806389311e6f146107b55780638da5cb5b146107cc578063903a3ef61461082357806395d89b411461083a578063a9059cbb146108ca578063bf5839031461092f578063c7876ea41461095a578063cbcb317114610985578063d73dd623146109b0578063dd62ed3e14610a15578063f2fde38b14610a8c575b60008060008060006001600281111561012757fe5b600560149054906101000a900460ff16600281111561014257fe5b14151561014e57600080fd5b60003411151561015d57600080fd5b600060045411151561016e57600080fd5b3494506101a7670de0b6b3a764000061019968056bc75e2d6310000088610acf90919063ffffffff16565b610b0790919063ffffffff16565b9350600092506b033b2e3c9fd0803ce80000006101cf85600354610b1d90919063ffffffff16565b111561024c576101f66003546b033b2e3c9fd0803ce8000000610b3990919063ffffffff16565b915061022e670de0b6b3a764000061022068056bc75e2d6310000085610b0790919063ffffffff16565b610acf90919063ffffffff16565b90506102438186610b3990919063ffffffff16565b92508094508193505b61026184600354610b1d90919063ffffffff16565b6003819055506102886003546b033b2e3c9fd0803ce8000000610b3990919063ffffffff16565b6004819055506000831115610344573373ffffffffffffffffffffffffffffffffffffffff166108fc849081150290604051600060405180830381858888f193505050501580156102dd573d6000803e3d6000fd5b503373ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef856040518082815260200191505060405180910390a35b610395846000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054610b1d90919063ffffffff16565b6000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055503373ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef866040518082815260200191505060405180910390a361045184600154610b1d90919063ffffffff16565b600181905550600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc869081150290604051600060405180830381858888f193505050501580156104bf573d6000803e3d6000fd5b505050505050005b3480156104d357600080fd5b506104dc610b52565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561051c578082015181840152602081019050610501565b50505050905090810190601f1680156105495780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561056357600080fd5b506105a2600480360381019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610b8b565b604051808215151515815260200191505060405180910390f35b3480156105c857600080fd5b506105d1610c7d565b6040518082815260200191505060405180910390f35b3480156105f357600080fd5b50610652600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610c87565b604051808215151515815260200191505060405180910390f35b34801561067857600080fd5b50610681611041565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b3480156106af57600080fd5b506106b8611046565b6040518082815260200191505060405180910390f35b3480156106da57600080fd5b506106e3611056565b6040518082815260200191505060405180910390f35b34801561070557600080fd5b50610744600480360381019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061105c565b604051808215151515815260200191505060405180910390f35b34801561076a57600080fd5b5061079f600480360381019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506112ed565b6040518082815260200191505060405180910390f35b3480156107c157600080fd5b506107ca611335565b005b3480156107d857600080fd5b506107e16113eb565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561082f57600080fd5b50610838611411565b005b34801561084657600080fd5b5061084f6114ab565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561088f578082015181840152602081019050610874565b50505050905090810190601f1680156108bc5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156108d657600080fd5b50610915600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506114e4565b604051808215151515815260200191505060405180910390f35b34801561093b57600080fd5b50610944611703565b6040518082815260200191505060405180910390f35b34801561096657600080fd5b5061096f611709565b6040518082815260200191505060405180910390f35b34801561099157600080fd5b5061099a611716565b6040518082815260200191505060405180910390f35b3480156109bc57600080fd5b506109fb600480360381019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611726565b604051808215151515815260200191505060405180910390f35b348015610a2157600080fd5b50610a76600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611922565b6040518082815260200191505060405180910390f35b348015610a9857600080fd5b50610acd600480360381019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506119a9565b005b600080831415610ae25760009050610b01565b8183029050818382811515610af357fe5b04141515610afd57fe5b8090505b92915050565b60008183811515610b1457fe5b04905092915050565b60008183019050828110151515610b3057fe5b80905092915050565b6000828211151515610b4757fe5b818303905092915050565b6040805190810160405280600981526020017f416c6578546f6b656e000000000000000000000000000000000000000000000081525081565b600081600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b6000600154905090565b60008073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614151515610cc457600080fd5b6000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020548211151515610d1157600080fd5b600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020548211151515610d9c57600080fd5b610ded826000808773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054610b3990919063ffffffff16565b6000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550610e80826000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054610b1d90919063ffffffff16565b6000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550610f5182600260008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054610b3990919063ffffffff16565b600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b601281565b6b033b2e3c9fd0803ce800000081565b60035481565b600080600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490508083111561116d576000600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550611201565b6111808382610b3990919063ffffffff16565b600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b8373ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546040518082815260200191505060405180910390a3600191505092915050565b60008060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561139157600080fd5b60028081111561139d57fe5b600560149054906101000a900460ff1660028111156113b857fe5b141515156113c557600080fd5b6001600560146101000a81548160ff021916908360028111156113e457fe5b0217905550565b600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561146d57600080fd5b60028081111561147957fe5b600560149054906101000a900460ff16600281111561149457fe5b141515156114a157600080fd5b6114a9611b01565b565b6040805190810160405280600381526020017f414c54000000000000000000000000000000000000000000000000000000000081525081565b60008073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161415151561152157600080fd5b6000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054821115151561156e57600080fd5b6115bf826000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054610b3990919063ffffffff16565b6000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550611652826000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054610b1d90919063ffffffff16565b6000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a36001905092915050565b60045481565b68056bc75e2d6310000081565b6b019d971e4fe8401e7400000081565b60006117b782600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054610b1d90919063ffffffff16565b600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546040518082815260200191505060405180910390a36001905092915050565b6000600260008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905092915050565b600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515611a0557600080fd5b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614151515611a4157600080fd5b8073ffffffffffffffffffffffffffffffffffffffff16600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a380600560006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b6002600560146101000a81548160ff02191690836002811115611b2057fe5b021790555060006004541115611c0a57611ba5600454600080600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054610b1d90919063ffffffff16565b600080600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc3073ffffffffffffffffffffffffffffffffffffffff16319081150290604051600060405180830381858888f19350505050158015611c89573d6000803e3d6000fd5b505600a165627a7a723058205bbef016cc7699572f944871cb6f05e69915ada3a92a1d9f03a3fb434aac0c2b0029</code></pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lebih detail tentang kontrak pintar dapat ditemukan di artikel: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa itu kontrak pintar di Ethereum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami telah membuat daftar teknologi di mana blockchain modern dibangun dan bagaimana mereka terkait satu sama lain. </font><font style="vertical-align: inherit;">Sekarang mari kita merumuskan tugas-tugas mana yang dapat diselesaikan dengan menggunakan blockchain, dan solusi mana yang, dalam kasus terbaik, tidak efisien. </font><font style="vertical-align: inherit;">Jadi, tidak perlu menggunakan blockchain jika:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transaksi dilakukan di lingkungan tepercaya; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kehadiran komisi perantara tidak memperburuk kehidupan para peserta; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Peserta tidak memiliki properti yang dapat direpresentasikan sebagai aset digital; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada distribusi dalam aset digital, mis. </font><font style="vertical-align: inherit;">hanya satu anggota yang memiliki atau memberikan nilai.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa masa depan blockchain? </font><font style="vertical-align: inherit;">Sekarang kita hanya dapat berspekulasi tentang cara-cara yang mungkin untuk mengembangkan teknologi blockchain:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blockchain akan menjadi teknologi basis data konvensional yang sama seperti, misalnya, SQL atau NoSQL untuk menyelesaikan berbagai tugas spesifiknya; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blockchain akan menjadi protokol luas seperti HTTP untuk Internet; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blockchain akan menjadi dasar untuk sistem keuangan dan politik baru di planet ini! </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selanjutnya,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kita akan melihat blockchain apa yang ada saat ini dan mengapa mereka digunakan di berbagai industri. </font></font><br><br> <b><font color="#B22222"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu baru permulaan!</font></font></font></b> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ketiga artikel: </font></font></h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang harus kita bangun dengan blockchain? </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blockchain: apa yang harus kita bangun kasing? </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blockchain: apa yang harus kita bangun PoC?</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443282/">https://habr.com/ru/post/id443282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443272/index.html">Mitos hama nichrome</a></li>
<li><a href="../id443274/index.html">Kompilasi berita industri game dari 8 Maret hingga Minggu</a></li>
<li><a href="../id443276/index.html">Penjadwal Permintaan Kejutan di Database PostgreSQL</a></li>
<li><a href="../id443278/index.html">Coinbase crypto-exchange kehilangan pengguna karena pembelian startup untuk pembuat spyware dari Tim Peretasan</a></li>
<li><a href="../id443280/index.html">Kisah bagaimana saya merakit home theater 120 inci dari pipa, tali, layar lipat dan beludru hitam</a></li>
<li><a href="../id443284/index.html">Indeks dalam PostgreSQL - 4 (Btree)</a></li>
<li><a href="../id443286/index.html">TDMS Fairway. Mekanisme pengisian otomatis untuk prasasti utama pada gambar dan detail dokumen</a></li>
<li><a href="../id443290/index.html">Zen Erlang [dan Elixir - sekitar. penerjemah]</a></li>
<li><a href="../id443294/index.html">Apa yang diizinkan oleh Jupyter?</a></li>
<li><a href="../id443298/index.html">Pengisian nirkabel. Bagaimana cara kerjanya dalam praktik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>