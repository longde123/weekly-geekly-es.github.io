<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöû ü§πüèæ ü§ôüèΩ Por que o LLVM pode chamar uma fun√ß√£o nunca chamada? ü§ôüèΩ üï∫üèª üôâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eu n√£o ligo para o que seu drag√£o disse, √© uma mentira. Os drag√µes mentem. Voc√™ n√£o sabe o que est√° esperando por voc√™ do outro lado. 

 Michael Swanw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Por que o LLVM pode chamar uma fun√ß√£o nunca chamada?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458442/"><blockquote>  <i>Eu n√£o ligo para o que seu drag√£o disse, √© uma mentira.</i>  <i>Os drag√µes mentem.</i>  <i>Voc√™ n√£o sabe o que est√° esperando por voc√™ do outro lado.</i> <br><br>  Michael Swanwick, a filha do drag√£o de ferro </blockquote>  Este artigo √© baseado na postagem no blog de Krister Walfridsson, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Por que um comportamento indefinido pode chamar uma fun√ß√£o nunca chamada?"</a>  . <br><br>  O artigo tira uma conclus√£o simples: o comportamento indefinido em um compilador pode fazer qualquer coisa, mesmo algo absolutamente inesperado.  Neste artigo, examino o mecanismo interno dessa otimiza√ß√£o. <br><a name="habracut"></a><br>  Para recapitular brevemente a postagem de Waldfridsson, no c√≥digo-fonte abaixo, a fun√ß√£o EraseAll n√£o deve ser chamada de main, e n√£o √© realmente chamada quando compilada com -O0, mas de repente √© chamada com a otimiza√ß√£o -O1 e superior. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdlib&gt; typedef int (*Function)(); static Function Do; static int EraseAll() { return system(‚Äúrm -rf /‚Äù); } void NeverCalled() { Do = EraseAll; } int main() { return Do(); }</span></span></span></span></code> </pre> <br>  Como um compilador o otimiza?  No in√≠cio, Do, o ponteiro para uma fun√ß√£o √© nulo, porque, de acordo com o padr√£o C, todas as vari√°veis ‚Äã‚Äãglobais t√™m valores zero quando um programa √© iniciado. <br><br><img src="https://habrastorage.org/webt/5i/k5/s0/5ik5s0xohytqkbqnw2exo1on1jc.jpeg"><br><br>  O programa tentar√° desreferenciar o ponteiro Do e chamar a fun√ß√£o atribu√≠da.  Mas se tentarmos desreferenciar um ponteiro nulo, o padr√£o diz que √© UB, comportamento indefinido.  Normalmente, se compilarmos sem otimiza√ß√µes, com a op√ß√£o -O0, obteremos uma falha de segmenta√ß√£o (no Linux).  Mas o Standard diz que, no caso do UB, um programa pode fazer qualquer coisa. <br><br><img src="https://habrastorage.org/webt/ez/mq/bc/ezmqbco46shm4fqad2pbjyfhygw.jpeg"><br><br>  Um compilador usa esse recurso do padr√£o para remover opera√ß√µes desnecess√°rias.  Se um compilador v√™ que Do est√° atribu√≠do em qualquer lugar do programa, ele pode atribuir esse valor no tempo de inicializa√ß√£o e n√£o em tempo de execu√ß√£o.  Na realidade, existem duas possibilidades: <br><br>  1. Se um ponteiro for desreferenciado ap√≥s ser atribu√≠do, vencemos, porque um compilador pode remover uma atribui√ß√£o desnecess√°ria. <br><br>  2. Se um ponteiro √© desreferenciado antes de ser atribu√≠do, o padr√£o diz que ele √© UB e o comportamento pode ser qualquer, incluindo a chamada de uma fun√ß√£o arbitr√°ria.  Ou seja, chamar a fun√ß√£o PrintHello () n√£o contradiz o padr√£o. <br><br>  Ou seja, em qualquer caso, podemos atribuir algum valor n√£o nulo a um ponteiro n√£o inicializado e obter comportamento, de acordo com o padr√£o. <br><br><img src="https://habrastorage.org/webt/se/th/yx/sethyxxeoe2wjcy941i8nxzj4gm.jpeg"><br><br>  Quais s√£o as condi√ß√µes que tornam essa otimiza√ß√£o poss√≠vel?  Inicialmente, um programa deve conter um ponteiro global sem nenhum valor inicial ou com valor nulo (que √© o mesmo).  Em seguida, o programa deve conter uma atribui√ß√£o de um valor para esse ponteiro, em qualquer lugar, n√£o importa, antes da refer√™ncia ao ponteiro ou depois dele.  No exemplo acima, uma atribui√ß√£o ainda n√£o ocorreu, mas um compilador v√™ que a atribui√ß√£o existe. <br><br>  Se essas condi√ß√µes forem atendidas, um compilador pode remover a atribui√ß√£o e alter√°-la para o valor inicial do ponteiro. <br><br>  No c√≥digo fornecido, a vari√°vel Do √© um ponteiro para uma fun√ß√£o e possui o valor inicial nulo.  Quando tentamos chamar uma fun√ß√£o no ponteiro nulo, o comportamento do programa √© indefinido (comportamento indefinido, UB) e o compilador tem o direito de otimizar o UB conforme desejado.  Nesse caso, o compilador executou imediatamente a atribui√ß√£o Do = EraseAll. <br><br>  Por que isso acontece?  No restante do texto, LLVM e Clang vers√£o 5.0.0 s√£o usados ‚Äã‚Äãcomo compilador.  Exemplos de c√≥digo s√£o execut√°veis ‚Äã‚Äãpara voc√™ praticar. <br><br>  Para come√ßar, vejamos o c√≥digo IR ao otimizar com -O0 e -O1.  Vamos mudar um pouco o c√≥digo fonte para torn√°-lo menos dram√°tico: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdlib&gt; typedef int (*Function)(); static Function Do; static int PrintHello() { return printf("hello world\n"); } void NeverCalled() { Do = PrintHello; } int main() { return Do(); }</span></span></span></span></code> </pre> <br>  E compilamos o c√≥digo IR com -O0 (as informa√ß√µes de depura√ß√£o s√£o omitidas para maior clareza): <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'test.c'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"test.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:e-i64:64-f80:128-n8:16:32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-unknown-linux-gnu"</span></span> @Do = internal global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span> ; Function Attrs: noinline nounwind optnone uwtable define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: <span class="hljs-function"><span class="hljs-function">store </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i32</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitcast</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i32 ()* @PrintHello to i32 (...)*)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i32</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">** @Do, align 8 ret </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> } </span></span>; Function Attrs: noinline nounwind optnone uwtable define i32 @main() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %retval = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %retval, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">0</span></span> = load i32 (...)*, i32 (...)** @Do, align <span class="hljs-number"><span class="hljs-number">8</span></span> %call = call i32 (...) %<span class="hljs-number"><span class="hljs-number">0</span></span>() ret i32 %call } ; Function Attrs: noinline nounwind optnone uwtable define internal i32 @PrintHello() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %call = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">13</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8]* @.str, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>)) ret i32 %call } declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...) #<span class="hljs-number"><span class="hljs-number">1</span></span> And with -O1: ; ModuleID = <span class="hljs-string"><span class="hljs-string">'test.ll'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"test.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:e-i64:64-f80:128-n8:16:32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-unknown-linux-gnu"</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span> ; Function Attrs: noinline nounwind optnone uwtable define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> } ; Function Attrs: noinline nounwind optnone uwtable define i32 @main() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %retval = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %retval, align <span class="hljs-number"><span class="hljs-number">4</span></span> %call = call i32 (...) bitcast (i32 ()* @PrintHello to i32 (...)*)() ret i32 %call } ; Function Attrs: noinline nounwind optnone uwtable define internal i32 @PrintHello() unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %call = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">13</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8]* @.str, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>)) ret i32 %call } declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Se voc√™ compilar os execut√°veis, confirmar√° que, no primeiro caso, ocorre um erro de segmenta√ß√£o e, no segundo caso, ‚Äúhello world‚Äù √© exibido.  Com outras op√ß√µes de otimiza√ß√£o, o resultado √© o mesmo que para -O1. <br><br>  Agora encontre a parte do c√≥digo do compilador que executa essa otimiza√ß√£o.  A arquitetura do LLVM, o front-end, n√£o lida com otimiza√ß√µes em si, ou seja, o cfe (Clang Frontend) sempre gera o c√≥digo sem otimiza√ß√µes, que vemos na vers√£o para -O0, e todas as otimiza√ß√µes s√£o executadas pelo utilit√°rio opt: <br><br><img src="https://habrastorage.org/webt/1o/c9/vt/1oc9vtkgl4qt2yxundzkjso_u0w.jpeg"><br><br>  Com -O1, s√£o executados 186 passes de otimiza√ß√£o. <br><br>  Desligando os passes um ap√≥s o outro, encontramos o que estamos procurando: o passe <i>globalopt</i> .  Podemos deixar apenas esse passo de otimiza√ß√£o e garantir que ele e mais ningu√©m gere o c√≥digo de que precisamos.  A fonte est√° no arquivo /lib/Transforms/IPO/GlobalOpt.cpp.  Voc√™ pode ver o c√≥digo-fonte no reposit√≥rio LLVM.  Por uma quest√£o de brevidade, forneci apenas fun√ß√µes importantes para entender como ele funciona. <br><br><img src="https://habrastorage.org/webt/4k/-g/nl/4k-gnlzr7e6573zeobjdcp91x5q.jpeg"><br><br>  Esta imagem representa uma estrutura da representa√ß√£o IR.  Um c√≥digo na representa√ß√£o LLVM IR possui n√≠veis hier√°rquicos: um m√≥dulo representa o n√≠vel mais alto de uma hierarquia e inclui todas as fun√ß√µes e objetos globais, como vari√°veis ‚Äã‚Äãglobais.  Uma fun√ß√£o √© o n√≠vel mais importante de representa√ß√£o de RI e a maioria das passagens funciona nesse n√≠vel.  Um bloco b√°sico √© aquele que √© o conceito mais importante de uma teoria de compilador.  Um bloco b√°sico consiste em instru√ß√µes, que n√£o podem saltar do meio de um bloco b√°sico ou dentro de um bloco b√°sico.  Todas as transi√ß√µes entre blocos b√°sicos s√£o poss√≠veis apenas a partir do final de um bloco b√°sico e do in√≠cio de um bloco b√°sico, e quaisquer saltos de ou para o meio de um bloco b√°sico nunca s√£o poss√≠veis.  Um n√≠vel de instru√ß√£o representa uma instru√ß√£o de c√≥digo IR LLVM.  N√£o √© uma instru√ß√£o de processador, √© uma instru√ß√£o de uma m√°quina virtual muito generalizada com um n√∫mero infinito de registros. <br><br><img src="https://habrastorage.org/webt/6y/dt/wn/6ydtwn5hajletngggvj27uzurls.png"><br><br>  Esta imagem mostra uma hierarquia de passes do LLVM.  Nos passes √† esquerda, trabalhando no c√≥digo IR LLVM, s√£o mostrados os passes √† direita, trabalhando com as instru√ß√µes do alvo. <br><br>  Inicialmente, implementa o m√©todo runOnModule, ou seja, ao trabalhar, ele v√™ e otimiza todo o m√≥dulo (o que, √© claro, √© razo√°vel nesse caso).  A fun√ß√£o que executa a otimiza√ß√£o √© optimizeGlobalsInModule: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimizeGlobalsInModule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Module &amp;M, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DataLayout &amp;DL, TargetLibraryInfo *TLI, function_ref&lt;dominatortree&gt; LookupDomTree)</span></span></span><span class="hljs-function"> </span></span>{ SmallSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> comdat=<span class="hljs-string"><span class="hljs-string">"Comdat"</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>=<span class="hljs-string"><span class="hljs-string">"8"</span></span>&gt; NotDiscardableComdats; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Changed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> LocalChange = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (LocalChange) { LocalChange = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; NotDiscardableComdats.clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GlobalVariable &amp;GV : M.globals()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = GV.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GV.isDiscardableIfUnused() || !GV.use_empty()) NotDiscardableComdats.insert(C); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Function &amp;F : M) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = F.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!F.isDefTriviallyDead()) NotDiscardableComdats.insert(C); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (GlobalAlias &amp;GA : M.aliases()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = GA.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GA.isDiscardableIfUnused() || !GA.use_empty()) NotDiscardableComdats.insert(C); <span class="hljs-comment"><span class="hljs-comment">// Delete functions that are trivially dead, ccc -&gt; fastcc LocalChange |= OptimizeFunctions(M, TLI, LookupDomTree, NotDiscardableComdats); // Optimize global_ctors list. LocalChange |= optimizeGlobalCtorsList(M, [&amp;](Function *F) { return EvaluateStaticConstructor(F, DL, TLI); }); // Optimize non-address-taken globals. LocalChange |= OptimizeGlobalVars(M, TLI, LookupDomTree, NotDiscardableComdats); // Resolve aliases, when possible. LocalChange |= OptimizeGlobalAliases(M, NotDiscardableComdats); // Try to remove trivial global destructors if they are not removed // already. Function *CXAAtExitFn = FindCXAAtExit(M, TLI); if (CXAAtExitFn) LocalChange |= OptimizeEmptyGlobalCXXDtors(CXAAtExitFn); Changed |= LocalChange; } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Move all global ctors functions to the end of the module for code // layout. return Changed; }</span></span></code> </pre> <br>  Vamos tentar descrever em palavras o que essa fun√ß√£o faz.  Para cada vari√°vel global no m√≥dulo, ele solicita um objeto Comdat. <br><br>  O que √© um objeto Comdat? <br><br>  Uma se√ß√£o Comdat √© uma se√ß√£o no arquivo de objeto, na qual os objetos s√£o colocados, que podem ser duplicados em outros arquivos de objeto.  Cada objeto possui informa√ß√µes para o vinculador, indicando o que ele deve fazer quando s√£o detectadas duplicatas.  As op√ß√µes podem ser: Qualquer um - fa√ßa qualquer coisa, ExactMatch - duplicatas devem corresponder completamente, caso contr√°rio, ocorre um erro, Maior - pegue o objeto com o maior valor, NoDublicates - n√£o deve haver uma duplicata, SameSize - as duplicatas devem ter o mesmo tamanho, caso contr√°rio, ocorrer√° um erro. <br><br>  No LLVM, os dados do Comdat s√£o representados por uma enumera√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SelectionKind { Any, <span class="hljs-comment"><span class="hljs-comment">///&lt; The linker may choose any COMDAT. ExactMatch, ///&lt; The data referenced by the COMDAT must be the same. Largest, ///&lt; The linker will choose the largest COMDAT. NoDuplicates, ///&lt; No other Module may specify this COMDAT. SameSize, ///&lt; The data referenced by the COMDAT must be the same size. };</span></span></code> </pre> <br>  e a classe Comdat realmente representa um par (Nome, SelectionKind).  (De fato, tudo √© mais complicado.) Todas as vari√°veis ‚Äã‚Äãque por algum motivo n√£o podem ser exclu√≠das s√£o colocadas em um conjunto de NotDiscardableComdats.  Com fun√ß√µes e aliases globais, fazemos o mesmo - algo que n√£o pode ser exclu√≠do √© colocado em NotDiscardableComdats.  Em seguida, s√£o chamadas fun√ß√µes de otimiza√ß√£o separadas para construtores globais, fun√ß√µes globais, vari√°veis ‚Äã‚Äãglobais, aliases globais e destruidores globais.  As otimiza√ß√µes continuam no loop at√© que nenhuma otimiza√ß√£o seja executada.  A cada itera√ß√£o do loop, o conjunto de NotDiscardableComdats √© definido como zero. <br><br>  Vamos ver quais objetos do listado nossa fonte de teste cont√©m. <br><br>  Vari√°veis ‚Äã‚Äãglobais: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span> @Do = internal global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">2.</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  (um pouco mais adiante, posso dizer que a primeira vari√°vel ser√° exclu√≠da pelo otimizador na primeira itera√ß√£o). <br>  Fun√ß√µes: <br><br><pre> <code class="cpp hljs">define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() define i32 @main() define internal i32 @PrintHello() declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...)</code> </pre> <br>  Observe que printf √© declarado apenas, mas n√£o definido. <br><br>  N√£o h√° aliases globais. <br><br>  Vamos dar uma olhada no exemplo desse passo de otimiza√ß√£o e considerar como esse resultado foi gerado.  Obviamente, analisar todas as op√ß√µes de otimiza√ß√£o mesmo em uma passagem √© uma tarefa muito grande, pois envolve muitos casos especiais diferentes de otimiza√ß√µes.  Vamos nos concentrar em nosso exemplo, considerando as fun√ß√µes e estruturas de dados que s√£o importantes para entender o trabalho dessa passagem de otimiza√ß√£o. <br><br>  Inicialmente, o otimizador faz v√°rias verifica√ß√µes desinteressantes nesse caso e chama a fun√ß√£o processInternalGlobal, que tenta otimizar vari√°veis ‚Äã‚Äãglobais.  Essa fun√ß√£o tamb√©m √© bastante complexa e faz muitas coisas diferentes, mas estamos interessados ‚Äã‚Äãem uma coisa: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GS.StoredType == GlobalStatus::StoredOnce &amp;&amp; GS.StoredOnceValue) { ... <span class="hljs-comment"><span class="hljs-comment">// We are trying to optimize global variables, about which it is known that they are assigned a value only once, except the initializing value. if (optimizeOnceStoredGlobal(GV, GS.StoredOnceValue, GS.Ordering, DL, TLI)) return true; ... }</span></span></code> </pre> <br>  As informa√ß√µes √†s quais a vari√°vel global √© atribu√≠da ao valor um e apenas uma vez s√£o extra√≠das da estrutura GS (GlobalStatus).  Essa estrutura √© preenchida na fun√ß√£o de chamada: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processGlobal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GlobalValue &amp;GV, TargetLibraryInfo *TLI, function_ref&lt;dominatortree&gt; LookupDomTree)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV.getName().startswith(<span class="hljs-string"><span class="hljs-string">"llvm."</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; GlobalStatus GS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GlobalStatus::analyzeGlobal(&amp;GV, GS)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ...</code> </pre> <br>  Aqui vemos mais um fato interessante: objetos cujos nomes come√ßam com "llvm".  n√£o est√£o sujeitos √† otimiza√ß√£o (pois s√£o chamadas do sistema para o llvm runtime).  E, apenas no caso, os nomes das vari√°veis ‚Äã‚Äãno LLVM IR podem conter pontos (e at√© mesmo consistir em um ponto com o prefixo @ ou%).  A fun√ß√£o analyGlobal √© uma chamada para a API LLVM e n√£o consideraremos seu trabalho interno.  A estrutura do GlobalStatus deve ser exibida em detalhes, pois cont√©m informa√ß√µes muito importantes para passes de otimiza√ß√£o. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// As we analyze each global, keep track of some information about it. If we /// find out that the address of the global is taken, none of this info will be /// accurate. struct GlobalStatus { /// True if the global's address is used in a comparison. bool IsCompared = false; /// True if the global is ever loaded. If the global isn't ever loaded it /// can be deleted. bool IsLoaded = false; /// Keep track of what stores to the global look like. enum StoredType { /// There is no store to this global. It can thus be marked constant. NotStored, /// This global is stored to, but the only thing stored is the constant it /// was initialized with. This is only tracked for scalar globals. InitializerStored, /// This global is stored to, but only its initializer and one other value /// is ever stored to it. If this global isStoredOnce, we track the value /// stored to it in StoredOnceValue below. This is only tracked for scalar /// globals. StoredOnce, /// This global is stored to by multiple values or something else that we /// cannot track. Stored } StoredType = NotStored; /// If only one value (besides the initializer constant) is ever stored to /// this global, keep track of what value it is. Value *StoredOnceValue = nullptr; ... };</span></span></code> </pre> <br>  Vale a pena explicar por que "Se descobrirmos que o endere√ßo do global √© usado, nenhuma dessas informa√ß√µes ser√° precisa".  De fato, se pegarmos o endere√ßo de uma vari√°vel global e depois escrevermos algo nesse endere√ßo, n√£o pelo nome, ser√° extremamente dif√≠cil rastrear isso, e √© melhor deixar as vari√°veis ‚Äã‚Äãcomo est√£o, sem tentar otimizar . <br><br>  Assim, entramos na fun√ß√£o optimizeOnceStoredGlobal, para a qual a vari√°vel (GV) e o valor armazenado (StoredOnceVal) s√£o transmitidos.  Aqui est√£o elas: <br><br><pre> <code class="cpp hljs">@Do = internal unnamed_addr global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-comment"><span class="hljs-comment">// the variable i32 (...)* bitcast (i32 ()* @PrintHello to i32 (...)*) // the value</span></span></code> </pre> <br>  Em seguida, para o valor, o bitcast insignificante √© exclu√≠do e para a vari√°vel a seguinte condi√ß√£o √© verificada: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV-&gt;getInitializer()-&gt;getType()-&gt;isPointerTy() &amp;&amp; GV-&gt;getInitializer()-&gt;isNullValue()) { ...</code> </pre> <br>  isto √©, a vari√°vel deve ser inicializada com um ponteiro nulo.  Se for esse o caso, criamos uma nova vari√°vel SOVC correspondente ao valor da convers√£o StoredOnceVal para o tipo GV: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Constant *SOVC = dyn_cast&lt;constant&gt;(StoredOnceVal)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV-&gt;getInitializer()-&gt;getType() != SOVC-&gt;getType()) SOVC = ConstantExpr::getBitCast(SOVC, GV-&gt;getInitializer()-&gt;getType());</code> </pre> <br>  Aqui, getBitCast √© o m√©todo que retorna o comando bitcast, que digita os tipos na linguagem LLVM IR. <br><br>  Depois disso, a fun√ß√£o OptimizeAwayTrappingUsesOfLoads √© chamada.  Transfere a vari√°vel global GV e a constante LV. <br><br>  A otimiza√ß√£o direta √© realizada pela fun√ß√£o OptimizeAwayTrappingUsesOfValue (Valor * V, Constante * NovoV). <br><br>  Para cada uso de uma vari√°vel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> UI = V-&gt;user_begin(), E = V-&gt;user_end(); UI != E; ) { Instruction *I = cast&lt;instruction&gt;(*UI++);</code> </pre> <br>  se este for um comando Load, substitua seu operando por um novo valor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LoadInst *LI = dyn_cast&lt;loadinst&gt;(I)) { LI-&gt;setOperand(<span class="hljs-number"><span class="hljs-number">0</span></span>, NewV); Changed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Se a vari√°vel for usada na chamada ou invoca√ß√£o da fun√ß√£o (que √© exatamente o que acontece em nosso exemplo), crie uma nova fun√ß√£o, substituindo seu argumento por um novo valor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isa&lt;callinst&gt;(I) || isa&lt;invokeinst&gt;(I)) { <span class="hljs-function"><span class="hljs-function">CallSite </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CS.getCalledValue() == V) { <span class="hljs-comment"><span class="hljs-comment">// Calling through the pointer! Turn into a direct call, but be careful // that the pointer is not also being passed as an argument. CS.setCalledFunction(NewV); Changed = true; bool PassedAsArg = false; for (unsigned i = 0, e = CS.arg_size(); i != e; ++i) if (CS.getArgument(i) == V) { PassedAsArg = true; CS.setArgument(i, NewV); }</span></span></code> </pre> <br>  Todos os outros argumentos para a fun√ß√£o s√£o simplesmente copiados. <br><br>  Al√©m disso, algoritmos de substitui√ß√£o semelhantes s√£o fornecidos para as instru√ß√µes de transmiss√£o e GEP, mas, no nosso caso, isso n√£o acontece. <br><br>  As a√ß√µes adicionais s√£o as seguintes: examinamos todos os usos de uma vari√°vel global, tentando excluir tudo, exceto a atribui√ß√£o de valor.  Se isso der certo, podemos excluir a vari√°vel Do. <br><br>  Assim, revisamos brevemente o trabalho do passe de otimiza√ß√£o LLVM em um exemplo espec√≠fico.  Em princ√≠pio, nada de super complicado est√° aqui, mas √© necess√°ria uma programa√ß√£o mais cuidadosa para fornecer todas as combina√ß√µes poss√≠veis de comandos e tipos de vari√°veis.  Obviamente, tudo isso deve ser coberto por testes.  Aprender o c√≥digo fonte dos otimizadores LLVM ajudar√° voc√™ a escrever suas otimiza√ß√µes, permitindo melhorar o c√≥digo para alguns casos espec√≠ficos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458442/">https://habr.com/ru/post/pt458442/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458428/index.html">Google abre o c√≥digo-fonte do analisador robots.txt</a></li>
<li><a href="../pt458432/index.html">Combinando v√°rios pacotes em um √∫nico espa√ßo para nome Python</a></li>
<li><a href="../pt458434/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 11. No√ß√µes b√°sicas de VLAN</a></li>
<li><a href="../pt458436/index.html">Erros de log comuns</a></li>
<li><a href="../pt458440/index.html">Suporte t√©cnico durante a semana: hist√≥rias sobre o que acontece quando voc√™ n√£o consegue alcan√ßar o usu√°rio</a></li>
<li><a href="../pt458444/index.html">Internet para o residente de ver√£o. Parte 4. Um cart√£o SIM √© suficiente</a></li>
<li><a href="../pt458446/index.html">Centros de dados em escala de hiperescala: quem os constr√≥i e quanto custam</a></li>
<li><a href="../pt458452/index.html">Como fazer uma cozinha de escrit√≥rio atrav√©s de uma abordagem de supermercado</a></li>
<li><a href="../pt458454/index.html">Alexey Savvateev: Modelos de Internet e redes sociais</a></li>
<li><a href="../pt458458/index.html">C√¢meras de profundidade - revolu√ß√£o silenciosa (quando os rob√¥s ver√£o) Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>