<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏴󠁧󠁢󠁳󠁣󠁴󠁿 🦈 👬 كيف ولماذا لسرقة الأشجار في بوابة 💔 ☝🏾 🏇🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="سأتحدث في هذه المقالة عن خدعة واحدة مفيدة ولكنها غير معروفة للعمل مع git - كيفية إنشاء التزام بسهولة باستخدام شجرة من التزام آخر. ببساطة ، كيفية الحصو...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>كيف ولماذا لسرقة الأشجار في بوابة</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433748/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><img src="https://habrastorage.org/webt/gu/kk/lu/gukklu2hqqy4qrjdnixfkmligiq.jpeg" alt="أشجار"></a> </p><br><p style=";text-align:right;direction:rtl">  سأتحدث في هذه المقالة عن خدعة واحدة مفيدة ولكنها غير معروفة للعمل مع git - كيفية إنشاء التزام بسهولة باستخدام شجرة من التزام آخر.  ببساطة ، كيفية الحصول على الحالة المطلوبة للمشروع على أي فرع ، إذا كانت هذه الحالة موجودة بالفعل في مكان ما وفي مكان ما في المستودع من قبل.  سيتم تقديم عدة أمثلة حول كيفية قيام ذلك بحل بعض المشكلات العملية بأناقة.  وعلى وجه الخصوص ، سأتحدث عن الطريقة التي وجدتها ، والتي يمكن أن تبسط بشكل كبير تصحيح تعارضات متعددة أثناء rebase.  بالإضافة إلى ذلك ، تعتبر هذه المقالة طريقة رائعة لفهم ما يشكل التزامًا في الممارسة العملية. </p><a name="habracut"></a><br><h3 id="soderzhanie" style=";text-align:right;direction:rtl">  <strong>المحتويات</strong> </h3><br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء النظري.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">حول يرتكب والأشجار</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بوابة الالتزام شجرة</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء العملي</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">1. التزامن مع فرع آخر</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">2. مقارنة بين فرعين</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">3. فرع عكس</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">4. عكس جزئي</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">5. دمج الاصطناعي</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">6 أ.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Rebase طريقة عبر دمج - الوصف</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">6 ب.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Rebase طريقة عبر دمج - النصي</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">7. الاسم المستعار</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الخاتمة</a> </p><br><a name="theory"></a><br><h3 id="teoreticheskaya-chast-pro-kommity-i-derevya" style=";text-align:right;direction:rtl">  <strong>الجزء النظري.</strong>  <strong>حول يرتكب والأشجار</strong> </h3><br><p style=";text-align:right;direction:rtl">  ربما يكون الالتزام هو المفهوم الأساسي في git ، دعنا نرى ما الذي يتكون منه.  لكل التزام معرف فريد خاص به في شكل علامة تجزئة ، على سبيل المثال <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">5e45ecb</a></strong> .  ومع الأمر التالي ، ومعرفة التجزئة ، يمكننا أن نرى محتوياته. </p><br><pre style=";text-align:right;direction:rtl"><code class="bash hljs">git cat-file -p 5e45ecb</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">tree 8640790949c12690fc71f9abadd7b57ec0539376 parent 930741d1f5fd2a78258aa1999bb4be897ba3d015 author Mark Tareshawty &lt;tareby...@github.com&gt; 1542718283 -0500 committer Mark Tareshawty &lt;tareby...@github.com&gt; 1542718283 -0500 gpgsig -----BEGIN PGP SIGNATURE----- ... -----END PGP SIGNATURE----- Fix scoping so that we don't break the naming convention</code> </pre> <br><p style=";text-align:right;direction:rtl">  هذه الأسطر القليلة هي محتويات الالتزام: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  شجرة - رابط إلى حالة مشروع معين </li><li style=";text-align:right;direction:rtl">  الوالد - رابط الالتزام الوالد </li><li style=";text-align:right;direction:rtl">  مؤلف - مؤلف الالتزام الأصلي + التاريخ </li><li style=";text-align:right;direction:rtl">  committer - خالق هذا الالتزام + التاريخ </li><li style=";text-align:right;direction:rtl">  gpgsig - التوقيع الرقمي (إن وجد) </li><li style=";text-align:right;direction:rtl">  رسالة - نص الالتزام </li></ul><br><p style=";text-align:right;direction:rtl">  اسمحوا لي أن أذكرك أن الالتزام في بوابة (على عكس VCS) لا يصف التغييرات التي تم إجراؤها.  إنه عكس ذلك: يصف كل التزام الحالة المحددة للمشروع ككل ، وما نراه على أنه التغييرات التي يتم إجراؤها هو في الواقع فرق محسوب ديناميكيًا مقارنة بالحالة السابقة.  تجدر الإشارة أيضًا إلى أن جميع الالتزامات غير قابلة للتغيير (غير قابلة للتغيير) ، أي على سبيل المثال ، مع rebase / cherry-pick / edit ، يتم إنشاء تعهدات جديدة تمامًا. </p><br><p style=";text-align:right;direction:rtl">  شجرة (شجرة) - في الواقع ، هو مجرد مجلد مع محتوى ثابت غير قابل للتغيير.  يحتوي كائن شجرة النوع على قائمة بالملفات ذات المحتويات المحددة (النقط) والمجلدات الفرعية (الأشجار).  والشجرة التي يرتكبها كل طرف هي المجلد الجذر للمشروع ، أو بالأحرى حالته الخاصة. </p><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">عرض محتويات الشجرة</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  يمكن أن يتم ذلك بنفس الطريقة تمامًا لأي كائن آخر (الالتزام / الشجرة / النقطة) ، ويكفي أن تأخذ الأحرف الأولى القليلة المميزة: 8640790949c12690fc71f9abadd7b57ec0539376 -&gt; 8640790. </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git cat-file -p 8640790</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">100644 blob 7ab08294a46f158c51460be3e7df6a190e15023b .env.example 100644 blob 0a1a4d1ad9ff3f35b67678ca893811e91b423af5 .gemset 040000 tree 033aa38ce0eab11fe229067c14ccce95e2b8b601 .github 100644 blob ca49bb7ffa6273b0be4ce7ba1accba456032fb11 .gitignore 100644 blob c99d2e7396e14ac072c63ec8419d9b8fede28d86 .rspec 100644 blob 65e77a2f59f635a8f24eb4714e8e43745c5c0eb9 .rubocop.yml 100644 blob 8e8299dcc068356889b365e23c948b92c6dfcd78 .ruby-version 100644 blob 19028f9885948aca2ba61f9d062e9dc21c21ad03 .stylelintrc.json 100644 blob 2f7a032fbc3f4f7195bfd91cb33889a684b572b9 .travis.yml 100644 blob 121615722a6c206a9fe24b9a1c9b647662a460d2 ARCHITECTURE.md 100644 blob 898195daeea0bbf8c5930deeaf1020ba8abab34a Gemfile 100644 blob de7ca707f9fe9172db941b65cdacaba7e024fc06 Gemfile.lock 100644 blob e6ff62fefd071b1a8ca279bae94ddbc4dd17b7a3 Gruntfile.js 100644 blob 0cac5b30fb32d36cce2aeb7d936be7b6207d68c7 MIT-LICENSE.txt 100644 blob c2c566e8cc3d440d3ee8041b79cded416db28136 Procfile 100644 blob d1fb2f575380e1e093a4d82e3f19e51f0b99a0a1 Procfile.dev 100644 blob 3a88e138f10fa65bd2cfe1a1d3292348205508b5 README.md 100644 blob 5366e6e073cc426518894cc379d3a07cf3c9cfb3 Rakefile 100644 blob e6d3d2d3e9d5122c5f75bbeee8ed0917ad38c131 app.json 040000 tree 94f83cf03bd6f1cf14672034877b14604744b7a2 app 040000 tree d4d859e82564250b4c4f2047de21e089e7555475 bin 100644 blob 1f71007621f17334fd6f2dd71c87b7a16867119c config.ru 040000 tree 9e8e4bf5ec44541aefff544672b94ca8a9d07bbf config 040000 tree 31b8d0e1fa2bb789dbd6319e04fc9f115952cf2a db 040000 tree 38e7a13e0e772c2a13e46d2007e239f679045bee doc 040000 tree a6e35ded8b35837660cf786e637912377f845515 lib 040000 tree d564d0bc3dd917926892c55e3706cc116d5b165e <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> 100644 blob 843523565ddee5e00f580d9c4e37fc2478fdaecc package-lock.json 100644 blob 791ee833ad316d75b1d2c83a64a3053fc952d254 package.json 040000 tree 4645317c52675d9889f89b26f4dd4d2ae1d8cbad public 040000 tree 31d3f8ae4a4ffe62787134642743ed32a35dbae2 resources 040000 tree 807ffa29868ef9c25ddb4b4126a4bb7f1b041bf0 script 040000 tree 4c3bf9a7f3679ba059b0f1c214a500d197546462 spec 040000 tree 136c8174412345531a9542cafef25ce558d2664f <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> 040000 tree e6524eafe066819e4181bc56c503320548d8009b vendor</code> </pre> </div></div><br><p style=";text-align:right;direction:rtl">  هذه هي في الحقيقة أهم ميزة لكيفية عمل git ، معرف الالتزام هو في الحقيقة جزء من محتوياته.  تماما مثل تجزئة الكائنات المضمنة فيه (الأشجار ، النقط). </p><br><p style=";text-align:right;direction:rtl">  الآن دعونا نرى ما يحدث عندما نفعل </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git commit -m <span class="hljs-string"><span class="hljs-string">"Fixed bug"</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  ينشئ هذا الأمر التزامًا جديدًا يلتقط ما يلي: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  حالة مشروع التدريج (تم حفظه ككائن شجرة جديد والتجزئة الخاصة به) </li><li style=";text-align:right;direction:rtl">  الارتباط الحالي (الأصل) الالتزام </li><li style=";text-align:right;direction:rtl">  المؤلف + المرسل + تاريخان </li><li style=";text-align:right;direction:rtl">  ارتكاب النص </li></ul><br><p style=";text-align:right;direction:rtl">  يتم حفظ كل هذا ، تجزئة ، ويتم الحصول على كائن التزام جديد.  ويقوم الفريق تلقائيًا برفع مؤشر الفرع الحالي إليه. </p><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">قليلا عن المصطلحات</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  كما نعلم بالفعل ، الشجرة هي كائن يحتوي على حالة المشروع في مرحلة معينة في الماضي - عندما تم إنشاء التزام باستخدام هذه الشجرة. </p><br><p style=";text-align:right;direction:rtl">  يسمى مجلد العمل دليل العمل / نسخة العمل / الشجرة ، وهو منطقي تمامًا. </p><br><p style=";text-align:right;direction:rtl">  لدينا أيضا - منطقة التدريج / مؤشر - مجال التغييرات المعدة.  <strong>ولكن من الناحية المنطقية ، هذه أيضًا شجرة</strong> ، أو بالأحرى ، الحالة التي يتم حفظها عند ارتكابها كشجرة.  لذلك ، يبدو لي أنه سيكون من المنطقي أكثر استدعاء شجرة مرحلية. </p></div></div><br><a name="commit-tree"></a><br><h3 id="git-commit-tree" style=";text-align:right;direction:rtl">  <strong>بوابة الالتزام شجرة</strong> </h3><br><p style=";text-align:right;direction:rtl">  أخيرًا ، يمكننا أن ننتقل إلى وصف أمر <strong>الالتزام - git</strong> الذي نحتاجه.  من الناحية الرسمية ، هذا هو أحد الأوامر ذات المستوى المنخفض ، لذلك نادراً ما يتم ذكره واستخدامه.  لن نأخذ في الاعتبار الأوامر الأخرى ذات المستوى المنخفض المرتبطة بها (مثل git-tree-git-update-index ، فهي تعرف أيضًا باسم أوامر السباكة).  نحن مهتمون فقط بنتيجة معينة: من خلال هذا الأمر ، يمكننا بسهولة نسخ (إعادة استخدام) شجرة حالة المشروع من أي التزام آخر. </p><br><p style=";text-align:right;direction:rtl">  انظروا الى تحديها </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git commit-tree 4c835c2 -m <span class="hljs-string"><span class="hljs-string">"Fixed bug"</span></span> -p a8fc5e3</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">d9aded78bf57ca906322e26883644f5f36cfdca5</code> </pre> <br><p style=";text-align:right;direction:rtl">  يتم تنفيذ الأمر git ارتكاب الشجرة أيضًا ، ولكن بطريقة منخفضة المستوى.  هنا يجب أن تحدد بشكل صريح الشجرة الحالية (الشجرة) 4c835c2 ورابطًا إلى الوالد الالتزام a8fc5e3.  وتقوم بإرجاع تجزئة الالتزام الجديد d9aded7 ، ولا يتغير وضع الفرع (لذلك ، يبدو أن هذا الالتزام يتجمد في الهواء). </p><br><a name="practice"></a><br><h3 id="prakticheskaya-chast" style=";text-align:right;direction:rtl">  <strong>الجزء العملي</strong> </h3><br><p style=";text-align:right;direction:rtl">  يتم عرض أمثلة على استخدام هذا الأمر في مستودع التخزين البسيط التالي. </p><br><img src="https://habrastorage.org/webt/ft/ot/to/ftottogtrm5xmyiqmbz1_loijuy.png"><br><p style=";text-align:right;direction:rtl">  يحتوي على ثلاثة فروع: </p><br><p style=";text-align:right;direction:rtl">  سيد - الفرع الرئيسي <br>  ألفا - الفرع الذي نعمل ونعمل عليه <br>  بيتا - فرع تم إيقافه سابقًا في برنامج الماجستير </p><br><p style=";text-align:right;direction:rtl">  من السهل تكرار جميع الإجراءات محليًا ، لذلك يكفي استنساخ المستودع ، والحصول على فرع ألفا ، ثم تنفيذ الأوامر من الأمثلة.  هذه الحالة الأولية مشتركة بين جميع الأمثلة. </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/capslocky/git-commit-tree-example.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ./git-commit-tree-example/ git checkout alpha</code> </pre> <br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">تحت النوافذ</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  جميع الأوامر ، بما في ذلك البرنامج النصي ، تعمل أيضًا تحت النوافذ.  تحتاج فقط إلى فتح محطة bash في مجلد المشروع ، على سبيل المثال ، مثل هذا </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">"C:\Program Files\Git\git-bash.exe" --cd="D:\path\project"</code> </pre> </div></div><br><a name="z1"></a><br><h3 id="1-sinhronizaciya-s-drugoy-vetkoy" style=";text-align:right;direction:rtl">  <strong>1. التزامن مع فرع آخر</strong> </h3><br><p style=";text-align:right;direction:rtl">  التحدي: <br>  مزامنة حالة المشروع على فرع <strong>ألفا</strong> مع فرع <strong>بيتا</strong> .  أي أنك تحتاج إلى إنشاء مثل هذا الالتزام الجديد على فرع <strong>ألفا</strong> بحيث تصبح حالة المشروع تمامًا كما في فرع <strong>بيتا</strong> . </p><br><p style=";text-align:right;direction:rtl">  على وجه التحديد ، من غير المحتمل أن تنشأ مثل هذه المهمة على الإطلاق ، ولكن هذه هي الحالة الأنسب لإظهار النهج. </p><br><p style=";text-align:right;direction:rtl">  إن أبسط الحلول هو أخذ الشجرة الموجودة التي يشير إليها فرع بيتا والإشارة إليها من الالتزام الجديد لفرع ألفا.  نظرًا لأن هذا هو المثال الأول ، يتم اعتبار كل منطقه بتفاصيل كافية. </p><br><p style=";text-align:right;direction:rtl">  أولاً ، ابحث عن تجزئة الالتزام التي أشار إليها فرع بيتا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git rev-parse origin/beta</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">280c30ff81a574f8dd41721726cf60b22fb2eced</code> </pre> <br><p style=";text-align:right;direction:rtl">  <strong>280c30f</strong> - فقط خذ الأحرف القليلة الأولى </p><br><p style=";text-align:right;direction:rtl">  الآن يمكنك العثور على علامة التجزئة الخاصة بشجرتها من خلال عرض محتويات الالتزام من خلال ملف cat git: </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git cat-file -p 280c30f</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">tree 3c1afe75f54518dbd82ea7a4e3c4ff50389a573a &lt;--- parent 560b449675513bc8f8f4d6cda56a922d4e36917a author Baur &lt;atanov...@gmail.com&gt; 1540619512 +0600 committer Baur &lt;atanov...@gmail.com&gt; 1540619512 +0600 Added info about windows</code> </pre> <br><p style=";text-align:right;direction:rtl">  <strong>3c1afe7</strong> - هذه هي الشجرة التي نحتاجها </p><br><p style=";text-align:right;direction:rtl">  والآن سننشئ التزامًا يشير إلى هذه الشجرة ، ومع الالتزام الوالد سنشير إلى الالتزام الحالي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git commit-tree 3c1afe7 -m <span class="hljs-string"><span class="hljs-string">"Synced with branch 'beta'"</span></span> -p HEAD</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">eb804d403d4ec0dbeee36aa09da706052a7cc687</code> </pre> <br><p style=";text-align:right;direction:rtl">  هذا كل شيء ، تم إنشاء الالتزام ، وحصل الفريق على التجزئة.  علاوة على ذلك ، ستظل هذه القيمة فريدة من نوعها دائمًا ، حيث يتم حسابها ليس فقط من الشجرة ، ولكن أيضًا من المؤلف والوقت.  يتم تجميد الالتزام نفسه في الهواء ، طالما أنه لا يدخل أي من الفروع.  يكفي أن نأخذ الأحرف القليلة الأولى: <strong>eb804d4</strong> ، هذه <strong>القيمة</strong> ، الفريدة لكل حالة ، سأقوم بتعيينها <strong>كسكسكسكسكسكس</strong> .  دعنا ننظر إلى محتوياته: </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git cat-file -p xxxxxxx</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">tree 3c1afe75f54518dbd82ea7a4e3c4ff50389a573a &lt;--- parent 64fafc79e8f6d22f5226490daa5023062299fd6c author Peter &lt;peter...@gmail.com&gt; 1545230299 +0600 committer Peter &lt;peter...@gmail.com&gt; 1545230299 +0600 Synced with branch 'beta'</code> </pre> <br><p style=";text-align:right;direction:rtl">  عظيم ، لديه نفس الشجرة مثل الالتزام على فرع الأصل / بيتا.  ولأن هذا الالتزام هو سليل مباشر للفرع الحالي ، لإدراجه في الفرع ، ما عليك سوى دمج دمج سريع للأمام </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git merge --ff xxxxxxx</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">Updating 64fafc7..xxxxxxx Fast-forward Azure.txt | 3 --- Bill.txt | 6 +----- Linus.txt | 15 +++++++++++++++ 3 files changed, 16 insertions(+), 8 deletions(-)</code> </pre> <br><p style=";text-align:right;direction:rtl">  تم  الآن حالة المشروع على فرع ألفا هو نفسه تمامًا كما هو الحال في فرع بيتا.  <strong>[تحديث]</strong> وإذا نظرت إلى حقيقة أن هذا الالتزام قد تغير ، فسنرى: أنه عكس جميع التزامات فرع ألفا (التغييرات) وأضاف جميع التزامات بيتا الفريدة (التغييرات) إلى سلف الالتزام المشترك. </p><br><img src="https://habrastorage.org/webt/6r/cp/9j/6rcp9jjsridsnn297yjyhaa3e-e.png"><br><a name="z2"></a><br><h3 id="2-sravnenie-dvuh-vetok" style=";text-align:right;direction:rtl">  <strong>2. مقارنة بين فرعين</strong> </h3><br><p style=";text-align:right;direction:rtl">  التحدي: <br>  مقارنة فرع <strong>ألفا</strong> مع فرع <strong>بيتا</strong> . </p><br><p style=";text-align:right;direction:rtl">  يوضح المثال الأول أن الالتزام الذي تم إنشاؤه يعرض جميع تلك التغييرات التي تمثل الفرق الفعلي بين الفرعين.  هذه الخاصية تجعل من السهل مقارنة فرع واحد بآخر.  يكفي إنشاء فرع مؤقت ثالث والتزام مماثل فيه. </p><br><p style=";text-align:right;direction:rtl">  لذا ، أولاً ، أعد فرع ألفا إلى حالته الأصلية </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git reset --hard origin/alpha</code> </pre> <br><p style=";text-align:right;direction:rtl">  دعونا إنشاء فرع مؤقت على الفرع الحالي والوقوف عليه </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git checkout -b temp</code> </pre> <br><p style=";text-align:right;direction:rtl">  وتركنا أن نفعل الشيء نفسه كما في المثال السابق.  ولكن هذه المرة سنلتقي سطر واحد.  للقيام بذلك ، نستخدم بناء الجملة الخاص للوصول إلى <strong>أصل</strong> شجرة الالتزام <strong>/ بيتا ^ {شجرة}</strong> أو نفس <strong>280c30f ^ {شجرة}</strong> . </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git merge --ff $(git commit-tree origin/beta^{tree} -m <span class="hljs-string"><span class="hljs-string">"Diff with branch 'beta'"</span></span> -p HEAD)</code> </pre> <br><p style=";text-align:right;direction:rtl">  فعلت ، ونحن أساسا تجسدت بمثابة فرق بين فرعين </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git show</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git diff alpha origin/beta</code> </pre> <br><p style=";text-align:right;direction:rtl">  بالطبع ، يمكننا إنشاء مثل هذا الالتزام "المقارن" لأي التزامين (حالات) في المستودع. </p><br><img src="https://habrastorage.org/webt/bd/eq/nt/bdeqntgdkpows5ly0zc7ahzjgf8.png"><br><a name="z3"></a><br><h3 id="3-revert-vetki" style=";text-align:right;direction:rtl">  <strong>3. فرع عكس</strong> </h3><br><p style=";text-align:right;direction:rtl">  التحدي: <br>  دحر الإلتزامات القليلة الماضية. </p><br><p style=";text-align:right;direction:rtl">  دعنا نعود إلى فرع ألفا وحذف فرع مؤقت </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git checkout alpha git branch -D temp</code> </pre> <br><p style=";text-align:right;direction:rtl">  لنفترض أننا نحتاج إلى استعادة آخر إعدامات في فرع ألفا.  هناك طريقتان تقليديتان للقيام بذلك: </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تشغيل بوابة العودة مرتين - لكل التزام </li><li style=";text-align:right;direction:rtl">  git reset ، أي إعادة تعيين موضع الفرع </li></ol><br><p style=";text-align:right;direction:rtl">  ولكن يمكنك القيام بذلك بطريقة ثالثة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git merge --ff $(git commit-tree 7a714bf^{tree} -m <span class="hljs-string"><span class="hljs-string">"Reverted to commit 7a714bf"</span></span> -p HEAD)</code> </pre> <br><p style=";text-align:right;direction:rtl">  سيؤدي ذلك إلى إضافة التزام جديد واحد يسترجع التغييرات في الالتزامين السابقين.  على عكس الطريقة الأولى ، يتم إنشاء التزام واحد فقط ، حتى إذا كنت بحاجة إلى استعادة آخر عشر تعهدات.  والفرق بين الأسلوب مع git reset هو أننا لا نرمي هذه الالتزامات من الفرع نفسه. </p><br><p style=";text-align:right;direction:rtl">  علاوة على ذلك ، إذا كنت بحاجة إلى إعادة الحالة الأصلية للفرع ، فيمكن القيام بذلك بطريقة مماثلة </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git merge --ff $(git commit-tree 64fafc7^{tree} -m <span class="hljs-string"><span class="hljs-string">"Reverted back to commit 64fafc7"</span></span> -p HEAD)</code> </pre> <br><p style=";text-align:right;direction:rtl">  في الوقت نفسه ، سيبقى هذان الالتزامان في تاريخ الفرع ، والذي سيتبين أنه تم إرجاعه وإعادته. </p><br><img src="https://habrastorage.org/webt/2a/w_/g_/2aw_g_0m9m2vf8zs9sqh_c4ozw8.png"><br><a name="z4"></a><br><h3 id="4-chastichnyy-revert" style=";text-align:right;direction:rtl">  <strong>4. عكس جزئي</strong> </h3><br><p style=";text-align:right;direction:rtl">  التحدي: <br>  استرجع التغييرات التي أجريت على بعض الملفات خلال آخر بضع مرات. </p><br><p style=";text-align:right;direction:rtl">  مرة أخرى ، أعد فرع ألفا إلى حالته الأصلية </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git reset --hard origin/alpha</code> </pre> <br><p style=";text-align:right;direction:rtl">  يحتوي فرع ألفا على 3 تعهدات ، يتم إجراء تغييرات في كل منها على ملف Bill.txt ، وفي الالتزام الأخير ، تتم إضافة ملف Azure.txt أيضًا.  لنفترض أننا نحتاج إلى استعادة التغييرات التي تم إجراؤها على ملف Bill.txt الخاص بعمليتي الاستخدام الأخيرتين ، دون لمس أي ملفات أخرى. </p><br><p style=";text-align:right;direction:rtl">  أولاً ، استرجع جميع الملفات 2 </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git merge --ff $(git commit-tree 7a714bf^{tree} -m <span class="hljs-string"><span class="hljs-string">"any text"</span></span> -p HEAD)</code> </pre> <br><p style=";text-align:right;direction:rtl">  بعد ذلك ، أعد الفرع إلى الالتزام السابق ، ولكن دون لمس حالة المشروع على القرص </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git reset HEAD~1</code> </pre> <br><p style=";text-align:right;direction:rtl">  والآن يكفي رفع الملفات الضرورية والالتزام بها ، ويمكن تجاهل التغييرات الأخرى. </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git add Bill.txt git commit -m <span class="hljs-string"><span class="hljs-string">"Reverted file Bill.txt to 7a714bf"</span></span> git reset --hard HEAD</code> </pre> <br><img src="https://habrastorage.org/webt/0p/8g/yy/0p8gyybuacise2ffx4qka3relhw.png"><br><a name="z5"></a><br><h3 id="5-iskustvennyy-merge" style=";text-align:right;direction:rtl">  <strong>5. دمج الاصطناعي</strong> </h3><br><p style=";text-align:right;direction:rtl">  التحدي: <br>  رفع فرع واحد إلى آخر ، والحصول على نتيجة محددة سلفا. </p><br><p style=";text-align:right;direction:rtl">  تخيل هذا الموقف.  تم اكتشاف خطأ حرج في الإنتاج ، وكما هو معتاد ، يجب إصلاحه بشكل عاجل.  ومع ذلك ، ليس من الواضح كم من الوقت سيستغرق لدراسته وإجراء الإصلاح الصحيح ، لذلك تم إجراء إصلاح عاجل مؤقت بسرعة ، مما عزل التفاعل مع الوحدة النمطية للمشكلة.  لذلك ، في الفرع الرئيسي ، يظهر الالتزام باستخدام هذا التصحيح المؤقت ، وبعد مرور بعض الوقت بدلاً من ذلك بشكل رئيسي ، تحتاج إلى إيقاف إصلاح عاجل كامل بالفعل. </p><br><p style=";text-align:right;direction:rtl">  وبالتالي ، نحن بحاجة إلى دمج دمج فرع ألفا في الرئيسي ، ولكن لا ينبغي أن يكون هذا دمجًا تقليديًا عندما تتم إضافة جميع التغييرات الفريدة من فرع ألفا إلى المعلم من أعلى ويكون هناك تعارض ، ويجب علينا استبدال المعلم بالكامل بفرع ألفا. </p><br><p style=";text-align:right;direction:rtl">  بادئ ذي بدء ، دعنا نتذكر ما يدور حوله أمر الدمج - إنه في الواقع نفس الالتزام العادي ، لكن لديه فقط إثنين من الوالدين ، يكون هذا مرئيًا بوضوح إذا نظرت إلى محتوياته (كيف تتشكل شجرة الشجرة مشكلة منفصلة) .  ومن الذي يحدده من هو بسيط - يعتبر الوالد الأول الالتزام الرئيسي. </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">git cat-file -p 7229df8</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">tree 3c1afe75f54518dbd82ea7a4e3c4ff50389a573a parent fd54ab7dde87593b9892b6d1ffbf1afd39ba6f9e parent 280c30ff81a574f8dd41721726cf60b22fb2eced author Baur &lt;atanov...@gmail.com&gt; 1540619579 +0600 committer Baur &lt;atanov...@gmail.com&gt; 1540619592 +0600 Merge branch <span class="hljs-string"><span class="hljs-string">'beta'</span></span> into <span class="hljs-string"><span class="hljs-string">'master'</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  إعادة تعيين فرع ألفا الحالي والتبديل إلى الرئيسي </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git reset --hard origin/alpha git checkout master</code> </pre> <br><p style=";text-align:right;direction:rtl">  والآن نفس الفريق ، ولكن مع <strong>اثنين من</strong> الوالدين يلتزم </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git merge --ff $(git commit-tree alpha^{tree} -m <span class="hljs-string"><span class="hljs-string">"Merge 'alpha' into 'master', but take 'alpha' tree"</span></span> -p HEAD -p alpha)</code> </pre> <br><p style=";text-align:right;direction:rtl">  انتهى الأمر ، لقد نظمنا فرع ألفا في الرئيسي ، ولم يكن علينا حذف الشفرة المؤقتة وحل التعارضات ، لأنه في هذه الحالة كان علينا فقط إعادة كتابة آخر التغييرات. </p><br><img src="https://habrastorage.org/webt/y3/qa/p_/y3qap_rct5emnkmqfirrhtmhmlg.png"><br><p style=";text-align:right;direction:rtl">  في الواقع ، ليس غريباً إنشاء دمج مع شجرة يتم نسخه من التزام آخر.  يمكن أن تنشأ مثل هذه المواقف لأن git هي أداة مرنة للغاية تتيح لك تنفيذ مجموعة متنوعة من الأساليب للتعامل مع الفروع والمستودعات.  ومع ذلك ، فإن المثال الأكثر شيوعًا كان في مستودعنا منذ البداية - حاول تحليله بنفسك أو افتح المفسد لقراءة التفسير. </p><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">المفسد</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  دعنا ننتبه إلى كيفية خنق فرع بيتا لإتقانه.  خلال الوقت الذي ظهر فيه التزامان ، لم تكن هناك تعهدات جديدة في الفرع الرئيسي نفسه.  هذا يعني أنه مع دمج النسخة التجريبية في برنامج الماجستير ، يتم استبعاد أي تعارض بسبب التغييرات المتزامنة. </p><br><img src="https://habrastorage.org/webt/ld/b2/9c/ldb29c4suiipfkkwc4qmozqxc9i.png"><br><img src="https://habrastorage.org/webt/mb/c8/za/mbc8za3pa9q9hmlcuvblb1holzk.png"><br><p style=";text-align:right;direction:rtl">  إذا فعلنا git merge beta ، فسيحدث دمج سريع للأمام (السلوك <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الافتراضي</a> ) ، أي أن الفرع الرئيسي سيكون على نفس الالتزام مثل فرع beta ، ولن يكون هناك التزام دمج.  سيكون مثل هذا: </p><br><img src="https://habrastorage.org/webt/sb/xb/ir/sbxbirjlbr69iwl0e6qfymenwb0.png"><br><p style=";text-align:right;direction:rtl">  ولكن هنا لم يتم إجراء دمج سريع للأمام باستخدام الأمر git merge beta --no-ff.  وهذا هو ، أجبرنا على إنشاء التزام دمج ، على الرغم من أنه لم يكن ضروريا.  وحيث أن الحالة النهائية المطلوبة للمشروع في المستقبل كانت معروفة ، فهذه شجرة تجريبية ، نسخت ببساطة الرابط إلى هذه الشجرة إلى التزام جديد: </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git cat-file -p origin/beta</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">tree 3c1afe75f54518dbd82ea7a4e3c4ff50389a573a &lt;--- parent 560b449675513bc8f8f4d6cda56a922d4e36917a author Baur &lt;atanov...@gmail.com&gt; 1540619512 +0600 committer Baur &lt;atanov...@gmail.com&gt; 1540619512 +0600 Added info about windows</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git cat-file -p 7229df8</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">tree 3c1afe75f54518dbd82ea7a4e3c4ff50389a573a &lt;--- parent fd54ab7dde87593b9892b6d1ffbf1afd39ba6f9e parent 280c30ff81a574f8dd41721726cf60b22fb2eced author Baur &lt;atanov...@gmail.com&gt; 1540619579 +0600 committer Baur &lt;atanov...@gmail.com&gt; 1540619592 +0600 Merge branch <span class="hljs-string"><span class="hljs-string">'beta'</span></span> into <span class="hljs-string"><span class="hljs-string">'master'</span></span></code> </pre> </div></div><br><a name="z6a"></a><br><h3 id="6a-metod-rebase-cherez-merge---opisanie" style=";text-align:right;direction:rtl">  <strong>6 أ.</strong>  <strong>Rebase طريقة عبر دمج - الوصف</strong> </h3><br><p style=";text-align:right;direction:rtl">  التحدي: <br>  من الضروري إنشاء فرع rebase "ثقيل" (العديد من التعارضات على عمليات مختلفة). </p><br><p style=";text-align:right;direction:rtl">  هناك مثل هذا holivar الكلاسيكية في بوابة - rebase مقابل دمج.  لكنني لن holivarit.  على العكس من ذلك ، سأتحدث عن كيفية تكوين صداقات في سياق هذه المهمة. </p><br><p style=";text-align:right;direction:rtl">  بشكل عام ، لقد تم تصميم git خصيصًا حتى نتمكن من القيام بالدمج بشكل فعال.  وعندما جئت إلى المشروع حيث يعتمد سير العمل على rebase ، كانت المرة الأولى التي كنت فيها غير مريح وغير عادي ، حتى قمت بتطوير التقنيات التي سهّلت عملي اليومي مع بوابة.  واحد منهم هو طريقتي الأصلية للقيام rebase الثقيلة. </p><br><p style=";text-align:right;direction:rtl">  لذلك ، نحن بحاجة إلى إعادة إنشاء فرع alpha عند التطوير ، بحيث يتم تلوينه لاحقًا بشكل جميل مثل فرع beta.  إذا بدأنا rebase كالمعتاد ، سينتج عن الالتزام الأول والأخير تعارضين مختلفين في مكانين مختلفين.  ولكن إذا قمنا بدمج ، بدلاً من rebase ، سيكون هناك تعارض واحد فقط في مكان واحد في التزام دمج واحد. </p><br><p style=";text-align:right;direction:rtl">  إذا كنت تريد التأكد من هذا ، فأنا أقدم فرقًا جاهزة تحت المفسد. </p><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">النص المخفي</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  عودة الفروع إلى حالتها الأصلية </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git checkout master git reset --hard origin/master git checkout alpha git reset --hard origin/alpha</code> </pre> <br><p style=";text-align:right;direction:rtl">  إنشاء والوقوف على فرع ألفا rebase- الصراعات وإعادة rebase على ماجستير </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git checkout -b alpha-rebase-conflicts git rebase master</code> </pre> <br><p style=";text-align:right;direction:rtl">  سيكون هناك صراعات في ارتكاب مختلف ، بما في ذلك صراع الوهمية. </p><br><p style=";text-align:right;direction:rtl">  الآن دعونا نجرب الدمج ، ونعود إلى فرع ألفا وحذف الفرع من أجل rebase. </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git checkout alpha git branch -D alpha-rebase-conflicts</code> </pre> <br><p style=";text-align:right;direction:rtl">  التبديل إلى إتقان وجعل الدمج </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git checkout master git merge alpha</code> </pre> <br><p style=";text-align:right;direction:rtl">  لن يكون هناك سوى صراع واحد بسيط ، ونحن تصحيحه والقيام به </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git add Bill.txt git commit -m <span class="hljs-string"><span class="hljs-string">"Merge branch 'alpha' into 'master'"</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  مارج الانتهاء بنجاح. </p></div></div><br><p style=";text-align:right;direction:rtl">  تعد الصراعات التي تحدث في بوابة غزة جزءًا طبيعيًا من حياتنا ، ويوضح هذا المثال البسيط أن الاندماج هو بالتأكيد أكثر ملاءمة من rebase في هذا الصدد.  في مشروع حقيقي ، يتم قياس هذا الاختلاف بمقدار أكبر بكثير من الوقت والأعصاب التي تقضيها.  لذلك ، على سبيل المثال ، هناك توصية غامضة لسحق كافة الالتزامات الخاصة بفرع الميزة في التزام واحد قبل الدمج. </p><br><p style=";text-align:right;direction:rtl">  فكرة هذه الطريقة هي جعل دمج مؤقت خفي سنحل فيه جميع النزاعات في وقت واحد.  تذكر النتيجة (الشجرة).  بعد ذلك ، قم بتشغيل rebase المعتاد ، ولكن باستخدام الخيار "حل النزاعات تلقائيًا ، واختيار تغييراتنا".  وفي النهاية ، أضف التزامًا إضافيًا إلى الفرع ، والذي سيعيد الشجرة الصحيحة. </p><br><p style=";text-align:right;direction:rtl">  لنبدأ.  مرة أخرى ، أعد كلا الفرعين إلى حالتهما الأصلية. </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git checkout master git reset --hard origin/master git checkout alpha git reset --hard origin/alpha</code> </pre> <br><p style=";text-align:right;direction:rtl">  دعونا إنشاء مؤقت فرع مؤقت الذي سنقوم دمج. </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git checkout -b temp git merge origin/master</code> </pre> <br><p style=";text-align:right;direction:rtl">  الصراع. </p><br><p style=";text-align:right;direction:rtl">  دعنا نحل تعارضًا بسيطًا واحدًا في ملف Bill.txt كالمعتاد (في أي محرر). <br>  لاحظ أن هناك تعارضًا واحدًا فقط وليس تعارضًا ، كما هو الحال مع rebase. </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git add Bill.txt git commit -m <span class="hljs-string"><span class="hljs-string">"Merge branch 'origin/master' into 'temp'"</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  نعود إلى فرع ألفا وننفذ حلاً مع الدقة التلقائية لجميع النزاعات لصالحنا ، ونعيد فرع درجة الحرارة إلى الحالة ، ونحذف فرع temp نفسه. </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git checkout alpha git rebase origin/master -X theirs git merge --ff $(git commit-tree temp^{tree} -m <span class="hljs-string"><span class="hljs-string">"Fix after rebase"</span></span> -p HEAD) git branch -D temp</code> </pre> <br><img src="https://habrastorage.org/webt/0c/dh/ou/0cdhoulztbrr4eskxlrotkxgjg0.png"><br><p style=";text-align:right;direction:rtl">  وأخيرا ، جميل mergim ألفا في الماجستير. </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git checkout master git merge alpha --no-ff --no-edit</code> </pre> <br><img src="https://habrastorage.org/webt/jj/aw/om/jjawom3amg15ki9ob7_osbahzdo.png"><br><p style=";text-align:right;direction:rtl">  لاحظ أن الفرع الرئيسي و alpha و temp البعيد يشير كلهم ​​إلى نفس الشجرة ، على الرغم من أنها ثلاث عمليات مختلفة. </p><br><p style=";text-align:right;direction:rtl">  سلبيات هذه الطريقة: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لا يوجد تصحيح يدوي لكل التزام صراع - يتم حل النزاعات تلقائيًا.  قد لا يتم تجميع مثل هذا الالتزام الوسيط. </li><li style=";text-align:right;direction:rtl">  تمت إضافة (ولكن ليس دائمًا) التزامًا إضافيًا على كل عملية إعادة تحويل </li></ul><br><p style=";text-align:right;direction:rtl">  الايجابيات: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  نحن فقط إصلاح الصراعات الحقيقية (لا الصراعات الوهمية) </li><li style=";text-align:right;direction:rtl">  يتم إصلاح جميع الصراعات مرة واحدة فقط. </li><li style=";text-align:right;direction:rtl">  أول نقطتين توفير الوقت </li><li style=";text-align:right;direction:rtl">  يتم حفظ محفوظات كاملة من الالتزامات وجميع التغييرات (على سبيل المثال ، يمكنك اختيار الكرز) </li><li style=";text-align:right;direction:rtl">  يتم تنفيذ هذه الطريقة كبرنامج نصي ويمكن استخدامها دائمًا إذا لزم الأمر لإعادة تشغيلها (لا تتطلب أي معرفة بالأشجار وما إلى ذلك) </li></ul><br><a name="z6b"></a><br><h3 id="6b-metod-rebase-cherez-merge---skript" style=";text-align:right;direction:rtl">  <strong>6 ب.</strong>  <strong>Rebase طريقة عبر دمج - النصي</strong> </h3><br><p style=";text-align:right;direction:rtl">  يتم نشر البرنامج النصي هنا: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://github.com/capslocky/git-rebase-via-merge</a> </p><br><p style=";text-align:right;direction:rtl">  دعونا التحقق من عملها على مثالنا.  مرة أخرى ، أعد كلا الفرعين إلى حالتهما الأصلية </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git checkout master git reset --hard origin/master git checkout alpha git reset --hard origin/alpha</code> </pre> <br><p style=";text-align:right;direction:rtl">  قم بتنزيل البرنامج النصي وجعله قابلاً للتنفيذ </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">curl -L https://git.io/rebase-via-merge -o ~/git-rebase-via-merge.sh chmod +x ~/git-rebase-via-merge.sh</code> </pre> <br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">النوافذ</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  سيظهر الملف هنا: C: \ Users \ user-name \ git-rebase-via-merge.sh </p></div></div><br><p style=";text-align:right;direction:rtl">  قم بتغيير الفرع الافتراضي الذي تحتاج إلى إعادة تشغيله ، وفي حالتنا نحتاج إلى الأصل / الرئيسي </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">nano ~/git-rebase-via-merge.sh</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">default_base_branch=<span class="hljs-string"><span class="hljs-string">'origin/master'</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  لنقم أيضًا بإنشاء فرع مؤقت والوقوف فيه حتى لا نلمس فرع ألفا نفسه </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git checkout -b alpha-rebase-test</code> </pre> <br><p style=";text-align:right;direction:rtl">  والآن يمكنك تشغيل البرنامج النصي (بدلاً من الأصل / الرئيسي rebase git) </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">~/git-rebase-via-merge.sh</code> </pre> <br><img src="https://habrastorage.org/webt/hi/nx/fw/hinxfwidwz65f9et23qqn9daxdi.png"><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">نتيجة البرنامج النصي</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">$ ~/git-rebase-via-merge.sh This script will perform rebase via merge. Current branch: alpha-rebase-test (64fafc7) Base branch: origin/master (9c6b60a) Continue (c) / Abort (a) c Auto-merging Bill.txt CONFLICT (content): Merge conflict <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Bill.txt Automatic merge failed; fix conflicts and <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> commit the result. You have at least one merge conflict. Fix all conflicts <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the following files, stage them up and <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">'c'</span></span>: Bill.txt Continue (c) / Abort (a) c [detached HEAD 785d49e] Hidden temp commit to save result of merging <span class="hljs-string"><span class="hljs-string">'origin/master'</span></span> into <span class="hljs-string"><span class="hljs-string">'alpha-rebase-test'</span></span> as detached head. Merge succeeded on hidden commit: 785d49e Starting rebase automatically resolving any conflicts <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> favor of current branch. First, rewinding head to replay your work on top of it... Auto-merging Bill.txt [detached HEAD a680316] Added <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> of windows Author: Baur &lt;atanov...@gmail.com&gt; Date: Sat Oct 27 11:45:50 2018 +0600 1 file changed, 6 insertions(+), 3 deletions(-) Committed: 0001 Added <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> of windows Auto-merging Bill.txt [detached HEAD dcd34a8] Replaced <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> of windows Author: Baur &lt;atanov...@gmail.com&gt; Date: Sat Oct 27 11:55:42 2018 +0600 1 file changed, 4 insertions(+), 5 deletions(-) Committed: 0002 Replaced <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> of windows Auto-merging Bill.txt [detached HEAD 8d6d82c] Added file about Azure and info about Windows 10 Author: Baur &lt;atanov...@gmail.com&gt; Date: Sat Oct 27 12:06:27 2018 +0600 2 files changed, 5 insertions(+), 3 deletions(-) create mode 100644 Azure.txt Committed: 0003 Added file about Azure and info about Windows 10 All <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>. Restoring project state from hidden merge with single additional commit. Updating 8d6d82c..268b320 Fast-forward Bill.txt | 4 ++++ 1 file changed, 4 insertions(+) Done.</code> </pre> </div></div><br><p style=";text-align:right;direction:rtl">       </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">~/git-rebase-via-merge.sh origin/develop</code> </pre> <br><p style=";text-align:right;direction:rtl">   ,  ours / theirs     : </p><br><p style=";text-align:right;direction:rtl"> ours —       (HEAD) <br> theirs —      (, origin/develop) </p><br><p style=";text-align:right;direction:rtl">      rebase —    . </p><br><a name="z7"></a><br><h3 id="7-alias" style=";text-align:right;direction:rtl"> <strong>7. </strong> </h3><br><p style=";text-align:right;direction:rtl">    git       . </p><br><p style=";text-align:right;direction:rtl">      . </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git config alias.copy <span class="hljs-string"><span class="hljs-string">'!git merge --ff $(git commit-tree ${1}^{tree} -p HEAD -m "Tree copy from ${1}")'</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">     git copy xxx,  xxx —    . </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git copy xxx</code> </pre> <br><p style=";text-align:right;direction:rtl">        </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git merge --ff $(git commit-tree xxx^{tree} -p HEAD -m <span class="hljs-string"><span class="hljs-string">"Tree copy from xxx"</span></span>)</code> </pre> <br><p style=";text-align:right;direction:rtl">  </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git copy a8fc5e3</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git copy origin/beta</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git copy HEAD~3</code> </pre> <br><p style=";text-align:right;direction:rtl">           git amend. </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git commit --amend -m <span class="hljs-string"><span class="hljs-string">"Just for test"</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">   : </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git commit --amend</code> </pre> <br><a name="end"></a><br><h3 id="zaklyuchenie" style=";text-align:right;direction:rtl"> <strong></strong> </h3><br><p style=";text-align:right;direction:rtl">   ,           ,      .    ,   .  —  .    , ,   .           .   "  "  "   "   .         ( ,   devops), ,   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar433748/">https://habr.com/ru/post/ar433748/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar433734/index.html">دونالد كنوث: "لعب الرفاق الأكبر سناً التنس ، وكنا كرات. لقد ضربونا ، لقد أصبت ". (11،12 / 97)</a></li>
<li><a href="../ar433738/index.html">الآثار: الألعاب تحت MS-DOS التي لم نختارها</a></li>
<li><a href="../ar433740/index.html">دوما الدولة يلغي التجوال الوطني في القراءة الثالثة</a></li>
<li><a href="../ar433742/index.html">Turbojet</a></li>
<li><a href="../ar433746/index.html">مالفار الذي يقرأ الميمات</a></li>
<li><a href="../ar433750/index.html">كيف أمضينا المدرسة الشتوية "الأنظمة الرقمية المدمجة" في كراسنويارسك</a></li>
<li><a href="../ar433752/index.html">مجنون Cassander حول الفروق الدقيقة في تعليم تصميم اللعبة في روسيا</a></li>
<li><a href="../ar433754/index.html">سلاك يحظر حسابات القرم</a></li>
<li><a href="../ar433756/index.html">جاذبية الروبوت. تقارير إخبارية لأتمتة المحمول</a></li>
<li><a href="../ar433758/index.html">بدلة الكترونية: التعبير عن الذات من خلال التصميم</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>