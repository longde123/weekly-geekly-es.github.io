<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏥 ↖️ 🤨 Kursus MIT "Keamanan Sistem Komputer". Kuliah 10: Eksekusi Simbolik, Bagian 1 🉐 🧦 📎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut Teknologi Massachusetts. Kursus Kuliah # 6.858. "Keamanan sistem komputer." Nikolai Zeldovich, James Mickens. Tahun 2014 
 Keamanan Sistem Ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kursus MIT "Keamanan Sistem Komputer". Kuliah 10: Eksekusi Simbolik, Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/425557/"><h3>  Institut Teknologi Massachusetts.  Kursus Kuliah # 6.858.  "Keamanan sistem komputer."  Nikolai Zeldovich, James Mickens.  Tahun 2014 </h3><br>  Keamanan Sistem Komputer adalah kursus tentang pengembangan dan implementasi sistem komputer yang aman.  Ceramah mencakup model ancaman, serangan yang membahayakan keamanan, dan teknik keamanan berdasarkan pada karya ilmiah baru-baru ini.  Topik meliputi keamanan sistem operasi (OS), fitur, manajemen aliran informasi, keamanan bahasa, protokol jaringan, keamanan perangkat keras, dan keamanan aplikasi web. <br><br>  Kuliah 1: “Pendahuluan: model ancaman” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 2: "Kontrol serangan hacker" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 3: “Buffer Overflows: Exploits and Protection” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 4: “Pemisahan Hak Istimewa” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 5: "Dari mana sistem keamanan berasal?" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> <br>  Kuliah 6: “Peluang” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 7: “Kotak Pasir Klien Asli” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 8: “Model Keamanan Jaringan” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 9: "Keamanan Aplikasi Web" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 10: “Eksekusi simbolik” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <a name="habracut"></a><br><br>  Selamat pagi semuanya, saya Armando Solar-Lesam dan hari ini saya akan memberikan ceramah tentang kinerja simbolik.  Siapa di antara mereka yang hadir di sini yang akrab dengan istilah ini atau pernah mendengar tentang ini sebelumnya?  Saya hanya ingin mendapatkan ide dari audiens kami.  Jadi mari kita mulai.  Saya menjatuhkan laptop saya beberapa kali, jadi butuh waktu lama untuk memuat. <br><br><img src="https://habrastorage.org/webt/t1/d0/ik/t1d0ikzwlt1dcgcg-1ifxfv-z3w.jpeg"><br><br>  Eksekusi simbolik adalah pekerja keras dari analisis program modern.  Ini adalah salah satu metode yang tumbuh dari penelitian dan kemudian mulai digunakan dalam banyak aplikasi.  Misalnya, hari ini di Microsoft ada sistem yang disebut SAGE, yang bekerja dengan banyak perangkat lunak Microsoft yang penting, mulai dari Power Point dan diakhiri dengan Windows sendiri, untuk benar-benar menemukan masalah keamanan dan kerentanan. <br><br>  Ada banyak proyek akademik yang memiliki dampak besar pada dunia nyata, seperti mendeteksi bug penting dalam perangkat lunak sumber terbuka menggunakan eksekusi simbolik.  Dan keindahan dari eksekusi simbolik sebagai teknik adalah dibandingkan dengan pengujian, ini memberi Anda kesempatan untuk membayangkan bagaimana program Anda akan berperilaku dengan set data input yang berpotensi tak terbatas.  Ini memungkinkan kami untuk menyelidiki array data input, yang akan sepenuhnya tidak praktis dan tidak praktis untuk menyelidiki, katakanlah, dengan pengujian acak, bahkan jika ada sejumlah besar penguji.  Di sisi lain, dibandingkan dengan metode analisis statis yang lebih tradisional, ia memiliki keuntungan sebagai berikut.  Saat menyelidiki masalah, eksekusi simbolik dapat membuat input dan jejak, jalur eksekusi yang dapat dijalankan dalam program nyata dan menjalankan program ini berdasarkan input ini.  Dan setelah itu, kita dapat mengidentifikasi bug nyata dan mulai memperbaikinya menggunakan mekanisme debugging tradisional.  Dan ini sangat berharga ketika Anda berada di lingkungan pengembangan industri di mana Anda mungkin tidak punya waktu untuk mengurus setiap masalah kecil dalam kode Anda. <br><br>  Misalnya, Anda benar-benar ingin dapat membedakan antara masalah nyata dan positif palsu.  Bagaimana cara kerjanya? <br><br>  Untuk benar-benar memahami cara kerjanya, sebaiknya mulai dengan eksekusi normal.  Jika kita menganggap eksekusi simbolik sebagai generalisasi dari eksekusi tradisional dan sederhana, masuk akal untuk mengetahui tampilannya.  Karena itu, saya akan menggunakan program yang sangat sederhana ini sebagai ilustrasi untuk banyak hal yang akan kita bicarakan hari ini. <br><br><img src="https://habrastorage.org/webt/1-/rv/gy/1-rvgymnpffellnl2jnb55j790i.jpeg"><br><br>  Di sini kita memiliki kutipan kode yang sangat sederhana dari beberapa cabang dan pernyataan bahwa jika, dalam kondisi tertentu, nilai t &lt;x, maka ini adalah pernyataan yang salah.  Kami ingin mengetahui apakah pernyataan ini dapat diajukan.  Apakah mungkin?  Apakah ada input yang akan membuat pernyataan ini gagal? <br><br>  Salah satu hal yang dapat saya lakukan adalah memeriksa pelaksanaan program ini menggunakan nilai input data tertentu sebagai contoh.  Misalkan kita menggunakan input yang X = 4 dan Y = 4. Nilai T adalah nol, seperti yang diumumkan di awal program. <br><br>  Jadi, sebelum kita sampai pada eksekusi normal, mari kita cari tahu apa yang penting di sini.  Kita perlu memiliki beberapa gagasan tentang keadaan program, kan?  Apakah kita melakukan eksekusi normal atau apakah kita melakukan eksekusi simbolik, kita perlu memiliki beberapa cara untuk mengkarakterisasi keadaan program.  Dalam hal ini, ini adalah program sederhana yang tidak menggunakan heap, tidak menggunakan stack, dan tidak ada panggilan fungsi di sini. <br><br>  Dengan demikian, negara dapat sepenuhnya ditandai oleh tiga variabel ini, bersama dengan mengetahui keberadaan saya dalam program ini.  Oleh karena itu, jika saya memulai eksekusi dari 4, 4 dan 0 dan sampai ke ujung cabang, maka saya akan memeriksa ekspresi: 4 lebih besar dari 4?  Jelas tidak. <br>  Sekarang saya akan menjalankan program di T = Y, yaitu, T tidak lagi 0, tetapi memiliki nilai 4. Ini adalah keadaan saat ini dari program saya, dan sekarang saya dapat mengevaluasi cabang ini. <br><br><img src="https://habrastorage.org/webt/xw/j1/pb/xwj1pbkpvyvv3vc_b3urir5ob-g.jpeg"><br><br>  Benarkah T &lt;X?  Tidak.  Kami menghindari peluru, pernyataan salah tidak bekerja.  Tidak ada masalah dalam eksekusi pribadi ini. <br><br>  Tapi ini tidak memberi tahu kita tentang eksekusi lainnya.  Kita tahu bahwa dengan nilai X = 4 dan Y = 4, program tidak akan gagal.  Tetapi ini tidak memberi tahu kami apa pun yang akan terjadi jika nilai inputnya adalah 2 dan 1. <br><br><img src="https://habrastorage.org/webt/8w/lv/vf/8wlvvfh7n43vvl2jaajhjd2opcy.jpeg"><br><br>  Dengan nilai input ini, eksekusi akan berjalan dengan cara yang berbeda.  Kali ini kita melihat bahwa T = X, dan setelah mengeksekusi baris ini T akan mengambil nilai sama dengan 2. Apakah ada masalah dalam eksekusi ini?  Apakah akan ada kesalahan pernyataan dengan input seperti itu? <br><br>  Baiklah, mari kita lihat.  Jadi, jika T adalah 2 dan X adalah 2, maka T tidak kurang dari X. Tampaknya kita kembali menghindari peluru.  Benar?  Jadi, di sini kita memiliki dua nilai input spesifik tempat program bekerja tanpa kesalahan.  Tapi sebenarnya, itu tidak memberi tahu kami apa pun tentang nilai input lainnya. <br><br>  Jadi, ide eksekusi simbolik adalah bahwa kita ingin melampaui eksekusi program dengan satu set data input.  Kami ingin dapat benar-benar berbicara tentang perilaku program ketika menggunakan kumpulan data yang sangat besar, dalam beberapa kasus, jumlah tak terbatas dari nilai input yang mungkin.  Gagasan utama ini adalah sebagai berikut. <br><br><img src="https://habrastorage.org/webt/wn/k5/fs/wnk5fs-evom1hqqeh8vnpppxezk.jpeg"><br><br>  Untuk program seperti ini, keadaannya ditentukan oleh nilai dari tiga variabel yang berbeda: X, Y, dan T, dan mengetahui di mana saya saat ini dalam program.  Tapi sekarang alih-alih nilai spesifik untuk X dan Y, saya akan memiliki nilai simbolik, hanya sebuah variabel.  Variabel yang memungkinkan saya untuk menyebutkan nilai ini, yang digunakan pengguna sebagai input.  Ini berarti bahwa keadaan program saya tidak lagi ditandai dengan mencocokkan nama variabel dengan nilai tertentu.  Sekarang ini adalah pemetaan nama variabel ke nilai simbolik ini. <br><br>  Nilai simbolik dapat dianggap sebagai formula.  Dalam hal ini, rumus untuk X sama dengan X dan rumus untuk Y hanyalah Y, dan untuk T sebenarnya sama dengan 0. Kita tahu bahwa untuk setiap nilai input tidak masalah apa yang Anda lakukan.  Nilai T setelah pernyataan pertama adalah 0. <br><br>  Di situlah mulai menarik sekarang.  Kita sampai pada cabang ini, yang mengatakan bahwa jika X lebih besar dari Y, kita akan menuju satu arah.  Jika X kurang dari atau sama dengan Y, kita akan pergi ke arah lain. <br><br>  Apakah kita tahu sesuatu tentang X dan Y?  Apa yang kita ketahui tentang mereka?  Setidaknya kita tahu tipenya, kita tahu bahwa mereka akan bervariasi dari min int ke max int, tapi hanya itu yang kita ketahui tentang mereka.  Ternyata informasi yang kita ketahui tentang mereka tidak cukup untuk mengatakan ke arah mana cabang ini bisa pergi.  Dia bisa pergi ke segala arah <br>  Ada banyak hal yang bisa kita lakukan, tetapi apa yang bisa kita lakukan saat ini?  Cobalah untuk membuat tebakan yang paling liar. <br><br><img src="https://habrastorage.org/webt/eu/a9/c-/eua9c-jo64thlkjghlaj3e9x6rs.jpeg"><br><br>  <b>Pemirsa:</b> kami dapat melacak pelaksanaan program di kedua cabang. <br><br>  <b>Profesor:</b> ya, kita bisa melacak kemajuan di kedua cabang.  Balik koin, dan tergantung bagaimana jatuh, pilih satu atau cabang lainnya. <br><br>  Jadi, jika kita ingin mengikuti kedua cabang, pertama kita harus mengikuti satu dan kemudian yang lain, kan?  Misalkan kita mulai dengan cabang ini - T = X.  Kita tahu bahwa jika kita sampai ke tempat ini, T akan memiliki arti yang sama dengan X. Kita tidak tahu apa nilai ini, tetapi kita memiliki nama untuk itu - ini adalah skrip X. <br><br><img src="https://habrastorage.org/webt/2l/zy/mx/2lzymxorfsurzuz_bjon1hr4kdi.jpeg"><br><br>  Jika kita mengambil cabang yang berlawanan, lalu apa yang akan terjadi?  Nilai T akan sama dengan sesuatu yang lain, bukan?  Di cabang ini, nilai T akan menjadi nilai simbolis dari Y. <br><br><img src="https://habrastorage.org/webt/q9/e6/fw/q9e6fwx1kg2llxhp3ci7rfzvwym.jpeg"><br><br>  Jadi apa artinya nilai T ini ketika kita sampai pada titik ini dalam program?  Mungkin itu X, mungkin Y. Kami tidak tahu persis apa nilai ini, tetapi mengapa kita tidak memberi nama?  Sebut saja t <sub>0</sub> .  Dan apa yang kita ketahui tentang t <sub>0</sub> ?  Dalam kasus apa t <sub>0</sub> akan sama dengan X? <br><br>  Pada dasarnya, kita tahu bahwa jika X lebih besar dari Y, maka variabelnya sama dengan X, dan jika X kurang dari atau sama dengan Y, maka variabelnya sama dengan Y. Oleh karena itu, kita memiliki nilai yang kita definisikan, sebut saja t <sub>0</sub> , dan ia memiliki ini sifat logis. <br><br><img src="https://habrastorage.org/webt/6l/ux/93/6lux93kqkmnz63fjddelibxu3ma.jpeg"><br><br>  Jadi, pada titik ini dalam program, kami memiliki nama untuk nilai T, ini t <sub>0</sub> .  Apa yang sudah kita lakukan di sini?  Kami mengambil kedua cabang dari pernyataan if, dan kemudian menghitung nilai simbolik, melihat dalam kondisi apa satu cabang dari program akan dieksekusi, dan di bawah yang lainnya. <br>  Sekarang sampai pada titik bahwa kita harus bertanya apakah T bisa kurang dari X. Sekarang nilai T adalah t <sub>0</sub> , dan kami ingin tahu apakah mungkin untuk t <sub>0</sub> menjadi kurang dari X?  Ingat cabang pertama yang kami periksa - kami mengajukan pertanyaan tentang X dan Y dan tidak tahu apa-apa tentang mereka, kecuali bahwa mereka bertipe int. <br><br>  Tetapi dengan t <sub>0</sub> , kami benar-benar tahu banyak tentang itu.  Kita tahu bahwa dalam beberapa kasus itu akan sama dengan X, dan dalam beberapa kasus itu akan sama dengan Y. Jadi sekarang memberi kita satu set persamaan yang bisa kita pecahkan.  Jadi, kita dapat mengatakan apakah mungkin <sub>0</sub> t kurang dari X, mengetahui bahwa t <sub>0</sub> memenuhi semua kondisi ini?  Jadi, kita dapat menyatakan ini sebagai batasan, menunjukkan apakah t <sub>0</sub> mungkin lebih kecil dari X. Dan jika X lebih besar dari Y, maka t <sub>0</sub> adalah X, dan jika X kurang dari atau sama dengan Y, ini berarti bahwa t <sub>0</sub> = Y. <br><br><img src="https://habrastorage.org/webt/kw/go/1p/kwgo1pvhy86moreg7j9vnwlybsi.jpeg"><br><br>  Jadi kita punya persamaan.  Jika memiliki solusi, jika mungkin untuk menemukan nilai t <sub>0</sub> , nilai X dan nilai Y yang memenuhi persamaan ini, maka kita mengenali nilai-nilai ini, dan ketika kita memasukkannya ke dalam program, maka ketika dieksekusi akan berjalan di sepanjang cabang ini jika t &lt;x dan " akan meledak ”ketika dinyatakan salah. <br><br>  Jadi apa yang sudah kita lakukan di sini?  Kami mengeksekusi program, tetapi alih-alih memetakan nama variabel ke nilai tertentu, kami memberikan nama variabel ini nilai simbolik.  Bahkan, mereka memberi mereka nama variabel lain.  Dan dalam hal ini, nama variabel kami yang lain adalah skrip X, skrip Y, t <sub>0</sub> , dan di samping itu, kami memiliki seperangkat persamaan yang menunjukkan bagaimana nilai-nilai ini terkait.  Kami memiliki persamaan yang memberi tahu kami bagaimana t <sub>0</sub> terkait dengan X dan Y dalam kasus ini. <br><br>  Solusi dari persamaan ini memungkinkan kita untuk menjawab pertanyaan apakah cabang ini dapat dieksekusi atau tidak.  Lihatlah persamaannya - apakah mungkin untuk mengambil cabang ini atau tidak?  Tampaknya tidak, karena kami mencari kasus di mana t <sub>0</sub> lebih kecil dari X, tetapi jika dalam kondisi pertama t <sub>0</sub> = X, maka ekspresi t <sub>0</sub> &lt;X tidak akan benar. <br><br>  Jadi, ini berarti bahwa ketika X&gt; Y, ini tidak dapat terjadi, karena t <sub>0</sub> = X dan tidak dapat sama dengan atau kurang dari X pada saat yang sama. <br><br>  Tetapi apa yang terjadi jika t <sub>0</sub> = Y?  Bisakah t <sub>0</sub> kurang dari X dalam hal ini? <br><br>  Tidak, itu pasti tidak bisa, karena kita tahu bahwa X &lt;Y. Jadi jika t <sub>0</sub> kurang dari X, maka itu juga akan kurang dari Y. Tetapi kita tahu bahwa dalam hal ini t <sub>0</sub> = Y. Dan karena itu, lagi , kondisi ini tidak dapat dipenuhi.  Jadi, di sini kami memiliki persamaan yang tidak memiliki solusi, dan tidak masalah apa nilai yang Anda sertakan dalam persamaan ini. <br><br>  Anda tidak dapat menyelesaikannya, dan ini memberi tahu kami bahwa apa pun input X dan Y yang kami berikan ke program, ia tidak akan turun ke cabang jika t &lt;x. <br><br>  Sekarang perhatikan bahwa dalam membuat argumen ini di sini, pada dasarnya saya mengisyaratkan intuisi Anda tentang bilangan bulat, tentang bilangan bulat matematika.  Dalam praktiknya, kita tahu bahwa int mesin tidak berperilaku persis seperti int matematika.  Ada kasus di mana hukum yang diterapkan pada tipe data integer matematis tidak berlaku untuk int terprogram. <br><br>  Oleh karena itu, kita harus sangat berhati-hati ketika menyelesaikan persamaan ini, karena kita harus ingat bahwa ini bukan bilangan bulat yang kita diberitahu di sekolah dasar.  Ini adalah bilangan bulat 32-bit yang digunakan oleh mesin.  Dan ada banyak kasus kesalahan yang terjadi karena programmer memikirkan kode mereka dalam hal bilangan bulat matematika, tidak menyadari bahwa ada hal-hal seperti luapan yang dapat menyebabkan perilaku program yang berbeda untuk input matematika. <br><br>  Hal lain yang saya jelaskan di sini adalah argumen yang murni intuitif.  Saya akan memandu Anda melalui proses, menunjukkan cara melakukannya secara manual, tetapi ini tidak berarti suatu algoritma.  Namun, keindahan dari eksekusi simbolik ini adalah bahwa ia dapat dikodekan ke dalam suatu algoritma.  Dan Anda dapat menyelesaikannya secara mekanis, yang memungkinkan Anda melakukan ini tidak hanya untuk program 10-line, tetapi untuk jutaan program.  Ini memungkinkan kami untuk menggunakan alasan intuitif yang sama yang kami gunakan dalam kasus ini dan berbicara tentang apa yang terjadi ketika kami menjalankan program ini dengan nilai input yang berbeda.  Dan pertimbangan ini dapat ditingkatkan dan diperluas ke program yang sangat besar. <br><br><img src="https://habrastorage.org/webt/b0/of/jr/b0ofjrqh-vesxglsfrxpikk8yb0.jpeg"><br><br>  <b>Audiens:</b> bagaimana jika program tidak mendukung input dari jenis variabel tertentu? <br><br>  <b>Profesor:</b> ini pertanyaan yang sangat bagus!  Misalkan kita memiliki program yang sama, tetapi alih-alih t = x kita akan memiliki t = (x-1).  Lalu, secara intuitif, kita bisa membayangkan bahwa sekarang program ini bisa "meledak", kan? <br><br><img src="https://habrastorage.org/webt/_k/sk/9v/_ksk9vik_mk_xno9mkjqkvoli3k.jpeg"><br><br>  Karena ketika program berjalan seperti ini, t benar-benar akan kurang dari x.  Apa yang akan terjadi pada program semacam itu?  Akan seperti apakah keadaan simbolis kita?  Apa yang akan menjadi <sub>0</sub> ketika x lebih besar dari y?  Kami mengoreksi garis dalam persamaan kami sesuai dengan nilai lain ketika t = (x-1).  Sekarang program mungkin gagal, dan Anda pergi ke pengembang dan katakan padanya: "hei, fungsi ini bisa meledak ketika x lebih besar dari y"! <br><br>  Pengembang melihat ini dan berkata: "Oh, saya lupa memberi tahu Anda - sebenarnya, fungsi ini tidak akan pernah dipanggil dengan parameter, di mana x lebih besar dari y.  "Saya hanya menulisnya untuk beberapa alasan historis, jadi jangan khawatir, saya tidak akan mengingatnya jika Anda tidak memberi tahu saya." <br><br>  Misalkan kita memiliki asumsi bahwa x akan kurang dari atau sama dengan y. <br><br><img src="https://habrastorage.org/webt/il/iu/un/iliuunmfbjyqdw1dxw7ugemm0go.jpeg"><br><br>  Ini adalah prasyarat atau kesepakatan untuk fungsi kita.  Fungsi berjanji untuk melakukan sesuatu, tetapi hanya jika nilainya memuaskan asumsi ini.  Tetapi jika tidak puas, fungsi mengatakan: "Saya tidak peduli apa yang terjadi.  Saya berjanji bahwa tidak akan ada kesalahan hanya jika asumsi ini dipenuhi. " <br><br>  Jadi, bagaimana kita memberi kode batasan ini ketika kita memecahkan persamaan?  Pada dasarnya, kami memiliki serangkaian kendala yang memberi tahu kami apakah cabang ini layak atau tidak.  Dan di samping keterbatasan, kita juga harus memastikan bahwa prasyarat, atau asumsi, dipenuhi. <br><br>  Pertanyaannya adalah, dapatkah saya menemukan x dan y yang memenuhi semua batasan ini dan pada saat yang sama memiliki properti yang diperlukan?  Anda dapat melihat bahwa batasan X ≤ Y ini merepresentasikan perbedaan antara case ketika batasan ini dipenuhi dan case ketika tidak dipenuhi. <br><br>  Ini adalah masalah yang sangat penting ketika bekerja dengan analisis, terutama ketika Anda ingin melakukan ini secara bersamaan di tingkat fungsi individu.  Dianjurkan untuk mengetahui apa yang ada dalam pikiran programmer ketika menulis fungsi ini.  Karena jika Anda tidak tahu tentang asumsi-asumsi ini, Anda mungkin berpikir bahwa ada beberapa masukan bahwa program akan gagal. <br><br>  Bagaimana melakukan ini dengan cara mekanis?  Ada dua aspek untuk masalah ini.  Aspek nomor satu - bagaimana Anda benar-benar menghasilkan formula ini? <br><br>  Dalam hal ini, secara intuitif jelas bagaimana kami sampai pada formula ini, kami hanya membuatnya secara manual.  Tetapi bagaimana cara membuat formula ini secara mekanis? <br><br>  Dan aspek kedua - bagaimana Anda memecahkan formula ini setelah Anda memilikinya?  Apakah mungkin untuk benar-benar menyelesaikan formula ini yang menjelaskan apakah program Anda macet atau tidak? <br>  Mari kita mulai dengan pertanyaan kedua.  Kita bisa mengurangi masalah kita dengan rumus-rumus ini, yang mencakup penalaran bilangan bulat dan vektor bit.  Saat membuat program, Anda mengurus array, fungsi, dan sebagai hasilnya, Anda mendapatkan formula raksasa.  Apakah mungkin untuk menyelesaikannya secara mekanis? <br><br><img src="https://habrastorage.org/webt/fb/wg/mp/fbwgmprqfh03wmz73pz3s5cfrv0.jpeg"><br><br>  Banyak teknologi yang kita bicarakan hari ini adalah alat praktis yang terkait dengan kemajuan luar biasa dalam mengembangkan pemecah untuk pertanyaan logis.  Secara khusus, ada kelas pemecah yang sangat penting, yang disebut SMT, atau "pemecah solvabilitas teori modular."  SMT solver adalah solvabilitas formula logis dengan mempertimbangkan teori yang mendasari mereka. <br><br>  Banyak orang mengklaim bahwa nama ini tidak terlalu baik, tetapi telah diperbaiki sebagai yang paling umum digunakan. <br><br>  SMT-solver adalah suatu algoritma karena rumus logis ini pada output akan memberikan Anda satu dari dua opsi: apakah memenuhi tujuannya atau tidak memuaskan.   ,        ,     . <br><br>         .   ,    SMT,  NP- ,      «»  «». <br>     ,           NP- ?     -,    ?   ,    SMT –       : «  ». <br><br><img src="https://habrastorage.org/webt/wp/se/q9/wpseq9oqvluas4nkjsstzagwpva.jpeg"><br><br>         , ,        ,    ,   : «  ».      ,           ,        . <br><br> 27:30  <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> MIT «  ».  10: « »,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yRVZPvHYHzw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Versi lengkap dari kursus ini tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps hingga Desember secara gratis</b> ketika membayar untuk jangka waktu enam bulan, Anda dapat memesan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425557/">https://habr.com/ru/post/id425557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425547/index.html">Qt: menggambar berdasarkan grafik vektor</a></li>
<li><a href="../id425549/index.html">Saham Supermicro jatuh di tengah penyelidikan penyebaran chip mata-mata Cina</a></li>
<li><a href="../id425551/index.html">Siapa yang harus menerima uang dari penjualan karya seni yang dibuat oleh AI?</a></li>
<li><a href="../id425553/index.html">Apa yang Dapat Diceritakan oleh Pangeran Monte Cristo Tentang Keamanan Siber</a></li>
<li><a href="../id425555/index.html">Charles Nutter pada bahasa dinamis di JVM di jug.msk.ru</a></li>
<li><a href="../id425559/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 10: Eksekusi Simbolik, Bagian 3</a></li>
<li><a href="../id425561/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 10: Eksekusi Simbolik, Bagian 2</a></li>
<li><a href="../id425563/index.html">California melarang penjualan perangkat IoT dengan atau tanpa kata sandi sederhana</a></li>
<li><a href="../id425565/index.html">Matematika fixed-point cepat untuk aplikasi keuangan di Jawa</a></li>
<li><a href="../id425569/index.html">Pengujian Fungsional PCB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>