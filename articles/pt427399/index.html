<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüè≠ üåí üÖ∞Ô∏è Trabalhando com dados ao criar uma API baseada no GraphQL üèÇ üïë üöº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pre√¢mbulo 


 Antes de tudo, este artigo foi desenvolvido para os leitores que j√° est√£o familiarizados com o GraphQL e mais sobre os meandros e as nua...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trabalhando com dados ao criar uma API baseada no GraphQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427399/"><h3 id="preambula">  Pre√¢mbulo </h3><br><p>  Antes de tudo, este artigo foi desenvolvido para os leitores que j√° est√£o familiarizados com o GraphQL e mais sobre os meandros e as nuances de como trabalhar com ele.  No entanto, espero que seja √∫til para iniciantes. </p><br><p>  O GraphQL √© uma √≥tima ferramenta.  Eu acho que muitas pessoas j√° conhecem e entendem suas vantagens.  No entanto, h√° algumas nuances a serem observadas ao criar suas APIs baseadas em GraphQL. </p><br><p> Por exemplo, o GraphQL permite retornar ao consumidor (usu√°rio ou programa) solicitando os dados apenas na parte da qual esse consumidor est√° interessado.  No entanto, ao construir um servidor, √© muito f√°cil cometer um erro, o que leva ao fato de que dentro do servidor (que pode ser, entre outras coisas, distribu√≠do), os dados ser√£o executados em "pacotes" completos.  Isso se deve principalmente ao fato de o GraphQL pronto para uso n√£o fornecer ferramentas convenientes para analisar uma consulta recebida, e as interfaces nele estabelecidas n√£o est√£o bem documentadas. </p><a name="habracut"></a><br><h3 id="istochnik-problemy">  Fonte do problema </h3><br><p>  Vejamos um exemplo t√≠pico de uma implementa√ß√£o n√£o ideal (abra a imagem em uma janela separada, se for mal lida): </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/497/409/cb6/497409cb638a09186c79f0c60e49154c.png" alt="imagem"></p><br><p>  Suponha que nosso consumidor seja um determinado aplicativo ou componente da "lista telef√¥nica" que solicite a partir de nossa API apenas o identificador, nome e n√∫mero de telefone dos usu√°rios armazenados por n√≥s.  Ao mesmo tempo, nossa API √© muito mais abrangente, permitindo acesso a outros dados, como o endere√ßo f√≠sico da resid√™ncia e o endere√ßo de e-mail dos usu√°rios. </p><br><p>  No momento da troca de dados entre o consumidor e a API, o GraphQL realiza perfeitamente todo o trabalho que precisamos - somente os dados solicitados ser√£o enviados em resposta √† solicita√ß√£o.  O problema neste caso est√° no ponto de amostragem de dados do banco de dados - ou seja,  na implementa√ß√£o interna de nosso servidor, e consiste no fato de que, para cada solicita√ß√£o recebida, selecionamos todos os dados do usu√°rio no banco de dados, apesar de n√£o precisarmos de alguns deles.  Isso gera carga excessiva no banco de dados e leva √† circula√ß√£o de tr√°fego excessivo dentro do sistema.  Com um n√∫mero significativo de consultas, voc√™ pode obter uma otimiza√ß√£o significativa alterando a abordagem da amostragem de dados e selecionando apenas os campos solicitados.  Ao mesmo tempo, n√£o importa qual seja a nossa fonte de dados - um banco de dados relacional, tecnologia NoSQL ou outro servi√ßo (interno ou externo).  Qualquer comportamento n√£o ideal pode ser afetado por qualquer implementa√ß√£o.  Neste caso, o MySQL √© selecionado simplesmente como exemplo. </p><br><h3 id="reshenie">  Solu√ß√£o </h3><br><p> √â poss√≠vel otimizar esse comportamento do servidor se analisarmos os argumentos que chegam √† fun√ß√£o <code>resolve()</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> resolve(source, args, context, info) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  √â o √∫ltimo argumento, <code>info</code> , que √© de particular interesse para n√≥s, neste caso.  Voltamos √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> e analisamos em detalhes em que consiste a fun√ß√£o <code>resolve()</code> e o argumento em que estamos interessados: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLFieldResolveFn</span></span></span><span class="hljs-class"> = ( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">source</span></span></span><span class="hljs-class">?: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">?: {[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">argName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class">}, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">?: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">?: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLResolveInfo</span></span></span><span class="hljs-class"> ) =&gt; any </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLResolveInfo</span></span></span><span class="hljs-class"> = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fieldName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fieldNodes</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Array</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Field</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">returnType</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLOutputType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parentType</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLCompositeType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schema</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLSchema</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fragments</span></span></span><span class="hljs-class">: { [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fragmentName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FragmentDefinition</span></span></span><span class="hljs-class"> }, rootValue: any, operation: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OperationDefinition</span></span></span><span class="hljs-class">, variableValues: { [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">variableName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class"> }, }</span></span></code> </pre> <br><p>  Portanto, os tr√™s primeiros argumentos transmitidos ao resolvedor s√£o a <code>source</code> - os dados transmitidos do n√≥ pai na √°rvore GraphQL do esquema, <code>args</code> - os argumentos de solicita√ß√£o (que v√™m da consulta) e o <code>context</code> - o objeto de contexto de execu√ß√£o definido pelo desenvolvedor, geralmente chamado para transmitir alguns dados globais nos "resolvedores".  E, finalmente, o quarto argumento √© a meta-informa√ß√£o sobre a solicita√ß√£o. </p><br><p>  O que podemos extrair do <code>GraphQLResolveInfo</code> para resolver nosso problema? </p><br><p>  Suas partes mais interessantes s√£o: </p><br><ul><li>  <code>fieldName</code> √© o nome do campo atual do esquema GraphQL.  I.e.  corresponde ao nome do campo especificado no esquema para esse resolvedor.  Se capturarmos o objeto de <code>info</code> no campo de <code>users</code> , como no exemplo acima, ser√£o "usu√°rios" que ser√£o contidos como o valor de <code>fieldName</code> </li><li>  <code>fieldNodes</code> - cole√ß√£o (matriz) de n√≥s que foram solicitados na consulta.  Apenas o que √© necess√°rio! </li><li>  <code>fragments</code> - uma cole√ß√£o de fragmentos da solicita√ß√£o (caso a solicita√ß√£o tenha sido fragmentada).  Tamb√©m informa√ß√µes importantes para recuperar os campos de dados finais. </li></ul><br><p>  Portanto, como solu√ß√£o, precisamos analisar a ferramenta de <code>info</code> e selecionar a lista de campos que nos chegaram da consulta e depois pass√°-los para a consulta SQL.  Infelizmente, o pacote GraphQL do Facebook "out of the box" n√£o fornece nada para simplificar esta tarefa.  No geral, como a pr√°tica demonstrou, essa tarefa n√£o √© t√£o trivial, dado o fato de que as solicita√ß√µes podem ser fragmentadas.  Al√©m disso, essa an√°lise tem uma solu√ß√£o universal, que √© posteriormente simplesmente copiada de um projeto para outro. </p><br><p>  Ent√£o, decidi escrev√™-lo como uma biblioteca de c√≥digo aberto sob a licen√ßa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ISC</a> .  Com sua ajuda, a solu√ß√£o para analisar os campos de consulta recebidos √© resolvida de maneira bastante simples, por exemplo, no nosso caso, da seguinte maneira: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { fieldsList } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'graphql-fields-list'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... async resolve(source, args, context, info) { const requestedFields = fieldsList(info); return await database.query(`SELECT ${requestedFields.join(',')} FROM users`) }</span></span></code> </pre> <br><p>  <code>fieldsList(info)</code> , nesse caso, faz todo o trabalho para n√≥s e retorna uma matriz "plana" de campos filho para esse resolvedor, ou seja,  nossa consulta SQL final ter√° a seguinte apar√™ncia: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, phone <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span>;</code> </pre> <br><p>  Se alterarmos a solicita√ß√£o recebida para: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> UserListQuery { <span class="hljs-section"><span class="hljs-section">users</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> name phone email } }</code> </pre> <br><p>  a consulta SQL se transformar√° em: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, phone, email <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span>;</code> </pre> <br><p>  No entanto, nem sempre √© poss√≠vel lidar com um desafio t√£o simples.  Freq√ºentemente, aplicativos reais s√£o muito mais complexos em estrutura.  Em algumas implementa√ß√µes, podemos precisar descrever o resolvedor no n√≠vel superior com rela√ß√£o aos dados no esquema final do GraphQL.  Por exemplo, se decidimos usar a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Relay</a> , gostar√≠amos de usar um mecanismo pronto para dividir cole√ß√µes de objetos de dados em p√°ginas, o que leva ao fato de que nosso esquema GraphQL ser√° constru√≠do de acordo com certas regras.  Por exemplo, refazemos nosso esquema dessa maneira (TypeScript): </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { GraphQLObjectType, GraphQLSchema, GraphQLString } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { connectionDefinitions, connectionArgs, nodeDefinitions, fromGlobalId, globalIdField, connectionFromArray, GraphQLResolveInfo, } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-relay'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { fieldsList } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-fields-list'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { nodeInterface, nodeField } = nodeDefinitions(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (globalId: string) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { type, id } = fromGlobalId(globalId); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node: any = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type === <span class="hljs-string"><span class="hljs-string">'User'</span></span>) { node = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> database.select(<span class="hljs-string"><span class="hljs-string">`SELECT id FROM user WHERE id="</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string">"`</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node; }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> User = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQLObjectType({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'User'</span></span>, <span class="hljs-attr"><span class="hljs-attr">interfaces</span></span>: [nodeInterface], <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: globalIdField(<span class="hljs-string"><span class="hljs-string">'User'</span></span>, (user: any) =&gt; user.id), <span class="hljs-attr"><span class="hljs-attr">name</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: GraphQLString }, <span class="hljs-attr"><span class="hljs-attr">email</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: GraphQLString }, <span class="hljs-attr"><span class="hljs-attr">phone</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: GraphQLString }, <span class="hljs-attr"><span class="hljs-attr">address</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: GraphQLString }, } }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-attr"><span class="hljs-attr">connectionType</span></span>: userConnection } = connectionDefinitions({ <span class="hljs-attr"><span class="hljs-attr">nodeType</span></span>: User }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Query = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQLObjectType({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Query'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: { <span class="hljs-attr"><span class="hljs-attr">node</span></span>: nodeField, <span class="hljs-attr"><span class="hljs-attr">users</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: userConnection, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: { ...connectionArgs }, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> resolve( source: any, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: {[argName: string]: any}, <span class="hljs-attr"><span class="hljs-attr">context</span></span>: any, <span class="hljs-attr"><span class="hljs-attr">info</span></span>: GraphQLResolveInfo, ) { <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> implement }, }, }); export const schema = new GraphQLSchema({ query: Query });</span></span></code> </pre> <br><p>  Nesse caso, a <code>connectionDefinition</code> from Relay adicionar√° <code>edges</code> , <code>node</code> , <code>pageInfo</code> e n√≥s de <code>cursor</code> ao esquema, ou seja,  agora precisaremos reconstruir nossas consultas de maneira diferente (n√£o vamos nos concentrar na pagina√ß√£o agora): </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> UserListQuery { <span class="hljs-section"><span class="hljs-section">users</span></span> { <span class="hljs-section"><span class="hljs-section">edges</span></span> { <span class="hljs-section"><span class="hljs-section">node</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> name phone email } } } }</code> </pre> <br><p>  Portanto, <code>resolve()</code> fun√ß√£o implementada no n√≥ de <code>users</code> agora ter√° que determinar quais campos s√£o solicitados n√£o para si, mas para o n√≥ do <code>node</code> filho aninhado, que, como vemos, √© relativo aos <code>users</code> ao longo do caminho <code>edges.node</code> . </p><br><p>  <code>fieldsList</code> da <code>fieldsList</code> <code>graphql-fields-list</code> ajudar√° a resolver esse problema; para isso, voc√™ deve passar a op√ß√£o de <code>path</code> correspondente.  Por exemplo, aqui est√° a implementa√ß√£o em nosso caso: </p><br><pre> <code class="hljs pgsql">async resolve( source: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, args: {[argName: string]: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>}, context: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>: GraphQLResolveInfo, ) { const fields = fieldsList(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>, { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">'edges.node'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> connectionFromArray( await <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>.query(`<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ${fields.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">','</span></span>)} <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> users`), args ); }</code> </pre> <br><p>  Tamb√©m no mundo real, pode ser que no esquema GraphQL tenha definido apenas um nome de campo e no esquema do banco de dados outros nomes de campos correspondam a eles.  Por exemplo, suponha que a tabela de usu√°rios no banco de dados tenha sido definida de forma diferente: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> AUTO_INCREMENT, fullName <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>), email <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>), phoneNumber <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">15</span></span>), address <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) );</code> </pre> <br><p>  Nesse caso, os campos da consulta GraphQL devem ser renomeados antes de serem incorporados na consulta SQL.  <code>fieldsList</code> ajudar√° nisso se voc√™ passar um mapa de convers√£o de nome na op√ß√£o de <code>transform</code> correspondente: </p><br><pre> <code class="hljs pgsql">async resolve( source: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, args: {[argName: string]: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>}, context: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>: GraphQLResolveInfo, ) { const fields = fieldsList(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>, { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">'edges.node'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>: { phone: <span class="hljs-string"><span class="hljs-string">'phoneNumber'</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'fullName'</span></span> }, }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> connectionFromArray( await <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>.query(`<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ${fields.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">','</span></span>)} <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> users`), args ); }</code> </pre> <br><p>  E, no entanto, √†s vezes, a convers√£o para uma matriz plana de campos n√£o √© suficiente (por exemplo, se a fonte de dados retornar uma estrutura complexa com aninhamento).  Nesse caso, a fun√ß√£o <code>fieldsMap</code> da <code>fieldsMap</code> <code>graphql-fields-list</code> chegar√° ao resgate, que retorna a √°rvore inteira dos campos solicitados como um objeto: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { fieldsMap } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">`graphql-fields-list`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... some resolver implementation on `users`: resolve(arc, args, ctx, info) { const map = fieldsMap(info); /* RESULT: { edges: { node: { id: false, name: false, phone: false, } } } */ }</span></span></code> </pre> <br><p>  Se assumirmos que o usu√°rio √© descrito por uma estrutura complexa, obteremos tudo.  Esse m√©todo tamb√©m pode usar o argumento de <code>path</code> opcional, que permite obter um mapa apenas da ramifica√ß√£o necess√°ria de toda a √°rvore, por exemplo: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { fieldsMap } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">`graphql-fields-list`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... some resolver implementation on `users`: resolve(arc, args, ctx, info) { const map = fieldsMap(info, 'edges.node'); /* RESULT: { id: false, name: false, phone: false, } */ }</span></span></code> </pre> <br><p>  A transforma√ß√£o de nomes em cart√µes atualmente n√£o √© suportada e permanece √† merc√™ do desenvolvedor. </p><br><h2 id="fragmentaciya-zaprosov">  Fragmenta√ß√£o de Solicita√ß√£o </h2><br><p>  O GraphQL suporta fragmenta√ß√£o de consultas, por exemplo, podemos esperar que o consumidor nos envie essa solicita√ß√£o (aqui nos referimos ao esquema original, um pouco for√ßado, mas sintaticamente correto): </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> UsersFragmentedQuery { <span class="hljs-section"><span class="hljs-section">users</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> ...NamesFramgment ...ContactsFragment } } fragment NamesFragment <span class="hljs-literal"><span class="hljs-literal">on</span></span> User { <span class="hljs-attribute"><span class="hljs-attribute">name</span></span> } fragment AddressFragment <span class="hljs-literal"><span class="hljs-literal">on</span></span> User { <span class="hljs-attribute"><span class="hljs-attribute">address</span></span> } fragment ContactsFragment <span class="hljs-literal"><span class="hljs-literal">on</span></span> User { <span class="hljs-attribute"><span class="hljs-attribute">phone</span></span> email ...AddressFragment }</code> </pre> <br><p>  Nesse caso, voc√™ n√£o deve se preocupar, e <code>fieldsList(info)</code> e <code>fieldsMap(info)</code> nesse caso retornar√£o o resultado esperado, pois eles levam em considera√ß√£o a possibilidade de fragmentar solicita√ß√µes.  Portanto, <code>fieldsList(info)</code> retornar√° <code>['id', 'name', 'phone', 'email', 'address']</code> e <code>fieldsMap(info)</code> , respectivamente, retornar√°: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">phone</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">email</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">address</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><h2 id="ps">  PS </h2><br><p>  Espero que este artigo tenha ajudado a esclarecer algumas das nuances do trabalho com o GraphQL no servidor, e a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca graphql-fields-list</a> pode ajud√°-lo a criar solu√ß√µes ideais no futuro. </p><br><h2 id="upd-1">  UPD 1 </h2><br><p>  A vers√£o 1.1.0 da biblioteca foi lan√ßada - foi adicionado suporte para as <code>@skip</code> e <code>@include</code> nas solicita√ß√µes.  Por padr√£o, a op√ß√£o est√° habilitada, se necess√°rio, desabilite-a assim: </p><br><pre> <code class="javascript hljs">fieldsList(info, { <span class="hljs-attr"><span class="hljs-attr">withDirectives</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }) fieldsMap(info, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427399/">https://habr.com/ru/post/pt427399/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427389/index.html">Opera√ß√£o Vk 2.0. Um projeto de lei sobre agregadores de not√≠cias foi apresentado. O Yandex.News ser√° fechado se o servi√ßo n√£o mudar de propriet√°rio</a></li>
<li><a href="../pt427391/index.html">Dicas para juniores: construindo bons h√°bitos</a></li>
<li><a href="../pt427393/index.html">An√°lise de seguran√ßa sem fio corporativa</a></li>
<li><a href="../pt427395/index.html">"Vamos explicar: ou por que um programador matem√°tico deveria". Um livro sobre como n√£o perder aulas de matem√°tica</a></li>
<li><a href="../pt427397/index.html">Desenvolvimento de um conjunto de dados ac√∫stico para o treinamento de uma rede neural</a></li>
<li><a href="../pt427401/index.html">Shaders de dissolu√ß√£o e explora√ß√£o mundial</a></li>
<li><a href="../pt427403/index.html">API ReportingObserver: uma an√°lise do c√≥digo das p√°ginas da web sob uma nova perspectiva</a></li>
<li><a href="../pt427405/index.html">ES2018 - finalmente promete m√©todo</a></li>
<li><a href="../pt427407/index.html">Meta-agrupamento com minimiza√ß√£o de erros e por que acho que o c√©rebro funciona dessa maneira</a></li>
<li><a href="../pt427409/index.html">O livro "O brilhante √°gil. Gerenciamento flex√≠vel de projetos com Agile, Scrum e Kanban ¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>