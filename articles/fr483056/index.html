<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏼 🌼 👨🏿‍🤝‍👨🏽 Champs logiques dans les bases de données, existe-t-il un antidote? 💸 ⏰ 🤜🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Souvent, les tables contiennent un grand nombre de champs logiques, il n’existe aucun moyen de les indexer tous et l’efficacité de cette indexation es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Champs logiques dans les bases de données, existe-t-il un antidote?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483056/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gv/ls/ke/gvlskeckr84dlji3r0xb3pmnk1k.jpeg" width="500"></div><br>  Souvent, les tables contiennent un grand nombre de champs logiques, il n’existe aucun moyen de les indexer tous et l’efficacité de cette indexation est faible.  Néanmoins, pour travailler avec des expressions logiques arbitraires en SQL, un mécanisme d'indexation multidimensionnelle convient, qui sera discuté sous le chat. <br><a name="habracut"></a><br>  En SQL, les champs logiques sont utilisés principalement dans deux cas.  Tout d'abord, lorsque vous avez vraiment besoin d'un attribut binaire, par exemple, 'acheter / vendre' dans la table de transaction.  Ces attributs changent rarement au fil du temps. <br><br>  Deuxièmement, pour enregistrer l'état de la <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">machine d'état</a> qui décrit l'enregistrement.  Il est entendu qu'un objet logique correspondant à un enregistrement de table passe par une série d'états, dont le nombre et les transitions entre eux sont déterminés par la logique appliquée.  Un exemple simple est la technique de «suppression en douceur», lorsqu'un enregistrement n'est pas physiquement détruit, mais uniquement marqué comme supprimé. <br><br>  Si la machine est complexe, il peut y avoir une bonne quantité de tels champs, dans l'un de <a href="https://arqatech.com/ru/products/qort/">nos</a> tableaux, il y a 58 (+14 obsolètes) de tels champs (y compris les ensembles d'indicateurs) et ce n'est pas quelque chose qui sort de l'ordinaire.  Cela n'était pas prévu à l'origine, mais au fur et à mesure que le produit se développe et que les exigences externes changent, les machines correspondantes se développent, les développeurs vont et viennent, les analystes changent ... à un moment donné, il peut être plus sûr d'obtenir un nouveau drapeau, plutôt que de comprendre toutes les subtilités.  De plus, les données historiques se sont accumulées et leurs conditions doivent rester adéquates. <br><br><div class="spoiler">  <b class="spoiler_title">hors sujet</b> <div class="spoiler_text">  À certains égards, cela est similaire à un processus évolutif lorsqu'une masse d'informations / mécanismes sont stockés dans le génome qui, à première vue, ne sont pas du tout nécessaires, mais il est impossible de s'en débarrasser.  D'un autre côté, il vaut la peine de respecter ces mécanismes, car ce sont eux qui ont permis aux prédécesseurs évolutionnaires de survivre (y compris pendant les <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2581%25D1%2581%25D0%25BE%25D0%25B2%25D0%25BE%25D0%25B5_%25D0%25B2%25D1%258B%25D0%25BC%25D0%25B8%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">grandes extinctions</a> ) et de gagner la course évolutionnaire.  Encore une fois, qui sait où l'évolution nous mènera et ce qui s'avérera utile à l'avenir. <br></div></div><br>  Mettre un drapeau signifie non seulement ajouter un champ du type correspondant, mais aussi le prendre en compte dans le fonctionnement de l'automate, quels états il affecte, à quelles transitions il participe.  En pratique, cela ressemble à ceci: <br><br><ul><li>  un processus ou une série de processus, appelons-les «écrivains», créons de nouveaux enregistrements dans l'état initial (éventuellement dans l'un des états initiaux) </li><li>  un certain nombre de processus, appelons-les "lecteurs", de temps en temps ils lisent des objets qui sont dans les états dont ils ont besoin </li><li>  un certain nombre de processus, appelons-les «gestionnaires», surveillons des états spécifiques et, en fonction de la logique appliquée, modifions ces états.  C'est-à-dire  faire fonctionner une machine d'état. </li></ul><br>  Pour sélectionner des enregistrements dans un état particulier, il est rare que le filtrage par l'un des champs booléens soit suffisant.  Il s'agit généralement d'une expression entière, parfois non triviale.  Il semblerait que vous ayez besoin d'indexer ces champs et le processeur SQL le découvrira.  Mais pas si simple. <br><br>  Premièrement, il peut y avoir de nombreux champs booléens; les indexer tous serait trop inutile. <br><br>  Deuxièmement, il peut s’avérer inutile car  la sélectivité pour chacun des champs sera faible et la probabilité conjointe n'est pas couverte par les statistiques du processeur SQL. <br><br>  Supposons que dans la table T1, il existe deux champs booléens: F1 et F2 et la requête <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> F1, F2, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> F1, F2</code> </pre> <br>  donne <br><div class="scrollable-table"><table><tbody><tr><th>  F1 </th><th>  F2 </th><th>  COUNT </th></tr><tr><td>  faux </td><td>  faux </td><td align="center">  499 </td></tr><tr><td>  faux </td><td>  vrai </td><td align="center">  1 </td></tr><tr><td>  vrai </td><td>  faux </td><td align="center">  1 </td></tr><tr><td>  vrai </td><td>  vrai </td><td align="center">  499 </td></tr></tbody></table></div><br>  C'est-à-dire  bien que, selon F1 et F2, vrai et faux soient également probables, la combinaison (vrai, faux) ne tombe qu'une fois sur mille.  Par conséquent, si nous indexons F1 et F2 séparément <u>et les forçons à être utilisés dans la requête</u> , le processeur SQL devrait lire la moitié des deux indices et croiser les résultats.  Il peut être moins coûteux de lire l'intégralité du tableau et de calculer l'expression pour chaque ligne. <br><br>  Et même si vous collectez des statistiques sur les demandes traitées, cela ne sera pas très utile.  les statistiques spécifiques aux domaines responsables de l'état de la machine flottent beaucoup.  En effet, à tout moment un "handler" peut venir et transférer la moitié des lignes de l'état S1 à S2. <br><br>  Pour travailler avec de telles expressions, un indice multidimensionnel se suggère, dont l'algorithme a été <a href="https://habr.com/post/464057/">présenté précédemment</a> et s'est révélé assez bon. <br><br>  Mais vous devez d'abord comprendre comment une expression logique arbitraire se transformera en requête (s) pour l'index. <br><br><h4>  Forme normale disjonctive </h4><br>  Une requête unique vers un index multidimensionnel est un rectangle multidimensionnel qui limite l'espace de requête.  Si le champ participe à la demande, une restriction est définie pour celui-ci.  Sinon, le rectangle dans cette coordonnée n'est limité que par la largeur de cette coordonnée.  Les coordonnées logiques ont une capacité de 1. <br><br>  Une requête de recherche dans un tel index est une chaîne de &amp; (conjonction), par exemple, l'expression: v1 &amp; v2 &amp; v3 &amp; (! V4), équivalente à v1: [1,1], v2: [1,1], v3: [1, 1], v4: [0,0].  Et tous les autres champs ont une plage: [0,1]. <br><br>  Compte tenu de cela, notre regard se tourne immédiatement vers le <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25B7%25D1%258A%25D1%258E%25D0%25BD%25D0%25BA%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BD%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0">DNF</a> - l'une des formes canoniques d'expressions logiques.  On soutient que toute expression peut être représentée comme une disjonction de conjonctions littéraires.  Un littéral désigne ici un champ logique ou sa négation. <br><br>  En d'autres termes, grâce à de simples manipulations, toute expression logique peut être représentée comme une disjonction de plusieurs requêtes vers un index logique multidimensionnel. <br><br>  Il y a un MAIS.  Une telle transformation peut dans certains cas conduire à une augmentation exponentielle de la taille de l'expression.  Par exemple, la conversion de <br><br><img src="https://habrastorage.org/webt/sn/fg/gd/snfggdwldqn3fggm4ymvhrfa_xa.png"><br><br>  conduit à une expression de 2 ** n termes.  Dans de tels cas, le développeur de l'application doit réfléchir à la signification physique de ce qu'il fait et, de la part du processeur SQL, vous pouvez toujours refuser d'utiliser l'index logique si le nombre de conjonctions dépasse les limites raisonnables. <br><br><h4>  Algorithme d'indexation multidimensionnelle </h4><br>  Pour l'indexation multidimensionnelle, les propriétés d'une courbe de numérotation auto-similaire basée sur des simplexes hyper-cubiques avec le côté 2. <a href="https://habr.com/post/464057/">Il s'est avéré que</a> deux versions de ces courbes sont d'une importance pratique - la courbe Z et la courbe Hilbert. <br><br><img src="https://habrastorage.org/webt/ij/pk/p2/ijpkp2sneivmayqaie38y91mylc.png" alt="image"><br>  <i>Figure 1 Courbe Z bidimensionnelle, 3 et 6 itérations</i> <br><br><img src="https://habrastorage.org/webt/bo/ar/oq/boaroq7scpwqyvargccwvv6i7li.png" alt="image"><br>  <i>Figure 2 Courbe de Hilbert bidimensionnelle, 3 et 6 itérations</i> <br><br><ul><li>  Un simplexe à N dimensions avec le côté 2 a 2 ** n sommets et (2 ** n-1) transitions entre eux. </li><li>  Une itération élémentaire d'un simplex transforme chaque sommet d'un simplex en un simplex de niveau inférieur. </li><li>  Après avoir fait le nombre d'itérations nécessaire, nous pouvons construire un réseau hyper-cubique de n'importe quelle taille. </li><li>  De plus, chaque nœud de ce réseau aura son propre numéro unique - le chemin emprunté le long de la courbe de numérotation depuis son début.  De plus, chaque nœud de ce réseau a une valeur dans chacune des coordonnées.  En fait, la <u>courbe de numérotation traduit le point multidimensionnel en une valeur unidimensionnelle adaptée à l'indexation avec un arbre B régulier</u> . </li><li>  Tous les nœuds situés à l'intérieur d'un simplex de n'importe quel niveau se trouvent dans le même intervalle et cet intervalle ne coupe aucun simplex du même niveau. </li><li>  Par conséquent, tout rectangle de recherche (case) peut être divisé en un petit nombre de sous-requêtes hyper-cubiques, dans chacune desquelles l'index peut être lu par une recherche / traversée. <br></li><li>  À cela, nous ajoutons la magie du travail de bas niveau avec l'arbre B afin de ne pas faire de requêtes inutiles et ... l'algorithme est prêt. </li></ul><br>  Voici comment cela fonctionne dans la pratique: <br><br><img src="https://habrastorage.org/webt/to/hc/pq/tohcpqixfqjdnwh_hhnqlx8lgio.png"><br>  <i>Figure 3 Exemple de recherche dans un index bidimensionnel (courbe Z)</i> <br><br>  La figure 3 montre le partitionnement de l'étendue de recherche d'origine en sous-requêtes et les points trouvés.  Un indice bidimensionnel a été utilisé, construit sur un ensemble aléatoire et uniformément réparti de 100 000 000 de points [1 000 000, 1 000 000]. <br><br><h4>  Index multidimensionnel logique </h4><br>  Puisque nous parlons d'indexation multidimensionnelle, il est temps de penser à combien elle peut être multidimensionnelle?  Y a-t-il des limites objectives? <br><br>  Bien sûr, parce que l'arbre B a une organisation de page et pour être un arbre, au moins deux éléments doivent être garantis pour tenir sur la page.  Si vous prenez la page pour 8K, le stockage d'un élément ne peut pas dépasser 4K.  En 4K, sans compression, environ 1000 valeurs 32 bits conviennent.  C'est beaucoup, au-delà des limites de toute application raisonnable, on peut dire que les limites physiques ne sont pratiquement pas disponibles. <br><br>  Il y a un autre côté, chaque dimension supplémentaire n'est en aucun cas libre, elle prend de l'espace disque et ralentit le travail.  Du point de vue de la «signification physique», les champs qui changent en même temps doivent être inclus dans le même index et leur recherche va également de pair.  Il est inutile d'indexer tout de suite. <br><br>  Les champs logiques sont différents.  Comme nous l'avons vu, des dizaines de champs logiques peuvent être impliqués dans les mêmes mécanismes.  Et les coûts de stockage / lecture sont assez faibles.  Il y a une tentation de collecter tous les champs logiques dans un index et de voir ce qui se passe. <br><br>  Certes, il y a des nuances: <br><br><ul><li>  Jusqu'à présent, dans la valeur indexée, les chiffres de coordonnées différentes étaient mélangés, dans les chiffres les moins significatifs de la clé étaient les bits les moins significatifs des coordonnées ... Par conséquent, l'ordre des champs lors de l'indexation n'avait pas d'importance. </li><li>  Maintenant, un bit est dépensé pour stocker la valeur d'un champ logique.  C'est-à-dire  certains champs logiques iront à la fin de la clé, et certains au début.  Cela signifie que le filtrage par une partie des champs sera très efficace, et par certains, il sera très inefficace.  En fait, si nous effectuons une recherche dans l'ordre le plus bas, nous devrons lire l'index entier pour obtenir une réponse.  Mais cela (le plus probable) est mieux que de lire le tableau entier pour répondre à la même question. </li><li>  Il y a un problème de choix - tous les champs logiques sont égaux, mais certains seront plus égaux que d'autres.  De considérations générales, il est nécessaire d'examiner les distorsions des statistiques, plus le rapport vrai / faux pour un domaine particulier est élevé, plus la décharge dans laquelle sa valeur sera ancienne. </li><li>  Le partitionnement par type de courbe de numérotation disparaît, si auparavant il fallait choisir entre la courbe Z et la courbe de Hilbert, il n'y a pas de différence pratique sur les données mono-bit. </li><li>  NULLs.  Étant donné que NULL n'est pas une valeur inconnue, mais l'absence de toute valeur, ces enregistrements ne doivent pas être inclus dans l'index.  Dans les indices unidimensionnels, c'est ce qui se passe.  Mais dans notre cas, il peut s'avérer que certains des champs logiques contiennent des valeurs, d'autres non.  En conséquence, nous ne pouvons pas mettre cela dans l'indice car  l'algorithme de recherche ne sait pas travailler avec la logique ternaire.  Et donc, de tels enregistrements devraient être impossibles à insérer dans la table (s'il y a un index multidimensionnel, pas nécessairement logique, soit dit en passant) </li></ul><br>  Il est prévu qu'un index logique multidimensionnel peut dans certains cas ne pas fonctionner très efficacement.  À strictement parler, tout index peut fonctionner de manière inefficace si trop de données tombent dans la zone de recherche.  Mais pour un index multidimensionnel logique, cela est aggravé par la dépendance de l'ordre des champs décrit ci-dessus, lorsque, pour un petit résultat, vous devez lire l'index entier.  Dans la mesure où il s'agit d'un problème dans la pratique, seule l'expérience peut le montrer. <br><br><h4>  Expérience numérique </h4><br>  Construire un index: <br><br><ul><li>  l'index sera de 128 bits, c'est-à-dire  construit sur 128 champs logiques </li><li>  et contiendra 2 ** 30 éléments </li><li>  la valeur de l'élément d'index sera un nombre de 0 à 2 ** 30 </li><li>  la clé de l'élément d'index sera le même nombre décalé de 48 bits vers la gauche, c'est-à-dire  les champs logiques 48 à 78 seront remplis avec les chiffres du nombre dans le même ordre </li><li>  en conséquence, nous obtenons 30 champs logiques significatifs au milieu de la clé, les bits restants seront remplis 0 <br></li><li>  Chacun des champs booléens a des statistiques égales vrai / faux </li><li>  Tous sont statistiquement indépendants. </li></ul><br>  Recherche: <br><br><ul><li>  Chaque expérience correspond à la sélection de plusieurs champs logiques consécutifs et à leur affectation de valeurs de recherche.  Non pas parce que l'algorithme ne peut rechercher que dans des bandes, mais parce qu'il est possible de visualiser plus clairement les résultats de l'expérience, nous n'avons que deux dimensions - la largeur de la bande et sa position </li><li>  Un total de 24 séries d'expériences.  Dans chaque série, nous chercherons des valeurs où la bande de champs logiques de largeur correspondante N (de 1 à 24 bits) prend la valeur true. </li><li>  Dans chaque série, il y aura une sous-série d'expériences dans laquelle une bande de champs logiques d'une largeur sélectionnée est située avec différents décalages S depuis le début de la bande en 30 champs logiques significatifs.  Expériences totales (30-N) dans la sous-série. </li><li>  Dans chaque expérience, une recherche est effectuée pour tous les éléments de l'indice qui satisfont à la condition, c'est-à-dire  les champs avec des nombres dans l'intervalle [48 + S, 48 + S + N -1] seront recherchés dans l'intervalle [1,1], le reste dans l'intervalle [0,1] <br></li><li>  La recherche se fait à partir d'un démarrage à froid </li><li>  Le résultat est le nombre de pages de disque lues, y compris la mise en cache (4096 pages cache) </li><li>  Le contrôle du bon fonctionnement se fait de deux manières - le nombre d'éléments trouvés doit être égal à 2 ** (30-N) et dans les valeurs trouvées vous pouvez vérifier les chiffres correspondants <br></li></ul><br>  Alors <br><br><img src="https://habrastorage.org/webt/1p/5a/bn/1p5abn4kb0b6myjlusbnoen308w.png"><br>  <i>Figure 4 Résultats, le nombre de pages lues dans différentes séries</i> <br><br>  Par Y - le nombre de pages lues est reporté. <br>  Au X - passage des bandes de la catégorie des plus jeunes (48) aux seniors.  Des rayures de différentes largeurs sont signées et marquées de différentes couleurs. <br><br><img src="https://habrastorage.org/webt/lf/t0/7x/lft07xucczbi19oxdskdrvzb-ia.png"><br>  <i>Figure 5 Les mêmes données que la figure 4, une autre vue</i> <br><br>  X - décalage de bande <br>  Y - bande passante <br><br>  À noter: <br><br><ul><li>  bien que cela ne soit pas directement visible dans les images, l'index fonctionne correctement, il est visible à la fois dans le nombre d'éléments trouvés et dans le contenu des éléments eux-mêmes </li><li>  toutes les bandes d'une largeur ne dépassant pas 10 avec un décalage de 0 nécessitent une lecture continue de l'index </li><li>  les bandes d'une largeur de 1 à 18 avec une augmentation du décalage atteignent l'asymptote 2 ** (- N) de la taille de l'index entier, ce qui est logique </li><li>  pour les bandes plus larges de l'asymptote - la hauteur de l'arbre, il ne peut pas y avoir moins de lectures </li><li>  un peu plus de 1000 éléments sont placés sur la page de feuille d'index, cela peut être vu dans une bande de largeur 10, qui lors du décalage 0 ne nécessite plus de lire l'index entier, certaines pages peuvent être sautées </li><li>  le filtrage de bas niveau fonctionne étonnamment bien.  Considérez une bande d'une largeur de 10. Une option idéale pour une recherche est avec un décalage de 20 (un total de 30 champs significatifs), quand il n'y a aucun champ non défini dans le préfixe du tout, les données peuvent être trouvées avec un seul faisceau.  Dans cette situation, environ 1/1000 de l'index est lu pendant la recherche - 779 pages. <br>  Le cas intermédiaire est un décalage de 10, nous avons un préfixe et un suffixe de 10 champs inconnus.  Le nombre de pages est de 2484, seulement trois fois pire que dans le cas idéal. <br>  Et même dans le pire des cas, avec un décalage de 0 (un préfixe de 20 champs inconnus), vous pouvez ignorer certaines pages. </li></ul><br>  Dans l'ensemble, l'algorithme d'indexation multidimensionnelle peut être reconnu comme efficace même dans un cas aussi absurde.  <u>Mais l'option la plus infructueuse du point de vue de l'index logique est considérée - des états équiprobables dans tous les champs logiques indépendants.</u> <br><br><h4>  Expérience sur des données réelles </h4><br>  Tableau des <i>métiers</i> , total 278 479 918 lignes, données d'une des boucles de test. <br>  Les résultats de certaines requêtes dans le tableau ci-dessous: <br><br><div class="scrollable-table"><table><tbody><tr><th>  N </th><th>  Demande </th><th>  Le nombre de lignes en conséquence </th><th>  Lire les pages </th></tr><tr><td>  1 </td><td align="right">  IsProcessed == 0 &amp;&amp; NullStatus == 0 </td><td align="right">  6,273 </td><td align="right">  9 </td></tr><tr><td>  2 </td><td align="right">  IsProcessed == 0 &amp;&amp; NullStatus == 0 &amp;&amp; IsCoverage == 0 </td><td align="right">  6,273 </td><td align="right">  9 </td></tr><tr><td>  3 </td><td align="right">  IsCoverage == 1 &amp;&amp; QF_ICEBERG == 1 </td><td align="right">  1 388 128 </td><td align="right">  386 </td></tr><tr><td>  4 </td><td align="right">  PutStatus == 1 &amp;&amp; PayStatus == 0 </td><td align="right">  61 788 376 </td><td align="right">  16,486 </td></tr><tr><td>  5 </td><td align="right">  IsProcessed == 1 &amp;&amp; NullStatus == 0 &amp;&amp; <br>  QF_CURR_PFI == 0 &amp;&amp; QF_TERMINATION == 0 </td><td align="right">  278 473 645 </td><td align="right">  74 285 </td></tr><tr><td>  6 </td><td align="right">  IsProcessed == 1 &amp;&amp; PutStatus == 0 &amp;&amp; <br>  IsCoverage == 1 <br></td><td align="right">  1 650 240 </td><td align="right">  447 </td></tr><tr><td>  7 </td><td align="right">  QF_UNK3 == 0 &amp;&amp; QF_UNK4 == 0 </td><td align="right">  23 392 </td><td align="right">  19 </td></tr></tbody></table></div><br>  La lecture / le traitement d'une seule page prend en moyenne 0,8 ms. <br><br>  Il n'est pas nécessaire de décrire la signification de requêtes spécifiques, elles ne sont là que pour démontrer l'opérabilité.  Ce qui, soit dit en passant, est confirmé. <br><br>  Mais avant que cette technique puisse être d'une utilité pratique, il reste beaucoup à faire.  Donc, pour continuer. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483056/">https://habr.com/ru/post/fr483056/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483042/index.html">9 Conseils sur les performances de Vue</a></li>
<li><a href="../fr483048/index.html">Terminal Fun: 10 blagues de console classiques</a></li>
<li><a href="../fr483050/index.html">Top 5 des sociétés de développement ReactJS</a></li>
<li><a href="../fr483052/index.html">Pyramide au lieu d'une sphère: regroupement non standard d'atomes d'or</a></li>
<li><a href="../fr483054/index.html">«Il n'y aura pas de massacre» - l'histoire de la traduction de The Worm</a></li>
<li><a href="../fr483058/index.html">Résultats du sondage sur les vacances</a></li>
<li><a href="../fr483064/index.html">Vue pour le plus petit aka petit blog sur tous les canons</a></li>
<li><a href="../fr483066/index.html">Les 5 livres traditionnels de Bill Gates</a></li>
<li><a href="../fr483068/index.html">Rétro-ingénierie du populaire BattlEye anti-triche</a></li>
<li><a href="../fr483074/index.html">TensorRT 6.xxx - inférence hautes performances pour les modèles d'apprentissage en profondeur (détection et segmentation d'objets)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>