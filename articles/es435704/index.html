<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☔️ 🔥 🎊 Soluciones arquitectónicas para un juego móvil. Parte 2: Comando y sus colas 🕺🏾 👎🏽 🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la primera parte del artículo, examinamos cómo se debe organizar el modelo para que sea fácil de usar, pero depurarlo y atornillar interfaces es si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Soluciones arquitectónicas para un juego móvil. Parte 2: Comando y sus colas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435704/"><img src="https://habrastorage.org/webt/1n/ji/xq/1njixqpyay22mmuyckufhgouye8.jpeg"><br><br>  En la primera parte del artículo, examinamos cómo se debe organizar el modelo para que sea fácil de usar, pero depurarlo y atornillar interfaces es simple.  En esta parte consideraremos la devolución de comandos para cambios en el modelo, en toda su belleza y diversidad.  Como antes, la prioridad para nosotros será la conveniencia de la depuración, minimizando los gestos que un programador debe hacer para crear una nueva característica, así como la legibilidad del código para una persona. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soluciones arquitectónicas para un juego móvil.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1: modelo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soluciones arquitectónicas para un juego móvil.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3: Ver en el empuje del jet</a> <br><a name="habracut"></a><br><h2>  Por qué comando </h2><br>  El patrón de comando suena fuerte, pero de hecho es solo un objeto en el que se agrega y almacena todo lo necesario para la operación solicitada.  Elegimos este enfoque, al menos porque nuestros equipos serán enviados a través de la red, e incluso obtendremos algunas copias del estado del juego para uso oficial.  Entonces, cuando el usuario hace clic en el botón, se crea una instancia de la clase de comando y se envía al destinatario.  El significado de la letra C en la abreviatura MVC es algo diferente. <br><br><h2>  Predicción de resultados y verificación de comandos a través de la red. </h2><br>  En este caso, el código específico es menos importante que la idea.  Y aquí está la idea: <br><br>  Un juego respetuoso no puede esperar una respuesta del servidor antes de reaccionar al botón.  Por supuesto, Internet está mejorando y puedes tener un montón de servidores en todo el mundo, y conozco incluso un par de juegos exitosos que esperan una respuesta del servidor, uno de ellos es incluso Invocando Guerras, pero aún así no necesitas hacer eso.  Debido a que los retrasos de Internet móvil de 5-15 segundos son más propensos a ser la norma que una excepción, en Moscú al menos el juego debería ser realmente excelente para que los jugadores no le presten atención. <br><br>  En consecuencia, tenemos un estado de juego que representa toda la información necesaria para la interfaz, y los comandos se aplican inmediatamente y solo después de eso se envían al servidor.  Por lo general, los programadores de Java que trabajan duro se sientan en el servidor duplicando todas las nuevas funcionalidades una a una en otro idioma.  En nuestro proyecto "ciervo", su número llegó a 3 personas, y los errores cometidos al portar fueron una fuente constante de alegría evasiva.  En cambio, podemos hacerlo de manera diferente.  Ejecutamos en el servidor .Net y ejecutamos en el lado del servidor el mismo código de comando que en el cliente. <br><br>  El modelo descrito en el último artículo nos brinda una nueva oportunidad interesante para la autoevaluación.  Después de ejecutar el comando en el cliente, calcularemos el hash del cambio que ocurrió en el árbol GameState y lo aplicaremos al equipo.  Si el servidor ejecuta el mismo código de comando y el hash de los cambios no coincide, entonces algo salió mal. <br><br>  Primeras ventajas: <br><br><ul><li>  Esta solución acelera enormemente el desarrollo y minimiza el número de programadores de servidores. </li><li>  Si el programador cometió errores que condujeron a un comportamiento no determinista, por ejemplo, obtuvo el primer valor del Diccionario, o usó DateTime.now, y generalmente usó algunos valores que no están escritos explícitamente en los campos de comando, entonces cuando heh se inicia en el servidor, no coincidirán, y lo descubriremos </li><li>  El desarrollo del cliente puede llevarse a cabo por el momento sin un servidor.  Incluso puede entrar en alfa amigable sin tener un servidor.  Esto es útil no solo para los desarrolladores independientes que se pierden el juego de sus sueños por la noche.  Cuando estaba en Piksonik hubo un caso en el que el programador del servidor perdió todos los polímeros, y nuestro juego se vio obligado a sufrir moderación, teniendo en lugar del servidor un muñeco que defendía estúpidamente todo el estado del juego de vez en cuando. </li></ul><br>  Una desventaja que por alguna razón se subestima sistemáticamente: <br><br><ul><li>  Si el programador del cliente hizo algo mal y es invisible durante las pruebas, por ejemplo, la probabilidad de que haya productos en los cuadros misteriosos, entonces no hay nadie que escriba lo mismo por segunda vez y encuentre un error.  El código autoportable requiere una actitud mucho más responsable hacia las pruebas. </li></ul><br><h2>  Información de depuración detallada </h2><br>  Una de nuestras prioridades declaradas es la conveniencia de depuración.  Si durante la ejecución del equipo atrapamos la ejecución: todo está claro, retrocedemos el estado del juego, enviamos el estado completo a los registros y serializamos el comando que lo dejó caer, todo es conveniente y hermoso.  La situación es más complicada si tenemos una desincronización con el servidor.  Debido a que el cliente ya ha completado varios otros comandos desde entonces, y resulta que no solo descubre en qué estado se encontraba el modelo antes de ejecutar el comando que condujo al desastre, sino que realmente quiero hacerlo.  Clonar un estado de juego frente a cada equipo es demasiado complicado y costoso.  Para resolver el problema, complicamos el esquema cosido debajo del capó del motor. <br><br>  En el cliente no tendremos un estado de juego, sino dos.  El primero sirve como interfaz principal para renderizar, los comandos se aplican inmediatamente.  Después de eso, los comandos aplicados se ponen en cola para enviarlos al servidor.  El servidor realiza la misma acción por su parte y confirma que todo está bien y es correcto.  Una vez recibida la confirmación, el cliente toma el mismo comando y lo aplica al segundo estado del juego, llevándolo al estado que el servidor ya ha confirmado como correcto.  Al mismo tiempo, también tenemos la oportunidad de comparar el hash de los cambios realizados para que sea seguro, y también podemos comparar el hash completo de todo el árbol en el cliente, que podemos calcular después de ejecutar el comando, pesa un poco y se considera lo suficientemente rápido.  Si el servidor no dice que todo está bien, le pide al cliente detalles de lo que sucedió, y el cliente puede enviarle un segundo estado de juego serializado exactamente como se veía antes de que el comando se ejecutara con éxito en el cliente. <br>  La solución parece muy atractiva, pero da lugar a dos problemas que deben resolverse a nivel de código: <br><br><ul><li>  Entre los parámetros de comando, puede haber no solo tipos simples, sino también enlaces a modelos.  En otro estado de juego, exactamente en el mismo lugar se encuentran otros objetos del modelo.  Resolvemos este problema de la siguiente manera: antes de ejecutar el comando en el cliente, serializamos todos sus datos.  Entre ellos puede haber enlaces a modelos, que escribiremos en forma de Path to the model desde la raíz del estado del juego.  Hacemos esto ante el equipo, porque después de su ejecución los caminos pueden cambiar.  Luego enviamos esta ruta al servidor, y el estado del juego del servidor podrá obtener un enlace a su modelo en el camino.  De manera similar, cuando un equipo se aplica al segundo estado del juego, el modelo se puede obtener del segundo estado del juego. </li><li>  Además de los tipos y modelos elementales, un equipo puede tener enlaces a colecciones.  Diccionario &lt;clave, Modelo&gt;, Diccionario &lt;Modelo, clave&gt;, Lista &lt;Modelo&gt;, Lista &lt;Valor&gt;.  Para todos, tienen que escribir serializadores.  Es cierto que no puede precipitarse en esto, en un proyecto real, tales campos surgen sorprendentemente raramente. </li><li>  Enviar comandos al servidor de uno en uno no es una buena idea, porque el usuario puede producirlos más rápido de lo que Internet puede arrastrarlos de un lado a otro, en Internet deficiente crecerá el conjunto de comandos que el servidor no ha elaborado.  En lugar de enviar comandos uno a la vez, los enviaremos en lotes de varias piezas.  En este caso, después de recibir una respuesta del servidor de que algo salió mal, primero deberá aplicar al segundo estado todos los comandos anteriores del mismo paquete que fueron confirmados por el servidor, y solo luego borrar y enviar el segundo estado de control al servidor. </li></ul><br><h2>  Comodidad y facilidad para escribir comandos </h2><br>  El código de ejecución del comando es el segundo código más grande y el primero más responsable del juego.  Cuanto más simple y claro sea, y cuanto menos necesite el programador hacer un extra con sus manos para escribirlo, más rápido se escribirá el código, menos errores se cometerán y, muy inesperadamente, más feliz será el programador.  Coloco el código de ejecución directamente en el comando en sí, además de las piezas y funciones generales que se encuentran en clases de reglas estáticas separadas, con mayor frecuencia en forma de extensiones a las clases de modelo con las que trabajan.  Te mostraré un par de ejemplos de comandos de mi proyecto favorito, uno muy simple y el otro un poco más complicado: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> HexKingdoms { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FCSetSideCostCommand</span></span></span><span class="hljs-class"> :</span></span> HexKingdomsCommand { <span class="hljs-comment"><span class="hljs-comment">//              protected override bool DetaliedLog { get { return true; } } public FCMatchModel match; public int newCost; protected override void HexApply(HexKingdomsRoot root) { match.sideCost = newCost; match.CalculateAssignments(); match.CalculateNextUnassignedPlayer(); } } }</span></span></code> </pre> <br>  Y aquí está el registro que este comando deja después de sí mismo, si este registro no está deshabilitado para él. <br><br><pre> <code class="json hljs">[FCSetSideCostCommand id=<span class="hljs-number"><span class="hljs-number">1</span></span> match=FCMatchModel[<span class="hljs-number"><span class="hljs-number">0</span></span>] newCost=<span class="hljs-number"><span class="hljs-number">260</span></span>] Execute:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.0027546</span></span> Apply:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.0008689</span></span> { <span class="hljs-attr"><span class="hljs-attr">"LOCAL_PERSISTENTS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@changed"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"0"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"SIDE_COST"</span></span>:<span class="hljs-number"><span class="hljs-number">260</span></span>}, <span class="hljs-attr"><span class="hljs-attr">"1"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"POSSIBLE_COST"</span></span>:<span class="hljs-number"><span class="hljs-number">260</span></span>}, <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"POSSIBLE_COST"</span></span>:<span class="hljs-number"><span class="hljs-number">260</span></span>}}}}</code> </pre> <br>  La primera vez que se indica en el registro es el tiempo durante el cual se realizaron todos los cambios necesarios en el modelo, y la segunda es el tiempo durante el cual los controladores de interfaz resolvieron todos los cambios.  Esto debe mostrarse en el registro para no hacer accidentalmente algo terriblemente lento o para darse cuenta a tiempo si las operaciones comienzan a tomar demasiado tiempo simplemente por el tamaño del modelo en sí. <br><br>  Además de las llamadas a objetos persistentes en Id-shniks, que reducen en gran medida la legibilidad del registro, que, por cierto, podría haberse evitado aquí, el código de comando en sí y el registro que hizo con el estado del juego son increíblemente claros.  Tenga en cuenta que en el texto del comando el programador no realiza un solo movimiento adicional.  Todo lo que necesita lo hace el motor debajo del capó. <br><br>  Ahora veamos un ejemplo de un equipo más grande <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> HexKingdoms { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FCSetUnitForPlayerCommand</span></span></span><span class="hljs-class"> :</span></span> HexKingdomsCommand { <span class="hljs-comment"><span class="hljs-comment">//            protected override bool DetaliedLog { get { return true; } } public FCSelectArmyScreenModel screen; public string unit; public int count; protected override void HexApply(HexKingdomsRoot root) { if (count == 0 &amp;&amp; screen.player.units.ContainsKey(unit)) { screen.player.units.Remove(unit); screen.selectedUnits.Remove(unit); } else if (count != 0) { if (screen.player.units.ContainsKey(unit)) { screen.player.units[unit] = count; screen.selectedUnits[unit].count = count; } else { screen.player.units.Add(unit, count); screen.selectedUnits[unit] = new ReferenceUnitModel() { type = unit, count = count }; } } screen.SetSelectedReferenceUnits(); screen.player.CalculateUnitsCost(); var side = screen.match.sides[screen.side]; screen.match.CalculatePlayerAssignmentsAcceptablity(side); screen.match.CalculateNextUnassignedPlayer(screen.player); } } }</span></span></code> </pre> <br>  Y aquí está el registro dejado por el equipo: <br><br><pre> <code class="json hljs">[FCSetUnitForPlayerCommand id=<span class="hljs-number"><span class="hljs-number">3</span></span> screen=/UI_SCREENS[main] unit=militia count=<span class="hljs-number"><span class="hljs-number">1</span></span>] Execute:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.0065625</span></span> Apply:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.0004573</span></span> { <span class="hljs-attr"><span class="hljs-attr">"LOCAL_PERSISTENTS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@changed"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"UNITS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@set"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"militia"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}}, <span class="hljs-attr"><span class="hljs-attr">"ASSIGNED"</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>}}}, <span class="hljs-attr"><span class="hljs-attr">"UI_SCREENS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@changed"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"SELECTED_UNITS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@set"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"militia"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"@new"</span></span>:<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">"TYPE"</span></span>:<span class="hljs-string"><span class="hljs-string">"militia"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"REMARK"</span></span>:<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">"COUNT"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"SELECTED"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"DISABLED"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"HIGHLIGHT_GREEN"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"HIGHLIGHT_RED"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"BUTTON_ENABLED"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>}}}}}}}</code> </pre> <br>  Como dicen, es mucho más claro.  Tómese el tiempo para equipar al equipo con un registro conveniente, compacto e informativo.  Esta es la clave de tu felicidad.  El modelo debe funcionar muy rápido, por lo que utilizamos una variedad de trucos con métodos de almacenamiento y acceso a los campos.  Los comandos se ejecutan en el peor de los casos una vez por cuadro, de hecho, varias veces con menos frecuencia, por lo que haremos la serialización y deserialización de los campos de comando sin ningún tipo de fantasía, solo a través de la reflexión.  Solo clasificamos los campos por nombres para que el orden sea fijo, bueno, compilaremos la lista de campos una vez durante la vida del comando y leeremos y escribiremos usando métodos nativos C #. <br><br><h2>  Modelo de información para la interfaz. </h2><br>  Vamos a dar el siguiente paso para complicar nuestro motor, un paso que parece aterrador, pero simplifica enormemente la escritura y la depuración de las interfaces.  Muy a menudo, especialmente en el patrón MVP relacionado, el modelo contiene solo lógica de negocios controlada por el servidor, y la información sobre el estado de la interfaz se almacena dentro del presentador.  Por ejemplo, desea pedir cinco boletos.  Ya seleccionó su número, pero aún no ha hecho clic en el botón "ordenar".  La información sobre exactamente cuántos boletos ha elegido en el formulario se puede almacenar en algún lugar de los rincones secretos de la clase, lo que sirve como una junta entre el modelo y su pantalla.  O, por ejemplo, el jugador cambia de una pantalla a otra, pero nada cambia en el modelo, y dónde estaba cuando ocurrió la tragedia, el programador de depuración solo lo sabe por las palabras de un probador extremadamente disciplinado.  El enfoque es simple, comprensible, casi siempre usado y un poco malicioso, en mi opinión.  Porque si algo salió mal, el estado de este presentador, que condujo a un error, es absolutamente imposible de descubrir.  Especialmente si el error ocurrió en el servidor de batalla durante la operación por $ 1000, y no en el probador en un entorno controlado y reproducible. <br><br>  En lugar de este enfoque habitual, prohibimos que cualquier persona, excepto el modelo, contenga información sobre el estado de la interfaz.  Esto tiene, como de costumbre, ventajas y desventajas que deben ser combatidas. <br><br><ul><li>  <b>(+1)</b> La ventaja más importante, ahorrar meses de trabajo de programación: si algo sale mal, el programador simplemente carga el estado del juego antes del accidente y recibe exactamente el mismo estado no solo del modelo de negocio, sino de toda la interfaz hasta el último botón de la pantalla. </li><li>  <b>(+2)</b> Si algún equipo cambió algo en la interfaz, el programador puede ir fácilmente al registro y ver qué ha cambiado exactamente en un conveniente formulario json, como en la sección anterior. </li><li>  <b>(-1)</b> En el modelo aparece una gran cantidad de información redundante que no es necesaria para comprender la lógica comercial del juego y que el servidor no la necesita dos veces. </li></ul><br>  Para resolver este problema, marcaremos algunos campos como notServerVerified, se ve así, por ejemplo, así: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EDictionary&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, UIStateModel&gt; uiScreens { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UI_SCREENS.Get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PDictionaryModel&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, UIStateModel&gt; UI_SCREENS = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PDictionaryModel&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, UIStateModel&gt;() { notServerVerified = <span class="hljs-literal"><span class="hljs-literal">true</span></span> };</code> </pre> <br>  Esta parte del modelo y todo lo que está debajo se relacionará exclusivamente con el cliente. <br><br>  Si aún recuerda, los indicadores de lo que necesita exportar y lo que no se ve así: <br><br><pre> <code class="cpp hljs">[Flags] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ExportMode { all = <span class="hljs-number"><span class="hljs-number">0x0</span></span>, changes = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, serverVerified = <span class="hljs-number"><span class="hljs-number">0x2</span></span> }</code> </pre> <br>  En consecuencia, al exportar o calcular un hash, puede especificar si exporta el árbol completo o solo esa parte que el servidor verifica. <br><br>  La primera complicación obvia que surge de aquí es la necesidad de crear comandos separados que el servidor debe verificar y aquellos que no son necesarios, pero también hay otros que deben verificarse no del todo.  Para no cargar al programador con operaciones innecesarias para configurar el comando, intentaremos nuevamente hacer todo lo necesario con el capó del motor. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Command</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/** &lt;summary&gt;    ,      &lt;/summary&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModelRoot root)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">/** &lt;summary&gt;         &lt;/summary&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyClientSide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModelRoot root)</span></span></span><span class="hljs-function"> </span></span>{} }</code> </pre> <br>  El programador que crea el comando puede anular una o ambas funciones.  Todo esto, por supuesto, es maravilloso, pero ¿cómo puedo asegurarme de que el programador no estropeó nada, y si arruinó algo, ¿cómo puede ayudarlo a solucionarlo rápida y fácilmente?  Hay dos formas  Apliqué el primero, pero puede que te guste el segundo más. <br><br><h3>  Primera forma </h3><br>  Utilizamos las características interesantes de nuestro modelo: <br><br><ol><li>  El motor llama a la primera función, después de lo cual recibe un hash de cambios en la parte del estado del juego verificada por el servidor.  Si no hay cambios, entonces estamos tratando exclusivamente con el equipo del cliente. </li><li>  Obtenemos el hash modelo de cambios en todo el modelo, no solo el verificado por el servidor.  Si difiere del hash anterior, el programador cometió un error y cambió algo en la parte del modelo que el servidor no comprobó.  Rodeamos el árbol de estado y volcamos al programador como una ejecución de una lista completa de los campos notServerVerified = true y los que se encuentran debajo del árbol que él cambió. </li><li>  Llamamos a la segunda función.  Obtenemos del modelo un resumen de los cambios que ocurrieron en la parte marcada.  Si no coincide con el hash después de la primera llamada, en la segunda función el programador ha hecho algo.  Si queremos obtener un registro muy informativo en este caso, revertimos todo el modelo a su estado original, lo serializamos en un archivo, luego el programador será útil para la depuración, luego lo clonará completo (dos líneas - serialización-deserialización), y ahora primero aplicamos el primero función, luego confirmamos los cambios para que el modelo se vea sin cambios, después de lo cual aplicamos la segunda función.  Y luego exportamos todos los cambios en la parte comprobada por el servidor en forma de JSON y los incluimos en la ejecución abusiva, para que el programador avergonzado pueda ver de inmediato qué y dónde cambió, qué no se debe cambiar. </li></ol><br>  Parece, por supuesto, aterrador, pero de hecho son 7 líneas, porque las funciones que hacen esto es todo (excepto atravesar el árbol desde el segundo párrafo) estamos listos.  Y como se trata de recepción, podemos permitirnos actuar de manera no óptima. <br><br><h3>  Segunda forma </h3><br>  Un poco más brutal, ahora en ModelRoot tenemos un campo de bloqueo, pero podemos dividirlo en dos, uno bloqueará solo los campos marcados en el servidor y el otro solo los campos marcados.  En este caso, el programador que hizo algo mal recibirá una explicación al respecto de inmediato con un vínculo con el lugar donde lo hizo.  El único inconveniente de este enfoque es que si en nuestro árbol una propiedad modelo está marcada como desmarcada, entonces todo lo que se encuentra en el árbol debajo de él con respecto al cálculo de hashes y el control de cambios no se inspeccionará, incluso si cada campo no se marcó.  Un bloqueo, por supuesto, no mirará dentro de la jerarquía, lo que significa que todos los campos de la parte no marcada del árbol tendrán que estar marcados, y no funcionará en algunos lugares para usar las mismas clases en la interfaz de usuario y la parte habitual del árbol.  Como opción, tal construcción es posible (la escribiré simplificada): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameState</span></span></span><span class="hljs-class"> :</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RootModelData data; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RootModelLocal local; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RootModel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> locked { get; } }</code> </pre> <br>  Entonces resulta que cada subárbol tiene su propio bloqueo.  GameState hereda modelos, porque es más fácil que crear una implementación separada de la misma funcionalidad. <br><br><h3>  Mejoras necesarias </h3><br>  Por supuesto, el gerente responsable del procesamiento de los equipos tendrá que agregar una nueva funcionalidad.  La esencia de los cambios será que no todos los comandos se enviarán al servidor, sino solo aquellos que crean los cambios marcados.  El servidor de su lado no elevará todo el árbol de estado del juego, sino solo la parte que se verifica y, en consecuencia, el hash coincidirá solo para la parte que se verifica.  Cuando se ejecuta el comando, solo la primera de las dos funciones del comando se iniciará en el servidor, y al resolver referencias a modelos en el estado del juego, si la ruta conduce a una parte no verificable del árbol, se colocará un valor nulo en la variable del comando en lugar del modelo.  Todos los equipos que no envían se alinearán honestamente con los habituales, pero se considerarán confirmados.  Tan pronto como lleguen a la línea y no haya personas sin confirmar antes de ellos, se aplicarán inmediatamente al segundo estado. <br><br>  No hay nada fundamentalmente complicado en la implementación.  Es solo que la propiedad de cada campo del modelo tiene una condición más, un recorrido del árbol. <br><br>  Otro refinamiento necesario: necesitará una Fábrica separada para ParsistentModel en las partes marcadas y no marcadas del árbol y NextFreeId para ellas será diferente. <br><br><h2>  Comandos iniciados por el servidor </h2><br>  Hay algún problema si el servidor quiere enviar su comando al cliente, porque el estado del cliente en relación con el servidor ya podría avanzar unos pasos.  La idea principal es que si el servidor necesita enviar su comando, envía la notificación del servidor al cliente con la siguiente respuesta, y lo escribe en el campo para las notificaciones enviadas a este cliente.  El cliente recibe una notificación, forma un comando sobre la base y lo coloca al final de su cola, después de aquellos que se han completado en el cliente pero aún no han llegado al servidor.  Después de un tiempo, el comando se envía al servidor como parte del proceso normal de trabajo con el modelo.  Habiendo recibido este comando para el procesamiento, el servidor arroja la notificación fuera de la cola saliente.  Si el cliente no respondió a la notificación dentro del tiempo establecido con el siguiente paquete, se le envía un comando de reinicio.  Si el cliente que recibió la notificación se ha caído, se conecta más tarde o, por alguna razón, carga el juego, entonces el servidor convertirá todas las notificaciones en comandos antes de darle el estado, las ejecutará de su lado y solo después de eso le dará al cliente que se une su nuevo estado.  Tenga en cuenta que un jugador puede tener un estado conflictivo con recursos negativos cuando el jugador logró gastar el dinero exactamente en el momento en que el servidor se los quitó.  La coincidencia es poco probable, pero con una DAU grande, es casi inevitable.  Por lo tanto, la interfaz y las reglas del juego no deben morir en tal situación. <br><br><h2>  Comandos para ejecutar que necesita saber la respuesta del servidor </h2><br>  Un error típico es pensar que solo se puede obtener un número aleatorio del servidor.  Nada le impide tener el mismo generador de números pseudoaleatorio ejecutándose simultáneamente desde el cliente y el servidor, comenzando desde un sid común.  Además, la semilla actual se puede almacenar directamente en el estado del juego.  A algunos les puede resultar difícil sincronizar la respuesta de este generador.  De hecho, para esto es suficiente tener un número más en el mismo artículo, exactamente cuántos números se recibieron del generador hasta este momento.  Si su generador por alguna razón no converge, entonces tiene un error en alguna parte y el código no funciona de manera determinista.  Y este hecho no debe ocultarse debajo de la alfombra, sino que debe resolverse y buscar un error.  Para la gran mayoría de los casos, incluso las cajas misteriosas, este enfoque es suficiente. <br><br>  Sin embargo, hay momentos en que esta opción no es adecuada.  Por ejemplo, estás jugando un premio muy costoso y no quieres que el astuto compañero descompile el juego, y escribe un bot que te diga de antemano qué se caerá de la caja de diamantes si lo abres ahora mismo, y qué pasa si giras el tambor en otro lugar antes de eso.  Puede almacenar semillas para cada variable aleatoria por separado, esto protegerá contra la piratería frontal, pero no ayudará de ninguna manera a un bot que le diga cuántas cajas tiene el producto que necesita actualmente.  Bueno, el caso más obvio es que es posible que no desee brillar en la configuración del cliente con información sobre la probabilidad de algún evento raro.  En resumen, a veces es necesario esperar una respuesta del servidor. <br>  Dichas situaciones deben resolverse no a través de las capacidades adicionales del motor, sino dividiendo al equipo en dos: la primera prepara la situación y pone la interfaz en un estado de espera para notificaciones, la segunda en realidad, con la respuesta que necesita.  Incluso si bloquea estrictamente la interfaz entre ellos en el cliente, puede pasar otro comando, por ejemplo, una unidad de energía se restaurará a tiempo. <br><br>  Es importante comprender que tales situaciones no son la regla, sino la excepción.  De hecho, la mayoría de los juegos solo necesitan un equipo esperando una respuesta: GetInitialGameState.  Otro paquete de tales comandos es la interacción entre jugadores en un metajuego, GetLeaderboard, por ejemplo.  Todas las otras doscientas piezas son deterministas. <br><br><h2>  Almacenamiento de datos del servidor y el tema turbio de la optimización del servidor </h2><br>  Admito de inmediato que soy un cliente, y a veces he escuchado tales ideas y algoritmos de servidores de servidores familiares que ni siquiera se me han metido en la cabeza.  Al comunicarme con mis colegas, de alguna manera desarrollé una imagen de cómo debería funcionar mi arquitectura en el lado del servidor en el caso ideal.  Sin embargo: existen contraindicaciones, es necesario consultar con un servidor especializado. <br><br>  Primero sobre el almacenamiento de datos.  Es su lado del servidor el que puede tener restricciones adicionales.  Por ejemplo, se le puede prohibir el uso de campos estáticos.  Además, el código de comandos y modelos es autoportable, pero el código de propiedad en el cliente y en el servidor no tiene que coincidir en absoluto.  Allí se puede ocultar cualquier cosa, hasta la inicialización diferida de los valores de campo de la memoria caché, por ejemplo.  Los campos de propiedades también pueden recibir parámetros adicionales que son utilizados por el servidor, pero no afectan el trabajo del cliente. <br><br>  La primera diferencia cardinal del servidor: donde los campos se serializan y deserializan.  Una solución razonable es que la mayoría del árbol de estado se serializa en un gran campo binario o json.  Al mismo tiempo, algunos campos se toman de las tablas.  Esto es necesario porque los valores de algunos campos serán constantemente necesarios para que funcionen los servicios de interacción entre jugadores.  Por ejemplo, el ícono y el nivel se mueven constantemente por una variedad de personas.  Se guardan mejor en una base de datos regular.  Raramente, cuando alguien decide buscar en su territorio, necesitará un estado completo o parcial, pero detallado de una persona que no sea él. <br><br>  Además, extraer los campos de la base uno a la vez es inconveniente, y puede llegar a arrastrar todo durante mucho tiempo.  Una solución muy no estándar, disponible solo para nuestra arquitectura, puede consistir en el hecho de que el cliente, cuando ejecuta un comando, recopila información sobre todos los campos almacenados por separado en tablas cuyos captadores lograron tocar y agrega esta información al comando para que el servidor pueda generar este grupo de campos Una solicitud a la base de datos.  Por supuesto, con restricciones razonables, para no rogar por DDOS causado por programadores curvos que tocaron todo sin prestar atención. <br><br>  Con dicho almacenamiento separado, uno debería considerar los mecanismos de transaccionalidad cuando un jugador se arrastra a los datos de otro, por ejemplo, le roba dinero.  Pero en el caso general, lo hacemos mediante notificación.  Es decir, el ladrón recibe su dinero de inmediato, y la persona robada recibe una notificación con instrucciones para cancelar el dinero cuando se trata de eso. <br><br><h2>  Cómo se dividen los equipos entre servidores </h2><br>  Ahora es el segundo momento importante para el servidor.  Hay dos enfoques.  Al principio, para procesar cualquier solicitud (o un paquete de solicitudes), todo el estado se eleva desde la base de datos o caché a la memoria, se procesa y luego se devuelve a la base de datos.  Las operaciones se resuelven atómicamente en un grupo de servidores de ejecución diferentes, y solo tienen una base común, y aun así no siempre.  Como cliente, elevar todo el estado a cada equipo es impactante, pero vi cómo funciona, y funciona de manera muy confiable y escalable.  La segunda opción es que el estado una vez aumenta en la memoria y permanece allí hasta que el cliente se cae solo ocasionalmente agregando su estado actual a la base de datos.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No soy competente para decirle las ventajas y desventajas de este o aquel método. Será bueno que alguien en los comentarios me explique por qué el primero tiene derecho a la vida en general. La segunda opción plantea preguntas sobre cómo interactuar entre jugadores que por casualidad se criaron en diferentes servidores. Esto puede ser crítico, por ejemplo, si varios miembros del clan se están preparando para lanzar un ataque conjunto. No puede mostrar a otros el estado de su miembro del grupo con un retraso de 10 salvados. Desafortunadamente, no lo abriré aquí, la interacción a través de las notificaciones descritas anteriormente, los comandos de un servidor a otro, en este momento está fuera de turno para guardar el estado actual del jugador planteado allí. Si los servidores tienen el mismo nivel de disponibilidad desde diferentes lugares,y puede administrar el equilibrador, puede intentar transferir silenciosamente el reproductor de un servidor a otro. Si conoce mejor una solución, asegúrese de describirla en los comentarios.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Baila con el tiempo </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos con la pregunta, que realmente me gusta derribar a las personas en las entrevistas: aquí tiene un cliente y un servidor, cada uno tiene su propio reloj bastante preciso. </font><font style="vertical-align: inherit;">Cómo averiguar cuánto difieren. </font><font style="vertical-align: inherit;">Un intento de resolver este problema en una cafetería con una servilleta revela las mejores y peores cualidades de un programador. </font><font style="vertical-align: inherit;">El hecho es que el problema no tiene una solución formal matemáticamente correcta. </font><font style="vertical-align: inherit;">Pero el entrevistado es consciente de esto, por lo general, tome un minuto en el quinto y solo después de las preguntas principales. </font><font style="vertical-align: inherit;">Y la forma en que conoce esta idea y lo que hace a continuación, dice mucho sobre lo más importante de su personaje, lo que hará esta persona cuando comiencen los problemas reales en su proyecto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mejor solución que conozco me permite descubrir no la diferencia exacta, sino aclarar el rango en el que cae a través de muchas solicitudes de respuesta hasta el momento del mejor paquete que se ejecutó de cliente a servidor, más el tiempo del mejor paquete que se ejecutó de servidor a cliente. En total, esto le dará algunas decenas de milisegundos de precisión. Esto es muchas veces mejor de lo necesario para el metajuego del juego móvil, aquí no tenemos multijugador de realidad virtual o CS, pero todavía es bueno para el programador representar la escala y la naturaleza de las dificultades con la sincronización del reloj. Lo más probable es que sea suficiente para que sepa el retraso promedio tomado como un ping a la mitad, durante mucho tiempo con un límite de desviaciones de más del 30%.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La segunda situación interesante que es probable que encuentres es organizar un juego de deslizamiento y transferir el reloj a tu teléfono. En ambos casos, el tiempo en la aplicación cambiará dramáticamente y abruptamente, y esto debe resolverse correctamente. Al menos reinicie el juego, pero es mejor, por supuesto, no reiniciar después de cada deslizamiento, por lo que no puede usar el tiempo que ha pasado en la aplicación desde su lanzamiento.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En tercer lugar, la situación, por alguna razón, es un problema que algunos programadores deben comprender, aunque existe una solución correcta: las operaciones no pueden realizarse absolutamente en tiempo de servidor. Por ejemplo, comience la producción de bienes cuando llegue una solicitud de producción al servidor. De lo contrario, despídase de su determinismo y obtenga 35 mil desincronizaciones por día causadas por diferentes opiniones del cliente y el servidor sobre si ya es posible hacer clic en el premio. La decisión correcta es que el equipo registra información sobre el momento en que se ejecutó. El servidor, a su vez, verifica si la diferencia horaria entre la hora actual del servidor y la hora en el comando cae dentro del intervalo permitido, y si lo hace, ejecuta el comando por su parte usando el tiempo declarado por el cliente.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra tarea para la entrevista: Tiempo de espera después del cual el cliente intentará reiniciar - 30 segundos. ¿Cuáles son los límites de la diferencia horaria aceptable para el servidor? Consejo # 1: El intervalo no es simétrico. Consejo # 2: Vuelva a leer el primer párrafo de esta sección nuevamente, especifique cómo extender el intervalo para no detectar 3000 errores por día en los efectos de borde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que esto funcione de manera hermosa y correcta, es mejor agregar un parámetro adicional a los parámetros de llamada de comando: el tiempo de llamada.</font></font> Algo como esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> interface Command { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModelRoot root, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time)</span></span></span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y mi consejo para ti, por cierto, no uses tipos de Unidad nativos por tiempo en el modelo: te ahogarás. Es mejor almacenar UnixTime en tiempo de servidor, siempre que necesite tener a mano métodos de conversión a mano, y almacenarlos en el modelo en un campo PTime especial que difiera de PValue &lt;long&gt; solo en que al exportar a JSON agrega información redundante entre paréntesis que no se puede leer cuando Importar: Tiempo en un formato legible para humanos. No puedes obedecerme. Te lo advertí</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuarta situación: en el estado del juego, hay situaciones en las que un equipo debe iniciarse sin la participación de un jugador, a tiempo, por ejemplo, la recuperación de energía. Una situación muy común, de hecho. Quiero tener un campo, está practicando convenientemente. Por ejemplo, PTimeOut, en el que será posible grabar un punto en el tiempo después del cual se debe crear y ejecutar un comando. En el código, puede verse así:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModel</span></span></span><span class="hljs-class"> :</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PTimeOut RESTORE_ENERGY = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PTimeOut() {command = (model, property) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RestoreEnergyCommand() { model = model}} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> restoreEnergy { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RESTORE_ENERGY.Get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { RESTORE_ENERGY.Set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, value); }} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, durante la carga inicial del reproductor, el servidor primero debe provocar la creación y ejecución de todos estos comandos, y solo entonces debe entregar el estado al jugador. El peligro aquí es que todo esto interfiere con las notificaciones que el jugador podría recibir durante este tiempo. Por lo tanto, será necesario desenroscar primero el tiempo anterior a la hora de la primera notificación, si necesita extraer un montón de comandos al mismo tiempo, luego crear un comando desde la notificación en sí, luego desenroscar el tiempo hasta la próxima notificación, luego resolverlo y así sucesivamente. Si todo este feriado de la vida no encaja en el tiempo de espera del servidor, y esto es posible si el jugador recibió muchas notificaciones, escribimos el estado actual de la memoria a la base de datos y respondemos con un comando para volver a conectar con el cliente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos estos comandos deben de alguna manera aprender sobre lo que necesitan crear y ejecutar. Mi solución un poco crujiente pero conveniente es que el modelo tiene un desafío más, que se extiende por toda la jerarquía del modelo, que se mueve después de ejecutar cada comando y también en el temporizador. Por supuesto, esta es una sobrecarga adicional para caminar alrededor del árbol casi en una actualización, en lugar de eso, puede suscribirse o darse de baja del evento CurrentTime que sobresale del estado del juego con cada cambio en este campo:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCurrentTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time)</span></span></span></span>; } vs <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RootModel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> event Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt; setCurrentTime; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto es bueno, pero el problema es que los modelos que se eliminan del árbol de modelos para siempre y que contienen dicho campo permanecerán suscritos a este evento, y tendrán que resolverlo correctamente. </font><font style="vertical-align: inherit;">Antes de enviar un comando, verifique si todavía están en el árbol y si tienen un enlace débil a este evento o inversión de control, de modo que debido a esto no sean inaccesibles para GC.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apéndice 1, un caso típico tomado de la vida real </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tomo de los comentarios a la primera parte. En los juguetes, muy a menudo algunas acciones no tienen lugar inmediatamente después del comando al modelo, sino al final de algún tipo de animación. En nuestra práctica, hubo un caso en el que se abrieron las cajas misteriosas y, por supuesto, el dinero debería cambiar solo cuando la animación se desarrolla hasta el final. Uno de nuestros desarrolladores decidió simplificar su vida, y no cambiar el valor en el comando, pero decirle al servidor que cambió, y al final de la animación ejecutar una devolución de llamada, que corregirá los valores en el modelo a los deseados. Bien hecho, en resumen. Hizo estas cajas misteriosas durante dos semanas, y luego otros tres errores difíciles de atrapar que surgieron como resultado de su trabajo y tuvimos que pasar tres semanas más para completarlos, a pesar de que el tiempo para "reescribir como normal" fue, por supuesto, nadie pudo destacar. De lo cual se desprende vívidamenteCreo que la conclusión es que era mejor hacer todo desde el principio con una reactividad normal.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, mi decisión es algo como esto. Por supuesto, el dinero no se encuentra en un campo separado, sino que es uno de los objetos en el diccionario de inventario, pero esto no es tan importante en este momento. El modelo tiene una parte que es verificada por el servidor, y sobre la base de la cual funciona la lógica de negocios, y la otra que existe solo en el cliente. El dinero en el modelo principal se acumula inmediatamente después de tomar la decisión, y en la segunda parte de la lista de "presentación diferida", se crea un elemento por la misma cantidad que inicia la animación por el hecho de su aparición, y cuando la animación termina, se lanza un comando que elimina este elemento. Tal nota puramente del cliente "todavía no muestra esta cantidad". Y en un campo real, no solo se muestra el valor del campo, sino el valor del campo menos todos los aplazamientos del cliente. La división en esos dos equipos se hace porque¿Qué pasa si el cliente se reinicia después del primer equipo, pero antes del segundo todo el dinero recibido por el jugador estará en su cuenta sin ninguna marca y excepción? En el código, será algo como esto:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenMisterBox</span></span></span><span class="hljs-class"> :</span></span> Command { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BoxItemModel item; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> slot; <span class="hljs-comment"><span class="hljs-comment">//        ,  . public override void Apply(GameState state) { state.inventory[item.revardKey] += item.revardCount; } //       . public override void Apply(GameState state) { var cause = state.NewPersistent&lt;WaitForCommand&gt;(); cause.key = item.key; cause.value = item.value; state.ui.delayedInventoryVisualization.Add(cause); state.ui.mysteryBoxScreen.animations.Add(new Animation() {cause = item, slot = slot})); } } public class MysteryBoxView : View { /* ... */ public override void ConnectModel(MysteryBoxScreenModel model, List&lt;Control&gt; c) { model.Get(c, MysteryBoxScreenModel.ANIMATIONS) .Control(c, onAdd = item =&gt; animationFactory(item, OnComleteOrAbort =&gt; { AsincQueue(new RemoveAnimation() {cause = item.cause, animation = item}) }), onRemove = item =&gt; {} ) } } public class InventoryView : View&lt;InventoryItem&gt; { public Text text; public override void ConnectModel(InventoryItem model, List&lt;Control&gt; c) { model.GameState.ui.Get(c, UIModel.DELAYED_INVENTORY_VISUALIZATION). .Where(c, item =&gt; item.key == model.key) .Expression(c, onChange = (IList&lt;InventoryItem&gt; list) =&gt; { int sum = 0; for (int i = 0; i &lt; list.Count; i++) sum += list[i].value; return sum; }, onAdd = null, onRemove = null ) //      .Join (c, model.GameState.Get(GameState.INVENTORY).ItemByKey(model.key)) .Expression(c, (delay, count) =&gt; count - delay) .SetText(c, text); //     ,      ,   ,  ,   ,       ,     : model.inventory.CreateVisibleInventoryItemCount(c, model.key).SetText(c, text); } } public class RemoveDelayedInventoryVisualization : Command { public DelayCauseModel cause; public override void Apply(GameState state) { state.ui.delayedInventoryVisualization.Remove(cause); } } public class RemoveAnimation : RemoveDelayedInventoryVisualization { public Animation animation public override void Apply(GameState state) { base.Apply(state); state.ui.mysteryBoxScreen.animations.Remove(animation); } }</span></span></code> </pre> <br>  ¿Qué tenemos al final?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay dos vistas, en una de ellas se reproduce una animación, cuyo final está esperando que el dinero se muestre en una vista completamente diferente, que no tiene idea de quién y por qué quiere mostrar un significado diferente. Todo es reactivo. En cualquier momento, puede cargar el estado completo de GameState en el juego y comenzará a reproducirse exactamente desde donde lo dejamos, incluida la animación que se inicia. La verdad comenzará desde el principio, porque no borramos la etapa de animación, pero si realmente la necesitamos, podemos borrarla incluso.</font></font><br><br><h2>  Total </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diseñar la lógica empresarial del juego a través de modelos, equipos y archivos estáticos con reglas, encerrándolos por todos lados con hermosos registros detallados y generados automáticamente y adjuntando ejecuciones informativas de muchos errores típicos cometidos por un programador que muestra nuevas características, esta es, en mi opinión, la forma correcta de vivir. luz blanca Y no solo porque puede presentar nuevas funciones varias veces más rápido. Esto sigue siendo muy importante, porque si te resulta fácil descargar y depurar una nueva función, entonces el diseñador del juego tendrá tiempo de realizar varias veces más experimentos de diseño de juegos con los mismos programadores. Con el debido respeto a nuestro trabajo, depende de nosotros si el juego falla o no, pero si dispara o no depende de los gamedismos, y necesitan espacio para los experimentos.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y ahora te pido que respondas preguntas muy importantes para mí. </font><font style="vertical-align: inherit;">Si tiene ideas sobre cómo hacer lo que he hecho mal, o simplemente desea comentar mis respuestas, los estoy esperando en los comentarios. </font><font style="vertical-align: inherit;">Una propuesta de cooperación e instrucciones sobre numerosos errores de sintaxis, por favor en PM.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435704/">https://habr.com/ru/post/es435704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435694/index.html">Cómo y por qué optimizamos el algoritmo para limpiar cachés SLAB en el kernel de Linux</a></li>
<li><a href="../es435696/index.html">Antigüedades: 1997 Computer Advertising</a></li>
<li><a href="../es435698/index.html">Escribiendo tu propio buen administrador de memoria</a></li>
<li><a href="../es435700/index.html">8 peores preguntas de la entrevista de Vue.js</a></li>
<li><a href="../es435702/index.html">Los trolls de patentes comienzan y ganan: cómo me quedé sin un juego</a></li>
<li><a href="../es435706/index.html">Usamos rcm para implementar la configuración en cualquier carpeta</a></li>
<li><a href="../es435708/index.html">Fayal: un lugar de encuentro en el Atlántico</a></li>
<li><a href="../es435712/index.html">Procter & Gamble lanza una impresora de piel antienvejecimiento</a></li>
<li><a href="../es435714/index.html">Los desarrolladores ucranianos tuvieron acceso a los archivos de todas las cámaras Ring del mundo.</a></li>
<li><a href="../es435718/index.html">Bombeamos Angular NGSW usando lógica personalizada en Service Worker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>