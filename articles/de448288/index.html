<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚èØÔ∏è ü§öüèæ üßëüèΩ Verwenden von C ++ und Vorlagen mit einer variablen Anzahl von Argumenten beim Programmieren von Mikrocontrollern üßï üìí ‚ûñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ARM mit Cortex Mx-Kern (am Beispiel STM32F10x) 
 Der Mikrocontroller ARM Cortex M3 STM32F103c8t6 wird h√§ufig als 32-Bit-Mikrocontroller f√ºr Amateurpro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden von C ++ und Vorlagen mit einer variablen Anzahl von Argumenten beim Programmieren von Mikrocontrollern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448288/"><h4>  ARM mit Cortex Mx-Kern (am Beispiel STM32F10x) </h4><br><img align="left" src="https://habrastorage.org/webt/yc/qs/a7/ycqsa7jgxrku5z8pf2yv63n3cyk.jpeg" alt="KDPV">  Der Mikrocontroller ARM Cortex M3 STM32F103c8t6 wird h√§ufig als 32-Bit-Mikrocontroller f√ºr Amateurprojekte verwendet.  Wie f√ºr fast jeden Mikrocontroller gibt es ein SDK, einschlie√ülich C ++ - Header-Dateien zur Bestimmung der Peripherie des Controllers. <br><br>  Dort wird beispielsweise die serielle Schnittstelle als Datenstruktur definiert, und eine Instanz dieser Struktur befindet sich in dem f√ºr Register reservierten Adressbereich, und wir haben √ºber einen Zeiger auf eine bestimmte Adresse Zugriff auf diesen Bereich. <br><br>  F√ºr diejenigen, die dies noch nicht erlebt haben, werde ich ein wenig beschreiben, wie es definiert ist. Dieselben Leser, die damit vertraut sind, k√∂nnen diese Beschreibung √ºberspringen. <br><br>  Diese Struktur und ihre Instanz werden wie folgt beschrieben: <a name="habracut"></a><br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* =========================================================================*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> __IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> CR1; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; USART Control register 1, Address offset: 0x00 */</span></span> . . . __IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ISR; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; USART Interrupt and status register, ... */</span></span> } USART_TypeDef; <span class="hljs-comment"><span class="hljs-comment">// USART_Type   . /* =========================================================================*/ #define USART1_BASE (APBPERIPH_BASE + 0x00013800) . . . #define USART1 ((USART_TypeDef *) USART1_BASE) #define USART1_BASE 0x400xx000U</span></span></code> </pre> <br>  Weitere Details finden Sie hier <a href="">stm32f103xb.h ‚âà 800 kB</a> <br><br>  Wenn Sie nur die Definitionen in dieser Datei verwenden, m√ºssen Sie wie folgt schreiben (Beispiel f√ºr die Verwendung des Statusregisters f√ºr die serielle Schnittstelle): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ---------------------------------------------------------------------------- if (USART1-&gt;ISR &amp; (ONE_ISR_FLAG &amp; OTHER_ISR_FLAG)) { }</span></span></code> </pre><br>  Und Sie m√ºssen es verwenden, weil die vorhandenen propriet√§ren L√∂sungen CMSIS und HAL zu komplex sind, um in Amateurprojekten verwendet zu werden. <br><br>  Wenn Sie jedoch in C ++ schreiben, k√∂nnen Sie folgenderma√üen schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ---------------------------------------------------------------------------- USART_TypeDef &amp; Usart1 = *USART1; // ---------------------------------------------------------------------------- if (Usart1.ISR &amp; (ONE_ISR_FLAG &amp; OTHER_ISR_FLAG)) { }</span></span></code> </pre><br>  Eine ver√§nderbare Referenz wird mit einem Zeiger initialisiert.  Das ist eine kleine Erleichterung, aber angenehm.  Besser noch, nat√ºrlich eine kleine Wrapper-Klasse dar√ºber zu schreiben, w√§hrend diese Technik immer noch n√ºtzlich ist. <br><br>  Nat√ºrlich m√∂chte ich diese Wrapper-Klasse sofort √ºber eine serielle Schnittstelle (EUSART - erweiterter universeller serieller asinhronischer Reseiver-Sender) schreiben, die so attraktiv ist, √ºber erweiterte Funktionen verf√ºgt, einen seriellen asynchronen Transceiver und die M√∂glichkeit bietet, unseren kleinen Mikrocontroller mit einem Desktop-System oder Laptop, aber mit Mikrocontrollern zu verbinden Cortex zeichnet sich durch ein entwickeltes Taktsystem aus, und Sie m√ºssen davon ausgehen und dann die entsprechenden E / A-Pins f√ºr die Arbeit mit Peripherieger√§ten konfigurieren, da in der STM32F1xx-Serie wie in  legged andere Mikrocontrollern ARM Cortex k√∂nnen den Port-Pins zu Ein- oder Ausgang und arbeitet in der gleichen Zeit mit der Peripherie nicht nur konfigurieren. <br><br>  Beginnen wir mit dem Einschalten des Timings.  Das Taktsystem wird als RCC-Register zur Taktsteuerung bezeichnet und stellt auch eine Datenstruktur dar, deren deklariertem Zeiger ein bestimmter Adresswert zugewiesen ist. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* =========================================================================*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> . . . } RCC_TypeDef;</code> </pre><br>  Felder dieser Struktur werden wie folgt deklariert, wobei __IO fl√ºchtig definiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* =========================================================================*/</span></span> __IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> CR;</code> </pre><br>  entsprechen den Registern von RCC, und die einzelnen Bits dieser Register sind eingeschaltet oder die Taktfunktionen der Peripherie des Mikrocontrollers.  All dies ist in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation (pdf)</a> gut beschrieben. <br><br>  Ein Zeiger auf eine Struktur ist definiert als <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* =========================================================================*/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RCC ((RCC_TypeDef *)RCC_BASE)</span></span></code> </pre><br>  Das Arbeiten mit Registerbits ohne Verwendung des SDK sieht normalerweise folgenderma√üen aus: <br><br>  Hier ist die Aufnahme von Port A. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ---------------------------------------------------------------------------- RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPAEN;</span></span></code> </pre><br>  Sie k√∂nnen zwei oder mehr Bits gleichzeitig aktivieren <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ---------------------------------------------------------------------------- RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPAEN | RCC_APB2ENR_IOPBEN;</span></span></code> </pre><br>  Es sieht f√ºr C ++ etwas ungew√∂hnlich aus oder etwas Ungew√∂hnliches.  Es w√§re besser, anders zu schreiben, beispielsweise mit OOP. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ---------------------------------------------------------------------------- Rcc.PortOn(Port::A);</span></span></code> </pre><br>  Es sieht besser aus, aber im 21. Jahrhundert werden wir etwas weiter gehen, C ++ 17 verwenden und mit Vorlagen mit einer variablen Anzahl von Parametern schreiben, die noch sch√∂ner sind: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ---------------------------------------------------------------------------- Rcc.PortOn&lt;Port::A, Port::B&gt;();</span></span></code> </pre><br>  Wo Rcc wie folgt definiert ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ---------------------------------------------------------------------------- TRcc &amp; Rcc = *static_cast&lt;TRcc *&gt;RCC;</span></span></code> </pre><br>  Daraus werden wir beginnen, einen Wrapper √ºber die Taktregister zu bauen.  Zuerst definieren wir eine Klasse und einen Zeiger (Link) darauf. <br><br>  Zuerst wollte ich in den C ++ 11/14-Standard schreiben, indem ich die Parameter einer Funktionsvorlage rekursiv entpackte.  Ein guter Artikel dazu finden Sie am Ende des Artikels im Link-Bereich. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ============================================================================ enum class GPort : uint32_t { A = RCC_APB2ENR_IOPAEN, B = RCC_APB2ENR_IOPBEN, C = RCC_APB2ENR_IOPCEN, }; // ---------------------------------------------------------------------------- class TRcc: public ::RCC_TypeDef { private: TRcc() = delete; ~TRcc() = delete; // ======================================================================== public: template&lt;GPort... port&gt; inline void PortOn(void) //    (inline) { //    -Og  -O0 APB2ENR |= SetBits&lt;(uint32_t)port...&gt;(); } // ------------------------------------------------------------------------ #define BITMASK 0x01 //    ,   #define MASKWIDTH 1 //      .   //          #undef. private: //   (fold)   . template&lt;uint8_t bitmask&gt; inline constexpr uint32_t SetBits(void) { //   ,  GPort  enum // (, , bitmask    ). // static_assert(bitmask &lt; 16, " ."); return bitmask; } template&lt;uint8_t bit1, uint8_t bit2, uint8_t... bit&gt; inline constexpr uint32_t SetBits(void) { return SetBits&lt;bit1&gt;() | SetBits&lt;bit2, bit...&gt;(); } }; #undef BITMASK #undef MASKWIDTH // ------------------------------------------------------------------------ TRcc &amp; Rcc = *static_cast&lt;TRcc *&gt;RCC;</span></span></code> </pre><br>  Betrachten Sie den Aufruf, um die Port-Taktung zu aktivieren: <br><br><pre> <code class="plaintext hljs"> Rcc.PortOn&lt;GPort::A&gt;();</code> </pre><br>  GCC wird es in einer Reihe von Befehlen bereitstellen: <br><br><pre> <code class="plaintext hljs"> ldr r3, [pc, #376] ; (0x8000608 &lt;main()+392&gt;) ldr r0, [r3, #24] orr.w r0, r0, #4 str r0, [r3, #24]</code> </pre><br>  Hat es geklappt?  √úberpr√ºfen Sie als n√§chstes <br><br><pre> <code class="cpp hljs"> Rcc.PortOn&lt;GPort::A, GPort::B, GPort::C&gt;();</code> </pre><br>  Leider hat der nicht so naive GCC den nachfolgenden Rekursionsaufruf separat bereitgestellt: <br><br><pre> <code class="plaintext hljs"> ldr r3, [pc, #380] ; (0x8000614 &lt;main()+404&gt;) ldr r0, [r3, #24] orr.w r0, r0, #4 ; APB2ENR |= GPort::A str r0, [r3, #24] ldr r0, [r3, #24] orr.w r0, r0, #28 ; APB2ENR |= Gport::B | GPort::C str r0, [r3, #24] #24]</code> </pre><br>  Zur Verteidigung von GCC muss ich sagen, dass dies nicht immer der Fall ist, sondern nur in komplexeren F√§llen, die bei der Implementierung der E / A-Portklasse auftreten werden.  Nun, C ++ 17 hat es eilig zu helfen. Schreiben Sie die TRCC-Klasse mithilfe der integrierten Bildlauffunktionen neu. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ---------------------------------------------------------------------------- class TRcc: public ::RCC_TypeDef { private: TRcc() = delete; //     ,  ~TRcc() = delete; //    . // ======================================================================== public: template&lt;GPort... port&gt; inline void PortOn(void) //    (inline) { //    -Og  -O0 APB2ENR |= SetBits17&lt;(uint32_t)port...&gt;(); } // ------------------------------------------------------------------------ #define BITMASK 0x01 //    ,   #define MASKWIDTH 1 //      .   //          #undef. private: //   (fold)   . ++ 17. template&lt;uint8_t... bitmask&gt; inline constexpr uint32_t SetBits17(void) { return (bitmask | ...); //     ... | bit } }; #undef BITMASK #undef MASKWIDTH</span></span></code> </pre><br>  Nun stellte sich heraus: <br><br><pre> <code class="plaintext hljs">ldr r2, [pc, #372] ; (0x800060c &lt;main()+396&gt;) ldr r0, [r2, #24] orr.w r0, r0, #28 ; APB2ENR |= Gport::A | Gport::B | GPort::C str r0, [r3, #24]</code> </pre><br>  Und der Klassencode ist einfacher geworden. <br><br>  Fazit: Mit C ++ 17 k√∂nnen wir die Vorlagen mit einer variablen Anzahl von Parametern verwenden, um den gleichen Mindestbefehlssatz (auch wenn die Optimierung deaktiviert ist) zu erhalten, der bei Verwendung der klassischen Arbeit mit dem Mikrocontroller durch Registerdefinitionen erhalten wird. Gleichzeitig erhalten wir jedoch alle Vorteile einer starken C ++ - Typisierung und -√úberpr√ºfung w√§hrend der Kompilierung durch die Struktur der Basisklassen des Codes wiederverwendet und so weiter. <br><br>  Hier ist so etwas in C ++ geschrieben <br><br><pre> <code class="cpp hljs">Rcc.PortOn&lt;Port::A, Port::B, Port::C&gt;();</code> </pre><br>  Und der klassische Text auf Registern: <br><br><pre> <code class="cpp hljs">RCC-&gt;APB2 |= RCC_APB2ENR_IOPAEN | RCC_APB2ENR_IOPBEN;</code> </pre><br>  entfalten Sie in einem optimalen Satz von Anweisungen.  Hier ist der von GCC generierte Code (Optimierung aus -Og): <br><br><pre> <code class="plaintext hljs"> ldr r2, [pc, #372] ; (0x800060c &lt;main()+396&gt;) [  RCC] ldr r0, [r2, #0] ; r0 = RCC-&gt;APB2 // [  APB2] orr.w r0, r0, #160 ; r0 |= 0x10100000 str r0, [r2, #0] ; RCC-&gt;APB2 = r0</code> </pre><br>  Jetzt sollten Sie weiterarbeiten und die Klasse des Eingabe-Ausgabe-Ports schreiben.  Das Arbeiten mit E / A-Portbits wird durch die Tatsache erschwert, dass vier Bits f√ºr die Konfiguration eines Portabschnitts zugewiesen werden und daher 64 Bit Konfiguration f√ºr einen 16-Bit-Port erforderlich sind, die in zwei 32-Bit-CRL- und CRH-Register unterteilt sind.  Au√üerdem wird die Breite der Bitmaske gr√∂√üer als 1. Das Scrollen durch C ++ 17 zeigt hier jedoch seine Funktionen. <br><br><img align="right" src="https://habrastorage.org/webt/rm/d5/t8/rmd5t8zm3a6gd1lupw8j2tgiev0.jpeg" alt="Bild"><br><br>  Als n√§chstes werden die TGPIO-Klasse sowie Klassen f√ºr die Arbeit mit anderen Peripherieger√§ten, eine serielle Schnittstelle, I2C, SPI, DAP, Timer und vieles mehr geschrieben, die normalerweise in ARM Cortex-Mikrocontrollern vorhanden sind, und dann k√∂nnen sie mit solchen LEDs blinken. <br><br>  Aber mehr dazu in der n√§chsten Notiz.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellen des Projekts auf Github</a> . <br><br><h4>  Internetartikel zum Schreiben von Notizen </h4><br>  <a href="">Vorlagen mit einer variablen Anzahl von Argumenten in C ++ 11</a> . <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Innovationen in den Vorlagen</a> . <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Sprachinnovation 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1. Faltung und Ableitung</a> . <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste der Links zur Dokumentation f√ºr STM-Mikrocontroller</a> . <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Makros f√ºr variable Parameter</a> <br><br><h4>  Artikel √ºber Khabr, die mich dazu veranlassten, diese Notiz zu schreiben </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ampel auf Attiny13</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Julian Assange von der britischen Polizei festgenommen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raum als vage Erinnerung</a> <br><br>  Geschrieben am 04/12/2019 - Happy Cosmonautics Day! <br><br><p></p><div class="spoiler">  <b class="spoiler_title">PS</b> <div class="spoiler_text"><img align="left" src="https://habrastorage.org/webt/gd/om/mv/gdommv5nfl-wivrw_l6yki7a_ki.png" alt="STM32F103c8t6 in Stm CubeMx">  Bild STM32F103c8t6 von CubeMX. <br><br>  Als Ausgangspunkt wird der von der Eclips-Erweiterung f√ºr die Arbeit mit den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GNU MCU-Eclipse ARM Embedded-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STM CubeMX-Mikrocontrollern erstellte Text verwendet</a> , d. H. Es gibt Dateien mit Standardfunktionen C ++, _start () und _init (), Definitionen von Interruptvektoren stammen aus Eclipse MCU ARM Embedded und das Cortex M3-Kernregister sowie die Arbeitsdateien stammen aus einem Projekt von CubeMX. <br></div></div><p></p><br><div class="spoiler">  <b class="spoiler_title">PPS</b> <div class="spoiler_text">  Beim KDPV-Debugging mit dem STM32F103c8t6-Controller ist dargestellt.  Nicht jeder hat ein solches Board, aber es ist nicht schwierig, es zu kaufen. Dies w√ºrde jedoch den Rahmen dieses Artikels sprengen. <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448288/">https://habr.com/ru/post/de448288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448274/index.html">SMS-√úberwachung des Gewichts von drei Bienenst√∂cken f√ºr 35 US-Dollar</a></li>
<li><a href="../de448276/index.html">Wie die Alfa Bank in einer Zeit des Wandels lebt und was wir durch die Kombination von IT-Entwicklung und Alfa Lab geschafft haben</a></li>
<li><a href="../de448278/index.html">Technische Hypothek: Was und wem schuldet das Team?</a></li>
<li><a href="../de448280/index.html">Probefahrt nanoCAD SPDS Metalwork 1.2. Teil 2</a></li>
<li><a href="../de448286/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 455 (04/02/2019 - 04/04/2019)</a></li>
<li><a href="../de448290/index.html">3D-Druck als Teil des revolution√§ren Konzepts Shipyard 4.0</a></li>
<li><a href="../de448292/index.html">√ñffnen Sie die API zum Akzeptieren von P2P-√úbertragungen</a></li>
<li><a href="../de448294/index.html">Das Gesetz zur Isolation der Runen wird von der Staatsduma in drei Lesungen verabschiedet</a></li>
<li><a href="../de448296/index.html">Freiberuflich und finanziell: 5 M√∂glichkeiten, sich zwischen einem Kunden und einem Freiberufler niederzulassen</a></li>
<li><a href="../de448298/index.html">GLTF- und GLB-Grundlagen, Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>