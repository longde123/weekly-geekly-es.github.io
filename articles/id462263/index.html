<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏻 👌🏼 ✋🏽 Pedal ke lantai: buat manipulator kaki lain untuk PC 👩‍🍳 ⚕️ ⏮️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hanya sebulan yang lalu, saya menemukan artikel ini , yang menceritakan tentang mengayuh Vim. Beberapa saat kemudian, setelah lama belajar selama tiga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pedal ke lantai: buat manipulator kaki lain untuk PC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462263/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/y3/4b/ju/y34bjuvl5jcdfxml6kgtlpgkdy4.png"></div><br>  Hanya sebulan yang lalu, saya menemukan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> , yang menceritakan tentang mengayuh Vim.  Beberapa saat kemudian, setelah lama belajar selama tiga menit, saya mengetahui bahwa topik ini tidak lagi baru dan cukup populer.  Saya sendiri menggunakan Vim hanya dalam keadaan darurat (jika saya harus bekerja di konsol, saya lebih suka Nano), tetapi Anda dapat melakukan hal yang sama untuk aplikasi lain. <br><a name="habracut"></a><br>  Awalnya, saya ingin membuat artikel kecil, tapi saya mendapat seluruh tutorial tentang cara membuat perangkat ini dengan penulisan kode langkah-demi-langkah dan penjelasan tentang apa dan bagaimana.  Agar tidak mengembang artikel, di bawah spoiler akan ada berbagai informasi yang tampaknya menarik dan layak menjadi perhatian pendatang baru ke Arduino, pengguna mahir dan terutama terburu-buru mungkin tidak membuang waktu untuk itu.  Kode sumber lengkap juga disajikan di akhir artikel. <br><br><h2>  Mengapa saya membutuhkannya? </h2><br>  Jika Anda tidak ragu tentang perlunya dan kegunaan perangkat ini, maka Anda dapat melewati item ini.  Untuk selebihnya, saya pertama-tama ingin berbicara tentang prasyarat untuk membuat perangkat ini. <br><br>  Setiap saat, programmer dan desainer telah mencoba membuat antarmuka yang nyaman dan ramah-pengguna sehingga pengguna dapat bekerja dengan aplikasi menggunakan mouse dan keyboard tanpa masalah yang tidak perlu, jadi mengapa kita perlu manipulator lain?  Baiklah, mari kita melihat sedikit ke dalam sejarah, atau lebih tepatnya, pada awal abad ke-18, ketika alat musik seperti piano diciptakan.  Seperti yang Anda tahu, kata ini secara harfiah diterjemahkan sebagai "keras dan tenang," tetapi beberapa orang berpikir bahwa master Italia yang pandai menerima instrumen seperti itu, sebenarnya "memanfaatkan" harpsichord yang ada saat itu, yang memungkinkan untuk mengontrol volume suara sampai batas tertentu, tanpa mengambil tangan dari kunci. <br><br>  Ada banyak contoh.  Mobil memiliki pedal agar tidak melempar setir jika perlu menambahkan bensin.  Drum kit juga memiliki pedal untuk mengetuk bass drum dan simbal.  Dan apa yang bisa diberikan pedal saat menggunakan komputer?  Misalnya, Anda dapat mengatur beberapa kombinasi tombol pintas, atau bahkan menambahkan kunci yang tidak ada di sana, seperti menyalakan dan mematikan suara.  Pedal dapat membantu jika tangan Anda sibuk: Saya bermain gitar sendiri, dan kadang-kadang dengan iringan, akan sangat nyaman bagi saya untuk menggulung backing tanpa berusaha terus-menerus meraih keyboard.  Dan akhirnya, pengontrol dapat memberikan kemungkinan yang sama sekali tidak manusiawi dalam permainan: akan keren untuk membangun seluruh basis Anda dalam strategi dengan satu klik atau hancurkan musuh dengan kecepatan selusin detak per detik dalam penembak, bukan? <br><br>  Secara umum, saya harap saya meyakinkan Anda, yang berarti saatnya untuk mulai langsung ke pengembangan itu sendiri. <br><br><h2>  Sumber daya yang dibutuhkan </h2><br><ul><li>  <b>Sebenarnya, pedal.</b>  Beberapa kesulitan segera muncul karena saya tidak dapat memikirkan nama untuk pedal seperti itu.  Saya hanya tahu bahwa hal-hal seperti itu digunakan dalam mesin jahit.  Secara umum, atas permintaan <b>pedal listrik,</b> saya masih berhasil menemukan apa yang saya butuhkan di Aliexpress, dan tanpa berpikir dua kali, saya memesan 3 buah. <br></li><li>  <b>Pengendali</b>  Pedboard harus meniru keyboard dan, mungkin, mouse untuk dapat terhubung ke PC tanpa driver yang tidak perlu.  Untuk ini, papan Micro Arduino Pro sempurna, yang, meskipun tidak memiliki beberapa kesimpulan, itu dibuat sekompak mungkin.  Kami pergi ke Aliexpress yang sama, dan membeli versi Cina dari keajaiban ini. <br></li><li>  <b>Kabel.</b>  Untuk menempatkan 3 pedal di bawah meja, Anda membutuhkan setidaknya empat kawat dengan panjang setidaknya satu meter.  Di sini, saya pikir, masalah tidak boleh muncul. <br></li><li>  <b>RGB LED dan tombol.</b>  Yang pertama diperlukan untuk menunjukkan mode, dan yang kedua adalah untuk mengubahnya. <br></li><li>  Yah, tentu saja, kita membutuhkan Arduino IDE, besi solder dan lengan lurus. <br></li></ul><br><h2>  Diagram perangkat </h2><br>  Bahkan sebelum parsel tiba, saya mulai membuat diagram perangkat.  Meskipun ini dikatakan banyak, karena saya hanya harus menghubungkan pedal, dioda dan tombol.  Ternyata entah bagaimana seperti ini: <br><br><img src="https://habrastorage.org/webt/7m/o8/yw/7mo8ywvzsfwlefxt7f-4ijqtejm.jpeg"><br><br>  Untuk pedal, saya memutuskan untuk mengalokasikan 4 port PB1-PB4 sekaligus, yaitu, dua untuk kiri, dan dua untuk kaki kanan, meskipun sejauh ini saya hanya memiliki 3 pedal.Selain itu, mereka semua dalam kelompok yang sama dan berada di satu tempat.  Di bawah LED, saya mengambil output PD0, PD1 dan PD4, di bawah tombol - PD7. <br>  Dalam hal ini, kita tidak memerlukan resistor pull-up, jika Anda menggunakan resistor yang ada di controller.  Benar, kemudian, ketika Anda menekan tombol atau pedal, input akan rendah, dan ketika dilepaskan, itu akan tinggi, yaitu, tekanan akan terbalik, dan Anda tidak boleh melupakan ini. <br><br><h2>  Penulisan kode </h2><br>  Tahap ini adalah yang paling sulit: karena beberapa kesalahan dalam petunjuk saya menghapus bootloader beberapa kali dan sebagai hasilnya saya hampir gagal papan pada tingkat perangkat lunak.  Di bawah semua tahap pembuatan firmware dijelaskan secara rinci, bagi mereka yang hanya ingin mendapatkan kode yang berfungsi, itu akan berada di akhir artikel. <br><br><h3>  Persiapan </h3><br>  Pertama-tama kita perlu memahami apa itu pedal dalam hal program.  Saya memutuskan untuk memungkinkan untuk mengatur pedal salah satu dari dua mode - real-time dan pemicu.  Pada saat yang sama, setiap pedal memiliki dua program: yang pertama dilakukan ketika pedal dipegang secara real time atau dengan penekanan ganjil dalam mode pemicu, yang kedua adalah ketika pedal dilepaskan secara real time atau ketika pedal ditekan secara merata dalam mode pemicu.  Pedal juga memiliki port, keadaan, dan dua variabel - posisi saat ini di program 1 dan 2. Saya mendapatkan struktur ini: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> port; <span class="hljs-comment"><span class="hljs-comment">//   char state; //  ,   char oldState; //  ,   char pos1; //  1 char pos2; //  2 unsigned char type; //0 —   , 1 —  ; unsigned char act1[16]; // 1 unsigned char act2[16]; // 2 };</span></span></code> </pre> <br>  Arduino memiliki cukup banyak memori dan juga 8-bit, jadi yang terbaik adalah mencoba menggunakan char daripada int jika memungkinkan. <br><br>  Kita juga membutuhkan pustaka Keyboard standar untuk berfungsi sebagai keyboard. <br><br><h3>  Klik Memproses </h3><br>  Sekarang kita perlu membuat juru bahasa yang akan membaca data dari array dan mengirimkannya dalam bentuk penekanan tombol ke mesin, serta memilih beberapa nilai untuk berbagai perintah internal.  Kami membuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman</a> dengan kode kunci, dan melihat apa dan bagaimana kita bisa mengklik.  Saya tidak menggali lebih dalam dan mempelajari segala macam standar keyboard, karena informasi di sini bagi saya cukup untuk proyek semacam itu.  Babak pertama dicadangkan untuk karakter ASCII standar (meskipun beberapa dari mereka tidak dapat dicetak atau tidak digunakan), babak kedua adalah untuk berbagai kunci pengubah.  Bahkan ada kode terpisah untuk tombol kiri dan kanan, yang sangat menyenangkan, tetapi saya tidak melihat kode khusus untuk angka-angka dari nampad, meskipun, sejauh yang saya tahu, mereka dianggap secara khusus dalam sistem daripada angka biasa.  Mungkin kode mereka ada di suatu tempat di "lubang", di antara rentang, tetapi sekarang bukan tentang itu.  Jadi, kode terbesar adalah tombol atas - 218, yang berarti bahwa rentang 219-255 dapat dianggap gratis, baik, atau setidaknya tidak ada kunci penting. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pedalAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//255  ,     if (pedal1-&gt;type == 255) return; //     unsigned char *prg; //     char *pos; if (pedal1-&gt;type) { //       int current; if ((current = digitalRead(ports[num])) != oldState[num]) { if (!current) state[num] = !state[num]; oldState[num] = current; } if (!state[num]) { //act1 pos2[num] = 0; pos = &amp;(pos1[num]); prg = pedal1-&gt;act1; } else { //act2 pos1[num] = 0; pos = &amp;(pos2[num]); prg = pedal1-&gt;act2; } } else { //        if (!digitalRead(ports[num])) { //act1 pos2[num] = 0; pos = &amp;(pos1[num]); prg = pedal1-&gt;act1; } else { //act2 pos1[num] = 0; pos = &amp;(pos2[num]); prg = pedal1-&gt;act2; } } while (1) { if (prg[*pos] == 254) { // ,   *pos Keyboard.press(prg[++*pos]); } else if (prg[*pos] == 253) { // ,   *pos Keyboard.release(prg[++*pos]); } else if (prg[*pos] == 252) { //" ",    ++*pos; return; } else if (prg[*pos] == 251) { //       *pos+1 *pos = prg[*pos + 1]; return; } else if (prg[*pos] == 255 || prg[*pos] == 0) { // ,   return; } else { //   Keyboard.write(prg[*pos]); } //       ,     if (++*pos&gt;=16) pos = 0; } }</span></span></code> </pre><br>  Saya pikir bahkan orang yang tidak memiliki tingkat pengetahuan C tertinggi tidak akan memiliki pertanyaan tentang apa yang terjadi di sini.  Pertama, fungsi memilih pedal yang diinginkan dan menentukan, tergantung pada mode dan kondisi pedal, program mana yang harus dilakukan.  Saat membaca setiap elemen array, jika itu bukan karakter kontrol, fungsi Keyboard.write () dipanggil, yang mengemulasi menekan dan melepaskan kunci.  Karakter kontrol diproses secara terpisah dan diperlukan untuk menjepit kombinasi tombol dan menavigasi program. <br><br><div class="spoiler">  <b class="spoiler_title">Beberapa fitur mode keyboard</b> <div class="spoiler_text">  Keyboard.write () memiliki beberapa nuansa sederhana, tetapi tidak jelas untuk pemula, berdasarkan fakta bahwa kami mengirim data tidak dalam bentuk mentah, tetapi sebagai penekanan tombol.  Pertama, anehnya, tanpa driver tambahan, komputer hanya dapat menerima karakter dari keyboard yang ada di keyboard, yang berarti bahwa kami tidak akan dapat mengirim 0x03 (sinyal interupsi) atau 0x1B (awal urutan ESCAPE).  Kedua, kita dapat menyesuaikan huruf besar seperti pada tabel ASCII, tetapi mesin akan mendapatkan kombinasi tombol Shift + &lt;huruf kecil&gt;.  Ini bisa menjadi masalah jika CapsLock diaktifkan dan kami "secara tak terduga" akan menerima huruf kecil, bukan huruf besar dan sebaliknya.  Ketiga, kami tidak dapat menggunakan bahasa Rusia, juga bahasa lainnya.  Ini terjadi lagi karena hal-hal yang mengganggu seperti <b>kode kunci</b> .  Meskipun Keyboard.write () menerimanya sebagai argumen, kode yang sesuai dengan kunci yang ada dalam tata letak bahasa Inggris standar masih dikirim melalui USB, dan jika kami mencoba mengirim alfabet Cyrillic, kami tidak akan tahu apa.  Karena itu, jika kita ingin menyapa teman-teman kita yang berbahasa Rusia melalui Arduino, maka dalam kode kita perlu menulis "Ghbdtn", dan kemudian mengirimkannya, setelah memilih tata letak Rusia.  "Ucapan" seperti itu akan bekerja dalam tata letak Ukraina, tetapi dalam bahasa Bulgaria, terlepas dari kenyataan bahwa ada juga alfabet Cyrillic, tidak ada yang akan datang darinya, karena huruf-hurufnya ada di tempat yang sama sekali berbeda.  (Saya pernah mendengar pendapat bahwa bagi banyak pengembang Amerika dan Inggris tidak dapat dipahami bahwa seseorang bahkan mungkin perlu menggunakan beberapa tata letak, tetapi juga mengubahnya.) <br></div></div><br>  Jadi, kami memiliki juru bahasa dan pemahaman kasar tentang bagaimana pedalboard kami berinteraksi dengan komputer.  Sekarang kita perlu membawa semua ini ke keadaan firmware penuh dan memeriksa kinerja dengan satu pedal.  Jika Anda membuat instance dari pedal dan secara otomatis memanggil pedalAction (), maka secara teori kami akan menjalankan program yang ditentukan dalam struktur. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal1</span></span></span><span class="hljs-class"> = {</span></span><span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, world!\0"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ pinMode(<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//2 - INPUT_PULLUP,        Keyboard.begin(); } void loop() { pedalAction(); }</span></span></code> </pre><br>  Ngomong-ngomong, jangan pernah lupakan terminator nol dalam "program" ini jika panjangnya kurang dari ukuran array dan jika mereka bukan siklus, karena Arduino tidak hanya akan mencoba menginterpretasikan data yang tidak diatur, tetapi juga akan mengirimnya ke mesin dengan kecepatan tinggi, dan itu sama dengan memberi monyet keyboard. <br><br><h3>  Satu pedal baik, dan dua lebih baik </h3><br>  Sekarang saatnya berurusan dengan pemrosesan sinyal dari beberapa pedal, serta menambahkan mode switching.  Pada awal artikel, 4 port dialokasikan untuk pedal, yang masing-masing harus diizinkan untuk bekerja dalam tujuh mode.  Mengapa 7?  Karena tanpa menggunakan PWM, LED kami hanya bisa memberi 7 warna, dan yang kedelapan.  Jumlah ini cukup bagi pengguna rata-rata, tetapi dalam kasus-kasus ekstrem dapat dengan mudah ditingkatkan.  Jadi kita akan menyimpan pedal dalam array dua dimensi 7 x 4. Agar tidak menyumbat memori, nilai-nilai yang umum untuk beberapa struktur, seperti nomor port, dapat dikeluarkan dalam array yang terpisah.  Akibatnya, kami mendapatkan sesuatu seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> act1[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> act2[<span class="hljs-number"><span class="hljs-number">16</span></span>]; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[7][4] = {</span></span> { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-string"><span class="hljs-string">"Hello, world!\0"</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} } }; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ports[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pos1[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pos2[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> state[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> oldState[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  char curPedal = 0; //  </span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Keajaiban nomor 255</b> <div class="spoiler_text">  Anda mungkin memperhatikan bahwa dalam artikel nomor 255 sering muncul, di mana akan lebih logis untuk menempatkan 0. Ke depan, saya akan mengatakan bahwa ini diperlukan untuk kenyamanan menyimpan pedal di EEPROM, karena dari pabrik masing-masing selnya tidak mengandung 0, tetapi hanya 255, yang berarti bahwa angka ini akan jauh lebih nyaman digunakan untuk menunjukkan variabel yang tidak terdefinisi daripada 0, sehingga Anda tidak menimpa memori setiap kali. <br></div></div><br>  Penting bagi kita untuk mengetahui hanya tipe pedal dan dua program, jadi kita akan membiarkannya hanya secara langsung dalam struktur, biarkan otomasi melakukan sisanya.  Metode persiapan dan putaran sekarang akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ pinMode(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i : ports) pinMode(i, <span class="hljs-number"><span class="hljs-number">2</span></span>); Keyboard.begin(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((current = digitalRead(modeButton)) != last) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++mode &gt;= <span class="hljs-number"><span class="hljs-number">7</span></span>) mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (pedals[mode][<span class="hljs-number"><span class="hljs-number">0</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">1</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">2</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">3</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++mode &gt;= <span class="hljs-number"><span class="hljs-number">7</span></span>) { mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } last = current; digitalWrite(<span class="hljs-number"><span class="hljs-number">2</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b001</span></span>); digitalWrite(<span class="hljs-number"><span class="hljs-number">3</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b010</span></span>); digitalWrite(<span class="hljs-number"><span class="hljs-number">4</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { pos1[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos2[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; state[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; oldState[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } delay(<span class="hljs-number"><span class="hljs-number">50</span></span>); } curPedal = i; pedalAction } } }</code> </pre><br>  Pengontrol akan mempertimbangkan mode yang tidak digunakan jika tidak ada pedal tunggal yang dideklarasikan di dalamnya (mode = 255), yang berarti bahwa ketika dipukul, itu akan langsung menuju ke yang berikutnya, tetapi mode pertama akan selalu ada.  Ketika beralih mode, semua nilai dalam array dibatalkan, karena kita tidak perlu menyimpannya untuk setiap mode (kan?), Dan kemudian loop memotong semua pedal dan memanggil pedalAction untuk mereka. <br><br>  Juga, di awal metode pedalAction (), Anda perlu menambahkan baris berikut ini agar mengerti struktur mana yang harus ditangani: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal1</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mode</span></span></span><span class="hljs-class">][</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curPedal</span></span></span><span class="hljs-class">];</span></span></code> </pre><br>  Struktur pedal1 yang ada dapat dilepas sebagai tidak perlu. <br><br>  Semua ini juga berfungsi dengan baik, namun, saya menemui satu masalah: beberapa program tidak punya waktu untuk menerima klik pada kecepatan yang dikirim Arduino.  Solusi yang paling jelas adalah menambahkan kemampuan untuk mengatur penundaan antara tindakan jika perlu.  Hanya ketika kita duduk untuk menulis program untuk mikrokontroler bahwa semua chip, seperti multithreading perangkat keras, tetap berada di suatu tempat di sana, di komputer tingkat tinggi, ketika kita menambahkan penundaan, seluruh program berhenti hingga pengontrol menghitung jumlah siklus yang tepat.  Karena kita tidak memiliki multithreading, kita harus membuatnya. <br><br><h3>  Sulit dikatakan ya mudah dilakukan </h3><br>  Saya tidak menciptakan sepeda, tetapi mengambil perpustakaan ArduinoThread yang sudah jadi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat membaca sedikit tentang cara kerjanya dan mengunduhnya.  Anda dapat mengunduh perpustakaan dari Arduino IDE itu sendiri.  Singkatnya, ini memungkinkan Anda untuk secara berkala melakukan fungsi dengan interval tertentu, sementara tidak memungkinkan Anda untuk masuk ke loop tak terbatas jika eksekusi memakan waktu lebih lama dari interval.  Apa yang kamu butuhkan  Buat array lain dengan utas untuk setiap pedal: <br><br><pre> <code class="cpp hljs">Thread pedalThreads[<span class="hljs-number"><span class="hljs-number">6</span></span>] = {Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>)};</code> </pre><br>  Sekarang kita memiliki 6 utas virtual yang identik, tetapi pada saat yang sama mereka adalah objek yang berbeda. <br><br>  Mari kita menulis ulang siklus bypass pedal agar berfungsi dengan fungsi baru: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pedalThreads[i].shouldRun()) { curPedal = i; pedalThreads[i].run(); } } ...</code> </pre><br>  Sekarang nilai 252 dalam array program, yang sesuai dengan "tidak melakukan apa-apa," akan memberikan penundaan 10 milidetik (meskipun sebenarnya sedikit lebih, karena eksekusi kode juga membutuhkan waktu).  Menambahkan beberapa baris ke juru bahasa akan memungkinkan untuk mengatur penundaan pada beberapa "kuanta" ini, hanya menghabiskan 2 byte array: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait[num]) { wait[num]--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prg[*pos] == <span class="hljs-number"><span class="hljs-number">250</span></span>) { wait[num] = prg[++*pos]; } ...</code> </pre><br>  Tidak seperti perintah lain, instruksi ini harus ditambahkan tepat di awal penerjemah, yaitu, segera setelah "sementara (1) {", karena penundaan harus diproses sebelum penerjemah melanjutkan membaca program.  Array tunggu harus dideklarasikan dengan cara yang sama seperti yang dilakukan dengan port, status, dll.  dan juga mengatur ulang sel-selnya saat beralih mode, sehingga penundaan tidak pergi ke program lain. <br><br>  Sekarang, dengan kemungkinan pengaturan penundaan hingga 2,55 detik, masalah dengan definisi kunci oleh program seharusnya tidak muncul. <br><br><h3>  Pemrograman on-the-go </h3><br>  Pada prinsipnya, di sini dimungkinkan untuk menyelesaikan dengan kode dan mulai merakit perangkat, tetapi dalam hal ini, jika seseorang tiba-tiba ingin memprogram ulang pedal, ia harus membuka IDE Arduino, mengedit kode, dan mengunduh firmware lagi.  Tentu saja, opsi ini bukan yang terbaik, jadi saya memutuskan untuk menambahkan kemampuan untuk mengubah program dari port serial Arduino, dan menyimpan program itu sendiri di EEPROM.  Untuk bekerja dengan memori non-volatile, Anda harus menghubungkan EEPROM.h perpustakaan standar.  Kode mode pemrograman adalah sebagai berikut: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!digitalRead(modeButton)) { <span class="hljs-comment"><span class="hljs-comment">//  Serial.begin(9600); while (!Serial) { PORTD = 0b00000000 + (PORTD &amp; 0b11101100); delay(250); PORTD = 0b00010000 + (PORTD &amp; 0b11101100); delay(250); } Serial.println(F("***Programming mode***")); Serial.println(F("Write the command as &lt;m&gt; &lt;p&gt; &lt;c&gt;")); Serial.println(F("m - number of mode, one digit")); Serial.println(F("p - number of pedal, one digit")); Serial.println(F("c - command, it can be:")); Serial.println(F("\tr - read pedal info")); Serial.println(F("\tw - enter to writing mode and change pedal programm")); Serial.println(F("\te - erase pedal programm and delete it")); Serial.println(F("There are up to 7 modes and 6 pedals per mode can be configured")); Serial.println(F("Mode will be incative if there is no pedal configured in it")); while (1) { while (Serial.available()) { Serial.read(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(""); Serial.println(F("Enter command")); while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); delay(3); if (Serial.available() == 3) { int curMode = Serial.read() - 48; int curPedal = Serial.read() - 48; char cmd = Serial.read(); if (curMode &gt; 6 || curMode &lt; 0) { Serial.print(F("Mode must be in 0-6. You entered ")); Serial.println(curMode); continue; } if (curPedal &gt; 3 || curPedal &lt; 0) { Serial.print(F("Pedal must be in 0-3. You entered ")); Serial.println(curPedal); continue; } Serial.println(); if (cmd == 'r') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.print("type: "); int curAddress = beginAddress; Serial.println(EEPROM[curAddress++]); Serial.print("act1: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.print("act2: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); } else if (cmd == 'w') { Serial.println(F("Enter type:")); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); while (!Serial.available()); int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); int curAddress = beginAddress; PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[curAddress++] = (char)Serial.parseInt(); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Enter act1 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.println(F("Enter act2 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Finished, don't forget to verify written data!")); } else if (cmd == 'e') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.println(F("Disabling pedal...")); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[beginAddress] = 255; PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Pedal disabled")); } } else { Serial.println(F("Incorrect command, please read help above")); } }; } ...</span></span></code> </pre><br>  Apa yang dilakukan kode ini dijelaskan oleh bantuan yang terkandung di dalamnya: nomor spasi dimasukkan untuk nomor mode, nomor pedal, dan perintah, yang ada 3 - membaca, menulis, dan <s>mengeksekusi</s> penghapusan program.  Semua data pada pedal disimpan satu demi satu dalam urutan 33 byte, yaitu jenis pedal, dan dua program, dan bahwa kami menempati 7 * 4 * 33 = 924 dari 1024 byte EEPROM.  Saya membuang opsi menggunakan ukuran dinamis dari pedal dalam memori, karena dalam hal ini ketika memprogram ulang satu pedal Anda harus menimpa hampir semua sel, dan ada sejumlah siklus penulisan ulang yang terbatas, jadi kami sarankan melakukan ini sesedikit mungkin. <br><br><div class="spoiler">  <b class="spoiler_title">Fitur kerja dengan EEPROM</b> <div class="spoiler_text">  Saya juga ingin menarik perhatian pada garis-garis bentuk: <br><pre> <code class="cpp hljs"> PORTD = <span class="hljs-number"><span class="hljs-number">0b00000010</span></span> + (PORTD &amp; <span class="hljs-number"><span class="hljs-number">0b11101100</span></span>); ... PORTD = <span class="hljs-number"><span class="hljs-number">0b00000001</span></span> + (PORTD &amp; <span class="hljs-number"><span class="hljs-number">0b11101100</span></span>);</code> </pre><br>  Berkat pustaka ini, dari sudut pandang programmer, memori non-volatile adalah array char biasa, tetapi, sebagai "Arduino", kita perlu memahami bahwa menulis ke ROM adalah operasi yang sangat sulit, yang memakan waktu ~ 3 detik dari controller, dan disarankan untuk tidak menghentikan ini proses.  Desain ini membuat dioda bersinar merah selama operasi tersebut, dan kemudian mengembalikan warna hijau "aman". <br></div></div><br>  Dalam mode perekaman program, input dibuat langsung oleh nilai byte dalam sistem angka desimal dengan spasi.  Ternyata sangat parah, tetapi Anda tidak perlu menulis parser yang rumit.  Selain itu, pemrograman ulang tidak sering terjadi, dan dalam kasus ini sangat mungkin untuk melihat tabel ASCII. <br><br>  Dengan pelestarian struktur yang diurutkan, sekarang kita perlu mengeluarkan data dari sana dan mengubahnya menjadi tampilan "pedal": <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; j++) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">][</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">j</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginAddress = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct pedal) * (i * <span class="hljs-number"><span class="hljs-number">6</span></span> + j); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curAddress = beginAddress; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> type = EEPROM[curAddress++]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == <span class="hljs-number"><span class="hljs-number">0</span></span> || type == <span class="hljs-number"><span class="hljs-number">1</span></span>) { p-&gt;type = type; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span> ; k &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; k++) { p-&gt;act1[k] = EEPROM[curAddress++]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span> ; k &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; k++) { p-&gt;act2[k] = EEPROM[curAddress++]; } } } } ...</code> </pre><br>  Tidak ada hal supernatural yang terjadi di sini: controller membaca data dari memori dan mengisi struktur yang ada dengannya. <br><br>  Keuntungan pemrograman melalui UART adalah kita kembali tidak memerlukan driver khusus, sehingga Anda dapat mengatur perilaku manipulator bahkan dari telepon. <br><br><h2>  Demonstrasi </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pkjtRLlNZnU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Kode sumber lengkap </h2><br><div class="spoiler">  <b class="spoiler_title">Dia disini</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Keyboard.h&gt; #include &lt;Thread.h&gt; #include &lt;EEPROM.h&gt; #define modeButton 6 struct pedal { unsigned char type; //0 —   , 1 —  , 255 —    unsigned char act1[16]; unsigned char act2[16]; }; struct pedal pedals[7][4] = { { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} } }; char ports[4] = {8, 16, 15, 14}; char pos1[4] = {0, 0, 0, 0}; char pos2[4] = {0, 0, 0, 0}; char state[4] = {0, 0, 0, 0}; char oldState[4] = {0, 0, 0, 0}; char wait[4] = {0, 0, 0, 0}; void pedalAction(); char mode = 0; char curPedal; Thread pedalThreads[6] = {Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10)}; void setup() { pinMode(2, 1); pinMode(3, 1); pinMode(4, 1); pinMode(modeButton, 2); if (!digitalRead(modeButton)) { //  Serial.begin(9600); while (!Serial) { PORTD = 0b00000000 + (PORTD &amp; 0b11101100); delay(250); PORTD = 0b00010000 + (PORTD &amp; 0b11101100); delay(250); } Serial.println(F("***Programming mode***")); Serial.println(F("Write the command as &lt;m&gt; &lt;p&gt; &lt;c&gt;")); Serial.println(F("m - number of mode, one digit")); Serial.println(F("p - number of pedal, one digit")); Serial.println(F("c - command, it can be:")); Serial.println(F("\tr - read pedal info")); Serial.println(F("\tw - enter to writing mode and change pedal programm")); Serial.println(F("\te - erase pedal programm and delete it")); Serial.println(F("There are up to 7 modes and 6 pedals per mode can be configured")); Serial.println(F("Mode will be incative if there is no pedal configured in it")); while (1) { while (Serial.available()) { Serial.read(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(""); Serial.println(F("Enter command")); while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); delay(3); if (Serial.available() == 3) { int curMode = Serial.read() - 48; int curPedal = Serial.read() - 48; char cmd = Serial.read(); if (curMode &gt; 6 || curMode &lt; 0) { Serial.print(F("Mode must be in 0-6. You entered ")); Serial.println(curMode); continue; } if (curPedal &gt; 3 || curPedal &lt; 0) { Serial.print(F("Pedal must be in 0-3. You entered ")); Serial.println(curPedal); continue; } Serial.println(); if (cmd == 'r') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.print("type: "); int curAddress = beginAddress; Serial.println(EEPROM[curAddress++]); Serial.print("act1: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.print("act2: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); } else if (cmd == 'w') { Serial.println(F("Enter type:")); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); while (!Serial.available()); int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); int curAddress = beginAddress; PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[curAddress++] = (char)Serial.parseInt(); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Enter act1 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.println(F("Enter act2 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Finished, don't forget to verify written data!")); } else if (cmd == 'e') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.println(F("Disabling pedal...")); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[beginAddress] = 255; PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Pedal disabled")); } } else { Serial.println(F("Incorrect command, please read help above")); } }; } for (int i : ports) pinMode(i, 2); pinMode(17, 1); for (int i = 0; i &lt; 7; i++) { for (int j = 0; j &lt; 4; j++) { struct pedal *p = &amp;pedals[i][j]; int beginAddress = sizeof(struct pedal) * (i * 6 + j); int curAddress = beginAddress; unsigned char type = EEPROM[curAddress++]; if (type == 0 || type == 1) { p-&gt;type = type; for (int k = 0 ; k &lt; 16; k++) { p-&gt;act1[k] = EEPROM[curAddress++]; } for (int k = 0 ; k &lt; 16; k++) { p-&gt;act2[k] = EEPROM[curAddress++]; } } } } Keyboard.begin(); } int last = 0; void loop() { int current; if ((current = digitalRead(modeButton)) != last) { if (!current) { if (++mode &gt;= 7) mode = 0; while (pedals[mode][0].type == 255 &amp;&amp; pedals[mode][1].type == 255 &amp;&amp; pedals[mode][2].type == 255 &amp;&amp; pedals[mode][3].type == 255) if (++mode &gt;= 7) { mode = 0; break; } } last = current; digitalWrite(2, (mode + 1) &amp; 0b001); digitalWrite(3, (mode + 1) &amp; 0b010); digitalWrite(4, (mode + 1) &amp; 0b100); for (int i = 0; i &lt; 4; i++) { pos1[i] = 0; pos2[i] = 0; state[i] = 0; oldState[i] = 0; wait[i] = 0; } delay(50); } for (int i = 0; i &lt; 4; i++) { if (pedalThreads[i].shouldRun()) { curPedal = i; pedalThreads[i].run(); } } } void pedalAction() { struct pedal *pedal1 = &amp;pedals[mode][curPedal]; if (pedal1-&gt;type == 255) return; unsigned char *prg; char *pos; if (pedal1-&gt;type) { int current; if ((current = digitalRead(ports[curPedal])) != oldState[curPedal]) { if (!current) state[curPedal] = !state[curPedal]; oldState[curPedal] = current; } if (!state[curPedal]) { //act1 pos2[curPedal] = 0; pos = &amp;(pos1[curPedal]); prg = pedal1-&gt;act1; } else { //act2 pos1[curPedal] = 0; pos = &amp;(pos2[curPedal]); prg = pedal1-&gt;act2; } } else { if (!digitalRead(ports[curPedal])) { //act1 pos2[curPedal] = 0; pos = &amp;(pos1[curPedal]); prg = pedal1-&gt;act1; } else { //act2 pos1[curPedal] = 0; pos = &amp;(pos2[curPedal]); prg = pedal1-&gt;act2; } } while (1) { if (wait[curPedal]) { wait[curPedal]--; return; } else if (prg[*pos] == 250) { wait[curPedal] = prg[++*pos]; } else if (prg[*pos] == 254) { // ,   *pos Keyboard.press(prg[++*pos]); } else if (prg[*pos] == 253) { // ,   *pos Keyboard.release(prg[++*pos]); } else if (prg[*pos] == 252) { delay(10); //" ",    ++*pos; return; } else if (prg[*pos] == 251) { //       *pos+1 *pos = prg[*pos + 1]; return; } else if (prg[*pos] == 255 || prg[*pos] == 0) { // ,   return; } else { //   Keyboard.write(prg[*pos]); } //       ,     if (++*pos &gt;= 16) pos = 0; } }</span></span></span></span></code> </pre><br></div></div><br><h2>  Kata penutup </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun pada awalnya saya membuat pedalboard untuk kemungkinan menggulung rekaman sambil bermain gitar, namun, secara pribadi saya merasa nyaman menggunakan pedal dalam tugas-tugas biasa, hal utama adalah sedikit terbiasa dengan manipulator yang tidak biasa. </font><font style="vertical-align: inherit;">Dan di sini ada masalah lain: tanpa pedal favorit, bekerja sebaliknya menjadi lebih sulit, karena Anda harus mengingat apa, di mana dan mengapa harus menekan. </font><font style="vertical-align: inherit;">Jika pedal masih bisa dipakai dan dihubungkan ke kantor, maka berlari di ruang kelas di institut sudah lebih sulit. </font><font style="vertical-align: inherit;">Jadi menggunakan perangkat ini untuk tujuan lain selain dari tujuan semula adalah risiko dan risiko Anda sendiri. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pedal dirakit:</font></font><br><br><img src="https://habrastorage.org/webt/rw/p9/-v/rwp9-vaul_zvd9awymeb1qexlqi.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462263/">https://habr.com/ru/post/id462263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462245/index.html">auto git membagi dua sebagai contoh dari kernel Linux</a></li>
<li><a href="../id462251/index.html">Apakah mode penyamaran di browser adalah fiksi?</a></li>
<li><a href="../id462253/index.html">Eksperimen pertama menggunakan protokol streaming pada contoh CPU dan komunikasi prosesor di Redd FPGA</a></li>
<li><a href="../id462257/index.html">Kafka di Kubernetes - apakah itu bagus?</a></li>
<li><a href="../id462259/index.html">Membuat pengontrol untuk rumah pintar</a></li>
<li><a href="../id462265/index.html">Python dan kubus</a></li>
<li><a href="../id462267/index.html">Mengenal Penganalisis Statis PVS-Studio untuk Java</a></li>
<li><a href="../id462269/index.html">John Romero to Doom: 80s Game Dev</a></li>
<li><a href="../id462271/index.html">Kode kunci di iOS: bagaimana Apple beralih dari pertahanan ke pertahanan untuk menjaga satu perbatasan</a></li>
<li><a href="../id462273/index.html">Kelola dudukan laptop Anda dengan digispark</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>