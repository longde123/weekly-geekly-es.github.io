<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏒 👨‍🔧 👩‍🎓 uMCPIno: Menulis Protokol Sederhana dengan Pengiriman yang Dijamin untuk Arduino 🧝🏼 🏳️‍🌈 🛥️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salam, yang terkasih! 
 Pada tahap tertentu dalam hidup mereka, setiap kotak DIY keras kepala yang keras kepala berhenti untuk kehilangan Kantian Ardu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>uMCPIno: Menulis Protokol Sederhana dengan Pengiriman yang Dijamin untuk Arduino</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480110/"><h3>  Salam, yang terkasih! </h3><br>  Pada tahap tertentu dalam hidup mereka, setiap kotak DIY keras kepala yang keras kepala berhenti untuk kehilangan Kantian Arduino sebagai "benda-benda" yang <s>mereka tidak bisa!</s>  : Berkedip LED, mengambil data dari sensor dan mentransfernya melalui kabel ke PC tentu menyenangkan, tetapi grail suci dalam mobilitas, dalam pembebasan dari "ikatan tembaga", dalam kebebasan sejati di antara gelombang eter universal. <br>  Di sinilah kenyataan pahit saluran komunikasi yang tidak stabil, kesalahan transmisi, pesan yang tidak terkirim terbuka untuk kita. <br>  Tuhan melarang untuk mengklaim orisinalitas di bidang ini: manusia telah lama menggunakan sejumlah protokol untuk semua kesempatan. <br>  Tetapi tujuan kami adalah untuk belajar, dan karena saya adalah pendukung pengintaian yang gigih dalam pertempuran, kami akan belajar dengan menciptakan "sepeda" protokol kami sendiri. <br>  Hari ini saya mengusulkan untuk mengembangkan protokol yang memastikan pengiriman terjamin, integritas dan urutan pesan antara dua pelanggan (point-to-point, Point-to-Point), tahu bagaimana dan menerapkan algoritma <a href="https://en.wikipedia.org/wiki/Nagle%2527s_algorithm" rel="nofollow">Nagle</a> dan <a href="https://en.wikipedia.org/wiki/Protocol_pipelining" rel="nofollow">pipelining protokol protokol</a> , apa pun artinya.  Pada saat yang sama, itu harus memiliki <a href="https://en.wikipedia.org/wiki/Overhead_(computing)" rel="nofollow">overhead</a> minimal dan masuk ke dalam bahkan Arduino UNO yang sempit. <br><br><img src="https://habrastorage.org/webt/jt/7a/_b/jt7a_bc6uynr5uu08ab3plyuucq.png"><br><br>  Saya bertanya kepada semua yang tertarik di atas kapal, kami menutup palka, membuka batu raja, mengisi tangki pemberat.  Kami bertamasya ke masa lalu, tujuan: tahun 1974! <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Untuk yang tidak sabar (saya sendiri juga begitu!)</b> <div class="spoiler_text">  Berikut adalah repositori github di mana implementasinya adalah: <br><ul><li>  <a href="https://github.com/AlekUnderwater/uMCPIno/tree/master/Arduino" rel="nofollow">Untuk Arduino</a> </li><li>  <a href="https://github.com/AlekUnderwater/uMCPIno/tree/master/STM32" rel="nofollow">Untuk STM32</a> </li><li>  <a href="https://github.com/AlekUnderwater/uMCPIno/tree/master/CSharp" rel="nofollow">Untuk PC (C #)</a> </li></ul><br></div></div><br>  Menurut tradisi lama yang baik, setidaknya dua ahli yang diakui dalam bidang ini terlibat dalam menggambarkan algoritma dan protokol kriptografi, jika orang lain tidak mengetahuinya, berkenalan: <br><div class="spoiler">  <b class="spoiler_title">Alice</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/fb4/6f4/f08/fb46f4f081e1affbfba68c39dcbc7768.jpg" alt="gambar"><br></div></div><br>  Dan <br><div class="spoiler">  <b class="spoiler_title">Bob</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/048/a75/668/048a75668215c8147df3f5720f283899.jpg" alt="gambar"><br></div></div><br><br><h3>  Pertama kita menggambarkan tugas sederhana </h3><br>  Alice dan Bob duduk di parit yang berdekatan dan tidak bisa mengangkat kepala untuk saling melihat.  Mereka hanya dapat berbicara dengan suara, di sebelahnya peluit dan peluru meledak, menenggelamkan teriakan mereka, dan di samping itu, ketika salah satu dari mereka berbicara, Anda harus berteriak sehingga Anda tidak mendengar apa-apa sama sekali. <br>  Situasi menjadi rumit oleh fakta bahwa mereka didengar oleh musuh - dan Anda harus menggunakan bahasa kode, untuk beberapa alasan yang terdiri dari urutan angka yang panjang. <br>  Karena Alice dan Bob adalah manusia, mereka secara berkala harus keluar untuk makan atau pergi ke toilet, dan mereka sangat tidak sabar sehingga mereka bisa tidak sabar pada saat yang paling tidak tepat! <br><br><h3>  Bagaimana dan mengapa membuat koneksi? </h3><br>  Bagaimana kita bisa mengatur transfer data yang andal dalam situasi yang menekan seperti ini, padahal kelihatannya semuanya akan gagal? <br><br>  Solusi pertama yang mungkin terlintas dalam pikiran adalah menggunakan frasa kode <s>kata berhenti</s> untuk memulai dan mengakhiri transfer. <br><br>  Nah, katakanlah jika Alice ingin mengirim pesan, maka dia perlu berteriak "Mulai transmisi!" Dan tunggu sampai Bob menjawab "Mulai penerimaan!". <br>  Jika Alice tidak menunggu respons Bob, ia hanya mengulangi permintaannya untuk memulai transfer.  Secara alami, Anda tidak harus melakukan ini terlalu sering, jika tidak, seperti yang kita tahu, Anda hanya tidak mendengar jawaban Bob. <br><br>  Bagus  Tetapi apa yang terjadi jika Alice sebagai tanggapan mendengar dari parit berikutnya, "Mulai Transmisi!"? <br>  Ternyata Bob juga memutuskan untuk mentransfer beberapa informasi penting saat ini.  Alice memiliki karakter yang lembut, dan dia mungkin berpikir: "Oke, aku akan menunggu, pesan saya pada prinsipnya, tidak mendesak, biarkan Bob meneruskannya terlebih dahulu."  Berpikir ini, dia menjawab, "Mulailah resepsi!". <br><br>  Karena <s>pada masa perang nilai sinus dapat mencapai empat,</s> kecepatan suara terbatas, dan butuh beberapa waktu untuk memahami apa yang telah didengar Alice dan Bob, dan bahkan Bob, sebagai pria terhormat, dapat memutuskan untuk menyerah pada wanita itu, ia mengangkat bahu dan berteriak, "Aku mulai menerima!" ... <br><br>  Untuk mengilustrasikan kemarahan itu, kita akan menggunakan grafik waktu.  Waktu berlalu ke mereka. <br><br>  Kasus ketika Alice dan Bob tidak setuju tepat waktu: <br><img src="https://habrastorage.org/webt/cz/ye/hn/czyehnoehw9e3wnxveaiwvef5ok.png"><br><br>  Kasus saat pesan hilang: <br><img src="https://habrastorage.org/webt/5u/yk/md/5uykmdq7sxiagt-5twd3uhpnxas.png"><br><br>  Ini kegagalan.  Semuanya menjadi terlalu membingungkan dan diperparah oleh kenyataan bahwa penerima dapat mendengar atau tidak mendengar frasa tersebut, dan dalam setiap kasus lawan bicara tidak tahu apakah pesannya didengar oleh penerima. <br><br>  Sekarang baik Alice dan Bob mengharapkan sambutan.  Adalah logis untuk menyadari bahwa konflik telah terjadi, dan seseorang perlu melanjutkan transmisi.  Tetapi bagaimana jika semuanya terjadi lagi dengan cara yang baru?  Dan di sinilah kita lagi di mana kita mulai. <br><br>  Jika Anda berpikir bahwa situasinya sangat langka, ingat kapan terakhir kali Anda berbicara dengan seseorang melalui suara, ketika pelanggan Anda atau Anda (atau keduanya) memiliki koneksi Internet yang lambat.  "Halo halo halo, kamu menghilang."  "Kamu tidak bisa mendengar halo halo." <br><br>  Sementara itu, di parit, situasi memanas, para komandan menuntut pengiriman laporan. <br>  Saatnya <s>beralih ke sumber-sumber utama: untuk mempelajari Marx, Engels</s> akan kembali lebih dari 40 tahun yang lalu dan melihat bagaimana masalah tersebut diselesaikan oleh para insinyur <a href="https://en.wikipedia.org/wiki/Digital_Equipment_Corporation" rel="nofollow">DEC</a> ketika merancang protokol <a href="https://en.wikipedia.org/wiki/Digital_Data_Communications_Message_Protocol" rel="nofollow">DDCMP</a> . <br><br>  Menurut pengembang DDCMP, Alice dan Bob perlu menolak emosi dan menjadi seperti <a href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="nofollow">mesin negara yang terbatas</a> . <br>  Ini berarti bahwa mulai sekarang, Alice dan Bob kita hanya akan memiliki beberapa kondisi tetap, transisi antara negara-negara ini dapat terjadi secara ketat sesuai dengan aturan tertentu ketika peristiwa tertentu terjadi. <br><br>  Pertama, kami hanya daftar negara: <br><br><ul><li>  Terhenti </li><li>  AWAL AWAL </li><li>  ACKNOWLEDGED MULAI </li><li>  MENJALANKAN </li></ul><br><br>  Seperti yang Anda lihat, hanya ada empat.  Dan sekarang, apa pun yang terjadi, masing-masing pelanggan setidaknya tahu pasti bahwa vis-a-vis-nya hanya ada di salah satu negara bagian ini.  Faktanya, dengan melihat sedikit ke depan, saya akan mengatakan bahwa hampir selalu satu pelanggan akan tahu seperti apa pelanggan kedua itu, <s>tetapi ini tidak akurat</s> . <br><br><h3>  Mari kita pertimbangkan negara secara terpisah, secara terperinci </h3><br>  <b>HALTED</b> adalah keadaan paling sederhana, tidak ada yang pergi ke mana pun, semua orang tetap di tempat mereka, tidak ada yang ditransmisikan dan tidak diterima, rangsangan eksternal diabaikan.  Semua kecuali satu - kehendak otoritas yang lebih tinggi.  Dalam protokol DDCMP asli, transisi dari keadaan <b>HALTED</b> hanya bisa dalam keadaan <b>MULAI AWAL</b> atas permintaan pengguna - Alice atau Bob menerima pesanan untuk membuat koneksi. <br><br>  Apa yang terjadi ketika Alice atau Bob menerima pesanan seperti itu? <br>  Mereka segera mencatat kepada diri mereka sendiri bahwa negara telah berubah dari <b>HALTED</b> menjadi <b>AWAL AWAL</b> , transisi ini, seperti yang lainnya, melibatkan serangkaian tindakan yang didefinisikan secara ketat.  Dalam hal ini, Anda perlu berteriak "LAKUKAN ITU!" Dan mengatur jam pada jam.  Itu saja. <br><br>  Jadi, Alice menjerit apa yang diminta darinya, dan menekan tombol pada stopwatch.  Sekarang, untuk memahami apa yang diharapkan dari Bob, kami akan mencari tahu apa yang dapat terjadi pada Alice ketika ia berada dalam status <b>MULAI AWAL</b> . <br><br>  - Dari saat Alice menyadari waktu telah berlalu, katakanlah 10 detik dan dia tidak mendengar reaksi dari Bob (perhatikan, saya tidak mengatakan bahwa Bob tidak meneriakkan apa pun kepadanya - ini tidak diketahui, tetapi hanya bahwa Alice tidak tahu apa-apa) terdengar selama ini, Alice adalah wanita yang bijaksana dan rasional dan hanya mengandalkan fakta).  Kami menyebut acara ini sebagai batas waktu - interval tunggu telah terlampaui.  Dalam kasus ini, protokol memberitahu kita untuk mengulang: berteriak "LAKUKAN SEKALI!" Dan waktunya lagi.  Belum tebal. <br><br>  - Jika Alice mendengar bahwa Bob meneriakkan hal yang sama - “LAKUKAN SATU WAKTU!”, Maka Alice secara <b>non-selektif</b> masuk ke kondisi <b>ACKNOWLEDGED START</b> , yang tentangnya ia harus segera berteriak “LAKUKAN DUA!” Dan mengatur jam lagi. <br><br>  - Lagi-lagi, jika Alice mendengar dari Bob “DO TWO!”, Maka dia segera masuk ke status <b>RUNNING</b> (!), Teriakan “DITERIMA NOOOOOL!”.  Jika stopwatch-nya telah dimulai, dia mematikannya dari garis depan kehati-hatian. <br><br>  Sangat penting untuk tidak membuat gerakan yang tidak perlu yang tidak disediakan oleh kondisi saat ini.  Apa pun yang menangis Bob, tidak peduli seberapa mengutuk atau memohon, Alice hanya bereaksi sesuai kesepakatan. <br><br>  Hal-hal seperti itu disajikan dengan nyaman dalam sebuah tabel.  Jadi, mari kita mulai dengan status <b>HALTED</b> dan <b>INITIAL START yang</b> sudah dijelaskan, dan kemudian kita akan mengisi tabel lebih lanjut. <br><br><div class="scrollable-table"><table><tbody><tr><th>  NEGARA SAAT INI </th><th>  ACARA <br></th><th>  KONDISI BARU </th><th>  AKSI <br></th></tr><tr><td>  SIAPAPUN </td><td>  Perintah "putus koneksi" </td><td>  Terhenti <br></td><td></td></tr><tr><td>  Terhenti <br></td><td>  Pesan "Hubungkan" <br></td><td>  NEGARA AWAL </td><td>  1) Berteriak "LAKUKAN SEKALI!" <br>  2) Mulai timer <br></td></tr><tr><td rowspan="3">  AWAL AWAL <br></td><td>  Saya mendengar "LAKUKAN SEKALI!" <br></td><td>  ACKNOWLEDGED MULAI <br></td><td>  1) Berteriak "LAKUKAN DUA!" <br>  2) Mulai timer <br></td></tr><tr><td>  Saya mendengar "LAKUKAN DUA!" </td><td>  MENJALANKAN <br></td><td>  1) Serukan “NOOOL DITERIMA!” <br>  2) Hentikan timer <br></td></tr><tr><td>  Waktu habis - habis </td><td>  AWAL AWAL <br></td><td>  1) Berteriak "LAKUKAN SEKALI!" <br>  2) Mulai timer <br></td></tr></tbody></table></div><br><br>  Saya secara sadar menghilangkan beberapa poin dari deskripsi asli DDCMP - kami tidak membutuhkannya, kami ingin tidak hanya mengulangi DDCMP, tetapi membangun atas dasar <s>yang sama, hanya</s> protokol baru lainnya. <br><br>  Tetapi kembali ke deskripsi negara dan transisi.  Status selanjutnya adalah <b>DIAKUI DIMULAI</b> . <br>  Berada dalam keadaan ini, yang bisa membuat khawatir Alice atau Bob adalah: <br><br>  - seperti sebelumnya, berakhirnya waktu tunggu, dalam hal ini Anda harus tetap dalam keadaan yang sama, berteriak "LAKUKAN DUA!" Dan mulai timer lagi <br><br>  - "DO DUA!" yang terdengar diterjemahkan ke dalam status <b>MENJALANKAN</b> , sambil meneriakkan "DITERIMA NOOOOL!" Dan hentikan timernya; <br><br>  - "DO IT!" yang didengar meninggalkan dalam keadaan yang sama, Anda perlu berteriak "DO TWO!" Dan mulai timer; <br><br>  - mendengar "NOOOL DITERIMA!" - transisi ke status <b>MENJALANKAN</b> , hentikan timer. <br><br>  Kami menempatkan semua hal di atas dalam sebuah tabel. <br><div class="scrollable-table"><table><tbody><tr><th>  NEGARA SAAT INI </th><th>  ACARA <br></th><th>  KONDISI BARU </th><th>  AKSI <br></th></tr><tr><td rowspan="4">  ACKNOWLEDGED MULAI <br></td><td>  Saya mendengar "LAKUKAN SEKALI!" <br></td><td>  ACKNOWLEDGED MULAI <br></td><td>  1) Berteriak "LAKUKAN DUA!" <br>  2) Mulai timer <br></td></tr><tr><td>  Saya mendengar "LAKUKAN DUA!" </td><td>  MENJALANKAN <br></td><td>  1) Serukan “NOOOL DITERIMA!” <br>  2) Hentikan timer <br></td></tr><tr><td>  Saya mendengar "NOOOL DITERIMA!" </td><td>  MENJALANKAN <br></td><td>  1) Hentikan timer <br></td></tr><tr><td>  Waktu habis - habis </td><td>  ACKNOWLEDGED MULAI </td><td>  1) Berteriak "LAKUKAN DUA!" <br>  2) Mulai timer <br></td></tr></tbody></table></div><br><br>  Dengan jabat tangan, hampir semuanya sudah siap - masih mempertimbangkan hanya satu keadaan <b>MENJALANKAN</b> , karena salah satu pelanggan sudah bisa masuk ke dalamnya, dan yang kedua - segera berlari ke toilet, dan ketika dia kembali, lupakan semuanya dan cobalah untuk membangun koneksi baru. <br><br>  Dari sudut pandang prosedur jabat tangan (kami belum berurusan dengan transfer data, yang semuanya dimulai - ini adalah cerita yang terpisah) dalam keadaan <b>MENJALANKAN</b> kami tertarik pada dua peristiwa: <br><br>  - jika mereka berteriak kepada kami "LAKUKAN SEKALI!" - semuanya sangat buruk, itu adalah desync yang lengkap, semuanya harus dimulai lagi.  Protokol asli <b>mengarahkan</b> Anda untuk cukup memasuki kondisi <b>HALTED</b> .  Tetapi ini tidak akan membantu kita dengan cara apa pun - jika karena alasan tertentu ini terjadi pada Arduino otonom, yang mentransmisikan beberapa data dari beberapa sensor, maka bagi kami ini adalah kegagalan total.  Seperti yang kita ketahui, dari <b>HALTED</b> Anda dapat pergi ke <b>MULAI AWAL</b> hanya atas perintah pihak berwenang. <br>  Oleh karena itu, kami memodifikasi protokol di sini: penerimaan dalam keadaan <b>HALTED</b> dari "DO ONCE!" Perintah harus bekerja seperti perintah dari pihak berwenang - yaitu.  <b>beralih ke</b> status <b>MULAI AWAL</b> , berteriak "LAKUKAN SEKALI!", mulai timer.  Selain itu, dalam beberapa kasus lebih mudah untuk memberi perintah untuk membangun komunikasi segera setelah memasok daya ke diri sendiri. <br>  Jadi, sekarang, dalam kasus yang paling tidak nyaman, kita hanya perlu mengatur ulang koneksi. <br><br>  - Peristiwa kedua yang diperlukan untuk bereaksi dalam keadaan <b>MENJALANKAN</b> - jika kita mendengar "LAKUKAN DUA!" Dari parit tetangga.  Ini sudah lebih menarik.  Dalam hal ini, Anda perlu meneriakkan “ER DITERIMA!” Di mana, oleh ER berarti jumlah pesan yang berhasil diterima dalam sesi komunikasi saat ini.  Ini adalah konsep baru.  Di bawah ini kami akan mempertimbangkan segala sesuatu dengan lebih terperinci, tetapi untuk saat ini kami akan membawa semua yang telah kami pelajari hingga saat ini ke dalam tabel: <br><br><div class="scrollable-table"><table><tbody><tr><th>  NEGARA SAAT INI </th><th>  ACARA <br></th><th>  KONDISI BARU </th><th>  AKSI <br></th></tr><tr><td rowspan="4">  ACKNOWLEDGED MULAI <br></td><td>  Saya mendengar "LAKUKAN SEKALI!" <br></td><td>  ACKNOWLEDGED MULAI <br></td><td>  1) Berteriak "LAKUKAN DUA!" <br>  2) Mulai timer <br></td></tr><tr><td>  Saya mendengar "LAKUKAN DUA!" </td><td>  MENJALANKAN <br></td><td>  1) Serukan “NOOOL DITERIMA!” <br>  2) Hentikan timer <br></td></tr><tr><td>  Saya mendengar "NOOOL DITERIMA!" </td><td>  MENJALANKAN <br></td><td>  1) Hentikan timer <br></td></tr><tr><td>  Waktu habis - habis </td><td>  ACKNOWLEDGED MULAI </td><td>  1) Berteriak "LAKUKAN DUA!" <br>  2) Mulai timer <br></td></tr></tbody></table></div><br><br>  Sekarang, jika Alice dan Bob benar-benar mengikuti protokol, maka mereka tidak punya pilihan <s>untuk masuk ke</s> sesuatu yang <s>tidak dapat dipahami</s> , kecuali bagaimana membangun koneksi, bersama-sama beralih ke keadaan <b>MENJALANKAN</b> atau, dalam kasus yang buruk, mencoba membangunnya sebelum kemenangan <s>diklik</s> . <br><br>  Pembaca yang agresif dapat mencoba memilah-milah semua opsi dan sampai pada kesimpulan bahwa rangkaian keadaan dan transisi ternyata tertutup dan ditentukan dengan ketat.  Kami (dengan bantuan pikiran para insinyur DEC) sekarang telah mengikat Alice dan Bob dengan seperangkat aturan yang hanya dengan mengikuti yang mereka akan membangun koneksi, jika dalam kondisi saat ini secara umum dimungkinkan pada prinsipnya. <br><br><h3>  Bagaimana cara mentransfer data sekarang? </h3><br>  Oke, itu latihan yang bagus.  Periode permen-buket dalam hubungan dua node jaringan.  Ingatlah bahwa kami memulai bisnis: kami perlu mentransfer data dengan pengiriman yang terjamin dan prioritas!  Dengan pemulihan bencana.  Sejauh sumber daya perangkat keras memungkinkan ini (lagipula, Alice dan Bob mungkin terbukti sebagai pengontrol 8-bit yang lemah dengan 2 kilobyte RAM!). <br><br>  Teknisi DEC mengajarkan kepada kita bahwa pesan yang perlu kita beri nomor, kita perlu menghitung berapa banyak yang kita kirim, berapa banyak yang kita terima dan berapa banyak pesan yang kita kirim mencapai penerima. <br><br><div class="spoiler">  <b class="spoiler_title">Sudah waktunya untuk penyimpangan!</b> <div class="spoiler_text">  Akui saja.  ketika saya melihat nama-nama variabel dalam deskripsi protokol DDCMP, saya memutuskan bahwa itu bukan kebetulan: Orang Amerika sangat suka menarik singkatan yang indah di telinga mereka. <br><br>  Untuk kenyamanan kita, bahkan ada beberapa sumber daya di mana mereka yang tertarik dapat menyentuh keindahan. <br>  Favorit saya adalah yang ini - <a href="https://www.cfa.harvard.edu/~gpetitpas/Links/Astroacro.html" rel="nofollow">Situs Akronim Astronomi yang Bodoh atau Terlalu Dipaksa (atau DOOFAAS)</a> <br><br>  Apa nilai-nilai palsu ini! <br>  Berikut ini sebuah contoh: <br><br>  <b>WASP</b> - Wideband Analog SPectrometer (Tapi tidak semua yang Anda pikirkan!) <br>  <b>SAURON</b> - Unit Areal Spektroskopi untuk Penelitian tentang Nebula Optik <br>  <b>CISCO</b> - Cooled Spectrograph Inframerah dan Kamera untuk OHS (Jadi itulah artinya!) <br><br>  Dan di sini, tembak saja: <br>  <b>SQUIRT</b> (oh ya, artikel 18+!) - Satettile QUick Research Testbed <br>  <b>SHIT</b> (Tidak lebih dan tidak kurang!) - Teleskop Interferometrik Super Besar, dengan tulisan “cari sendiri”, di mana tautan ke abstrak dilampirkan ke artikel dengan nama yang sama. <br><br>  Jadi, variabel yang menunjukkan jumlah paket yang diterima, dikirim dan dikirim pada node dalam deskripsi asli protokol disebut sebagai <b>RNA</b> . <br><br>  Ah, mengapa mereka tidak menyebutkan protokol seperti itu - RNA!  Semacam jaringan RNA.  Protokol DECnet memiliki setiap kesempatan untuk menjadi protokol Internet jika ceritanya berubah secara berbeda. <br></div></div><br><br><h3>  Tapi kembali ke parit kita </h3><br>  Standar protokol asli menetapkan bahwa semua penghitung adalah 8-bit dan modulo peningkatan 256. Ini berarti bahwa mungkin ada maksimum 256 pesan terkirim yang konfirmasi belum diterima. <br>  Dan jika konfirmasi tidak diterima, maka mereka mungkin perlu dikirim ulang, dan jika mungkin diperlukan, maka mereka harus disimpan sampai konfirmasi.  Bagaimanapun, kami telah menjamin pengiriman! <br><br>  Parameter fisik Alice dan Bob kita menentukan bagi kita kondisi yang berbeda.  Dalam Arduino 8-bit, jumlah data ini tidak bisa disimpan dan kita harus berkompromi.  Dan saya tidak berbicara tentang fakta bahwa dalam standar panjang paket (pesan) dalam byte terbatas pada angka 16-bit, yaitu  64 kilobyte adalah kemewahan yang tidak dapat diterima! <br><br><h3>  Jadi, koneksi terjalin.  Apa selanjutnya </h3><br>  Saat Alice atau Bob <b>memasuki</b> keadaan <b>MENJALANKAN</b> , penghitung diatur ulang. <br>  Seperti yang sudah saya sebutkan, protokol asli melibatkan penomoran pesan modulo 256, tetapi kita harus mengurangi jumlah ini agar sesuai dengan sedikit memori dalam hal-hal seperti Arduino. <br>  Agar dapat segera membatasi semua peningkatan penghitung, kami akan memperkenalkan UMCP_PACKETS_NUMBER konstan tertentu, dan sekarang semua peningkatan akan terjadi dalam modul ini. <br><br>  Jika Anda menggunakan UMCP_PACKETS_NUMBER = 8, dan ukuran paket maksimum adalah UMCP_PACKET_DATA_SIZE - bagian dari data yang dikirimkan pada suatu waktu dibatasi hingga 64 byte, maka semuanya akan sesuai dengan UNO Arduino dan akan tetap sedikit untuk kebutuhan pengguna. <br>  Penting untuk diingat bahwa kedua parameter ini harus sama untuk kedua belah pihak. <br><br>  Jelas, sekarang, jika Alice dan Bob telah berhasil membuat koneksi, dan salah satunya perlu mentransfer data, maka data pertama-tama harus dibagi menjadi bagian-bagian yang tidak melebihi ukuran 64 byte, dan kedua, setiap paket juga harus berisi keadaan dua penghitung pengirim: jumlah pesan yang diterima dan dikirim (R dan N). <br><br>  Lihat betapa mudahnya sekarang mengatur apa yang disebut  pipelining dan betapa mudahnya menangani situasi kesalahan! <br><br>  Jika Alice mengirim 3 paket berturut-turut tepat setelah koneksi tersambung, maka semuanya akan memiliki counter R yang diatur ke 0 (dia belum menerima paket apa pun), dan counter N akan bertambah satu dengan setiap paket baru. <br><br>  Jika Bob berhasil menerima semuanya, maka untuk mengonfirmasi penerimaan ketiga paket, cukup baginya untuk mengirim konfirmasi hanya untuk yang terakhir, pada kenyataannya, jika ia hanya mengirim kembali status counter-nya R = 3 dan N = 0, maka Alice akan segera memahami bahwa semua yang dikirim pesannya mencapai penerima. <br><br>  Itu adalah kasus yang ideal ketika force majeure tidak terjadi.  Sekarang mari kita lihat apa yang mungkin salah dan bagaimana mengatasinya. <br><br>  Jika Bob karena alasan tertentu melewatkan paket pertama dan menerima salah satu dari yang berikutnya, maka ia segera menarik perhatian pada fakta bahwa penghitung N di dalamnya (jumlah paket yang dikirimkan oleh Alice) jelas melebihi penghitung R di sisi Bob dan Bob dengan mudah menyadari bahwa ia melewatkan paket pertama. .  Dalam hal ini, ia hanya perlu memainkan Captain Evidence paling datar dan memberi tahu Alice status counter dari paket yang diterima (R = 0).  Alice pada saat yang sama memahami bahwa dia adalah N = 3, dan Bob memiliki R = 0, yaitu, perlu untuk mentransfer paket dengan cara yang baru, mulai dari yang pertama. <br><br>  Jika Anda melihat skema ini dengan hati-hati, Anda dapat melihat bahwa setiap pengiriman status penghitungnya oleh pelanggan mana pun segera memberitahukan kepadanya tentang hasil pengiriman paket data, dan perbedaan antara penghitung yang dikirimkan di satu sisi dan yang diterima di sisi lain menunjukkan berapa banyak paket yang hilang dan mulai dari nomor berapa. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artinya, dalam kasus terburuk, ada pengiriman ulang lengkap transmisi, dalam kasus rata-rata, penghitung A di sisi pemancar meningkat ke nilai penghitung R di sisi penerima, dan "mengirim" paket yang hilang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sangat mudah untuk memahami bahwa dengan cara ini, kontinuitas kenaikan penghitung dipertahankan, yang berarti bahwa pengiriman pesan (paket) dijamin. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain variabel RNA, setiap pelanggan memiliki dua flag SACK dan SPEP. Jika yang pertama diinstal, maka Anda harus mengirim konfirmasi (Kirim pengakuan), jika yang kedua - maka Anda perlu mengirim permintaan konfirmasi (Kirim REPly ke pesan).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Omong-omong, bendera lain tersirat dalam DDCMP asli - SNAK (Kirim pengakuan negatif). Instalasinya melibatkan pengiriman pesan kesalahan dengan beberapa jenis kode. Tetapi dalam versi protokol kami, kami akan menyelesaikan semua kesalahan secara eksklusif menggunakan mekanisme batas waktu, karena protokol tersebut dapat digunakan, misalnya, dalam komunikasi sonar atau radio dalam pita frekuensi yang sama - tidak masuk akal untuk menyumbat lingkungan umum dengan kode kesalahan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika pesan diterima dengan kesalahan integritas, maka secara tegas itu adalah pesan yang tidak dapat diterima. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada titik ini, pembaca yang korosif harus memiliki perasaan bahwa ada sesuatu yang hilang. Ada yang salah dengan skema ramping ini.</font></font> Dan itu benar.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lebih lanjut tentang ini nanti. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sementara itu, saya mengusulkan, mengikuti contoh proses pengaturan koneksi, untuk mengumpulkan semua pemikiran terpisah tentang mentransfer data ke tabel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kita sekarang hanya memiliki satu negara, tabel hanya akan berisi dua kolom - acara dan tindakan yang harus diambil. </font><font style="vertical-align: inherit;">Untuk menghindari kebingungan antara variabel-variabel yang menjadi milik variabel, kami menandai yang lokal dengan indeks L dan yang dihapus (yang terkandung dalam pesan yang diterima dengan indeks R).</font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ACARA </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AKSI </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paket data datang NR = RL + 1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) Hentikan timer </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) Kirim paket ke pengguna </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) RL = RL + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4) Jika RR = NL atau AL &lt;= RR &lt;= NL tandai semua </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket yang dikirimkan dengan angka dari AL ke RR sebagai </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dikonfirmasi </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5) AL = RR</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Permintaan konfirmasi telah tiba - REP </font></font></td><td> 1) SACK = true <br> 2) SREP = false <br></td></tr><tr><td>   — ACK </td><td> 1)   <br> 2) SREP = false <br> 3)  RR=NL  AL&lt;=RR&lt;=NL   <br>      AL  RR  <br>  <br> 4) AL=RR <br></td></tr><tr><td>    </td><td> 1) SREP = true </td></tr><tr><td>      SREP </td><td> 1)     REP(RL, NL) <br> 2)   <br></td></tr><tr><td>    AL&lt;NL </td><td> 1)     AL+1 <br> 2)   <br></td></tr><tr><td>  ,   SACK </td><td> 1)   ACK(RL,NL) </td></tr><tr><td>  , AL=NL,  SACK  SREP <br>  ,     <br></td><td> 1) NL=NL+1 <br> 2)     <br></td></tr></tbody></table></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang perhatikan dari dekat, gulir ke seluruh sirkuit di kepala. Kami menyadari apa yang hilang di sini. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam uraian asli DDCMP, yang telah kami tinggalkan dengan sangat kuat, ini disebut flag SELECT - sebuah simpul (Alice atau Bob) mungkin atau mungkin tidak “dipilih”. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang membingungkan kami adalah tidak ada mekanisme yang diizinkan untuk mengizinkan atau melarang transfer. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nah, ini dia: ini adalah flag SELECT. Ini diterapkan dengan sangat sederhana: jika bendera diatur, maka dimungkinkan untuk mengirimkan, jika tidak, itu tidak mungkin.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua pesan kontrol seperti ACK dan REP harus mengandung panji ini. </font><font style="vertical-align: inherit;">Paket terakhir dalam antrian juga harus mengandung flag ini. </font><font style="vertical-align: inherit;">Jika sebuah simpul “menjahit” sebuah bendera ke dalam sebuah paket, maka ia “memberikannya”, dan karenanya tidak lagi dipasang. </font><font style="vertical-align: inherit;">Node yang mendeteksi flag ini dalam paket, sebaliknya, harus menginstalnya sendiri. </font><font style="vertical-align: inherit;">Ini mirip dengan mengoper tongkat atau bermain daging cincang (ingat itu?). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal terpenting dalam bekerja dengan flag ini adalah bahwa salah satu node harus memiliki flag ini secara default, dan yang lainnya tidak. </font><font style="vertical-align: inherit;">Itu adalah timer lain yang sangat penting - timer kembali flag SELECT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kami memiliki seperangkat aturan lengkap untuk membuat koneksi dan mengirimkan data di atasnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak menyentuh hanya pada implementasi konkret dari set aturan ini. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baiklah, perbaiki!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Formasi dan Format Paket </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini disebut Pembingkaian Pesan - aturan untuk menganalisis dan menghasilkan pesan dan format. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita hitung berapa yang kita butuhkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Minimal, kami membutuhkan setiap pesan untuk memuat status penghitung R dan N pengirim. </font><font style="vertical-align: inherit;">Untuk Arduino, kami sepakat bahwa kami dapat memiliki maksimal 8 pesan terkirim tetapi belum dikonfirmasi. </font><font style="vertical-align: inherit;">Tetapi karena kita mentransfer byte, kita mendorong kedua penghitung menjadi satu byte, biarkan mereka menjadi 4-bit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte ini akan dibentuk seperti ini:</font></font><br><pre><code class="cpp hljs"> = (RL &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>) | (NL &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Dan kita akan membaca status penghitung seperti ini: <br><pre> <code class="cpp hljs">NR = (c &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; RR = c &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>;</code> </pre> <br>  c - byte yang sesuai dari pesan <br><br>  2. Kami juga ingat bahwa setiap pesan harus mengandung keadaan bendera SELECT.  Dan berbagai jenis pesan itu sendiri adalah: <br><div class="scrollable-table"><table><tbody><tr><th>  Nama lucu <br></th><th>  Nama yang serius <br></th><th>  Deskripsi <br></th><th>  Nilai flag SELECT <br></th><th>  Nilai PTYPE </th></tr><tr><td>  "LAKUKAN SEKALI!" <br></td><td>  STR <br></td><td>  STaRt <br></td><td>  benar </td><td>  40 <br></td></tr><tr><td>  "LAKUKAN DUA!" <br></td><td>  STA <br></td><td>  MULAI Diakui </td><td>  benar </td><td>  36 </td></tr><tr><td>  "NOOL DITERIMA!" <br></td><td>  ACK (NL = 0, RL = 0) <br></td><td>  Pengakuan <br></td><td>  benar </td><td>  33 <br></td></tr><tr><td>  "DITERIMA OLEH ER, DIKIRIM OLEH EN" </td><td>  ACK (NL, RL) </td><td>  Pengakuan </td><td>  benar </td><td>  33 </td></tr><tr><td>  "KONFIRMASI BAGAIMANA SAYA MEMAHAMI?" <br></td><td>  REP (NL, RL) <br></td><td>  Balas pesan </td><td>  benar </td><td>  34 </td></tr><tr><td>  "PAKET DATA" <br></td><td>  DTA (NL, RL) <br></td><td>  Paket data </td><td>  salah </td><td>  17 </td></tr><tr><td>  PAKET DATA EKSTRIM <br></td><td>  DTE (NL, RL) </td><td>  Paket DaTa - Akhir </td><td>  benar </td><td>  49 </td></tr></tbody></table></div><br><br>  Artinya, hanya 6 jenis pesan yang berbeda.  Semua pesan kecuali DTA "melepaskan" bendera SELECT - mereka membutuhkan respons langsung dari pelanggan jarak jauh, dan tanpa bendera ia tidak akan dapat mengirimkannya.  Pesan DTA tidak mengembalikan bendera untuk memungkinkan pipelining. <br><br>  Secara umum, kami memiliki cukup 3 bit untuk jenis pesan, tetapi agar tidak mengacaukan bit, kami menetapkan satu byte penuh ke jenis pesan - dalam kasus revisi kami akan memiliki beberapa kebebasan bertindak. <br><br>  Jika pesan berisi data, maka kami perlu mentransfer kuantitas dan checksumnya.  Karena ukuran paket maksimum adalah 64 byte, kami juga akan mengambil byte untuk checksum dan panjangnya - tiba-tiba Anda harus menambah ukuran paket. <br><br>  3. Kami juga membutuhkan beberapa tanda tangan dari awal pesan dan checksum terpisah untuk header. <br><br>  Dengan semua ini dalam pikiran, header (alias mengontrol pesan) terlihat seperti ini: <br><div class="scrollable-table"><table><tbody><tr><th>  Offset, byte <br></th><th>  Deskripsi </th><th>  Ukuran, bit </th></tr><tr><td>  0 </td><td>  SIGN = 0xAD <br></td><td>  8 </td></tr><tr><td>  1 </td><td>  PTYPE </td><td>  8 </td></tr><tr><td>  2 </td><td>  TCNT </td><td>  4 <br></td></tr><tr><td>  2 </td><td>  RCNT </td><td>  4 </td></tr><tr><td>  3 </td><td>  Hchk </td><td>  8 </td></tr></tbody></table></div><br><br>  Dan blok data adalah seperti ini: <br><div class="scrollable-table"><table><tbody><tr><th>  Offset, byte <br></th><th>  Deskripsi </th><th>  Ukuran, bit </th></tr><tr><td>  4 </td><td>  DCNT <br></td><td>  8 </td></tr><tr><td>  5..5 + DCNT-1 <br></td><td>  DATA <br></td><td>  8 * DCNT </td></tr><tr><td>  5 + DCNT </td><td>  Dchk </td><td>  8 </td></tr></tbody></table></div><br><br>  Itu saja.  Ini adalah deskripsi lengkap protokol yang kami dapatkan dari DDCMP. <br>  Sekarang Anda bisa melalui implementasi. <br><br><h3>  Bagaimana cara mengaturnya dan bagaimana menggunakannya? </h3><br>  Pertama, sedikit tentang struktur repositori. <br>  Seperti yang saya sebutkan di awal, kode proyek terletak di github: <a href="https://github.com/AlekUnderwater/uMCPIno" rel="nofollow">uMCPIno</a> <br><br>  Untuk melihat cara kerja semuanya, Anda dapat menjalankan <a href="" rel="nofollow">aplikasi uji</a> pada PC. <br><br>  Di arsip, jalankan uMCPIno_Test.exe, pilih port COM yang diinginkan dan coba cara kerjanya. <br>  Anda dapat memeriksa sepasang port COM virtual (saya biasanya melakukan ini). <br>  Mengapa Anda dapat menjalankan dua salinan aplikasi.  Hanya saja, jangan lupa untuk menyalakan "PILIHAN OLEH DEFAULT" dalam satu salinan - ini akan menjadi Master, dan yang lain - matikan.  Omong-omong, jika tertarik, Anda dapat melihat apa yang terjadi jika Anda tidak mematuhi aturan ini =) <br><br>  Opsi EXTRAS memungkinkan Anda untuk melihat semua gerakan pikiran di dalam otak protokol.  Semua perubahan dalam keadaan flag SELECT, peristiwa dari penghitung waktu, perubahan status node, serta nilai variabel R dan N dalam pesan yang dikirim dan diterima akan ditampilkan. <br><br>  Saya menghubungkan UNO Arduino ke laptop saya melalui konverter USB &lt;-&gt; UART.  Konektor pin memungkinkan Anda mensimulasikan pemutusan saluran kapan saja: <br><img src="https://habrastorage.org/webt/nn/vg/kp/nnvgkplqtoqbazpubopcb8bff-g.jpeg"><br><br>  Jika sekarang Anda menjalankan aplikasi di laptop, maka setelah menekan tombol "CONNECT", arduina akan membuat koneksi: <br><img src="https://habrastorage.org/webt/cy/jm/lx/cyjmlxn_ga-_zvrzel5yjmfwdz4.png"><br><br>  Dan ini adalah bagaimana sistem bereaksi terhadap upaya untuk mengirim melalui garis "sobek": <br><img src="https://habrastorage.org/webt/lu/kb/dw/lukbdwxot1xuopxjdqxgpq1xqsq.png"><br><br>  Untuk menanamkan uMCPIno di aplikasi Anda untuk PC: <br><ol><li>  Repositori memiliki pustaka uMCPIno.  Hubungkan ke referensi proyek Anda </li><li>  Ini berisi kelas uMCPInoPort.  Kami menyatakan contohnya: <br><pre> <code class="cs hljs">uMCPInoPort port; port = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> uMCPInoPort(<span class="hljs-string"><span class="hljs-string">"COM1"</span></span>, UCNLDrivers.BaudRate.baudRate9600, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-number"><span class="hljs-number">8100</span></span>, <span class="hljs-number"><span class="hljs-number">2000</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>);</code> </pre><br>  Parameter berurutan: nama port, lalu kecepatan port, status SELECT default, interval untuk SELECT, interval waktu habis, ukuran paket, dan jumlah maksimum pesan yang tidak diakui. <br></li><li>  Berlangganan acara: <br>  ketika SELECT - port. Pilih flag yang berubah: <br><pre> <code class="cs hljs">OnSelectChangedEventHandler</code> </pre> <br>  ketika keadaan berubah - port.State: <br><pre> <code class="cs hljs">OnStateChangedEventHandler</code> </pre> <br>  Host jarak jauh mengonfirmasi penerimaan kode: <br><pre> <code class="cs hljs">OnDataBlockAcknowledgedEventHandler</code> </pre> <br>  kapan paket data tiba: <br><pre> <code class="cs hljs">OnDataBlockReceivedEventHandler</code> </pre> <br></li><li>  Sebelum bekerja, buka porta <br><pre> <code class="cs hljs">port.Open();</code> </pre> <br></li><li>  Untuk mengirim data, kami memanggil metode: <pre> <code class="cs hljs">port.Send(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data);</code> </pre> <br></li><li>  Setelah selesai, tutup port: <pre> <code class="cs hljs">port.Close();</code> </pre> <br></li></ol><br><br>  Cukup kirim dua byte! <br><br>  Sekarang mari kita beralih ke implementasi untuk Arduino.  Dua contoh ada di folder <a href="https://github.com/AlekUnderwater/uMCPIno/tree/master/Arduino" rel="nofollow">github.com/AlekUnderwater/uMCPIno/tree/master/Arduino</a> <br><br>  <a href="" rel="nofollow">Yang pertama</a> hanyalah konverter dari dan ke uMCP.  Serial pertama berfungsi untuk berkomunikasi dengan Host, dan Serial1 (jika ada di papan Anda) atau SoftwareSerial pada pin 2 dan 3 - untuk berkomunikasi dengan simpul uMCPIno lainnya.  Anda dapat menghubungkan Bluetooth atau modul radio di sini. <br><br>  <a href="" rel="nofollow">Yang kedua</a> adalah templat proyek dengan dukungan untuk protokol uMCPIno <br><br>  Kedua proyek memiliki pengaturan di mana Anda dapat dan harus memanjat.  Inilah mereka: <br><br>  Status default dari flag SELECT.  Jika diatur ke (true), maka bahkan jika node jauh tidak mengembalikan bendera, itu akan diatur ke true oleh timer. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_SELECT_DEFAULT_STATE (false)</span></span></code> </pre> <br><br>  Untuk mengatur periode timer ini, ada pengaturan berikut: interval untuk mengembalikan flag SELECT dalam milidetik <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_SELECT_DEFAULT_INTERVAL_MS (4000)</span></span></code> </pre> <br><br>  Interval untuk menunggu respons dalam milidetik, lebih baik meninggalkannya sedikit kurang dari interval untuk mengembalikan bendera SELECT. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_TIMEOUT_INTERVAL_MS (3000)</span></span></code> </pre> <br><br>  Tingkat baud aktual dari garis.  Parameter ini diperlukan untuk menentukan kapan transfer akan berakhir. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_LINE_BAUDRATE_BPS (9600)</span></span></code> </pre> <br><br>  Interval akumulasi data untuk algoritma Nagle.  Kurang ajar sama dengan 100 milidetik.  Selama ini, kami sedang menunggu satu set paket, jika tidak diketik, maka kami mengirimkannya apa adanya.  Tugas algoritma Nagle adalah membersihkan jaringan dari tumpukan paket-paket kecil dari ukuran satu hingga beberapa byte. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_NAGLE_DELAY_MS (100)</span></span></code> </pre> <br><br>  Pengaturan ini mengatur kecepatan port untuk komunikasi dengan sistem kontrol (Host) dan saluran.  Jangan bingung kecepatan port dengan saluran dengan kecepatan transfer fisik. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_HOST_CONNECTION_BAUDRATE_BPS (9600) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Host connection port speed #define CFG_LINE_CONNECTION_BAUDRATE_BPS (9600) // Line connection port speed</span></span></span></span></code> </pre> <br><br>  Jika pengaturan ini diaktifkan, maka ketika daya disuplai ke controller, protokol itu sendiri akan memerintahkan dirinya untuk mulai membuat koneksi. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_IS_AUTOSTART_ON_POWERON (true)</span></span></code> </pre> <br><br>  Ini adalah ukuran dalam byte buffer untuk paket data yang masuk. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_IL_RING_SIZE (255)</span></span></code> </pre> <br><br>  Selanjutnya, mari kita lihat seperti apa loop sketsa utama: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ uMCP_ITimers_Process(); DC_Input_Process(); DC_Output_Process(); <span class="hljs-comment"><span class="hljs-comment">//  ip_ready  ,      if (ip_ready) { uMCP_OnIncomingPacket(); } //        ,     -  if ((state == uMCP_STATE_HALTED) &amp;&amp; ((ih_Cnt &gt; 0) || (isStartup &amp;&amp; CFG_IS_AUTOSTART_ON_POWERON))) { if (isStartup) { isStartup = false; } uMCP_STATE_Set(uMCP_STATE_ISTART); uMCP_CtrlSend(uMCP_PTYPE_STR, 0, 0, true); } else if (state == uMCP_STATE_RUNNING) { uMCP_Protocol_Perform(); //      -   if (il_ready) { il_ready = false; USER_uMCPIno_DataPacketReceived(); } } }</span></span></code> </pre><br><br>  Sekarang mari kita lihat bagaimana protokol bekerja.  Logika utama terkandung dalam fungsi uMCP_Protocol_Perform ();  Ini kodenya: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uMCP_Protocol_Perform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == uMCP_STATE_RUNNING) { <span class="hljs-comment"><span class="hljs-comment">//              SELECT  if ((!iTimer_State[uMCP_Timer_TX]) &amp;&amp; (!iTimer_State[uMCP_Timer_TMO]) &amp;&amp; (select)) { //     if (ih_Cnt == 0) { //    REP -  if (srep) { uMCP_CtrlSend(uMCP_PTYPE_REP, N, R, true); srep = false; } //     -   else if (sentBlocksCnt &gt; 0) { uMCP_DataBlockResend((A + 1) % UMCP_PACKETS_NUMBER, true, true); } //    SACK  -        //  -       ACK else if ((!selectDefaultState) || (sack)) { uMCP_CtrlSend(uMCP_PTYPE_ACK, N, R, false); sack = false; } } //     -  else if (ih_Cnt &gt; 0) { //              -  if ((ih_Cnt &gt;= UMCP_PACKET_DATA_SIZE) || (millis() &gt;= ih_TS + CFG_NAGLE_DELAY_MS)) { //   N N = (N + 1) % UMCP_PACKETS_NUMBER; uMCP_NextDataBlockSend(); } } } } }</span></span></code> </pre><br><br>  Paket parser yang hidup dalam suatu fungsi <pre> <code class="cpp hljs">On_NewByte_From_Line</code> </pre>  juga diatur oleh prinsip mesin negara terbatas dan bekerja "byte-by-byte".  Ini dilakukan untuk menghemat memori. <br><br>  Sisa implementasi bukan merupakan kepentingan khusus.  Kami akan lebih baik menganalisis bagaimana pengguna berinteraksi dengan protokol.  Dalam contoh ini, ada empat "titik kontak". <br><br>  Yang pertama adalah fungsi pengiriman data di jalur uMCPIno: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uMCPIno_SendData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte* dataToSend, byte dataSize)</span></span></span></span>;</code> </pre> <br>  Semuanya sederhana di sini - Anda memiliki buffer byte dataToSend, ukurannya adalah dataSize.  Fungsi mengembalikan true jika pengiriman dimungkinkan (ada ruang untuk menambahkan data), dan false jika tidak. <br>  Agar tidak mengemudi dengan sia-sia, Anda dapat segera memeriksa ketersediaan ruang yang cukup menggunakan fungsi: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uMCP_IsCanSend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte dataSize)</span></span></span></span>;</code> </pre> <br><br>  Untuk menganalisis paket data yang masuk, Anda perlu menambahkan kode Anda ke badan fungsi <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USER_uMCPIno_DataPacketReceived</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><br>  Data yang masuk ditulis ke buffer ring il_ring.  Membaca darinya dapat diatur byte seperti ini: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (il_Cnt &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { c = il_ring[il_rPos]; il_rPos = (il_rPos + <span class="hljs-number"><span class="hljs-number">1</span></span>) % CFG_IL_RING_SIZE; il_Cnt--; <span class="hljs-comment"><span class="hljs-comment">//   "c" -      }</span></span></code> </pre><br><br>  Untuk kesenangan canggih ada fungsi <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USER_uMCP_OnTxBufferEmptry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  Yang disebut ketika semua data berhasil dikirim.  Mungkin juga dan perlu untuk meletakkan beberapa jenis kode di dalamnya. <br><br><h3>  Mengapa ini semua dan di mana? </h3><br>  Saya berurusan terutama dengan Hanya untuk bersenang-senang.  Selain itu, saya membutuhkan beberapa protokol sederhana dan, yang paling penting, "ringan" untuk mengirim data melalui modem sonar <a href="https://habr.com/ru/post/428367/">uWAVE</a> kami.  Karena mereka mentransmisikan data melalui air pada kecepatan hanya 80 bps, dan dengan jangkauan komunikasi maksimum 1000 meter dan kecepatan suara dalam air sekitar 1500 m / s, transmisi dikaitkan dengan penundaan yang nyata, dan hanya ada satu saluran sonar (jika bukan yang paling !) dari yang paling berisik, paling lambat dan paling tidak stabil. <br>  Sebagian besar karena ini, saya harus meninggalkan mekanisme pengakuan negatif (NAK) - jika mungkin untuk tidak mengirimkan - dalam air lebih baik untuk tidak mengirimkan 100%. <br>  Pada kenyataannya, protokol ini sangat berguna ketika mentransmisikan data melalui saluran radio menggunakan modul <a href="http://www.dorji.com/products.php%3FCateId%3D9" rel="nofollow">DORJI</a> dan <a href="https%253A%252F%252Fwww.elecrow.com%252Fdownload%252FHC-12.pdf%26usg%3DAOvVaw2rNtYm7nLdpqPN6HR-LAS8" rel="nofollow">NS-012 yang</a> terkenal untuk Arduino. <br><br><h3>  Apa selanjutnya </h3><br>  Jika ada waktu, saya berencana untuk menambahkan kemungkinan pengalamatan (yang, omong-omong, ada di DDCMP).  Karena tugas utama dari protokol ini sekarang adalah untuk memberikan kemudahan untuk semua jenis pengujian modem sonar kami dan Jaringan Sensor lainnya, maka ada (secara harfiah!) Perangkap di sana.  Saya hanya bisa mengatakan bahwa masalahnya tidak dapat diselesaikan dengan hanya menambahkan bidang "Pengirim" dan "Target". <br>  Mungkin akan datang ke <a href="https://en.wikipedia.org/wiki/Geographic_routing" rel="nofollow">Geographic Routing</a> dan semua jazz itu. <br><br><h3>  PS </h3><br>  Secara tradisional, saya akan sangat berterima kasih atas kritik, harapan, dan saran yang membangun.  Selalu penting untuk memahami apakah Anda melakukan sesuatu yang bermanfaat bagi orang atau membuang-buang waktu. <br>  Mungkin, dalam upaya untuk menghindari transisi dari longread ini ke novel "War and Peace", saya telah melewatkan beberapa detail - jangan ragu untuk bertanya. <br><br><h3>  PPS </h3><br>  Banyak terima kasih untuk mempermalukan buta huruf saya, menunjukkan kesalahan (tata bahasa dan logis): <br><ul><li>  <a href="https://habr.com/ru/users/berez/" class="user_link">berez</a> </li><li>  <a href="https://habr.com/ru/users/edo1h/" class="user_link">edo1h</a> </li></ul><br>  Proyek ini awalnya open source, tetapi sekarang artikelnya juga open source. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480110/">https://habr.com/ru/post/id480110/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480100/index.html">Pemula Tentang SEO</a></li>
<li><a href="../id480102/index.html">November Manajemen Produk Digest</a></li>
<li><a href="../id480104/index.html">9 trik HTML yang berguna</a></li>
<li><a href="../id480106/index.html">Cara merakit gambar Oracle DB untuk Testcontainers</a></li>
<li><a href="../id480108/index.html">Fisika dalam Proyek Persatuan Menggunakan Pertarungan Bergerak sebagai Contoh</a></li>
<li><a href="../id480112/index.html">Perbedaan antara C ++ / Visual Basic dan Java pada tingkat umum (untuk pemula dan siswa)</a></li>
<li><a href="../id480114/index.html">Semua tentang pajak untuk freelancer IT. IE dan wiraswasta. Bagian 1</a></li>
<li><a href="../id480116/index.html">Posisi Mail.ru Group pada pengembangan opensource di Rusia</a></li>
<li><a href="../id480118/index.html">Kami sedang menulis simulator pengetikan sentuh menggunakan JavaScript murni. Bagian 1</a></li>
<li><a href="../id480120/index.html">Sebuah Pencapaian Baru dalam Kriptografi - Faktorisasi RSA 795-bit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>