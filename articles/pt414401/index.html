<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó∫Ô∏è üçÖ üîâ 100.500 m√©todos de cache no banco de dados Oracle üëºüèæ üç• üßó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dizer o que s√£o caches, o que √© o cache de resultados, como √© feito no Oracle e em outros bancos de dados n√£o √© muito interessante e bonito. Mas tudo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>100.500 m√©todos de cache no banco de dados Oracle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/414401/">  Dizer o que s√£o caches, o que √© o cache de resultados, como √© feito no Oracle e em outros bancos de dados n√£o √© muito interessante e bonito.  Mas tudo assume cores completamente diferentes quando se trata de exemplos espec√≠ficos.  <strong>Alexander Tokarev</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">shtock</a> ) construiu seu relat√≥rio no Highload ++ 2017 com base em casos.  E foi precisamente com base nos casos que ele contou quando um cache caseiro pode ser conveniente, qual √© a dor do cache de resultados do servidor e como substitu√≠-lo por um do lado do cliente e, em geral, ele trouxe v√°rias dicas √∫teis para configurar o cache de resultados no Oracle. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/hTCXaAKIArk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre o palestrante:</strong> Alexander Tokarev trabalha na DataArt e lida com quest√µes relacionadas aos bancos de dados, tanto em termos de constru√ß√£o de sistemas a partir do zero quanto na otimiza√ß√£o dos existentes. <br><br>  Vamos come√ßar com algumas perguntas ret√≥ricas.  Voc√™ j√° trabalhou com o Oracle Result Cache?  Voc√™ acredita que o Oracle √© um banco de dados adequado para todas as ocasi√µes?  De acordo com a experi√™ncia de Alexander, a maioria das pessoas responde negativamente √† √∫ltima pergunta: <strong>cem sonhadores t√™m um sonhador</strong> .  Mas, gra√ßas √† sua f√©, o progresso est√° se movendo. <br><br>  A prop√≥sito, a Oracle j√° possui 14 bancos de dados - at√© agora 14 - o que acontecer√° no futuro √© desconhecido. <br><br>  Como j√° mencionado, todos os problemas e solu√ß√µes ser√£o ilustrados com casos espec√≠ficos.  Esses ser√£o dois casos de projetos DataArt e um exemplo de terceiros. <br><a name="habracut"></a><br><h2>  Caches de banco de dados <br></h2><br>  Para come√ßar, quais caches est√£o nos bancos de dados.  Tudo est√° claro aqui: <br><br><ul><li>  Cache de buffer - cache de dados - cache para p√°ginas / blocos de dados; </li><li>  Cache de instru√ß√µes - cache de instru√ß√µes e seus planos - plano de cache de consultas; </li><li>  Cache de resultados - cache dos resultados da linha - linhas de consultas; </li><li>  Cache do SO - cache do sistema operacional. </li></ul><br>  Al√©m disso, o cache de resultados, em geral, √© usado apenas no Oracle.  Ele j√° esteve no MySQL, mas foi heroicamente cortado.  No PostgreSQL, ele tamb√©m n√£o existe, est√° presente de uma forma ou de outra apenas no produto pgpool de terceiros. <br><br><h2>  Caso 1. Cofre do varejista <br></h2><br><img src="https://habrastorage.org/webt/qo/cq/t5/qocqt5zzctiqj1hh5n-6hc9skkm.jpeg"><br><br>  Acima est√° o diagrama do produto que acompanhamos - o reposit√≥rio (Oracle 11, 20 TB, 300 usu√°rios) e cont√©m algum tipo de relat√≥rio sombrio, no qual havia 350 produtos exclusivos por 5000 linhas de dados.  Levou cerca de 20 minutos e os usu√°rios ficaram tristes. <br><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A apresenta√ß√£o</a> deste relat√≥rio, como todo mundo, est√° dispon√≠vel no site da confer√™ncia Highload ++. </blockquote><br>  Este relat√≥rio possui SELECT, JOINs e uma fun√ß√£o.  Uma fun√ß√£o como uma fun√ß√£o, tudo ficaria bem, apenas calcula um par√¢metro misterioso chamado ‚Äúvalor do pre√ßo de transfer√™ncia‚Äù, funciona por 0,2 s - parece nada, mas √© chamado quantas vezes houver linhas na tabela.  Essa fun√ß√£o possui 400 linhas de SQL + PL / SQL, pois  o produto √© compat√≠vel, √© assustador alter√°-lo. <br><br>  Pelo mesmo motivo, result_cache n√£o p√¥de ser usado. <br><br><img src="https://habrastorage.org/webt/1o/u5/ct/1ou5ctbufxqrsme66mbz60bieuy.jpeg"><br><br>  Para resolver o problema, usamos a <strong>abordagem</strong> padr√£o <strong>com o armazenamento em cache feito √† m√£o</strong> : deixamos os 3 primeiros blocos do circuito, como era, simplesmente renomeie nossa fun√ß√£o sku_detail () para sku_full () e declare uma matriz associativa, onde respectivamente: <br><br><ul><li>  chaves s√£o nossos SKUs (itens b√°sicos), <br></li><li>  Os valores s√£o o pre√ßo de convers√£o de transfer√™ncia calculado. <br></li></ul><br>  Tornamos a fun√ß√£o de cache (sku) √≥bvia: se n√£o houver esse ID em nossa matriz associativa, nossa fun√ß√£o √© iniciada, o resultado √© armazenado em cache, salvo e retornado.  Por conseguinte, se esse ID for, tudo isso n√£o acontece.  De fato, temos <strong>cache sob demanda</strong> . <br><br>  Assim, reduzimos o n√∫mero de chamadas de fun√ß√£o √† quantidade realmente necess√°ria.  <strong>O tempo de processamento do relat√≥rio diminuiu para 4 minutos</strong> , todos os usu√°rios se sentiram bem. <br><br><h3>  <strong>Mem√≥ria cache feita √† m√£o</strong> <br></h3><br>  As desvantagens e vantagens deste sistema s√£o evidentes nesta grande imagem inteligente, que abordaremos muito - essa √© a arquitetura da mem√≥ria. <br><br><img src="https://habrastorage.org/webt/ku/e4/2o/kue42onfhkjjpxxyk0klg0-at50.jpeg"><br><br>  √â importante entender em qual √°rea de mem√≥ria as cole√ß√µes est√£o localizadas.  Eles s√£o colocados em uma √°rea de mem√≥ria chamada PGA.  <strong>A √°rea global do programa √©</strong> instanciada em todas as conex√µes com o banco de dados.  Isso √© o que determina as vantagens e desvantagens, uma vez que mais conex√µes - mais mem√≥ria e <strong>mais mem√≥ria, servidores</strong> e administradores <strong>caros</strong> . <br><br><img src="https://habrastorage.org/webt/7c/gi/hd/7cgihdigefzcded25cmfondxkcc.jpeg"><br><br><ul><li>  <strong>Pr√≥s:</strong> tudo funciona muito r√°pido, muito f√°cil de fazer, sem configura√ß√£o necess√°ria, sem problemas com o envolvimento entre processos. <br></li><li>  <strong>Os contras</strong> s√£o compreens√≠veis: se a l√≥gica armazenada √© proibida no projeto, eles n√£o podem ser usados, n√£o h√° mecanismo para invalida√ß√£o autom√°tica e, como a mem√≥ria no cache √© alocada em uma sess√£o do banco de dados, n√£o em uma inst√¢ncia, seu <strong>consumo √© exagerado</strong> .  Al√©m disso, no caso do caso de uso do conjunto de conex√µes, lembre-se de liberar os caches se houver um cache diferente para cada sess√£o. <br></li></ul><br>  Existem outras op√ß√µes para caches feitos √† m√£o com base em visualiza√ß√µes materializadas, tabelas tempor√°rias, mas a partir delas existe uma grande carga no sistema de entrada e sa√≠da, portanto, aqui n√£o as consideramos.  Eles s√£o mais aplic√°veis ‚Äã‚Äãa outros bancos de dados nos quais esses problemas geralmente s√£o resolvidos armazenando o procedimento armazenado em alguma tabela intermedi√°ria e retirando os dados dele antes de acessar uma solicita√ß√£o pesada.  E somente se n√£o for encontrado o necess√°rio, a solicita√ß√£o inicial ser√° chamada. <br><br><img src="https://habrastorage.org/webt/mh/8u/xg/mh8uxg2hjytjwrp0fbds1gvoc4k.jpeg"><br><br>  A ilustra√ß√£o acima √© uma ilustra√ß√£o dessa abordagem para o problema de armazenamento em cache para obter uma lista de produtos relacionados no MsSQL.  Em geral, a abordagem √© relativamente semelhante, mas n√£o funciona na mem√≥ria do banco de dados, tanto em termos de obten√ß√£o de dados quanto de preenchimento prim√°rio, por isso <strong>pode ser mais lenta</strong> . <br><br>  Em geral, result_cache caseiro √© usado ativamente, mas result_cache no banco de dados √© uma abordagem diferente para a implementa√ß√£o desta tarefa.  Ele e como n√£o funcionou rapidamente ganharemos mais adiante. <br><br><h2>  Caso 2. Processamento da documenta√ß√£o financeira <br></h2><br>  Ent√£o, nosso segundo caso. <br><br><img src="https://habrastorage.org/webt/dd/zn/wy/ddznwymy92vgt32eox6fvwanepq.jpeg"><br><br>  Este √© um sistema de processamento de documenta√ß√£o financeira semi-automatizado - uma empresa sombria com uma arquitetura cl√°ssica, que inclui: <br><br><ul><li>  thin client; <br></li><li>  4.000 usu√°rios que vivem em diferentes partes do mundo; <br></li><li>  balanceador; <br></li><li>  2 JBoss para calcular a l√≥gica de neg√≥cios; <br></li><li>  cluster na mem√≥ria; <br></li><li>  n√∫cleo Oracle; <br></li><li>  Backup Oracle <br></li></ul><br>  Uma das muitas tarefas deste sistema √© o <strong>c√°lculo de recomenda√ß√µes</strong> . <br><br><img src="https://habrastorage.org/webt/dm/rt/cf/dmrtcfcgvy2q94g-jl52qnhatbo.jpeg"><br><br>  Existem documentos, para cada indicador que n√£o √© reconhecido automaticamente pelo sistema, um conjunto de indicadores √© oferecido a partir de documentos de clientes anteriores, de um setor semelhante ou de uma lucratividade semelhante, enquanto o indicador √© comparado com o valor reconhecido para n√£o oferecer muito.  O que √© importante, os <strong>documentos s√£o multil√≠ngues</strong> . <br><br>  O usu√°rio seleciona o valor desejado e repete a opera√ß√£o para cada linha vazia. <br><br>  Simplificada, esta tarefa consiste no seguinte: os documentos chegam na forma de pares de valores-chave de diferentes sistemas de reconhecimento e os par√¢metros s√£o reconhecidos em algum lugar, mas n√£o em algum lugar.  √â necess√°rio garantir que, no final, os usu√°rios processem os documentos e todos os valores sejam reconhecidos.  A recomenda√ß√£o visa precisamente a simplifica√ß√£o desta tarefa e leva em considera√ß√£o: <br><br><ol><li>  Multilinguismo - cerca de 30 idiomas.  Cada idioma tem seus pr√≥prios termos, sin√¥nimos e outros recursos. </li><li>  Os dados anteriores deste cliente, ou, na sua aus√™ncia, os dados de um cliente do mesmo setor ou de um cliente com lucro semelhante. </li></ol><br>  De fato, trata-se de 12 regras muito complexas. <br><br>  <strong>Premissas iniciais:</strong> <br><br><ul><li>  N√£o mais que 100 usu√°rios por vez; </li><li>  2-3 colunas para reconhecimento; </li><li>  100 linhas. </li></ul><br>  <strong>Sem carga alta</strong> - tudo √© chato. <br><br>  Ent√£o, √© hora de lan√ßar.  O congelamento de c√≥digo ocorreu, o Java tem medo de tocar e leva pelo menos 5 minutos para processar um documento. <br><br>  Eles chegam √† equipe de desenvolvimento de banco de dados pedindo ajuda.  Obviamente, porque <em>se algo diminuir na JVM, ent√£o, por si s√≥, voc√™ precisar√° alterar ou reparar o banco de dados</em> . <br><br><img src="https://habrastorage.org/webt/ae/q_/tm/aeq_tm3cua2tkk3ohgxl7rntova.jpeg"><br><br>  Estudamos os documentos e percebemos que em pares de valores-chave os valores s√£o repetidos com frequ√™ncia - 5 a 10 vezes.  Dessa forma, decidimos usar o banco de dados para armazenar em cache, porque ele j√° foi testado. <br><br>  Decidimos usar o cache de resultados do servidor Oracle, porque: <br><br><ol><li>  as oportunidades para otimizar o SQL foram esgotadas, porque ele usa o mecanismo de pesquisa de texto completo do Oracle; <br></li><li>  cache ser√° usado para par√¢metros duplicados; <br></li><li>  a maioria dos dados para recomenda√ß√µes √© recalculada uma vez por hora, pois eles usam um √≠ndice de texto completo; <br></li><li>  <strong>PL / SQL √© proibido</strong> . <br></li></ol><br><h3>  <strong>Cache de Resultados Oracle</strong> <br></h3><br>  Cache de resultados - cache de resultados do Oracle - possui as seguintes propriedades: <br><br><ul><li>  Essa √© a √°rea de mem√≥ria na qual todos os resultados da consulta s√£o revistados; </li><li>  leia consistente, e sua invalida√ß√£o autom√°tica ocorre; </li><li>  s√£o necess√°rias altera√ß√µes m√≠nimas no aplicativo.  Voc√™ pode fazer com que o aplicativo n√£o precise ser alterado; </li><li>  b√¥nus - voc√™ pode armazenar em cache a l√≥gica PL / SQL, mas √© proibida aqui. </li></ul><br>  <strong>Como habilit√°-lo?</strong> <br><br><h4>  M√©todo n√∫mero 1 <br></h4><br><img src="https://habrastorage.org/webt/qo/im/jv/qoimjvcbfclnfsp_pncn6uf-74g.jpeg"><br><br>  √â muito simples <strong>especificar a instru√ß√£o result_cache</strong> .  O slide mostra que o identificador de resultado apareceu.  Portanto, na primeira vez em que a consulta √© executada, o banco de dados realiza algum trabalho; durante a execu√ß√£o subsequente, nesse caso, nenhum trabalho √© necess√°rio.  Est√° tudo bem. <br><br><h4>  M√©todo n√∫mero 2 <br></h4><br><img src="https://habrastorage.org/webt/5x/uy/d5/5xuyd5seajh5kshz1xmdvmd6fu0.jpeg"><br><br>  A segunda maneira permite que os desenvolvedores de aplicativos n√£o fa√ßam nada - essas s√£o as chamadas anota√ß√µes.  Indicamos uma marca de sele√ß√£o para a tabela em que a solicita√ß√£o deve ser colocada em result_cache.  Portanto, n√£o h√° dica, n√£o tocamos no aplicativo e tudo j√° est√° em result_cache. <br><br><blockquote>  A prop√≥sito, o que voc√™ acha, se uma consulta se refere a duas tabelas, uma das quais est√° marcada como result_cache e a segunda n√£o, o resultado dessa consulta √© armazenado em cache? <br><br>  A resposta √© n√£o, de maneira alguma. <br></blockquote><br>  Para que seja armazenada em cache, todas as tabelas que participam da consulta devem ter anota√ß√£o result_cache. <br><br><h3>  <strong>Rastreamento de depend√™ncia</strong> <br></h3><br>  Existem visualiza√ß√µes relevantes nas quais voc√™ pode ver o que s√£o depend√™ncias. <br><br><img src="https://habrastorage.org/webt/ni/12/bp/ni12bpiy04zhswxncy1rsq1h29s.jpeg"><br><br>  No exemplo acima, a consulta JOIN √© uma tabela na qual existe uma depend√™ncia.  Porque  Porque o Oracle determina a depend√™ncia n√£o apenas analisando, mas a implementa de <strong>acordo com os resultados do plano de trabalho</strong> . <br><br>  Nesse caso, esse plano foi escolhido porque apenas uma tabela √© usada e, de fato, a tabela de tarefas est√° vinculada √† tabela de funcion√°rios por meio de restri√ß√£o de chave estrangeira.  Se removermos a restri√ß√£o de chave estrangeira que permite essa transforma√ß√£o de elimina√ß√£o de jun√ß√£o, veremos duas depend√™ncias, porque o plano mudar√° dessa maneira. <br><br>  <strong>O Oracle n√£o rastreia o que n√£o precisa ser rastreado</strong> . <br><br>  No PL / SQL, a depend√™ncia √© executada em tempo de execu√ß√£o, para que voc√™ possa usar o SQL din√¢mico e fazer outras coisas. <br><br><img src="https://habrastorage.org/webt/3j/nh/fk/3jnhfkrft2dgbs-4nyvnwg6nfkm.jpeg"><br><br>  Observe que voc√™ pode armazenar em cache n√£o apenas toda a solicita√ß√£o, mas <strong>tamb√©m pode armazenar em cache a exibi√ß√£o em linha com e de</strong> .  Suponha que, por um lado, precisamos de um cache, e o outro seria melhor ler do banco de dados para n√£o sobrecarreg√°-lo.  Adotamos uma visualiza√ß√£o embutida, declaramos novamente como result_cache e vemos que apenas uma parte √© armazenada em cache e, na segunda, acessamos o banco de dados todas as vezes. <br><br><img src="https://habrastorage.org/webt/zq/ze/7z/zqze7zgbnbljnme7a9j8qfbewdo.jpeg"><br><br>  E, finalmente, os <strong>bancos de dados tamb√©m t√™m encapsulamento</strong> , embora ningu√©m acredite nele.  Temos uma vis√£o, colocamos result_cache nela, e nossos programadores nem percebem que ela est√° armazenada em cache.  Abaixo, vemos que, de fato, apenas uma parte funciona. <br><br><img src="https://habrastorage.org/webt/-x/-a/mt/-x-amt3jzaygadispddtfx_fojy.jpeg"><br><br><h3>  Defici√™ncia <br></h3><br>  Ent√£o, vamos ver quando o Oracle invalida o result_cache.O status Publicado mostra o estado atual da validade do cache.  Quando a solicita√ß√£o para result_cache, como eu disse, n√£o h√° trabalhos no banco de dados <br><br><img src="https://habrastorage.org/webt/uv/9b/at/uv9batcfvtszo6tudxpovnhzy8s.jpeg"><br><br>  Quando fizemos a atualiza√ß√£o, o status ainda √© publicado, porque a atualiza√ß√£o n√£o foi confirmada e outras sess√µes devem exibir o resultado_cache antigo.  Essa √© a not√≥ria consist√™ncia da leitura. <br><br>  Mas, na sess√£o atual, veremos que a carga acabou, pois √© nessa sess√£o que o cache √© ignorado.  Isso √© bastante razo√°vel, vamos fazer o commit - o resultado se tornar√° Inv√°lido, tudo funciona por si s√≥. <br><br><img src="https://habrastorage.org/webt/-r/sn/rt/-rsnrtdyj9bk6vthaott4qondaq.jpeg"><br><br>  Parece - um sonho!  A depend√™ncia √© considerada correta - apenas dependendo da solicita√ß√£o.  Mas n√£o, v√°rias nuances foram reveladas.  <strong>A Oracle produz defici√™ncias e em v√°rios casos n√£o √≥bvios</strong> : <br><br><ol><li>  Em qualquer chamada SELECT FOR UPDATE, as depend√™ncias desaparecem. </li><li>  Se a tabela tiver chaves estrangeiras n√£o indexadas e ocorrer uma atualiza√ß√£o na tabela marcada como result_cache, que n√£o afetou nada, mas algo mudou na tabela pai, o cache tamb√©m se tornar√° inv√°lido. </li><li>  Essa √© a coisa mais interessante que estraga a vida o m√°ximo poss√≠vel - se houver alguma atualiza√ß√£o malsucedida na tabela marcada como result_cache, nada funcionou, mas, na mesma transa√ß√£o, outras altera√ß√µes foram aplicadas que de alguma forma afetaram a primeira tabela, de qualquer maneira result_cache ser√° redefinido. </li></ol><br>  Ainda existe um antipadr√£o sobre o result_cache, quando os desenvolvedores, ao ouvirem que h√° uma coisa t√£o legal, pensam: ‚ÄúOh, h√° armazenamento!  Agora, vamos fazer uma solicita√ß√£o que funcione em 2-3 parti√ß√µes - na data atual e na anterior, marque-a como result_cache, e ela sempre ser√° retirada da mem√≥ria! " <br><br>  Mas quando voc√™ muda a patricia em retrospectiva, todo o cache voa, porque na verdade a unidade de rastreamento de depend√™ncia em result_cache √© sempre uma tabela e n√£o sei se haver√° parti√ß√µes ou n√£o. <br><br>  Pensamos e decidimos que ir√≠amos para a produ√ß√£o de um sistema de recomenda√ß√£o com essas coisas: <br><br><ul><li>  <strong>N√£o armazenaremos em cache todas as nossas tabelas, apenas as necess√°rias.</strong> <br></li><li>  <strong>Defina result_cache para a consulta de longa execu√ß√£o.</strong> <br></li></ul><br>  Verificamos tudo, realizamos testes de desempenho, <strong>tempo de processamento - 30 s</strong> .  Tudo est√° √≥timo, v√° para produ√ß√£o! <br><br>  Partiu - foi dormir.  Chegamos de manh√£.  Vemos uma carta: "O reconhecimento leva pelo menos 20 minutos, as sess√µes congelam".  Por que eles est√£o congelando?  Como <strong>30 segundos se transformaram em 20 minutos</strong> ? <br><br>  Eles come√ßaram a entender, olhe para o banco de dados: <br><br><ul><li>  sess√µes ativas - 400; </li><li>  em linhas m√©dias em um documento para reconhecimento - 500; </li><li>  m√≠nimo de colunas - 5-8; </li><li>  o n√∫mero de sess√µes no banco de dados √© sempre igual ao n√∫mero de aplicativos do usu√°rio multiplicado por 3!  E result_cache n√£o gosta de acesso frequente a ele. </li></ul><br>  Ap√≥s realizar uma investiga√ß√£o interna, descobrimos que os desenvolvedores Java fazem reconhecimento em 3 threads. <br><br>  Ficamos chateados - uma carga, queda, degrada√ß√£o de 5 vezes e, mesmo com esses par√¢metros, tal subsid√™ncia n√£o deveria ter acontecido. <br><br>  Obviamente, voc√™ precisa entender. <br><br><h3>  Monitoramento <br></h3><br><img src="https://habrastorage.org/webt/b6/iq/iw/b6iqiwwevjqyua9xr6p8j2aq0bu.jpeg"><br><br>  Para o monitoramento, temos duas coisas principais: <br><br><ol><li>  V $ RESULT_CACHE_OBJECTS - uma lista de todos os objetos; </li><li>  V $ RESULT_CACHE_STATISTICS - agrega estat√≠sticas de result_cache como um todo. </li></ol><br>  MEMORY_REPORT s√£o varia√ß√µes de um tema, n√£o precisaremos deles. <br><br>  Oracle √© m√°gico!  A documenta√ß√£o √© √≥tima, mas foi projetada para aqueles que alternam de outros bancos de dados para ler e pensar que o Oracle √© muito legal!  Mas <strong>todas as informa√ß√µes no result_cache est√£o apenas no suporte</strong> . <br><br><img src="https://habrastorage.org/webt/vm/u1/bt/vmu1bt35lwpsvebw9o-rnxxasgs.jpeg"><br><br>  H√° uma nuance que consiste no fato de que, assim que nos voltamos para esses objetos, a fim de resolver o problema, n√≥s o exacerbamos por finalmente nos enterrando!  At√© o Oracle12.2, antes do patch lan√ßado em outubro do ano passado, essas solicita√ß√µes tornam o resultado_cache inacess√≠vel para status e grava√ß√£o at√© que sejam contados completamente. <br><br><img src="https://habrastorage.org/webt/8b/nd/4y/8bnd4ygeerwxy7n38lqjrqrfwnw.jpeg"><br><br>  Portanto, usando a visualiza√ß√£o v $ result_cache_objects, descobrimos que existem milhares de entradas na lista de objetos em cache - muito mais do que esper√°vamos.  Al√©m disso, esses eram objetos de algumas de nossas consultas em tabelas estranhas - tablets pequenos e consultas last_modified_date.  Obviamente, <strong>algu√©m colocou o ETL em nossa base</strong> . <br><br>  Antes de falar palavr√µes com os desenvolvedores de ETL, verificamos que a op√ß√£o result_cache force estava ativada para essas tabelas e lembramos que a ativamos, pois alguns desses dados geralmente eram exigidos pelo aplicativo e o cache era apropriado. <br><br><img src="https://habrastorage.org/webt/u1/wq/28/u1wq28jkvtylav6ndpx7qql6koo.jpeg"><br><br>  Mas <strong>todos esses pedidos apenas pegam e lavam nosso cache</strong> .  Felizmente, os desenvolvedores tiveram a oportunidade de influenciar o ETL na produ√ß√£o, portanto, pudemos alterar o result_cache para excluir essas solicita√ß√µes minuciosas. <br><br>  Voc√™ acha que √© mais f√°cil?  - N√£o se sinta melhor!  O n√∫mero de objetos em cache diminuiu e subiu novamente para 12.000. Continuamos estudando o que mais foi armazenado em cache, pois a velocidade n√£o mudou. <br><br><img src="https://habrastorage.org/webt/iy/1o/di/iy1odismaewdpasdhlh_uidjeay.jpeg"><br><br>  N√≥s olhamos - um monte de pedidos, e t√£o inteligentes, mas todos incompreens√≠veis.  Embora qualquer pessoa que tenha trabalhado com o Oracle 12 saiba que o DS SVC √© uma estat√≠stica adaptativa.  √â necess√°rio melhorar o desempenho, mas quando h√° result_cache, acontece que o mata porque a concorr√™ncia est√° acontecendo.  Obviamente, isso √© escrito <strong>apenas como suporte</strong> . <br><br>  Sab√≠amos como a carga de trabalho √© organizada e entendemos que, no nosso caso, as estat√≠sticas adaptativas n√£o melhorariam radicalmente nossos planos.  Portanto, heroicamente o desativamos - o resultado, conforme est√° escrito no manual secreto, √© de 10 minutos por documento.  N√£o √© ruim, mas n√£o o suficiente. <br><br><h3>  Travas <br></h3><br>  <strong>A competi√ß√£o entre result_cache e DS SVC</strong> se deve ao fato de a Oracle ter travas - pequenas travas leves. <br><br><img src="https://habrastorage.org/webt/d5/ts/nd/d5tsndbmieve1hguz6yv-qzq2jk.jpeg"><br><br>  Sem entrar em detalhes sobre como eles funcionam, tentamos colocar uma trava nomeada v√°rias vezes - n√£o deu certo - a Oracle pega e adormece <br><br>  Qualquer pessoa que esteja no assunto pode dizer que no result_cache, duas travas s√£o colocadas em cada bloco com busca.  Estes s√£o os detalhes.  Existem dois tipos de travas em result_cache: <br><br>  1. Trave pelo per√≠odo enquanto escrevemos dados em result_cache. <br><br><img src="https://habrastorage.org/webt/pv/db/qe/pvdbqeunmn4qjgcybpkxai3thne.jpeg"><br><br>  Ou seja, se sua solicita√ß√£o estiver funcionando por 8 s, durante o per√≠odo desses 8 s, outras mesmas solicita√ß√µes (a palavra-chave ‚Äúmesmo‚Äù) n√£o poder√£o fazer nada, pois aguardam at√© que os dados sejam gravados em result_cache.  Outros pedidos ser√£o gravados, mas aguardar√£o pelo bloqueio apenas na primeira linha.  Quanto eles ter√£o que esperar √© desconhecido; esse √© o par√¢metro n√£o documentado result_cache_timeout.  Depois disso, eles come√ßam a ignorar result_cache, por assim dizer, e trabalham lentamente.  No entanto, assim que a trava da √∫ltima linha na porta √© liberada, eles automaticamente come√ßam a trabalhar com o result_cache novamente. <br><br>  2. O segundo tipo de bloqueios - para receber de result_cache tamb√©m da 1¬™ linha at√© a √∫ltima. <br>  Mas como a busca vem da mem√≥ria instant√¢nea, eles s√£o removidos muito rapidamente. <br><br><img src="https://habrastorage.org/webt/pl/es/ds/plesds8v7w0qd8vjfrecofbmwno.jpeg"><br><br>  Lembre-se de que, quando o DBA v√™ travas no banco de dados, ele come√ßa a dizer: ‚ÄúTravas!  Tempo de espera - tudo se foi!  ¬ªE aqui come√ßa o jogo mais interessante: <strong>convencer o DBA de que o tempo de espera das travas √© realmente incomparavelmente menor do que o tempo de repeti√ß√£o da consulta</strong> . <br><br><img src="https://habrastorage.org/webt/ii/du/sv/iidusv3bzptakrexkjrco7cubsw.jpeg"><br><br>  Como mostra nossa experi√™ncia, nossas medi√ß√µes, <strong>travas em result_cache ocupam 10% das solicita√ß√µes</strong> . <br><br><img src="https://habrastorage.org/webt/7-/o8/8a/7-o88agtahp-edtfts_lb2ss6s4.jpeg"><br><br>  Estas s√£o estat√≠sticas agregadas.  O fato de que tudo est√° ruim pode ser entendido pelo fato de o cache estar entupido.  Outra confirma√ß√£o √© Resultados adequados s√£o exclu√≠dos.  Ou seja, o <strong>cache √© substitu√≠do</strong> .  Parece que somos inteligentes e sempre consideramos o tamanho da mem√≥ria - pegamos o tamanho da linha do resultado em cache para nossa recomenda√ß√£o, multiplicado pelo n√∫mero de linhas e algo deu errado. <br><br><img src="https://habrastorage.org/webt/mg/lh/5e/mglh5eorzkulnfqoewvrreqpb_u.jpeg"><br><br>  support   2 ,  ,  <strong>  result_cache   </strong> .         . <br><br>   ,    .   , ,   ,  workload   5 .           ,     ,    . <br><br> <strong>   ?</strong> <br><br>  :     .   ,      . <br><br><img src="https://habrastorage.org/webt/2i/qm/_j/2iqm_jbqws8mw7udadiwhkrngao.jpeg"><br><br>    4 : <br><br><ul><li> RESULT_CACHE_MAX_SIZE; <br></li><li> RESULT_CACHE_MAX_RESULT; <br></li><li> RESULT_CACHE_MODE; <br></li><li> _RESULT_CACHE_MAX_TIMEOUT. <br></li></ul><br><img src="https://habrastorage.org/webt/bt/fr/wp/btfrwpqmjmcs6evdykbcvizgte4.jpeg"><br><br>     ‚Äî  .  ,    100   512,      6 . <br><br>    ,    - . , Invalidation Count = 10000. <br><br>   ,    .     ,   job  ,      . ,   .   job   ,    ,      . <br><br><img src="https://habrastorage.org/webt/2b/m0/dl/2bm0dl2vlmo6bbv16wyksdoora0.jpeg"><br><br>    , invalid     ,    . <strong>         40 </strong> . <br><br>  ,    .     ,     ,     Oracle.  ! <br><br><img src="https://habrastorage.org/webt/wj/dd/jw/wjddjwnlpkmemk8lglmb7rczgb0.jpeg"><br><br> <strong>SHELFLIVE</strong> ‚Äî ,    read-consistent  ,       10 ,   .        . ,     ,    . <br><br>      ‚Äî <strong>SNAPSHOT</strong> .  ,       ,     read-consistent    ‚Äî       . <br><br> <strong></strong> : <br><br><img src="https://habrastorage.org/webt/bj/ts/pd/bjtspdkmsfo2d2xicp_pmxgtqag.jpeg"><br><br><ol><li>  ‚Äî       SYS. </li><li>      . ,    ,  Oracle    ,     ,        .  , Oracle ,   ,   12.2     . ,  external  -    support,    . </li><li>    sql  pl/sql : current_date, current_time  .   ,     current_time,          . </li><li>    . </li><li>          ,    CLOB, BLOB  . </li></ol><br><h3> Result cache inside Oracle <br></h3><br> Result_cache ‚Äî   Oracle Core.        , ,    job  result_cache (,    hint,    )  ,    APEX. <br><br><img src="https://habrastorage.org/webt/6n/u3/wf/6nu3wfqtrqzz3n5r_kyfdfwfv8c.jpeg"><br><br> ,    Dynamic sampling    ,   ,      ,   result_cache. <br><br><img src="https://habrastorage.org/webt/qa/gr/al/qagralka35xxjh68wtrfpprgrii.jpeg"><br><br><h2> Oracle internals for result cache <br></h2><br>         result_cache: <br><br><ol><li>        (storage)   ; <br></li><li>         result_cache; <br></li><li> result_cache   shared pool. <br></li></ol><br><img src="https://habrastorage.org/webt/yx/29/pk/yx29pkuz-o_c4dbgk9dbjwbn0lm.jpeg"><br><br> <strong>:</strong> <br><br><ul><li>     . <br></li><li>           read-consistent. </li><li> Result_cache,   ,  . </li></ul><br> <strong>:</strong> <br><br><ul><li>    . <br></li><li>     ,    . <br></li></ul><br><h2>   ! <br></h2><br>      ,    .    support Oracle, ,  29  2017 .:   Oracle E-Business suite    result_cache,      . <br><br><img src="https://habrastorage.org/webt/zh/h3/eu/zhh3eud6fphqdaiuukx1yoklczu.jpeg"><br><br> ,       ,     .          support        ,    ,      . <br><br><img src="https://habrastorage.org/webt/qp/e8/5i/qpe85iwdofjvbxhgtrrihdjmxb4.jpeg"><br><br>             : <br><br><ol><li>  -    ; <br></li><li> , , , ,  v$result_cache_memory  dbms_result_cache.memory_report,       . <br></li></ol><br> ,     ,      ,   v_result_cache_objects  . <br><br><blockquote>   ,  support note ‚Äî   support ,   . <br></blockquote><br><img src="https://habrastorage.org/webt/me/ut/5o/meut5o7krxdlelwjxgavdxrq-fe.jpeg"><br><br>    ,       ,   :     - .    ,    ,      : <br><br><ol><li>  hint result_cache; </li><li>  hint no result_cache; </li><li>  black_list,  ,   ,   -. </li></ol><br> <strong>    ?</strong> <br><br><ul><li>   ,  - , ,      ; </li><li>     ,    ,   . ,   - ,  ,   . </li></ul><br>   , <strong>     ‚Äî     </strong> .  Oracle  ,  . <br><br><h3> Client side result cache <br></h3><br><img src="https://habrastorage.org/webt/mk/6s/5m/mk6s5m24srinff6gkhrmxxei7xu.jpeg"><br><br>  O diagrama do seu dispositivo √© mostrado acima, estes s√£o os principais componentes do banco de dados e do driver. <br><br>  Na primeira vez em que o lado do cliente √© acessado, o cache de resultados acessa o banco de dados, que √© pr√©-configurado, recebe o tamanho do cache do cliente e instala esse cache no cliente uma vez na primeira conex√£o.  A consulta em cache primeiro acessa o banco de dados e grava dados no cache.  Os segmentos restantes solicitam um cache de driver compartilhado, economizando mem√≥ria e recursos do servidor.  A prop√≥sito, √†s vezes, dependendo da carga, o driver envia estat√≠sticas sobre o uso do cache ao banco de dados, que pode ser visualizado. <br><br>  <strong>Uma pergunta interessante √©: como a defici√™ncia acontece?</strong> <br><br>  Existem dois modos de invalida√ß√£o, que s√£o aprimorados pelo par√¢metro Invalidation lag.  √â o quanto o Oracle permite que o cache do driver n√£o seja consistente. <br><br>  O primeiro modo √© usado quando as solicita√ß√µes s√£o frequentes e o atraso de Invalida√ß√£o n√£o ocorre.  Nesse caso, o fluxo ir√° para o banco de dados, atualizar√° os caches e ler√° os dados dele. <br><br><img src="https://habrastorage.org/webt/ah/wo/u1/ahwou1tplbgyiq4w8lizx0raeto.jpeg"><br><br>  Se o atraso da Invalida√ß√£o falhar, qualquer solicita√ß√£o n√£o armazenada em cache, referente ao banco de dados, al√©m dos resultados da consulta, traz uma lista de objetos inv√°lidos.  Assim, eles s√£o marcados como inv√°lidos no cache e tudo funciona como na imagem desde o primeiro cen√°rio. <br><br>  No segundo caso, se tiver passado mais tempo do que o atraso da Invalida√ß√£o, o pr√≥prio cliente result_cache vai ao banco de dados e diz: "D√™-me uma lista de altera√ß√µes!"  Ou seja, ele pr√≥prio mant√©m seu estado adequado. <br><br>  <strong>A configura√ß√£o do cache de resultados do lado do cliente √© muito simples</strong> .  Existem 2 op√ß√µes: <br><br><ol><li>  CLIENT_RESULT_CACHE_LAG - valor do atraso no cache; </li><li>  CLIENT_RESULT_CACHE_SIZE - tamanho (m√≠nimo 32 Kb, m√°ximo - 2 GB). </li></ol><br><img src="https://habrastorage.org/webt/ky/zl/mh/kyzlmhtgmgjkodcgtwkjm6sqoym.jpeg"><br><br>  Do ponto de vista do desenvolvedor do aplicativo, o cache do cliente n√£o √© muito diferente do cache do servidor, eles tamb√©m inseriram a dica result_cache.  Se fosse, ele come√ßar√° a ser usado pelo cliente - no .Net e no Java. <br><br><img src="https://habrastorage.org/webt/xo/bv/of/xobvof-_m9gwfhdocpw5dywqshe.jpeg"><br><br>  Depois de fazer 10 itera√ß√µes da consulta, obtive o seguinte. <br><br><img src="https://habrastorage.org/webt/vq/zs/di/vqzsdifg9jkvb18jnrgy_bu9je4.jpeg"><br><br>  O primeiro apelo √© a cria√ß√£o, depois 9 acessos ao cache.  A tabela indica que a mem√≥ria tamb√©m est√° alocada em blocos.  Tamb√©m preste aten√ß√£o ao SELECT - n√£o √© muito intuitivo.  Para ser sincero, antes de come√ßar a lidar com isso, eu nem sabia que havia uma representa√ß√£o de <code>GV$SESSION_CONNECT_INFO</code> .  Por que a Oracle n√£o levou diretamente a esta tabela (e esta √© uma tabela, n√£o uma exibi√ß√£o), eu n√£o conseguia entender.  Mas √© por isso que acredito que essa funcionalidade n√£o √© muito popular, embora, como me pare√ßa, seja muito √∫til. <br><br>  <strong>Vantagens do armazenamento em cache do cliente:</strong> <br><br><ul><li>  mem√≥ria barata do cliente; </li><li>  qualquer driver dispon√≠vel - JDBC, .NET, etc; </li><li>  impacto m√≠nimo no c√≥digo do aplicativo. </li><li>  Reduzindo a carga na CPU, E / S e geralmente no banco de dados; </li><li>  n√£o h√° necessidade de aprender e usar todos os tipos de camadas e APIs de cache inteligente; </li><li>  sem travas. </li></ul><br>  <strong>Desvantagens:</strong> <br><br><ul><li>  consist√™ncia na leitura com atraso - em princ√≠pio, agora esta √© uma tend√™ncia; </li><li>  precisa do cliente Oracle OCI; </li><li>  limita√ß√£o de 2 GB por cliente, mas em geral 2 GB √© muito; </li><li>  Para mim, pessoalmente, a principal limita√ß√£o √© um pouco de informa√ß√£o sobre produ√ß√£o. </li></ul><br>  No suporte, que sempre usamos ao trabalhar com o result_cache, encontrei apenas 5 bugs.  Isso sugere que, provavelmente, poucas pessoas precisam disso. <br><br>  Ent√£o, reunimos tudo o que foi dito acima. <br><br><h3>  <strong>Cache feito √† m√£o</strong> <br></h3><br>  <strong>Cen√°rios ruins:</strong> <br><br><ul><li>  Altera√ß√£o instant√¢nea - se, ap√≥s a altera√ß√£o dos dados, o cache se tornar imediatamente irrelevante.  Para caches criados manualmente, √© dif√≠cil criar a invalida√ß√£o correta em caso de altera√ß√µes nos objetos nos quais eles s√£o criados. </li><li>  Se o uso da l√≥gica armazenada no banco de dados for proibido pelas pol√≠ticas de desenvolvimento. </li></ul><br>  <strong>Bons cen√°rios:</strong> <br><br><ul><li>  Existe uma forte equipe de desenvolvimento de banco de dados. </li><li>  Implementada l√≥gica PL / SQL. </li><li>  Existem limita√ß√µes que impedem o uso de outras t√©cnicas de armazenamento em cache. </li></ul><br><h3>  <strong>Cache de resultados do lado do servidor</strong> <br></h3><br>  <strong>Cen√°rios ruins:</strong> <br><br><ul><li>  Muitos resultados diferentes que apenas lavam o cache inteiro; </li><li>  As solicita√ß√µes demoram mais que _RESULT_CACHE_TIMEOUT ou esse par√¢metro est√° configurado incorretamente. </li><li>  Os resultados de sess√µes muito grandes s√£o carregados no cache em threads paralelos. </li></ul><br>  <strong>Bons cen√°rios:</strong> <br><br><ul><li>  Quantidade razo√°vel de resultados em cache. </li><li>  Conjuntos de dados relativamente pequenos (200 a 300 linhas). </li><li>  SQL bastante caro, caso contr√°rio, o tempo todo vai para travas. </li><li>  Tabelas mais ou menos est√°ticas. </li><li>  Existe um DBA, que em caso de algo vir√° e salvar√° a todos. </li></ul><br><h3>  <strong>Cache de resultados do lado do cliente</strong> <br></h3><br>  <strong>Cen√°rios ruins:</strong> <br><br><ul><li>  Quando surge o pr√≥prio problema da incapacidade instant√¢nea. </li><li>  Drivers finos necess√°rios. <br></li></ul><br>  <strong>Bons cen√°rios:</strong> <br><br><ul><li>  Existe uma equipe de desenvolvimento normal da camada intermedi√°ria. </li><li>  Muito SQL j√° est√° em uso sem o uso de uma camada de cache externa que possa ser facilmente conectada. </li><li>  Existem restri√ß√µes nas gl√¢ndulas. </li></ul><br><br><h2>  Conclus√µes <br></h2><br>  Acredito que minha hist√≥ria seja sobre a dor no cache de Resultados do lado do servidor, portanto as conclus√µes s√£o as seguintes: <br><br><ol><li>  Sempre avalie o tamanho da mem√≥ria corretamente, levando em considera√ß√£o o n√∫mero de consultas e n√£o o n√∫mero de resultados, ou seja, blocos, APEX, trabalho, estat√≠sticas adaptativas etc. </li><li>  N√£o tenha medo de usar as op√ß√µes de libera√ß√£o autom√°tica de cache (captura instant√¢nea + validade). </li><li>  N√£o sobrecarregue o cache com solicita√ß√µes ao carregar grandes quantidades de dados; desative o result_cache antes disso.  Aque√ßa o cache. </li><li>  Certifique-se de que _result_cache_timeout atenda √†s suas expectativas. </li><li>  NUNCA use FORCE para todo o banco de dados.  Precisa de um banco de dados em mem√≥ria - use uma solu√ß√£o especializada em mem√≥ria. </li><li>  Verifique se a op√ß√£o FORCE √© usada adequadamente para tabelas individuais, para que n√£o funcione, como ocorre com ETLs de terceiros. </li><li>  Decida se as estat√≠sticas adaptativas s√£o t√£o boas quanto as descritas pelo Oracle (_optimizer_ads_use_result_cache = false). </li></ol><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Highload ++ Siberia na</a> pr√≥xima segunda-feira, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">programa√ß√£o est√°</a> pronta e publicada no site.  Existem v√°rios relat√≥rios no t√≥pico deste artigo: <br><br><ul><li>  <strong>Alexander Makarov</strong> (CFT GC) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">demonstrar√° um</a> m√©todo para identificar gargalos no lado do servidor do software usando o banco de dados Oracle como exemplo. <br></li><li>  <strong>Ivan Sharov</strong> e <strong>Konstantin Poluektov</strong> lhe dir√£o quais problemas surgem ao migrar o produto para novas vers√µes do banco de dados Oracle e tamb√©m prometem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dar recomenda√ß√µes</a> sobre a organiza√ß√£o e realiza√ß√£o de tal trabalho. <br></li><li>  <strong>Nikolay Golov</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mostrar√°</a> como garantir a integridade dos dados em uma arquitetura de microsservi√ßo, sem transa√ß√µes distribu√≠das e conectividade r√≠gida. <br></li></ul><br>  <strong>Encontre-me em Novosibirsk!</strong> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414401/">https://habr.com/ru/post/pt414401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414389/index.html">Analisando logs de dispositivos Cisco usando o Splunk Cisco Security Suite</a></li>
<li><a href="../pt414393/index.html">Rob√¥ operado por voz em 1961</a></li>
<li><a href="../pt414395/index.html">Mais f√°cil do que parece. Fratura</a></li>
<li><a href="../pt414397/index.html">O FCS prop√µe reduzir o limite de isen√ß√£o de impostos para zero</a></li>
<li><a href="../pt414399/index.html">O uso da produ√ß√£o digital em neg√≥cios e educa√ß√£o reais</a></li>
<li><a href="../pt414403/index.html">A Fujitsu criou uma nova tecnologia de modelagem molecular</a></li>
<li><a href="../pt414405/index.html">Instalar certificado no servidor HTTP Apache</a></li>
<li><a href="../pt414411/index.html">Wiren Board 6: novamente em Habr√© com a nova vers√£o do controlador para automa√ß√£o</a></li>
<li><a href="../pt414413/index.html">Sinopse e v√≠deo da hist√≥ria sobre redes na ind√∫stria de jogos com o gamedev do festival</a></li>
<li><a href="../pt414415/index.html">Confer√™ncia Tarantool 21 de junho - n√£o apenas sobre Tarantool, mas em geral sobre computa√ß√£o em mem√≥ria</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>