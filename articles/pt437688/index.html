<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüë¶‚Äçüë¶ üîΩ üö¥üèø OpenSceneGraph: T√©cnicas b√°sicas de programa√ß√£o üë≤üèΩ üéê üôÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 Este artigo focar√° n√£o apenas nos gr√°ficos, mas tamb√©m na organiza√ß√£o do aplicativo que o utiliza, levando em considera√ß√£o as especifi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: T√©cnicas b√°sicas de programa√ß√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437688/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="imagem"><br><h1>  1. Introdu√ß√£o </h1><br>  Este artigo focar√° n√£o apenas nos gr√°ficos, mas tamb√©m na organiza√ß√£o do aplicativo que o utiliza, levando em considera√ß√£o as especificidades do mecanismo OpenSceneGraph e o software que ele fornece. <br><br>  N√£o √© segredo que a chave para o sucesso de qualquer produto de software √© uma arquitetura bem projetada que forne√ßa a capacidade de manter e expandir o c√≥digo escrito.  Nesse sentido, o mecanismo que estamos considerando est√° em um n√≠vel bastante alto, fornecendo ao desenvolvedor um kit de ferramentas muito amplo, proporcionando a constru√ß√£o de uma arquitetura modular flex√≠vel. <br><br>  Este artigo √© bastante longo e inclui uma vis√£o geral das v√°rias ferramentas e t√©cnicas (padr√µes de design, se voc√™ desejar) fornecidas pelo mecanismo do desenvolvedor.  Todas as se√ß√µes do artigo s√£o fornecidas com exemplos, cujo c√≥digo pode ser obtido no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">meu reposit√≥rio</a> . <br><a name="habracut"></a><br><h1>  1. Analisando Op√ß√µes da Linha de Comandos </h1><br>  No C / C ++, os par√¢metros da linha de comando s√£o passados ‚Äã‚Äãatrav√©s dos argumentos para a fun√ß√£o main ().  Nos exemplos anteriores, marcamos cuidadosamente esses par√¢metros como n√£o utilizados, agora vamos us√°-los para informar alguns dados ao programa quando ele for iniciado. <br><br>  O OSG possui ferramentas de an√°lise de linha de comando internas. <br><br>  Crie o seguinte exemplo <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de linha de comando</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre> <br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ArgumentParser args(&amp;argc, argv); std::string filename; args.read(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"--model"</span></span></span><span class="hljs-meta">, filename); osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; root = osgDB::readNodeFile(filename); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Defina os par√¢metros de inicializa√ß√£o do programa no QtCreator <br><br><img src="https://habrastorage.org/webt/41/le/8p/41le8pjjdv2q-in3idhgnpe6-ao.png"><br><br>  Executando o programa para execu√ß√£o, obtemos o resultado (modelo de caminh√£o <a href="">retirado do mesmo OpenSceneGraph-Data</a> ) <br><br><img src="https://habrastorage.org/webt/t-/_o/bb/t-_obbiwlzwuax1e336kqd6tosy.png"><br><br>  Agora vamos ver um exemplo linha por linha <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">ArgumentParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;argc, argv)</span></span></span></span>;</code> </pre><br>  cria uma inst√¢ncia da classe analisador de linha de comando osg :: ArgumentParser.  Quando criado, o construtor de classe recebe os argumentos aceitos pela fun√ß√£o main () do sistema operacional. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> filename; args.read(<span class="hljs-string"><span class="hljs-string">"--model"</span></span>, filename);</code> </pre><br>  analisamos os argumentos, ou seja, procuramos a chave ‚Äú‚Äìmodel‚Äù entre eles, colocando seu valor na string filename.  Assim, usando essa chave, transferimos o nome do arquivo com um modelo tridimensional para o programa.  Em seguida, carregamos este modelo e o exibimos <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFile(filename); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  O m√©todo read () da classe osg :: ArgumentParser possui muitas sobrecargas, permitindo que voc√™ leia n√£o apenas valores de string da linha de comando, mas tamb√©m n√∫meros inteiros, n√∫meros de ponto flutuante, vetores, etc.  Por exemplo, voc√™ pode ler um determinado par√¢metro do tipo float <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> size = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; args.read(<span class="hljs-string"><span class="hljs-string">"--size"</span></span>, size);</code> </pre><br>  Se esse par√¢metro n√£o for exibido na linha de comando, seu valor permanecer√° como estava ap√≥s a inicializa√ß√£o da vari√°vel de tamanho. <br><br><h1>  2. Mecanismo de notifica√ß√£o e registro </h1><br>  O OpenSceneGraph possui um mecanismo de notifica√ß√£o que permite exibir mensagens de depura√ß√£o durante o processo de renderiza√ß√£o, bem como iniciado pelo desenvolvedor.  Esta √© uma grande ajuda ao rastrear e depurar um programa.  O sistema de notifica√ß√£o OSG suporta a sa√≠da de informa√ß√µes de diagn√≥stico (erros, avisos, notifica√ß√µes) no n√≠vel do n√∫cleo do mecanismo e seus plug-ins.  O desenvolvedor pode exibir uma mensagem de diagn√≥stico durante a opera√ß√£o do programa usando a fun√ß√£o osg :: notify (). <br><br>  Esta fun√ß√£o funciona como um fluxo de sa√≠da padr√£o da biblioteca C ++ padr√£o atrav√©s da sobrecarga do operador &lt;&lt;.  Ele leva o n√≠vel da mensagem como argumento: SEMPRE, FATAL, WARN, AVISO, INFORMA√á√ÉO, DEBUG_INFO e DEBUG_FP.  Por exemplo <br><br><pre> <code class="cpp hljs">osg::notify(osg::WARN) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Some warning message"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  exibe um aviso com texto definido pelo usu√°rio. <br><br>  As notifica√ß√µes OSG podem conter informa√ß√µes importantes sobre o estado do programa, extens√µes do subsistema gr√°fico do computador, poss√≠veis problemas com o mecanismo. <br><br>  Em alguns casos, √© necess√°rio enviar esses dados n√£o para o console, mas para poder redirecionar essa sa√≠da para um arquivo (na forma de um log) ou para qualquer outra interface, incluindo um widget gr√°fico.  O mecanismo cont√©m uma classe especial osg :: NotifyHandler que fornece redirecionamento de notifica√ß√µes para o fluxo de sa√≠da que o desenvolvedor precisa. <br><br>  Usando um exemplo simples, considere como voc√™ pode redirecionar a sa√≠da de notifica√ß√µes, por exemplo, para um arquivo de log de texto.  Escreva o seguinte c√≥digo <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de notifica√ß√£o</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;fstream&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> class LogFileHandler : public osg::NotifyHandler { public: LogFileHandler(const std::string &amp;file) { _log.open(file.c_str()); } virtual ~LogFileHandler() { _log.close(); } virtual void notify(osg::NotifySeverity severity, const char *msg) { _log </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; msg; } protected: std::ofstream _log; }; int main(int argc, char *argv[]) { osg::setNotifyLevel(osg::INFO); osg::setNotifyHandler(new LogFileHandler("../logs/log.txt")); osg::ArgumentParser args(&amp;argc, argv); osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); if (!root) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; ": No data loaded." &lt;&lt; std::endl; return -1; } osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Para redirecionar a sa√≠da, escrevemos a classe LogFileHandler, que √© a sucessora de osg :: NotifyHandler.  O construtor e destruidor desta classe controla a abertura e o fechamento do fluxo de sa√≠da _log ao qual o arquivo de texto est√° associado.  O m√©todo notify () √© um m√©todo de classe base semelhante que redefinimos para gerar as notifica√ß√µes de arquivo enviadas pelo OSG durante a opera√ß√£o atrav√©s do par√¢metro msg. <br><br>  <strong>Classe LogFileHandler</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogFileHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::NotifyHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: LogFileHandler(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;file) { _log.open(file.c_str()); } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~LogFileHandler() { _log.close(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::NotifySeverity severity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *msg)</span></span></span><span class="hljs-function"> </span></span>{ _log &lt;&lt; msg; } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ofstream _log; };</code> </pre><br>  Em seguida, no programa principal, execute as configura√ß√µes necess√°rias <br><br><pre> <code class="cpp hljs">osg::setNotifyLevel(osg::INFO);</code> </pre><br>  defina o n√≠vel de notifica√ß√µes INFO, ou seja, a sa√≠da para o log de todas as informa√ß√µes sobre a opera√ß√£o do mecanismo, incluindo as notifica√ß√µes atuais de opera√ß√£o normal. <br><br><pre> <code class="cpp hljs">osg::setNotifyHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LogFileHandler(<span class="hljs-string"><span class="hljs-string">"../logs/log.txt"</span></span>));</code> </pre><br>  instale o manipulador de notifica√ß√µes.  Em seguida, processamos argumentos de linha de comando nos quais os caminhos para os modelos carregados s√£o transmitidos <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">ArgumentParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;argc, argv)</span></span></span></span>; osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!root) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">": No data loaded."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br>  Ao mesmo tempo, lidamos com a situa√ß√£o de falta de dados na linha de comando, exibindo uma mensagem no modo manual de logon usando a macro OSG_FATAL.  Execute o programa com os seguintes argumentos <br><br><img src="https://habrastorage.org/webt/mc/h4/so/mch4sot5pfjjpq9vb2dlolnjllm.png"><br><br>  obtendo sa√≠da para um arquivo de log como este <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de log OSG</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Opened DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_osgd.dll CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() Opened DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_deprecated_osgd.dll OSGReaderWriter wrappers loaded OK CullSettings::readEnvironmentalVariables() void StateSet::setGlobalDefaults() void StateSet::setGlobalDefaults() ShaderPipeline disabled. StateSet::setGlobalDefaults() Setting up GL2 compatible shaders CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() ShaderComposer::ShaderComposer() 0xa5ce8f0 CullSettings::readEnvironmentalVariables() ShaderComposer::ShaderComposer() 0xa5ce330 View::setSceneData() Reusing existing scene0xa514220 CameraManipulator::computeHomePosition(0, 0) boundingSphere.center() = (-6.40034 1.96225 0.000795364) boundingSphere.radius() = 16.6002 CameraManipulator::computeHomePosition(0xa52f138, 0) boundingSphere.center() = (-6.40034 1.96225 0.000795364) boundingSphere.radius() = 16.6002 Viewer::realize() - No valid contexts found, setting up view across all screens. Applying osgViewer::ViewConfig : AcrossAllScreens . . . . ShaderComposer::~ShaderComposer() 0xa5ce330 ShaderComposer::~ShaderComposer() 0xa5ce8f0 ShaderComposer::~ShaderComposer() 0xa5d6228 close(0x1)0xa5d3e50 close(0)0xa5d3e50 ContextData::unregisterGraphicsContext 0xa5d3e50 DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. ShaderComposer::~ShaderComposer() 0xa5de4e0 close(0x1)0xa5ddba0 close(0)0xa5ddba0 ContextData::unregisterGraphicsContext 0xa5ddba0 Done destructing osg::View DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. Closing DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_osgd.dll Closing DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_deprecated_osgd.dll</code> </pre><br></div></div><br>  N√£o importa que, no momento, essas informa√ß√µes possam parecer in√∫teis para voc√™ - no futuro, essa conclus√£o poder√° ajudar a depurar erros no seu programa. <br><br>  Por padr√£o, o OSG envia mensagens para a sa√≠da padr√£o std :: cout e mensagens de erro para o fluxo std :: cerr.  No entanto, substituindo o manipulador de notifica√ß√£o, conforme mostrado no exemplo, essa sa√≠da pode ser redirecionada para qualquer fluxo de sa√≠da, incluindo elementos da GUI. <br><br>  Lembre-se de que, ao definir um n√≠vel alto de notifica√ß√µes (por exemplo, FATAL), o sistema ignora todas as notifica√ß√µes de n√≠vel inferior.  Por exemplo, em um caso semelhante <br><br><pre> <code class="cpp hljs">osg::setNotifyLevel(osg::FATAL); . . . osg::notify(osg::WARN) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Some message."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  uma mensagem personalizada simplesmente n√£o ser√° exibida. <br><br><h1>  3. Intercep√ß√£o de atributos geom√©tricos </h1><br>  A classe osg :: Geometry gerencia um conjunto de dados que descreve v√©rtices e exibe uma malha de pol√≠gono usando um conjunto ordenado de primitivas.  No entanto, essa classe n√£o tem id√©ia sobre elementos da topologia do modelo, como faces, arestas e o relacionamento entre elas.  Essa nuance impede a implementa√ß√£o de coisas como mover determinadas faces, por exemplo, ao animar modelos.  Atualmente, o OSG n√£o suporta essa funcionalidade. <br><br>  No entanto, o mecanismo implementa v√°rios functores que permitem reler os atributos geom√©tricos de qualquer objeto e us√°-los para modelar a topologia da malha poligonal.  No C ++, um functor √© uma constru√ß√£o que permite usar um objeto como uma fun√ß√£o. <br><br>  A classe osg :: Drawable fornece ao desenvolvedor quatro tipos de functores: <br><br><ol><li>  osg :: Drawable :: AttributeFunctor - l√™ os atributos dos v√©rtices como uma matriz de ponteiros.  Ele possui v√°rios m√©todos virtuais para aplicar atributos de v√©rtice de diferentes tipos de dados.  Para usar este functor, voc√™ deve descrever a classe e substituir um ou mais de seus m√©todos, dentro dos quais as a√ß√µes requeridas pelo desenvolvedor s√£o executadas <br></li></ol><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Drawable::AttributeType type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, osg::Vec3* ptr )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  3-     ptr. //      }</span></span></code> </pre><br><ol><li>  osg :: Drawable :: ConstAttributeFunctor - vers√£o somente leitura do functor anterior: um ponteiro para uma matriz de vetores √© passado como um par√¢metro constante <br></li><li>  osg :: PrimitiveFunctor - imita o processo de renderiza√ß√£o de objetos OpenGL.  Sob o pretexto de renderizar um objeto, os m√©todos functor substitu√≠dos pelo desenvolvedor s√£o chamados.  Esse functor possui duas subclasses de modelo importantes: osg :: TemplatePrimitiveFunctor &lt;&gt; e osg :: TriangleFunctor &lt;&gt;.  Essas classes recebem v√©rtices primitivos como par√¢metros e os transmitem aos m√©todos do usu√°rio usando o operador operator (). <br></li><li>  osg :: PrimitiveIndexFunctor - executa as mesmas a√ß√µes que o functor anterior, mas aceita os √≠ndices de v√©rtice da primitiva como par√¢metro. <br></li></ol><br>  Classes derivadas de osg :: Drawable, como osg :: ShapeDrawable e osg :: Geometry, t√™m um m√©todo accept () para aplicar v√°rios functores. <br><br><h1>  4. Exemplo de uso do functor primitivo </h1><br>  Ilustramos a funcionalidade descrita usando o exemplo de coleta de informa√ß√µes sobre faces triangulares e pontos de alguma geometria que determinamos anteriormente. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de Functor</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geode&gt; #include &lt;osg/Geometry&gt; #include &lt;osg/TriangleFunctor&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;iostream&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> std::string vec2str(const osg::Vec3 &amp;v) { std::string tmp = std::to_string(vx()); tmp += </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" "</span></span></span><span class="hljs-meta">; tmp += std::to_string(vy()); tmp += </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" "</span></span></span><span class="hljs-meta">; tmp += std::to_string(vz()); return tmp; } struct FaceCollector { void operator()(const osg::Vec3 &amp;v1, const osg::Vec3 &amp;v2, const osg::Vec3 &amp;v3) { std::cout </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "Face vertices: " &lt;&lt; vec2str(v1) &lt;&lt; "; " &lt;&lt; vec2str(v2) &lt;&lt; "; " &lt;&lt; vec2str(v3) &lt;&lt; std::endl; } }; int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 1.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.5f) ); vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 1.0f) ); vertices-&gt;push_back( osg::Vec3(3.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(3.0f, 0.0f, 1.5f) ); vertices-&gt;push_back( osg::Vec3(4.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(4.0f, 0.0f, 1.0f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;setNormalArray(normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); geom-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUAD_STRIP, 0, 10)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); osg::TriangleFunctor&lt;FaceCollector&gt; functor; geom-&gt;accept(functor); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Omitindo o processo de cria√ß√£o de geometria considerada por n√≥s muitas vezes, vamos prestar aten√ß√£o ao seguinte.  Definimos uma estrutura FaceCollector para a qual redefinimos operator () da seguinte maneira <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FaceCollector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;v3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Face vertices: "</span></span> &lt;&lt; vec2str(v1) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"; "</span></span> &lt;&lt; vec2str(v2) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"; "</span></span> &lt;&lt; vec2str(v3) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } };</code> </pre><br>  Este operador, quando chamado, exibir√° as coordenadas dos tr√™s v√©rtices transmitidos a ele pelo mecanismo.  A fun√ß√£o vec2str √© necess√°ria para converter os componentes do vetor osg :: Vec3 em std :: string.  Para chamar o functor, crie uma inst√¢ncia e passe-a para o objeto geometry atrav√©s do m√©todo accept () <br><br><pre> <code class="cpp hljs">osg::TriangleFunctor&lt;FaceCollector&gt; functor; geom-&gt;accept(functor);</code> </pre><br>  Essa chamada, como mencionado acima, imita a renderiza√ß√£o da geometria, substituindo o pr√≥prio desenho, chamando um m√©todo functor substitu√≠do.  Nesse caso, ele ser√° chamado durante o "desenho" de cada um dos tri√¢ngulos que comp√µem a geometria do exemplo. <br><br>  Na tela, temos essa geometria <br><br><img src="https://habrastorage.org/webt/ai/-a/6v/ai-a6vj4eeubetgk0bpicmjbgfm.png"><br><br>  e um escape para o console <br><br><pre> <code class="plaintext hljs">Face vertices: 0.000000 0.000000 0.000000; 0.000000 0.000000 1.000000; 1.000000 0.000000 0.000000 Face vertices: 0.000000 0.000000 1.000000; 1.000000 0.000000 1.500000; 1.000000 0.000000 0.000000 Face vertices: 1.000000 0.000000 0.000000; 1.000000 0.000000 1.500000; 2.000000 0.000000 0.000000 Face vertices: 1.000000 0.000000 1.500000; 2.000000 0.000000 1.000000; 2.000000 0.000000 0.000000 Face vertices: 2.000000 0.000000 0.000000; 2.000000 0.000000 1.000000; 3.000000 0.000000 0.000000 Face vertices: 2.000000 0.000000 1.000000; 3.000000 0.000000 1.500000; 3.000000 0.000000 0.000000 Face vertices: 3.000000 0.000000 0.000000; 3.000000 0.000000 1.500000; 4.000000 0.000000 0.000000 Face vertices: 3.000000 0.000000 1.500000; 4.000000 0.000000 1.000000; 4.000000 0.000000 0.000000</code> </pre><br>  De fato, ao chamar geom-&gt; accept (...), tri√¢ngulos n√£o s√£o renderizados, chamadas OpenGL s√£o simuladas e, em vez deles, dados sobre os v√©rtices do tri√¢ngulo, cuja renderiza√ß√£o √© simulada <br><br><img src="https://habrastorage.org/webt/gx/gp/il/gxgpilewn7pw26w9tdy-e28ypds.png"><br><br>  A classe osg :: TemplatePrimitiveFunctor coleta dados n√£o apenas sobre tri√¢ngulos, mas tamb√©m sobre quaisquer outras primitivas do OpenGL.  Para implementar o processamento desses dados, voc√™ deve substituir os seguintes operadores no argumento do modelo <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   void operator()( const osg::Vec3&amp;, bool ); //   void operator()( const osg::Vec3&amp;, const osg::Vec3&amp;, bool ); //   void operator()( const osg::Vec3&amp;, const osg::Vec3&amp;, const osg::Vec3&amp;, bool ); //   void operator()( const osg::Vec3&amp;, const osg::Vec3&amp;, const osg::Vec3&amp;, const osg::Vec3&amp;, bool );</span></span></code> </pre><br><br><h1>  5. O Padr√£o do Visitante </h1><br>  O padr√£o de visitante √© usado para acessar opera√ß√µes para alterar os elementos do gr√°fico de cena sem alterar as classes desses elementos.  A classe de visitante implementa todas as fun√ß√µes virtuais relevantes para aplic√°-las a v√°rios tipos de elementos por meio de um mecanismo de despacho duplo.  Usando esse mecanismo, o desenvolvedor pode criar sua pr√≥pria inst√¢ncia de visitante implementando a funcionalidade necess√°ria com a ajuda de operadores especiais e vinculando o visitante a v√°rios tipos de elementos gr√°ficos de cena em tempo real, sem alterar a funcionalidade dos pr√≥prios elementos.  Essa √© uma √≥tima maneira de estender a funcionalidade de um elemento sem definir subclasses desses elementos. <br><br>  Para implementar esse mecanismo no OSG, a classe osg :: NodeVisitor √© definida.  A classe herdada de osg :: NodeVisitor se move pelo gr√°fico da cena, visita cada n√≥ e aplica as opera√ß√µes definidas pelo desenvolvedor a ele.  Essa √© a classe principal usada para intervir no processo de atualiza√ß√£o de n√≥s e recortar n√≥s invis√≠veis, al√©m de aplicar outras opera√ß√µes relacionadas √† modifica√ß√£o da geometria dos n√≥s de cenas, como osgUtil :: SmoothingVisitor, osgUtil :: Simplifier e osgUtil :: TriStripVisitor. <br><br>  Para subclassificar o visitante, devemos substituir um ou mais m√©todos apply () sobrecarregados virtuais fornecidos pela classe base osg :: NodeVisitor.  A maioria dos principais tipos de n√≥s OSG possui esses m√©todos.  O visitante chamar√° automaticamente o m√©todo apply () para cada um dos n√≥s visitados ao percorrer o gr√°fico da cena da cena.  O desenvolvedor substitui o m√©todo apply () para cada um dos tipos de n√≥s que ele precisa. <br><br>  Na implementa√ß√£o do m√©todo apply (), o desenvolvedor, no momento apropriado, deve chamar o m√©todo traverse () da classe base osg :: NodeVisitor.  Isso inicia a transi√ß√£o do visitante para o pr√≥ximo n√≥, um filho ou um vizinho no n√≠vel da hierarquia, se o n√≥ atual n√£o tiver nenhum n√≥ filho no qual a transi√ß√£o possa ser feita.  A aus√™ncia de uma chamada para atravessar () significa interromper a travessia do gr√°fico de cena e o restante do gr√°fico de cena √© ignorado. <br><br>  Sobrecargas do m√©todo apply () t√™m formatos unificados <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Node&amp; )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Geode&amp; )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Group&amp; )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Transform&amp; )</span></span></span></span>;</code> </pre><br>  Para ignorar o subgr√°fico do n√≥ atual do objeto visitante, voc√™ deve definir o modo de rastreamento, por exemplo, <br><br><pre> <code class="cpp hljs">ExampleVisitor visitor; visitor-&gt;setTraversalMode( osg::NodeVisitor::TRAVERSE_ALL_CHILDREN ); node-&gt;accept( visitor );</code> </pre><br>  O modo de desvio √© definido por v√°rios enumeradores <br><br><ol><li>  TRAVERSE_ALL_CHILDREN - movendo-se por todos os n√≥s filhos. <br></li><li>  TRAVERSE_PARENTS - retorna do n√≥ atual, n√£o alcan√ßando o n√≥ raiz <br></li><li>  TRAVERSE_ACTIVE_CHILDREN - ignora n√≥s exclusivamente ativos, ou seja, aqueles cuja visibilidade √© ativada atrav√©s do n√≥ osg :: Switch. <br></li></ol><br><br><h1>  6. An√°lise da estrutura do cessna em chamas </h1><br>  O desenvolvedor sempre pode analisar a parte do gr√°fico de cena gerada pelo modelo carregado no arquivo. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de Functor</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;iostream&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class InfoVisitor : public osg::NodeVisitor { public: InfoVisitor() : _level(0) { setTraversalMode(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN); } std::string spaces() { return std::string(_level * 2, ' '); } virtual void apply(osg::Node &amp;node); virtual void apply(osg::Geode &amp;geode); protected: unsigned int _level; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void InfoVisitor::apply(osg::Node &amp;node) { std::cout &lt;&lt; spaces() &lt;&lt; node.libraryName() &lt;&lt; "::" &lt;&lt; node.className() &lt;&lt; std::endl; _level++; traverse(node); _level--; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void InfoVisitor::apply(osg::Geode &amp;geode) { std::cout &lt;&lt; spaces() &lt;&lt; geode.libraryName() &lt;&lt; "::" &lt;&lt; geode.className() &lt;&lt; std::endl; _level++; for (unsigned int i = 0; i &lt; geode.getNumDrawables(); ++i) { osg::Drawable *drawable = geode.getDrawable(i); std::cout &lt;&lt; spaces() &lt;&lt; drawable-&gt;libraryName() &lt;&lt; "::" &lt;&lt; drawable-&gt;className() &lt;&lt; std::endl; } traverse(geode); _level--; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { osg::ArgumentParser args(&amp;argc, argv); osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); if (!root.valid()) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; ": No data leaded. " &lt;&lt; std::endl; return -1; } InfoVisitor infoVisitor; root-&gt;accept(infoVisitor); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Criamos a classe InfoVisitor, herdando-a de osg :: NodeVisitor <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InfoVisitor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::NodeVisitor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: InfoVisitor() : _level(<span class="hljs-number"><span class="hljs-number">0</span></span>) { setTraversalMode(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spaces</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(_level * <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::Node &amp;node)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::Geode &amp;geode)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _level; };</code> </pre><br>  A propriedade protected_level apontar√° para o n√≠vel do gr√°fico de cena no qual nossa classe de visitantes est√° localizada atualmente.  No construtor, inicialize o contador de n√≠vel e defina o modo de travessia do n√≥ - para ignorar todos os n√≥s filhos. <br><br>  Agora redefina os m√©todos apply () para n√≥s <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> InfoVisitor::apply(osg::Node &amp;node) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; node.libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; node.className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _level++; traverse(node); _level--; }</code> </pre><br>  Aqui vamos mostrar o tipo do n√≥ atual.  O m√©todo libraryName () para o n√≥ exibe o nome da biblioteca OSG em que esse n√≥ est√° implementado e o m√©todo className exibe o nome da classe do n√≥.  Esses m√©todos s√£o implementados atrav√©s do uso de macros no c√≥digo das bibliotecas OSG. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; node.libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; node.className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Depois disso, aumentamos o contador do n√≠vel do gr√°fico e chamamos o m√©todo traverse (), iniciando uma transi√ß√£o para um n√≠vel superior, para o n√≥ filho.  Ap√≥s retornar de traverse (), diminu√≠mos novamente o valor do contador.  √â f√°cil adivinhar que traverse () inicia uma chamada repetida para o m√©todo apply (), traverse repetido () j√° para um subgr√°fico iniciando no n√≥ atual.  Temos execu√ß√£o recursiva do visitante at√© atingirmos os n√≥s finais do gr√°fico de cena. <br><br>  Para um n√≥ final do tipo osg :: Geode, sua sobrecarga do m√©todo apply () √© substitu√≠da <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> InfoVisitor::apply(osg::Geode &amp;geode) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; geode.libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; geode.className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _level++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; geode.getNumDrawables(); ++i) { osg::Drawable *drawable = geode.getDrawable(i); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; drawable-&gt;libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; drawable-&gt;className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } traverse(geode); _level--; }</code> </pre><br>  com c√≥digo de trabalho semelhante, exceto que exibimos dados em todos os objetos geom√©tricos anexados ao n√≥ geom√©trico atual <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; geode.getNumDrawables(); ++i) { osg::Drawable *drawable = geode.getDrawable(i); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; drawable-&gt;libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; drawable-&gt;className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  Na fun√ß√£o main (), processamos argumentos de linha de comando atrav√©s dos quais passamos uma lista de modelos carregados na cena e formamos a cena <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">ArgumentParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;argc, argv)</span></span></span></span>; osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!root.valid()) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">": No data leaded. "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br>  Ao mesmo tempo, processamos erros relacionados √† aus√™ncia de nomes de arquivo de modelo na linha de comando.  Agora criamos uma classe de visitante e a passamos para o gr√°fico de cena para executar <br><br><pre> <code class="cpp hljs">InfoVisitor infoVisitor; root-&gt;accept(infoVisitor);</code> </pre><br>  A seguir, est√£o as etapas para iniciar o visualizador, o que j√° fizemos v√°rias vezes.  Depois de iniciar o programa com par√¢metros <br><br><pre> <code class="bash hljs">$ visitor ../data/cessnafire.osg</code> </pre><br>  veremos a seguinte sa√≠da para o console <br><br><pre> <code class="plaintext hljs">osg::Group osg::MatrixTransform osg::Geode osg::Geometry osg::Geometry osg::MatrixTransform osgParticle::ModularEmitter osgParticle::ModularEmitter osgParticle::ParticleSystemUpdater osg::Geode osgParticle::ParticleSystem osgParticle::ParticleSystem osgParticle::ParticleSystem osgParticle::ParticleSystem</code> </pre><br>  De fato, temos uma √°rvore completa da cena carregada.  Com licen√ßa, onde est√£o tantos n√≥s?  Tudo √© muito simples - os modelos do formato * .osg s√£o cont√™ineres que armazenam n√£o apenas dados sobre a geometria do modelo, mas tamb√©m outras informa√ß√µes sobre sua estrutura como um subgrafo da cena OSG.  A geometria do modelo, transforma√ß√µes, efeitos de part√≠culas que realizam fuma√ßa e chama s√£o todos n√≥s do gr√°fico de cena OSG.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualquer cena pode ser baixada de * .osg ou descarregada do visualizador para o formato * .osg. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este √© um exemplo simples de aplica√ß√£o da mec√¢nica do visitante. </font><font style="vertical-align: inherit;">De fato, dentro dos visitantes, voc√™ pode executar muitas opera√ß√µes para modificar os n√≥s quando o programa est√° sendo executado.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Controlando o comportamento dos n√≥s no gr√°fico de cena, substituindo o m√©todo traverse () </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma maneira importante de trabalhar com o OSG √© substituir o m√©todo traverse (). Esse m√©todo √© chamado toda vez que um quadro √© desenhado. Eles aceitam um par√¢metro do tipo osg :: NodeVisitor e que informa qual passagem do gr√°fico de cena est√° sendo executada atualmente (atualiza√ß√£o, processamento de eventos ou recorte). A maioria dos hosts OSG substitui esse m√©todo para implementar sua funcionalidade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deve-se lembrar que a substitui√ß√£o do m√©todo traverse () pode ser perigosa, pois afeta o processo de atravessar o gr√°fico da cena e pode levar √† exibi√ß√£o incorreta da cena. Tamb√©m √© inconveniente se voc√™ deseja adicionar novas funcionalidades a v√°rios tipos de n√≥s. Nesse caso, s√£o usados ‚Äã‚Äãretornos de chamada de n√≥, cuja conversa ser√° um pouco menor.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J√° sabemos que o n√≥ osg :: Switch pode controlar a exibi√ß√£o de seus n√≥s filhos, incluindo a exibi√ß√£o de alguns n√≥s e desativando a exibi√ß√£o de outros. </font><font style="vertical-align: inherit;">Mas como ele n√£o sabe fazer isso automaticamente, criaremos um novo n√≥ baseado no antigo, que alternar√° entre n√≥s filhos em diferentes momentos no tempo, de acordo com o valor do contador interno.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo de animswitch</font></font></b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class AnimatingSwitch : public osg::Switch { public: AnimatingSwitch() : osg::Switch(), _count(0) {} AnimatingSwitch(const AnimatingSwitch &amp;copy, const osg::CopyOp &amp;copyop = osg::CopyOp::SHALLOW_COPY) : osg::Switch(copy, copyop), _count(copy._count) {} META_Node(osg, AnimatingSwitch); virtual void traverse(osg::NodeVisitor &amp;nv); protected: unsigned int _count; }; void AnimatingSwitch::traverse(osg::NodeVisitor &amp;nv) { if (!((++_count) % 60) ) { setValue(0, !getValue(0)); setValue(1, !getValue(1)); } osg::Switch::traverse(nv); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;AnimatingSwitch&gt; root = new AnimatingSwitch; root-&gt;addChild(model1.get(), true); root-&gt;addChild(model2.get(), false); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos dar uma olhada neste exemplo. </font><font style="vertical-align: inherit;">Estamos criando uma nova classe AnimatingSwitch que herda de osg :: Switch.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnimatingSwitch</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::Switch { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AnimatingSwitch() : osg::Switch(), _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} AnimatingSwitch(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnimatingSwitch &amp;copy, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osg::CopyOp &amp;copyop = osg::CopyOp::SHALLOW_COPY) : osg::Switch(copy, copyop), _count(copy._count) {} META_Node(osg, AnimatingSwitch); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::NodeVisitor &amp;nv)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnimatingSwitch::traverse(osg::NodeVisitor &amp;nv) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) ) { setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } osg::Switch::traverse(nv); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esta classe cont√©m o construtor padr√£o. </font></font><br><br><pre> <code class="cpp hljs">AnimatingSwitch() : osg::Switch(), _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) {}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e construtor para c√≥pia, criado de acordo com os requisitos da OSG </font></font><br><br><pre> <code class="cpp hljs">AnimatingSwitch(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnimatingSwitch &amp;copy, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osg::CopyOp &amp;copyop = osg::CopyOp::SHALLOW_COPY) : osg::Switch(copy, copyop), _count(copy._count) {}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O construtor para copiar deve conter como par√¢metros: uma refer√™ncia constante √† inst√¢ncia da classe a ser copiada e o par√¢metro osg :: CopyOp que especifica as configura√ß√µes de c√≥pia da classe. </font><font style="vertical-align: inherit;">Cartas muito estranhas seguem</font></font><br><br><pre> <code class="cpp hljs">META_Node(osg, AnimatingSwitch);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa √© uma macro que forma a estrutura necess√°ria para o descendente de uma classe derivada de osg :: Node. </font><font style="vertical-align: inherit;">At√© atribuirmos import√¢ncia a essa macro, √© importante que ela esteja presente ao herdar de osg :: Switch ao definir todas as classes descendentes. </font><font style="vertical-align: inherit;">A classe cont√©m o campo protegido _count - o pr√≥prio contador com base no qual alternamos. </font><font style="vertical-align: inherit;">Implementamos a altern√¢ncia ao substituir o m√©todo traverse ()</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnimatingSwitch::traverse(osg::NodeVisitor &amp;nv) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) ) { setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } osg::Switch::traverse(nv); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A mudan√ßa do status de exibi√ß√£o dos n√≥s ocorrer√° toda vez que o valor do contador (aumentando cada chamada de m√©todo) for m√∫ltiplo de 60. Compilamos o exemplo e o executamos </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z5/fl/2u/z5fl2uhbnzxafceoro_wbga-pk4.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o m√©todo traverse () √© constantemente redefinido para v√°rios tipos de n√≥s, ele deve fornecer um mecanismo para obter matrizes de transforma√ß√£o e renderizar estados para uso posterior por seu algoritmo sobrecarregado. </font><font style="vertical-align: inherit;">O par√¢metro de entrada osg :: NodeVisitor √© a chave para v√°rias opera√ß√µes com n√≥s. </font><font style="vertical-align: inherit;">Em particular, indica o tipo de passagem atual do gr√°fico de cena, como atualiza√ß√£o, processamento de eventos e recorte de faces invis√≠veis. </font><font style="vertical-align: inherit;">Os dois primeiros est√£o relacionados a retornos de chamada de n√≥ e ser√£o considerados ao estudar anima√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A passagem de recorte pode ser identificada convertendo o objeto osg :: NodeVisitor em osg :: CullVisitor</font></font><br><br><pre> <code class="cpp hljs">osgUtil::CullVisitor *cv = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgUtil::CullVisitor *&gt;(&amp;nv); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cv) { <span class="hljs-comment"><span class="hljs-comment">///  - ,     }</span></span></code> </pre><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Mecanismo de retorno de chamada </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo anterior,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementamos a anima√ß√£o de um objeto de cena alterando os par√¢metros de sua transforma√ß√£o dentro do ciclo de renderiza√ß√£o da cena. Como j√° foi mencionado muitas vezes, essa abordagem cont√©m um comportamento potencialmente perigoso do aplicativo na renderiza√ß√£o multithread. Para resolver esse problema, √© usado um mecanismo de retorno de chamada que √© executado ao percorrer o gr√°fico de cena. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem v√°rios tipos de retornos de chamada no mecanismo. Os retornos de chamada s√£o implementados por classes especiais, entre as quais osg :: NodeCallback √© projetado para lidar com o processo de atualiza√ß√£o de n√≥s de cena, e osg :: Drawable :: UpdateCallback, osg :: Drawable :: EventCallback e osg :: Drawable: CullCallback - executam as mesmas fun√ß√µes, mas para objetos de geometria.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A classe osg :: NodeCallback possui um operador operator (substitu√≠vel virtual) fornecido pelo desenvolvedor para implementar sua pr√≥pria funcionalidade. </font><font style="vertical-align: inherit;">Para que o retorno de chamada funcione, voc√™ deve anexar uma inst√¢ncia da classe de chamada ao n√≥ para o qual ser√° processado chamando o m√©todo setUpdateCallback () ou addUpdateCallback (). </font><font style="vertical-align: inherit;">O operador operator () √© chamado automaticamente durante a atualiza√ß√£o dos n√≥s no gr√°fico de cena ao renderizar cada quadro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A tabela a seguir lista os retornos de chamada dispon√≠veis para o desenvolvedor no OSG.</font></font><br><br><table><thead><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Primeiro nome </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fun√ß√£o de retorno de chamada </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√©todo virtual </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√©todo para anexar a um objeto </font></font></th></tr></thead><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atualiza√ß√£o do n√≥ </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: NodeCallback </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operador () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: Node :: setUpdateCallback () </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evento do n√≥ </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: NodeCallback </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operador () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: Node :: setEventCallback () </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recorte de n√≥ </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: NodeCallback </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operador () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: Node :: setCullCallback () </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atualiza√ß√£o de geometria </font></font></td><td> osg::Drawable::UpdateCallback </td><td> update() </td><td> osg::Drawable::setUpdateCallback() </td></tr><tr><td>   </td><td> osg::Drawable::EventCallback </td><td> event() </td><td> osg::Drawable::setEventCallback() </td></tr><tr><td>   </td><td> osg::Drawable::CullCallback </td><td> cull() </td><td> osg::Drawable::setCullCallback() </td></tr><tr><td>   </td><td> osg::StateAttributeCallback </td><td> operator() </td><td> osg::StateAttribute::setUpdateCallback() </td></tr><tr><td>   </td><td> osg::StateAttributeCallback </td><td> operator() </td><td> osg::StateAttribute::setEventCallback() </td></tr><tr><td>   </td><td> osg::Uniform::Callback </td><td> operator() </td><td> osg::Uniform::setUpdateCallback() </td></tr><tr><td>   </td><td> osg::Uniform::Callback </td><td> operator() </td><td> osg::Uniform::setEvevtCallback() </td></tr><tr><td>       </td><td> osg::Camera::DrawCallback </td><td> operator() </td><td> osg::Camera::PreDrawCallback() </td></tr><tr><td>       </td><td> osg::Camera::DrawCallback </td><td> operator() </td><td> osg::Camera::PostDrawCallback() </td></tr></tbody></table><br><br><h1> 9.  osg::Switch     </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um pouco mais alto, escrevemos um exemplo com a troca de dois modelos de aeronaves. </font><font style="vertical-align: inherit;">Agora repetiremos este exemplo, mas faremos tudo corretamente usando o mecanismo de retorno de chamada OSG.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retorno de chamada com exemplo</font></font></b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class SwitchingCallback : public osg::NodeCallback { public: SwitchingCallback() : _count(0) {} virtual void operator()(osg::Node *node, osg::NodeVisitor *nv); protected: unsigned int _count; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void SwitchingCallback::operator()(osg::Node *node, osg::NodeVisitor *nv) { osg::Switch *switchNode = static_cast&lt;osg::Switch *&gt;(node); if ( !((++_count) % 60) &amp;&amp; switchNode ) { switchNode-&gt;setValue(0, !switchNode-&gt;getValue(0)); switchNode-&gt;setValue(1, !switchNode-&gt;getValue(0)); } traverse(node, nv); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;osg::Switch&gt; root = new osg::Switch; root-&gt;addChild(model1, true); root-&gt;addChild(model2, false); root-&gt;setUpdateCallback( new SwitchingCallback ); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voc√™ deve criar uma classe herdada de osg :: NodeCallback, que controla o n√≥ osg :: Switch </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwitchingCallback</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::NodeCallback { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SwitchingCallback() : _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::Node *node, osg::NodeVisitor *nv)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O contador _count controlar√° a altern√¢ncia do n√≥ osg :: Switch do mapeamento de um n√≥ filho para outro, dependendo do seu valor. </font><font style="vertical-align: inherit;">No construtor, inicializamos o contador e redefinimos o m√©todo virtual operator ()</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SwitchingCallback::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(osg::Node *node, osg::NodeVisitor *nv) { osg::Switch *switchNode = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Switch *&gt;(node); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) &amp;&amp; switchNode ) { switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); } traverse(node, nv); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O n√≥ no qual a chamada trabalhou √© passado atrav√©s do par√¢metro node. </font><font style="vertical-align: inherit;">Como sabemos com certeza que este ser√° um n√≥ do tipo osg :: Switch, executamos uma convers√£o est√°tica do ponteiro para o n√≥ no ponteiro para o n√≥ do switch</font></font><br><br><pre> <code class="cpp hljs">osg::Switch *switchNode = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Switch *&gt;(node);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trocaremos os n√≥s filhos exibidos com o valor v√°lido desse ponteiro e, quando o valor do contador for m√∫ltiplo de 60 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) &amp;&amp; switchNode ) { switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√£o se esque√ßa de chamar o m√©todo traverse () para continuar a travessia recursiva do gr√°fico de cena </font></font><br><br><pre> <code class="cpp hljs">traverse(node, nv);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O restante do c√≥digo do programa √© trivial, exceto a linha </font></font><br><br><pre> <code class="cpp hljs">root-&gt;setUpdateCallback( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SwitchingCallback );</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onde atribu√≠mos o retorno de chamada que criamos ao n√≥ raiz do tipo osg :: Switch. </font><font style="vertical-align: inherit;">O programa funciona de maneira semelhante ao exemplo anterior</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z5/fl/2u/z5fl2uhbnzxafceoro_wbga-pk4.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© o momento, usamos o m√©todo misterioso traverse () para dois prop√≥sitos: substituir esse m√©todo nas classes sucessoras e chamar esse m√©todo na classe osg :: NodeVisitor para continuar percorrendo o gr√°fico da cena. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No exemplo que acabamos de examinar, usamos a terceira op√ß√£o de chamar traverse (), passando um ponteiro para o n√≥ e um ponteiro para a inst√¢ncia do visitante como par√¢metros. Como nos dois primeiros casos, se n√£o houver chamada para atravessar () neste n√≥, o rastreamento do gr√°fico da cena ser√° interrompido. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os m√©todos addUpdateCallback () tamb√©m servem para adicionar um retorno de chamada ao n√≥. Ao contr√°rio de setUpdateCallback (), ele √© usado para adicionar outro retorno de chamada aos existentes. Portanto, pode haver v√°rios retornos de chamada para o mesmo n√≥.</font></font><br><br><h1>  Conclus√£o </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examinamos as t√©cnicas b√°sicas usadas no desenvolvimento de aplicativos usando o mecanismo gr√°fico OpenSceneGraph. </font><font style="vertical-align: inherit;">No entanto, isso est√° longe de ser todos os pontos que eu gostaria de abordar (apesar do fato de o artigo ter sido bastante longo), portanto,</font></font><br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para continuar ...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437688/">https://habr.com/ru/post/pt437688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437676/index.html">Universidades e aceleradores corporativos como alavanca para lan√ßar startups B2B nos EUA</a></li>
<li><a href="../pt437680/index.html">Minha cole√ß√£o DIY no Youtube</a></li>
<li><a href="../pt437682/index.html">Escrevendo mais uma ferramenta de modelagem do Kubernetes</a></li>
<li><a href="../pt437684/index.html">Algoritmo Supremo - Comp√™ndio enviesado</a></li>
<li><a href="../pt437686/index.html">Aprendendo: escrevendo um messenger p2p com criptografia de ponta a ponta</a></li>
<li><a href="../pt437694/index.html">An√°lise do utilit√°rio Files.walkFileTree ();</a></li>
<li><a href="../pt437696/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel 283 (de 21 a 27 de janeiro)</a></li>
<li><a href="../pt437698/index.html">WIPO Translate service translation translation - minhas experi√™ncias</a></li>
<li><a href="../pt437702/index.html">An√°lise de entrevista de emprego do Google: consultas sin√¥nimas</a></li>
<li><a href="../pt437704/index.html">Excelente conhecimento do curr√≠culo escolar como um indicador da intelig√™ncia n√£o mais alta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>