<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßìüèª ‚ôìÔ∏è üë≤üèæ Introdu√ß√£o aos processos de inicializa√ß√£o e inicializa√ß√£o do kernel Linux ü§¶üèø ‚òÆÔ∏è üì©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! Por isso, abrimos o pr√≥ximo, quarto lugar consecutivo, do curso Linux Administrator , que ocupa seu nicho com confian√ßa ao lado do curso ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introdu√ß√£o aos processos de inicializa√ß√£o e inicializa√ß√£o do kernel Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/424761/">  Ol√° pessoal!  Por isso, abrimos o pr√≥ximo, quarto lugar consecutivo, do curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Linux Administrator</a> , que ocupa seu nicho com confian√ßa ao lado do curso devopersky.  Mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">professores</a> , mais informa√ß√µes e stands.  Bem, como sempre, informa√ß√µes mais interessantes que os professores obtiveram. <br><br>  Vamos l√° <br><br>  Voc√™ j√° se perguntou o que √© necess√°rio para o seu sistema estar pronto para executar aplicativos? <br><br>  Compreender os processos de carregamento do kernel e iniciar o sistema Linux √© importante para configurar o Linux e resolver problemas de inicializa√ß√£o.  Este artigo fornece uma vis√£o geral do processo de inicializa√ß√£o do kernel usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">carregador de inicializa√ß√£o GRUB2</a> e a inicializa√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">executada pelo sistema de inicializa√ß√£o systemd</a> . <br><br>  De fato, existem duas s√©ries de eventos necess√°rios para colocar um computador Linux em condi√ß√µes de funcionamento: inicializa√ß√£o do kernel (inicializa√ß√£o) e inicializa√ß√£o do sistema (inicializa√ß√£o).  O processo de inicializa√ß√£o do kernel inicia quando voc√™ liga o computador e termina com a inicializa√ß√£o e o sistemad do kernel.  Depois disso, o processo de inicializa√ß√£o do sistema come√ßa, e √© ele quem coloca o computador Linux em condi√ß√µes de funcionamento. <br><br><img src="https://habrastorage.org/webt/fn/kk/zz/fnkkzz6scajfvnktxj_5hwxavby.png"><a name="habracut"></a><br><br>  Em geral, o processo de carregar o kernel e iniciar o sistema Linux √© bastante simples.  Consiste nas seguintes etapas, que ser√£o descritas em mais detalhes nas se√ß√µes abaixo: <br><br><ul><li>  BIOS POST; </li><li>  Carregamento de kernel (GRUB2); </li><li>  Inicializa√ß√£o do kernel; </li><li>  Executando systemd, o pai de todos os processos. </li></ul><br>  Observe que este artigo trata do GRUB2 e do systemd, pois eles s√£o o carregador do kernel e o programa de inicializa√ß√£o para a maioria das distribui√ß√µes.  Outras op√ß√µes foram usadas anteriormente e, √†s vezes, ainda podem ser encontradas em algumas distribui√ß√µes. <br><br>  <b>Processo de inicializa√ß√£o do kernel</b> <br><br>  O processo de inicializa√ß√£o do kernel pode ser iniciado de v√°rias maneiras.  Primeiro, se a energia estiver desligada, ligar o computador iniciar√° o processo de inicializa√ß√£o.  Em segundo lugar, se um usu√°rio local j√° estiver em execu√ß√£o no computador, incluindo o usu√°rio root e o usu√°rio n√£o privilegiado, o usu√°rio poder√° iniciar programaticamente o processo de inicializa√ß√£o do kernel usando a GUI ou a linha de comando para reiniciar.  A reinicializa√ß√£o primeiro desliga o computador e somente depois o reinicia. <br><br>  <b>POST do BIOS</b> <b><br></b> <br>  A primeira etapa do processo de inicializa√ß√£o do kernel do Linux n√£o tem nada a ver com o Linux.  Essa √© a parte de hardware do processo, a mesma para todos os sistemas operacionais.  Quando a energia √© fornecida ao computador, a primeira coisa que inicia √© o POST (Power On Self Test), que faz parte do BIOS (Sistema b√°sico de E / S, Sistema b√°sico de entrada / sa√≠da). <br><br>  Quando a IBM lan√ßou seu primeiro computador pessoal em 1981, o BIOS foi projetado para inicializar componentes de hardware.  O POST faz parte do BIOS, cuja tarefa √© garantir a opera√ß√£o correta dos equipamentos de computador.  Se o POST falhar, o computador poder√° estar com defeito e o processo de inicializa√ß√£o n√£o continuar√°. <br><br>  O BIOS POST verifica o desempenho b√°sico do hardware e causa uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interrup√ß√£o do</a> BIOS - INT 13H, que localiza os setores de inicializa√ß√£o do kernel em todos os dispositivos conectados com a capacidade de inicializar.  O primeiro setor encontrado, que cont√©m um registro de inicializa√ß√£o v√°lido, √© carregado na RAM, ap√≥s o qual o controle √© transferido para o c√≥digo do setor de inicializa√ß√£o. <br>  O setor de inicializa√ß√£o √© apenas o primeiro est√°gio.  A maioria das distribui√ß√µes Linux usa uma das tr√™s op√ß√µes do carregador de inicializa√ß√£o: GRUB, GRUB2 e LILO.  O GRUB2 √© o mais novo e agora √© usado com muito mais frequ√™ncia do que vers√µes anteriores. <br><br>  <b>GRUB2</b> <br><br>  GRUB2 significa "GRand Unified Bootloader, vers√£o 2", e agora √© o principal carregador de inicializa√ß√£o das distribui√ß√µes Linux mais modernas.  O GRUB2 √© um programa que torna um computador inteligente o suficiente para encontrar o kernel do sistema operacional e carreg√°-lo na mem√≥ria.  Como falar e escrever apenas o GRUB √© mais f√°cil que o GRUB2, neste artigo provavelmente usarei o termo GRUB, mas implicarei no GRUB2, a menos que especificado de outra forma. <br><br>  O GRUB √© compat√≠vel com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a especifica√ß√£o de inicializa√ß√£o m√∫ltipla</a> , que permite carregar diferentes vers√µes do Linux e outros sistemas operacionais;  tamb√©m pode iniciar o registro de inicializa√ß√£o de sistemas operacionais propriet√°rios em uma cadeia. <br><br>  O GRUB tamb√©m permite ao usu√°rio escolher entre v√°rios downloads poss√≠veis do kernel para qualquer distribui√ß√£o Linux fornecida.  Isso possibilita o download da vers√£o anterior do kernel se a vers√£o atualizada n√£o puder ser inicializada corretamente ou for incompat√≠vel com alguma parte importante do software.  O GRUB pode ser configurado no arquivo <code>/boot/grub/grub.conf</code> . <br><br>  O GRUB1 agora √© considerado obsoleto e, na maioria das distribui√ß√µes modernas, √© substitu√≠do pelo GRUB2, que √© sua vers√£o reescrita.  Distribui√ß√µes baseadas no Red Hat atualizadas para o GRUB2 em torno do Fedora 15 e CentOS / RHEL 7. O GRUB2 possui a mesma funcionalidade de inicializa√ß√£o que o GRUB1, mas al√©m disso, fornece ambientes baseados em comandos do sistema operacional principal e pr√©-SO e mais flexibilidade no est√°gio de pr√©-inicializa√ß√£o.  O GRUB2 est√° configurado em <code>/boot/grub2/grub.cfg</code> . <br><br>  A principal tarefa de qualquer GRUB √© carregar o kernel do Linux na mem√≥ria e execut√°-lo.  Ambas as vers√µes do GRUB funcionam da mesma forma em tr√™s est√°gios, mas neste artigo vou usar o GRUB2 para descrever como o GRUB funciona.  A configura√ß√£o do GRUB e o GRUB2 e o uso de comandos do GRUB2 est√£o fora do escopo deste artigo. <br><br>  Embora oficialmente o GRUB2 n√£o use a numera√ß√£o de etapas, por uma quest√£o de conveni√™ncia, usarei neste artigo. <br><br>  <b>Etapa 1</b> <br><br>  Como j√° mencionado na se√ß√£o BIOS POST, no final do POST, o BIOS procura registros de inicializa√ß√£o nos discos conectados, geralmente localizados no MBR (Master Boot Record), ap√≥s o qual carrega o primeiro registro encontrado na mem√≥ria e come√ßa a execut√°-lo.  O c√≥digo de inicializa√ß√£o, ou seja, o primeiro est√°gio do GRUB2, ocupa muito pouco espa√ßo, porque deve caber no primeiro setor de 512 bytes no disco r√≠gido junto com a tabela de parti√ß√£o.  A quantidade total de espa√ßo alocado para o pr√≥prio c√≥digo de auto-inicializa√ß√£o no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MBR padr√£o</a> √© 446 bytes.  O arquivo de 446 bytes para o est√°gio 1 √© chamado boot-img e n√£o cont√©m uma tabela de parti√ß√£o - √© adicionado ao registro de inicializa√ß√£o separadamente. <br><br>  Como o registro de inicializa√ß√£o deve ser t√£o pequeno, n√£o √© muito "inteligente" e n√£o entende a estrutura do sistema de arquivos.  Portanto, o √∫nico objetivo da etapa 1 √© detectar e carregar a etapa 1.5.  Para conseguir isso, a etapa 1.5 do GRUB deve estar localizada no espa√ßo entre o pr√≥prio registro de inicializa√ß√£o e a primeira parti√ß√£o no disco.  Depois de carregar o est√°gio 1.5 GRUB na RAM, o est√°gio 1 transfere o controle para o est√°gio 1.5. <br><br>  <b>Etapa 1.5</b> <br><br>  Como observado acima, a etapa 1.5 do GRUB deve estar entre o registro de inicializa√ß√£o e a primeira parti√ß√£o no disco.  Historicamente, esse espa√ßo permanece sem uso por raz√µes t√©cnicas.  A primeira parti√ß√£o no disco r√≠gido inicia no setor 63 e, considerando o MBR no setor 0, existem 62 setores de 512 bytes - 31744 bytes - nos quais √© poss√≠vel armazenar o arquivo core.img - est√°gio 1.5 GRUB.  O arquivo core.img pesa 25389 bytes, o que √© espa√ßo suficiente para armazen√°-lo entre o MBR e a primeira parti√ß√£o de disco. <br><br>  Como mais c√≥digo pode ser usado na etapa 1.5, pode ser suficiente conter v√°rios drivers de sistema de arquivos comuns, como EXT padr√£o e outros sistemas de arquivos Linux, FAT e NTFS.  core.img no GRUB2 √© mais complexo e funcional do que na etapa 1.5 do GRUB1.  Isso significa que o est√°gio 2 do GRUB2 pode residir em um sistema de arquivos EXT padr√£o, mas n√£o em um volume l√≥gico.  Portanto, o local padr√£o para os arquivos do est√°gio 2 √© o sistema de arquivos <code>/boot</code> , ou melhor, <code>/boot/grub2</code> . <br><br>  Observe que o diret√≥rio / boot deve estar localizado no sistema de arquivos suportado pelo GRUB.  Nem todos os sistemas de arquivos t√™m esse suporte.  A tarefa do est√°gio 1.5 √© iniciar com os drivers do sistema de arquivos necess√°rios para procurar arquivos do est√°gio 2 no sistema de arquivos / boot e carregar os drivers necess√°rios. <br><br>  <b>Etapa 2</b> <br><br>  Todos os arquivos do GRUB Stage 2 est√£o localizados no <code>/boot/grub2</code> e em v√°rios subdiret√≥rios.  O GRUB2 n√£o possui um arquivo de imagem como nas etapas 1 e 2. Em vez disso, consiste principalmente de m√≥dulos do kernel de tempo de execu√ß√£o, carregados no diret√≥rio <code>/boot/grub2/i386-pc</code> , conforme necess√°rio. <br><br>  A tarefa do GRUB2 est√°gio 2 √© detectar e carregar o kernel do Linux na RAM e transferir o controle do controle do computador para o kernel.  O kernel e seus arquivos associados est√£o localizados no diret√≥rio <code>/boot</code> .  Os arquivos do kernel s√£o f√°ceis de reconhecer, pois seus nomes come√ßam com vmlinuz.  Voc√™ pode listar o conte√∫do do diret√≥rio <code>/boot</code> para ver os kernels atualmente instalados no seu sistema. <br><br>  O GRUB2, como o GRUB1, suporta o carregamento de um dos v√°rios kernels do Linux.  O sistema de gerenciamento de pacotes Red Hat suporta o armazenamento de v√°rias vers√µes do kernel, para que voc√™ possa carregar a vers√£o antiga do kernel em caso de problemas com os mais novos.  Por padr√£o, o GRUB fornece um menu pr√©-carregado de kernels instalados, incluindo a op√ß√£o de recupera√ß√£o e, ap√≥s a configura√ß√£o, a op√ß√£o de recupera√ß√£o. <br><br>  Etapa 2 O GRUB2 carrega o kernel selecionado na mem√≥ria e transfere o controle do controle do computador para o kernel. <br><br>  <b>O n√∫cleo</b> <br><br>  Todos os n√∫cleos est√£o em um formato compactado e auto-extra√≠vel para economizar espa√ßo.  Os kernels est√£o localizados no diret√≥rio <code>/boot</code> , junto com a imagem original do disco RAM e uma lista de parti√ß√µes nos discos r√≠gidos. <br><br>  Depois que o kernel selecionado √© carregado na mem√≥ria e come√ßa a ser executado, primeiro, ele deve se extrair da vers√£o compactada do arquivo antes de come√ßar a fazer um trabalho √∫til.  Depois que a extra√ß√£o ocorre, ele carrega o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">systemd</a> , que substitui o antigo programa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">init do SysV</a> e transfere o controle para ele. <br><br>  Este √© o fim do processo de inicializa√ß√£o do kernel.  Neste ponto, o kernel do Linux e o systemd est√£o em execu√ß√£o, mas n√£o podem executar tarefas √∫teis para o usu√°rio final, pois n√£o h√° mais nada a fazer. <br><br>  <b>Processo de inicializa√ß√£o do sistema</b> <br><br>  O processo de inicializa√ß√£o do sistema segue o processo de inicializa√ß√£o do kernel e coloca o computador Linux em funcionamento. <br><br>  <b>systemd</b> <br><br>  systemd √© o pai de todos os processos respons√°veis ‚Äã‚Äãpor levar o host Linux a um estado eficiente.  Algumas de suas fun√ß√µes, mais extensas do que as apresentadas no antigo programa de inicializa√ß√£o, devem gerenciar muitos aspectos do host Linux em execu√ß√£o, incluindo a montagem do sistema de arquivos, o in√≠cio e o gerenciamento dos servi√ßos do sistema necess√°rios para que o host Linux funcione com efici√™ncia.  Todas as tarefas do sistema que n√£o est√£o relacionadas ao processo de inicializa√ß√£o do sistema est√£o al√©m do escopo da discuss√£o neste artigo. <br><br>  Primeiro, o systemd monta os sistemas de arquivos conforme definido em <code>/etc/fstab</code> , incluindo quaisquer arquivos de troca e parti√ß√µes.  Nesse ponto, ele pode acessar os arquivos de configura√ß√£o localizados em <code>/etc</code> , incluindo os seus.  Ele usa seu pr√≥prio arquivo de configura√ß√£o <code>/etc/systemd/system/default.target</code> para determinar o destino para o qual carregar o host.  O arquivo default.target √© apenas um link simb√≥lico para o arquivo de destino real.  Para uma esta√ß√£o de trabalho de mesa, isso geralmente √© graphical.target, equivalente ao n√≠vel de execu√ß√£o 5 no inicializador SystemV antigo.  Para o servidor, √© prov√°vel que o padr√£o seja multiusu√°rio.target, semelhante ao n√≠vel de execu√ß√£o 3 no SystemV.  Emergency.target √© semelhante ao modo de usu√°rio √∫nico. <br><br>  Observe que destinos e servi√ßos s√£o unidades systemd. <br><br>  A Tabela 1 abaixo √© uma compara√ß√£o de todos os destinos do systemd com os n√≠veis de execu√ß√£o antigos no SystemV.  Os aliases de destino do Systemd s√£o fornecidos pelo systemd para compatibilidade com vers√µes anteriores.  Os aliases de destino permitem que scripts - e muitos administradores de sistemas, incluindo eu - usem comandos do SystemV, como o init3, para alterar os n√≠veis de execu√ß√£o.  Obviamente, os comandos do SystemV s√£o direcionados pelo systemd para interpreta√ß√£o e execu√ß√£o. <br><div class="scrollable-table"><table><tbody><tr><th>  N√≠vel de execu√ß√£o do Systemv </th><th>  <nobr>alvo systemd</nobr> </th><th>  aliases de <nobr>destino do systemd</nobr> </th><th>  Descri√ß√£o do produto </th></tr><tr><td></td><td>  halt.target </td><td></td><td>  Suspende o sistema sem desligar a energia </td></tr><tr><td>  0 0 </td><td>  poweroff.target </td><td>  runlevel0.target </td><td>  Interrompe o sistema e desliga a energia </td></tr><tr><td>  S </td><td>  emergency.target </td><td></td><td>  Modo de usu√°rio √∫nico.  Os servi√ßos n√£o est√£o em execu√ß√£o;  sistemas de arquivos n√£o est√£o montados.  Este √© o n√≠vel mais b√°sico de opera√ß√£o.  Para intera√ß√£o do usu√°rio com o sistema, apenas o shell de emerg√™ncia √© iniciado no console principal. </td></tr><tr><td>  1 </td><td>  rescue.target </td><td>  runlevel1.target </td><td>  O sistema base, incluindo a montagem do sistema de arquivos com o conjunto mais b√°sico de servi√ßos e o shell de resgate no console principal. </td></tr><tr><td>  2 </td><td></td><td>  runlevel2.target </td><td>  Modo multiusu√°rio, sem NFS, mas todos os servi√ßos que n√£o s√£o da GUI est√£o em execu√ß√£o. </td></tr><tr><td>  3 </td><td>  multi-user.target </td><td>  runlevel3.target </td><td>  Todos os servi√ßos est√£o em execu√ß√£o, mas somente atrav√©s da interface da linha de comandos (CLI). </td></tr><tr><td>  4 </td><td></td><td>  runlevel4.target </td><td>  N√£o usado. </td></tr><tr><td>  5 </td><td>  graphical.target </td><td>  runlevel5.target </td><td>  Modo multiusu√°rio com GUI. </td></tr><tr><td>  6 </td><td>  reboot.target </td><td>  runlevel6.target </td><td>  Reiniciar </td></tr><tr><td></td><td>  default.target </td><td></td><td>  Esse destino sempre tem um link simb√≥lico com multi-user.target ou graphical.target.  O systemd sempre usa default.target para iniciar o sistema.  O default.target nunca deve ser associado a halt.target, poweroff.target ou reboot.target. </td></tr></tbody></table></div><br>  <i>Tabela 1: Compara√ß√£o dos n√≠veis de controle do SystemV com os destinos do systemd e alguns aliases de destino.</i> <br><br>  Cada destino possui um conjunto de depend√™ncias descritas no arquivo de configura√ß√£o.  O systemd executa os necess√°rios.  Essas depend√™ncias s√£o os servi√ßos necess√°rios para executar um host Linux com um certo n√≠vel de funcionalidade.  Quando todas as depend√™ncias listadas nos arquivos de configura√ß√£o de destino s√£o carregadas e iniciadas, o sistema funciona nesse n√≠vel de destino. <br><br>  O systemd tamb√©m verifica diret√≥rios obsoletos de inicializa√ß√£o do SystemV em busca de arquivos de inicializa√ß√£o.  Se estiverem, o systemd os utiliza como arquivos de configura√ß√£o para executar os servi√ßos descritos nos arquivos.  Um servi√ßo de rede desatualizado √© um bom exemplo de um que ainda usa arquivos de inicializa√ß√£o do SystemV no Fedora. <br><br>  A Figura 1 abaixo √© copiada diretamente da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">p√°gina principal</a> da inicializa√ß√£o.  Ele mostra a sequ√™ncia geral de eventos durante o in√≠cio do systemd e os requisitos b√°sicos para garantir seu sucesso. <br><br>  Os destinos sysinit.target e basic.target podem ser considerados pontos de verifica√ß√£o durante a inicializa√ß√£o do sistema.  Embora um dos objetivos do systemd seja executar servi√ßos do sistema em paralelo, existem alguns servi√ßos e destinos funcionais que devem ser iniciados antes de outros.  Esses pontos de controle n√£o podem ser transmitidos at√© que todos os servi√ßos e destinos necess√°rios sejam conclu√≠dos. <br><br>  Assim, sysinit.target √© alcan√ßado quando todas as unidades das quais depende s√£o conclu√≠das.  Todas as seguintes unidades devem ser conclu√≠das: montagem de sistemas de arquivos, configura√ß√£o de arquivos de troca, inicializa√ß√£o do udev, configura√ß√£o do estado inicial do gerador de n√∫meros aleat√≥rios, inicializa√ß√£o de servi√ßos de baixo n√≠vel, configura√ß√£o de servi√ßos de criptografia se pelo menos um sistema de arquivos estiver criptografado.  No sysinit.target, eles podem ser executados em paralelo. <br>  O sysinit.target executa todos os servi√ßos e unidades de baixo n√≠vel necess√°rios para a funcionalidade m√≠nima do sistema e aqueles necess√°rios para acessar o basic.target. <br><br><img src="https://habrastorage.org/webt/gx/k_/yj/gxk_yjpanfeksjnoiyfxob5bqlw.png"><br>  <i>Figura 1. Mapa de inicializa√ß√£o do Systemd</i> <br><br>  Ap√≥s executar o sysinit.target, o systemd inicia o basic.target, come√ßando com todas as unidades necess√°rias para execut√°-lo.  O destino b√°sico fornece funcionalidade adicional iniciando as unidades necess√°rias para o pr√≥ximo destino, incluindo a configura√ß√£o de caminhos para v√°rios diret√≥rios execut√°veis, soquetes de comunica√ß√£o e timers. <br><br>  Por fim, voc√™ pode come√ßar a inicializar destinos no n√≠vel do usu√°rio: multi-user.target ou graphical.target.  Vale notar que multi-user.target deve ser alcan√ßado antes que as depend√™ncias do destino gr√°fico sejam executadas. <br><br>  Os alvos sublinhados na Figura 1 s√£o alvos t√≠picos de inicializa√ß√£o.  A inicializa√ß√£o do sistema termina quando um deles √© alcan√ßado.  Se multi-user.target for o destino padr√£o, no console, voc√™ ver√° o login no modo de texto.  Se graphical.target for especificado por padr√£o, voc√™ ver√° um login gr√°fico;  A GUI da tela de login depende do gerenciador de tela que voc√™ est√° usando. <br><br>  <b>Os problemas</b> <br><br>  Recentemente, tive que alterar o kernel de inicializa√ß√£o padr√£o em um computador Linux que usava o GRUB2.  Descobri que alguns comandos pararam de funcionar corretamente ou os usei de forma incorreta.  Ainda n√£o sei qual era o problema, levar√° mais tempo para pesquis√°-lo. <br><br>  O comando grub2-set-default configurou incorretamente o √≠ndice padr√£o do kernel no arquivo <code>/etc/default/grub</code> , para que o kernel alternativo desejado n√£o seja carregado.  <code>/etc/default/grub GRUB_DEFAULT=saved</code> manualmente <code>/etc/default/grub GRUB_DEFAULT=saved</code> em <code>GRUB_DEFAULT=2</code> , em que 2 √© o √≠ndice do kernel instalado que eu queria executar.  Em seguida, executei o comando <code>grub2-mkconfig &gt; /boot/grub2/grub.cfg</code> para criar um novo arquivo de configura√ß√£o do grub.  Esse truque funcionou e um kernel alternativo foi lan√ßado. <br><br>  <b>Conclus√µes</b> <br><br>  O GRUB2 e o sistema de inicializa√ß√£o systemd s√£o componentes essenciais para as fases de inicializa√ß√£o do sistema e inicializa√ß√£o do sistema da maioria das distribui√ß√µes modernas do Linux.  Apesar das contradi√ß√µes, especialmente em torno do systemd, esses dois componentes funcionam bem juntos para carregar o kernel e executar todos os servi√ßos do sistema necess√°rios para criar um sistema Linux funcional. <br>  Embora eu considere o GRUB2 e o systemd como um todo mais complexos que seus antecessores, eles n√£o s√£o mais dif√≠ceis de dominar e gerenciar.  Os manuais cont√™m muitas informa√ß√µes sobre o systemd e, no freedesktop.org, a lista de suas p√°ginas √© apresentada na √≠ntegra.  Para mais informa√ß√µes, consulte os links abaixo: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GNU GRUB</a> (Wikipedia) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GNU GRUB</a> Manual (GNU.org) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Registro mestre de inicializa√ß√£o</a> (Wikipedia) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Especifica√ß√£o de inicializa√ß√£o m√∫ltipla</a> (Wikipedia) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">systemd</a> (Wikipedia) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">processo de inicializa√ß√£o do systemd</a> (Freedesktop.org) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√≠ndice systemd de p√°ginas de manual</a> (Freedesktop.org) </li></ul><br><br>  Isso √© tudo.  Estamos aguardando perguntas e coment√°rios aqui ou eles podem ser solicitados diretamente em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma li√ß√£o aberta</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt424761/">https://habr.com/ru/post/pt424761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt424747/index.html">O lugar onde o som vive</a></li>
<li><a href="../pt424751/index.html">Como o sistema biom√©trico unificado funciona</a></li>
<li><a href="../pt424753/index.html">O que h√° de novo no YouTrack 2018.3</a></li>
<li><a href="../pt424755/index.html">O dinheiro adora a conta: como os carros classificam as contas</a></li>
<li><a href="../pt424757/index.html">O resumo de eventos para profissionais de RH na √°rea de TI em outubro de 2018</a></li>
<li><a href="../pt424763/index.html">Um editor de texto n√£o √© a sua matem√°tica mais alta, aqui voc√™ precisa pensar</a></li>
<li><a href="../pt424765/index.html">Gerenciamento de estado em aplicativos Flutter</a></li>
<li><a href="../pt424767/index.html">N√≥s fazemos um bolo de Habr. Novamente</a></li>
<li><a href="../pt424771/index.html">Experi√™ncia pessoal: de uma ideia e uma folha em branco a uma vers√£o de rascunho de um site</a></li>
<li><a href="../pt424773/index.html">Biofarma e modelagem num√©rica: experi√™ncia e pr√°tica da Amgen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>