<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚗 🆓 🤦🏻 Datos de series de tiempo en un DBMS relacional. Extensiones TimescaleDB y PipelineDB para PostgreSQL 📤 📓 🧛🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los datos de series temporales o series temporales son datos que cambian con el tiempo. Las cotizaciones de divisas, la telemetría de los movimientos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Datos de series de tiempo en un DBMS relacional. Extensiones TimescaleDB y PipelineDB para PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/464303/">  Los datos de series temporales o series temporales son datos que cambian con el tiempo.  Las cotizaciones de divisas, la telemetría de los movimientos de transporte, las estadísticas de acceso al servidor o la carga de la CPU son datos de series temporales.  Para almacenarlos se requieren herramientas específicas: bases de datos temporales.  Hay docenas de herramientas, por ejemplo, InfluxDB o ClickHouse.  Pero incluso las mejores soluciones de almacenamiento de series temporales tienen desventajas.  Todos los almacenamientos de series temporales son de bajo nivel, adecuados solo para datos de series temporales, y ejecutar e inyectar en la pila actual es costoso y doloroso. <br><br><img src="https://habrastorage.org/webt/sx/9x/bz/sx9xbzv26lix6lh-frspdsopknw.jpeg"><br><br>  Pero, si tiene una pila PostgreSQL, puede olvidarse de InfluxDB y todas las demás bases de datos temporales.  Instale dos extensiones, TimescaleDB y PipelineDB, y almacene, procese y analice datos de series temporales directamente en el ecosistema PostgreSQL.  Sin la introducción de soluciones de terceros, sin las desventajas de los almacenamientos temporales y sin los problemas de ejecutarlos.  Cuáles son estas extensiones, cuáles son sus ventajas y capacidades, le dirá a <b>Ivan Muratov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">binakot</a> )</b> , el jefe del departamento de desarrollo de la "Primera Compañía de Monitoreo". <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3WkNp7mllv0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  ¿Qué son las series temporales o las series temporales? </h2><br><blockquote>  Estos son datos sobre el proceso que se recopilan en diferentes momentos de su vida. </blockquote><br>  Por ejemplo, la ubicación del automóvil: velocidad, coordenadas, dirección o el uso de recursos en el servidor con datos sobre la carga en la CPU, RAM utilizada y espacio libre en disco. <br><br>  Las series de tiempo tienen varias características. <br><br><ul><li>  En una <b>correa de fijación</b> .  Cualquier registro de serie temporal tiene un campo con una marca de tiempo en la que se registró el valor. <br></li><li>  <b>Las características del proceso, que se denominan niveles de la serie</b> : velocidad, coordenadas, datos de carga. <br></li><li>  Casi siempre con dichos datos funcionan <b>en modo de solo agregar</b> .  Esto significa que los nuevos datos no reemplazan a los antiguos.  Solo se eliminan los datos obsoletos. <br></li><li>  <b>Las entradas no se consideran por separado entre sí</b> .  Los datos se usan solo colectivamente para ventanas de tiempo, intervalos o períodos. <br></li></ul><br><h3>  Soluciones de almacenamiento populares </h3><br>  El gráfico que tomé de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">db-engines.com</a> muestra la popularidad de varios modelos de almacenamiento en los últimos dos años. <br><br><img src="https://habrastorage.org/webt/w2/wf/_u/w2wf_uryfor_djey8enzmrskywo.jpeg"><br><br>  La posición de liderazgo está ocupada por almacenamientos de series de tiempo, en segundo lugar - bases de datos de gráficos, luego - bases de datos clave y relacionales.  La popularidad de los repositorios especializados se asocia con un crecimiento intensivo en la integración de las tecnologías de la información: Big Data, redes sociales, IoT, monitoreo de infraestructura de alta carga.  Además de los datos comerciales útiles, incluso los registros y las métricas ocupan una gran cantidad de recursos. <br><br><h3>  Soluciones de almacenamiento populares para datos de series temporales </h3><br>  El gráfico muestra soluciones especializadas para almacenar datos de series temporales.  La escala es logarítmica. <br><br><img src="https://habrastorage.org/webt/ny/bz/6_/nybz6_-_3ce7t0y7xre1oxkbks8.jpeg"><br><br>  Líder estable InfluxDB.  Todos los que han encontrado datos de series de tiempo han escuchado sobre este producto.  Pero el gráfico muestra un aumento de diez veces en TimescaleDB: una extensión del DBMS relacional está luchando por un lugar bajo el sol entre los productos que se desarrollaron originalmente en la serie temporal. <br><br><blockquote>  PostgreSQL no es solo una buena base de datos, sino también una plataforma extensible para desarrollar soluciones especializadas. </blockquote><br><h2>  Postgres, Postgis y TimescaleDB </h2><br>  The First Monitoring Company monitorea el movimiento de vehículos utilizando satélites.  Rastreamos 20,000 vehículos y almacenamos datos de movimiento durante dos años.  En total, tenemos 10 TB de datos de telemetría actuales.  En promedio, cada vehículo envía 5 registros de telemetría por minuto mientras conduce.  Los datos se envían a través de equipos de navegación a nuestros servidores telemáticos.  Reciben 500 paquetes de navegación por segundo. <br><br>  Hace algún tiempo, decidimos actualizar globalmente la infraestructura y pasar de un monolito a microservicios.  Llamamos al nuevo sistema Waliot, y ya está en producción: el 90% de todos los vehículos se transfieren a él. <br><br>  Mucho ha cambiado en la infraestructura, pero el enlace central se ha mantenido sin cambios: esta es la base de datos PostgreSQL.  Ahora estamos trabajando en la versión 10 y nos estamos preparando para pasar a 11. Además de PostgreSQL, como almacenamiento principal, utilizamos PostGIS para la informática geoespacial en la pila y TimescaleDB para almacenar una gran variedad de datos de series temporales. <br><br><h3>  ¿Por qué PostgreSQL? </h3><br>  ¿Por qué estamos tratando de usar una base de datos relacional para almacenar series de tiempo, en lugar de <s>soluciones</s> especializadas de <s>ClickHouse</s> para este tipo de datos?  Debido a los antecedentes de la experiencia acumulada y las impresiones de trabajar con PostgreSQL, no queremos utilizar una solución desconocida como almacenamiento principal. <br><br><blockquote>  Cambiar a una nueva solución es un riesgo. </blockquote><br>  Existen muchas soluciones especializadas para almacenar y procesar datos de series temporales.  La documentación no siempre es suficiente, y una gran selección de soluciones no siempre es buena.  Parece que los desarrolladores de cada nuevo producto quieren escribir todo desde cero, porque algo no era agradable en la solución anterior.  Para comprender lo que no le gustó exactamente, debe buscar información, analizar y comparar.  Una gran variedad de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tops</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clasificaciones</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comparaciones son</a> bastante atemorizantes en lugar de motivar a probar algo.  Tendrá que pasar mucho tiempo para probar todas las soluciones usted mismo.  No podemos permitirnos adaptar solo una solución durante varios meses.  Esta es una tarea difícil, y el tiempo dedicado nunca valdrá la pena.  Por lo tanto, hemos elegido extensiones para PostgreSQL. <br><br>  Durante la fase de desarrollo de la infraestructura de Waliot, consideramos que InfluxDB es el principal repositorio de telemetría.  Pero cuando me encontré con TimescaleDB y ejecuté pruebas en él, no hubo preguntas sobre la elección.  PostgreSQL con la extensión TimescaleDB le permite usar otras extensiones en el mismo almacenamiento PostGIS o PipelineDB.  No necesitamos extraer datos, transformar, realizar análisis y transferirlos a través de la red.  Todo se encuentra en un servidor o en un sistema agrupado; no es necesario arrastrar los datos.  Todos los cálculos se realizan al mismo nivel. <br><br>  Recientemente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nikolay Samokhvalov</a> , el autor de la cuenta postgresmen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicó un enlace</a> a un artículo interesante sobre el uso de SQL para el procesamiento de datos en streaming.  Cinco de los seis autores del artículo participan en el desarrollo de varios productos de Apache y trabajan con el procesamiento continuo.  Por lo tanto, el artículo menciona Apache Spark, Apache Flink, Apache Beam, Apache Calcite y KSQL de Confluent. <br><br>  Pero no es interesante el artículo en sí, sino el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tema en Hacker News</a> , en el que se discute.  El autor del tema escribe que, basándose en el artículo, implementó casi todas las ideas basadas en PostgreSQL 11. Utilizó extensiones CitusDB para escalado y fragmentación horizontal, PipelineDB para computación de flujo y vistas materializadas, TimescaleDB para almacenar datos de series temporales y seccionamiento.  También usa varios envoltorios de datos extranjeros. <br><br><blockquote>  Una mezcla loca de PostgreSQL y sus extensiones confirma una vez más que PostgreSQL no es solo un DBMS, es una plataforma. </blockquote><br>  Y cuando se entregue el almacenamiento conectable ... ¡Uf! <br><br>  Irónicamente, al investigar las soluciones, encontramos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Outflux</a> , el desarrollo del equipo TimescaleDB, que publicaron el 1 de abril.  ¿Qué crees que hace ella?  Esta es una utilidad para migrar de InfluxDB a TimescaleDB en un comando ... <br><br><h3>  Postgres bombo! </h3><br>  ¡No subestimes el poder del bombo!  A menudo bromeamos diciendo que "el desarrollo está impulsado por el bombo", porque influye en nuestra percepción de los componentes de infraestructura y ajuste.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++,</a> discutimos mucho sobre PostgreSQL, ClickHouse, Tarantool, estos son desarrollos exagerados.  Simplemente no diga que no afecta sus preferencias y la elección de soluciones para la infraestructura ... Por supuesto, este no es el factor principal, pero ¿tiene algún efecto? <br><br>  He estado trabajando con PostgreSQL durante 5 años.  Me gusta esta solución  Resuelve casi todas mis tareas con una explosión.  Cada vez que algo salía mal con esta base, mis manos torcidas tenían la culpa.  Por lo tanto, la elección estaba predeterminada. <br><br><h2>  TimescaleDB VS PipelineDB </h2><br>  Pasemos a las extensiones TimescaleDB y PipelineDB.  ¿Qué dicen sus creadores sobre las extensiones? <br><br>  <b>TimescaleDB es una base de datos de series de tiempo de</b> código abierto que está optimizada para una inserción rápida y consultas complejas. <br><br>  <b>PipelineDB</b> es una extensión de alto rendimiento diseñada para ejecutar consultas SQL continuas <b>para datos de series temporales</b> . <br><br>  Además de trabajar con datos de series temporales, tienen una historia similar.  Timescale se fundó en 2015 y Pipeline en 2013. Las primeras versiones de trabajo aparecieron en 2017 y 2015, respectivamente.  Los equipos tardaron dos años en liberar la funcionalidad mínima.  Los lanzamientos de producción de ambas extensiones tuvieron lugar en octubre pasado con una diferencia de una semana.  Aparentemente, apurados uno tras otro. <br><br>  GitHub tiene un montón de estrellas y tenedores, que, como de costumbre, no son un solo compromiso.  Así es como funciona el Código Abierto, no hay nada que hacer.  Pero hay muchas estrellas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TimescaleDB tiene</a> más que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PipelineDB</a> , e incluso más que PostgreSQL. <br><br>  Las extensiones parecen ser similares, pero se posicionan de manera diferente. <br><br>  <b>TimescaleDB</b> afirma haber insertado millones de registros por segundo y almacenado cientos de miles de millones de filas y decenas de terabytes de datos.  La extensión es más rápida que InfluxDB, Cassandra, MongoDB o Vangre PostgreSQL.  Admite replicación de transmisión y herramientas de copia de seguridad.  TimescaleDB es una extensión, no una bifurcación de PostgreSQL. <br><br>  <b>PipelineDB</b> solo almacena el resultado de los cálculos de transmisión, sin la necesidad de almacenar datos sin procesar para sus cálculos.  La extensión es capaz de agregación continua sobre flujos de datos en tiempo real, combinándose con tablas convencionales para cálculos en el contexto de un dominio de dominio.  PipelineDB es una extensión, no una bifurcación, pero inicialmente era una bifurcación. <br><br><h2>  Timescaledb </h2><br>  Ahora en detalle sobre las extensiones.  Comencemos con TimescaleDB.  He estado trabajando con él por casi 2 años.  Arrastrado a producción antes de la versión de lanzamiento.  Veamos ejemplos de cómo aplicarlo. <br><br>  <b>Almacenamiento para métricas de infraestructura</b> .  Tenemos métricas de consumo de recursos de contenedor Docker, tiempo de confirmación de métricas, identificador de contenedor y campos de consumo de recursos, por ejemplo, memoria libre.  Necesitamos mostrar estadísticas para todos los contenedores con una cantidad promedio de ventanas de memoria libre durante 10 segundos.  La consulta que ve resuelve este problema y TimescaleDB se puede utilizar como repositorio de métricas de infraestructura. <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> time_bucket(<span class="hljs-string"><span class="hljs-string">'10 seconds'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span>, container_id, <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(free_mem) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> metrics <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> <span class="hljs-string"><span class="hljs-string">'10 minutes'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span>, container_id <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>, container_id;</code> </pre> <br><pre> <code class="plaintext hljs">period | container_id | avg -----------------------+--------------+--- 2019-06-24 12:01:00+00 | 16 | 72202 2019-06-24 12:01:00+00 | 73 | 837725 2019-06-24 12:01:00+00 | 96 | 412237 2019-06-24 12:00:50+00 | 16 | 1173393 2019-06-24 12:00:50+00 | 73 | 90104 2019-06-24 12:00:50+00 | 96 | 784596</code> </pre> <br>  <b>Para cálculos</b>  Necesitamos calcular la cantidad de camiones que dejaron Krasnodar y su tonelaje total por días. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> time_bucket(<span class="hljs-string"><span class="hljs-string">'1 day'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">day</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> trucks_exiting, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(weight) / <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tonnage <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vehicles <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> cities <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> cities.name = <span class="hljs-string"><span class="hljs-string">'Krasnodar'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ST_Within(last_location, ST_Polygon(cities.geom, <span class="hljs-number"><span class="hljs-number">4326</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> ST_Within(current_location, ST_Polygon(cities.geom, <span class="hljs-number"><span class="hljs-number">4326</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br>  También utiliza funciones de la extensión PostGIS para calcular el transporte que salió de la ciudad, en lugar de simplemente moverse en ella. <br><br>  <b>Monitoreo de la tasa de cambio</b> .  El tercer ejemplo es sobre las criptomonedas.  La solicitud le permite mostrar cómo ha cambiado el precio de Ethereum en relación con Bitcoin y el dólar estadounidense en las últimas 2 semanas por día. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> time_bucket(<span class="hljs-string"><span class="hljs-string">'14 days'</span></span>, c.time) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>(c.closing_price, c.time) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> closing_price_btc, <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>(c.closing_price, c.time) * <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>(b.closing_price, c.time) filter (<span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> b.currency_code = <span class="hljs-string"><span class="hljs-string">'USD'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> closing_price_usd <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> crypto_prices c <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> btc_prices b <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> time_bucket(<span class="hljs-string"><span class="hljs-string">'1 day'</span></span>, c.time) = time_bucket(<span class="hljs-string"><span class="hljs-string">'1 day'</span></span>, b.time) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.currency_code = <span class="hljs-string"><span class="hljs-string">'ETH'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre> <br>  Todo esto es igual de claro y conveniente para nosotros SQL. <br><br><h3>  ¿Qué tiene de bueno TimescaleDB? </h3><br>  ¿Por qué no usar las herramientas integradas de partición de tablas?  ¿Y por qué molestarse en romper las mesas?  La respuesta obvia es la <b>velocidad de inserción en tales bases de datos</b> .  El gráfico muestra las mediciones reales de la tasa de inserción del número de filas por segundo entre la tabla de vainilla regular PostgreSQL 10 sin seccionamiento y el hiperestable TimescaleDB. <br><br><img src="https://habrastorage.org/webt/gq/ln/xd/gqlnxdxeupbqkf_i-wdeihs0zlq.jpeg"><br><br>  Este punto de referencia escribe mil millones de líneas en una máquina, simulando un escenario para recopilar métricas de la infraestructura.  El registro contiene tiempo, el identificador del componente de infraestructura y 10 métricas.  El punto de referencia se ejecutó en Azure VM con 8 núcleos y 28 gigabytes de RAM, así como unidades SSD de red.  La inserción se realizó en lotes de 10 mil registros. <br><br>  ¿De dónde viene esa degradación del rendimiento de PostgreSQL?  Porque cuando inserta, también necesita actualizar los índices de la tabla.  Cuando no caben en el caché, comenzamos a cargar discos.  La partición resuelve este problema si los índices de la sección en la que insertamos los datos se colocan en la RAM. <br><br>  Veamos el siguiente cuadro.  Esto compara el sistema de particionamiento declarativo integrado en PostgreSQL 10 y la hipertabla TimescaleDB.  En el eje horizontal, el número de secciones. <br><br><img src="https://habrastorage.org/webt/kd/dz/xd/kddzxdttzspi9peoiriem7sipms.jpeg"><br><br>  En TimescaleDB, la degradación es insignificante con secciones crecientes.  Los desarrolladores de extensiones afirman que les está yendo bien con 10,000 secciones en una sola instancia de PostgreSQL. <br><br>  En PostgreSQL, la implementación nativa se degrada significativamente después de 3.000. En general, la partición declarativa en PostgreSQL es un gran paso adelante, pero solo funciona bien para tablas con menos carga.  Por ejemplo, para bienes, compradores y otras entidades de dominio que ingresan al sistema de manera no tan intensa como las métricas. <br><br>  En las versiones 11 y 12 de PostgreSQL, aparecerá el soporte de particionamiento nativo y puede intentar ejecutar pruebas comparativas para datos de series temporales con nuevas versiones.  Pero, me parece que TimescaleDB es aún mejor.  Todos los puntos de referencia de TimescaleDB se pueden encontrar en su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> y probar. <br><br><h3>  Características clave </h3><br>  Espero que ya tenga interés en la extensión.  Repasemos las características principales de TimescaleDB para consolidar este sentimiento. <br><br>  <b>Particionamiento a través de hipertables</b> .  TimescaleDB utiliza el término "hipertable" para las tablas a las que se ha aplicado la función create_hypertable ().  Después de eso, la tabla se convertirá en el padre de todas las secciones heredadas: fragmentos.  La tabla principal en sí no contendrá ningún dato, pero será un punto de entrada para todas las consultas y una plantilla al crear automáticamente nuevas secciones.  Todas las secciones se almacenan no en el esquema principal de sus datos, sino en un esquema especial.  Esto es conveniente porque no vemos miles de estas secciones en el esquema de datos. <br><br>  <b>La extensión está integrada en el planificador y el ejecutor de consultas</b> .  A través de enlaces especiales en PostgreSQL, TimescaleDB comprende cuándo accede a un hipertable.  TimescaleDB analiza la consulta y redirige las consultas solo a las secciones necesarias en función de las condiciones especificadas en la propia llamada SQL.  Esto le permite paralelizar el trabajo con secciones durante la extracción de una cantidad significativa de datos. <br><br>  <b>La extensión no impone restricciones en SQL</b> .  Puede utilizar libremente uniones, agregados, funciones de ventana, CTE e índices adicionales.  Si vio la lista de restricciones para el sistema de particionamiento incorporado, esto debería complacerle. <br><br>  <b>Funciones útiles adicionales</b> específicas para datos de series temporales: <br><br><ul><li>  "Time_bucket" - "date_trun" de una persona sana; <br></li><li>  histogramas: completar los intervalos perdidos utilizando la interpolación o el último valor conocido; <br></li><li>  Trabajador en segundo plano: servicios que le permiten realizar operaciones en segundo plano: limpieza de secciones antiguas, reorganización. <br></li></ul><br>  <b>TimescaleDB le permite permanecer en el poderoso ecosistema PostgreSQL</b> .  Esta extensión no rompe PostgreSQL, por lo tanto, todas las soluciones de alta disponibilidad, sistemas de respaldo y herramientas de monitoreo continuarán funcionando.  TimescaleDB es amigo de Grafana, Periscope, Prometheus, Telegraf, Zabbix, Kubernetes, Kafka, Seeq, JackDB. <br><br>  <b>Grafana</b> ya tiene soporte nativo para TimescaleDB como fuente de datos.  Grafana entiende de inmediato que PostscreSQL tiene TimescaleDB.  El generador de consultas en Grafana en los paneles comprende funciones adicionales de TimescaleDB, como "time_bucket", "first", "last".  Puede crear gráficos directamente desde la base de datos relacional con estas funciones de series de tiempo sin consultas gigantes. <br><br>  <b>Prometheus tiene</b> un adaptador que le permite combinar datos de él y usar TimescaleDB como un almacén de datos confiable.  Use un adaptador para no almacenar datos en Prometheus durante años. <br><br>  También hay un <b>complemento Telegraf</b> .  La solución le permite eliminar completamente Prometheus.  Los datos de infraestructura se transfieren inmediatamente a TimescaleDB y se leen a través de Telegraf. <br><br><h3>  Licencias y noticias </h3><br>  No hace mucho tiempo, la compañía cambió a un nuevo modelo de licencia.  La mayor parte del código tiene licencia de Apache 2.0.  Una pequeña porción es de uso gratuito, pero tiene licencia bajo TSL. <br><br>  Hay una versión Enterprise con licencia comercial.  No se preocupe, no todas las cosas buenas en la versión Enterprise.  Básicamente, hay automatización, como la eliminación automática de fragmentos obsoletos que se puede hacer a través de un simple "cron" y cosas similares. <br><br>  Ahora la compañía está trabajando activamente en una solución de clúster.  Quizás caiga en la versión Enterprise.  También hay una versión en la nube para nuevas empresas que desean ingresar al mercado antes de que los inversores se queden sin dinero. <br><br>  De las noticias: <br><br><ul><li>  un millón de descargas en el último año y medio; <br></li><li>  Inversión de $ 31 millones; <br></li><li>  Colaboración activa con MS Azure con respecto a las soluciones de IoT. <br></li></ul><br><h3>  Para resumir </h3><br><blockquote>  TimescaleDB está diseñado para almacenar datos de series temporales.  Este es un poderoso sistema de particionamiento con restricciones mínimas en comparación con los nativos en PostgreSQL. </blockquote><br>  Desafortunadamente, la extensión aún no tiene una versión multinodo.  Si desea un multimaestro o un fragmento, debe jugar, por ejemplo, con CitusDB.  Si quieres una replicación lógica, te dolerá.  Pero siempre duele con ella. <br><br><h2>  Pipelinedb </h2><br>  Ahora hablemos de la segunda extensión.  Desafortunadamente, no pudimos probarlo adecuadamente en la batalla.  Ahora está pasando por la etapa de adaptación en nuestro sistema.  Es cierto, hay un problema del que hablaré más cerca del final. <br><br>  Como en el caso anterior, comenzamos con ejemplos reales.  Es más fácil comprender los beneficios de la extensión y la motivación para usarla. <br><br>  <b>Colección de estadísticas</b> .  Imagine que recopilamos estadísticas sobre las visitas a nuestro sitio web.  Necesitamos análisis de las páginas más populares, la cantidad de usuarios únicos y alguna idea de demoras en los recursos.  Todo esto debe actualizarse en tiempo real.  Pero no queremos tocar la tabla de datos cada vez y generar una consulta, o actualizar la vista en la parte superior de la tabla. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> CONTINUOUS <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> total_count, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> cookie::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> uniques, <span class="hljs-keyword"><span class="hljs-keyword">percentile_cont</span></span>(<span class="hljs-number"><span class="hljs-number">0.99</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WITHIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> latency::<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> p99_latency <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_views <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">url | total_count | uniques | p99_latency -----------+-------------+---------+------------ some/url/0 | 633 | 51 | 178 some/url/1 | 688 | 37 | 139 some/url/2 | 508 | 88 | 121 some/url/3 | 848 | 36 | 59 some/url/4 | 126 | 64 | 159</code> </pre> <br>  El procesamiento de transmisión y la extensión PipelineDB vienen al rescate.  La extensión agrega la abstracción CONTINUES VIEW.  En la versión rusa, esto puede sonar como una "presentación continua".  Esta vista se actualiza automáticamente cuando se inserta en la tabla con los registros de visitas, mientras que solo se basa en datos nuevos, sin leerlos ya registrados de antemano. <br><br>  <b>Flujo de datos</b> .  PipelineDB no se limita solo al nuevo tipo de vista.  Supongamos que realizamos pruebas A / B y recopilamos análisis en tiempo real sobre la efectividad de una nueva solución de negocios.  Pero no queremos almacenar los datos sobre las acciones del usuario.  Solo nos interesa el resultado: qué grupo tiene la mayor conversión. <br><br>  Para evitar el almacenamiento directo de datos sin procesar para la informática de transmisión, necesitamos una abstracción como las <b>transmisiones: transmisión de datos</b> .  PipelineDB presenta esta característica.  Puede crear transmisiones como tablas normales.  Debajo del capó, será "TABLA EXTRANJERA" basada en la cola ZeroMQ, que la extensión utiliza imperceptiblemente de nosotros.  Los datos entran en la cola interna de ZeroMQ y desencadenan una actualización de la vista continua. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> STREAM ab_event_stream ( <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, ab_group <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, event_type <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>), cookie <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> CONTINUOUS <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> ab_test_monitor <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, ab_group, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> WHENevent_type = <span class="hljs-string"><span class="hljs-string">'v'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> view_count, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> WHENevent_type = <span class="hljs-string"><span class="hljs-string">'c'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> conversion_count, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> cookie) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> uniques <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ab_event_stream <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, ab_group;</code> </pre> <br>  Luego creamos una "VISTA CONTINUA" basada en datos de una secuencia creada previamente.  Cuando los datos llegan a la secuencia, la vista se actualizará en función de estos datos.  Después de eso, los datos simplemente se descartarán, no se guardarán en ningún lugar y no ocuparán espacio en disco.  Esto le permite crear análisis sobre una cantidad casi ilimitada de datos, cargarlos en el flujo de datos de PipelineDB y leer el resultado del cálculo desde una vista continua. <br><br>  <b>Streaming de computación</b>  Después de haber creado el flujo de datos y la vista continua, podemos trabajar con la informática de flujo.  Se ve así. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> ab_event_stream (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, ab_group, event_type, cookie) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random() * <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random() * <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ab_group, (<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> WHENrandom() &gt; <span class="hljs-number"><span class="hljs-number">0.4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'v'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'c'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> event_type, <span class="hljs-keyword"><span class="hljs-keyword">md5</span></span>(random()::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> cookie <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ab_group, uniques <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ab_test_monitor; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ab_group, view_count * <span class="hljs-number"><span class="hljs-number">100</span></span> / (conversion_count + view_count) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> conversion_rate <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ab_test_monitor;</code> </pre> <br>  El primer "SELECCIONAR" le da al grupo "ab" y el número de visitantes únicos.  El segundo - da la relación entre los grupos - conversión.  Eso es todo prueba A / B en cinco llamadas SQL en una base de datos relacional. <br><br>  La vista se actualiza dinámicamente.  No puede esperar el procesamiento de toda la matriz de datos, sino leer los resultados intermedios que ya se han procesado.  Las vistas se leen de la misma manera que PostgreSQL normal.  También puede combinar una vista con tablas o incluso otras vistas.  No hay restricciones <br><br><h3>  Topología </h3><br>  Kafka recibe telemetría, el tema en Kafka envía estos datos a PostgreSQL y los agregamos más.  Por ejemplo, combinamos con alguna tabla ordinaria y redirigimos los datos a la secuencia.  Además, provoca la actualización de la presentación continua correspondiente, desde la cual los clientes de la base de datos ya pueden leer los datos terminados. <br><br><img src="https://habrastorage.org/webt/0e/4p/zb/0e4pzbehsh35td5tdiillcaq82m.jpeg"><br><br>  <i>Un ejemplo de la topología de los componentes PipelineDB dentro de PostgreSQL.</i>  <i>El circuito está tomado de una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">presentación de</a> Derek Nelson.</i> <br><br>  Además de las transmisiones y las vistas, la extensión también proporciona una abstracción de "transformadores": convertidores o mutadores.  Esta vista, pero apuntaba a convertir el flujo de datos entrantes en una salida modificada.  Con estos mutadores, puede cambiar la presentación de los datos o filtrarlos.  Desde el mutador, todo cae en la vista VISTA CONTINUA.  Ya hacemos consultas para negocios en él.  Cualquier persona familiarizada con la programación funcional debe entender la idea. <br><br>  En PipelineDB podemos colgar un disparador en nuestras vistas y realizar acciones, por ejemplo, "alerta".  Con todos estos cálculos, nunca almacenamos los datos sin procesar nosotros mismos, en base a los cuales todos los calculamos.  Estos pueden ser terabytes, que cargamos secuencialmente a un servidor con un disco de cien gigabytes.  Después de todo, solo estamos interesados ​​en el resultado de los cálculos. <br><br><h3>  Características clave </h3><br>  La extensión PipelineDB es más difícil de aprender que TimescaleDB.  En TimescaleDB, creamos una tabla, le decimos que es hiperactiva y disfrutamos la vida usando varias funciones adicionales que ofrece la extensión. <br><br>  <b>PipelineDB resuelve el problema de la informática en streaming en bases de datos relacionales</b> .  La tarea de procesar el procesamiento de datos es más complicada que la partición en términos de integración y uso.  Sin embargo, no todos tienen grandes datos y miles de millones de filas.  ¿Por qué complicar la infraestructura si hay PipelineDB?  La extensión proporciona sus propias implementaciones de representaciones, flujos, convertidores y agregados para el procesamiento de flujos.  También está <b>integrado en el planificador de consultas y el ejecutor de consultas</b> permite implementar el concepto de informática de flujo en una base de datos relacional. <br><br>  Al igual que TimescaleDB, la extensión PipelineDB <b>no impone restricciones de SQL en PostgreSQL</b> .  Hay varias características, por ejemplo, no puede combinar dos secuencias, pero esto no es necesario. <br><br>  <b>Soporte para estructuras de datos probabilísticos y algoritmos</b> .  La extensión utiliza el filtro Bloom para SELECT DISTINCT, HyperLogLog para COUNT (DISTINCT) y T-Digest para percentile_count () directamente en SQL.  Esto mejora la productividad. <br><br>  <b>Ecosistema</b>  La extensión le permite trabajar con las soluciones habituales de alta disponibilidad, herramientas de monitoreo y todo lo demás que es familiar en PostgreSQL. <br><br>  Dados los detalles de la informática de transmisión, PipelineDB tiene <b>integraciones con Apache Kafka</b> y con Amazon Kinesis, un servicio de análisis en tiempo real.  Dado que PipelineDB ya no es una bifurcación, sino una extensión, la integración con el resto del zoológico también debería estar lista para usar.  Una visita obligada, pero no vivimos en un mundo ideal, y todo vale la pena comprobarlo. <br><br><h3>  Licencias y noticias </h3><br>  Todo el código tiene licencia bajo Apache 2.0.  Hay una suscripción paga al soporte de diferentes galerías de tiro, así como una versión en clúster con licencia comercial.  Basado en PipelineDB, la compañía proporciona el servicio de análisis Stride. <br><br>  Antes de comenzar a hablar sobre la extensión, dije que hay un "pero".  Es hora de hablar de él.  El 1 de mayo de 2019, el equipo de PipelineDB anunció que ahora es parte de Confluent.  Esta es la compañía que desarrolla KSQL, un motor para transmitir datos en Kafka con sintaxis SQL.  Ahora Victor Gamov, cofundador del podcast Debriefing, está trabajando allí. <br><br>  ¿Qué se sigue de esto?  PipelineDB se congeló en la versión 1.0.0.  Además de corregir errores críticos, no hay nada planeado en él.  Debido a la adquisición, esperamos la integración de Uber de Kafka con PostgreSQL.  Quizás sea Confluent basado en almacenamiento conectable que hará algo genial. <br><br>  Que hacer  Vaya a TimescaleDB.  En la última versión hicieron su "VISTA CONTINUA" con el blackjack.  Por supuesto, ahora la funcionalidad no es tan buena como en PipelineDB, pero es cuestión de tiempo. <br><br><h3>  Para resumir </h3><br><blockquote>  PipelineDB está diseñado para el procesamiento de datos de transmisión de alto rendimiento.  Le permite realizar cálculos en grandes conjuntos de datos sin tener que guardar los datos en sí. </blockquote><br>  Con PipelineDB, cuando enviamos un flujo de datos a PostgreSQL en un flujo, los consideramos virtuales.  No guardamos datos, sino que agregamos, calculamos y descartamos.  Puede crear un servidor de 200 gigabytes y extraer terabytes de datos a través de flujos.  Obtendremos el resultado, pero los datos en sí serán descartados. <br><br>  Si por alguna razón la "VISTA CONTINUA" de TimescaleDB no es suficiente para usted, pruebe PipelineDB.  Este es un proyecto de código abierto bajo la licencia Apache.  No irá a ninguna parte, aunque ya no se está desarrollando activamente.  Pero las cosas pueden cambiar, Confluent aún no ha escrito sobre planes de expansión. <br><br><h2>  Usando TimescaleDB y PipelineDB </h2><br>  Con PostgreSQL y dos extensiones, <b>podemos almacenar y procesar grandes matrices de datos de series temporales</b> .  Puedes pensar en muchas aplicaciones.  Veamos un ejemplo de mi área temática: monitoreo de vehículos. <br><br><img src="https://habrastorage.org/webt/mx/_k/ru/mx_krumolcfgrlfrraktizshhem.jpeg"><br><br>  El equipo de navegación envía continuamente grabaciones de telemetría a nuestros servidores.  Analizan varios protocolos de texto y binarios en un formato común y envían datos a Kafka en un tema especial.  A partir de ahí, se integran con PipelineDB en el flujo de datos de telemetría dentro de PostgreSQL.  Este flujo actualiza la vista del estado actual de los vehículos y el análisis general de la flota, y sobre la base del desencadenante provoca la grabación de registros de telemetría en el hiperestable TimescaleDB. <br><br>  Con extensiones, tenemos tres ventajas. <br><br><ul><li>  Análisis en tiempo real. <br></li><li>  Almacenamiento de datos de series temporales. <br></li><li>  Disminución del volumen de telemetría almacenada.  Usando el mutador PipelineDB, agregamos datos, por ejemplo, en un minuto, calculando valores promedio. <br></li></ul><br>  Grafana tiene soporte incorporado para las funciones de TimescaleDB.  Por lo tanto, es posible construir gráficos según las métricas comerciales directamente desde el cuadro, hasta las pistas en el mapa por coordenadas.  El departamento de análisis estará encantado. <br><br>  Para "tocar" todo usted mismo, mire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la demostración en GitHub</a> y ejecute la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">imagen Docker</a> , dentro del ensamblaje de los últimos PostgreSQL, TimescaleDB y PipelineDB. <br><br><h2>  Total </h2><br>  PostgreSQL le permite combinar varias extensiones, así como agregar sus propios tipos de datos y funciones para resolver problemas específicos.  En nuestro caso, el uso de las extensiones TimescaleDB y PostGIS cubre casi por completo las necesidades de almacenamiento de datos de series temporales y cálculos geoespaciales.  Con la extensión PipelineDB, podemos realizar cálculos continuos para diversos análisis y estadísticas, y el uso de columnas JSONB nos permite almacenar datos débilmente estructurados en una base de datos relacional.  Las soluciones de código abierto son suficientes con la cabeza: no utilizamos soluciones comerciales. <br><br>  Estas extensiones prácticamente no imponen restricciones al ecosistema en torno a PostgreSQL, como soluciones de alta disponibilidad, sistemas de respaldo, herramientas de monitoreo y análisis de registros.  No necesitamos MongoDB si hay columnas JSONB, y no necesitamos InfluxDB si hay TimescaleDB. <br><br><blockquote>  ¿Te gusta la historia de Ivan y quieres compartir algo similar?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Solicite</a> antes del 7 de septiembre en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++</a> en Moscú.  El programa se está llenando gradualmente.    ,    ,  , ,  .    ,    ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464303/">https://habr.com/ru/post/464303/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464289/index.html">Cómo escribir paquetes Go</a></li>
<li><a href="../464291/index.html">Los 10 lenguajes de programación más influyentes de los últimos 50 años y sus creadores.</a></li>
<li><a href="../464293/index.html">¿Los ganchos se reemplazan en React Redux?</a></li>
<li><a href="../464295/index.html">Ejemplos de uso de algunas funciones nuevas de JavaScript</a></li>
<li><a href="../464299/index.html">0, 0, 1, 0, 2, 0, 2, 2, 1, 6, 0, 5, 0, 2, 6, 5, 4, 0, 5, 3, 0, 3, 2, 9, 0, 4, 9, 3, 6, 14, 0, 6, 3, 5, 15, 0, 5, 3, 5 ...</a></li>
<li><a href="../464305/index.html">Pequeño, si. Unboxing del petardo microvirtual</a></li>
<li><a href="../464307/index.html">Pruebas de integración de microservicios en Scala</a></li>
<li><a href="../464309/index.html">Botón de llamada de bricolaje. Raspberry Pi, MajorDoMo, Freeswitch y Linphonec</a></li>
<li><a href="../464315/index.html">La película en la que había tierra. Investigación de Yandex y una breve historia de búsqueda por significado</a></li>
<li><a href="../464317/index.html">Proyecto Konbanwa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>