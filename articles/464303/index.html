<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöó üÜì ü§¶üèª Datos de series de tiempo en un DBMS relacional. Extensiones TimescaleDB y PipelineDB para PostgreSQL üì§ üìì üßõüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los datos de series temporales o series temporales son datos que cambian con el tiempo. Las cotizaciones de divisas, la telemetr√≠a de los movimientos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Datos de series de tiempo en un DBMS relacional. Extensiones TimescaleDB y PipelineDB para PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/464303/">  Los datos de series temporales o series temporales son datos que cambian con el tiempo.  Las cotizaciones de divisas, la telemetr√≠a de los movimientos de transporte, las estad√≠sticas de acceso al servidor o la carga de la CPU son datos de series temporales.  Para almacenarlos se requieren herramientas espec√≠ficas: bases de datos temporales.  Hay docenas de herramientas, por ejemplo, InfluxDB o ClickHouse.  Pero incluso las mejores soluciones de almacenamiento de series temporales tienen desventajas.  Todos los almacenamientos de series temporales son de bajo nivel, adecuados solo para datos de series temporales, y ejecutar e inyectar en la pila actual es costoso y doloroso. <br><br><img src="https://habrastorage.org/webt/sx/9x/bz/sx9xbzv26lix6lh-frspdsopknw.jpeg"><br><br>  Pero, si tiene una pila PostgreSQL, puede olvidarse de InfluxDB y todas las dem√°s bases de datos temporales.  Instale dos extensiones, TimescaleDB y PipelineDB, y almacene, procese y analice datos de series temporales directamente en el ecosistema PostgreSQL.  Sin la introducci√≥n de soluciones de terceros, sin las desventajas de los almacenamientos temporales y sin los problemas de ejecutarlos.  Cu√°les son estas extensiones, cu√°les son sus ventajas y capacidades, le dir√° a <b>Ivan Muratov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">binakot</a> )</b> , el jefe del departamento de desarrollo de la "Primera Compa√±√≠a de Monitoreo". <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3WkNp7mllv0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  ¬øQu√© son las series temporales o las series temporales? </h2><br><blockquote>  Estos son datos sobre el proceso que se recopilan en diferentes momentos de su vida. </blockquote><br>  Por ejemplo, la ubicaci√≥n del autom√≥vil: velocidad, coordenadas, direcci√≥n o el uso de recursos en el servidor con datos sobre la carga en la CPU, RAM utilizada y espacio libre en disco. <br><br>  Las series de tiempo tienen varias caracter√≠sticas. <br><br><ul><li>  En una <b>correa de fijaci√≥n</b> .  Cualquier registro de serie temporal tiene un campo con una marca de tiempo en la que se registr√≥ el valor. <br></li><li>  <b>Las caracter√≠sticas del proceso, que se denominan niveles de la serie</b> : velocidad, coordenadas, datos de carga. <br></li><li>  Casi siempre con dichos datos funcionan <b>en modo de solo agregar</b> .  Esto significa que los nuevos datos no reemplazan a los antiguos.  Solo se eliminan los datos obsoletos. <br></li><li>  <b>Las entradas no se consideran por separado entre s√≠</b> .  Los datos se usan solo colectivamente para ventanas de tiempo, intervalos o per√≠odos. <br></li></ul><br><h3>  Soluciones de almacenamiento populares </h3><br>  El gr√°fico que tom√© de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">db-engines.com</a> muestra la popularidad de varios modelos de almacenamiento en los √∫ltimos dos a√±os. <br><br><img src="https://habrastorage.org/webt/w2/wf/_u/w2wf_uryfor_djey8enzmrskywo.jpeg"><br><br>  La posici√≥n de liderazgo est√° ocupada por almacenamientos de series de tiempo, en segundo lugar - bases de datos de gr√°ficos, luego - bases de datos clave y relacionales.  La popularidad de los repositorios especializados se asocia con un crecimiento intensivo en la integraci√≥n de las tecnolog√≠as de la informaci√≥n: Big Data, redes sociales, IoT, monitoreo de infraestructura de alta carga.  Adem√°s de los datos comerciales √∫tiles, incluso los registros y las m√©tricas ocupan una gran cantidad de recursos. <br><br><h3>  Soluciones de almacenamiento populares para datos de series temporales </h3><br>  El gr√°fico muestra soluciones especializadas para almacenar datos de series temporales.  La escala es logar√≠tmica. <br><br><img src="https://habrastorage.org/webt/ny/bz/6_/nybz6_-_3ce7t0y7xre1oxkbks8.jpeg"><br><br>  L√≠der estable InfluxDB.  Todos los que han encontrado datos de series de tiempo han escuchado sobre este producto.  Pero el gr√°fico muestra un aumento de diez veces en TimescaleDB: una extensi√≥n del DBMS relacional est√° luchando por un lugar bajo el sol entre los productos que se desarrollaron originalmente en la serie temporal. <br><br><blockquote>  PostgreSQL no es solo una buena base de datos, sino tambi√©n una plataforma extensible para desarrollar soluciones especializadas. </blockquote><br><h2>  Postgres, Postgis y TimescaleDB </h2><br>  The First Monitoring Company monitorea el movimiento de veh√≠culos utilizando sat√©lites.  Rastreamos 20,000 veh√≠culos y almacenamos datos de movimiento durante dos a√±os.  En total, tenemos 10 TB de datos de telemetr√≠a actuales.  En promedio, cada veh√≠culo env√≠a 5 registros de telemetr√≠a por minuto mientras conduce.  Los datos se env√≠an a trav√©s de equipos de navegaci√≥n a nuestros servidores telem√°ticos.  Reciben 500 paquetes de navegaci√≥n por segundo. <br><br>  Hace alg√∫n tiempo, decidimos actualizar globalmente la infraestructura y pasar de un monolito a microservicios.  Llamamos al nuevo sistema Waliot, y ya est√° en producci√≥n: el 90% de todos los veh√≠culos se transfieren a √©l. <br><br>  Mucho ha cambiado en la infraestructura, pero el enlace central se ha mantenido sin cambios: esta es la base de datos PostgreSQL.  Ahora estamos trabajando en la versi√≥n 10 y nos estamos preparando para pasar a 11. Adem√°s de PostgreSQL, como almacenamiento principal, utilizamos PostGIS para la inform√°tica geoespacial en la pila y TimescaleDB para almacenar una gran variedad de datos de series temporales. <br><br><h3>  ¬øPor qu√© PostgreSQL? </h3><br>  ¬øPor qu√© estamos tratando de usar una base de datos relacional para almacenar series de tiempo, en lugar de <s>soluciones</s> especializadas de <s>ClickHouse</s> para este tipo de datos?  Debido a los antecedentes de la experiencia acumulada y las impresiones de trabajar con PostgreSQL, no queremos utilizar una soluci√≥n desconocida como almacenamiento principal. <br><br><blockquote>  Cambiar a una nueva soluci√≥n es un riesgo. </blockquote><br>  Existen muchas soluciones especializadas para almacenar y procesar datos de series temporales.  La documentaci√≥n no siempre es suficiente, y una gran selecci√≥n de soluciones no siempre es buena.  Parece que los desarrolladores de cada nuevo producto quieren escribir todo desde cero, porque algo no era agradable en la soluci√≥n anterior.  Para comprender lo que no le gust√≥ exactamente, debe buscar informaci√≥n, analizar y comparar.  Una gran variedad de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tops</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clasificaciones</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comparaciones son</a> bastante atemorizantes en lugar de motivar a probar algo.  Tendr√° que pasar mucho tiempo para probar todas las soluciones usted mismo.  No podemos permitirnos adaptar solo una soluci√≥n durante varios meses.  Esta es una tarea dif√≠cil, y el tiempo dedicado nunca valdr√° la pena.  Por lo tanto, hemos elegido extensiones para PostgreSQL. <br><br>  Durante la fase de desarrollo de la infraestructura de Waliot, consideramos que InfluxDB es el principal repositorio de telemetr√≠a.  Pero cuando me encontr√© con TimescaleDB y ejecut√© pruebas en √©l, no hubo preguntas sobre la elecci√≥n.  PostgreSQL con la extensi√≥n TimescaleDB le permite usar otras extensiones en el mismo almacenamiento PostGIS o PipelineDB.  No necesitamos extraer datos, transformar, realizar an√°lisis y transferirlos a trav√©s de la red.  Todo se encuentra en un servidor o en un sistema agrupado; no es necesario arrastrar los datos.  Todos los c√°lculos se realizan al mismo nivel. <br><br>  Recientemente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nikolay Samokhvalov</a> , el autor de la cuenta postgresmen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">public√≥ un enlace</a> a un art√≠culo interesante sobre el uso de SQL para el procesamiento de datos en streaming.  Cinco de los seis autores del art√≠culo participan en el desarrollo de varios productos de Apache y trabajan con el procesamiento continuo.  Por lo tanto, el art√≠culo menciona Apache Spark, Apache Flink, Apache Beam, Apache Calcite y KSQL de Confluent. <br><br>  Pero no es interesante el art√≠culo en s√≠, sino el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tema en Hacker News</a> , en el que se discute.  El autor del tema escribe que, bas√°ndose en el art√≠culo, implement√≥ casi todas las ideas basadas en PostgreSQL 11. Utiliz√≥ extensiones CitusDB para escalado y fragmentaci√≥n horizontal, PipelineDB para computaci√≥n de flujo y vistas materializadas, TimescaleDB para almacenar datos de series temporales y seccionamiento.  Tambi√©n usa varios envoltorios de datos extranjeros. <br><br><blockquote>  Una mezcla loca de PostgreSQL y sus extensiones confirma una vez m√°s que PostgreSQL no es solo un DBMS, es una plataforma. </blockquote><br>  Y cuando se entregue el almacenamiento conectable ... ¬°Uf! <br><br>  Ir√≥nicamente, al investigar las soluciones, encontramos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Outflux</a> , el desarrollo del equipo TimescaleDB, que publicaron el 1 de abril.  ¬øQu√© crees que hace ella?  Esta es una utilidad para migrar de InfluxDB a TimescaleDB en un comando ... <br><br><h3>  Postgres bombo! </h3><br>  ¬°No subestimes el poder del bombo!  A menudo bromeamos diciendo que "el desarrollo est√° impulsado por el bombo", porque influye en nuestra percepci√≥n de los componentes de infraestructura y ajuste.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++,</a> discutimos mucho sobre PostgreSQL, ClickHouse, Tarantool, estos son desarrollos exagerados.  Simplemente no diga que no afecta sus preferencias y la elecci√≥n de soluciones para la infraestructura ... Por supuesto, este no es el factor principal, pero ¬øtiene alg√∫n efecto? <br><br>  He estado trabajando con PostgreSQL durante 5 a√±os.  Me gusta esta soluci√≥n  Resuelve casi todas mis tareas con una explosi√≥n.  Cada vez que algo sal√≠a mal con esta base, mis manos torcidas ten√≠an la culpa.  Por lo tanto, la elecci√≥n estaba predeterminada. <br><br><h2>  TimescaleDB VS PipelineDB </h2><br>  Pasemos a las extensiones TimescaleDB y PipelineDB.  ¬øQu√© dicen sus creadores sobre las extensiones? <br><br>  <b>TimescaleDB es una base de datos de series de tiempo de</b> c√≥digo abierto que est√° optimizada para una inserci√≥n r√°pida y consultas complejas. <br><br>  <b>PipelineDB</b> es una extensi√≥n de alto rendimiento dise√±ada para ejecutar consultas SQL continuas <b>para datos de series temporales</b> . <br><br>  Adem√°s de trabajar con datos de series temporales, tienen una historia similar.  Timescale se fund√≥ en 2015 y Pipeline en 2013. Las primeras versiones de trabajo aparecieron en 2017 y 2015, respectivamente.  Los equipos tardaron dos a√±os en liberar la funcionalidad m√≠nima.  Los lanzamientos de producci√≥n de ambas extensiones tuvieron lugar en octubre pasado con una diferencia de una semana.  Aparentemente, apurados uno tras otro. <br><br>  GitHub tiene un mont√≥n de estrellas y tenedores, que, como de costumbre, no son un solo compromiso.  As√≠ es como funciona el C√≥digo Abierto, no hay nada que hacer.  Pero hay muchas estrellas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TimescaleDB tiene</a> m√°s que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PipelineDB</a> , e incluso m√°s que PostgreSQL. <br><br>  Las extensiones parecen ser similares, pero se posicionan de manera diferente. <br><br>  <b>TimescaleDB</b> afirma haber insertado millones de registros por segundo y almacenado cientos de miles de millones de filas y decenas de terabytes de datos.  La extensi√≥n es m√°s r√°pida que InfluxDB, Cassandra, MongoDB o Vangre PostgreSQL.  Admite replicaci√≥n de transmisi√≥n y herramientas de copia de seguridad.  TimescaleDB es una extensi√≥n, no una bifurcaci√≥n de PostgreSQL. <br><br>  <b>PipelineDB</b> solo almacena el resultado de los c√°lculos de transmisi√≥n, sin la necesidad de almacenar datos sin procesar para sus c√°lculos.  La extensi√≥n es capaz de agregaci√≥n continua sobre flujos de datos en tiempo real, combin√°ndose con tablas convencionales para c√°lculos en el contexto de un dominio de dominio.  PipelineDB es una extensi√≥n, no una bifurcaci√≥n, pero inicialmente era una bifurcaci√≥n. <br><br><h2>  Timescaledb </h2><br>  Ahora en detalle sobre las extensiones.  Comencemos con TimescaleDB.  He estado trabajando con √©l por casi 2 a√±os.  Arrastrado a producci√≥n antes de la versi√≥n de lanzamiento.  Veamos ejemplos de c√≥mo aplicarlo. <br><br>  <b>Almacenamiento para m√©tricas de infraestructura</b> .  Tenemos m√©tricas de consumo de recursos de contenedor Docker, tiempo de confirmaci√≥n de m√©tricas, identificador de contenedor y campos de consumo de recursos, por ejemplo, memoria libre.  Necesitamos mostrar estad√≠sticas para todos los contenedores con una cantidad promedio de ventanas de memoria libre durante 10 segundos.  La consulta que ve resuelve este problema y TimescaleDB se puede utilizar como repositorio de m√©tricas de infraestructura. <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> time_bucket(<span class="hljs-string"><span class="hljs-string">'10 seconds'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span>, container_id, <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(free_mem) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> metrics <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> <span class="hljs-string"><span class="hljs-string">'10 minutes'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span>, container_id <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>, container_id;</code> </pre> <br><pre> <code class="plaintext hljs">period | container_id | avg -----------------------+--------------+--- 2019-06-24 12:01:00+00 | 16 | 72202 2019-06-24 12:01:00+00 | 73 | 837725 2019-06-24 12:01:00+00 | 96 | 412237 2019-06-24 12:00:50+00 | 16 | 1173393 2019-06-24 12:00:50+00 | 73 | 90104 2019-06-24 12:00:50+00 | 96 | 784596</code> </pre> <br>  <b>Para c√°lculos</b>  Necesitamos calcular la cantidad de camiones que dejaron Krasnodar y su tonelaje total por d√≠as. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> time_bucket(<span class="hljs-string"><span class="hljs-string">'1 day'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">day</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> trucks_exiting, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(weight) / <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tonnage <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vehicles <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> cities <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> cities.name = <span class="hljs-string"><span class="hljs-string">'Krasnodar'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ST_Within(last_location, ST_Polygon(cities.geom, <span class="hljs-number"><span class="hljs-number">4326</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> ST_Within(current_location, ST_Polygon(cities.geom, <span class="hljs-number"><span class="hljs-number">4326</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br>  Tambi√©n utiliza funciones de la extensi√≥n PostGIS para calcular el transporte que sali√≥ de la ciudad, en lugar de simplemente moverse en ella. <br><br>  <b>Monitoreo de la tasa de cambio</b> .  El tercer ejemplo es sobre las criptomonedas.  La solicitud le permite mostrar c√≥mo ha cambiado el precio de Ethereum en relaci√≥n con Bitcoin y el d√≥lar estadounidense en las √∫ltimas 2 semanas por d√≠a. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> time_bucket(<span class="hljs-string"><span class="hljs-string">'14 days'</span></span>, c.time) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>(c.closing_price, c.time) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> closing_price_btc, <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>(c.closing_price, c.time) * <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>(b.closing_price, c.time) filter (<span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> b.currency_code = <span class="hljs-string"><span class="hljs-string">'USD'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> closing_price_usd <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> crypto_prices c <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> btc_prices b <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> time_bucket(<span class="hljs-string"><span class="hljs-string">'1 day'</span></span>, c.time) = time_bucket(<span class="hljs-string"><span class="hljs-string">'1 day'</span></span>, b.time) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.currency_code = <span class="hljs-string"><span class="hljs-string">'ETH'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre> <br>  Todo esto es igual de claro y conveniente para nosotros SQL. <br><br><h3>  ¬øQu√© tiene de bueno TimescaleDB? </h3><br>  ¬øPor qu√© no usar las herramientas integradas de partici√≥n de tablas?  ¬øY por qu√© molestarse en romper las mesas?  La respuesta obvia es la <b>velocidad de inserci√≥n en tales bases de datos</b> .  El gr√°fico muestra las mediciones reales de la tasa de inserci√≥n del n√∫mero de filas por segundo entre la tabla de vainilla regular PostgreSQL 10 sin seccionamiento y el hiperestable TimescaleDB. <br><br><img src="https://habrastorage.org/webt/gq/ln/xd/gqlnxdxeupbqkf_i-wdeihs0zlq.jpeg"><br><br>  Este punto de referencia escribe mil millones de l√≠neas en una m√°quina, simulando un escenario para recopilar m√©tricas de la infraestructura.  El registro contiene tiempo, el identificador del componente de infraestructura y 10 m√©tricas.  El punto de referencia se ejecut√≥ en Azure VM con 8 n√∫cleos y 28 gigabytes de RAM, as√≠ como unidades SSD de red.  La inserci√≥n se realiz√≥ en lotes de 10 mil registros. <br><br>  ¬øDe d√≥nde viene esa degradaci√≥n del rendimiento de PostgreSQL?  Porque cuando inserta, tambi√©n necesita actualizar los √≠ndices de la tabla.  Cuando no caben en el cach√©, comenzamos a cargar discos.  La partici√≥n resuelve este problema si los √≠ndices de la secci√≥n en la que insertamos los datos se colocan en la RAM. <br><br>  Veamos el siguiente cuadro.  Esto compara el sistema de particionamiento declarativo integrado en PostgreSQL 10 y la hipertabla TimescaleDB.  En el eje horizontal, el n√∫mero de secciones. <br><br><img src="https://habrastorage.org/webt/kd/dz/xd/kddzxdttzspi9peoiriem7sipms.jpeg"><br><br>  En TimescaleDB, la degradaci√≥n es insignificante con secciones crecientes.  Los desarrolladores de extensiones afirman que les est√° yendo bien con 10,000 secciones en una sola instancia de PostgreSQL. <br><br>  En PostgreSQL, la implementaci√≥n nativa se degrada significativamente despu√©s de 3.000. En general, la partici√≥n declarativa en PostgreSQL es un gran paso adelante, pero solo funciona bien para tablas con menos carga.  Por ejemplo, para bienes, compradores y otras entidades de dominio que ingresan al sistema de manera no tan intensa como las m√©tricas. <br><br>  En las versiones 11 y 12 de PostgreSQL, aparecer√° el soporte de particionamiento nativo y puede intentar ejecutar pruebas comparativas para datos de series temporales con nuevas versiones.  Pero, me parece que TimescaleDB es a√∫n mejor.  Todos los puntos de referencia de TimescaleDB se pueden encontrar en su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> y probar. <br><br><h3>  Caracter√≠sticas clave </h3><br>  Espero que ya tenga inter√©s en la extensi√≥n.  Repasemos las caracter√≠sticas principales de TimescaleDB para consolidar este sentimiento. <br><br>  <b>Particionamiento a trav√©s de hipertables</b> .  TimescaleDB utiliza el t√©rmino "hipertable" para las tablas a las que se ha aplicado la funci√≥n create_hypertable ().  Despu√©s de eso, la tabla se convertir√° en el padre de todas las secciones heredadas: fragmentos.  La tabla principal en s√≠ no contendr√° ning√∫n dato, pero ser√° un punto de entrada para todas las consultas y una plantilla al crear autom√°ticamente nuevas secciones.  Todas las secciones se almacenan no en el esquema principal de sus datos, sino en un esquema especial.  Esto es conveniente porque no vemos miles de estas secciones en el esquema de datos. <br><br>  <b>La extensi√≥n est√° integrada en el planificador y el ejecutor de consultas</b> .  A trav√©s de enlaces especiales en PostgreSQL, TimescaleDB comprende cu√°ndo accede a un hipertable.  TimescaleDB analiza la consulta y redirige las consultas solo a las secciones necesarias en funci√≥n de las condiciones especificadas en la propia llamada SQL.  Esto le permite paralelizar el trabajo con secciones durante la extracci√≥n de una cantidad significativa de datos. <br><br>  <b>La extensi√≥n no impone restricciones en SQL</b> .  Puede utilizar libremente uniones, agregados, funciones de ventana, CTE e √≠ndices adicionales.  Si vio la lista de restricciones para el sistema de particionamiento incorporado, esto deber√≠a complacerle. <br><br>  <b>Funciones √∫tiles adicionales</b> espec√≠ficas para datos de series temporales: <br><br><ul><li>  "Time_bucket" - "date_trun" de una persona sana; <br></li><li>  histogramas: completar los intervalos perdidos utilizando la interpolaci√≥n o el √∫ltimo valor conocido; <br></li><li>  Trabajador en segundo plano: servicios que le permiten realizar operaciones en segundo plano: limpieza de secciones antiguas, reorganizaci√≥n. <br></li></ul><br>  <b>TimescaleDB le permite permanecer en el poderoso ecosistema PostgreSQL</b> .  Esta extensi√≥n no rompe PostgreSQL, por lo tanto, todas las soluciones de alta disponibilidad, sistemas de respaldo y herramientas de monitoreo continuar√°n funcionando.  TimescaleDB es amigo de Grafana, Periscope, Prometheus, Telegraf, Zabbix, Kubernetes, Kafka, Seeq, JackDB. <br><br>  <b>Grafana</b> ya tiene soporte nativo para TimescaleDB como fuente de datos.  Grafana entiende de inmediato que PostscreSQL tiene TimescaleDB.  El generador de consultas en Grafana en los paneles comprende funciones adicionales de TimescaleDB, como "time_bucket", "first", "last".  Puede crear gr√°ficos directamente desde la base de datos relacional con estas funciones de series de tiempo sin consultas gigantes. <br><br>  <b>Prometheus tiene</b> un adaptador que le permite combinar datos de √©l y usar TimescaleDB como un almac√©n de datos confiable.  Use un adaptador para no almacenar datos en Prometheus durante a√±os. <br><br>  Tambi√©n hay un <b>complemento Telegraf</b> .  La soluci√≥n le permite eliminar completamente Prometheus.  Los datos de infraestructura se transfieren inmediatamente a TimescaleDB y se leen a trav√©s de Telegraf. <br><br><h3>  Licencias y noticias </h3><br>  No hace mucho tiempo, la compa√±√≠a cambi√≥ a un nuevo modelo de licencia.  La mayor parte del c√≥digo tiene licencia de Apache 2.0.  Una peque√±a porci√≥n es de uso gratuito, pero tiene licencia bajo TSL. <br><br>  Hay una versi√≥n Enterprise con licencia comercial.  No se preocupe, no todas las cosas buenas en la versi√≥n Enterprise.  B√°sicamente, hay automatizaci√≥n, como la eliminaci√≥n autom√°tica de fragmentos obsoletos que se puede hacer a trav√©s de un simple "cron" y cosas similares. <br><br>  Ahora la compa√±√≠a est√° trabajando activamente en una soluci√≥n de cl√∫ster.  Quiz√°s caiga en la versi√≥n Enterprise.  Tambi√©n hay una versi√≥n en la nube para nuevas empresas que desean ingresar al mercado antes de que los inversores se queden sin dinero. <br><br>  De las noticias: <br><br><ul><li>  un mill√≥n de descargas en el √∫ltimo a√±o y medio; <br></li><li>  Inversi√≥n de $ 31 millones; <br></li><li>  Colaboraci√≥n activa con MS Azure con respecto a las soluciones de IoT. <br></li></ul><br><h3>  Para resumir </h3><br><blockquote>  TimescaleDB est√° dise√±ado para almacenar datos de series temporales.  Este es un poderoso sistema de particionamiento con restricciones m√≠nimas en comparaci√≥n con los nativos en PostgreSQL. </blockquote><br>  Desafortunadamente, la extensi√≥n a√∫n no tiene una versi√≥n multinodo.  Si desea un multimaestro o un fragmento, debe jugar, por ejemplo, con CitusDB.  Si quieres una replicaci√≥n l√≥gica, te doler√°.  Pero siempre duele con ella. <br><br><h2>  Pipelinedb </h2><br>  Ahora hablemos de la segunda extensi√≥n.  Desafortunadamente, no pudimos probarlo adecuadamente en la batalla.  Ahora est√° pasando por la etapa de adaptaci√≥n en nuestro sistema.  Es cierto, hay un problema del que hablar√© m√°s cerca del final. <br><br>  Como en el caso anterior, comenzamos con ejemplos reales.  Es m√°s f√°cil comprender los beneficios de la extensi√≥n y la motivaci√≥n para usarla. <br><br>  <b>Colecci√≥n de estad√≠sticas</b> .  Imagine que recopilamos estad√≠sticas sobre las visitas a nuestro sitio web.  Necesitamos an√°lisis de las p√°ginas m√°s populares, la cantidad de usuarios √∫nicos y alguna idea de demoras en los recursos.  Todo esto debe actualizarse en tiempo real.  Pero no queremos tocar la tabla de datos cada vez y generar una consulta, o actualizar la vista en la parte superior de la tabla. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> CONTINUOUS <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> total_count, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> cookie::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> uniques, <span class="hljs-keyword"><span class="hljs-keyword">percentile_cont</span></span>(<span class="hljs-number"><span class="hljs-number">0.99</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WITHIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> latency::<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> p99_latency <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_views <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">url | total_count | uniques | p99_latency -----------+-------------+---------+------------ some/url/0 | 633 | 51 | 178 some/url/1 | 688 | 37 | 139 some/url/2 | 508 | 88 | 121 some/url/3 | 848 | 36 | 59 some/url/4 | 126 | 64 | 159</code> </pre> <br>  El procesamiento de transmisi√≥n y la extensi√≥n PipelineDB vienen al rescate.  La extensi√≥n agrega la abstracci√≥n CONTINUES VIEW.  En la versi√≥n rusa, esto puede sonar como una "presentaci√≥n continua".  Esta vista se actualiza autom√°ticamente cuando se inserta en la tabla con los registros de visitas, mientras que solo se basa en datos nuevos, sin leerlos ya registrados de antemano. <br><br>  <b>Flujo de datos</b> .  PipelineDB no se limita solo al nuevo tipo de vista.  Supongamos que realizamos pruebas A / B y recopilamos an√°lisis en tiempo real sobre la efectividad de una nueva soluci√≥n de negocios.  Pero no queremos almacenar los datos sobre las acciones del usuario.  Solo nos interesa el resultado: qu√© grupo tiene la mayor conversi√≥n. <br><br>  Para evitar el almacenamiento directo de datos sin procesar para la inform√°tica de transmisi√≥n, necesitamos una abstracci√≥n como las <b>transmisiones: transmisi√≥n de datos</b> .  PipelineDB presenta esta caracter√≠stica.  Puede crear transmisiones como tablas normales.  Debajo del cap√≥, ser√° "TABLA EXTRANJERA" basada en la cola ZeroMQ, que la extensi√≥n utiliza imperceptiblemente de nosotros.  Los datos entran en la cola interna de ZeroMQ y desencadenan una actualizaci√≥n de la vista continua. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> STREAM ab_event_stream ( <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, ab_group <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, event_type <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>), cookie <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> CONTINUOUS <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> ab_test_monitor <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, ab_group, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> WHENevent_type = <span class="hljs-string"><span class="hljs-string">'v'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> view_count, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> WHENevent_type = <span class="hljs-string"><span class="hljs-string">'c'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> conversion_count, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> cookie) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> uniques <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ab_event_stream <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, ab_group;</code> </pre> <br>  Luego creamos una "VISTA CONTINUA" basada en datos de una secuencia creada previamente.  Cuando los datos llegan a la secuencia, la vista se actualizar√° en funci√≥n de estos datos.  Despu√©s de eso, los datos simplemente se descartar√°n, no se guardar√°n en ning√∫n lugar y no ocupar√°n espacio en disco.  Esto le permite crear an√°lisis sobre una cantidad casi ilimitada de datos, cargarlos en el flujo de datos de PipelineDB y leer el resultado del c√°lculo desde una vista continua. <br><br>  <b>Streaming de computaci√≥n</b>  Despu√©s de haber creado el flujo de datos y la vista continua, podemos trabajar con la inform√°tica de flujo.  Se ve as√≠. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> ab_event_stream (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, ab_group, event_type, cookie) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random() * <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random() * <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ab_group, (<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> WHENrandom() &gt; <span class="hljs-number"><span class="hljs-number">0.4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'v'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'c'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> event_type, <span class="hljs-keyword"><span class="hljs-keyword">md5</span></span>(random()::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> cookie <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ab_group, uniques <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ab_test_monitor; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ab_group, view_count * <span class="hljs-number"><span class="hljs-number">100</span></span> / (conversion_count + view_count) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> conversion_rate <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ab_test_monitor;</code> </pre> <br>  El primer "SELECCIONAR" le da al grupo "ab" y el n√∫mero de visitantes √∫nicos.  El segundo - da la relaci√≥n entre los grupos - conversi√≥n.  Eso es todo prueba A / B en cinco llamadas SQL en una base de datos relacional. <br><br>  La vista se actualiza din√°micamente.  No puede esperar el procesamiento de toda la matriz de datos, sino leer los resultados intermedios que ya se han procesado.  Las vistas se leen de la misma manera que PostgreSQL normal.  Tambi√©n puede combinar una vista con tablas o incluso otras vistas.  No hay restricciones <br><br><h3>  Topolog√≠a </h3><br>  Kafka recibe telemetr√≠a, el tema en Kafka env√≠a estos datos a PostgreSQL y los agregamos m√°s.  Por ejemplo, combinamos con alguna tabla ordinaria y redirigimos los datos a la secuencia.  Adem√°s, provoca la actualizaci√≥n de la presentaci√≥n continua correspondiente, desde la cual los clientes de la base de datos ya pueden leer los datos terminados. <br><br><img src="https://habrastorage.org/webt/0e/4p/zb/0e4pzbehsh35td5tdiillcaq82m.jpeg"><br><br>  <i>Un ejemplo de la topolog√≠a de los componentes PipelineDB dentro de PostgreSQL.</i>  <i>El circuito est√° tomado de una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">presentaci√≥n de</a> Derek Nelson.</i> <br><br>  Adem√°s de las transmisiones y las vistas, la extensi√≥n tambi√©n proporciona una abstracci√≥n de "transformadores": convertidores o mutadores.  Esta vista, pero apuntaba a convertir el flujo de datos entrantes en una salida modificada.  Con estos mutadores, puede cambiar la presentaci√≥n de los datos o filtrarlos.  Desde el mutador, todo cae en la vista VISTA CONTINUA.  Ya hacemos consultas para negocios en √©l.  Cualquier persona familiarizada con la programaci√≥n funcional debe entender la idea. <br><br>  En PipelineDB podemos colgar un disparador en nuestras vistas y realizar acciones, por ejemplo, "alerta".  Con todos estos c√°lculos, nunca almacenamos los datos sin procesar nosotros mismos, en base a los cuales todos los calculamos.  Estos pueden ser terabytes, que cargamos secuencialmente a un servidor con un disco de cien gigabytes.  Despu√©s de todo, solo estamos interesados ‚Äã‚Äãen el resultado de los c√°lculos. <br><br><h3>  Caracter√≠sticas clave </h3><br>  La extensi√≥n PipelineDB es m√°s dif√≠cil de aprender que TimescaleDB.  En TimescaleDB, creamos una tabla, le decimos que es hiperactiva y disfrutamos la vida usando varias funciones adicionales que ofrece la extensi√≥n. <br><br>  <b>PipelineDB resuelve el problema de la inform√°tica en streaming en bases de datos relacionales</b> .  La tarea de procesar el procesamiento de datos es m√°s complicada que la partici√≥n en t√©rminos de integraci√≥n y uso.  Sin embargo, no todos tienen grandes datos y miles de millones de filas.  ¬øPor qu√© complicar la infraestructura si hay PipelineDB?  La extensi√≥n proporciona sus propias implementaciones de representaciones, flujos, convertidores y agregados para el procesamiento de flujos.  Tambi√©n est√° <b>integrado en el planificador de consultas y el ejecutor de consultas</b> permite implementar el concepto de inform√°tica de flujo en una base de datos relacional. <br><br>  Al igual que TimescaleDB, la extensi√≥n PipelineDB <b>no impone restricciones de SQL en PostgreSQL</b> .  Hay varias caracter√≠sticas, por ejemplo, no puede combinar dos secuencias, pero esto no es necesario. <br><br>  <b>Soporte para estructuras de datos probabil√≠sticos y algoritmos</b> .  La extensi√≥n utiliza el filtro Bloom para SELECT DISTINCT, HyperLogLog para COUNT (DISTINCT) y T-Digest para percentile_count () directamente en SQL.  Esto mejora la productividad. <br><br>  <b>Ecosistema</b>  La extensi√≥n le permite trabajar con las soluciones habituales de alta disponibilidad, herramientas de monitoreo y todo lo dem√°s que es familiar en PostgreSQL. <br><br>  Dados los detalles de la inform√°tica de transmisi√≥n, PipelineDB tiene <b>integraciones con Apache Kafka</b> y con Amazon Kinesis, un servicio de an√°lisis en tiempo real.  Dado que PipelineDB ya no es una bifurcaci√≥n, sino una extensi√≥n, la integraci√≥n con el resto del zool√≥gico tambi√©n deber√≠a estar lista para usar.  Una visita obligada, pero no vivimos en un mundo ideal, y todo vale la pena comprobarlo. <br><br><h3>  Licencias y noticias </h3><br>  Todo el c√≥digo tiene licencia bajo Apache 2.0.  Hay una suscripci√≥n paga al soporte de diferentes galer√≠as de tiro, as√≠ como una versi√≥n en cl√∫ster con licencia comercial.  Basado en PipelineDB, la compa√±√≠a proporciona el servicio de an√°lisis Stride. <br><br>  Antes de comenzar a hablar sobre la extensi√≥n, dije que hay un "pero".  Es hora de hablar de √©l.  El 1 de mayo de 2019, el equipo de PipelineDB anunci√≥ que ahora es parte de Confluent.  Esta es la compa√±√≠a que desarrolla KSQL, un motor para transmitir datos en Kafka con sintaxis SQL.  Ahora Victor Gamov, cofundador del podcast Debriefing, est√° trabajando all√≠. <br><br>  ¬øQu√© se sigue de esto?  PipelineDB se congel√≥ en la versi√≥n 1.0.0.  Adem√°s de corregir errores cr√≠ticos, no hay nada planeado en √©l.  Debido a la adquisici√≥n, esperamos la integraci√≥n de Uber de Kafka con PostgreSQL.  Quiz√°s sea Confluent basado en almacenamiento conectable que har√° algo genial. <br><br>  Que hacer  Vaya a TimescaleDB.  En la √∫ltima versi√≥n hicieron su "VISTA CONTINUA" con el blackjack.  Por supuesto, ahora la funcionalidad no es tan buena como en PipelineDB, pero es cuesti√≥n de tiempo. <br><br><h3>  Para resumir </h3><br><blockquote>  PipelineDB est√° dise√±ado para el procesamiento de datos de transmisi√≥n de alto rendimiento.  Le permite realizar c√°lculos en grandes conjuntos de datos sin tener que guardar los datos en s√≠. </blockquote><br>  Con PipelineDB, cuando enviamos un flujo de datos a PostgreSQL en un flujo, los consideramos virtuales.  No guardamos datos, sino que agregamos, calculamos y descartamos.  Puede crear un servidor de 200 gigabytes y extraer terabytes de datos a trav√©s de flujos.  Obtendremos el resultado, pero los datos en s√≠ ser√°n descartados. <br><br>  Si por alguna raz√≥n la "VISTA CONTINUA" de TimescaleDB no es suficiente para usted, pruebe PipelineDB.  Este es un proyecto de c√≥digo abierto bajo la licencia Apache.  No ir√° a ninguna parte, aunque ya no se est√° desarrollando activamente.  Pero las cosas pueden cambiar, Confluent a√∫n no ha escrito sobre planes de expansi√≥n. <br><br><h2>  Usando TimescaleDB y PipelineDB </h2><br>  Con PostgreSQL y dos extensiones, <b>podemos almacenar y procesar grandes matrices de datos de series temporales</b> .  Puedes pensar en muchas aplicaciones.  Veamos un ejemplo de mi √°rea tem√°tica: monitoreo de veh√≠culos. <br><br><img src="https://habrastorage.org/webt/mx/_k/ru/mx_krumolcfgrlfrraktizshhem.jpeg"><br><br>  El equipo de navegaci√≥n env√≠a continuamente grabaciones de telemetr√≠a a nuestros servidores.  Analizan varios protocolos de texto y binarios en un formato com√∫n y env√≠an datos a Kafka en un tema especial.  A partir de ah√≠, se integran con PipelineDB en el flujo de datos de telemetr√≠a dentro de PostgreSQL.  Este flujo actualiza la vista del estado actual de los veh√≠culos y el an√°lisis general de la flota, y sobre la base del desencadenante provoca la grabaci√≥n de registros de telemetr√≠a en el hiperestable TimescaleDB. <br><br>  Con extensiones, tenemos tres ventajas. <br><br><ul><li>  An√°lisis en tiempo real. <br></li><li>  Almacenamiento de datos de series temporales. <br></li><li>  Disminuci√≥n del volumen de telemetr√≠a almacenada.  Usando el mutador PipelineDB, agregamos datos, por ejemplo, en un minuto, calculando valores promedio. <br></li></ul><br>  Grafana tiene soporte incorporado para las funciones de TimescaleDB.  Por lo tanto, es posible construir gr√°ficos seg√∫n las m√©tricas comerciales directamente desde el cuadro, hasta las pistas en el mapa por coordenadas.  El departamento de an√°lisis estar√° encantado. <br><br>  Para "tocar" todo usted mismo, mire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la demostraci√≥n en GitHub</a> y ejecute la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">imagen Docker</a> , dentro del ensamblaje de los √∫ltimos PostgreSQL, TimescaleDB y PipelineDB. <br><br><h2>  Total </h2><br>  PostgreSQL le permite combinar varias extensiones, as√≠ como agregar sus propios tipos de datos y funciones para resolver problemas espec√≠ficos.  En nuestro caso, el uso de las extensiones TimescaleDB y PostGIS cubre casi por completo las necesidades de almacenamiento de datos de series temporales y c√°lculos geoespaciales.  Con la extensi√≥n PipelineDB, podemos realizar c√°lculos continuos para diversos an√°lisis y estad√≠sticas, y el uso de columnas JSONB nos permite almacenar datos d√©bilmente estructurados en una base de datos relacional.  Las soluciones de c√≥digo abierto son suficientes con la cabeza: no utilizamos soluciones comerciales. <br><br>  Estas extensiones pr√°cticamente no imponen restricciones al ecosistema en torno a PostgreSQL, como soluciones de alta disponibilidad, sistemas de respaldo, herramientas de monitoreo y an√°lisis de registros.  No necesitamos MongoDB si hay columnas JSONB, y no necesitamos InfluxDB si hay TimescaleDB. <br><br><blockquote>  ¬øTe gusta la historia de Ivan y quieres compartir algo similar?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Solicite</a> antes del 7 de septiembre en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++</a> en Mosc√∫.  El programa se est√° llenando gradualmente.    ,    ,  , ,  .    ,    ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464303/">https://habr.com/ru/post/464303/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464289/index.html">C√≥mo escribir paquetes Go</a></li>
<li><a href="../464291/index.html">Los 10 lenguajes de programaci√≥n m√°s influyentes de los √∫ltimos 50 a√±os y sus creadores.</a></li>
<li><a href="../464293/index.html">¬øLos ganchos se reemplazan en React Redux?</a></li>
<li><a href="../464295/index.html">Ejemplos de uso de algunas funciones nuevas de JavaScript</a></li>
<li><a href="../464299/index.html">0, 0, 1, 0, 2, 0, 2, 2, 1, 6, 0, 5, 0, 2, 6, 5, 4, 0, 5, 3, 0, 3, 2, 9, 0, 4, 9, 3, 6, 14, 0, 6, 3, 5, 15, 0, 5, 3, 5 ...</a></li>
<li><a href="../464305/index.html">Peque√±o, si. Unboxing del petardo microvirtual</a></li>
<li><a href="../464307/index.html">Pruebas de integraci√≥n de microservicios en Scala</a></li>
<li><a href="../464309/index.html">Bot√≥n de llamada de bricolaje. Raspberry Pi, MajorDoMo, Freeswitch y Linphonec</a></li>
<li><a href="../464315/index.html">La pel√≠cula en la que hab√≠a tierra. Investigaci√≥n de Yandex y una breve historia de b√∫squeda por significado</a></li>
<li><a href="../464317/index.html">Proyecto Konbanwa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>