<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🎨 🧒🏾 👨‍👩‍👧 学说中的数据库游标 🚐 🧝🏿 🎍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="使用游标，您可以批量从数据库接收数据并处理大量数据，而不会浪费应用程序内存。 我确信每个Web开发人员都至少经历过一次类似的任务，而不仅仅是在我之前经历过一次。 在本文中，我将告诉您游标在哪些任务中有用，并以PostrgeSQL的示例为例，提供PHP + Doctrine使用游标的现成代码。 
 问...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>学说中的数据库游标</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lamoda/blog/455571/"><p><img src="https://habrastorage.org/webt/a_/l9/rc/a_l9rcqm9ubhpc_gstic1u-rxtq.jpeg" alt="图片"></p><br><p> 使用游标，您可以批量从数据库接收数据并处理大量数据，而不会浪费应用程序内存。 我确信每个Web开发人员都至少经历过一次类似的任务，而不仅仅是在我之前经历过一次。 在本文中，我将告诉您游标在哪些任务中有用，并以PostrgeSQL的示例为例，提供PHP + Doctrine使用游标的现成代码。 </p><a name="habracut"></a><br><h3 id="problema"> 问题 </h3><br><p> 假设我们有一个庞大的PHP项目。 当然，它是在某些框架的帮助下编写的。 例如，Symfony。 它还使用数据库（例如PostgreSQL），并且该数据库具有一个用于存储200万条记录的板，其中包含有关订单的信息。 项目本身就是这些订单的界面，可以显示和过滤它们。 而且，我想说，这做得很好。 </p><br><p> 现在，我们被要求（是否还没有要求您？肯定会要求他们）将筛选订单的结果上传到Excel文件中。 让我们按下带有表格图标的按钮，它将向用户吐出带有命令的文件。 </p><br><h3 id="kak-obychno-reshayut-i-chem-eto-ploho"> 通常如何决定，为什么会变坏？ </h3><br><p> 尚未遇到此类任务的程序员该如何处理？ 他在数据库中进行SELECT，读取查询结果，将响应转换为Excel文件并将其提供给用户的浏览器。 该任务有效，测试完成，但是问题开始于生产中。 </p><br><p> 当然，我们为每个进程设置了合理的（可能是）1 GB的PHP内存限制，并且一旦这200万行不再适合此千兆字节时，一切都会中断。  PHP崩溃并显示“内存不足”错误，用户抱怨该文件未上传。 发生这种情况是因为我们选择了一种非常幼稚的方式从数据库中卸载数据-所有这些首先都从数据库内存（及其下的磁盘）传输到PHP进程的RAM，然后被处理并上传到浏览器。 </p><br><p>为了使数据始终存储在内存中，您需要分批从数据库中获取数据。 例如，读取，处理，写入文件等次数达10,000条记录。 </p><br><p> 好吧，认为是第一次完成我们任务的程序员。 然后，我将做一个循环，并将查询结果分段压缩，以指示LIMIT和OFFSET。 它可以工作，但是对数据库来说是一个非常昂贵的操作，因此，上载报告的时间不是30秒，而是30分钟（还不错！）。 顺便说一句，如果此时除了OFFSET没什么让程序员想到的，那么<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">仍然有很多方法可以</a>在不强奸数据库的情况下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实现</a>相同的功能。 </p><br><p> 同时，数据库本身具有内建的从线程中读取数据的能力-游标。 </p><br><h3 id="kursory"> 游标 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">游标</a>是指向驻留在数据库中的查询结果中的一行的指针。 使用它们时，我们不能以立即下载数据的方式执行SELECT，而是使用此选择打开光标。 接下来，随着游标向前移动，我们开始从数据库接收数据流。 这给我们带来了相同的结果：我们分批读取数据，但是数据库并没有像查找OFFSET那样做同样的工作来查找需要开始的行。 </p><br><p> 游标仅在事务内部打开，并且一直存在直到事务有效（存在例外，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WITH HOLD</a> ）。 这意味着，如果我们从数据库中缓慢读取大量数据，则将需要很长时间。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有时</a>这很<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">糟糕</a> ，您需要了解并接受这种风险。 </p><br><h3 id="kursory-v-doctrine"> 学说中的游标 </h3><br><p> 让我们尝试在Doctrine中实现游标的工作。 首先，打开游标的请求是什么样的？ </p><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> mycursor1 <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> huge_table );</code> </pre> <br><p>  DECLARE创建并打开用于指定SELECT查询的游标。 创建游标后，您可以开始从中读取数据： </p><br><pre> <code class="sql hljs">FETCH FORWARD 10000 FROM mycursor1; &lt; 10 000 &gt; FETCH FORWARD 10000 FROM mycursor1; &lt;  10 000 &gt; ...</code> </pre> <br><p> 依此类推，直到FETCH返回一个空列表。 这将意味着它们滚动到结尾。 </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre> <br><p> 我们概述了一个与Doctrine兼容的类，该类将用光标封装工作。 为了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在20％的时间内解决80％的问题</a> ，它只能与本机查询一起使用。 因此，我们称它为PgSqlNativeQueryCursor。 </p><br><p> 构造函数： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NativeQuery $query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;query = $query; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection = $query-&gt;getEntityManager()-&gt;getConnection(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;cursorName = uniqid(<span class="hljs-string"><span class="hljs-string">'cursor_'</span></span>); assert(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection-&gt;getDriver() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> PDOPgSqlDriver); }</code> </pre> <br><p> 在这里，我为将来的游标生成一个名称。 </p><br><p> 由于该课程中包含该课程的PostgreSQL专用SQL代码，因此最好检查我们的驱动程序是否为PG。 </p><br><p> 在课堂上，我们需要三件事： </p><br><ol><li> 能够打开光标。 </li><li> 能够将数据返回给我们。 </li><li> 能够关闭光标。 </li></ol><br><p>  <strong>打开光标：</strong> </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openCursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection-&gt;getTransactionNestingLevel() === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \BadMethodCallException(<span class="hljs-string"><span class="hljs-string">'Cursor must be used inside a transaction'</span></span>); } $query = <span class="hljs-keyword"><span class="hljs-keyword">clone</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;query; $query-&gt;setSQL(sprintf( <span class="hljs-string"><span class="hljs-string">'DECLARE %s CURSOR FOR (%s)'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection-&gt;quoteIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;cursorName), <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;query-&gt;getSQL() )); $query-&gt;execute(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;query-&gt;getParameters()); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;isOpen = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre> <br><p> 如我所说，游标在事务中打开。 因此，在这里，我检查了是否我们没有忘记在已打开的事务中调用此方法。  （感谢上帝，我被吸引在这里开设交易的时间已经过去！） </p><br><p> 为了简化创建和初始化新NativeQuery的任务，我只克隆了一个馈入构造函数的函数，并将其包装在DECLARE ... CURSOR FOR（here_original_query）中。 我执行。 </p><br><p>  <strong>让我们制作getFetchQuery方法。</strong> 它不会返回数据，而是另一个请求，您可以根据需要使用该请求来获取给定批次中的所需数据。 这给了调用代码更多的自由。 </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFetchQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $count = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NativeQuery</span></span></span><span class="hljs-function"> </span></span>{ $query = <span class="hljs-keyword"><span class="hljs-keyword">clone</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;query; $query-&gt;setParameters([]); $query-&gt;setSQL(sprintf( <span class="hljs-string"><span class="hljs-string">'FETCH FORWARD %d FROM %s'</span></span>, $count, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection-&gt;quoteIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;cursorName) )); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $query; }</code> </pre> <br><p> 该方法有一个参数-这是包的大小，它将成为此方法返回的请求的一部分。 我对查询克隆应用了相同的技巧，覆盖了其中的参数，并用FETCH ... FROM ...;构造函数替换了SQL。 </p><br><p> 为了避免在第一次调用getFetchQuery（）之前忘记打开游标（突然我将无法获得足够的睡眠），我将直接在getFetchQuery（）方法中隐式打开它： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFetchQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $count = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NativeQuery</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;isOpen) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;openCursor(); } …</code> </pre> <br><p> 并且openCursor（）方法本身将被设为私有。 需要显式调用时，根本看不到任何情况。 </p><br><p> 在getFetchQuery（）中，我对FORWARD进行了硬编码，以将光标向前移动给定的行数。 但是FETCH调用模式有很多不同。 我们也添加它们吗？ </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DIRECTION_NEXT = <span class="hljs-string"><span class="hljs-string">'NEXT'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DIRECTION_PRIOR = <span class="hljs-string"><span class="hljs-string">'PRIOR'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DIRECTION_FIRST = <span class="hljs-string"><span class="hljs-string">'FIRST'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DIRECTION_LAST = <span class="hljs-string"><span class="hljs-string">'LAST'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DIRECTION_ABSOLUTE = <span class="hljs-string"><span class="hljs-string">'ABSOLUTE'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// with count const DIRECTION_RELATIVE = 'RELATIVE'; // with count const DIRECTION_FORWARD = 'FORWARD'; // with count const DIRECTION_FORWARD_ALL = 'FORWARD ALL'; const DIRECTION_BACKWARD = 'BACKWARD'; // with count const DIRECTION_BACKWARD_ALL = 'BACKWARD ALL';</span></span></code> </pre> <br><p> 其中一半接受参数中的行数，另一半则不接受。 这是我得到的： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFetchQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $count = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, string $direction = self::DIRECTION_FORWARD)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NativeQuery</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;isOpen) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;openCursor(); } $query = <span class="hljs-keyword"><span class="hljs-keyword">clone</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;query; $query-&gt;setParameters([]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( $direction == <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::DIRECTION_ABSOLUTE || $direction == <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::DIRECTION_RELATIVE || $direction == <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::DIRECTION_FORWARD || $direction == <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::DIRECTION_BACKWARD ) { $query-&gt;setSQL(sprintf( <span class="hljs-string"><span class="hljs-string">'FETCH %s %d FROM %s'</span></span>, $direction, $count, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection-&gt;quoteIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;cursorName) )); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $query-&gt;setSQL(sprintf( <span class="hljs-string"><span class="hljs-string">'FETCH %s FROM %s'</span></span>, $direction, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection-&gt;quoteIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;cursorName) )); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $query; }</code> </pre> <br><p> 使用CLOSE <strong>关闭游标</strong> ，无需等待事务完成： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;isOpen) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection-&gt;exec(<span class="hljs-string"><span class="hljs-string">'CLOSE '</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection-&gt;quoteIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;cursorName)); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;isOpen = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br><p> 析构函数： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__destruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;isOpen) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;close(); } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是整个班级的全部</a> 。 让我们尝试一下吗？ </p><br><p> 我在某些条件XLSX中打开一些条件编写器。 </p><br><pre> <code class="php hljs">$writer-&gt;openToFile($targetFile);</code> </pre> <br><p> 在这里，我得到NativeQuery来从数据库中提取订单列表。 </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> NativeQuery $query */</span></span> $query = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getOrdersRepository($em) -&gt;getOrdersFiltered($dateFrom, $dateTo, $filters);</code> </pre> <br><p> 基于此查询，我声明一个游标。 </p><br><pre> <code class="php hljs">$cursor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PgSqlNativeQueryCursor($query);</code> </pre> <br><p> 对于他，我得到了一个请求，以10,000行为单位批量接收数据。 </p><br><pre> <code class="php hljs">$fetchQuery = $cursor-&gt;getFetchQuery(<span class="hljs-number"><span class="hljs-number">10000</span></span>);</code> </pre> <br><p> 我迭代直到得到空结果。 在每次迭代中，我执行FETCH，处理结果，然后写入文件。 </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { $result = $fetchQuery-&gt;getArrayResult(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $row) { $writer-&gt;addRow(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;toXlsxRow($row)); } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($result);</code> </pre> <br><p> 我关闭光标和Writer。 </p><br><pre> <code class="php hljs">$cursor-&gt;close(); $writer-&gt;close();</code> </pre> <br><p> 我将文件本身写入临时目录的磁盘中，并在记录完成后将其提供给浏览器，以避免再次在内存中缓冲。 </p><br><p> 准备报告！ 我们使用来自PHP的恒定内存来处理所有数据，并且没有因一系列繁琐的查询而折磨数据库。 而且卸载本身花费的时间比满足请求所需的时间略多。 </p><br><p> 看看项目中是否有可以使用光标加速/保存内存的地方？ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455571/">https://habr.com/ru/post/zh-CN455571/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455555/index.html">机械经理的作品</a></li>
<li><a href="../zh-CN455559/index.html">量子计算机如何进入现代加密系统并降低氨气生产成本？</a></li>
<li><a href="../zh-CN455563/index.html">小型企业：是否自动化？</a></li>
<li><a href="../zh-CN455565/index.html">心灵可以伪造宇宙吗？</a></li>
<li><a href="../zh-CN455569/index.html">我们邀请您参加6月17日的Tarantool会议</a></li>
<li><a href="../zh-CN455575/index.html">神经匹配：如何使内容适应Google的现实</a></li>
<li><a href="../zh-CN455577/index.html">SDL 2课：第3课-事件</a></li>
<li><a href="../zh-CN455579/index.html">特百惠：Facebook杀手Kubernetes？</a></li>
<li><a href="../zh-CN455580/index.html">必备的移动应用动画</a></li>
<li><a href="../zh-CN455582/index.html">商店中的导航：通过增强现实到达所需的货架</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>