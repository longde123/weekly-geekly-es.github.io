<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💔 🥙 🚋 异国数据结构：修改后的Merkle Patricia Trie 🍬 🕶️ 🏄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="“我应该牢记所有这些该死的算法和数据结构是什么样的魔鬼？” 


 关于这一点，可以归结为大多数有关技术采访通过的文章的评论。 通常，主要的论点是，以一种或另一种方式使用的所有东西都已经被实施了十次，并且这位普通程序员不太可能必须处理。 好吧，在某种程度上这是事实。 但是，事实证明，并不是所有的事情...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>异国数据结构：修改后的Merkle Patricia Trie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446558/"><p>  <em>“我应该牢记所有这些该死的算法和数据结构是什么样的魔鬼？”</em> </p><br><p> 关于这一点，可以归结为大多数有关技术采访通过的文章的评论。 通常，主要的论点是，以一种或另一种方式使用的所有东西都已经被实施了十次，并且这位普通程序员不太可能必须处理。 好吧，在某种程度上这是事实。 但是，事实证明，并不是所有的事情都得到了实现，不幸的是（或者幸运的是，我）仍然必须创建一个数据结构。 </p><br><p> 神秘修饰的默克尔·帕特里夏·特里。 </p><br><p> 由于在哈勃尔树上以及在媒介上根本没有关于这棵树的信息-还有一点，我想告诉你它是哪种动物，以及它是怎么吃的。 </p><br><p><img src="https://habrastorage.org/webt/mc/ar/6q/mcar6qnrhs1vh6noextlta_dpfo.png" alt="KDPV"></p><a name="habracut"></a><br><h2 id="chto-eto"> 这是什么 </h2><br><p>  <em>免责声明：对我来说，实施的主要信息来源是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">黄皮书</a> ，以及源代码<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">parity-ethereum</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">go-ethereum</a> 。</em>  <em>关于某些决定的合理性的理论信息很少，因此，做出某些决定的原因的所有结论都是我个人的。</em>  <em>万一我在某件事上弄错了，我会很高兴在评论中更正。</em> </p><br><p>  <em>树</em>是作为连接的非循环图的数据结构。 这里的一切都很简单，每个人都对此很熟悉。 </p><br><p>  <em>前缀树</em>是根树，可以在其中存储键-值对，这是因为节点分为两种类型：包含路径一部分（前缀）的节点和包含存储值的叶节点。 当且仅当使用键，我们可以从树的根部一直走到最后找到一个具有值的节点时，树中才会存在一个值。 </p><br><p>  <em>PATRICIA树</em>是一个前缀树，其中的前缀是二进制的-也就是说，每个关键节点都存储有关一位的信息。 </p><br><p>  <em>Merkle</em>树是基于某种数据链构建的哈希树，将这些相同的哈希表聚合为一个（根），存储有关所有数据块状态的信息。 也就是说，根哈希是一种区块链状态的“数字签名”。 这个东西在区块链中被积极使用，更多信息可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到。 </p><br><p><img src="https://habrastorage.org/webt/ui/x4/nr/uix4nregm5i_dcxm5cgxsv27hjg.png" alt="努力是..."></p><br><p> 总计：修改过的Merkle Patricia Trie（以下简称MPT）是一种散列树，用于存储键值对，并且键以二进制形式表示。 到底是“修改”的内容，我们在稍后讨论实现时会发现一点。 </p><br><h2 id="zachem-eto"> 怎么会这样 </h2><br><p> 在以太坊项目中使用MPT来存储有关帐户，交易，其执行结果以及系统功能所需的其他数据的数据。 <br> 不像比特币那样，状态是隐式的，并且是由每个节点独立计算的，每个账户的余额（以及与之关联的数据）直接存储在空中的区块链上。 此外，必须以密码方式提供数据的位置和不变性-很少有人会使用其中无需客观原因即可更改随机账户余额的加密货币。 </p><br><p> 以太坊开发人员面临的主要问题是创建一个数据结构，该结构可以有效地存储键值对，同时提供对所存储数据的验证。 于是MPT出现了。 </p><br><h2 id="kak-eto"> 怎么了 </h2><br><p>  MPT是前缀PATRICIA树，其中的键是字节序列。 </p><br><p> 这棵树的边缘是半字节序列（半字节）。 因此，一个节点最多可具有十六个后代（对应于从0x0到0xF的分支）。 </p><br><p> 节点分为3种类型： </p><br><ul><li> 分支节点。 用于分支的节点。 最多包含1到16个到子节点的链接。 也可能包含一个值。 </li><li> 扩展节点。 一个辅助节点，存储一些子节点共有的路径的某些部分，以及位于下面的分支节点的链接。 </li><li> 叶节点。 包含路径的一部分和存储值的节点。 这是链中的终点。 </li></ul><br><p>如前所述，MPT建立在另一个kv存储库的顶部，该存储库以“链接” =&gt;“ <code>RLP</code>编码节点”的形式存储节点。 </p><br><p>  <em>在这里，我们提出了一个新概念：RLP。</em>  <em>简而言之，这是一种对表示列表或字节序列的数据进行编码的方法。</em>  <em>示例： <code>[ "cat", "dog" ] = [ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]</code> 。</em>  <em>我不会特别详细，在实现中，我将使用现成的库，因为对该主题的覆盖也会使本来已经很大的文章充实。</em>  <em>如果您仍然感兴趣，可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读更多内容。</em>  <em>我们将自己限制在可以在<code>RLP</code>编码数据并将其解码回来的事实。</em> </p><br><p> 到节点的链接定义如下：如果<code>RLP</code>编码节点的长度为32个字节或更多字节，则该链接是该节点的<code>RLP</code>表示形式的<code>keccak</code>哈希。 如果长度小于32个字节，则链接是节点本身的<code>RLP</code>表示形式。 </p><br><p> 显然，在第二种情况下，无需将节点保存到数据库，因为 它将完全保存在父节点中。 </p><br><p><img src="https://habrastorage.org/webt/rs/vz/0j/rsvz0j-fmp0f3p35phzmkxzbzlw.png" alt="官员不同"></p><br><p> 三种类型的节点的组合使您可以在键很少的情况下有效地存储数据（然后大多数路径将存储在扩展节点和叶节点中，并且分支节点将很少），并且在节点很多的情况下（路径将不会显式存储）但它们会在通过分支节点的过程中“聚集”。 </p><br><p> 使用各种节点的树的完整示例： </p><br><p><img src="https://habrastorage.org/webt/tm/8y/_p/tm8y_p43ggyutxiw5a7murovrpa.png" alt="树已满但不厚"></p><br><p> 您可能已经注意到，路径的存储部分带有前缀。 出于多种目的需要前缀： </p><br><ol><li> 区分扩展节点和叶节点。 </li><li> 对齐奇数个半字节的序列。 </li></ol><br><p> 创建前缀的规则非常简单： </p><br><ul><li> 前缀占用1个半字节。 如果路径长度（不包括前缀）为奇数，则路径在前缀之后立即开始。 如果路径长度是偶数，要在前缀后对齐，请先添加半字节0x0。 </li><li> 前缀初始为0x0。 </li><li> 如果路径长度为奇数，则将0x1添加到前缀（即使为-0x0）。 </li><li> 如果路径通向叶节点，则将0x2添加到前缀，如果将0x0添加到Extension节点。 </li></ul><br><p> 我认为在Beatiks上会更清楚： </p><br><pre> <code class="plaintext hljs">0b0000 =&gt;  , Extension  0b0001 =&gt;  , Extension  0b0010 =&gt;  , Leaf  0b0011 =&gt;  , Leaf </code> </pre> <br><h3 id="udalenie-kotoroe-ne-udalenie"> 去除不是去除 </h3><br><p> 尽管树具有删除节点的功能，但实际上，一旦添加的所有内容将永远保留在树中。 </p><br><p> 为了不为每个块创建完整的树，而是仅存储树的新旧版本之间的差异，这是必需的。 </p><br><p> 因此，使用不同的根哈希作为入口点，我们可以获得树曾经处于的任何状态。 </p><br><p><img src="https://habrastorage.org/webt/lv/-e/mr/lv-emrvfxac4ccdfi38ps6ajvfs.png" alt="用笔写的是什么..."></p><br><p> 这些并不是全部优化。 还有更多，但我们不再赘述-因此文章很大。 但是，您可以自己<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">阅读</a> 。 </p><br><h2 id="realizaciya"> 实作 </h2><br><p> 理论已经结束，让我们继续实践。 我们将使用来自IT领域的lingua franca，即<code>python</code> 。 </p><br><p> 由于将有很多代码，并且对于本文的格式，将不得不减少和划分很多工作，我将立即留下指向<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a>的链接。 <br> 如有必要，您可以在那里看到整个图片。 </p><br><p> 首先，我们定义要作为结果的树接口： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, storage, root=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key, encoded_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p> 界面非常简单。 可用的操作包括获取，删除，插入和更改（与更新结合），以及获取根哈希。 </p><br><p> 存储将被转移到<code>__init__</code>方法-一种类似<code>dict</code>的数据结构，我们将在其中存储节点以及<code>root</code> -树的“顶部”。 如果<code>None</code>作为<code>root</code>传递，我们假定树为空，并且从头开始工作。 </p><br><p>  _Remark：您可能想知道为什么方法中的变量被命名为<code>encoded_key</code>和<code>encoded_value</code> ，而不仅仅是<code>key</code> / <code>value</code> 。 答案很简单：根据规范，所有键和值都必须以<code>RLP</code>编码。 我们不会为此烦恼，而将这一职业留给图书馆用户。 </p><br><p> 但是，在我们开始实现树本身之前，必须完成两个重要的工作： </p><br><ol><li> 实现<code>NibblePath</code>类，该类是<code>NibblePath</code>半字节，以免对其进行手动编码。 </li><li> 在此类的框架内实现<code>Node</code>类<code>Extension</code> ， <code>Leaf</code>和<code>Branch</code> 。 </li></ol><br><h3 id="nibblepath"> 半路 </h3><br><p> 因此， <code>NibblePath</code> 。 由于我们将在树上四处移动，因此我们班级功能的基础应该是能够从路径的开头设置“偏移”，以及接收特定的半字节。 知道了这一点，我们定义了类的基础（以及下面用于处理前缀的几个有用的常量）： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NibblePath</span></span></span><span class="hljs-class">:</span></span> ODD_FLAG = <span class="hljs-number"><span class="hljs-number">0x10</span></span> LEAF_FLAG = <span class="hljs-number"><span class="hljs-number">0x20</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, data, offset=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self._data = data <span class="hljs-comment"><span class="hljs-comment"># ,   . self._offset = offset #      def consume(self, amount): # "" N      . self._offset += amount return self def at(self, idx): #      idx = idx + self._offset #    ,   ,    , #   ,    -      . byte_idx = idx // 2 nibble_idx = idx % 2 #   . byte = self._data[byte_idx] #      . nibble = byte &gt;&gt; 4 if nibble_idx == 0 else byte &amp; 0x0F return nibble</span></span></code> </pre> <br><p> 很简单，不是吗？ </p><br><p> 仍然仅编写用于对半字节序列进行编码和解码的功能。 </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NibblePath</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def decode_with_type(data): #   : # ,     ,    . is_odd_len = data[0] &amp; NibblePath.ODD_FLAG == NibblePath.ODD_FLAG is_leaf = data[0] &amp; NibblePath.LEAF_FLAG == NibblePath.LEAF_FLAG #    ,     #    . offset  , #       "" . offset = 1 if is_odd_len else 2 return NibblePath(data, offset), is_leaf def encode(self, is_leaf): output = [] #    ,       . nibbles_len = len(self._data) * 2 - self._offset is_odd = nibbles_len % 2 == 1 #  . prefix = 0x00 #    ,    . #      (self.at(0))     . #           (0x0). prefix += self.ODD_FLAG + self.at(0) if is_odd else 0x00 #  ,  Leaf node,  . prefix += self.LEAF_FLAG if is_leaf else 0x00 output.append(prefix) # ,      ,  . pos = nibbles_len % 2 #          , #     2 ,    , #     , #    . while pos &lt; nibbles_len: byte = self.at(pos) * 16 + self.at(pos + 1) output.append(byte) pos += 2 return bytes(output)</span></span></code> </pre> <br><p> 原则上，这是方便进行轻咬的最低要求。 当然，在当前的实现中，仍然存在许多辅助方法（例如<code>combine</code> ，将两条路径合并为一个），但是它们的实现非常简单。 如果有兴趣，可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到完整版本。 </p><br><h3 id="node"> 结点 </h3><br><p> 众所周知，我们的节点分为三种类型：叶子，扩展和分支。 所有这些都可以进行编码和解码，唯一的区别是存储在内部的数据。 老实说，这就是要求的代数数据类型，例如，在<code>Rust</code> ，我本着一种精神写了一些东西： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { Leaf(NibblesSlice&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]), Extension(NibblesSlice&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, NodeReference), Branch([<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;NodeReference&gt;; <span class="hljs-number"><span class="hljs-number">16</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]&gt;), }</code> </pre> <br><p> 但是，python中没有这样的ADT，因此我们将定义<code>Node</code>类，并且在其中有三个与节点类型相对应的类。 我们直接在节点类中实现编码，并在<code>Node</code>类中实现解码。 </p><br><p> 但是，实现是基本的： </p><br><p> 叶： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Leaf</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, data)</span></span></span><span class="hljs-function">:</span></span> self.path = path self.data = data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    , #   -  ,   -  . return rlp.encode([self.path.encode(True), self.data])</span></span></code> </pre> <br><p> 扩展名： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Extension</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, next_ref)</span></span></span><span class="hljs-function">:</span></span> self.path = path self.next_ref = next_ref <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    , #   -  ,   -    . next_ref = _prepare_reference_for_encoding(self.next_ref) return rlp.encode([self.path.encode(False), next_ref])</span></span></code> </pre> <br><p> 分行： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Branch</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, branches, data=None)</span></span></span><span class="hljs-function">:</span></span> self.branches = branches self.data = data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    ,  #  16 -     (  ), #   -   (  ). branches = list(map(_prepare_reference_for_encoding, self.branches)) return rlp.encode(branches + [self.data])</span></span></code> </pre> <br><p> 一切都非常简单。 唯一可能引起问题的是<code>_prepare_reference_for_encoding</code>函数。 </p><br><p>  <em>然后我承认，我不得不使用一个小拐杖。</em>  <em>事实是，所<code>rlp</code>的<code>rlp</code>库以递归方式解码数据，并且众所周知，到另一个节点的链接可以是<code>rlp</code>数据（如果编码节点的长度少于32个字符）。</em>  <em>使用两种格式的链接（哈希字节和解码的节点）非常不方便。</em>  <em>因此，我编写了两个函数，这些函数在解码节点之后以字节格式返回链接，并在保存之前根据需要对其进行解码。</em>  <em>这些功能是：</em> </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_prepare_reference_for_encoding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    ( ,   ) --  . #       :) if 0 &lt; len(ref) &lt; 32: return rlp.decode(ref) return ref def _prepare_reference_for_usage(ref): #     -   . #          . if isinstance(ref, list): return rlp.encode(ref) return ref</span></span></code> </pre> <br><p> 通过编写<code>Node</code>类来完成节点。 其中只有2种方法：解码节点并将该节点转换为链接。 </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># class Leaf(...) # class Extension(...) # class Branch(...) def decode(encoded_data): data = rlp.decode(encoded_data) # 17  -  Branch . if len(data) == 17: branches = list(map(_prepare_reference_for_usage, data[:16])) node_data = data[16] return Node.Branch(branches, node_data) #    17,   2.   - . #      ,     . path, is_leaf = NibblePath.decode_with_type(data[0]) if is_leaf: return Node.Leaf(path, data[1]) else: ref = _prepare_reference_for_usage(data[1]) return Node.Extension(path, ref) def into_reference(node): #    . #      32 , #   -   . #       . encoded_node = node.encode() if len(encoded_node) &lt; 32: return encoded_node else: return keccak_hash(encoded_node)</span></span></code> </pre> <br><h2 id="pereryv"> 休息一下 </h2><br><p>  ！ 有很多信息。 我认为是时候放松一下了。 这是另一只为您服务的猫： </p><br><p><img src="https://habrastorage.org/webt/cn/qu/jt/cnqujtdcxdavek8wvwghernczvk.png" alt="你可以在休息时间吃点东西"></p><br><p> 米洛塔，对不对？ 好，回到我们的树上。 </p><br><h2 id="merklepatriciatrie"> 默克尔·帕特里夏·特里 </h2><br><p> 华友世纪-辅助元素已经准备好，我们传递给最美味的。 以防万一，我会提醒我们树的界面。 同时，我们实现了<code>__init__</code>方法。 </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, storage, root=None)</span></span></span><span class="hljs-function">:</span></span> self._storage = storage self._root = root <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key, encoded_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p> 但是，对于其余方法，我们将一一处理。 </p><br><h3 id="get"> 得到 </h3><br><p>  <code>get</code>方法（原则上与其他方法一样）将由两部分组成。 该方法本身将准备数据并将结果带入预期的形式，而实际工作将在辅助方法内部进行。 </p><br><p> 基本方法非常简单： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def get(self, encoded_key): if not self._root: raise KeyError path = NibblePath(encoded_key) #       #  ,    ,    . result_node = self._get(self._root, path) if type(result_node) is Node.Extension or len(result_node.data) == 0: raise KeyError return result_node.data</span></span></code> </pre> <br><p> 但是， <code>_get</code>并不复杂：为了到达所需的节点，我们需要从根目录转到整个提供的路径。 如果最后我们找到一个包含数据的节点（叶或分支）-欢呼声，则接收到数据。 如果无法通过，则树中缺少必需的密钥。 </p><br><p> 实现方式： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def _get(self, node_ref, path): #      . node = self._get_node(node_ref) #    --   . #   ,      . if len(path) == 0: return node if type(node) is Node.Leaf: #     Leaf-,     , #      . if node.path == path: return node elif type(node) is Node.Extension: #    -- Extension,    . if path.starts_with(node.path): rest_path = path.consume(len(node.path)) return self._get(node.next_ref, rest_path) elif type(node) is Node.Branch: #    -- Branch,     . #   ,           #  :      . branch = node.branches[path.at(0)] if len(branch) &gt; 0: return self._get(branch, path.consume(1)) #    ,        , #     . raise KeyError</span></span></code> </pre> <br><p> 好吧，与此同时，我们将编写用于保存和加载节点的方法。 它们很简单： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def _get_node(self, node_ref): raw_node = None if len(node_ref) == 32: raw_node = self._storage[node_ref] else: raw_node = node_ref return Node.decode(raw_node) def _store_node(self, node): reference = Node.into_reference(node) if len(reference) == 32: self._storage[reference] = node.encode() return reference</span></span></code> </pre> <br><h3 id="update"> 更新 </h3><br><p>  <code>update</code>方法已经更加有趣了。 只需进行最后操作，然后插入“叶子”节点就不会总是成功。 密钥分离点可能在已保存的Leaf或Extension节点内的某个位置。 在这种情况下，您必须将它们分开并创建几个新节点。 </p><br><p> 通常，所有逻辑都可以通过以下规则描述： </p><br><ol><li> 当路径与现有节点完全重合时，我们递归地下降树。 </li><li> 如果路径已完成，并且我们位于“分支”或“叶子”节点中，则意味着<code>update</code>只会更新与此键对应的值。 </li><li> 如果路径被分割（也就是说，我们不更新值，而是插入一个新值），并且位于“分支”节点中-创建一个“叶子”节点并在相应的分支“分支”分支中指定指向该节点的链接。 </li><li> 如果路径被划分并且位于“叶子”或“扩展”节点中，则需要创建一个“分支”节点来分隔路径，并在必要时创建用于路径公共部分的“扩展”节点。 </li></ol><br><p> 让我们逐步用代码表达这一点。 为什么逐渐？ 由于该方法很大，因此很难全面理解它。 <br> 但是，我将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>保留完整方法的链接。 </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def update(self, encoded_key, encoded_value): path = NibblePath(encoded_key) result = self._update(self._root, path, encoded_value) self._root = result def _update(self, node_ref, path, value): #       (,   ), #       . if not node_ref: return self._store_node(Node.Leaf(path, value)) #          #    . node = self._get_node(node_ref) if type(node) == Node.Leaf: ... elif type(node) == Node.Extension: ... elif type(node) == Node.Branch: ...</span></span></code> </pre> <br><p> 通用逻辑不够多，最有趣的是<code>if</code> s内部。 </p><br><h5 id="if-typenode--nodeleaf"> <code>if type(node) == Node.Leaf</code> </h5> <br><p> 首先，让我们处理Leaf节点。 它们只有两种情况： </p><br><ol><li><p> 我们遵循的其余路径与“叶子”节点中存储的路径完全相同。 在这种情况下，我们只需要更改值，保存新节点并返回指向它的链接即可。 </p><br></li><li><p> 路径是不同的。 <br> 在这种情况下，您需要创建一个将两个路径分开的分支节点。 <br> 如果路径之一为空，则其值将直接传输到分支节点。 <br> 否则，我们将必须创建两个Leaf节点，这些节点的长度缩短了路径的公共部分的长度+ 1个半字节（此半字节将由Branch节点相应分支的索引指示）。 </p><br></li></ol><br><p> 您还需要检查路径中是否存在公共部分，以了解我们是否也需要创建一个扩展节点。 </p><br><p> 在代码中，它将如下所示： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(node) == Node.Leaf: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.path == path: <span class="hljs-comment"><span class="hljs-comment">#  .       . node.data = value return self._store_node(node) #    . #    . common_prefix = path.common_prefix(node.path) #      . path.consume(len(common_prefix)) node.path.consume(len(common_prefix)) #  Branch . branch_reference = self._create_branch_node(path, value, node.path, node.data) # ,    Extension-. if len(common_prefix) != 0: return self._store_node(Node.Extension(common_prefix, branch_reference)) else: return branch_reference</span></span></code> </pre> <br><p>  <code>_create_branch_node</code>过程如下： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_create_branch_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path_a, value_a, path_b, value_b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    Branch-. branches = [b''] * 16 # ,     Branch- . branch_value = b'' if len(path_a) == 0: branch_value = value_a elif len(path_b) == 0: branch_value = value_b #    Leaf-,  . self._create_branch_leaf(path_a, value_a, branches) self._create_branch_leaf(path_b, value_b, branches) #  Branch-     . return self._store_node(Node.Branch(branches, branch_value)) def _create_branch_leaf(self, path, value, branches): # ,     Leaf-. if len(path) &gt; 0: #    ( ). idx = path.at(0) #  Leaf-   ,     . leaf_ref = self._store_node(Node.Leaf(path.consume(1), value)) branches[idx] = leaf_ref</span></span></code> </pre> <br><h5 id="if-typenode--nodeextension"> <code>if type(node) == Node.Extension</code> </h5> <br><p> 在扩展节点的情况下，所有内容看起来都像叶子节点。 </p><br><ol><li><p> 如果来自“扩展”节点的路径是我们路径的前缀，那么我们只需递归继续。 </p><br></li><li><p> 否则，如上所述，我们需要使用Branch节点进行分离。 </p><br></li></ol><br><p> 因此，代码： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Extension: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.starts_with(node.path): <span class="hljs-comment"><span class="hljs-comment">#         . new_reference = \ self._update(node.next_ref, path.consume(len(node.path)), value) return self._store_node(Node.Extension(node.path, new_reference)) #  Extension-. #     . common_prefix = path.common_prefix(node.path) #  . path.consume(len(common_prefix)) node.path.consume(len(common_prefix)) #  Branch- ,  ,    . branches = [b''] * 16 branch_value = value if len(path) == 0 else b'' #     Leaf-  Extension- . self._create_branch_leaf(path, value, branches) self._create_branch_extension(node.path, node.next_ref, branches) branch_reference = self._store_node(Node.Branch(branches, branch_value)) # ,    Extension-. if len(common_prefix) != 0: return self._store_node(Node.Extension(common_prefix, branch_reference)) else: return branch_reference</span></span></code> </pre> <br><p>  <code>_create_branch_extension</code>过程<code>_create_branch_extension</code>逻辑上等效于<code>_create_branch_leaf</code>过程，但可与扩展节点一起使用。 </p><br><h5 id="if-typenode--nodebranch"> <code>if type(node) == Node.Branch</code> </h5> <br><p> 但是对于分支节点，一切都很简单。 如果路径为空，则只需将新值保存在当前“分支”节点中。 如果路径不为空，则我们从该路径“咬住”一个半字节，然后递归地向下移动。 </p><br><p> 我认为该代码不需要注释。 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Branch: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._store_node(Node.Branch(node.branches, value)) idx = path.at(<span class="hljs-number"><span class="hljs-number">0</span></span>) new_reference = self._update(node.branches[idx], path.consume(<span class="hljs-number"><span class="hljs-number">1</span></span>), value) node.branches[idx] = new_reference <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._store_node(node)</code> </pre> <br><h3 id="delete"> 删除 </h3><br><p>  ！ 最后一种方法仍然存在。 他是最开朗的。 删除的复杂性在于，如果我们完成了整个<code>update</code>链（不包括已删除的键），则需要将结构返回到该结构所处的状态。 </p><br><p>   ,       ,     ,      ,    .   "",   ,      . </p><br><p>         .  ,   N-        ,    N+1 .      enum — <code>DeleteAction</code> ,    . </p><br><p>    <code>delete</code>   : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... # Enum, ,         . class _DeleteAction(Enum): #    . #     , #        (_DeleteAction, None). DELETED = 1, #    (,    ). #     ,    #    : (_DeleteAction, ___). UPDATED = 2, #    Branch-  .   -- #    : # (_DeleteAction, (___, ___)) USELESS_BRANCH = 3 def delete(self, encoded_key): if self._root is None: return path = NibblePath(encoded_key) action, info = self._delete(self._root, path) if action == MerklePatriciaTrie._DeleteAction.DELETED: #   . self._root = None elif action == MerklePatriciaTrie._DeleteAction.UPDATED: #   . new_root = info self._root = new_root elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #   . _, new_root = info self._root = new_root def _delete(self, node_ref, path): node = self._get_node(node_ref) if type(node) == Node.Leaf: pass elif type(node) == Node.Extension: pass elif type(node) == Node.Branch: pass</span></span></code> </pre> <br><p>      ,      <code>get</code>  <code>update</code> .     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . </p><br><h4 id="if-typenode--nodeleaf-1"> <code>if type(node) == Node.Leaf</code> </h4> <br><p>   .     .      —     ,     ,   . </p><br><p>  : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(node) == Node.Leaf: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path == node.path: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MerklePatriciaTrie._DeleteAction.DELETED, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError</code> </pre> <br><p>    ,  "" —    .       ,      .              . </p><br><h4 id="if-typenode--nodeextension-1"> <code>if type(node) == Node.Extension</code> </h4> <br><p> C Extension-   : </p><br><ol><li>  ,     Extension-      .   —    . </li><li>   <code>_delete</code> , ""   . </li><li>    .  : </li></ol><br><ul><li>    .         . </li><li>    .      . </li><li>      Branch-.          .      ,  Branch-   .      ,   ,    Leaf-.    —   Extension-. </li></ul><br><p>     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Extension: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> path.starts_with(node.path): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError <span class="hljs-comment"><span class="hljs-comment">#   . #       . action, info = self._delete(node.next_ref, path.consume(len(node.path))) if action == MerklePatriciaTrie._DeleteAction.DELETED: return action, None elif action == MerklePatriciaTrie._DeleteAction.UPDATED: #    ,     . child_ref = info new_ref = self._store_node(Node.Extension(node.path, child_ref)) return action, new_ref elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #     Branch-. stored_path, stored_ref = info # ,     Branch-. child = self._get_node(stored_ref) new_node = None if type(child) == Node.Leaf: #  branch-  . #     Leaf-  Extension. path = NibblePath.combine(node.path, child.path) new_node = Node.Leaf(path, child.data) elif type(child) == Node.Extension: #  Branch-  Extension-. #       . path = NibblePath.combine(node.path, child.path) new_node = Node.Extension(path, child.next_ref) elif type(child) == Node.Branch: #  Branch-      Branch-. #    Extension-    . path = NibblePath.combine(node.path, stored_path) new_node = Node.Extension(path, stored_ref) new_reference = self._store_node(new_node) return MerklePatriciaTrie._DeleteAction.UPDATED, new_reference</span></span></code> </pre> <br><h4 id="if-typenode--nodebranch-1"> <code>if type(node) == Node.Branch</code> </h4> <br><p>   . </p><br><p> , .    Branch-,     … </p><br><p> 怎么了   Branch-      Leaf- ( )     Extension- (    ). <br> ,        .      ,    —     Leaf-.          —      Extension-.         ,    ,    2   —  Branch-   . </p><br><p>     ?  : </p><br><p>    : </p><br><ol><li>    ,   . </li><li>    ,  <code>_delete</code>   . </li></ol><br><p>      : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Branch: action = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> idx = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> info = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) != <span class="hljs-number"><span class="hljs-number">0</span></span>: node.data = <span class="hljs-string"><span class="hljs-string">b''</span></span> action = MerklePatriciaTrie._DeleteAction.DELETED <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-comment"><span class="hljs-comment">#   ,    . #    . idx = path.at(0) if len(node.branches[idx]) == 0: raise KeyError action, info = self._delete(node.branches[idx], path.consume(1)) #  ,   ,  . #      -    #    . node.branches[idx] = b''</span></span></code> </pre> <br><p>     <code>_DeleteAction</code>       . </p><br><ol><li>       Branch-  ,      (    ,   ).            . </li></ol><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == MerklePatriciaTrie._DeleteAction.UPDATED: <span class="hljs-comment"><span class="hljs-comment">#   . next_ref = info node.branches[idx] = next_ref reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #    . _, next_ref = info node.branches[idx] = next_ref reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference</span></span></code> </pre> <br><ol><li>     ( ,  ),   ,      . </li></ol><br><p>      .  : </p><br><ul><li>       .  ,   ,    ,       .  ,  . </li><li>   ,   .   Leaf-   .      . </li><li>  ,   .    ,   ,      . </li><li>   , ,  Branch-   .    ,  <code>_DeleteAction</code> — <code>UPDATED</code> . </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == MerklePatriciaTrie._DeleteAction.DELETED: non_empty_count = sum(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(x) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, node.branches)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> non_empty_count == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Branch- ,  . return MerklePatriciaTrie._DeleteAction.DELETED, None elif non_empty_count == 0 and len(node.data) != 0: #  ,   . path = NibblePath([]) reference = self._store_node(Node.Leaf(path, node.data)) return MerklePatriciaTrie._DeleteAction.USELESS_BRANCH, (path, reference) elif non_empty_count == 1 and len(node.data) == 0: #  ,   . return self._build_new_node_from_last_branch(node.branches) else: #  1+   ,  2+ . # Branch-  ,   - UPDATED. reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference</span></span></code> </pre> <br><p>  <code>_build_new_node_from_last_branch</code>           . </p><br><p>    — Leaf  Extension,           ,   . </p><br><p>     — Branch,      Extension ,        ,      Branch. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_build_new_node_from_last_branch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, branches)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    . idx = 0 for i in range(len(branches)): if len(branches[i]) &gt; 0: idx = i break #     . prefix_nibble = NibblePath([idx], offset=1) #     child = self._get_node(branches[idx]) path = None node = None #   . if type(child) == Node.Leaf: path = NibblePath.combine(prefix_nibble, child.path) node = Node.Leaf(path, child.data) elif type(child) == Node.Extension: path = NibblePath.combine(prefix_nibble, child.path) node = Node.Extension(path, child.next_ref) elif type(child) == Node.Branch: path = prefix_nibble node = Node.Extension(path, branches[idx]) #  . reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.USELESS_BRANCH, (path, reference)</span></span></code> </pre> <br><h3 id="ostalnoe"> 其余的 </h3><br><p>      .  , …    <code>root</code> . </p><br><p> 在这里： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def root(self): return self._root</span></span></code> </pre> <br><p>   ,   . </p><br><p>  …  .  ,   ,      Ethereum         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . ,   , ,   .      ,    :) </p><br><p> ,      ,    <code>pip install -U eth_mpt</code> —  . </p><br><p><img src="https://habrastorage.org/webt/qm/wo/fx/qmwofx6jaxe_0t50akn0sdnt-0m.png" alt="所有人！"></p><br><h2 id="rezultaty"> 结果 </h2><br><p>      ? </p><br><p> , -,      ,  -       ,      ,   .    —  ,       . </p><br><p> -,   ,  ,            — .  ,        skip list  interval tree,     — , , . </p><br><p> -,     ,            .   ,           -  . </p><br><p> -,     —   . </p><br><p>   ,  ,        —    ! </p><br><h2 id="arty">  </h2><br><p>      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3</a> .   !    ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446558/">https://habr.com/ru/post/zh-CN446558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446546/index.html">Microsoft通过Azure IoT创新者和初创公司的新IP优势扩展了Azure IP优势</a></li>
<li><a href="../zh-CN446548/index.html">分析广告活动的统计信息-在DataFrame中创建一个新指标（python）</a></li>
<li><a href="../zh-CN446550/index.html">协调器模式问题以及RouteComposer与它有什么关系</a></li>
<li><a href="../zh-CN446552/index.html">使用示例EToken处理APDU命令</a></li>
<li><a href="../zh-CN446554/index.html">Yandex居民计划，或如何使经验丰富的后端成为ML工程师</a></li>
<li><a href="../zh-CN446560/index.html">“礼貌交流”：两家最著名的流媒体公司之间冲突的实质</a></li>
<li><a href="../zh-CN446562/index.html">编程异步</a></li>
<li><a href="../zh-CN446566/index.html">零项目。 亚马逊如何应对假货</a></li>
<li><a href="../zh-CN446568/index.html">Umbraco 8大规模CMS更新：新功能</a></li>
<li><a href="../zh-CN446570/index.html">第一个GPU的故事：RenditionVérité1000</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>