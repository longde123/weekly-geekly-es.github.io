<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöØ üëºüèø üöÜ Pourquoi les gens n'utilisent-ils pas des m√©thodes formelles? üë®‚Äçüë©‚Äçüë¶ üë©üèø‚Äç‚öñÔ∏è üò≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au Software Engineering Stack Exchange, j'ai vu cette question : "Qu'est-ce qui emp√™che l'adoption g√©n√©ralis√©e des m√©thodes formelles?" La question a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourquoi les gens n'utilisent-ils pas des m√©thodes formelles?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437296/">  Au Software Engineering Stack Exchange, j'ai vu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette question</a> : "Qu'est-ce qui emp√™che l'adoption g√©n√©ralis√©e des m√©thodes formelles?"  La question a √©t√© ferm√©e car biais√©e, et la plupart des r√©ponses √©taient des commentaires comme ¬´Trop cher !!!¬ª  ou "Un site n'est pas un avion !!!"  D'une certaine mani√®re, c'est vrai, mais cela n'explique pas grand-chose.  J'ai √©crit cet article pour donner une image historique plus large des m√©thodes formelles (FM), pourquoi elles ne sont pas r√©ellement utilis√©es et ce que nous faisons pour corriger la situation. <br><br>  Avant de commencer, vous devez formuler certaines conditions.  En fait, il n'y a pas beaucoup de m√©thodes formelles: seulement <abbr title="TLA + est l'un des langages de sp√©cifications les plus populaires, et tous les experts TLA + s'adapteront √† un grand bus scolaire">quelques petits groupes</abbr> .  Cela signifie que diff√©rents groupes utilisent les termes diff√©remment.  D'une mani√®re g√©n√©rale, il existe deux groupes de m√©thodes formelles: la <b>sp√©cification formelle</b> √©tudie la r√©daction de sp√©cifications pr√©cises et non ambigu√´s, et la <b>v√©rification formelle</b> √©tudie les m√©thodes de preuve.  Cela inclut √† la fois le code et les syst√®mes abstraits.  Non seulement nous utilisons des termes diff√©rents pour le code et les syst√®mes, mais nous utilisons souvent diff√©rents outils pour les v√©rifier.  Pour rendre les choses encore plus confuses, si quelqu'un dit qu'il cr√©e une sp√©cification formelle, cela signifie <i>g√©n√©ralement une</i> v√©rification de la conception.  Et si quelqu'un dit qu'il fait une v√©rification formelle, cela <i>se</i> r√©f√®re <i>g√©n√©ralement</i> √† la v√©rification du code. <br><a name="habracut"></a><br>  Pour plus de clart√©, nous diviserons la v√©rification en v√©rification de <b>code</b> (CV) et <b>v√©rification de conception</b> (DV) et de la m√™me mani√®re divisons les sp√©cifications en CS et DS.  Ces termes ne sont pas couramment utilis√©s dans la vaste communaut√© FM.  Commen√ßons par CS et CV, puis passons √† DS et DV. <br><br>  De plus, <b>une v√©rification partielle</b> est possible, o√π seul un sous-ensemble de la sp√©cification est v√©rifi√©, ou <b>une v√©rification compl√®te</b> .  Cela peut √™tre la diff√©rence entre les preuves des all√©gations ¬´le syst√®me ne se bloque jamais et n'accepte pas le mauvais mot de passe¬ª ou ¬´le syst√®me ne se bloque jamais et ne verrouille pas le compte si vous entrez trois fois le mauvais mot de passe¬ª.  Fondamentalement, nous supposerons que nous effectuons une v√©rification compl√®te. <br><br>  Vous devez √©galement clarifier le type de logiciel que nous formalisons.  La plupart des gens identifient implicitement <b>des</b> programmes <b>hautement fiables</b> tels que les appareils m√©dicaux et les avions.  Les gens supposent que les m√©thodes formelles sont largement utilis√©es pour eux, mais elles ne sont pas n√©cessaires pour le reste.  C'est trop <i>optimiste</i> : la plupart des logiciels tr√®s fiables n'utilisent pas de m√©thodes formelles.  Au lieu de cela, nous nous concentrerons sur les logiciels ¬´ordinaires¬ª. <br><br>  Enfin, l'avertissement: je ne suis pas un historien professionnel, et bien que j'aie essay√© de v√©rifier soigneusement les informations, il peut y avoir des erreurs dans l'article.  De plus, je me sp√©cialise dans les sp√©cifications formelles (DS et DV), il y a donc plus de risques d'erreur lorsque je parle de v√©rification de code.  Si vous voyez, √©crivez-moi, je vais le r√©parer (et encore une chose: je gagne de l'argent gr√¢ce √† des s√©minaires sur TLA + et Alloy, donc je suis tr√®s partisan de ces langues; j'essaie d'√™tre aussi objectif que possible, mais vous comprenez: le parti pris est un parti pris). <br><br><h1>  Programmation formelle </h1><br><h2>  Obtenir des sp√©cifications </h2><br>  Avant de prouver l'exactitude du code, vous devez obtenir la norme de v√©rit√©.  Cela signifie une certaine <b>sp√©cification de</b> ce que le code doit faire.  Nous devons savoir avec certitude que le r√©sultat correspond √† la sp√©cification.  Il ne suffit pas de dire que la liste est ¬´tri√©e¬ª: nous ne savons pas ce que nous trions, quels crit√®res nous utilisons et m√™me ce que nous entendons par ¬´tri¬ª.  Au lieu de cela, nous pouvons dire: "La liste des entiers <code>l</code> <i>tri√©e par ordre croissant</i> pour deux indices i et j quelconques, si <code>i &lt; j</code> , alors <code>l[i] &lt;= l[j]</code> ." <br><br>  Les sp√©cifications du code sont divis√©es en trois types principaux: <br><br><ol><li>  La premi√®re consiste √† √©crire des instructions ind√©pendantes du code.  Nous √©crivons notre fonction de tri, et dans un fichier s√©par√© nous √©crivons le th√©or√®me ¬´cela retourne des listes tri√©es¬ª.  Il s'agit de la plus ancienne forme de sp√©cification, mais Isabelle et ACL2 fonctionnent toujours de cette fa√ßon (ML a √©t√© invent√© sp√©cifiquement pour aider √† r√©diger de telles sp√©cifications). <br></li><li>  Le second impl√©mente des sp√©cifications dans le code sous la forme de pr√© et postconditions, d√©clarations et invariants.  Vous pouvez ajouter une postcondition √† la fonction selon laquelle "la valeur de retour est une liste tri√©e".  Les sp√©cifications bas√©es sur les revendications ont √©t√© initialement formalis√©es dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la logique de Hoar</a> .  Ils sont apparus pour la premi√®re fois dans le langage de programmation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Euclid</a> au d√©but des ann√©es 1970 (on ne sait pas qui a commenc√© √† les utiliser: Euclid ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SPV</a> , mais pour autant que je sache, Euclid a √©t√© pr√©sent√© au public auparavant).  Ce style est √©galement appel√© <b>programmation par contrat</b> - la forme de v√©rification la plus populaire dans l'industrie moderne (ici, les contrats sont utilis√©s comme sp√©cifications de code). <br></li><li>  Enfin, il existe des syst√®mes de types.  Par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correspondance Curry - Howard,</a> tout th√©or√®me math√©matique ou preuve peut √™tre cod√© comme un type d√©pendant.  Nous allons d√©finir le type de listes tri√©es et d√©clarer le type <code>[Int] -&gt; Sorted [Int]</code> pour la fonction. </li></ol><br>  Sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Let's Prove Leftpad,</a> vous pouvez voir √† quoi cela ressemble.  HOL4 et Isabelle sont de bons exemples des sp√©cifications du ¬´th√©or√®me ind√©pendant¬ª, SPARK et Dafny sont les sp√©cifications de la ¬´d√©claration imbriqu√©e¬ª, et Coq et Agda sont le ¬´type d√©pendant¬ª. <br><br>  Si vous regardez attentivement, ces trois formes de sp√©cification de code sont compar√©es aux trois principaux domaines de la validation automatique: les tests, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contrats</a> et les types.  Ce n'est pas un hasard.  La correction est un large √©ventail, et la v√©rification formelle est l'un de ses extr√™mes.  √Ä mesure que la rigueur (et l'effort) de v√©rification diminue, nous obtenons des v√©rifications plus simples et plus √©troites, qu'il s'agisse de limiter l'espace d'√©tats √† l'√©tude, d'utiliser des types plus faibles ou de v√©rifier la force au moment de l'ex√©cution.  Ensuite, tout moyen de sp√©cification compl√®te se transforme en moyen de sp√©cification partielle, et vice versa: beaucoup consid√®rent la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">salle blanche</a> comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une</a> technique de v√©rification formelle, o√π une revue de code va bien au-del√† des capacit√©s humaines. <br><br><h3>  Quelles sp√©cifications sont correctes? </h3><br>  La v√©rification v√©rifie que le code est conforme √† la sp√©cification.  La question se pose: comment savoir si nous avons la bonne sp√©cification?  Trouver la bonne sp√©cification est l'un des plus gros probl√®mes des m√©thodes formelles.  C'est √©galement l'une des principales objections √† leur encontre.  Mais les sceptiques ici ne signifient pas <i>exactement</i> ce que les sp√©cialistes formels ont en t√™te. <br><br>  Lorsque des tiers demandent: ¬´Comment obtenir les bonnes sp√©cifications?¬ª Ils pensent <i>g√©n√©ralement</i> √† la <b>validation</b> , c'est-√†-dire aux sp√©cifications qui ne r√©pondent pas aux exigences du client.  Si vous prouvez formellement que votre code trie la liste et que le client veut r√©ellement Uber pour les soupes (tm), vous venez de passer une tonne de temps.  Par exemple, seules des it√©rations rapides et de courtes boucles de r√©troaction peuvent confirmer vos besoins. <br><br>  Il est vrai que la v√©rification du code ne le valide pas.  Mais il y a deux probl√®mes avec cet argument.  La premi√®re est que l'√©tape d'application des m√©thodes formelles est simplement report√©e, mais ne dispara√Æt pas compl√®tement.  Apr√®s toutes ces it√©rations rapides, vous avez probablement d√©j√† une id√©e de ce que veut le client.  Et <i>puis vous</i> commencez la v√©rification du code.  Deuxi√®mement, bien que nous ne sachions pas exactement ce que veut le client, nous pouvons supposer ce qu'il <i>ne</i> veut absolument <i>pas</i> .  Par exemple, pour bloquer accidentellement un logiciel.  Ils n'ont pas besoin de failles de s√©curit√©.  Tout le monde est d'accord avec cela: au final, personne ne dit que vous devez ignorer les tests unitaires pendant les it√©rations.  Assurez-vous au moins que votre syst√®me de contr√¥le de version ne supprime pas les donn√©es utilisateur al√©atoires (remarque: ne pensez pas que je suis aigri ou quelque chose comme √ßa). <br><br>  Le probl√®me de trouver la bonne sp√©cification est plus fondamental: <i>nous ne savons souvent pas quoi y √©crire</i> .  Nous pensons √† nos besoins en termes humains et non math√©matiques.  Si je dis: ¬´Le programme devrait distinguer les arbres des oiseaux¬ª, alors de quoi s'agit-il?  Je peux l'expliquer √† une personne en montrant un tas de photos d'arbres et d'oiseaux, mais ce ne sont que des exemples concrets, pas une description de l' <i>id√©e</i> .  En fait, pour traduire cela en une sp√©cification formelle, il est n√©cessaire de formaliser les concepts humains, et c'est un probl√®me s√©rieux. <br><br>  Ne vous m√©prenez pas.  Les sp√©cifications pertinentes peuvent √™tre d√©finies ici, et les experts le font tout le temps.  Mais la r√©daction des sp√©cifications appropri√©es est une comp√©tence qui doit √™tre d√©velopp√©e, ainsi que des comp√©tences en programmation.  C'est pourquoi de nombreux succ√®s r√©cents de la v√©rification de code s'expliquent par une mise en correspondance claire de ce que nous voulons et de ce que nous pouvons exprimer.  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CompCert</a> est un compilateur C officiellement v√©rifi√©. La sp√©cification est: ¬´Evitez les erreurs de compilation¬ª. <br><br>  Mais tout cela n'a rien √† voir avec la v√©rification.  Lorsque vous avez une sp√©cification, vous devez toujours prouver que le code la correspond. <br><br><h3>  Preuve de sp√©cification </h3><br>  Le tout premier outil de v√©rification de code est la m√©thode ¬´pensez √† pourquoi c'est vrai¬ª √† la mani√®re de Dijkstra, qui concerne principalement ALGOL.  Par exemple, je peux ¬´prouver¬ª l'exactitude du tri par la m√©thode d'insertion comme suit: <br><br><ol><li>  <i>L'option de base</i> : si vous ajoutez un √©l√©ment √† la liste vide, ce sera le seul √©l√©ment, il sera donc tri√©. <br></li><li>  Si nous avons une liste tri√©e avec k √©l√©ments et ajoutons un √©l√©ment, alors nous ins√©rons l'√©l√©ment de sorte qu'il soit apr√®s tous les plus petits nombres et avant tous les plus grands nombres.  Cela signifie que la liste est toujours tri√©e. <br></li><li>  Par induction, le tri par insertion triera la liste enti√®re. </li></ol><br>  √âvidemment, en r√©alit√©, la preuve para√Ætra plus rigoureuse, mais c'est une id√©e g√©n√©rale.  Dijkstra et d'autres ont utilis√© ce style pour prouver l'exactitude de nombreux algorithmes, y compris de nombreuses bases de la concurrence.  C‚Äôest aussi le style auquel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les mots de Knuth</a> sont associ√©s: ¬´M√©fiez-vous des erreurs dans ce code;  J'ai seulement prouv√© que c'√©tait correct, mais je n'ai pas commenc√©. "  Vous pouvez facilement ruiner une preuve math√©matique afin que personne ne le remarque.  Selon certaines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">estimations</a> , environ 20% des preuves math√©matiques publi√©es contiennent des erreurs.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20140630071239/">Peter Guttmann</a> a un excellent essai sur les preuves de la sant√© d'un programme ridicule, o√π des tonnes de code "test√©" tombent imm√©diatement si vous les ex√©cutez. <br><br>  Dans le m√™me temps, nous avons √©tudi√© les moyens de prouver automatiquement les th√©or√®mes math√©matiques.  Le premier <b>programme pour prouver les th√©or√®mes a</b> √©t√© publi√© en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1967</a> .  Au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©but des ann√©es 1970, de</a> tels programmes ont commenc√© √† √™tre utilis√©s pour tester le code Pascal, et au milieu de la d√©cennie, des langages formels sp√©ciaux sont apparus.  Le programmeur formule certaines propri√©t√©s du code, puis cr√©e une preuve v√©rifiable que le code poss√®de ces propri√©t√©s.  Les premiers programmes de d√©monstration de th√©or√®mes ont simplement aid√© les gens √† v√©rifier les preuves, tandis que des outils plus sophistiqu√©s pouvaient prouver ind√©pendamment des parties du th√©or√®me. <br><br>  Ce qui conduit au probl√®me suivant. <br><br><h3>  Les preuves sont difficiles √† obtenir </h3><br>  Les preuves sont difficiles et c'est un travail tr√®s m√©chant.  Il est difficile de quitter la programmation et d'aller au cirque.  √âtonnamment, les preuves de code formelles sont souvent plus strictes que les preuves √©crites par la plupart des math√©maticiens!  Les math√©matiques sont une activit√© tr√®s cr√©ative, o√π la r√©ponse au th√©or√®me n'est valable que si vous le montrez.  La cr√©ativit√© va mal avec le formalisme et les ordinateurs. <br><br>  Prenons le m√™me exemple de tri par insertion o√π nous avons appliqu√© l'induction.  Tout math√©maticien comprendra imm√©diatement ce qu'est l'induction, comment elle fonctionne en g√©n√©ral et comment elle fonctionne dans ce cas.  Mais dans le programme de d√©monstration des th√©or√®mes, tout doit √™tre strictement formalis√©.  Il en va de m√™me pour la preuve par contradiction, la preuve par contreposition, etc. De plus, toutes les hypoth√®ses doivent √™tre formalis√©es, m√™me celles o√π la plupart des math√©maticiens ne se soucient pas de la preuve.  Par exemple, <code>a + (b + c) = (a + b) + c</code> .  Le programme de v√©rification des th√©or√®mes a priori ne sait pas que cela est vrai.  Vous devez soit le prouver (dur), soit le d√©clarer comme vrai selon la loi associative d'addition (dangereux), soit acheter une biblioth√®que de th√©or√®mes √† quelqu'un qui a d√©j√† pu le prouver (cher).  Les premiers programmes de d√©monstration de th√©or√®mes rivalisaient dans le nombre de tactiques de preuve int√©gr√©es et de biblioth√®ques de th√©or√®mes connexes.  L'un des premiers programmes SPADE r√©pandus a pr√©sent√© la biblioth√®que arithm√©tique compl√®te comme le principal avantage. <br><br>  Ensuite, vous devez obtenir la preuve elle-m√™me.  Vous pouvez le confier au programme ou l'√©crire vous-m√™me.  Habituellement, la d√©finition automatique de la preuve n'est pas d√©cidable.  Pour les cas extr√™mement √©troits, tels que la logique propositionnelle ou la v√©rification de type HM, il est ¬´uniquement¬ª NP-complet.  En fait, nous √©crivons nous-m√™mes la plupart des preuves et l'ordinateur v√©rifie leur exactitude.  Cela signifie que vous devez bien conna√Ætre: <br><br><ul><li>  math√©matiques <br></li><li>  l'informatique; <br></li><li>  la zone dans laquelle vous travaillez: compilateurs, mat√©riel, etc.; <br></li><li>  les nuances de votre programme et de votre sp√©cialisation; <br></li><li>  les nuances du programme pour prouver les th√©or√®mes que vous utilisez, ce qui en soi est toute une sp√©cialit√©. </li></ul><br>  Pire, des b√¢tons sp√©cifiques √† l'ordinateur sont plac√©s dans des roues.  Rappelez-vous, j'ai dit qu'il √©tait dangereux de supposer une loi associative d'addition?  Certaines langues ne le respectent pas.  Par exemple, en C ++ <code>INT_MAX. ((-1) + INT_MAX) + 1</code>  <code>INT_MAX. ((-1) + INT_MAX) + 1</code> est <code>INT_MAX. -1 + (INT_MAX + 1)</code>  <code>INT_MAX. -1 + (INT_MAX + 1)</code> , qui est ind√©tectable.  En supposant un ajout associatif en C ++, votre preuve sera incorrecte et le code sera rompu.  Vous devez soit √©viter cette d√©claration, soit prouver qu'aucun d√©bordement ne se produira jamais pour votre fragment particulier. <br><br>  Vous pouvez dire que l'addition ind√©finie est une erreur, mais vous devez utiliser un langage avec des entiers ind√©pendants.  Mais la plupart des langues ont des caract√©ristiques sp√©cifiques qui interf√®rent avec les preuves.  Prenez le code suivant: <br><br><pre> <code class="plaintext hljs">a = true; b = false; f(a); assert a;</code> </pre> <br>  Est-ce toujours le cas?  Pas un fait.  Peut-√™tre que <code>f</code> changera <code>a</code> .  Peut-√™tre que cela changera le flux parall√®le.  Peut-√™tre que <code>b</code> attribuer un alias <code>a</code> , donc le changer changera √©galement <code>a</code> (note: les alias rendent si difficile d'√©crire des preuves que John C. Reynolds a d√ª cr√©er une toute nouvelle <b>logique de s√©paration</b> pour r√©soudre ce probl√®me).  Si quelque chose comme cela est possible dans votre langue, vous devez clairement prouver que cela ne se produit pas ici.  Le code propre aidera ici, dans un autre cas, il peut d√©truire la preuve, car il vous oblige √† utiliser la r√©cursivit√© et les fonctions d'un ordre sup√©rieur.  Soit dit en passant, les deux sont la base pour √©crire de bons programmes fonctionnels.  Ce qui est bon pour la programmation est mauvais pour la preuve!  (Remarque: dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette conf√©rence,</a> Edmund Clark a √©num√©r√© certaines des propri√©t√©s qui sont difficiles √† v√©rifier: ¬´virgules flottantes, cha√Ænes, types d√©finis par l'utilisateur, proc√©dures, simultan√©it√©, mod√®les universels, stockage, biblioth√®ques ...¬ª). <br><br>  Les v√©rificateurs formels ont un dilemme: plus le langage est expressif, plus il est difficile de prouver quelque chose.  Mais moins la langue est expressive, plus il est difficile d'√©crire dessus.  Les premiers langages formels de travail √©taient des sous-ensembles tr√®s limit√©s de langages plus expressifs: ACL2 √©tait un sous-ensemble de Lisp, Euclid √©tait un sous-ensemble de Pascal, etc. Et rien de ce que nous avons discut√© jusqu'√† pr√©sent ne prouve en fait de vrais programmes, ce ne sont que des tentatives d'approche √† la r√©daction de preuves. <br><br>  La preuve est difficile.  Mais √ßa devient plus facile.  Les chercheurs dans ce domaine ajoutent de nouvelles heuristiques, des biblioth√®ques de th√©or√®mes, des composants pr√©-test√©s, etc. Le progr√®s technique aide √©galement: plus les ordinateurs sont rapides, plus la recherche est rapide. <br><br><h3>  R√©volution SMT </h3><br>  L'une des innovations du milieu des ann√©es 2000 a √©t√© l'inclusion de solveurs SMT dans les programmes de d√©monstration des th√©or√®mes.  De mani√®re g√©n√©rale, un solveur SMT peut transformer (certains) th√©or√®mes math√©matiques en probl√®mes de conformit√© aux contraintes.  Cela transforme une t√¢che cr√©ative en une t√¢che informatique.  Vous devrez peut-√™tre encore lui fournir des probl√®mes interm√©diaires (lemmes) comme √©tapes du th√©or√®me, mais c'est mieux que de tout prouver vous-m√™me.  Les premiers solveurs SMT sont apparus vers 2004, d'abord comme projets acad√©miques.  Quelques ann√©es plus tard, Microsoft Research a publi√© le Z3, un solveur SMT complet.  Le gros avantage du Z3 √©tait qu'il devenait beaucoup plus pratique √† utiliser que les autres SMT, qui, franchement, ne disaient presque rien.  Microsoft Research l'a utilis√© en interne pour aider √† prouver les propri√©t√©s du noyau Windows, donc elles n'√©taient pas limit√©es √† une UX minimale. <br><br>  SMT a frapp√© la communaut√© FM √† bout de souffle car elle a soudainement rendu triviales de nombreuses preuves simples et lui a permis d'aborder des probl√®mes tr√®s complexes.  Ainsi, les gens pouvaient travailler dans des langues plus expressives, car maintenant les probl√®mes des d√©clarations expressives commen√ßaient √† √™tre r√©solus.  Des progr√®s incroyables sont √©vidents dans le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IronFleet</a> : en utilisant les meilleurs solveurs SMT et un langage de v√©rification avanc√©, Microsoft a pu √©crire 5 000 lignes de code Dafny √©prouv√© en seulement 3,7 ann√©es-hommes!  C'est un rythme incroyablement rapide: <i>jusqu'√† quatre lignes enti√®res par jour</i> (note: le pr√©c√©dent record appartenait √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">seL4</a> , dont les d√©veloppeurs √©crivaient <i>deux lignes par jour en C.</i> <br><br>  La preuve est difficile. <br><br><h3>  Pourquoi est-ce n√©cessaire? </h3><br>  Il est temps de prendre du recul et de demander: ¬´√Ä quoi √ßa sert?¬ª  Nous essayons de prouver que certains programmes r√©pondent √† certaines sp√©cifications.  La correction est une plage.  La v√©rification comporte deux parties: le degr√© de ¬´correction¬ª objective de votre programme et la pr√©cision avec laquelle vous avez v√©rifi√© l'exactitude.  De toute √©vidence, plus il est v√©rifi√©, mieux c'est, mais la v√©rification vaut le temps et l'argent.  Si nous avons plusieurs restrictions (performances, d√©lais de mise sur le march√©, co√ªt, etc.), une validation compl√®te n'est pas n√©cessairement la meilleure option.  Ensuite, la question se pose, quel est le contr√¥le minimum dont nous avons besoin et ce qu'il en co√ªte.  Dans la plupart des cas, par exemple, une exactitude de 90% ou 95% ou 99% vous suffit.  Peut-√™tre devriez-vous passer du temps √† am√©liorer l'interface, plut√¥t que de v√©rifier les 1% restants? <br><br>  Puis la question: "Un ch√®que de 90/95/99% est-il beaucoup moins cher que 100%?"  La r√©ponse est oui.  Il est assez confortable de dire que la base de code, que nous avons bien test√©e et typ√©e, <i>est fondamentalement</i> correcte, √† l'exception de quelques corrections en production, et nous √©crivons m√™me plus de quatre lignes de code par jour.  En fait, la grande majorit√© des dysfonctionnements dans les syst√®mes distribu√©s auraient pu √™tre √©vit√©s gr√¢ce √† des tests l√©g√®rement plus complets.  Et ce n'est qu'une extension des tests, sans parler du fuzzing, des tests bas√©s sur les propri√©t√©s ou des tests de mod√®les.  Vous pouvez obtenir un r√©sultat vraiment exceptionnel avec ces astuces simples sans avoir √† obtenir une preuve compl√®te. <br><br>  Que se passe-t-il si la saisie et les tests ne fournissent pas une v√©rification suffisante?  Il est encore plus facile de passer de 90% √† 99% que de 99% √† 100%.  Comme mentionn√© pr√©c√©demment, Cleanroom est une pratique de d√©veloppeur qui comprend une documentation compl√®te, une analyse approfondie des flux et des r√©visions de code approfondies.  Aucune preuve, aucune v√©rification formelle, pas m√™me des tests unitaires.  Mais une salle blanche correctement organis√©e r√©duit la densit√© des d√©fauts √† moins de 1 bogue pour 1000 lignes de code dans la production (note: les chiffres de l'√©tude Stavley dans <i>Toward Zero-Defect Programming</i> &gt; mais soyez toujours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sceptiques et v√©rifiez la source</a> ).  La programmation de Cleanroom ne ralentit pas le rythme de d√©veloppement, et va certainement plus vite que 4 lignes par jour.  Et Cleanroom lui-m√™me n'est qu'une des nombreuses m√©thodes de d√©veloppement logiciel hautement fiables qui se situent entre le d√©veloppement habituel et la v√©rification du code.  Vous n'avez pas besoin d'une v√©rification compl√®te pour √©crire un bon logiciel ou m√™me presque parfait.  Il y a des moments o√π cela est n√©cessaire, mais pour la plupart des industries, c'est un gaspillage d'argent. <br><br>  Cependant, cela ne signifie pas que les m√©thodes formelles ne sont g√©n√©ralement pas √©conomiques.  De nombreuses m√©thodes hautement fiables mentionn√©es ci-dessus sont bas√©es sur l'√©criture de sp√©cifications de code que vous ne prouvez pas officiellement.  En termes de v√©rification, il existe deux fa√ßons courantes dont l'industrie b√©n√©ficie.  Tout d'abord, la v√©rification de la conception au lieu du code, dont nous discuterons plus tard.  Deuxi√®mement, une v√©rification partielle du code, que nous allons examiner maintenant. <br><br><h2>  V√©rification partielle du code </h2><br>  Pour les t√¢ches quotidiennes, il est trop co√ªteux de faire une v√©rification compl√®te.  Que diriez-vous partielle?  Apr√®s tout, vous pouvez b√©n√©ficier de la preuve de certaines propri√©t√©s de fragments de code individuels.  Au lieu de prouver que ma fonction trie toujours correctement les nombres, je peux au moins prouver qu'elle ne boucle pas ind√©finiment et ne sort jamais de la plage.  Il s'agit √©galement d'informations tr√®s utiles.  Ainsi, m√™me les preuves les plus simples pour les programmes C sont un excellent moyen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'√©liminer une grande partie des comportements non d√©finis</a> . <br><br>  Le probl√®me est l' <i>accessibilit√©</i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La plupart des langues sont con√ßues pour une v√©rification compl√®te ou ne les prennent pas en charge du tout. Dans le premier cas, vous manquez de nombreuses fonctionnalit√©s int√©ressantes de langages plus expressifs, et dans le second cas, vous avez besoin d'un moyen de prouver les choses dans un langage hostile au concept lui-m√™me. Pour cette raison, la plupart des √©tudes sur la v√©rification partielle se concentrent sur plusieurs langages hautement prioritaires, tels que C et Java. Beaucoup fonctionnent avec des sous-ensembles de langues limit√©s. Par exemple, SPARK est un sous-ensemble limit√© d'Ada, vous pouvez donc √©crire du code SPARK critique et interagir avec du code Ada moins critique. Mais la plupart de ces langues sont assez niches.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le plus souvent, certains types de v√©rification sont int√©gr√©s dans la structure de base des langues. </font><font style="vertical-align: inherit;">Les syst√®mes de typification utilis√©s dans la production sont une variante courante: vous ne savez peut-√™tre pas que la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> retourne toujours la queue, mais vous savez exactement quel est son type </font></font><code>[a] -&gt; [a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il existe √©galement des exemples comme Rust avec une s√©curit√© de la m√©moire √©prouv√©e et Pony avec une preuve de s√©curit√© avec des exceptions. </font><font style="vertical-align: inherit;">Ils sont l√©g√®rement diff√©rents de SPARK et Frama-C en ce qu'ils ne </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peuvent</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> effectuer que </font><font style="vertical-align: inherit;">des v√©rifications partielles. </font><font style="vertical-align: inherit;">Et ils sont g√©n√©ralement d√©velopp√©s par des experts en langages de programmation, et non par des experts en m√©thodes formelles: il y a beaucoup de points communs entre les deux disciplines, mais ils ne sont pas identiques. </font><font style="vertical-align: inherit;">C'est peut-√™tre la raison pour laquelle des langues comme Rust et Haskell sont vraiment adapt√©es √† une utilisation pratique.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sp√©cifications de conception </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous n'avons parl√© que de la v√©rification du code. Cependant, les m√©thodes formelles ont un autre c√¥t√©, qui est plus abstrait et v√©rifie la conception elle-m√™me, l'architecture du projet. Cette analyse est si profonde qu'elle est synonyme de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sp√©cification formelle</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : si quelqu'un dit qu'il remplit une sp√©cification formelle, cela signifie tr√®s probablement qu'il d√©finit et v√©rifie la conception.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme nous l'avons d√©j√† dit, prouver toutes les lignes de code est tr√®s, tr√®s difficile. Mais de nombreux probl√®mes de production ne surviennent pas √† cause du code, mais √† cause de l'interaction des composants du syst√®me. Si nous ignorons les d√©tails de la mise en ≈ìuvre, par exemple, si nous consid√©rons comme acquis que le syst√®me est capable de reconna√Ætre les oiseaux, il nous sera plus facile d'analyser comment les arbres et les oiseaux s'int√®grent dans la conception globale en tant que modules de haut niveau. √Ä une telle √©chelle, il devient beaucoup plus facile de d√©crire des choses que vous ne pouviez pas r√©aliser, comme un environnement d'ex√©cution, des interactions humaines ou un </font></font><abbr title="       ,   ,  &nbsp;‚Äî ,    "><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flux de temps impitoyable</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . √Ä cette √©chelle, nous formalisons nos intentions √† l'aide d'un syst√®me commun, plut√¥t que de lignes de code. Ceci est beaucoup plus proche du niveau humain, o√π les projets et les exigences peuvent √™tre beaucoup plus ambigus qu'au niveau du code.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, prenons une proc√©dure avec une sp√©cification approximative ¬´si elle est appel√©e, elle effectue un appel syst√®me pour enregistrer les donn√©es dans le r√©f√©rentiel et traite les erreurs syst√®me¬ª. </font><font style="vertical-align: inherit;">Les propri√©t√©s sont difficiles √† v√©rifier, mais il est assez clair comment proc√©der. </font><font style="vertical-align: inherit;">Les donn√©es sont-elles s√©rialis√©es correctement? </font><font style="vertical-align: inherit;">Nos garanties sont-elles viol√©es en raison d'une saisie incorrecte? </font><font style="vertical-align: inherit;">Sommes-nous en train de g√©rer toutes les mani√®res possibles d'√©chouer un appel syst√®me? </font><font style="vertical-align: inherit;">Comparez maintenant le syst√®me de journalisation de haut niveau avec la sp√©cification ¬´tous les messages sont enregistr√©s¬ª et r√©pondez aux questions suivantes:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tous les messages sont-ils enregistr√©s ou tous les messages </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui entrent dans le syst√®me</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font><font style="vertical-align: inherit;">Les messages sont enregistr√©s une fois ou </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">garantis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> une fois?</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment les messages sont-ils envoy√©s? </font><font style="vertical-align: inherit;">Est-ce le tour? </font><font style="vertical-align: inherit;">La cha√Æne ne les d√©livre-t-elle qu'une seule fois? </font><font style="vertical-align: inherit;">Tout va bien avec la livraison?</font></font><br></li><li>          ?      ,    ?    ¬´¬ª     ,     ? <br></li><li>  ,       ?   ? <br></li><li>     ?    ¬´  ¬ª      ? <br></li><li>   GDPR? <br></li><li>      . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sans une conception formelle, il est plus difficile d'exprimer les exigences vraiment n√©cessaires pour le syst√®me. Si vous ne pouvez pas les exprimer, vous ne savez pas si le design r√©pond vraiment aux exigences ou leur ressemble, mais cela peut entra√Æner des cons√©quences impr√©visibles. En exprimant plus formellement les intentions et la conception, nous pouvons facilement v√©rifier que nous d√©veloppons r√©ellement ce dont nous avons besoin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout comme nous utilisons des langages de programmation pour repr√©senter du code, nous utilisons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des langages de sp√©cification</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour repr√©senter des projets. Les langages de sp√©cification sont g√©n√©ralement orient√©s vers les sp√©cifications de conception plut√¥t que vers les sp√©cifications de code, bien que certains langages puissent √™tre utilis√©s dans les deux cas (remarque: le processus de mise en correspondance des sp√©cifications de conception avec les sp√©cifications de code est appel√© </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raffinement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä l'avenir, j'appellerai des langages de conception (DL) pour minimiser la confusion (encore une fois, ce n'est pas une terminologie courante; la plupart des gens utilisent le ¬´langage de sp√©cification¬ª, mais je veux faire une distinction claire entre les sp√©cifications de code et les sp√©cifications de conception). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le premier DL complet √©tait probablement le VDM vers 1972. </font><font style="vertical-align: inherit;">Depuis lors, nous avons vu une grande vari√©t√© de langages de sp√©cifications diff√©rents. </font><font style="vertical-align: inherit;">L'espace DL est beaucoup plus diversifi√© et fragment√© qu'avec les langages de v√©rification de code (CVL). </font><font style="vertical-align: inherit;">En gros, les gens ont invent√© le DL comme moyen d'atteindre une fin et le CVL comme objectif lui-m√™me. </font><font style="vertical-align: inherit;">Puisqu'ils sont fortement influenc√©s par des probl√®mes sp√©cifiques, DL met en ≈ìuvre toutes sortes d'id√©es et de s√©mantique. </font><font style="vertical-align: inherit;">Voici un tr√®s, tr√®s bref aper√ßu de certaines des premi√®res DL:</font></font><br><br><table><tbody><tr><th>  La langue </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zone de mod√©lisation </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moyens </font></font></th></tr><tr><td>  Z </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exigences commerciales </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alg√®bre relationnelle </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promela </font></font></td><td>  </td><td> CSP </td></tr><tr><td> SDL </td><td>  </td><td> - </td></tr><tr><td>    </td><td>  </td><td>  </td></tr><tr><td>    </td><td>  </td><td>  </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que les DL sont g√©n√©ralement cr√©√©s pour r√©soudre des probl√®mes sp√©cifiques, la plupart d'entre eux ont au moins deux ou trois applications r√©elles. En r√®gle g√©n√©rale, les r√©sultats sont tr√®s positifs. Les praticiens disent que DL permet de comprendre les probl√®mes et facilite la recherche de solutions. Pendant longtemps, le principal champion a √©t√© Praxis (maintenant Altran), qui a appliqu√© le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬´fix-by-design¬ª</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - une combinaison de constructions en Z et de code SPARK - pour cr√©er des syst√®mes de s√©curit√© critiques. Les sp√©cifications permettent d'√©conomiser du temps et de l'argent car vous ne trouverez pas d'erreurs de conception √† un stade avanc√© du projet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pamela Zave a exp√©riment√© avec Alloy et a d√©couvert un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bug fondamental</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans Chord, l'une des principales tables de hachage distribu√©es. AWS commence √† rechercher des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erreurs critiques en 35 √©tapes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en √©crivant les sp√©cifications TLA +. D'apr√®s mon exp√©rience, lorsque les gens essaient de r√©diger des sp√©cifications, ils deviennent tr√®s vite de grands fans de cette entreprise. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais les fans de m√©thodes formelles et les gens de l'ext√©rieur √©valuent compl√®tement diff√©remment la valeur de la r√©daction des sp√©cifications. Pour les fans, le plus grand avantage est que le processus de conception lui-m√™me vous fait comprendre ce que vous √©crivez. Lorsque vous devez exprimer formellement ce que fait votre syst√®me, de nombreuses erreurs implicites deviennent soudainement douloureusement √©videntes. Les √©trangers ne peuvent pas comprendre cela du tout. Si vous voulez donner √† quelqu'un un essai DL, une personne devrait avoir un moyen de v√©rifier que la conception a vraiment les propri√©t√©s qu'il souhaite.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Heureusement, cela est √©galement extr√™mement important pour de nombreux sp√©cificateurs, de sorte que la v√©rification de la conception est un vaste domaine de recherche. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V√©rification du mod√®le </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme pour le code, nous pouvons v√©rifier la conception en √©crivant des th√©or√®mes. Heureusement, nous avons une autre astuce: vous pouvez utiliser </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le programme de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> v√©rification de mod√®le. Au lieu de compiler des preuves que la conception est correcte, nous for√ßons simplement l'espace brut des √©tats possibles et voyons si le mauvais √©tat existe en lui. Si nous ne trouvons rien, alors tout va bien (remarque: les programmes de v√©rification de mod√®le sont √©galement utilis√©s pour v√©rifier le code, comme JMBC, mais la v√©rification de mod√®le est beaucoup plus souvent utilis√©e dans la v√©rification de conception que la v√©rification de code). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La validation du mod√®le pr√©sente de nombreux avantages. Premi√®rement, il n'est pas n√©cessaire de r√©diger des preuves, ce qui √©conomise beaucoup de temps et d'efforts. Deuxi√®mement, pas besoin </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'apprendre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©diger des preuves, de sorte que la barri√®re d'entr√©e est beaucoup plus faible. Troisi√®mement, si la conception est bris√©e, la v√©rification du mod√®le donnera un contre-exemple explicite. Cela </font><font style="vertical-align: inherit;">rend </font><font style="vertical-align: inherit;">beaucoup </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> facile de corriger l'erreur, surtout s'il faut 35 √©tapes pour la reproduire. Essayez de le trouver vous-m√™me. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a quelques inconv√©nients. Tout d'abord, ces outils ne sont pas si puissants. En particulier, vous pouvez rencontrer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un nombre illimit√©</font></font></b> (unbounded) ,      . ,     :        .        ‚Ä¶ ,   ,      .            ,       ,    . <br><br>    ‚Äî <b>   </b> (state-space explosion). ,     ,        ,       .        ,   <code>(4*3)! / (4!)^3 = 34 650</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ex√©cutions (comportements) possibles. Si chaque processus a l'un des cinq √©tats initiaux, le nombre total de comportements augmente √† 4 300 000. Et la v√©rification des mod√®les doit s'assurer qu'ils se comportent tous bien. Et cela √† condition qu'ils n'interagissent pas entre eux! S'ils commencent √† le faire, l'espace d'√©tat augmentera encore plus rapidement. Une explosion combinatoire est consid√©r√©e comme le principal probl√®me pour tester des mod√®les, et beaucoup de travail reste √† faire pour r√©soudre ce probl√®me.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais en m√™me temps, il existe une autre fa√ßon de faire face √† l'explosion de l'espace de l'√âtat: lui jeter plus d'√©quipement. Le plus gros probl√®me pour v√©rifier le mod√®le est ¬´juste¬ª le probl√®me de performance, et nous r√©solvons tr√®s bien les probl√®mes de performance. La plupart (mais pas tous) les v√©rifications de mod√®le sont facilement parall√©lis√©es. Apr√®s avoir optimis√© le mod√®le et l'avoir test√© avec de petits param√®tres, vous pouvez d√©ployer le cluster AWS et l'ex√©cuter avec de grands param√®tres.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la pratique, de nombreux qualificatifs utilisent la validation du mod√®le, puis, si n√©cessaire, passent √† des programmes pour prouver les th√©or√®mes (note: gardez √† l'esprit que ¬´de nombreux qualificatifs¬ª sont environ dix). </font><font style="vertical-align: inherit;">Encore plus de compilateurs de sp√©cifications commencent √† tester des mod√®les et lorsqu'ils atteignent la limite de leurs capacit√©s, ils passent √† des formes de v√©rification moins intensives.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Probl√®me de sp√©cification de conception </font></font></h3><br>  ,     ,   ,     .      ?   DV  .   ‚Äî   ,    ‚Äî  :     . <br><br>     ,  <i> ‚Äî   </i> .   DL      ,             (:      <b></b> ;   .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ; ,     (    )  <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clarification</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : des recherches actives sont en cours dans les deux sens). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les programmeurs ont tendance √† se m√©fier des artefacts logiciels qui ne sont pas du code ou ne sont pas oblig√©s de se synchroniser avec le code. Pour la m√™me raison, la documentation, les commentaires, les graphiques, les wikis et les validations sont souvent ignor√©s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble que les programmeurs ne croient tout simplement pas que les sp√©cifications soient utiles. D'apr√®s mon exp√©rience, ils sugg√®rent que les outils actuels (pseudo-code, diagrammes, TDD) sont plus que suffisants pour une bonne conception. Je ne sais pas √† quel point cette opinion est r√©pandue et je ne peux pas l'expliquer avec autre chose que le conservatisme g√©n√©ral.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais exactement chaque communaut√© de m√©thodologie a de telles plaintes que je sais: les partisans de TDD se plaignent que les programmeurs ne veulent pas essayer TDD, les fans de Haskell se plaignent que les programmeurs ne pensent pas au typage statique, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai entendu l'argument selon lequel Agile n'accepte pas une conception pr√©con√ßue, donc personne ne veut faire de sp√©cification formelle. Peut-√™tre. Mais beaucoup de gens que j'ai rencontr√©s rejettent Agile et FM. Un autre argument est que les m√©thodes historiquement formelles ont √©t√© constamment r√©√©valu√©es et n'ont pas rempli ce qui avait √©t√© promis. C'est √©galement possible, mais la plupart des gens n'ont m√™me pas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entendu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parler des m√©thodes formelles, et encore plus de leur histoire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est tout simplement tr√®s difficile de faire en sorte que les gens s'inqui√®tent de ce qu'ils ne font pas encore, m√™me s'ils en reconnaissent les avantages.</font></font><br><br><h1>  R√©sum√© </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La v√©rification du code est une t√¢che difficile. </font><font style="vertical-align: inherit;">De plus en plus de personnes s'impliquent, bien que les programmes de d√©monstration de th√©or√®mes et les solveurs SMT deviennent plus complexes. </font><font style="vertical-align: inherit;">Mais encore, dans un avenir pr√©visible, probablement, cela restera le lot de sp√©cialistes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La v√©rification de la conception est beaucoup plus simple, mais son utilisation n√©cessite de surmonter la barri√®re culturelle. </font><font style="vertical-align: inherit;">Je pense que la situation peut changer. </font><font style="vertical-align: inherit;">Il y a vingt ans, les tests automatis√©s et les r√©visions de code √©taient des sujets assez exotiques et de niche, mais sont finalement devenus courants. </font><font style="vertical-align: inherit;">Encore une fois, la programmation des contrats √©tait une niche et le reste.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'esp√®re que cet article explique un peu mieux pourquoi les m√©thodes formelles sont si rarement utilis√©es. </font><font style="vertical-align: inherit;">Au moins, c'est une meilleure explication que l'argument habituel "le web n'est pas un avion". </font><font style="vertical-align: inherit;">N'h√©sitez pas √† crier si vous voyez des erreurs √©videntes.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437296/">https://habr.com/ru/post/fr437296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437280/index.html">Logistique facile √† faire soi-m√™me</a></li>
<li><a href="../fr437282/index.html">Une introduction √† Kubernetes pour les utilisateurs de VMware. Partie 2. Pratique</a></li>
<li><a href="../fr437284/index.html">Professions zoologiques li√©es √† l'industrie audio</a></li>
<li><a href="../fr437286/index.html">J'essaie .NET Core + Kubernetes + appmetrics + prometheus + grafana + jobs + health checks</a></li>
<li><a href="../fr437292/index.html">Pourquoi le mod√®le de magasin de d√©tail traditionnel est d√©j√† mort</a></li>
<li><a href="../fr437298/index.html">√Ä propos d'un gars</a></li>
<li><a href="../fr437300/index.html">10 comp√©tences et connaissances n√©cessaires pour un d√©veloppeur iOS d√©butant</a></li>
<li><a href="../fr437304/index.html">Comment acheter des pommes de terre si vous √™tes daltonien</a></li>
<li><a href="../fr437306/index.html">Comp√©tences non √©videntes requises par le chef de produit</a></li>
<li><a href="../fr437308/index.html">Cycle de le√ßon SDL 2.0: Le√ßon 4 - Gestion des √©v√©nements</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>