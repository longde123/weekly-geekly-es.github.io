<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¾â€ğŸ³ ğŸ¤œ ğŸ¤¹ğŸ¾ Keterbacaan kode ğŸ‘¨ğŸ»â€ğŸ”¬ ğŸ¤˜ğŸ½ ğŸŒµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kode digunakan untuk membuat antarmuka. Tetapi kode itu sendiri adalah sebuah antarmuka. 
 Terlepas dari kenyataan bahwa keterbacaan kode sangat penti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Keterbacaan kode</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alconost/blog/443678/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/g-/nh/_a/g-nh_a2awcaa_upnpuhgq2hch6g.jpeg"></a> <br><br><h3>  Kode digunakan untuk membuat antarmuka.  Tetapi kode itu sendiri adalah sebuah antarmuka. </h3><br>  Terlepas dari kenyataan bahwa keterbacaan kode sangat penting, konsep ini tidak didefinisikan dengan baik - dan seringkali dalam bentuk hanya seperangkat aturan: menggunakan nama variabel yang bermakna, memecah fungsi besar menjadi yang lebih kecil, dan menggunakan pola desain standar. <br><br>  Pada saat yang sama, pasti, semua orang harus berurusan dengan kode yang sesuai dengan aturan-aturan ini, tetapi untuk beberapa alasan adalah semacam kekacauan. <br><br>  Anda dapat mencoba menyelesaikan masalah ini dengan menambahkan aturan baru: jika nama variabel menjadi sangat panjang, Anda perlu memperbaiki logika utama;  jika banyak metode bantu terakumulasi dalam satu kelas, mungkin itu harus dibagi menjadi dua;  Pola desain tidak dapat diterapkan dalam konteks yang salah. <br><br>  Instruksi semacam itu berubah menjadi labirin keputusan subyektif, dan untuk menavigasinya, Anda akan membutuhkan pengembang yang dapat membuat pilihan yang tepat - yaitu, ia harus sudah dapat menulis kode yang dapat dibaca. <br><br>  Dengan demikian, seperangkat instruksi bukan pilihan.  Oleh karena itu, kita harus merumuskan gambaran yang lebih luas tentang keterbacaan kode. <br><br><h2>  Mengapa keterbacaan dibutuhkan </h2><br>  Dalam praktiknya, keterbacaan yang baik biasanya berarti bahwa kode itu enak dibaca.  Namun, seseorang tidak dapat melangkah jauh dengan definisi seperti itu: pertama, itu subjektif, dan kedua, itu mengikat kita untuk membaca teks biasa. <br><br>  Kode yang tidak terbaca dianggap sebagai novel yang berpura-pura menjadi kode: banyak komentar yang mengungkapkan esensi dari apa yang terjadi, lembaran teks yang perlu dibaca secara berurutan, formulasi cerdas, satu-satunya makna yang harus "pintar", takut menggunakan kembali kata-kata.  Pengembang mencoba membuat kode dapat dibaca, tetapi menargetkan jenis pembaca yang salah. <br><br>  Keterbacaan teks dan pembacaan kode bukan hal yang sama. <br><br>  <b>Diterjemahkan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alconost</a></b> <br><a name="habracut"></a><br><blockquote>  Kode digunakan untuk membuat antarmuka.  Tetapi kode itu sendiri adalah sebuah antarmuka. </blockquote><br>  Jika kodenya terlihat indah, apakah ini berarti dapat dibaca?  Estetika adalah efek samping yang menyenangkan dari keterbacaan, tetapi sebagai kriteria tidak terlalu berguna.  Mungkin dalam kasus ekstrim, estetika kode dalam proyek akan membantu mempertahankan karyawan - tetapi dengan kesuksesan yang sama, Anda dapat menawarkan paket sosial yang baik.  Selain itu, setiap orang memiliki ide mereka sendiri tentang apa artinya "kode indah".  Dan seiring berjalannya waktu, definisi keterbacaan ini berubah menjadi pusaran sengketa tentang tabulasi, spasi, tanda kurung, "notasi unta", dll. Tidak mungkin ada orang yang akan kehilangan kesadaran ketika mereka melihat lekukan yang salah, meskipun hal ini menarik perhatian ketika memeriksa kode. <br><br>  Jika kode menghasilkan lebih sedikit kesalahan, dapatkah itu dianggap lebih mudah dibaca?  Semakin sedikit kesalahan, semakin baik, tetapi mekanisme apa yang ada?  Bagaimana saya bisa menghubungkan sensasi menyenangkan samar yang Anda alami ketika membaca kode?  Selain itu, tidak peduli seberapa alisnya berkerut saat membaca kode, ini tidak akan menambah kesalahan. <br><br>  Jika kodenya mudah diedit, apakah bisa dibaca?  Tapi ini, mungkin, adalah arah pemikiran yang benar.  Persyaratan berubah, fungsi ditambahkan, kesalahan muncul - dan pada titik tertentu seseorang harus mengedit kode Anda.  Dan agar tidak menimbulkan masalah baru, pengembang perlu memahami apa yang sebenarnya dia edit dan bagaimana perubahan akan mengubah perilaku kode.  Jadi, kami menemukan aturan heuristik baru: kode yang mudah dibaca harus mudah diedit. <br><br><h2>  Kode mana yang lebih mudah diedit? </h2><br>  Saya segera ingin menjelaskan: "Kode lebih mudah diedit ketika nama variabel diberikan secara bermakna," tetapi kami hanya mengganti nama "keterbacaan" menjadi "kemudahan mengedit."  Kita membutuhkan pemahaman yang lebih dalam, dan bukan seperangkat aturan yang sama dalam kedok yang berbeda. <br><br>  Mari kita mulai dengan melupakan sejenak bahwa kita berbicara tentang kode.  Pemrograman, yang sudah berumur beberapa dekade, hanyalah titik pada skala sejarah manusia.  Membatasi diri kita pada "titik" ini, kita tidak bisa menggali lebih dalam. <br><br>  Oleh karena itu, mari kita lihat keterbacaan melalui prisma merancang antarmuka yang kita temui di hampir setiap langkah - dan tidak hanya dengan yang digital.  Mainan itu memiliki fungsi yang membuatnya naik atau mencicit.  Pintu memiliki antarmuka yang memungkinkan Anda untuk membuka, menutup, dan menguncinya.  Data dalam buku dikumpulkan dalam halaman, yang menyediakan akses acak lebih cepat daripada menggulir.  Mempelajari desain, Anda bisa belajar lebih banyak tentang antarmuka ini - tanyakan pada tim desain apakah Anda bisa.  Dalam kasus umum, kita semua lebih suka antarmuka yang baik, bahkan jika kita tidak selalu tahu apa yang membuatnya baik. <br><br>  Kode digunakan untuk membuat antarmuka.  Tetapi kode itu sendiri, dikombinasikan dengan IDE, adalah sebuah antarmuka.  Antarmuka yang dirancang untuk sekelompok kecil pengguna - kolega kami.  Selanjutnya kami akan memanggil mereka "pengguna" - agar tetap dalam ruang merancang antarmuka pengguna. <br><br>  Dengan mengingat hal ini, pertimbangkan contoh jalur pengguna ini: <br><br><ul><li>  Pengguna ingin menambahkan fungsi baru.  Ini membutuhkan menemukan tempat yang tepat dan menambahkan fungsi tanpa menghasilkan kesalahan baru. <br></li><li>  Pengguna ingin memperbaiki kesalahan.  Dia perlu menemukan sumber masalah dan mengedit kode sehingga kesalahan hilang dan kesalahan baru tidak muncul. <br></li><li>  Pengguna ingin memastikan bahwa dalam kasus batas, kode berperilaku dengan cara tertentu.  Dia perlu menemukan bagian kode tertentu, kemudian melacak logikanya dan mensimulasikan apa yang terjadi. <br></li></ul><br>  Dan seterusnya: sebagian besar jalur mengikuti pola yang sama.  Agar tidak menyulitkan hal-hal, pertimbangkan contoh-contoh spesifik - tetapi jangan lupa bahwa ini adalah pencarian prinsip-prinsip umum, bukan daftar aturan. <br><br>  Kami yakin dapat berasumsi bahwa pengguna tidak akan dapat langsung membuka bagian kode yang diinginkan.  Ini juga berlaku untuk proyek hobi Anda sendiri: bahkan jika fungsi itu ditulis oleh Anda, sangat mudah untuk melupakan di mana ia berada.  Karena itu, kodenya harus sedemikian rupa sehingga mudah untuk menemukan yang tepat di dalamnya. <br><br>  Untuk menerapkan pencarian yang mudah, Anda perlu beberapa optimasi mesin pencari - ini dia bagi kami bahwa nama variabel yang bermakna datang untuk menyelamatkan.  Jika pengguna tidak dapat menemukan fungsi, bergerak di sepanjang tumpukan panggilan dari titik yang diketahui, ia dapat memulai pencarian dengan kata kunci.  Namun, Anda tidak dapat memasukkan terlalu banyak kata kunci dalam nama.  Saat mencari berdasarkan kode, satu-satunya titik masuk dicari, dari mana Anda dapat terus bekerja lebih lanjut.  Karena itu, pengguna perlu membantu sampai ke tempat tertentu, dan jika Anda berlebihan dengan kata kunci, akan ada terlalu banyak hasil pencarian yang tidak berguna. <br><br><blockquote>  Jika pengguna dapat segera memverifikasi bahwa semuanya benar pada tingkat logika tertentu, ia dapat melupakan lapisan abstraksi sebelumnya dan membebaskan pikirannya untuk selanjutnya. </blockquote><br>  Anda dapat mencari menggunakan pelengkapan otomatis: jika Anda memiliki gagasan umum tentang fungsi yang ingin Anda panggil atau penghitungan yang digunakan, Anda dapat mulai mengetik nama yang dimaksud, dan kemudian memilih opsi yang sesuai dari daftar pelengkapan otomatis.  Jika fungsi ini hanya ditujukan untuk kasus-kasus tertentu atau jika Anda perlu membaca dengan cermat implementasinya karena fitur penggunaannya, Anda dapat menunjukkan ini dengan memberinya nama yang lebih otentik: dengan menggulir daftar pelengkapan otomatis, pengguna lebih suka menghindari apa yang terlihat rumit - kecuali, tentu saja, dia yakin apa yang terjadi. <br><br>  Oleh karena itu, nama biasa pendek lebih cenderung dianggap sebagai opsi default, cocok untuk pengguna "biasa".  Seharusnya tidak ada kejutan dalam fungsi dengan nama-nama tersebut: Anda tidak dapat memasukkan setter ke dalam fungsi yang terlihat seperti getter sederhana, karena alasan yang sama bahwa tombol Lihat di antarmuka tidak boleh mengubah data pengguna. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3cc/a47/753/3cca47753d7f089d36509f51e84c9054.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2c5/43d/3c4/2c543d3c4b9f902b9efc344a6993088f.png"><br>  <font color="#0096d6"><i>Di antarmuka yang menghadap klien, fungsi-fungsi yang akrab, seperti jeda, melakukan hampir tanpa teks.</i></font>  <font color="#0096d6"><i>Ketika fungsi menjadi lebih kompleks, nama-nama memanjang, yang membuat pengguna melambat dan berpikir.</i></font>  <font color="#0096d6"><i>Tangkapan layar - Pandora</i></font> <br><br>  Pengguna ingin menemukan informasi yang tepat dengan cepat.  Dalam kebanyakan kasus, kompilasi membutuhkan banyak waktu, dan dalam aplikasi yang sedang berjalan Anda harus memeriksa secara manual berbagai kasus perbatasan.  Jika memungkinkan, pengguna kami akan lebih suka membaca kode dan memahami bagaimana perilakunya, daripada mengatur breakpoints dan menjalankan kode. <br><br>  Untuk melakukannya tanpa menjalankan kode, dua syarat harus dipenuhi: <br><br><ol><li>  Pengguna mengerti apa yang coba dilakukan oleh kode. <br></li><li>  Pengguna yakin bahwa kode melakukan apa yang diklaimnya. <br></li></ol><br>  Abstraksi membantu memenuhi kondisi pertama: pengguna harus dapat menyelami lapisan abstraksi ke tingkat detail yang diinginkan.  Bayangkan sebuah antarmuka pengguna hierarkis: pada tingkat pertama, navigasi dilakukan melalui bagian-bagian yang luas, dan kemudian semakin dikonkritkan - ke tingkat logika yang perlu dipelajari secara lebih rinci. <br><br>  Pembacaan berurutan file atau metode dilakukan dalam waktu linier.  Tetapi jika pengguna dapat bergerak naik dan turun tumpukan panggilan - ini adalah pencarian di pohon, dan jika hirarki seimbang, tindakan ini dilakukan dalam waktu logaritmik.  Tentu saja ada ruang untuk daftar di antarmuka, tetapi Anda harus hati-hati mempertimbangkan apakah harus ada lebih dari dua atau tiga pemanggilan metode dalam beberapa konteks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4e/54b/63b/b4e54b63bef2986ed14b7c01475f0ac3.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff4/016/78d/ff401678d9087319f881763d6506ed17.png"><br>  <font color="#0096d6"><i>Dalam menu pendek, navigasi hierarkis jauh lebih cepat.</i></font>  <font color="#0096d6"><i>Dalam menu "panjang" di sebelah kanan - hanya 11 baris.</i></font>  <font color="#0096d6"><i>Seberapa sering kita memasukkan angka ini ke dalam kode metode?</i></font>  <font color="#0096d6"><i>Tangkapan layar - Pandora</i></font> <br><br>  Pengguna yang berbeda memiliki strategi yang berbeda untuk kondisi kedua.  Dalam situasi berisiko rendah, komentar atau nama metode adalah bukti yang cukup.  Di area yang lebih berisiko dan kompleks, serta ketika kode dibebani dengan komentar yang tidak relevan, yang terakhir cenderung diabaikan.  Terkadang bahkan nama metode dan variabel akan diragukan.  Dalam kasus seperti itu, pengguna harus membaca lebih banyak kode dan ingat model logika yang lebih luas.  Membatasi konteks untuk area kecil yang mudah dipegang juga akan membantu di sini.  Jika pengguna dapat segera memverifikasi bahwa semuanya benar pada tingkat logika tertentu, ia dapat melupakan lapisan abstraksi sebelumnya dan membebaskan pikirannya untuk selanjutnya. <br><br>  Dalam mode operasi ini, token individu mulai memiliki kepentingan yang lebih besar.  Misalnya, bendera boolean <br><br><pre><code class="plaintext hljs">element.visible = true/false</code> </pre> <br>  mudah dimengerti secara terpisah dari sisa kode, tetapi ini membutuhkan menggabungkan dua token yang berbeda dalam pikiran.  Jika digunakan <br><br><pre> <b><code class="plaintext hljs">element.visibility = .visible/.hidden</code></b> </pre> <br>  maka nilai flag dapat langsung dipahami: dalam hal ini, Anda tidak perlu membaca nama variabel untuk mengetahui bahwa itu terkait dengan visibilitas. Â¹ Kami melihat pendekatan serupa dalam merancang antarmuka berorientasi klien.  Selama beberapa dekade terakhir, tombol OK dan Cancel telah berubah menjadi elemen antarmuka yang lebih deskriptif: "Simpan" dan "Batalkan", "Kirim" dan "Lanjutkan mengedit", dll., Untuk memahami apa yang akan dilakukan, cukup bagi pengguna untuk melihat opsi yang diusulkan tanpa membaca keseluruhan konteks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45c/a82/808/45ca8280883829b703ea2a0c8ae47776.png"><br>  <font color="#0096d6"><i>Baris "Mode Offline" pada contoh di atas menunjukkan bahwa aplikasi sedang offline.</i></font>  <font color="#0096d6"><i>Switch dalam contoh di bawah ini memiliki arti yang sama, tetapi untuk memahaminya, Anda perlu melihat konteksnya.</i></font>  <font color="#0096d6"><i>Tangkapan layar - Pandora</i></font> <br><br>  Tes unit juga membantu untuk mengkonfirmasi perilaku kode yang diharapkan: mereka bertindak sebagai komentar - yang, bagaimanapun, dapat dipercaya lebih luas, karena mereka lebih relevan.  Benar, mereka juga harus menyelesaikan perakitan.  Tetapi dalam kasus pipa CI yang sudah mapan, tes dijalankan secara teratur, sehingga Anda dapat melewati langkah ini ketika membuat perubahan pada kode yang ada. <br><br>  Secara teori, keamanan mengikuti dari pemahaman yang memadai: begitu pengguna kami memahami perilaku kode, ia akan dapat membuat perubahan dengan aman.  Dalam praktiknya, Anda harus mempertimbangkan bahwa pengembang adalah orang biasa: otak kita menggunakan trik yang sama dan juga malas.  Karena itu, semakin sedikit upaya yang Anda perlu habiskan untuk memahami kode, semakin aman tindakan kami. <br><br>  Kode yang dapat dibaca harus melewati sebagian besar pemeriksaan kesalahan ke komputer.  Salah satu cara untuk melakukan ini adalah dengan menggunakan pemeriksaan debug "menegaskan", namun, mereka juga memerlukan perakitan dan startup.  Lebih buruk lagi, jika pengguna lupa tentang kasus batas, menegaskan tidak akan membantu.  Tes unit untuk memeriksa kasus perbatasan yang sering dilupakan bisa lebih baik, tetapi begitu pengguna melakukan perubahan, Anda harus menunggu tes berjalan. <br><br><blockquote>  Singkatnya: kode yang mudah dibaca harus mudah digunakan.  Dan - sebagai efek samping - itu bisa terlihat indah. </blockquote><br>  Untuk mempercepat siklus pengembangan, kami menggunakan fungsi pengecekan kesalahan yang ada di kompiler.  Biasanya untuk kasus seperti itu, perakitan lengkap tidak diperlukan, dan kesalahan ditampilkan secara real time.  Bagaimana cara memanfaatkan peluang ini?  Secara umum, Anda perlu menemukan situasi di mana pemeriksaan kompiler menjadi sangat ketat.  Sebagai contoh, kebanyakan kompiler tidak melihat seberapa komprehensif pernyataan "jika" dijelaskan, tetapi hati-hati memeriksa "saklar" untuk kondisi yang hilang.  Jika pengguna mencoba untuk menambah atau mengubah suatu kondisi, akan lebih aman jika semua operator serupa sebelumnya bersifat komprehensif.  Dan ketika kondisi "case" berubah, kompiler akan menandai semua kondisi lain yang perlu diperiksa. <br><br>  Masalah keterbacaan umum lainnya adalah penggunaan primitif dalam ekspresi bersyarat.  Masalah ini sangat akut ketika aplikasi mem-parsing JSON, karena Anda hanya ingin menambahkan pernyataan "jika" di sekitar string atau integer equality.  Ini tidak hanya meningkatkan kemungkinan kesalahan ketik, tetapi juga mempersulit tugas bagi pengguna untuk menentukan nilai yang mungkin.  Ketika memeriksa kasus batas, ada perbedaan besar antara kapan garis mungkin, dan ketika - hanya dua atau tiga opsi terpisah.  Bahkan jika primitif ditetapkan dalam konstanta, Anda harus bergegas sekali, mencoba menyelesaikan proyek tepat waktu, dan nilai sewenang-wenang akan muncul.  Tetapi jika Anda menggunakan objek atau enumerasi yang dibuat khusus, kompiler memblokir argumen yang tidak valid dan memberikan daftar spesifik yang valid. <br><br>  Demikian pula, jika beberapa kombinasi bendera Boolean tidak diizinkan, ganti dengan satu enumerasi.  Ambil, misalnya, komposisi yang bisa dalam keadaan berikut: itu buffer, terisi penuh, dan dimainkan.  Jika Anda membayangkan status pemuatan dan pemutaran sebagai dua bendera Boolean <br><br><pre> <b><code class="plaintext hljs">(loaded, playing)</code></b> </pre> <br>  kompiler akan memungkinkan input nilai yang tidak valid <br><br><pre> <b><code class="plaintext hljs">(loaded: false, playing: true)</code></b> </pre> <br>  Dan jika Anda menggunakan enumerasi <br><br><pre> <b><code class="plaintext hljs">(.buffering/.loaded/.playing)</code></b> </pre> <br>  maka tidak mungkin untuk menunjukkan keadaan yang tidak valid.  Di antarmuka berorientasi klien, defaultnya adalah untuk melarang kombinasi pengaturan yang tidak valid.  Tetapi ketika kita menulis kode di dalam aplikasi, kita sering lupa untuk memberi diri kita perlindungan yang sama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/38a/468/91e/38a46891e7b4ad809dd15e89e7e8460c.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/fde/c69/142/fdec69142f6e9dd7695516b143574ec0.png"><br>  <font color="#0096d6"><i>Kombinasi yang tidak valid dimatikan sebelumnya;</i></font>  <font color="#0096d6"><i>pengguna tidak perlu memikirkan konfigurasi mana yang tidak kompatibel.</i></font>  <font color="#0096d6"><i>Tangkapan layar - Apple</i></font> <br><br>  Mengikuti jalur pengguna yang dianggap, kami sampai pada aturan yang sama seperti di awal.  Tetapi sekarang kita memiliki prinsip yang dengannya mereka dapat dirumuskan secara independen dan diubah sesuai dengan situasi.  Untuk melakukan ini, kami bertanya pada diri sendiri: <br><br><ul><li>  Apakah mudah bagi pengguna untuk mencari bagian kode yang diinginkan?  Apakah hasil pencarian akan berantakan dengan fungsi yang tidak terkait dengan permintaan? <br></li><li>  Bisakah seorang pengguna, setelah menemukan kode yang diperlukan, dengan cepat memeriksa kebenaran perilakunya? <br></li><li>  Apakah lingkungan pengembangan menyediakan pengeditan yang aman dan penggunaan kembali kode? <br></li></ul><br>  Singkatnya: kode yang mudah dibaca harus mudah digunakan.  Dan - sebagai efek samping - itu bisa terlihat indah. <br><br><h4>  Catatan </h4><br><ol><li>  Tampaknya variabel Boolean lebih nyaman untuk digunakan kembali, tetapi opsi penggunaan kembali ini menyiratkan interchangeability.  Ambil, misalnya, <b>flag yang dapat</b> <b>disentuh</b> dan di- <b>cache</b> , yang mewakili konsep yang terletak di pesawat yang sama sekali berbeda: kemampuan untuk mengklik elemen dan status cache.  Tetapi jika kedua flag adalah Boolean, Anda dapat secara tidak sengaja menukar mereka, mendapatkan ekspresi non-sepele dalam satu baris kode, yang berarti bahwa cache dikaitkan dengan kemampuan untuk mengklik pada suatu elemen.  Saat menggunakan penghitungan, untuk membentuk hubungan seperti itu, kami akan dipaksa untuk membuat logika yang eksplisit dan dapat diverifikasi untuk konversi "satuan pengukuran" yang digunakan oleh kami. <br></li></ol><br><br>  <b>Tentang penerjemah</b> <br><br>  Artikel ini diterjemahkan oleh Alconost. <br><br>  Alconost <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melokalkan game</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dan situs</a> dalam 70 bahasa.  Penerjemah asli bahasa, pengujian linguistik, platform cloud dengan API, pelokalan berkelanjutan, manajer proyek 24/7, semua format sumber daya string. <br><br>  Kami juga membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video iklan dan pelatihan</a> - untuk situs yang menjual, gambar, iklan, pelatihan, permainan asah, penjelajah, trailer untuk Google Play dan App Store. <br><br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca lebih lanjut</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443678/">https://habr.com/ru/post/id443678/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443666/index.html">Pendekatan kami untuk mewarnai benang</a></li>
<li><a href="../id443668/index.html">Kembali ke layanan microser dengan Istio. Bagian 3</a></li>
<li><a href="../id443670/index.html">Kesalahan dalam versi baru Google Chrome (73.0.3683.75)</a></li>
<li><a href="../id443672/index.html">Pengujian Berbasis Risiko</a></li>
<li><a href="../id443676/index.html">Vinyl alih-alih perangko: jarang terjadi</a></li>
<li><a href="../id443680/index.html">Empat hari kerja seminggu. Pengalaman Rusia</a></li>
<li><a href="../id443682/index.html">Monetisasi cloud: cara menarik pelanggan dan tidak bangkrut</a></li>
<li><a href="../id443684/index.html">Daftar lengkap perbedaan antara VB.NET dan C #. Bagian 1</a></li>
<li><a href="../id443686/index.html">30 - 31 Maret, SIBUR CHALLENGE di Nizhny Novgorod</a></li>
<li><a href="../id443690/index.html">Parallels RAS: ada apa dan dengan apa ia makan?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>