<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💳 👀 👨🏽‍⚕️ Dari salin-tempel ke komponen: menggunakan kembali kode dalam aplikasi yang berbeda 👨🏻‍🔬 ⛷️ 👩‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Badoo mengembangkan beberapa aplikasi, dan masing-masing dari mereka adalah produk yang terpisah dengan karakteristik, manajemen, produk dan tim tekni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dari salin-tempel ke komponen: menggunakan kembali kode dalam aplikasi yang berbeda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/466049/"><img src="https://habrastorage.org/webt/4j/xp/to/4jxptoi9jrqf5aynpoeurc816ee.jpeg"><br><br>  Badoo mengembangkan beberapa aplikasi, dan masing-masing dari mereka adalah produk yang terpisah dengan karakteristik, manajemen, produk dan tim teknik sendiri.  Tapi kami semua bekerja bersama di kantor yang sama dan menyelesaikan masalah serupa. <br><br>  Pengembangan setiap proyek berbeda.  Basis kode tidak hanya dipengaruhi oleh kerangka waktu dan solusi produk yang berbeda, tetapi juga oleh visi pengembang.  Pada akhirnya, kami memperhatikan bahwa proyek-proyek tersebut memiliki fungsi yang sama, yang secara fundamental berbeda dalam implementasinya. <br><br>  Kemudian kami memutuskan untuk datang ke struktur yang akan memberi kami kesempatan untuk menggunakan kembali fitur di antara aplikasi.  Sekarang, alih-alih mengembangkan fungsionalitas dalam proyek individual, kami membuat komponen umum yang berintegrasi ke semua produk.  Jika Anda tertarik dengan bagaimana kami sampai pada ini, selamat datang di kucing. <a name="habracut"></a><br><br>  Tapi pertama-tama, mari kita memikirkan masalah, solusinya yang mengarah pada penciptaan komponen umum.  Ada beberapa di antaranya: <br><br><ul><li>  salin-tempel antar aplikasi; <br></li><li>  proses yang memasukkan tongkat ke roda; <br></li><li>  arsitektur proyek yang berbeda. <br></li></ul><br><img src="https://habrastorage.org/webt/wq/ls/ov/wqlsovroayg0xhqrwibqc37pv6y.png"><br><br>  <i>Artikel ini adalah versi teks dari laporan saya dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsConf 2019</a> , yang dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .</i> <br><br><h2>  Masalah: salin tempel </h2><br>  Beberapa waktu yang lalu, ketika pohon-pohon lebih buram, rumput lebih hijau, dan saya setahun lebih muda, kami sering mengalami situasi berikut. <br><br>  Ada pengembang, sebut saja dia Lesha.  Dia membuat modul keren untuk tugasnya, memberi tahu rekan-rekannya tentang hal itu dan meletakkannya di repositori untuk aplikasinya, tempat dia menggunakannya. <br><br>  Masalahnya adalah bahwa semua aplikasi kita berada di repositori yang berbeda. <br><br><img src="https://habrastorage.org/webt/-a/1f/zq/-a1fzqhp9m--jhxy1tcrmx7plwi.png"><br><br>  Pengembang Andrey saat ini hanya bekerja pada aplikasi lain di repositori yang berbeda.  Dia ingin menggunakan modul ini dalam tugasnya, yang mencurigakan mirip dengan yang digunakan Lesha.  Tetapi ada masalah: proses menggunakan kembali kode sepenuhnya debugged. <br><br>  Dalam situasi ini, Andrei akan menulis keputusannya (yang terjadi pada 80% kasus) atau menyalin-paste solusi Lyosha dan mengubah semua yang ada di dalamnya sehingga sesuai dengan aplikasi, tugas, atau suasana hatinya. <br><br><img src="https://habrastorage.org/webt/2e/nd/95/2end959nckg-szaxu_nwwwcqxtm.png"><br><br>  Setelah itu, Lesha dapat memperbarui modulnya dengan menambahkan perubahan pada kode untuk tugasnya.  Dia tidak tahu tentang versi lain dan hanya akan memperbarui repositori-nya. <br><br>  Situasi ini membawa beberapa masalah. <br><br>  Pertama, kami memiliki beberapa aplikasi, masing-masing dengan sejarah pengembangannya sendiri.  Ketika mengerjakan setiap aplikasi, tim produk sering menciptakan solusi yang sulit untuk dibawa ke struktur tunggal. <br><br>  Kedua, tim yang terpisah terlibat dalam proyek-proyek, yang berkomunikasi dengan buruk satu sama lain dan, oleh karena itu, jarang saling menginformasikan tentang pembaruan / penggunaan kembali satu atau modul lain. <br><br>  Ketiga, arsitektur aplikasi sangat berbeda: dari MVP ke MVI, dari aktivitas dewa ke aktivitas tunggal. <br><br>  Nah, "sorotan program": aplikasi berada di repositori yang berbeda, masing-masing dengan prosesnya sendiri. <br><br>  Pada awal perjuangan melawan masalah ini, kami menetapkan tujuan akhir: untuk menggunakan kembali praktik terbaik kami (baik logika dan UI) antara semua aplikasi. <br><br><h2>  Keputusan: kami menetapkan proses </h2><br>  Dari masalah di atas, dua terkait dengan proses: <br><br><ol><li>  Dua repositori yang berbagi proyek dengan tembok yang tidak bisa ditembus. <br></li><li>  Pisahkan tim tanpa komunikasi yang mapan dan persyaratan yang berbeda dari tim aplikasi produk. <br></li></ol><br>  Mari kita mulai dengan yang pertama: kita berurusan dengan dua repositori dengan versi modul yang sama.  Secara teoritis, kita bisa menggunakan git-subtree atau solusi serupa dan meletakkan modul proyek umum ke dalam repositori terpisah. <br><br><img src="https://habrastorage.org/webt/ro/q0/nr/roq0nrr9xuy2my8ajbsldfcismw.png"><br><br>  Masalah terjadi selama modifikasi.  Tidak seperti proyek open-source, yang memiliki API stabil dan didistribusikan melalui sumber eksternal, perubahan sering terjadi pada komponen internal yang merusak segalanya.  Saat menggunakan subtree, setiap migrasi semacam itu menjadi menyakitkan. <br><br>  Rekan-rekan saya dari tim iOS memiliki pengalaman serupa, dan ternyata itu tidak terlalu berhasil, seperti yang dibicarakan Anton Schukin di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konferensi Mobius</a> tahun lalu. <br><br>  Setelah mempelajari dan memahami pengalaman mereka, kami beralih ke satu repositori.  Semua aplikasi Android sekarang berada di satu tempat, yang memberi kita manfaat tertentu: <br><br><ul><li>  Anda dapat menggunakan kembali kode dengan aman menggunakan modul Gradle; <br></li><li>  kami berhasil menghubungkan rantai alat pada CI menggunakan satu infrastruktur untuk pembuatan dan pengujian; <br></li><li>  perubahan ini menghilangkan hambatan fisik dan mental antar tim, karena sekarang kita bebas menggunakan perkembangan dan solusi masing-masing. <br></li></ul><br>  Tentu saja, solusi ini juga memiliki kekurangan.  Kami memiliki proyek besar, yang kadang-kadang tidak tunduk pada IDE dan Gradle.  Masalahnya bisa diselesaikan sebagian oleh modul Load / Unload di Android Studio, tetapi sulit untuk menggunakannya jika Anda perlu bekerja secara bersamaan di semua aplikasi dan sering beralih. <br><br>  Masalah kedua - interaksi antar tim - terdiri dari beberapa bagian: <br><br><ul><li>  tim terpisah tanpa komunikasi yang mapan; <br></li><li>  distribusi tanggung jawab yang tidak jelas untuk modul-modul umum; <br></li><li>  persyaratan yang berbeda dari tim produk. <br></li></ul><br>  Untuk mengatasinya, kami membentuk tim yang terlibat dalam penerapan fungsi tertentu di setiap aplikasi: misalnya, obrolan atau pendaftaran.  Selain pengembangan, mereka juga bertanggung jawab untuk mengintegrasikan komponen-komponen ini ke dalam aplikasi. <br><br>  Tim produk sudah memiliki komponen yang ada di tangan mereka, meningkatkan dan menyesuaikannya dengan kebutuhan proyek tertentu. <br><br>  Dengan demikian, sekarang penciptaan komponen yang dapat digunakan kembali adalah bagian dari proses untuk seluruh perusahaan, dari tahap ide hingga awal produksi. <br><br><h2>  Solusi: perampingan arsitektur </h2><br>  Langkah kami selanjutnya untuk menggunakan kembali adalah merampingkan arsitektur.  Kenapa kita melakukan ini? <br><br>  Basis kode kami membawa warisan sejarah beberapa tahun pembangunan.  Seiring dengan waktu dan orang, pendekatan berubah.  Jadi kami menemukan diri kami dalam situasi dengan seluruh kebun binatang arsitektur, yang mengakibatkan masalah berikut: <br><br><ol><li>  Integrasi modul umum hampir lebih lambat daripada menulis yang baru.  Selain fitur fungsional, perlu untuk memasang dengan struktur komponen dan aplikasi. <br></li><li>  Pengembang yang harus beralih antar aplikasi sangat sering menghabiskan banyak waktu untuk menguasai pendekatan baru. <br></li><li>  Seringkali, pembungkus ditulis dari satu pendekatan ke yang lain, yang berjumlah setengah kode dalam integrasi modul. <br></li></ol><br>  Pada akhirnya, kami memutuskan pada pendekatan MVI, yang kami susun di perpustakaan MVICore kami ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> ).  Kami terutama tertarik pada salah satu fiturnya - pembaruan keadaan atom, yang selalu menjamin validitas.  Kami melangkah lebih jauh dan menggabungkan kondisi lapisan logis dan presentasi, mengurangi fragmentasi.  Dengan demikian, kita sampai pada struktur di mana satu-satunya entitas bertanggung jawab atas logika, dan tampilan hanya menampilkan model yang dibuat dari negara. <br><br><img src="https://habrastorage.org/webt/ze/4z/kr/ze4zkr0ecnm_x9il17ibon6uzkk.png"><br><br>  Pemisahan tanggung jawab terjadi melalui transformasi model antar level.  Berkat ini, kami mendapatkan bonus dalam bentuk kegunaan ulang.  Kami menghubungkan elemen-elemen dari luar, yaitu masing-masing tidak mencurigai ada yang lain - mereka hanya memberikan beberapa model dan bereaksi terhadap apa yang datang kepada mereka.  Ini memungkinkan Anda untuk mengeluarkan komponen dan menggunakannya di tempat lain dengan menulis adaptor untuk model mereka. <br><br>  Mari kita lihat contoh layar sederhana bagaimana tampilannya dalam kenyataan. <br><br><img src="https://habrastorage.org/webt/wm/0k/cs/wm0kcsuh1io0cr4cnil0ui11gme.png"><br><br>  Kami menggunakan antarmuka RxJava dasar untuk menunjukkan jenis elemen yang bekerja.  Input ditandai oleh antarmuka Konsumen &lt;T&gt;, output - ObservableSource &lt;T&gt;. <br><br><pre><code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// input = Consumer&lt;ViewModel&gt; // output = ObservableSource&lt;Event&gt; class View( val events: PublishRelay&lt;Event&gt; ): ObservableSource&lt;Event&gt; by events, Consumer&lt;ViewModel&gt; { val button: Button val textView: TextView init { button.setOnClickListener { events.accept(Event.ButtonClick) } } override fun accept(model: ViewModel) { textView.text = model.text } }</span></span></code> </pre> <br>  Dengan menggunakan antarmuka ini, kita dapat mengekspresikan View as Consumer &lt;ViewModel&gt; dan ObservableSource &lt;Event&gt;.  Perhatikan bahwa ViewModel hanya berisi keadaan layar dan tidak ada hubungannya dengan MVVM.  Setelah menerima model, kami dapat menunjukkan data dari itu, dan ketika kami mengklik tombol, kami mengirim acara, yang dikirim di luar. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// input = Consumer&lt;Wish&gt; // output = ObservableSource&lt;State&gt; class Feature: ReducerFeature&lt;Wish, State&gt;( initialState = State(counter = 0), reducer = ReducerImpl() ) { class ReducerImpl: Reducer&lt;Wish, State&gt; { override fun invoke(state: State, wish: Wish) = when (wish) { is Increment -&gt; state.copy(counter = state.counter + 1) } } }</span></span></code> </pre> <br>  Fitur sudah mengimplementasikan ObservableSource dan Konsumen untuk kami;  kita perlu mentransfer di sana keadaan awal (penghitung sama dengan 0) dan menunjukkan cara mengubah keadaan ini. <br><br>  Setelah transfer Wish, Reducer dipanggil, yang membuat yang baru berdasarkan pada status terakhir.  Selain Peredam, logika dapat dijelaskan oleh komponen lain.  Anda dapat mempelajari lebih lanjut tentang mereka di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Setelah membuat dua elemen, kita tetap harus menghubungkannya. <br><br><img width="250" src="https://habrastorage.org/webt/pq/kh/jp/pqkhjphpe4pvypmm5y8icqralhy.png" align="left"><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> eventToWish: (Event) -&gt; Wish = { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (it) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ButtonClick -&gt; Increment } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stateToModel: (State) -&gt; ViewModel = { ViewModel(text = state.counter.toString()) } Binder().apply { bind(view to feature using eventToWish) bind(feature to view using stateToModel) }</code> </pre> <br>  Pertama, kami menunjukkan bagaimana kami mengubah elemen dari satu jenis menjadi yang lain.  Jadi, ButtonClick menjadi Peningkatan, dan bidang penghitung dari Status masuk ke teks. <br><br>  Sekarang kita dapat membuat masing-masing rantai dengan transformasi yang diinginkan.  Untuk ini kami menggunakan Binder.  Ini memungkinkan Anda untuk membuat hubungan antara ObservableSource dan Konsumen, mengamati siklus hidup.  Dan semua ini dengan sintaks yang bagus.  Jenis koneksi ini membawa kita ke sistem yang fleksibel yang memungkinkan kita untuk menarik dan menggunakan elemen secara individual. <br><br>  MVICore-elements bekerja sangat baik dengan "kebun binatang" arsitektur kami setelah menulis pembungkus dari ObservableSource dan Konsumen.  Sebagai contoh, kita dapat membungkus metode Use Case dari Clean Architecture in Wish / State dan menggunakan dalam rantai alih-alih Fitur. <br><br><img src="https://habrastorage.org/webt/l3/x7/ee/l3x7eef1pxxq4qbl6epceicz_1a.png"><br><br><h2>  Komponen </h2><br>  Akhirnya, kita beralih ke komponen.  Seperti apa mereka? <br><br>  Pertimbangkan layar dalam aplikasi dan membaginya menjadi bagian-bagian yang logis. <br><br><img src="https://habrastorage.org/webt/s6/xb/mg/s6xbmgomehcdqao1psynv5mnnlc.png"><br><br>  Itu dapat dibedakan: <br><br><ul><li>  toolbar dengan logo dan tombol di bagian atas; <br></li><li>  kartu dengan profil dan logo; <br></li><li>  Bagian Instagram. <br></li></ul><br>  Masing-masing bagian ini adalah komponen yang dapat digunakan kembali dalam konteks yang sama sekali berbeda.  Jadi, bagian Instagram dapat menjadi bagian dari pengeditan profil di aplikasi lain. <br><br><img src="https://habrastorage.org/webt/o_/yh/c7/o_yhc7jqyzwma6l4nljmf2jasuk.png"><br><br>  Dalam kasus umum, komponen adalah beberapa tampilan, elemen logika dan komponen bersarang di dalamnya, disatukan oleh fungsi umum.  Dan segera muncul pertanyaan: bagaimana cara mengumpulkan mereka menjadi struktur yang didukung? <br><br>  Masalah pertama yang kami temui adalah bahwa MVICore membantu membuat dan mengikat elemen, tetapi tidak menawarkan struktur yang sama.  Ketika menggunakan kembali elemen dari modul umum, tidak jelas di mana harus menempatkan potongan-potongan ini: di dalam bagian umum atau di sisi aplikasi? <br><br>  Dalam kasus umum, kami pasti tidak ingin memberikan potongan aplikasi yang tersebar.  Idealnya, kami mengupayakan beberapa jenis struktur yang akan memungkinkan kami untuk mendapatkan dependensi dan mengumpulkan komponen secara keseluruhan dengan siklus hidup yang diinginkan. <br><br>  Awalnya, kami membagi komponen menjadi layar.  Koneksi elemen terjadi di sebelah pembuatan wadah DI untuk aktivitas atau fragmen.  Wadah ini sudah tahu tentang semua dependensi, memiliki akses ke View dan siklus hidup. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SomeScopedComponent : ScopedComponent&lt;SomeComponent&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: SomeComponent { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DaggerSomeComponent.builder() .build() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> SomeComponent.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Array&lt;Disposable&gt; = arrayOf( Binder().apply { bind(feature().news to otherFeature()) bind(feature() to view()) } ) }</code> </pre> <br>  Masalah dimulai di dua tempat sekaligus: <br><br><ol><li>  DI mulai bekerja dengan logika, yang menyebabkan deskripsi seluruh komponen dalam satu kelas. <br></li><li>  Karena wadah dilampirkan ke Aktivitas atau Fragmen dan menjelaskan setidaknya seluruh layar, ada banyak elemen di layar / wadah tersebut, yang diterjemahkan menjadi sejumlah besar kode untuk menghubungkan semua dependensi layar ini. <br></li></ol><br>  Memecahkan masalah secara berurutan, kami mulai dengan menempatkan logika dalam komponen yang terpisah.  Jadi, kami dapat mengumpulkan semua Fitur di dalam komponen ini dan berkomunikasi dengan View melalui input dan output.  Dari sudut pandang antarmuka, ini terlihat seperti elemen MVICore biasa, tetapi pada saat yang sama dibuat dari beberapa yang lain. <br><br><img src="https://habrastorage.org/webt/bx/xf/ih/bxxfihgylnpbclxg3o9pcem9xr8.png"><br><br>  Setelah menyelesaikan masalah ini, kami berbagi tanggung jawab untuk menghubungkan elemen-elemen tersebut.  Tapi kami masih berbagi komponen di layar, yang jelas-jelas tidak ada di tangan kami, menghasilkan banyak ketergantungan di satu tempat. <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Scope</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> params: ScreenParams, news: NewsRelay, <span class="hljs-meta"><span class="hljs-meta">@OnDisposeAction</span></span> onDisposeAction: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>, globalFeature: GlobalFeature, conversationControlFeature: ConversationControlFeature, messageSyncFeature: MessageSyncFeature, conversationInfoFeature: ConversationInfoFeature, conversationPromoFeature: ConversationPromoFeature, messagesFeature: MessagesFeature, messageActionFeature: MessageActionFeature, initialScreenFeature: InitialScreenFeature, initialScreenExplanationFeature: InitialScreenExplanationFeature?, errorFeature: ErrorFeature, conversationInputFeature: ConversationInputFeature, sendRegularFeature: SendRegularFeature, sendContactForCreditsFeature: SendContactForCreditsFeature, screenEventTrackingFeature: ScreenEventTrackingFeature, messageReadFeature: MessageReadFeature?, messageTimeFeature: MessageTimeFeature?, photoGalleryFeature: PhotoGalleryFeature?, onlineStatusFeature: OnlineStatusFeature?, favouritesFeature: FavouritesFeature?, isTypingFeature: IsTypingFeature?, giftStoreFeature: GiftStoreFeature?, messageSelectionFeature: MessageSelectionFeature?, reportingFeature: ReportingFeature?, takePhotoFeature: TakePhotoFeature?, giphyFeature: GiphyFeature, goodOpenersFeature: GoodOpenersFeature?, matchExpirationFeature: MatchExpirationFeature, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pushIntegration: PushIntegration ) : AbstractMviComponent&lt;UiEvent, States&gt;(</code> </pre> <br>  Solusi yang tepat dalam situasi ini adalah memecah komponen.  Seperti yang kita lihat di atas, setiap layar terdiri dari banyak elemen logis yang dapat kita bagi menjadi beberapa bagian independen. <br><br>  Setelah sedikit refleksi, kami sampai pada struktur pohon dan, secara naif membangunnya dari komponen yang ada, kami mendapat skema ini: <br><br><img src="https://habrastorage.org/webt/el/yl/v1/elylv1elwdrgyoqdamiepx0lleo.png"><br><br>  Tentu saja, mempertahankan sinkronisasi dua pohon (dari Tampilan dan dari logika) hampir tidak mungkin.  Namun, jika komponen bertanggung jawab untuk menampilkan View-nya, kami dapat menyederhanakan skema ini.  Setelah mempelajari solusi yang telah dibuat, kami memikirkan kembali pendekatan kami, dengan mengandalkan RIB Uber. <br><br><img src="https://habrastorage.org/webt/sy/xt/kd/syxtkdw8uiusbnrneqna1-bqfbe.png"><br><br>  Gagasan di balik pendekatan ini sangat mirip dengan dasar-dasar MVICore.  RIB adalah semacam "kotak hitam", komunikasi yang terjadi melalui antarmuka yang didefinisikan secara ketat dari dependensi (yaitu, input dan output).  Terlepas dari kerumitan nyata mendukung antarmuka seperti itu dalam produk berulang yang cepat, kami mendapatkan peluang besar untuk menggunakan kembali kode. <br><br>  Jadi, dibandingkan dengan iterasi sebelumnya, kita mendapatkan: <br><br><ul><li>  logika dikemas di dalam komponen; <br></li><li>  dukungan untuk bersarang, yang memungkinkan untuk membagi layar menjadi beberapa bagian; <br></li><li>  interaksi dengan komponen lain melalui antarmuka yang ketat dari input / output dengan dukungan untuk MVICore; <br></li><li>  kompilasi waktu aman dari dependensi komponen (mengandalkan Dagger sebagai DI). <br></li></ul><br>  Tentu saja, ini jauh dari semua.  Repositori di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> berisi deskripsi yang lebih terperinci dan terkini. <br><br>  Dan di sini kita memiliki dunia yang sempurna.  Ini memiliki komponen dari mana kita dapat membangun pohon yang sepenuhnya dapat digunakan kembali. <br><br>  Tapi kita hidup di dunia yang tidak sempurna. <br><br><h2>  Selamat datang di kenyataan! </h2><br>  Di dunia yang tidak sempurna, ada banyak hal yang harus kita hadapi.  Kami khawatir tentang hal berikut: <br><br><ul><li>  fungsi yang berbeda: meskipun semua penyatuan, kami masih berurusan dengan produk individu dengan persyaratan yang berbeda; <br></li><li>  dukungan: bagaimana tanpa fungsi baru di bawah uji A / B? <br></li><li>  Legacy (semua yang ditulis sebelum arsitektur baru kami). <br></li></ul><br>  Kompleksitas solusi meningkat secara eksponensial, karena setiap aplikasi menambahkan sesuatu sendiri ke komponen umum. <br><br>  Pertimbangkan proses pendaftaran sebagai contoh komponen umum yang terintegrasi ke dalam aplikasi.  Secara umum, pendaftaran adalah rangkaian layar dengan tindakan yang memengaruhi seluruh aliran.  Setiap aplikasi memiliki layar berbeda dan UI sendiri.  Tujuan utamanya adalah membuat komponen yang dapat digunakan kembali secara fleksibel, yang juga akan membantu kita memecahkan masalah dari daftar di atas. <br><br><img src="https://habrastorage.org/webt/22/v6/cd/22v6cdpd9uf8ebuxcdo0j4mgc5a.png"><br><br><h3>  Persyaratan lain-lain </h3><br>  Setiap aplikasi memiliki variasi registrasi yang unik, baik dari sisi logika dan dari sisi UI.  Oleh karena itu, kami mulai menggeneralisasi fungsionalitas dalam komponen dengan minimum: dengan mengunduh data dan merutekan seluruh aliran. <br><br><img src="https://habrastorage.org/webt/nv/lr/1b/nvlr1bpwh_s1bw0lrlfk0py2zww.png"><br><br>  Wadah seperti itu mentransfer data ke aplikasi dari server, yang diubah menjadi layar jadi dengan logika.  Satu-satunya persyaratan adalah bahwa layar yang diteruskan ke wadah seperti itu harus memenuhi dependensi untuk berinteraksi dengan logika dari seluruh aliran. <br><br>  Setelah melakukan trik ini dengan beberapa aplikasi, kami perhatikan bahwa logika layar hampir sama.  Di dunia yang ideal, kami akan membuat logika umum dengan menyesuaikan Tampilan.  Pertanyaannya adalah bagaimana menyesuaikannya. <br><br>  Seperti yang dapat Anda ingat dari deskripsi MVICore, baik View maupun Feature didasarkan pada antarmuka dari ObservableSource dan Consumer.  Menggunakannya sebagai abstraksi, kita dapat mengganti implementasi tanpa mengubah bagian utama. <br><br><img src="https://habrastorage.org/webt/ay/ox/lo/ayoxlo24e49tsprdsdxplsdv4yo.png"><br><br>  Jadi kami menggunakan kembali logika dengan membagi UI.  Akibatnya, dukungan menjadi jauh lebih nyaman. <br><br><h3>  Dukungan </h3><br>  Pertimbangkan uji A / B untuk variasi elemen visual.  Dalam hal ini, logika kami tidak berubah, yang memungkinkan kami untuk mengganti implementasi tampilan lain untuk antarmuka yang ada dari ObservableSource dan Konsumen. <br><br><img src="https://habrastorage.org/webt/ag/qg/vm/agqgvmwnzn_cztnwovas8jk9ydw.png"><br><br>  Tentu saja, terkadang persyaratan baru bertentangan dengan logika yang sudah tertulis.  Dalam hal ini, kami selalu dapat kembali ke skema asli, tempat aplikasi memasok seluruh layar.  Bagi kami ini semacam "kotak hitam", dan tidak masalah bagi wadah apa yang mereka berikan padanya, asalkan antar mukanya dihormati. <br><br><h3>  Integrasi </h3><br>  Seperti yang ditunjukkan oleh praktik, sebagian besar aplikasi menggunakan Activity sebagai unit dasar, alat komunikasi yang sudah lama dikenal.  Yang harus kami lakukan adalah mempelajari cara membungkus komponen dalam Aktivitas dan meneruskan data melalui input dan output.  Ternyata, pendekatan ini berfungsi baik dengan fragmen. <br><br>  Untuk aplikasi aktivitas tunggal, tidak ada banyak perubahan.  Hampir semua kerangka kerja menawarkan elemen dasar mereka di mana komponen RIB memungkinkan mereka untuk dibungkus. <br><br><h2>  Pada akhirnya </h2><br>  Setelah melewati tahap ini, kami telah secara signifikan meningkatkan persentase penggunaan kembali kode antara proyek-proyek perusahaan kami.  Saat ini, jumlah komponen mendekati 100, dan sebagian besar dari mereka menerapkan fungsionalitas untuk beberapa aplikasi sekaligus. <br><br>  Pengalaman kami menunjukkan bahwa: <br><br><ul><li>  Meskipun kompleksitas yang semakin meningkat dalam merancang komponen umum, mengingat persyaratan aplikasi yang berbeda, dukungan mereka jauh lebih mudah dalam jangka panjang; <br></li><li>  membangun komponen secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terpisah satu sama lain</a> , kami sangat menyederhanakan integrasi mereka ke dalam aplikasi yang dibangun berdasarkan prinsip yang berbeda; <br></li><li>  revisi proses, ditambah dengan penekanan pada pengembangan dan dukungan komponen, memiliki efek positif pada kualitas fungsionalitas keseluruhan. <br></li></ul><br>  Rekan saya Zsolt Kocsi sebelumnya menulis tentang MVICore dan ide-ide di baliknya.  Saya sangat merekomendasikan membaca artikelnya, yang telah kami terjemahkan di blog kami ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3</a> ). <br><br>  Tentang RIB, Anda dapat membaca artikel asli dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Uber</a> .  Dan untuk pengetahuan praktis, saya sarankan mengambil beberapa pelajaran <a href="">dari kami</a> (dalam bahasa Inggris). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466049/">https://habr.com/ru/post/id466049/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466033/index.html">Bagaimana cara melibatkan tim dalam pencarian ide dan mendapatkan lebih banyak daripada ide</a></li>
<li><a href="../id466039/index.html">Perpustakaan PHP untuk e-commerce: bekerja dengan ATOL dan Payture, parsing kode GS1 dan tugas lainnya</a></li>
<li><a href="../id466041/index.html">Acara offline pertama dari Lingkaran Pengembang Facebook: komunitas Moskow - Acara Peluncuran</a></li>
<li><a href="../id466045/index.html">Cara merevitalisasi merek: mendongeng yang berhasil</a></li>
<li><a href="../id466047/index.html">Merancang toko online. Bagian 3. Halaman depan dan katalog</a></li>
<li><a href="../id466051/index.html">Otomatis profiling Java meetup 10/09</a></li>
<li><a href="../id466053/index.html">Representasi perusahaan IT Rusia di Singapura: mengapa tidak?</a></li>
<li><a href="../id466059/index.html">Buku "Desain Berpikir. Dari wawasan ke produk dan pasar baru ”</a></li>
<li><a href="../id466065/index.html">Intisari berita PostgreSQL. Edisi No.17</a></li>
<li><a href="../id466067/index.html">Screensaver yang mempesona untuk Kodi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>