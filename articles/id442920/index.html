<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’´ ğŸ’†ğŸ¿ ğŸ—ƒï¸ Coroutines :: pengalaman praktis ğŸ‘Ÿ ğŸ…±ï¸ ğŸ¤¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini saya akan berbicara tentang cara kerja coroutine dan cara membuatnya. Pertimbangkan aplikasi dalam eksekusi paralel berurutan. Mari ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Coroutines :: pengalaman praktis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/442920/"> Dalam artikel ini saya akan berbicara tentang cara kerja coroutine dan cara membuatnya.  Pertimbangkan aplikasi dalam eksekusi paralel berurutan.  Mari kita bicara tentang penanganan kesalahan, debugging, dan cara untuk menguji coroutine.  Pada akhirnya, saya akan meringkas dan berbicara tentang kesan yang tersisa setelah menerapkan pendekatan ini. <br><br>  Artikel ini disiapkan berdasarkan bahan laporan saya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MBLT DEV 2018</a> , di akhir posting - tautan ke video. <br><br><h2>  Gaya yang konsisten </h2><br><img src="https://habrastorage.org/webt/ke/8z/tu/ke8ztulkufchujj6k5pxutqtigw.png"><a name="habracut"></a><br>  <i>Fig.</i>  <i>2.1</i> <br><br>  Apa tujuan para pengembang Corutin?  Mereka ingin pemrograman asinkron menjadi sesederhana mungkin.  Tidak ada yang lebih mudah daripada mengeksekusi kode "baris demi baris" menggunakan konstruksi sintaksis bahasa: try-catch-akhirnya, loop, pernyataan kondisional, dan sebagainya. <br><br>  Mari kita pertimbangkan dua fungsi.  Masing-masing dieksekusi pada utasnya sendiri (Gbr. 2.1).  Yang pertama dieksekusi pada utas <b>B</b> dan mengembalikan beberapa hasil <b>dataB</b> , maka kita perlu meneruskan hasil ini ke fungsi kedua, yang mengambil <b>dataB</b> sebagai argumen dan sudah berjalan pada utas <b>A.</b>  Dengan coroutine, kita dapat menulis kode seperti yang ditunjukkan pada gambar.  2.1.  Pertimbangkan cara untuk mencapai ini. <br><br>  Fungsi <b>longOpOnB, longOpOnA</b> - yang disebut fungsi <i>suspend</i> , sebelum <b>untaiannya</b> dibebaskan, dan setelah menyelesaikan pekerjaannya, ia menjadi sibuk kembali. <br><br>  Agar kedua fungsi ini benar-benar dilakukan dalam utas berbeda dibandingkan dengan yang disebut, sambil mempertahankan gaya penulisan kode yang â€œkonsistenâ€, kita harus membenamkannya dalam konteks coroutine. <br><br>  Ini dilakukan dengan membuat coroutine menggunakan apa yang disebut Coroutine Builder.  Dalam gambar, ini <i>diluncurkan</i> , tetapi ada yang lain, misalnya, <i>async</i> , <i>runBlocking</i> .  Saya akan membicarakannya nanti. <br><br>  Argumen terakhir adalah blok kode yang dieksekusi dalam konteks coroutine: memanggil fungsi suspend, yang berarti bahwa semua perilaku di atas hanya mungkin dalam konteks coroutine atau dalam fungsi suspend lainnya. <br><br>  Ada parameter lain dalam metode Coroutine Builder, misalnya, jenis peluncuran, utas di mana blok akan dieksekusi, dan lainnya. <br><br><h2>  Manajemen siklus hidup </h2><br>  Coroutine Builder memberi kita nilai balik sebagai nilai balik - subkelas kelas <i>Pekerjaan</i> (Gbr.2.2).  Dengan itu, kita dapat mengatur siklus hidup korutin. <br><br>  Mulai dengan metode <i>start ()</i> , batalkan dengan metode <i>cancel ()</i> , tunggu sampai pekerjaan selesai menggunakan metode <i>join (</i> ), berlangganan ke acara penyelesaian pekerjaan dan banyak lagi. <br><br><img src="https://habrastorage.org/webt/os/bf/9j/osbf9jvwmvqtlidv_ugwrfbk-yc.png"><br>  <i>Fig.</i>  <i>2.2</i> <br><br><h2>  Aliran berubah </h2><br>  Anda dapat mengubah aliran eksekusi coroutine dengan mengubah elemen konteks coroutine yang bertanggung jawab untuk penjadwalan.  (Gbr. 2.3) <br><br>  Misalnya, corutin 1 akan dijalankan di utas <i>UI</i> , sedangkan corutin 2 di utas diambil dari kumpulan <i>Dispatchers.IO</i> . <br><br><img src="https://habrastorage.org/webt/oe/9e/o1/oe9eo1ynqwdskvi-laxuunj-xkk.png"><br>  <i>Gbr.2.3</i> <br><br>  Pustaka coroutine juga menyediakan fungsi penangguhan <i>withContext (CoroutineContext)</i> , yang dengannya Anda dapat beralih di antara utas dalam konteks coroutine.  Jadi, melompat di antara utas bisa sangat sederhana: <br><br><img src="https://habrastorage.org/webt/ga/ca/im/gacaimxsxh_bjcxjweywrc8kstw.png"><br>  <i>Fig.</i>  <i>2.4.</i> <br><br>  Kami memulai coroutine kami pada utas UI 1 â†’ tampilkan indikator beban â†’ beralih ke utas kerja 2, membebaskan utas utama â†’ kami melakukan operasi panjang di sana yang tidak dapat dilakukan pada utas UI â†’ mengembalikan hasilnya kembali ke utas UI 3 â†’ dan sudah bekerja di sana dengan itu, menampilkan data yang diterima dan menyembunyikan indikator pemuatan. <br><br>  Sejauh ini terlihat cukup nyaman, teruskan. <br><br><h2>  Menunda Fungsi </h2><br>  Pertimbangkan kerja corutin pada contoh kasus yang paling umum - bekerja dengan permintaan jaringan menggunakan pustaka Retrofit 2. <br><br>  Hal pertama yang perlu kita lakukan adalah mengubah <b>panggilan balik</b> menjadi fungsi <i>menangguhkan</i> untuk memanfaatkan fitur coroutine: <br><br><img src="https://habrastorage.org/webt/hs/kk/ue/hskkuekq2frbocs_hd-oxsz8k7o.png"><br>  <i>Fig.</i>  <i>2.5</i> <br><br>  Untuk mengontrol keadaan coroutine, perpustakaan menyediakan fungsi dari bentuk <i>suspendXXXXCoroutine</i> , yang menyediakan argumen yang mengimplementasikan antarmuka <i>Lanjutan</i> , menggunakan metode <i>resumeWithException</i> dan <i>melanjutkan</i> yang masing-masing kita dapat melanjutkan coroutine jika terjadi kesalahan dan kesuksesan. <br><br>  Selanjutnya, kita akan mencari tahu apa yang terjadi ketika metode resumeWithException dipanggil, dan pertama, pastikan bahwa kita perlu membatalkan panggilan permintaan jaringan. <br><br><h2>  Menunda fungsi.  Pembatalan panggilan </h2><br>  Untuk membatalkan panggilan dan tindakan lain yang terkait dengan pelepasan sumber daya yang tidak digunakan, saat menerapkan fungsi penangguhan, Anda dapat menggunakan metode <i>suspendCancellableCoroutine</i> yang keluar dari kotak (Gbr. 2.6).  Di sini, argumen blok sudah mengimplementasikan antarmuka <i>CancellableContinuation</i> , salah satu metode tambahan di antaranya adalah <i>invokeOnCancellation</i> , yang memungkinkan Anda mendaftar untuk kesalahan atau acara pembatalan coroutine yang berhasil.  Oleh karena itu, di sini juga perlu untuk membatalkan pemanggilan metode. <br><br><img src="https://habrastorage.org/webt/59/ut/hw/59uthwhyrpuk2-hzm6c2rax0vzk.png"><br>  <i>Fig.</i>  <i>2.6</i> <br><br><h3>  Tampilan perubahan di UI </h3><br>  Sekarang fungsi tunda telah disiapkan untuk permintaan jaringan, Anda dapat menggunakan panggilannya di utas UI coroutine sebagai berurutan, sementara selama pelaksanaan permintaan, aliran akan bebas, dan aliran retrofit akan digunakan untuk menjalankan permintaan. <br><br>  Dengan demikian, kami menerapkan perilaku asinkron sehubungan dengan aliran UI, tetapi kami menulisnya dengan gaya yang konsisten (Gbr. 2.6). <br><br>  Jika setelah menerima jawaban Anda perlu melakukan kerja keras, misalnya, menulis data yang diterima ke database, maka fungsi ini, seperti yang telah ditunjukkan, dapat dengan mudah dilakukan menggunakan <i>withContext</i> pada kumpulan aliran back-stream dan melanjutkan eksekusi pada UI tanpa satu baris kode. <br><br><img src="https://habrastorage.org/webt/ks/qk/g4/ksqkg48x7gjja00x6hii4cpc1uo.png"><br>  <i>Fig.</i>  <i>2.7</i> <br><br>  Sayangnya, ini tidak semua yang kita butuhkan untuk pengembangan aplikasi.  Pertimbangkan penanganan kesalahan. <br><br><h3>  Menangani kesalahan: coba-tangkap-akhirnya.  Batalkan Coroutine: PembatalanException </h3><br>  Pengecualian yang tidak tertangkap di dalam coroutine dianggap tidak tertangani dan dapat menyebabkan aplikasi mogok.  Selain situasi normal, pengecualian dilemparkan dengan melanjutkan coroutine menggunakan metode <i>resumeWithException</i> pada baris yang sesuai dari panggilan ke fungsi menangguhkan.  Dalam hal ini, pengecualian yang dilewatkan sebagai argumen dilemparkan tidak berubah.  (Gbr. 2.8) <br><br><img src="https://habrastorage.org/webt/hm/sv/f0/hmsvf0yzwobbhf3mlv_ce8xy2l8.png"><br>  <i>Fig.</i>  <i>2.8</i> <br><br>  Untuk penanganan pengecualian, standar coba tangkap akhirnya bahasa konstruksi tersedia.  Sekarang kode yang dapat menampilkan kesalahan di UI mengambil bentuk berikut: <br><br><img src="https://habrastorage.org/webt/ce/53/hp/ce53hpazfknfd3962fn0wvfv8x8.png"><br>  <i>Fig.</i>  <i>2.9</i> <br><br>  Dalam kasus pembatalan coroutine, yang dapat dicapai dengan memanggil metode Job # cancel, <i>PembatalanException</i> dilemparkan.  Pengecualian ini ditangani secara default dan tidak menyebabkan crash atau konsekuensi negatif lainnya. <br><br>  Namun, ketika menggunakan konstruksi <b>coba / tangkap</b> , itu akan ditangkap di <b>blok tangkap</b> , dan Anda harus memperhitungkannya dalam kasus jika Anda ingin menangani hanya situasi yang benar-benar "salah".  Misalnya, penanganan kesalahan di UI saat dimungkinkan untuk "membatalkan" permintaan atau kesalahan logging disediakan.  Dalam kasus pertama, kesalahan akan ditampilkan kepada pengguna, meskipun sebenarnya tidak ada, dan yang kedua, pengecualian yang tidak berguna akan dicatat dan mengacaukan laporan. <br><br>  Untuk mengabaikan situasi pembatalan coroutine, Anda perlu sedikit memodifikasi kode: <br><br><img src="https://habrastorage.org/webt/cw/9p/yf/cw9pyfzj3sbzqrpz49b0ochntjq.png"><br>  <i>Fig.</i>  <i>2.10</i> <br><br><h2>  Galat saat masuk </h2><br>  Pertimbangkan pengecualian jejak tumpukan pengecualian. <br><br>  Jika Anda melempar pengecualian langsung di blok kode coroutine (Gbr. 2.11), maka jejak tumpukan terlihat rapi, dengan hanya beberapa panggilan dari coroutine, ini dengan benar menunjukkan garis dan informasi tentang pengecualian.  Dalam hal ini, Anda dapat dengan mudah memahami dari jejak tumpukan di mana tepatnya, di kelas mana dan di mana fungsi pengecualian dilemparkan. <br><br><img src="https://habrastorage.org/webt/70/1q/h7/701qh72uei7qbt8jpf9kegbnavy.png"><br>  <i>Fig.</i>  <i>2.11</i> <br><br>  Namun, pengecualian yang diteruskan ke metode <i>resumeWithException</i> dari fungsi <i>suspend</i> , sebagai aturan, tidak mengandung informasi tentang coroutine di mana itu terjadi.  Misalnya (Gbr. 2.12), jika Anda melanjutkan coroutine dari fungsi penangguhan yang diterapkan sebelumnya dengan pengecualian yang sama seperti pada contoh sebelumnya, maka jejak tumpukan tidak akan memberikan informasi tentang di mana harus secara spesifik mencari kesalahan. <br><br><img src="https://habrastorage.org/webt/wd/41/xr/wd41xr4kb6f-luf61_cvcmxetr4.png"><br>  <i>Fig.</i>  <i>2.12</i> <br><br>  Untuk memahami coroutine yang dilanjutkan dengan pengecualian, Anda dapat menggunakan <i>elemen</i> konteks <i>CoroutineName</i> .  (Gbr. 2.13) <br><br>  Elemen <i>CoroutineName</i> digunakan untuk debugging, meneruskan nama coroutine ke dalamnya, Anda dapat mengekstraknya dalam fungsi-fungsi yang ditangguhkan dan, misalnya, menambahkan pesan pengecualian.  Artinya, setidaknya akan menjadi jelas di mana harus mencari kesalahan. <br><br>  Pendekatan ini hanya akan berfungsi jika fungsi menangguhkan dikecualikan dari ini: <br><br><img src="https://habrastorage.org/webt/5u/xs/st/5uxsstlugngflzdlcrarrfws1d4.png"><br>  <i>Fig.</i>  <i>2.13</i> <br><br><h3>  Galat saat masuk.  ExceptionHandler </h3><br>  Untuk mengubah logging pengecualian untuk coroutine tertentu, Anda bisa mengatur ExceptionHandler Anda sendiri, yang merupakan salah satu elemen dari konteks coroutine.  (Gbr. 2.14) <br><br>  Pawang harus mengimplementasikan antarmuka <i>CoroutineExceptionHandler</i> .  Menggunakan operator + yang diganti untuk konteks coroutine, Anda dapat mengganti handler pengecualian standar dengan milik Anda.  Pengecualian yang tidak tertangani akan jatuh ke dalam metode <i>handleException</i> , di mana Anda dapat melakukan apa pun yang Anda perlukan dengannya.  Misalnya, abaikan sepenuhnya.  Ini akan terjadi jika Anda membiarkan pawang kosong atau menambahkan informasi Anda sendiri: <br><br><img src="https://habrastorage.org/webt/c_/1w/3y/c_1w3ya8lagmhplbeeq9ajvtbws.png"><br>  <i>Fig.</i>  <i>2.14</i> <br><br>  Mari kita lihat seperti apa tampilan dari pengecualian kita: <br><br><ol><li>  Anda perlu mengingat tentang <i>PembatalanException</i> , yang ingin kami abaikan. </li><li>  Tambahkan log Anda sendiri. </li><li>  Ingat tentang perilaku default, yang meliputi pencatatan dan penghentian aplikasi, jika tidak pengecualian akan "menghilang" dan tidak akan jelas apa yang terjadi. </li></ol><br>  Sekarang, untuk kasus pengecualian, daftar tumpukan jejak akan dikirim ke logcat dengan informasi tambahan: <br><br><img src="https://habrastorage.org/webt/mr/jl/sc/mrjlscj8bilbyancdfmygexqlki.png"><br>  <i>Fig.</i>  <i>2.15</i> <br><br><h2>  Eksekusi paralel.  async </h2><br>  Pertimbangkan operasi paralel fungsi penangguhan. <br><br>  <i>Async</i> paling cocok untuk mengatur hasil paralel dari berbagai fungsi.  Async, seperti <i>peluncuran</i> - Coroutine Builder.  Kemudahannya adalah bahwa, menggunakan metode <i>await ()</i> , ia mengembalikan data jika berhasil atau melempar pengecualian yang telah terjadi selama eksekusi coroutine.  Metode menunggu akan menunggu coroutine selesai, jika belum selesai, jika tidak akan segera mengembalikan hasil pekerjaan.  Perhatikan bahwa menunggu adalah fungsi penangguhan, dan karena itu tidak dapat dijalankan di luar konteks coroutine atau fungsi penangguhan lainnya. <br><br>  Menggunakan async, mendapatkan data dari dua fungsi secara paralel akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/w1/-t/hv/w1-thvudknznjyexdz7_c5rb0w8.png"><br>  <i>Fig.</i>  <i>2.16</i> <br><br>  Bayangkan kita dihadapkan dengan tugas mendapatkan data dari dua fungsi secara paralel.  Kemudian, Anda perlu menggabungkan dan menampilkannya.  Jika terjadi kesalahan, Anda perlu menggambar UI, membatalkan semua permintaan saat ini.  Kasus seperti ini sering ditemukan dalam praktik. <br><br>  Dalam hal ini, kesalahan harus ditangani sebagai berikut: <br><br><ol><li>  Bawa penanganan kesalahan di dalam masing-masing async-corutin. </li><li>  Jika terjadi kesalahan, batalkan semua coroutine.  Untungnya, untuk ini dimungkinkan untuk menentukan pekerjaan orang tua, setelah pembatalan semua anak-anaknya dibatalkan. </li><li>  Kami datang dengan implementasi tambahan untuk memahami apakah semua data telah berhasil dimuat.  Misalnya, kami menganggap bahwa jika menunggu dikembalikan nol, kesalahan terjadi saat menerima data. </li></ol><br>  Dengan semua ini dalam pikiran, menerapkan coroutine orangtua menjadi sedikit lebih rumit.  Implementasi async-corutin juga rumit: <br><br><img src="https://habrastorage.org/webt/wy/xe/ny/wyxenyk2quyek7zmhz4ze1dq5sw.png"><br>  <i>Fig.</i>  <i>2.17</i> <br><br>  Pendekatan ini bukan satu-satunya yang mungkin.  Misalnya, Anda bisa mengimplementasikan eksekusi paralel dengan penanganan kesalahan menggunakan <i>ExceptionHandler</i> atau <i>SupervisorJob</i> . <br><br><h2>  Coroutines bersarang </h2><br>  Mari kita lihat karya coroutine bersarang. <br><br>  Secara default, coroutine bersarang dibuat menggunakan lingkup eksternal dan mewarisi konteksnya.  Akibatnya, coroutine yang bersarang menjadi anak perempuan, dan orang tua eksternal. <br><br>  Jika kita membatalkan coroutine eksternal, coroutine bersarang yang dibuat dengan cara ini, yang digunakan dalam contoh sebelumnya, juga akan dibatalkan.  Ini juga akan berguna ketika meninggalkan layar ketika Anda harus membatalkan permintaan saat ini.  Selain itu, orang tua corutin akan selalu menunggu penyelesaian putri. <br><br>  Anda dapat membuat coroutine yang independen dari eksternal menggunakan lingkup global.  Dalam hal ini, ketika coroutine eksternal dibatalkan, yang bersarang akan terus bekerja seolah-olah tidak ada yang terjadi: <br><br><img src="https://habrastorage.org/webt/fj/pu/_y/fjpu_yzyp3z0ttuypjypxu2oav4.png"><br>  <i>Fig.</i>  <i>2.18</i> <i><br></i> <br>  Anda dapat membuat anak dari coroutine bersarang global dengan mengganti elemen konteks dengan kunci <i>Pekerjaan</i> dengan pekerjaan induk, atau Anda dapat sepenuhnya menggunakan konteks coroutine induk.  Tetapi dalam hal ini perlu diingat bahwa semua elemen induk coroutine diambil alih: kumpulan thread, pengendali pengecualian, dan sebagainya: <br><br><img src="https://habrastorage.org/webt/hh/wd/jx/hhwdjxobjkl0arojj0sh6ufii7m.png"><br>  <i>Fig.</i>  <i>2.19</i> <br><br>  Sekarang sudah jelas bahwa jika Anda menggunakan coroutine dari luar, Anda harus memberi mereka kemampuan untuk menginstal instance pekerjaan atau konteks induk.  Dan pengembang perpustakaan perlu mempertimbangkan kemungkinan menginstalnya sebagai anak, yang menyebabkan ketidaknyamanan. <br><br><h2>  Breakpoints </h2><br>  Coroutine mempengaruhi tampilan nilai objek dalam mode debug.  Jika Anda meletakkan breakpoint di dalam coroutine berikutnya pada fungsi <b>logData</b> , maka ketika itu menyala, kita melihat bahwa semuanya baik-baik saja di sini dan nilainya ditampilkan dengan benar: <br><br><img src="https://habrastorage.org/webt/hp/t-/oc/hpt-ockcfqvrlzej2ncx0v2cboy.png"><br>  <i>Fig.</i>  <i>2.20</i> <br><br>  Sekarang dapatkan <b>dataA</b> menggunakan coroutine bersarang, meninggalkan breakpoint pada <b>logData</b> : <br><br><img src="https://habrastorage.org/webt/bq/0j/cb/bq0jcbefwitj0ss-bhahf8_cjy8.png"><br>  <i>Fig.</i>  <i>2.21</i> <br><br>  Mencoba memperluas blok ini untuk mencoba menemukan nilai yang diinginkan gagal.  Dengan demikian, debugging di hadapan fungsi-menangguhkan menjadi sulit. <br><br><h2>  Pengujian unit </h2><br>  Pengujian unit cukup mudah.  Anda dapat menggunakan Coroutine Builder <i>runBlocking untuk ini</i> .  <i>runBlocking</i> memblokir utas sampai semua coroutine bersarangnya selesai, yang persis seperti yang Anda butuhkan untuk pengujian. <br><br>  Sebagai contoh, jika diketahui bahwa suatu tempat di dalam metode coroutine digunakan untuk mengimplementasikannya, maka untuk menguji metode ini Anda hanya perlu membungkusnya di <i>runBlocking</i> . <br><br>  <i>runBlocking</i> dapat digunakan untuk menguji fungsi menangguhkan: <br><br><img src="https://habrastorage.org/webt/ok/vi/4t/okvi4t5bogczdolbbiimwmqyz5g.png"><br>  <i>Fig.</i>  <i>2.22</i> <br><br><h2>  Contohnya </h2><br>  Akhirnya, saya ingin menunjukkan beberapa contoh penggunaan corutin. <br><br>  Bayangkan bahwa kita perlu menjalankan tiga pertanyaan A, B, dan C secara paralel, menunjukkan penyelesaiannya dan mencerminkan momen penyelesaian permintaan A dan B. <br><br>  Untuk melakukan ini, Anda cukup membungkus kueri coroutine A dan B menjadi satu yang umum dan bekerja dengannya sebagai satu kesatuan: <br><br><img src="https://habrastorage.org/webt/xy/ut/fo/xyutfowgblzyjx5l-fb0tcazbx4.png"><br>  <i>Fig.</i>  <i>2.23</i> <br><br>  Contoh berikut menunjukkan bagaimana menggunakan loop reguler untuk menjalankan kueri berkala dengan interval 5 detik: <br><br><img src="https://habrastorage.org/webt/an/bk/zb/anbkzbm6ozetsl3vtwopsmtm2f0.png"><br>  <i>Fig.</i>  <i>2.24</i> <br><br><h2>  Kesimpulan </h2><br>  Dari minus, saya perhatikan bahwa coroutine adalah alat yang relatif muda, jadi jika Anda ingin menggunakannya pada prod, Anda harus melakukan ini dengan hati-hati.  Ada kesulitan debugging, sebuah boilerplate kecil dalam implementasi hal-hal yang jelas. <br><br>  Secara umum, coroutine cukup mudah digunakan, terutama untuk mengimplementasikan tugas asinkron yang tidak rumit.  Secara khusus, karena fakta bahwa konstruksi bahasa standar dapat digunakan.  Coroutine mudah menerima pengujian unit dan semua ini keluar dari kotak dari perusahaan yang sama yang mengembangkan bahasa. <br><br><h2>  Laporkan video </h2><br>  Ternyata banyak surat.  Bagi mereka yang suka mendengarkan lebih banyak - video dari laporan saya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MBLT DEV 2018</a> : <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wsYou5lx6zA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Materi yang berguna tentang topik: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar Coroutines</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menyelam dalam-dalam ke coroutine</a> </li><li>  <a href="">Panduan untuk kotlinx.coroutines dengan contoh</a> </li><li>  <a href="">Panduan untuk pemrograman UI dengan coroutine</a> </li><li>  <a href="">Dokumen desain Coroutines (KEEP)</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442920/">https://habr.com/ru/post/id442920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442910/index.html">Mengapa kita memerlukan analitik lanjutan di SIBUR</a></li>
<li><a href="../id442912/index.html">Rapat melawan isolasi Runet</a></li>
<li><a href="../id442914/index.html">Battle royale: rahasia desain genre game paling populer</a></li>
<li><a href="../id442916/index.html">Apakah stasiun radio FM bajakan relevan hari ini?</a></li>
<li><a href="../id442918/index.html">Panduan untuk menyebarkan model pembelajaran mesin di lingkungan produksi sebagai API menggunakan Flask</a></li>
<li><a href="../id442922/index.html">Misi Lunar "Bereshit" - karakteristik perangkat, serangkaian manuver dan jalur terpanjang ke bulan</a></li>
<li><a href="../id442924/index.html">Pemisahan Tekstur Terrain Tingkat Lanjut</a></li>
<li><a href="../id442926/index.html">"Tikus ribut" dalam cahaya inframerah: pengenalan partikel nano ke dalam daerah subretinal mata tikus</a></li>
<li><a href="../id442928/index.html">Menulis Kode yang Fleksibel Menggunakan SOLID</a></li>
<li><a href="../id442934/index.html">Cara merekrut orang di perusahaan besar dengan tumpukan tidak populer. Percakapan dengan Wrike</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>