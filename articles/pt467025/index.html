<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏖️ 👩🏽‍🤝‍👨🏿 🧡 Sobre o modelo de rede em jogos para iniciantes 🤐 👩🏽‍🎨 👩‍👩‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nas últimas duas semanas, tenho trabalhado em um mecanismo de rede para o meu jogo. Antes disso, eu não sabia nada sobre tecnologias de rede em jogos,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sobre o modelo de rede em jogos para iniciantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467025/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69e/de3/6bb/69ede36bb7e48411280ffad409751c0d.png" alt="imagem"></div><br>  Nas últimas duas semanas, tenho trabalhado em um mecanismo de rede para o meu jogo.  Antes disso, eu não sabia nada sobre tecnologias de rede em jogos, então li muitos artigos e realizei muitos experimentos para entender todos os conceitos e poder escrever meu próprio mecanismo de rede. <br><br>  Neste guia, gostaria de compartilhar com você vários conceitos que você precisa aprender antes de escrever seu próprio mecanismo de jogo, bem como os melhores recursos e artigos para aprendê-los. <br><br>  Em geral, existem dois tipos principais de arquiteturas de rede: ponto a ponto e cliente-servidor.  Na arquitetura ponto a ponto (p2p), os dados são transferidos entre qualquer par de players conectados e, na arquitetura cliente-servidor, os dados são transmitidos apenas entre os players e o servidor. <br><br>  Embora a arquitetura ponto a ponto ainda seja usada em alguns jogos, o padrão é cliente-servidor: é mais fácil de implementar, requer uma largura de canal menor e facilita a proteção contra trapaças.  Portanto, neste guia, focaremos na arquitetura cliente-servidor. <br><a name="habracut"></a><br>  Em particular, estamos mais interessados ​​em servidores autoritários: nesses sistemas, o servidor está sempre certo.  Por exemplo, se um jogador pensa que ele está em coordenadas (10, 5) e o servidor diz que ele está em (5, 3), o cliente deve substituir sua posição pela posição transmitida pelo servidor e não vice-versa.  O uso de servidores autoritários facilita o reconhecimento de trapaceiros. <br><br>  Existem três componentes principais nos sistemas de rede de jogos: <br><br><ul><li>  Protocolo de Transporte: como os dados são transferidos entre os clientes e o servidor. </li><li>  Protocolo de aplicação: o que é transferido dos clientes para o servidor e do servidor para os clientes e em que formato. </li><li>  Lógica do aplicativo: como os dados transmitidos são usados ​​para atualizar o status dos clientes e do servidor. </li></ul><br>  É muito importante entender o papel de cada parte e as dificuldades associadas. <br><br><h1>  Protocolo de transporte </h1><br>  O primeiro passo é escolher um protocolo para o transporte de dados entre o servidor e os clientes.  Existem dois protocolos da Internet para isso: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TCP</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UDP</a> .  Mas você pode criar seu próprio protocolo de transporte com base em um deles ou usar a biblioteca na qual eles são usados. <br><br><h2>  Comparando TCP e UDP </h2><br>  O TCP e o UDP são baseados em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IP</a> .  O IP permite transferir um pacote da origem para o destinatário, mas não garante que o pacote enviado chegue mais cedo ou mais tarde ao destinatário, que ele chegue ao menos uma vez e que a sequência de pacotes chegue na ordem correta.  Além disso, um pacote pode conter apenas um tamanho de dados limitado especificado pelo valor da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MTU</a> . <br><br>  O UDP é apenas uma camada fina sobre o IP.  Portanto, tem as mesmas limitações.  Por outro lado, o TCP possui muitos recursos.  Ele fornece uma conexão confiável e ordenada entre dois nós com verificação de erros.  Portanto, o TCP é muito conveniente e é usado em muitos outros protocolos, por exemplo, em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HTTP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FTP</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SMTP</a> .  Mas todos esses recursos têm um preço: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>atraso</em></a> . <br><br>  Para entender por que essas funções podem causar um atraso, você precisa entender como o TCP funciona.  Quando o nó de envio encaminha o pacote para o nó de recebimento, espera receber uma confirmação (ACK).  Se depois de um certo tempo ele não o receber (porque o pacote ou a confirmação foi perdida ou por outros motivos), ele reenviará o pacote.  Além disso, o TCP garante que os pacotes sejam recebidos na ordem correta; portanto, até que um pacote perdido seja recebido, todos os outros pacotes não poderão ser processados, mesmo que já tenham sido recebidos pelo nó de recebimento. <br><br>  Mas, como você provavelmente entende, o atraso nos jogos multiplayer é muito importante, especialmente em gêneros ativos como o FPS.  É por isso que muitos jogos usam o UDP com seu próprio protocolo. <br><br>  Um protocolo nativo baseado em UDP pode ser mais eficiente que o TCP por vários motivos.  Por exemplo, pode marcar alguns pacotes como confiáveis ​​e outros como não confiáveis.  Portanto, ele não se importa se o pacote não confiável chegou ao receptor.  Ou pode processar vários fluxos de dados para que um pacote perdido em um fluxo não diminua a velocidade dos fluxos restantes.  Por exemplo, pode haver um fluxo para entrada do jogador e outro fluxo para mensagens de bate-papo.  Se uma mensagem de bate-papo que não contém dados urgentes for perdida, ela não diminuirá a velocidade da entrada, o que é urgente.  Ou, um protocolo proprietário pode implementar confiabilidade de maneira diferente da do TCP, a fim de ser mais eficiente nos videogames. <br><br>  Então, se o TCP é uma porcaria, criaremos nosso próprio protocolo de transporte baseado no UDP? <br><br>  Tudo é um pouco mais complicado.  Embora o TCP seja quase subótimo para sistemas de rede de jogos, ele pode funcionar muito bem no seu jogo e economizar seu tempo valioso.  Por exemplo, atraso pode não ser um problema para um jogo baseado em turnos ou um jogo que só pode ser jogado em LANs, onde há muito menos atrasos e perda de pacotes do que na Internet. <br><br>  Muitos jogos de sucesso, incluindo World of Warcraft, Minecraft e Terraria, usam TCP.  No entanto, a maioria dos FPS usa protocolos proprietários baseados em UDP, então falaremos mais sobre eles abaixo. <br><br>  Se você decidir usar o TCP, verifique se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o algoritmo Nagle está</a> desativado, porque ele armazena em buffer os pacotes antes do envio, o que significa que aumenta o atraso. <br><br>  Para saber mais sobre as diferenças entre UDP e TCP no contexto de jogos multiplayer, você pode ler o artigo de Glenn Fiedler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20180823015049/"><em>UDP vs.</em></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20180823015049/"><em>TCP</em></a> <br><br><h2>  Protocolo próprio </h2><br>  Então, você deseja criar seu próprio protocolo de transporte, mas não sabe por onde começar?  Você tem sorte, porque Glenn Fiedler escreveu dois artigos incríveis sobre isso.  Você encontrará muitos pensamentos inteligentes neles. <br><br>  O primeiro artigo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20180823012240/"><em>Networking for Game Programmers</em></a> 2008, é mais simples que o segundo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20180823014904/"><em>Building A Game Network Protocol</em></a> 2016.  Eu recomendo que você comece com um mais antigo. <br><br>  Lembre-se de que Glenn Fiedler é um grande defensor do uso de seu próprio protocolo UDP.  E depois de ler seus artigos, você certamente superará a opinião dele de que o TCP tem sérias desvantagens nos videogames e deseja implementar seu próprio protocolo. <br><br>  Mas se você é novo na rede, faça um favor a si mesmo e use o TCP ou uma biblioteca.  Para implementar com sucesso seu próprio protocolo de transporte, primeiro você precisa aprender muito. <br><br><h2>  Bibliotecas de rede </h2><br>  Se você precisar de algo mais eficiente que o TCP, mas não quiser se preocupar em implementar seu próprio protocolo e entrar em muitos detalhes, poderá usar a biblioteca de rede.  Existem muitos deles: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">yojimbo</a> Glenn Fiedler </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RakNet</a> , que não é mais suportado, mas seu fork do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SLikeNet</a> parece ainda estar ativo. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ENet</a> é uma biblioteca criada para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cubo</a> FPS multiusuário </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GameNetworkingSockets da Valve</a> </li></ul><br>  Eu não tentei todos eles, mas prefiro o ENet, porque é fácil de usar e confiável.  Além disso, ela possui documentação clara e um tutorial para iniciantes. <br><br><h2>  Protocolo de Transporte: Conclusão </h2><br>  Para resumir: existem dois protocolos principais de transporte: TCP e UDP.  O TCP possui muitos recursos úteis: confiabilidade, solicitação de pacotes, detecção de erros.  O UDP não tem tudo isso, mas o TCP, por sua natureza, aumentou atrasos que são inaceitáveis ​​para alguns jogos.  Ou seja, para garantir baixas latências, você pode criar seu próprio protocolo baseado em UDP ou usar uma biblioteca que implemente o protocolo de transporte UDP e seja adaptada para videogames para vários jogadores. <br><br>  A escolha entre TCP, UDP e a biblioteca depende de vários fatores.  Em primeiro lugar, pelas necessidades do jogo: ele precisa de baixas latências?  Segundo, a partir dos requisitos do protocolo de aplicação: ele precisa de um protocolo confiável?  Como veremos na próxima parte, você pode criar um protocolo de aplicativo para o qual um protocolo não confiável é bastante adequado.  Por fim, você ainda precisa considerar a experiência do desenvolvedor do mecanismo de rede. <br><br>  Eu tenho duas dicas: <br><br><ul><li>  Maximize o protocolo de transporte do restante do aplicativo para que ele possa ser facilmente substituído sem reescrever o código inteiro. </li><li>  Não faça otimização prematura.  Se você não é um especialista em rede e não tem certeza se precisa de seu próprio protocolo de transporte baseado em UDP, pode começar com o TCP ou uma biblioteca que fornece confiabilidade e, em seguida, testar e medir o desempenho.  Se você tiver problemas e tiver certeza de que o motivo está no protocolo de transporte, talvez seja a hora de criar seu próprio protocolo de transporte. </li></ul><br>  No final desta parte, recomendo que você leia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20190519135537/"><em>Introdução à programação de jogos multiplayer de</em></a> Brian Hook, que aborda muitos dos tópicos discutidos aqui. <br><br><h1>  Protocolo de aplicação </h1><br>  Agora que podemos trocar dados entre clientes e o servidor, precisamos decidir quais dados transferir e em qual formato. <br><br>  O esquema clássico é que os clientes enviam entradas ou ações ao servidor e o servidor envia o estado atual do jogo aos clientes. <br><br>  O servidor não envia um estado completo, mas filtrado, com entidades próximas ao player.  Ele faz isso por três razões.  Primeiro, o estado geral pode ser muito grande para transmissão de alta frequência.  Em segundo lugar, os clientes estão interessados ​​principalmente em dados visuais e de áudio, porque a maior parte da lógica do jogo é simulada no servidor do jogo.  Em terceiro lugar, em alguns jogos, o jogador não precisa conhecer certos dados, por exemplo, a posição do oponente no outro extremo do mapa, porque, caso contrário, ele pode cheirar pacotes e saber exatamente para onde se mover para matá-lo. <br><br><h2>  Serialização </h2><br>  O primeiro passo é converter os dados que queremos enviar (estado de entrada ou jogo) em um formato adequado para transmissão.  Esse processo é chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>serialização</em></a> . <br><br>  Imediatamente se pensa em usar um formato legível por humanos, como JSON ou XML.  Mas será completamente ineficaz e em vão ocupará a maior parte do canal. <br><br>  Em vez disso, é recomendável usar um formato binário muito mais compacto.  Ou seja, os pacotes conterão apenas alguns bytes.  Aqui você precisa considerar o problema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>da ordem dos bytes</em></a> , que pode diferir em computadores diferentes. <br><br>  Você pode usar uma biblioteca para serializar dados, por exemplo: <br><br><ul><li>  Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FlatBuffers</a> </li><li>  Tempestade de areia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cap'n Proto</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cereal por</a> Shane Grant e Randolph Voorhees </li></ul><br>  Apenas verifique se a biblioteca cria arquivos portáteis e cuida da ordem dos bytes. <br><br>  Uma solução independente pode ser uma implementação independente, não é particularmente complicada, especialmente se você usar uma abordagem orientada a dados no código.  Além disso, permitirá executar otimizações que nem sempre são possíveis ao usar a biblioteca. <br><br>  Glenn Fiedler escreveu dois artigos sobre serialização: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20180823004533/"><em>ler e escrever pacotes</em></a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20180823015044/"><em>estratégias de serialização</em></a> . <br><br><h2>  Compressão </h2><br>  A quantidade de dados transferidos entre clientes e o servidor é limitada pela largura de banda do canal.  A compactação de dados permite transferir mais dados em cada instantâneo, aumentar a taxa de atualização ou simplesmente reduzir os requisitos de canal. <br><br><h3>  Bit embalagem </h3><br>  A primeira técnica é a embalagem de bits.  Consiste em usar exatamente o número de bits necessário para descrever o valor desejado.  Por exemplo, se você tiver uma enumeração que possa ter 16 valores diferentes, em vez de um byte inteiro (8 bits), poderá usar apenas 4 bits. <br><br>  Glenn Fiedler explica como implementar isso na segunda parte do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20180823004533/"><em>Pacotes de leitura e gravação</em></a> . <br><br>  O empacotamento de bits funciona especialmente bem com a amostragem, que será o tópico da próxima seção. <br><br><h3>  Discretização </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>A discretização</em></a> é uma técnica de compactação com perdas que usa apenas um subconjunto dos valores possíveis para codificar um valor.  A maneira mais fácil de implementar a discretização é arredondar números de ponto flutuante. <br><br>  Glenn Fiedler (novamente!) Mostra como aplicar a amostragem na prática em seu artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20180823021121/">Snapshot Compression</a> . <br><br><h3>  Algoritmos de compressão </h3><br>  A próxima técnica serão algoritmos de compactação sem perdas. <br><br>  Aqui, na minha opinião, os três algoritmos mais interessantes que você precisa conhecer: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Codificação de Huffman</a> com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">código</a> pré-calculado que é extremamente rápido e pode dar bons resultados.  Foi usado para compactar pacotes no mecanismo de rede Quake3. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O zlib</a> é um algoritmo de compactação de uso geral que nunca aumenta a quantidade de dados.  Como pode ser visto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , ele tem sido usado em muitas aplicações.  Pode ser redundante para atualizar estados.  Mas pode ser útil se você precisar enviar ativos, textos longos ou alívio para os clientes a partir do servidor. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A cópia de séries</a> é provavelmente o algoritmo de compactação mais simples, mas é muito eficaz para determinados tipos de dados e pode ser usado como uma etapa de pré-processamento antes do zlib.  É especialmente adequado para comprimir terrenos constituídos por ladrilhos ou voxels, nos quais muitos elementos vizinhos são repetidos. </li></ul><br><h3>  Compressão delta </h3><br>  A técnica de compactação mais recente é a compactação delta.  Está no fato de que apenas diferenças entre o estado atual do jogo e o último estado recebido pelo cliente são transmitidas. <br><br>  Foi usado pela primeira vez no mecanismo de rede Quake3.  Aqui estão dois artigos que explicam como usá-lo: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20190628180906/"><em>O modelo de rede Quake3 de</em></a> Brian Hook </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Revisão do código-fonte do Quake 3: modelo de rede</em></a> Fabien Sanglar [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradução de</a> artigo sobre Habré, consulte a seção "Modelo de rede"] </li></ul><br>  Glenn Fiedler também o usou na segunda parte de seu artigo sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20180823021121/"><em>Snapshot Compression</em></a> . <br><br><h2>  Criptografia </h2><br>  Além disso, pode ser necessário criptografar a transferência de informações entre clientes e o servidor.  Existem várias razões para isso: <br><br><ul><li>  privacidade / confidencialidade: as mensagens só podem ser lidas pelo destinatário e nenhuma outra pessoa que cheira a rede pode lê-las. </li><li>  autenticação: uma pessoa que deseja desempenhar o papel de jogador deve conhecer sua chave. </li><li>  prevenção de trapaça: será muito mais difícil para jogadores mal-intencionados criarem seus próprios pacotes de trapaça, eles terão que reproduzir o esquema de criptografia e encontrar a chave (que muda a cada conexão). </li></ul><br>  Eu recomendo fortemente o uso da biblioteca para isso.  Eu sugiro usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">libsodium</a> porque é especialmente simples e tem ótimos tutoriais.  De particular interesse é o tutorial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">troca de chaves</a> , que permite gerar novas chaves a cada nova conexão. <br><br><h2>  Protocolo de Aplicação: Conclusão </h2><br>  Terminaremos com o protocolo do aplicativo.  Acredito que a compactação é completamente opcional e a decisão de usá-la depende apenas do jogo e da largura de banda necessária.  Criptografia, na minha opinião, é obrigatória, mas no primeiro protótipo você pode ficar sem ela. <br><br><h1>  Lógica de aplicação </h1><br>  Agora, podemos atualizar o estado no cliente, mas podemos encontrar problemas com atrasos.  Depois de entrar, o jogador precisa aguardar a atualização do estado do jogo do servidor para ver qual o impacto que ele teve no mundo. <br><br>  Além disso, entre duas atualizações de estado, o mundo é completamente estático.  Se a taxa de atualização dos estados for baixa, os movimentos ficarão muito trêmulos. <br><br>  Existem várias técnicas para reduzir o impacto desse problema e, na próxima seção, falarei sobre elas. <br><br><h2>  Atraso nas técnicas de suavização </h2><br>  Todas as técnicas descritas nesta seção são discutidas em detalhes na série <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Multiplayer em ritmo acelerado, de</em></a> Gabriel Gambetta.  Eu recomendo a leitura desta grande série de artigos.  Ele também possui uma demonstração interativa que permite ver como essas técnicas funcionam na prática. <br><br>  A primeira técnica é aplicar a entrada diretamente, sem aguardar uma resposta do servidor.  Isso é chamado <em>de previsão do lado do cliente</em> .  No entanto, quando o cliente recebe a atualização do servidor, ele deve verificar se sua previsão estava correta.  Se não for assim, ele só precisará alterar seu estado de acordo com o recebido do servidor, porque o servidor é autoritário.  Esta técnica foi usada pela primeira vez no Quake.  Você pode ler mais sobre isso no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Revisão do código do Quake Engine por</em></a> Fabien Sanglar [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradução</a> para Habré]. <br><br>  O segundo conjunto de técnicas é usado para facilitar a movimentação de outras entidades entre duas atualizações de estado.  Existem duas maneiras de resolver esse problema: interpolação e extrapolação.  No caso de interpolação, os dois últimos estados são tomados e a transição de um para o outro é mostrada.  Sua desvantagem é que causa uma pequena fração do atraso, porque o cliente sempre vê o que aconteceu no passado.  A extrapolação está prevendo onde as entidades agora devem se basear no último estado recebido pelo cliente.  Sua desvantagem é que, se a entidade mudar completamente a direção do movimento, haverá um grande erro entre a previsão e a posição real. <br><br>  A última técnica mais avançada, útil apenas no FPS é a <em>compensação de atraso</em> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao usar a compensação de atraso, o servidor leva em consideração os atrasos do cliente quando dispara em um alvo. Por exemplo, se um jogador completou um tiro na cabeça em sua tela, mas, na realidade, seu objetivo foi devido a um atraso em outro lugar, seria desonesto negar a um jogador o direito de matar por causa de um atraso. Portanto, o servidor retrocede o tempo até o momento em que o jogador disparou para simular o que o jogador viu na tela e verificar a colisão entre o tiro e o alvo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glenn Fiedler (como sempre!) Escreveu um artigo de 2004 na </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20180823005028/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Network Physics (2004)</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que lançou as bases para sincronizar simulações de física entre um servidor e um cliente. Em 2014, ele escreveu uma nova série de artigos de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20180823004853/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Networking Physics</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que descreviam outras técnicas para sincronizar simulações de física.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem também dois artigos no wiki da Valve, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rede de Multijogadores de Origem</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Métodos de Compensação de Latência no Projeto e Otimização de Protocolo no Jogo Cliente / Servidor</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que discutem a compensação de atraso.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prevenção de trapaça </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem duas técnicas principais para evitar trapaças. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro: complicar o envio de pacotes maliciosos por trapaceiros. </font><font style="vertical-align: inherit;">Como mencionado acima, a criptografia é uma boa maneira de implementá-la. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segundo: um servidor autoritário deve receber apenas comandos / entradas / ações. </font><font style="vertical-align: inherit;">O cliente não deve poder alterar o estado no servidor, exceto enviando entrada. </font><font style="vertical-align: inherit;">Então, toda vez que a entrada é recebida, o servidor deve verificar sua validade antes de aplicá-la.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lógica de Aplicação: Conclusão </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu recomendo que você implemente um método de simular grandes atrasos e baixas taxas de atualização para poder testar o comportamento do seu jogo em condições precárias, mesmo quando o cliente e o servidor estiverem executando no mesmo computador. </font><font style="vertical-align: inherit;">Isso simplificará bastante a implementação de técnicas de suavização de retardo.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Outros recursos úteis </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se você deseja explorar outros recursos nos modelos de rede, pode encontrá-los aqui: </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20190328001900/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog de Glenn Fiedler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - vale a pena ler o blog inteiro, possui muitos ótimos artigos. </font><font style="vertical-align: inherit;">Todos os artigos sobre tecnologias de rede </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20180823014743/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">são</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coletados </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20180823014743/"><font style="vertical-align: inherit;">aqui</font></a><font style="vertical-align: inherit;"> .</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awesome Game Networking</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de M. Fatih MAR é uma lista detalhada de artigos e vídeos sobre os mecanismos de rede de videogames.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wiki do r / gamedev subreddit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> também possui muitos links úteis.</font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467025/">https://habr.com/ru/post/pt467025/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467015/index.html">JWT: ataque de assinatura digital vs ataque de MAC</a></li>
<li><a href="../pt467017/index.html">O que é o HED / MRSD e para que serve?</a></li>
<li><a href="../pt467019/index.html">Projetando painéis para o site de comércio eletrônico de análise da web. Parte 3: Canal SEO</a></li>
<li><a href="../pt467021/index.html">Como o robô da consciência se comunica com os clientes</a></li>
<li><a href="../pt467023/index.html">Criamos um plugin na Grafana para monitorar o k8s: já na loja oficial da Grafana</a></li>
<li><a href="../pt467029/index.html">Grigory Petrov: trabalhando com uma rede em Ruby</a></li>
<li><a href="../pt467033/index.html">Uma seleção de artigos técnicos interessantes do Chaos Communication Camp 2019</a></li>
<li><a href="../pt467035/index.html">Projetando painéis para o site de comércio eletrônico de análise da web. Parte 4: Canal do Youtube</a></li>
<li><a href="../pt467037/index.html">Factoring: como conseguir dinheiro para cadeiras</a></li>
<li><a href="../pt467039/index.html">Como conduzir uma revisão de código</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>