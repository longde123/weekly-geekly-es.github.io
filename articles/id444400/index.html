<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔳 🍌 🙍🏾 Bagaimana saya menulis ulang mesin pencari penerbangan dari PHP ke NodeJS 🕙 🧖🏿 💇🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Nama saya Andrey, saya mahasiswa pascasarjana di salah satu universitas teknik di Moskow dan paruh waktu  sangat sederhana  pengusaha dan pengemba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana saya menulis ulang mesin pencari penerbangan dari PHP ke NodeJS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444400/"><p>  Hai  Nama saya Andrey, saya mahasiswa pascasarjana di salah satu universitas teknik di Moskow dan paruh waktu <del>  sangat sederhana </del>  pengusaha dan pengembang pemula.  Dalam artikel ini, saya memutuskan untuk berbagi pengalaman saya beralih dari PHP (yang dulu saya suka karena kesederhanaannya, tetapi akhirnya menjadi dibenci oleh saya - saya menjelaskan mengapa di bawah potongan) ke NodeJS.  Tugas yang sangat sepele dan tampaknya elementer dapat diberikan di sini, yang, bagaimanapun, secara pribadi saya ingin menyelesaikannya selama berkenalan dengan NodeJS dan fitur pengembangan sisi server dalam JavaScript.  Saya akan mencoba menjelaskan dan menunjukkan dengan jelas bahwa PHP akhirnya pergi ke matahari terbenam dan telah memberi jalan kepada NodeJS.  Mungkin bahkan akan berguna bagi seseorang untuk mempelajari beberapa fitur rendering halaman HTML di Node, yang pada awalnya tidak disesuaikan dengan ini dari kata sama sekali. </p><a name="habracut"></a><br><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Saat menulis mesin, saya menggunakan teknik yang paling sederhana.  Tidak ada pengelola paket, tidak ada perutean.  Hanya folder hardcore, yang namanya cocok dengan rute yang diminta, dan <strong>index.php</strong> di masing-masingnya, yang dikonfigurasi oleh PHP-FPM untuk mendukung kumpulan proses.  Kemudian menjadi perlu untuk menggunakan Komposer dan Laravel, yang merupakan jerami terakhir bagi saya.  Sebelum beralih ke kisah mengapa saya bahkan memutuskan untuk menulis ulang semuanya dari PHP ke NodeJS, saya akan memberi tahu Anda sedikit tentang latar belakangnya. </p><br><h3 id="menedzher-paketov">  Manajer paket </h3><br><p>  Pada akhir 2018, saya bekerja dengan satu proyek yang ditulis dalam Laravel.  Itu perlu untuk memperbaiki beberapa bug, membuat perubahan pada fungsi yang ada, menambahkan beberapa tombol baru di antarmuka.  Prosesnya dimulai dengan menginstal paket dan dependensi manager.  Dalam PHP, Komposer digunakan untuk ini.  Kemudian pelanggan menyediakan server dengan 1 core dan RAM 512 megabyte dan ini adalah pengalaman pertama saya dengan Composer.  Saat memasang dependensi pada server pribadi virtual dengan memori 512 megabita, proses macet karena kurangnya memori. </p><br><p><img src="https://habrastorage.org/webt/pg/jm/hh/pgjmhhg0efngekrokj1yryvdzxg.png" alt="Apa?"></p><br><p> Bagi saya, sebagai orang yang akrab dengan Linux dan berpengalaman dalam bekerja dengan Debian dan Ubuntu, solusi untuk masalah ini jelas - menginstal file SWAP (file swap - bagi mereka yang tidak terbiasa dengan administrasi Linux).  Seorang pengembang pemula yang belum berpengalaman yang memasang distribusi Laravel pertamanya di Digital Ocean, misalnya, hanya pergi ke panel kontrol dan menaikkan tarif hingga pemasangan dependensi berhenti dengan kesalahan segmentasi memori.  Bagaimana dengan NodeJS? <br>  Dan NodeJS memiliki manajer paket sendiri - npm.  Ini jauh lebih mudah digunakan, lebih kompak, dapat bekerja bahkan di lingkungan dengan jumlah minimum RAM.  Secara umum, tidak ada yang bisa disalahkan Komposer terhadap latar belakang NPM, namun, jika ada kesalahan selama instalasi paket, Komposer akan mogok seperti aplikasi PHP biasa dan Anda tidak akan pernah tahu bagian mana dari paket yang berhasil diinstal dan apakah itu diinstal pada akhirnya. berakhir.  Secara umum, untuk administrator Linux, instalasi yang macet = kilas balik dalam Mode Penyelamatan dan <code>dpkg --configure -a</code> .  Pada saat "kejutan" seperti itu menyalip saya, saya tidak menyukai PHP, tetapi ini adalah paku terakhir dalam peti mati cinta saya yang dulu sangat bagus untuk PHP. </p><br><h2 id="long-term-support-i-problema-versionirovaniya">  Dukungan jangka panjang dan masalah versi </h2><br><p>  Ingat hype dan keheranan apa yang menyebabkan PHP7 saat pengembang pertama kali mempresentasikannya?  Tingkatkan produktivitas lebih dari 2 kali, dan di beberapa komponen hingga 5 kali!  Ingat kapan versi ketujuh PHP lahir?  Dan seberapa cepat WordPress menghasilkan!  Itu Desember 2015.  Tahukah Anda bahwa PHP 7.0 sekarang dianggap sebagai versi PHP yang sudah usang dan sangat disarankan untuk memperbaruinya ... Tidak, bukan ke versi 7.1, tetapi ke versi 7.2.  Menurut pengembang, versi 7.1 sudah kehilangan dukungan aktif dan hanya menerima pembaruan keamanan.  Dan setelah 8 bulan ini akan berhenti.  Ini akan berhenti, bersama dengan dukungan aktif dan versi 7.2.  Ternyata pada akhir tahun ini, PHP hanya akan memiliki satu versi saat ini - 7.3. </p><br><p><img src="https://habrastorage.org/webt/zd/0p/me/zd0pmebltmchxqafrdw5yfpdfta.png" alt="Versi PHP saat ini"></p><br><p>  Sebenarnya, ini tidak akan menjadi rewel dan saya tidak akan mengaitkan ini dengan alasan keberangkatan saya dari PHP jika proyek yang saya tulis di PHP 7.0. * Sudah tidak menyebabkan peringatan penghentian ketika saya membukanya.  Mari kita kembali ke proyek tempat pemasangan dependensi macet.  Ini adalah proyek yang ditulis pada tahun 2015 di Laravel 4 dengan PHP 5.6.  Tampaknya hanya 4 tahun yang telah berlalu, tetapi tidak - banyak peringatan penghentian, modul yang sudah ketinggalan zaman, ketidakmampuan untuk meningkatkan ke Laravel 5 secara normal karena banyak pembaruan engine root. </p><br><p>  Dan ini tidak hanya berlaku untuk Laravel.  Cobalah untuk mendapatkan aplikasi PHP yang ditulis selama dukungan aktif dari versi pertama PHP 7.0 dan bersiaplah untuk menghabiskan malam Anda mencari solusi untuk masalah yang muncul dalam modul PHP yang sudah ketinggalan zaman.  Akhirnya, fakta yang menarik: dukungan untuk PHP 7.0 dihentikan lebih awal daripada dukungan untuk PHP 5.6.  Untuk sesaat. </p><br><p>  Bagaimana dengan NodeJS?  Saya tidak akan mengatakan bahwa semuanya jauh lebih baik di sini dan periode dukungan untuk NodeJS pada dasarnya berbeda dari PHP.  Tidak, ini hampir sama di sini - setiap versi LTS didukung selama 3 tahun.  Tetapi NodeJS memiliki sedikit lebih banyak dari versi terbaru ini. </p><br><p><img src="https://habrastorage.org/webt/ff/xf/x_/ffxfx_rhvieo0jmad4wnabdrwuy.png" alt="Versi NodeJS saat ini"></p><br><p>  Jika Anda perlu menggunakan aplikasi yang ditulis pada tahun 2016, maka pastikan Anda sama sekali tidak memiliki masalah dengan ini.  Kebetulan, versi 6. * tidak akan lagi didukung hanya pada bulan April tahun ini.  Dan di depan ada 8, 10, 11 dan 12 mendatang. </p><br><h2 id="o-trudnostyah-i-syurprizah-pri-perehode-na-nodejs">  Kesulitan dan kejutan ketika beralih ke NodeJS </h2><br><p>  Saya akan mulai, mungkin, dengan pertanyaan paling menarik bagi saya tentang cara merender halaman HTML di NodeJS.  Tapi pertama-tama mari kita ingat bagaimana hal ini dilakukan dalam PHP: </p><br><ol><li>  Cantumkan HTML secara langsung dalam kode PHP.  Begitu juga semua pemula yang belum mencapai MVC.  Dan itu dilakukan di WordPress, yang benar-benar mengerikan. </li><li>  Gunakan MVC, yang seharusnya menyederhanakan interaksi pengembang dan menyediakan semacam membagi proyek menjadi beberapa bagian, tetapi pada kenyataannya pendekatan ini hanya memperumit semuanya pada waktu-waktu tertentu. </li><li>  Gunakan mesin template.  Opsi paling nyaman, tetapi tidak di PHP.  Lihat saja sintaks yang disarankan di Twig atau Blade dengan kurung kurawal dan persentase. </li></ol><br><p>  Saya adalah lawan yang gigih menggabungkan atau menggabungkan beberapa teknologi bersama.  HTML harus ada secara terpisah, gaya untuk itu secara terpisah, JavaScript secara terpisah (dalam Bereaksi, ini umumnya terlihat mengerikan - HTML dan JavaScript dicampur).  Itulah sebabnya opsi ideal untuk pengembang dengan preferensi seperti milik saya adalah mesin templat.  Saya tidak perlu mencarinya untuk aplikasi web di NodeJS untuk waktu yang lama dan saya memilih Jade (PugJS).  Hanya menghargai kesederhanaan sintaksnya: </p><br><pre> <code class="plaintext hljs"> div.row.links div.col-lg-3.col-md-3.col-sm-4 h4.footer-heading . div.copyright div.copy-text 2017 - #{current_year} . div.contact-link span : a(href='mailto:hello@flaut.ru') hello@flaut.ru</code> </pre> <br><p>  Semuanya sangat sederhana di sini: Saya menulis sebuah templat, mengunduhnya ke dalam aplikasi, mengompilasinya satu kali dan kemudian menggunakannya di tempat yang nyaman pada waktu yang nyaman.  Menurut pendapat saya, kinerja PugJS sekitar 2 kali lebih baik daripada rendering dengan menanamkan HTML dalam kode PHP.  Jika sebelumnya di PHP halaman statis dihasilkan oleh server dalam sekitar 200-250 milidetik, sekarang kali ini sekitar 90-120 milidetik (kita tidak berbicara tentang rendering dalam PugJS, tetapi tentang waktu yang diambil dari permintaan halaman ke respons server kepada klien dengan HTML siap) )  Beginilah tampilan dan kompilasi templat dan komponennya pada tahap peluncuran aplikasi seperti: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pugs = {} fs.readdirSync(__dirname + <span class="hljs-string"><span class="hljs-string">'/templates/'</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(file.endsWith(<span class="hljs-string"><span class="hljs-string">'.pug'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filepath = __dirname + <span class="hljs-string"><span class="hljs-string">'/templates/'</span></span> + file pugs[file.split(<span class="hljs-string"><span class="hljs-string">'.pug'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]] = pug.compile(fs.readFileSync(filepath, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>), { <span class="hljs-attr"><span class="hljs-attr">filename</span></span>: filepath }) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(e) } } }) <span class="hljs-comment"><span class="hljs-comment">//       return pugs.tickets({ ...config })</span></span></code> </pre> <br><p>  Ini terlihat sangat sederhana, tetapi dengan Jade ada sedikit kerumitan pada tahap bekerja dengan HTML yang sudah dikompilasi.  Faktanya adalah bahwa untuk mengimplementasikan skrip pada halaman, fungsi asinkron digunakan, yang mengambil semua file <code>.js</code> dari direktori dan menambahkan tanggal perubahan terakhir mereka ke masing-masing.  Fungsi ini memiliki bentuk sebagai berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; files.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> period = files[i].lastIndexOf(<span class="hljs-string"><span class="hljs-string">'.'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// get last dot in filename let filename = files[i].substring(0, period) let extension = files[i].substring(period + 1) if(extension === 'js') { let fullFilename = filename + '.' + extension if(env === 'production') { scripts.push({ path: paths.production.web + fullFilename, mtime: await getMtime(paths.production.code + fullFilename)}) } else { if(files[i].startsWith('common') || files[i].startsWith('search')) { scripts.push({ path: paths.developer.scripts.web + fullFilename, mtime: await getMtime(paths.developer.scripts.code + fullFilename)}) } else { scripts.push({ path: paths.developer.vendor.web + fullFilename, mtime: await getMtime(paths.developer.vendor.code + fullFilename)}) } } } }</span></span></code> </pre> <br><p>  Pada output, kita mendapatkan array objek dengan dua properti - path ke file dan waktu terakhir diedit di timestamp (untuk memperbarui cache klien).  Masalahnya adalah bahwa bahkan pada tahap pengumpulan file skrip dari direktori, mereka semua dimuat ke dalam memori secara alfabetis (karena mereka berada di direktori itu sendiri, dan file dikumpulkan di dalamnya dari atas ke bawah - dari yang pertama ke yang terakhir).  Ini mengarah pada fakta bahwa file <strong>app.js</strong> dimuat pertama kali, dan setelah itu datang file <strong>core.min.js</strong> dengan polyfill, dan vendor.min.js di bagian paling akhir.  Masalah ini diselesaikan dengan cukup sederhana - penyortiran sangat dangkal: </p><br><pre> <code class="javascript hljs">scripts.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a.path.includes(<span class="hljs-string"><span class="hljs-string">'core.min.js'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a.path.includes(<span class="hljs-string"><span class="hljs-string">'vendor.min.js'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> })</code> </pre> <br><p>  Di PHP, semuanya memiliki tampilan mengerikan dalam bentuk path ke file JS yang ditulis sebelumnya dalam sebuah string.  Sederhana tapi tidak praktis. </p><br><h3 id="nodejs-derzhit-svoyo-prilozhenie-v-operativnoy-pamyati">  NodeJS menyimpan aplikasinya dalam RAM </h3><br><p>  Ini merupakan nilai tambah yang besar.  Semuanya diatur untuk saya sehingga pada server secara paralel dan independen satu sama lain ada dua situs terpisah - versi untuk pengembang dan versi produksi.  Bayangkan saya membuat beberapa perubahan pada file PHP di situs pengembangan dan saya perlu meluncurkan perubahan ini untuk produksi.  Untuk melakukan ini, Anda harus menghentikan server atau meletakkan rintisan "maaf, tech. Work" dan saat ini salin file satu per satu dari folder pengembang ke folder produksi.  Ini menyebabkan semacam downtime dan dapat mengakibatkan hilangnya konversi.  Keuntungan dari <strong>aplikasi</strong> dalam <strong>memori</strong> di NodeJS bagi saya adalah bahwa semua perubahan pada file engine akan dilakukan hanya setelah reboot.  Ini sangat nyaman, karena Anda dapat menyalin semua file yang diperlukan dengan perubahan dan hanya kemudian me-restart server.  Prosesnya tidak lebih dari 1-2 detik dan tidak menyebabkan downtime. <br>  Pendekatan yang sama digunakan dalam nginx, misalnya.  Anda pertama-tama mengedit konfigurasi, periksa dengan <code>nginx -t</code> dan baru kemudian melakukan perubahan dengan <code>service nginx reload</code> </p><br><h3 id="klasterizaciya-nodejs-prilozheniya">  Clustering Aplikasi NodeJS </h3><br><p>  NodeJS memiliki alat yang sangat nyaman - <strong>manajer</strong> proses <strong>pm2</strong> .  Bagaimana biasanya kita menjalankan aplikasi di Node?  Kami masuk ke konsol dan menulis <code>node index.js</code> .  Segera setelah kami menutup konsol, aplikasi ditutup.  Setidaknya inilah yang terjadi pada server dengan Ubuntu.  Untuk menghindari hal ini dan menjaga aplikasi tetap berjalan, tambahkan saja ke <strong>pm2 dengan</strong> <code>pm2 start index.js --name production</code> sederhana <code>pm2 start index.js --name production</code> perintah.  Tapi itu belum semuanya.  Alat ini memungkinkan pemantauan ( <code>pm2 monit</code> ) dan pengelompokan aplikasi. </p><br><p>  Mari kita ingat bagaimana proses diatur dalam PHP.  Misalkan kita memiliki permintaan nginx yang melayani http dan kita harus meneruskan permintaan itu ke PHP.  Anda bisa melakukan ini secara langsung dan kemudian dengan setiap permintaan proses PHP baru akan muncul, dan ketika selesai, itu akan dibunuh.  Atau Anda dapat menggunakan server fastcgi.  Saya pikir semua orang tahu apa itu dan tidak perlu masuk ke detail, tapi kalau-kalau, saya akan mengklarifikasi bahwa PHP-FPM paling sering digunakan sebagai fastcgi dan tugasnya adalah menelurkan banyak proses PHP yang siap menerima dan memproses permintaan baru kapan saja.  Apa kerugian dari pendekatan ini? </p><br><p>  Yang pertama adalah Anda tidak pernah tahu berapa banyak memori yang akan dikonsumsi aplikasi Anda.  Kedua, Anda akan selalu dibatasi dalam jumlah maksimum proses, dan karenanya, dengan lonjakan tajam dalam lalu lintas, aplikasi PHP Anda akan menggunakan semua memori dan kerusakan yang tersedia, atau bersandar pada batas proses yang diijinkan dan mulai membunuh yang lama.  Ini dapat dicegah dengan menetapkan Saya tidak ingat parameter mana dalam file konfigurasi PHP-FPM yang <strong>dinamis</strong> dan kemudian banyak proses akan muncul sebagaimana diperlukan saat ini.  Tetapi sekali lagi, serangan dasar DDoS akan memakan semua RAM dan menempatkan server Anda.  Atau, misalnya, skrip bug akan memakan semua RAM dan server akan membeku untuk beberapa waktu (ada preseden dalam proses pengembangan). </p><br><p>  Perbedaan mendasar dalam NodeJS adalah bahwa aplikasi tidak dapat mengkonsumsi lebih dari 1,5 gigabytes RAM.  Tidak ada batasan proses, hanya ada batas memori.  Ini mendorong Anda untuk menulis program seringan mungkin.  Selain itu, sangat sederhana untuk menghitung jumlah cluster yang kami mampu, tergantung pada sumber daya CPU yang tersedia.  Disarankan agar tidak lebih dari satu cluster digantung pada setiap inti (persis seperti di nginx, tidak lebih dari satu pekerja per inti CPU). </p><br><p><img src="https://habrastorage.org/webt/rk/z4/hp/rkz4hp9g8jkptpmq_tbc-_gpdpu.png" alt="Pengelompokan dalam PM2"></p><br><p>  Keuntungan dari pendekatan ini adalah bahwa PM2 memuat kembali semua cluster secara bergantian.  Kembali ke paragraf sebelumnya, yang berbicara tentang downtime 1-2 detik saat reboot.  Dalam Mode-Cluster, ketika Anda me-restart server, aplikasi Anda tidak akan mengalami downtime milidetik. </p><br><h3 id="nodejs---eto-horoshiy-shveycarskiy-nozh">  NodeJS adalah pisau Swiss yang bagus </h3><br><p>  Sekarang ada situasi seperti itu ketika PHP bertindak sebagai bahasa untuk menulis situs, dan Python bertindak sebagai alat untuk merayapi situs ini.  NodeJS adalah 2 in 1, di satu sisi adalah garpu, di sisi lain adalah sendok.  Anda dapat menulis aplikasi dan perayap web yang cepat dan tangguh di server yang sama dalam aplikasi yang sama.  Kedengarannya menggoda.  Tetapi bagaimana ini bisa diwujudkan, Anda bertanya?  Google sendiri meluncurkan Chromium API resmi - Puppeteer.  Anda dapat meluncurkan Chrome Tanpa Kepala (peramban tanpa antarmuka pengguna - "tanpa kepala" Chrome) dan mendapatkan akses seluas mungkin ke API peramban untuk merayapi laman.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara paling sederhana dan paling mudah digunakan untuk bekerja dengan Dalang</a> . </p><br><p>  Misalnya, dalam grup VKontakte kami ada posting diskon dan penawaran khusus secara teratur ke berbagai tujuan dari kota-kota CIS.  Kami menghasilkan gambar untuk posting dalam mode otomatis, dan untuk membuatnya indah, kami membutuhkan gambar yang indah.  Saya tidak ingin mengikat ke berbagai API dan membuat akun di banyak situs, jadi saya menulis aplikasi sederhana yang meniru pengguna biasa dengan browser Google Chrome yang berjalan di sekitar situs dengan gambar stok dan mengambil secara acak gambar yang ditemukan oleh kata kunci.  Saya dulu menggunakan Python dan BeautifulSoup untuk ini, tetapi sekarang ini tidak lagi diperlukan.  Dan fitur utama dan keunggulan Puppeteer adalah Anda dapat dengan mudah menyontek bahkan situs SPA, karena Anda dapat menggunakan browser lengkap yang memahami dan mengeksekusi kode JavaScript di situs.  Sangat sederhana: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch({<span class="hljs-attr"><span class="hljs-attr">headless</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">args</span></span>:[<span class="hljs-string"><span class="hljs-string">'--no-sandbox'</span></span>]}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = (<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.pages())[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">`https://pixabay.com/photos/search/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${imageKeyword}</span></span></span><span class="hljs-string">/?cat=buildings&amp;orientation=horizontal`</span></span>, { <span class="hljs-attr"><span class="hljs-attr">waitUntil</span></span>: <span class="hljs-string"><span class="hljs-string">'networkidle0'</span></span> })</code> </pre> <br><p>  Jadi, dalam 3 baris kode, kami meluncurkan browser dan membuka halaman situs dengan gambar stok.  Sekarang kita dapat memilih blok acak dengan gambar pada halaman dan menambahkan kelas untuk itu, di mana nanti kita bisa berbelok dengan cara yang sama dan pergi ke halaman secara langsung dengan gambar itu sendiri untuk memuat lebih lanjut: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imagesLength = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.evaluate(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> photos = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'.search_results &gt; .item'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(photos.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { photos[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * photos.length)].className += <span class="hljs-string"><span class="hljs-string">' --anomaly_selected'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> photos.length })</code> </pre> <br><p>  Ingat berapa banyak kode yang diperlukan untuk menulis ini di PhantomJS (yang, kebetulan, menutup dan mengadakan kerja sama erat dengan tim pengembangan Dalang).  Bisakah alat yang luar biasa seperti itu menghentikan siapa pun dari beralih ke NodeJS? </p><br><h3 id="v-nodejs-zalozhena-asinhronnost-na-fundamentalnom-urovne">  NodeJS menyediakan asynchrony dasar </h3><br><p>  Ini dapat dianggap sebagai keuntungan besar NodeJS dan JavaScript, terutama dengan munculnya async / menunggu di ES2017.  Tidak seperti PHP, di mana panggilan apa pun dilakukan secara sinkron.  Saya akan memberikan contoh sederhana.  Sebelumnya, di mesin pencari, halaman dihasilkan di server, tetapi sesuatu harus ditampilkan pada halaman yang sudah ada di klien menggunakan JavaScript, dan pada saat itu Yandex belum dapat menggunakan JavaScript di situs web dan harus menerapkan mekanisme snapshot (snapshot halaman) khusus untuk itu. menggunakan Prerender.  Snapshots disimpan di server kami dan dikeluarkan ke robot berdasarkan permintaan.  Dilema adalah bahwa gambar-gambar ini dihasilkan dalam 3-5 detik, yang sama sekali tidak dapat diterima dan dapat mempengaruhi peringkat situs dalam hasil pencarian.  Untuk mengatasi masalah ini, sebuah algoritma sederhana ditemukan: ketika robot meminta beberapa halaman, snapshot yang sudah kita miliki, maka kita cukup memberikan snapshot yang ada, setelah itu kita melakukan operasi untuk membuat snapshot baru di latar belakang dan menggantinya sudah tersedia.  Cara melakukannya di PHP: </p><br><pre> <code class="php hljs">exec(<span class="hljs-string"><span class="hljs-string">'/usr/bin/php '</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">'/snapshot.php -a '</span></span> . $affiliation_type . <span class="hljs-string"><span class="hljs-string">' -l '</span></span> . urlencode($full_uri) . <span class="hljs-string"><span class="hljs-string">' &gt; /dev/null 2&gt;/dev/null &amp;'</span></span>);</code> </pre> <br><p>  Tidak pernah melakukannya. <br>  Di NodeJS, ini dapat dicapai dengan memanggil fungsi asinkron: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveSnapshot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ getSnapshot().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> { db.saveSnapshot().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">status</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(status.err) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }) }) } <span class="hljs-comment"><span class="hljs-comment">/** *     await * ..    resolve()   */</span></span> saveSnapshot()</code> </pre> <br><p>  Singkatnya, Anda tidak mencoba untuk memotong sinkronisasi, tetapi Anda memutuskan kapan harus menggunakan eksekusi kode sinkron dan kapan harus menggunakan asinkron.  Dan itu sangat nyaman.  Terutama ketika Anda belajar tentang kemungkinan <strong>Promise.all ()</strong> </p><br><p>  Mesin mesin pencari penerbangan itu sendiri dirancang sedemikian rupa sehingga mengirimkan permintaan ke server kedua yang mengumpulkan dan mengumpulkan data, dan kemudian beralih ke itu untuk data siap-untuk-masalah.  Halaman arahan digunakan untuk menarik lalu lintas organik. </p><br><p>  Misalnya, untuk permintaan "Flights Moscow St. Petersburg" halaman akan dikeluarkan dengan alamat <em>/ tiket / moscow / saint-petersburg /</em> , dan membutuhkan data: </p><br><ol><li>  Harga maskapai di arah ini untuk bulan ini </li><li>  Harga maskapai dalam arah ini untuk tahun yang akan datang (harga rata-rata untuk setiap bulan selama 12 bulan ke depan) </li><li>  Jadwalkan penerbangan ke arah ini </li><li>  Tujuan populer dari kota pengiriman - dari Moskow (untuk menghubungkan) </li><li>  Tujuan populer dari kota kedatangan adalah dari St. Petersburg (untuk menghubungkan) </li></ol><br><p>  Di PHP, semua permintaan ini dijalankan secara sinkron - satu demi satu.  Rata-rata waktu respons API per permintaan adalah 150-200 milidetik.  Kami mengalikan 200 dengan 5 dan, rata-rata, hanya satu detik untuk memenuhi permintaan ke server dengan data.  NodeJS memiliki fungsi hebat yang <strong>disebut Promise.all</strong> , yang mengeksekusi semua permintaan secara paralel, tetapi menulis hasilnya satu per satu.  Misalnya, kode eksekusi untuk kelima permintaan di atas akan terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> [montlyPrices, yearlyPrices, flightsSchedule, originPopulars, destPopulars] = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ getMontlyPrices(), getYearlyPrices(), getFlightSchedule(), getOriginPopulars(), getDestPopulars() ])</code> </pre> <br><p>  Dan kami mendapatkan semua data dalam 200-300 milidetik, mengurangi waktu pembuatan data untuk halaman dari 1-1,5 detik menjadi ~ 500 milidetik. </p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>  Beralih dari PHP ke NodeJS membantu saya menjadi lebih terbiasa dengan JavaScript asinkron, belajar cara bekerja dengan janji dan asinkron / menunggu.  Setelah mesin ditulis ulang, kecepatan pemuatan halaman dioptimalkan dan berbeda secara dramatis dari hasil yang ditunjukkan oleh mesin dalam PHP.  Pada artikel ini, kita juga dapat berbicara tentang bagaimana modul sederhana digunakan untuk bekerja dengan cache (Redis) dan pg-janji (PostgreSQL) di NodeJS dan untuk membandingkannya dengan Memcached dan php-pgsql, tetapi artikel ini ternyata cukup produktif.  Dan karena mengetahui "bakat" saya dalam menulis, ternyata ia juga tidak terstruktur dengan baik.  Tujuan artikel ini adalah untuk menarik perhatian pengembang yang masih bekerja dengan PHP dan tidak menyadari kelezatan NodeJS dan pengembangan aplikasi berbasis web di dalamnya menggunakan contoh proyek kehidupan nyata yang pernah ditulis dalam PHP, tetapi karena preferensi pemiliknya pergi ke platform lain. </p><br><p>  Saya berharap bahwa saya dapat menyampaikan pikiran saya dan kurang lebih terstruktur untuk mengungkapkannya dalam materi ini.  Setidaknya saya mencoba :) </p><br><p>  Tulis komentar apa pun - ramah atau marah.  Saya akan menjawab konstruktif apa pun. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444400/">https://habr.com/ru/post/id444400/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444390/index.html">DeviceLock 8.3 sistem DLP: satu tahun telah berlalu, Billy, tetapi Anda belum berubah sama sekali</a></li>
<li><a href="../id444392/index.html">Radiasi: risiko, keselamatan, perlindungan</a></li>
<li><a href="../id444394/index.html">Linux Foundation meluncurkan proyek DevOps baru dengan Jenkins dan Spinnaker</a></li>
<li><a href="../id444396/index.html">Gerai Epson di ISE 2019 - pameran telah berlalu, kesan tetap ada</a></li>
<li><a href="../id444398/index.html">Mengapa toko non-makanan membutuhkan organisasi swalayan?</a></li>
<li><a href="../id444402/index.html">Bereaksi Pemecahan Kode pada 2019</a></li>
<li><a href="../id444404/index.html">Kenapa kita takut dengan robot?</a></li>
<li><a href="../id444406/index.html">Digital Italia. Apa dan bagaimana cara kerjanya</a></li>
<li><a href="../id444408/index.html">Apple merilis iPad baru kemarin dan ada pertanyaan.</a></li>
<li><a href="../id444410/index.html">Peta Jaringan. Tinjauan singkat perangkat lunak untuk membangun peta jaringan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>