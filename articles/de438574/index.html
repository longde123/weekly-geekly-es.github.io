<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏾 🛸 🎠 Grundlagen der Flatter-Anwendungsarchitektur: Vanilla, Scoped Model, BLoC 👩🏻‍🤝‍👨🏼 🗺️ 🔄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(Originalartikel in englischer Sprache auf Medium veröffentlicht ) 


 Flutter bietet ein modernes Responsive Framework, eine große Auswahl an Widgets...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlagen der Flatter-Anwendungsarchitektur: Vanilla, Scoped Model, BLoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438574/"><p><img src="https://habrastorage.org/webt/2j/2p/yu/2j2pyudr-kde4fqeczqoic_9lpq.png"></p><br><p>  (Originalartikel in englischer Sprache auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Medium veröffentlicht</a> ) </p><br><p>  Flutter bietet ein modernes Responsive Framework, eine große Auswahl an Widgets und Tools.  Leider ist die Dokumentation nichts anderes als eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anleitung zur empfohlenen Architektur der Android-Anwendung</a> . </p><br><p>  Es gibt keine ideale, universelle Architektur, die den denkbaren Anforderungen einer technischen Aufgabe gerecht werden könnte, aber lassen Sie uns zugeben, dass die meisten mobilen Anwendungen, an denen wir arbeiten, die folgenden Funktionen haben: </p><br><ol><li>  Daten anfordern und herunterladen. </li><li>  Transformation und Aufbereitung von Daten für den Benutzer. </li><li>  Schreiben und Lesen von Daten aus einer Datenbank oder einem Dateisystem. </li></ol><br><p> Vor diesem Hintergrund habe ich eine Demo-Anwendung erstellt, die das gleiche Problem mit unterschiedlichen Architekturansätzen löst. <a name="habracut"></a></p><br><p>  Zunächst wird dem Benutzer ein Bildschirm mit der Schaltfläche „Benutzerdaten laden“ in der Mitte angezeigt.  Wenn der Benutzer auf die Schaltfläche klickt, erfolgt ein asynchrones Laden der Daten, und die Schaltfläche wird durch eine Ladeanzeige ersetzt.  Wenn der Daten-Download abgeschlossen ist, wird die Download-Anzeige durch Daten ersetzt. </p><br><p>  Also fangen wir an. </p><br><p><img src="https://habrastorage.org/webt/c5/by/8g/c5by8gjmz_oov-ukuy4_dwo4njs.gif"></p><br><h2 id="dannye">  Daten </h2><br><p> Um die Aufgabe zu vereinfachen, habe ich die <code>Repository</code> Klasse erstellt, die die Methode <code>getUser()</code> enthält.  Diese Methode simuliert das asynchrone Laden von Daten aus dem Netzwerk und gibt <code>Future&lt;User&gt;</code> . </p><br><p>  Wenn Sie mit Futures und asynchroner Programmierung in Dart nicht vertraut sind, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> mehr darüber lesen und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation der Future-Klasse</a> lesen. </p><br><pre> <code class="plaintext hljs">class Repository { Future&lt;User&gt; getUser() async { await Future.delayed(Duration(seconds: 2)); return User(name: 'John', surname: 'Smith'); } }</code> </pre> <br><pre> <code class="plaintext hljs">class User { User({ @required this.name, @required this.surname, }); final String name; final String surname; }</code> </pre> <br><h2 id="vanilla">  Vanille </h2><br><p>  Lassen Sie uns die Anwendung entwickeln, wie es ein Entwickler tun würde, wenn er die Flutter-Dokumentation auf der offiziellen Website lesen würde. </p><br><p>  Öffnen Sie den <code>VanillaScreen</code> Bildschirm mit <code>Navigator</code> </p><br><pre> <code class="plaintext hljs">Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; VanillaScreen(_repository), ), );</code> </pre> <br><p>  Da sich der Status des Widgets während seines Lebenszyklus mehrmals ändern kann, müssen wir von <code>StatefulWidget</code> erben.  Um Ihr Stateful-Widget zu implementieren, benötigen Sie auch die <code>State</code> Klasse.  Die Felder <code>bool _isLoading</code> und <code>User _user</code> in der Klasse <code>_VanillaScreenState</code> repräsentieren den Status des Widgets.  Beide Felder werden initialisiert, bevor die <code>build(BuildContext context)</code> Methode <code>build(BuildContext context)</code> zum ersten Mal aufgerufen wird. </p><br><pre> <code class="plaintext hljs">class VanillaScreen extends StatefulWidget { VanillaScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _VanillaScreenState(); } class _VanillaScreenState extends State&lt;VanillaScreen&gt; { bool _isLoading = false; User _user; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Vanilla'), ), body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), ), ); } Widget _buildBody() { if (_user != null) { return _buildContent(); } else { return _buildInit(); } } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { setState(() { _isLoading = true; }); widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); }); }, ), ); } Widget _buildContent() { return Center( child: Text('Hello ${_user.name} ${_user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  Nachdem das <code>build(BuildContext context)</code> des Widgets erstellt wurde, wird die <code>build(BuildContext context)</code> Methode <code>build(BuildContext context)</code> aufgerufen, um die Benutzeroberfläche zu <code>build(BuildContext context)</code> .  Alle Entscheidungen darüber, welches Widget auf dem Bildschirm angezeigt werden soll, werden direkt im Deklarationscode der Benutzeroberfläche getroffen. </p><br><pre> <code class="plaintext hljs">body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), )</code> </pre> <br><p>  Um eine Fortschrittsanzeige anzuzeigen, gehen Sie wie folgt vor, wenn der Benutzer auf die Schaltfläche „Benutzerdetails laden“ klickt. </p><br><pre> <code class="plaintext hljs">setState(() { _isLoading = true; });</code> </pre> <br><p>  Aus der Dokumentation (Übersetzung): </p><br><blockquote>  Ein Aufruf der Methode setState () benachrichtigt das Framework, dass sich der interne Status dieses Objekts geändert hat und sich auf die Benutzeroberfläche im Teilbaum auswirken kann.  Aus diesem Grund ruft das Framework die Erstellungsmethode für dieses Statusobjekt auf. </blockquote><p>  Dies bedeutet, dass das <code>setState()</code> nach dem Aufrufen der <code>setState()</code> -Methode die <code>build(BuildContext context)</code> Methode <code>build(BuildContext context)</code> erneut <code>build(BuildContext context)</code> , wodurch <strong>der gesamte Widget-Baum neu erstellt wird</strong> .  Da sich der Wert des <code>_isLoading</code> in <code>true</code> geändert <code>_isLoading</code> , wird anstelle der Methode <code>_buildLoading()</code> Methode <code>_buildLoading()</code> aufgerufen und eine Fortschrittsanzeige auf dem Bildschirm angezeigt. <br>  Genau das Gleiche passiert, wenn wir einen Rückruf von <code>getUser()</code> und die Methode aufrufen <br>  <code>setState()</code> , um den Feldern <code>_isLoading</code> und <code>_user</code> neue Werte <code>_user</code> . </p><br><pre> <code class="plaintext hljs">widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); });</code> </pre> <br><h3 id="plyusy">  Vorteile </h3><br><ol><li>  Niedrige Eintrittsschwelle. </li><li>  Keine Bibliotheken von Drittanbietern erforderlich. </li></ol><br><h3 id="minusy">  Nachteile </h3><br><ol><li>  Wenn sich der Status des Widgets ändert, wird der Widget-Baum jedes Mal vollständig neu erstellt. </li><li>  Verstößt gegen den Grundsatz der alleinigen Verantwortung.  Das Widget ist nicht nur für die Erstellung der Benutzeroberfläche verantwortlich, sondern auch für das Laden von Daten, die Geschäftslogik und die Statusverwaltung. </li><li>  Entscheidungen zur Anzeige des aktuellen Status werden direkt im UI-Code getroffen.  Wenn der Zustand komplexer wird, nimmt die Lesbarkeit des Codes stark ab. </li></ol><br><h2 id="scoped-model">  Modell mit Gültigkeitsbereich </h2><br><p>  Scoped Model ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliothek</a> eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drittanbieters</a> .  So beschreiben es die Entwickler: </p><br><blockquote>  Eine Reihe von Dienstprogrammen, mit denen Sie das Datenmodell des Ahnen-Widgets auf alle Nachkommen übertragen können.  Wenn sich die Modelldaten ändern, werden außerdem alle Nachkommen, die das Modell verwenden, neu erstellt.  Diese Bibliothek wurde ursprünglich aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fuchsia-</a> Projektcode entnommen. </blockquote><p>  Lassen Sie uns den gleichen Bildschirm wie im vorherigen Beispiel erstellen, jedoch das Scoped-Modell verwenden.  Zuerst müssen wir dem Projekt die Scoped Model-Bibliothek hinzufügen.  Fügen Sie die Abhängigkeit <code>scoped_model</code> Datei <code>scoped_model</code> im Abschnitt <code>dependencies</code> . </p><br><pre> <code class="plaintext hljs">scoped_model: ^1.0.1</code> </pre> <br><p>  Schauen wir uns den <code>UserModelScreen</code> Code an und vergleichen ihn mit dem vorherigen Beispiel, in dem wir das Scoped-Modell nicht verwendet haben.  Um unser Modell für die Nachkommen des Widgets zugänglich zu machen, müssen wir das Widget und das Modell in <code>ScopedModel</code> . </p><br><pre> <code class="plaintext hljs">class UserModelScreen extends StatefulWidget { UserModelScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserModelScreenState(); } class _UserModelScreenState extends State&lt;UserModelScreen&gt; { UserModel _userModel; @override void initState() { _userModel = UserModel(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return ScopedModel( model: _userModel, child: Scaffold( appBar: AppBar( title: const Text('Scoped model'), ), body: SafeArea( child: ScopedModelDescendant&lt;UserModel&gt;( builder: (context, child, model) { if (model.isLoading) { return _buildLoading(); } else { if (model.user != null) { return _buildContent(model); } else { return _buildInit(model); } } }, ), ), ), ); } Widget _buildInit(UserModel userModel) { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { userModel.loadUserData(); }, ), ); } Widget _buildContent(UserModel userModel) { return Center( child: Text('Hello ${userModel.user.name} ${userModel.user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  Im vorherigen Beispiel wurde der Widget-Baum jedes Mal, wenn ein Widget den Status ändert, vollständig neu erstellt.  Aber müssen wir wirklich den gesamten Widget-Baum (Vollbild) neu erstellen?  Beispielsweise ändert sich die AppBar überhaupt nicht, und es macht keinen Sinn, sie neu zu erstellen.  Im Idealfall sollten Sie nur die Widgets neu erstellen, die sich entsprechend der Statusänderung ändern sollten.  Das Scoped-Modell kann uns bei der Lösung dieses Problems helfen. </p><br><p>  Das <code>ScopedModelDescendant&lt;UserModel&gt;</code> Widget <code>ScopedModelDescendant&lt;UserModel&gt;</code> wird verwendet, um das <code>UserModel</code> in der Widget- <code>UserModel</code> zu finden.  Es wird jedes Mal automatisch neu erstellt, wenn das <code>UserModel</code> eine Änderung benachrichtigt. </p><br><p>  Eine weitere Verbesserung besteht darin, dass <code>UserModelScreen</code> nicht mehr für die <code>UserModelScreen</code> , die Geschäftslogik und das Laden von Daten verantwortlich ist. </p><br><p>  Schauen wir uns den Code für die <code>UserModel</code> Klasse an. </p><br><pre> <code class="plaintext hljs">class UserModel extends Model { UserModel(this._repository); final Repository _repository; bool _isLoading = false; User _user; User get user =&gt; _user; bool get isLoading =&gt; _isLoading; void loadUserData() { _isLoading = true; notifyListeners(); _repository.getUser().then((user) { _user = user; _isLoading = false; notifyListeners(); }); } static UserModel of(BuildContext context) =&gt; ScopedModel.of&lt;UserModel&gt;(context); }</code> </pre> <br><p>  <code>UserModel</code> enthält und verwaltet jetzt den Status.  Um Listener zu benachrichtigen (und Nachkommen neu zu erstellen), dass eine Änderung aufgetreten ist, müssen Sie die Methode <code>notifyListeners()</code> . </p><br><h3 id="plyusy-1">  Vorteile </h3><br><ol><li>  Statusverwaltung, Geschäftslogik und Laden von Daten sind vom UI-Code getrennt. </li><li>  Niedrige Eintrittsschwelle. </li></ol><br><h3 id="minusy-1">  Nachteile </h3><br><ol><li>  Bibliotheksabhängigkeit von Drittanbietern. </li><li>  Wenn das Modell komplex genug wird, ist es schwierig zu verfolgen, wann es wirklich notwendig ist, die <code>notifyListeners()</code> -Methode <code>notifyListeners()</code> , um unnötige Neuerstellungen zu vermeiden. </li></ol><br><h2 id="bloc">  BLoC </h2><br><p>  BLoC (Business Logic Components) ist ein Muster, das von Entwicklern von Google empfohlen wird.  Streams werden zum Verwalten des Status und zum Benachrichtigen über eine Statusänderung verwendet. </p><br><p>  <strong>Für Android-Entwickler:</strong> Sie können sich vorstellen, dass <code>Bloc</code> ein <code>ViewModel</code> und <code>StreamController</code> ein <code>LiveData</code> .  Dadurch wird der folgende Code leicht verständlich, da Sie bereits mit den Grundprinzipien vertraut sind. </p><br><pre> <code class="plaintext hljs">class UserBloc { UserBloc(this._repository); final Repository _repository; final _userStreamController = StreamController&lt;UserState&gt;(); Stream&lt;UserState&gt; get user =&gt; _userStreamController.stream; void loadUserData() { _userStreamController.sink.add(UserState._userLoading()); _repository.getUser().then((user) { _userStreamController.sink.add(UserState._userData(user)); }); } void dispose() { _userStreamController.close(); } } class UserState { UserState(); factory UserState._userData(User user) = UserDataState; factory UserState._userLoading() = UserLoadingState; } class UserInitState extends UserState {} class UserLoadingState extends UserState {} class UserDataState extends UserState { UserDataState(this.user); final User user; }</code> </pre> <br><p>  Der Code zeigt, dass keine zusätzlichen Methoden mehr aufgerufen werden müssen, um über Statusänderungen zu benachrichtigen. </p><br><p>  Ich habe 3 Klassen erstellt, um mögliche Zustände darzustellen: </p><br><p>  <code>UserInitState</code> für den Status, in dem der Benutzer einen Bildschirm mit einer Schaltfläche in der Mitte öffnet. </p><br><p>  <code>UserLoadingState</code> für den Status, in dem die Ladeanzeige angezeigt wird, während Daten <code>UserLoadingState</code> . </p><br><p>  <code>UserDataState</code> für den Status, in dem Daten bereits geladen und auf dem Bildschirm angezeigt werden. </p><br><p>  Wenn wir den Status auf diese Weise übergeben, können wir die Logik im UI-Code vollständig entfernen.  Im Beispiel für das Bereichsmodell haben wir weiterhin überprüft, ob der Wert des <code>_isLoading</code> <code>true</code> oder <code>false</code> , um zu bestimmen, welches Widget erstellt werden soll.  Im Fall von BLoC übergeben wir den neuen Status an den Stream. Die einzige Aufgabe des <code>UserBlocScreen</code> Widgets <code>UserBlocScreen</code> , eine Benutzeroberfläche für den aktuellen Status <code>UserBlocScreen</code> erstellen. </p><br><pre> <code class="plaintext hljs">class UserBlocScreen extends StatefulWidget { UserBlocScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserBlocScreenState(); } class _UserBlocScreenState extends State&lt;UserBlocScreen&gt; { UserBloc _userBloc; @override void initState() { _userBloc = UserBloc(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Bloc'), ), body: SafeArea( child: StreamBuilder&lt;UserState&gt;( stream: _userBloc.user, initialData: UserInitState(), builder: (context, snapshot) { if (snapshot.data is UserInitState) { return _buildInit(); } if (snapshot.data is UserDataState) { UserDataState state = snapshot.data; return _buildContent(state.user); } if (snapshot.data is UserLoadingState) { return _buildLoading(); } }, ), ), ); } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { _userBloc.loadUserData(); }, ), ); } Widget _buildContent(User user) { return Center( child: Text('Hello ${user.name} ${user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } @override void dispose() { _userBloc.dispose(); super.dispose(); } }</code> </pre> <br><p>  Der Code für das <code>UserBlocScreen</code> Widget ist noch einfacher als in den vorherigen Beispielen.  Um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statusänderungen</a> abzuhören, wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StreamBuilder</a> verwendet.  <code>StreamBuilder</code> ist ein <code>StatefulWidget</code> , das sich selbst gemäß dem letzten Wert (Snapshot) des Streams ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stream</a> ) erstellt. </p><br><h3 id="plyusy-2">  Vorteile </h3><br><ol><li>  Keine Bibliotheken von Drittanbietern erforderlich. </li><li>  Geschäftslogik, Statusverwaltung und Laden von Daten sind vom UI-Code getrennt. </li><li>  Reaktivität  Es müssen keine zusätzlichen Methoden aufgerufen werden, wie im Beispiel mit <code>notifyListeners()</code> . </li></ol><br><h3 id="minusy-2">  Nachteile </h3><br><ol><li>  Die Eintrittsschwelle ist etwas höher.  Benötigen Sie Erfahrung mit Streams oder RXDART. </li></ol><br><h2 id="linki">  Links </h2><br><p>  Sie können den vollständigen Code lesen, indem Sie ihn aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinem Github-Repository</a> herunterladen. </p><br><p>  Originalartikel auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Medium veröffentlicht</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438574/">https://habr.com/ru/post/de438574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438560/index.html">XGBoost von Grund auf neu schreiben - Teil 1: Entscheidungsbäume</a></li>
<li><a href="../de438562/index.html">XGBoost von Grund auf neu schreiben - Teil 2: Gradientenverstärkung</a></li>
<li><a href="../de438566/index.html">Apple Strange A12X Mikroprozessorgehäuse</a></li>
<li><a href="../de438568/index.html">Über Quantencomputer: Wie verschiedene Länder diese Technologie entwickeln</a></li>
<li><a href="../de438570/index.html">CS Center 2018 Silvesterwettbewerb</a></li>
<li><a href="../de438576/index.html">Beliebte Open Source - Teil drei: 5 Tools für Entwickler</a></li>
<li><a href="../de438578/index.html">Wie der Audio-Riese IT-Riese zum zweiten Mal „umgangen“ wurde</a></li>
<li><a href="../de438580/index.html">Automatisch generierte Passwörter in iOS 12</a></li>
<li><a href="../de438582/index.html">AntiRating 2018</a></li>
<li><a href="../de438584/index.html">Frontend für Backend-Entwickler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>