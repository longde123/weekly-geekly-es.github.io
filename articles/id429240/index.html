<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•— ğŸ¤·ğŸ¿ ğŸ§˜ğŸ½ Bagaimana saya mencoba memperbaiki pencarian peta untuk driver â˜¹ï¸ ğŸ¤°ğŸ» ğŸ”…</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah kisah tentang bagaimana saya mencoba memecahkan satu masalah aneh yang menghalangi saya sendiri. Ke depan, saya akan mengatakan bahwa saya ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana saya mencoba memperbaiki pencarian peta untuk driver</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429240/">  Ini adalah kisah tentang bagaimana saya mencoba memecahkan satu masalah aneh yang menghalangi saya sendiri.  Ke depan, saya akan mengatakan bahwa saya puas dengan solusi yang dihasilkan dan membawa aplikasi ke akhir yang logis.  Namun, untuk menjalankannya sepenuhnya, Anda membutuhkan lebih banyak sumber daya, jadi saya memutuskan untuk beristirahat dan bertanya kepada orang-orang apakah ada orang lain yang membutuhkannya.  Untuk tujuan ini (dan juga untuk berbicara) saya menulis di sini. <br><a name="habracut"></a><br>  Dua kata tentang diri saya: Saya tinggal di Dublin, Irlandia, saya bekerja sebagai programmer.  Itu tidak tepat di tempat, itu sebabnya di waktu luang saya di rumah saya melihat berbagai proyek, terutama di atas meja.  Saya menulis di HabrÃ© untuk pertama kalinya, meskipun saya membaca selama bertahun-tahun. <br><br><h3>  Masalah </h3><br>  Sudah lama sekali, ketika saya harus sering bepergian ke tempat-tempat asing untuk bekerja, saya mulai memperhatikan bahwa pencarian standar pada kartu apa pun sama sekali tidak berlaku untuk pengemudi saat ini.  Lihat: Anda mengemudi di daerah yang tidak dikenal, dan Anda memiliki panah bensin di nol.  Tindakan Anda?  Jika pada saat itu saya tidak sendirian di dalam mobil, maka saya memberi tahu penumpang: "Baiklah, cari pompa bensin terdekat saat saya mengemudi."  Karena jika Anda melakukannya sendiri, Anda perlu melakukan tindakan berikut: <br><br><ol><li>  Untuk berhenti </li><li>  Dalam aplikasi peta, masukkan "bensin" dalam pencarian (atau klik salah satu tombol cepat yang sekarang menawarkan beberapa kartu) </li><li>  Aplikasi melakukan pencarian dan menampilkan peta besar dengan selusin pompa bensin </li><li>  Anda mencoba mencari tahu mana yang paling dekat dengan Anda dan mengkliknya untuk membangun rute </li></ol><br>  Menurut saya, mimpi buruk.  Pertama, Anda harus berhenti atau setidaknya menunggu lampu lalu lintas.  Karena kartunya kompleks dan ikonnya kecil.  Kedua, kartu nifig tidak memberi tahu Anda apa pompa bensin terdekat.  Dalam hal ini, Google adalah yang terburuk: bahkan dalam hasil dalam bentuk daftar, Google terus-menerus mendorong bukan tempat terdekat, dan yang paling dinilai / dengan foto / berbayar / saya tidak tahu. <br><br><img src="https://habrastorage.org/webt/nc/kj/mu/nckjmuxsfajkjffvk8bx0ksjtse.png" width="300"><br><br>  Nah, faktor ketiga: kita bergerak.  Hasil kartu yang dikeluarkan relevan untuk beberapa hal, tetapi kami sudah jauh dari itu.  Apakah Anda memperhatikan bahwa bahkan rute yang diletakkan oleh Google tidak diperbarui secara otomatis jika kami telah bergeser?  Hanya jika navigasi telah diluncurkan, maka akan dibangun kembali. <br><br>  Secara umum, masalahnya jelas.  Logika yang berfungsi untuk pejalan kaki dan kebutuhan mereka, bagi pengemudi tidak ada artinya.  Saya tidak peduli dengan peringkat tempat dan jenis dapur di sana - saya perlu, tanpa terganggu dari jalan, secara real time mendapatkan rute ke pompa bensin terdekat, biaya, parkir, ATM, dll. <br><br><h3>  Ide </h3><br>  Sekarang mari kita coba menentukan skenario pencarian yang ideal.  Kriteria tersebut adalah sebagai berikut: <br><br><ul><li>  interaksinya singkat dan jelas agar tidak mengganggu pengemudi </li><li>  output berbasis jarak transparan </li><li>  pembaruan waktu nyata </li></ul><br>  Hal pertama yang memintanya adalah mengganti pencarian standar satu kali dengan pemindaian.  Artinya, rantai tindakannya kira-kira seperti ini: <br><br><ol><li>  Meluncurkan pemindaian </li><li>  Berkuda, melihat hasil terkini secara real-time </li><li>  Ketika saya menyukai sesuatu, saya mengklik dan membuka rute </li></ol><br>  Anda menentukan kriteria pencarian sebelumnya - pada kenyataannya, ini adalah jenis tempat dan jari-jari pemindaian.  Lebih lanjut, saat mobil bergerak, aplikasi bekerja seperti radar.  Cukup cepat menjadi jelas bahwa, pertama, jari-jari tidak bulat, tetapi dalam bentuk isoline.  Kedua, itu harus dibangun bukan oleh jarak, tetapi oleh waktu, karena menit lebih mudah dilihat daripada kilometer. <br><br>  Kemudian saya memikirkan cara untuk menampilkan hasilnya.  Lebih tepatnya, apakah saya memerlukan kartu sama sekali?  Pengemudi melihat aplikasi dengan satu mata dan berinteraksi dengan satu jari - dia tidak membutuhkan peta, tetapi teks besar dan tombol besar.  Karena itu, saya segera memutuskan bahwa layar utama akan menjadi daftar, dan saya mungkin menambahkan peta pada awalnya dan kemudian melihat apakah saya harus meninggalkannya. <br><br><h3>  Rencanakan </h3><br>  Mengetahui keanehan saya sendiri dari proyek peregangan, saya memutuskan untuk memberikan diri saya 2 bulan untuk semuanya - pada akhirnya saya bertemu di 3. Pada prinsipnya, aplikasi ini cukup sederhana: <br><br><ol><li>  Klien dari sepasang layar (pencarian, daftar, dan peta) </li><li>  Secara berkala mengirim ke server koordinat, radius pencarian, dan jenis tempat </li><li>  Server membangun isoline dalam waktu (omong-omong, namanya dalam bahasa Inggris - isochrone), melakukan pencarian di tempat dan mengembalikan daftar </li></ol><br>  Kedengarannya seperti paru-paru yang lebih ringan.  Saya sudah memiliki pengalaman sebelumnya dalam kartografi (beberapa tahun yang lalu saya membuat portal real estat di mana pencarian ada di peta), jadi tumpukan di backend langsung jelas: <br><br><ul><li>  impor data dari OpenStreetMaps ke Elasticsearch </li><li>  OpenTripPlanner untuk membangun kontur </li></ul><br>  Pada klien, saya pikir, memutuskan untuk menggunakan kerangka kerja baru dari Google - Flutter.  Ini adalah lintas platform, cukup fleksibel, dan memungkinkan Anda untuk membuat aplikasi lengkap dengan kode minimal.  Tentu saja, itu mentah dan tidak jelas apa yang ada di produksi, tetapi terlihat sempurna untuk pembuatan prototipe.  Harus diklarifikasi bahwa pada titik ini saya memiliki pengalaman dalam pengembangan asli untuk android (saya adalah seorang pemimpin tim) dan memutuskan, untuk berbicara, menghadapi musuh.  Musuh tidak begitu menakutkan. <br><br><h3>  Implementasi </h3><br>  Aplikasi prototipe pertama siap sangat cepat - Flutter memiliki ambang masuk yang rendah dan filosofi seperti redux yang dapat dimengerti.  Anehnya, deskripsi deklaratif antarmuka juga menyenangkan, dan juga hot reboot (Bereaksi Asli, bitmap Anda).  Secara umum, kesan adalah bahwa Google menyumbang sebagian besar penyakit bawaan dari upaya sebelumnya.  Namun, saya memahami orang-orang yang mungkin tidak ingin membahasnya - seseorang tidak suka panah, sejumlah widget, dan "debug visual" yang ditawarkan di sini adalah sesuatu yang sangat mentah. <br><br>  Di backend, saya melakukan hal berikut: <br><br><ol><li>  Memberikan Nominatim, mengunggah ekstrak data OpenStreetMaps (dibawa ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ) ke dalam basis datanya menggunakan utilitas osm2pgsql aslinya.  Mengapa saya beralih ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Photon</a> asam geokoder terbuka kecil tapi sangat menyenangkan.  Sebelumnya, saya sudah menggunakannya dalam beberapa proyek - ini menghasilkan indeks Elasticsearch, mengimpor data dari database Nominatim di sana, dan mencari indeks ini.  Saya menyukainya dengan kecepatan dan pemetaan murni (misalnya, saya mencoba Pelias dan saya kurang menyukainya).  Masalah utamanya adalah versi lama dari elastis, tetapi dalam kasus saya, saya tidak memerlukan fungsi geocoder itu sendiri, hanya data, jadi setelah mengimpor, saya mentransfer indeks ke pemasangan elastis versi terbaru dengan jiwa murni.  Ngomong-ngomong, mengapa saya memilih Elasticsearch?  Ini sangat cepat, dan memiliki fungsi menemukan koordinat dengan poligon. </li><li>  Landfill - alias isochrone - awalnya menghasilkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenTripPlanner</a> untuk saya.  Ini adalah perencana rute open source yang cukup bagus.  Ia bekerja sebagai berikut: ia mengambil ekstrak OpenStreetMaps yang sama dan mengkompilasinya ke dalam grafik jalan besar, yang, sebagai objek terpisah, disimpan ke disk.  Ketika server mulai, grafik ini dimuat ke dalam RAM dan semua rute dicari melalui itu.  Pro: mengambil cepat, fungsionalitas yang kaya (misalnya, menghasilkan kontur dari kotak) dan kecepatan yang baik.  Cons: kecepatan ini tergantung pada jumlah RAM, dan dokumentasinya sangat menjijikkan.  Dokumentasi hanya mengerikan.  Kilas balik Vietnam. </li><li>  Saya melemparkan api kecil ke python, yang mengambil jenis tempat dan radius pencarian dalam hitungan detik, meminta poligon dari OpenTripPlanner, lalu mencarinya di Elasticsearch.  Ia meminta rute ke setiap lokasi yang ditemukan (lagi dari OpenTripPlanner), membutuhkan waktu dan waktu yang lama.  Setelah itu, semua data yang dikumpulkan dikemas dan dikembalikan dengan indah. </li></ol><br>  Saya melakukan pembaruan hasil dengan menggeser koordinat perangkat sebesar 5 meter.  Peta itu statis - Saya hanya menggunakan api dari peta Google statis (seperti yang Anda lihat, ini adalah satu-satunya tempat di mana korporasi merangkak ke dunia terbuka kita yang nyaman).  Implementasi pertama terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/uu/re/ti/uuretiwzesv31fig6voucz43jx0.png" width="300"><br><br><img src="https://habrastorage.org/webt/_u/6y/ll/_u6yllx-mdeso0qlfdeaho65epg.png" width="300"><br><br><img src="https://habrastorage.org/webt/qt/le/ho/qtlehoo18mjchlj4eiybao_aei0.png" width="300">  ï¿¼ï¿¼ï¿¼ <br><br>  Setelah bermain dengan aplikasi tersebut, saya memutuskan untuk menyembunyikan peta.  Dia melakukan pekerjaan yang baik untuk memahami apa poligon pencarian dibuat, dan dia tampak lucu - itu menarik untuk melihat bagaimana gurita ini berubah bentuk secara real time.  Namun, hiburan ini tidak membantu aplikasi untuk memenuhi fungsinya dan menempati sepertiga layar. <br><br>  Terpikir oleh saya untuk menambahkan panah, yang menunjukkan arah untuk setiap hasil.  Ini berfungsi seperti ini: <br><br><ol><li>  Ingat koordinat Anda sebelumnya </li><li>  Saat bergeser, kami meletakkan rute dari posisi sebelumnya ke saat ini </li><li>  Kami mengambil segmen terakhir dari rute kami dan membandingkannya dengan segmen pertama dari rute setiap hasil.  Karena mereka diletakkan di sepanjang grid jalan yang sama, dengan probabilitas 99% sudut di antara mereka dekat dengan 0 atau 180. </li></ol><br>  Trik yang sangat sederhana ini sangat memudahkan pemahaman apakah kita sudah menuju tempat itu atau perlu membalikkan keadaan. <br><br><img src="https://habrastorage.org/webt/rb/mp/h5/rbmph5eycajawl1s5b83eamgtwy.gif" width="300"><br>  ï¿¼ <br>  Pada titik ini, saya cukup senang dengan aplikasi yang dihasilkan dan memutuskan untuk mencoba menyebarkannya ke beberapa negara.  Meski demikian, Irlandia adalah negara bagian yang sangat kecil, dan indeks elastis dan grafik jalannya kecil.  Untuk pengujian, saya memutuskan untuk menghubungkan tetangga Inggris.  Ini sekitar 4 kali lebih besar dan memiliki jaringan jalan yang jauh lebih padat (terutama ibu kota dan kota-kota besar).  Dan kemudian muncul masalah. <br><br>  Elasticsearch diharapkan mencerna kenaikan indeks dengan cukup baik, tetapi dengan OpenTripPlanner ada kegagalan total.  Itu ditulis dalam Java dan, seperti yang saya katakan di atas, menghasilkan grafik jalan, sehingga setelah memuatnya ke dalam RAM.  Grafik untuk Irlandia adalah 1 gigabyte, untuk Inggris sudah 5. Itu mungkin, tentu saja, untuk membaginya menjadi negara, wilayah dan bahkan wilayah, dan kemudian mengarahkan ke grafik yang diinginkan tergantung pada koordinat pengguna.  Namun, ini membuat tidak mungkin untuk meletakkan rute antar wilayah, dan yang paling penting, itu tidak menyelesaikan kebutuhan untuk menyimpan semua grafik ini dalam memori.  Akhirnya, hanya dengan mengkompilasi setiap objek tersebut SANGAT banyak sumber daya dan bertahan selamanya.  Untuk bersenang-senang, saya meluncurkan pada mesin saya (bingkai 16 GB) perakitan Count of France, menunggu sehari dan dibatalkan. <br><br>  Jelas, teknologi yang telah membuktikan dirinya dengan baik dalam tugas-tugas kecil tidak dirancang untuk penskalaan sama sekali (setidaknya tidak dengan sumber daya saya).  Jadi harus mengakui kekalahan, atau merangkak ke teknologi lain.  Saya beristirahat selama beberapa hari dan mulai mempelajari apa solusi open source lain yang ada di dunia.  Ternyata pada dasarnya ada dua di antaranya: <br><br><ul><li>  OpenTripPlanner </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proyek OSRM</a> </li></ul><br>  Jika yang pertama ditulis dalam Java dan memuat grafik jalan ke dalam RAM, maka OSRM - Open Source Routing Machine - sudah ditulis dalam plus dan menyimpan file perantara (tidak kurang mengerikan) pada disk.  Dengan demikian, kebutuhan untuk memiliki sejumlah besar RAM digantikan oleh persyaratan disk yang besar dan cepat.  Ini lebih nyata. <br><br><h3>  Garis finish </h3><br>  Setelah beberapa malam memilih dalam dokumentasi, semua kode server dipindahkan ke solusi baru.  Itu benar-benar bekerja, dan itu bekerja dengan cukup baik.  Itu mungkin untuk menghubungkan beberapa negara, dan bahkan kecepatan pencarian meningkat.  Prinsip-prinsip umumnya sama: dari file perantara ekstrak OpenStreetMaps dikompilasi untuk profil "mesin" (profil adalah seperangkat bobot dan instruksi untuk tepi grafik - ada profil "berjalan kaki", "sepeda", dll.).  Kemudian file-file ini dimasukkan ke dalam direktori, dan OSRM api sudah membacanya dari disk.  Omong-omong, Api ternyata agak besar - kontur dan perencanaan rute dengan berbagai nuansa didukung, bahkan ada generasi ubin untuk peta.  Saya memutuskan untuk memikirkan yang terakhir lebih terinci. <br><br>  Kembali ke aplikasi dan terus mengujinya, saya menyadari beberapa hal lagi: <br><br><ul><li>  menu di atas tidak bagus, jangkauan jauh </li><li>  peta umum jelas tidak diperlukan, itu hanya mengikat saya ke google </li><li>  kartu hasil membosankan dan monoton </li></ul><br>  Dia dengan senang hati mengeluarkan peta Google (hore, sekarang 100% open source dan datanya), menyederhanakan menu, pindah ke bawah.  Mulai memikirkan apa yang harus dilakukan dengan kartu.  Dan kemudian ubin api muncul dengan sangat tepat, yang saya sebutkan di atas.  Ini memungkinkan Anda untuk menghasilkan ubin vektor untuk koordinat yang diberikan dan tingkat zoom.  Hasilnya dikeluarkan dalam bentuk gumpalan biner dari tipe aplikasi / x-protobuf - tipe data yang agak tidak nyaman untuk manipulasi.  Saya tidak akan memerinci (saya harus sedikit berkeringat), tetapi singkatnya tindakan saya terlihat seperti ini: <br><br><ol><li>  Ambil garis rute yang dibangun ke titik dalam bentuk polyline </li><li>  Polyline -&gt; GeoJSON </li><li>  Dapatkan kotak pembatas bentuk ini </li><li>  Minta semua ubin yang ditangkap oleh kotak pembatas ini </li><li>  Konversi data ubin dari format biner ke GeoJSON </li><li>  Ubin lem, rapikan dengan kotak pembatas, kombinasikan dengan garis rute, warnai </li><li>  GeoJSON yang dihasilkan dikonversi menjadi bitmap </li></ol><br>  Selama aksi, ada nuansa yang berbeda, misalnya, indentasi kotak pembatas atau tanda titik dengan cincin berwarna (dan jadikan jari-jarinya konstan untuk semua level zoom).  Gambar yang dihasilkan tampak seperti ini: <br>  ï¿¼ <br><img src="https://habrastorage.org/webt/r2/za/2u/r2za2us1ntmhvdfshs4hsnu2rj8.png" width="300"><br><br><h3>  Sentuhan akhir </h3><br>  Ketika saya melampirkan rute visual ke setiap hasil, daftar mulai berkilau dengan warna baru.  Selain itu, menyadari bahwa setiap gambar, secara default, naik mengangkang ke utara, saya membuatnya berputar sehubungan dengan kompas.  Jadi, selain efek visual, chip ini juga menjadi fungsional - menggantikan panah arah.  Sekarang setelah Anda mengemudi, Anda dapat melihat dengan pasti sisi mana dari Anda ini atau hasil itu. <br><br>  Bulan ketiga pembangunan telah kedaluwarsa, dan itu sudah perlu dibulatkan.  Semakin banyak yang Anda tambahkan, semakin banyak yang Anda inginkan, jadi pada titik tertentu Anda hanya perlu menyatukan diri dan melepaskan proyek.  Saya mengubah dan melukis antarmuka sedikit lagi, dan untuk penyelesaian, saya membuat sketsa logo aplikasi: <br><br>  ï¿¼ <img src="https://habrastorage.org/webt/kt/pv/hq/ktpvhqnibjmjewucwszvopdmgoe.png" width="150"><br><br>  dan halaman intro: <br><br>  ï¿¼ <img src="https://habrastorage.org/webt/rq/no/l1/rqnol1usdtcguhyktktrowbdbdk.png" width="300"><br><br>  Dan akhirnya, versi terakhir dari aplikasi: <br><br>  ï¿¼ï¿¼ï¿¼ï¿¼ <img src="https://habrastorage.org/webt/ue/4p/og/ue4pogbsgbzaqbinhj3mjmronha.png" width="300"><br><br><img src="https://habrastorage.org/webt/wo/34/sw/wo34swgdxsfk6tk6uw1njgwg90a.png" width="300"><br><br><img src="https://habrastorage.org/webt/17/5p/xr/175pxr7hgipc6dpylbejnxv5hb0.png" width="300"><br><br><img src="https://habrastorage.org/webt/6r/e1/xr/6re1xrvrtcmp2udr4lyc4iqai5u.png" width="300"><br><br><h3>  Ringkasan </h3><br>  Terima kasih sudah menonton.  Saya harap aliran kesadaran ini akan menarik bagi seseorang, dan mungkin bahkan bermanfaat.  Pada tahap ini, saya pikir aplikasi sudah siap: cepat, tanpa bug khusus dan dapat bekerja di negara mana pun di dunia.  Ngomong-ngomong, Anda mungkin telah memperhatikan bahwa tangkapan layar berasal dari iPhone dan Android, karena berkat Flutter, aplikasi ini bekerja persis sama di kedua platform. <br><br>  Namun demikian, sejauh ini saya telah memutuskan untuk membekukan segalanya - mengubah pekerjaan saya, kekhawatiran baru telah muncul.  Setelah beberapa bulan, saya membersihkan debu dan memutuskan untuk menulis retrospektif.  Ulasan Anda menarik: apakah Anda menyukainya, menggunakannya, apa yang bisa diubah. <br><br>  <b>PS</b> Tentu saja, tentang kesiapan aplikasi adalah omong kosong.  Ini siap sebagai prototipe - jika Anda mendekati produksi serius, Anda perlu membuat skrip untuk menyinkronkan data dengan OpenStreetMaps, memeriksa operasi di kebun binatang perangkat, melokalisasi antarmuka, dll.  Backend yang sama pada node dan python akan jatuh di bawah beban yang serius. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429240/">https://habr.com/ru/post/id429240/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429230/index.html">Laporkan: Proyektor Epson di Integrated Systems Russia 2018</a></li>
<li><a href="../id429232/index.html">Steroid karier. Anjing</a></li>
<li><a href="../id429234/index.html">Penciptaan game "Seperti koin" di Godot Engine. Bagian 1</a></li>
<li><a href="../id429236/index.html">Berapa banyak Ilmuwan Data yang Anda butuhkan untuk menyalakan bola lampu (atau tim mana yang akan membuat data berfungsi untuk bisnis)</a></li>
<li><a href="../id429238/index.html">Sekali lagi tentang level level</a></li>
<li><a href="../id429242/index.html">â€œJangan malu-malu. Cobalah! " Wawancara tentang kehidupan, penyusun dan kehidupan dalam penyusun dengan Unity Alexandre Mutel</a></li>
<li><a href="../id429244/index.html">Greedy Gnome: Ketika saya menulis analitik pasar di Lineage 2</a></li>
<li><a href="../id429246/index.html">Magang musim panas di Mars IS: tampilan bagian dalam</a></li>
<li><a href="../id429248/index.html">Kiat Polyglot: cara mempelajari bahasa apa pun tanpa air mata dan kutukan</a></li>
<li><a href="../id429250/index.html">Seratus Resep Pembukuan Digital</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>