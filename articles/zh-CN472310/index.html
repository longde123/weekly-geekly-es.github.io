<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧖🏻 🛳️ 👩🏽‍🏭 没有密码和Cookie的站点上的客户标识：标准申请 🤲🏽 🐽 🤙🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="亲爱的habrozhitel！ 尊敬的专家！ 我为您评估了一个新的网站用户身份识别概念，希望在您的帮助下成为开放的Internet标准，使这个Internet世界变得更好一点。 这是无密码身份验证协议的草稿版本，设计为免费文章。 亲爱的读者，如果它的想法得到您的正面评价，我将继续在reddit.co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>没有密码和Cookie的站点上的客户标识：标准申请</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472310/"><img src="https://habrastorage.org/webt/zx/gv/lz/zxgvlzpzrabaux0m9y-brjkhhpi.jpeg" alt="图片"><br><br> 亲爱的habrozhitel！ 尊敬的专家！ 我为您评估了一个新的网站用户身份识别概念，希望在您的帮助下成为开放的Internet标准，使这个Internet世界变得更好一点。 这是无密码身份验证协议的草稿版本，设计为免费文章。 亲爱的读者，如果它的想法得到您的正面评价，我将继续在reddit.com和rfc-editor.org上发布。 我希望我能够引起领先浏览器开发人员的兴趣。 因此，我希望您提出建设性的批评。 <br><br> 注意：大量文字。 <br><br><a name="habracut"></a><br> 问题是。 是否可以明确标识站点访问者而不泄露他们的个人数据并在不同站点之间进行跟踪？ 解决这样的问题，是否有可能完全放弃登录名/密码所使用的最原始的授权形式，而使用cookie / localStorage？ <br><br> 一方面，站点需要识别客户，以便例如“恢复”其设置，产品篮，广告，文章等。 另一方面，访问者希望尽可能保持匿名，而不泄露其个人数据，并阻止第三方站点对其进行跟踪。 后者可以通过在彼此之间交换所收集的数据来做到这一点。 <br><br> 听起来像是要确保狼吃饱了，羊是安全的任务。 这是真的吗？ <br><br> 在某种程度上，我认为我-是的。 <br><br><h1> 目录 </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1无密码认证概念</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.1键和令牌，而不是登录名和密码</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.2代币结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/472310/&amp;usg=ALkJrhgJOKd6hnAIaoX3jS3HWXN7nNAO9g#">1.3 HTTP协议标头</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.4客户如何识别站点？</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.4.2如何知道站点是否支持此协议？</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.5客户如何授权网站？</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.6如何实施可靠的客户识别？</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.7通过用户的眼睛对网站的授权</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.8站点密钥如何更改？</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.9如何实施跨域授权？</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.10如何实现跨域认证？</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.11帐户移动性</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2协议的技术说明</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.0域密钥生成算法</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.1计算源令牌的算法</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.2传输期间的令牌保护算法</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.3浏览器和服务器之间的盐交换程序</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.4上下文字段的形成规则</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.5定义发件人和收件人字段的规则</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.6上下文定义表的详细信息</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.7协议场景</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.8在服务器上处理令牌</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.9跨域认证</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3安全建议</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.1保护关键信息免遭未经授权的访问</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.2关于密码作为域密钥</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.3丢失/破坏密钥并将密钥最小化的风险</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4攻击授权方案</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.1用户跟踪</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.2 XSS攻击</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.3 CSRF攻击</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.4使用SSO进行跟踪</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.5 SSO的主要危害</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.6转让期间的代币泄露</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.7入侵网站并破坏令牌</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结论</a> <br><br><br><div class="spoiler">  <b class="spoiler_title">密码有什么问题？</b> <div class="spoiler_text"> 是的，事实并非如此。 他们可能会丢失。 他们可能被盗。 必须记住它们。 无论如何，为什么我必须填写某种形式的注册并输入另一个密码来查看天气或下载此文件？ 最后，密码比许多少。 您喜欢多少个站点，那么多密码。 因此，许多人实际上在所有站点上都使用一个密码。 有人使用棘手的算法来记住它们。 或密码管理器。 或者，愚蠢的笔记本。 还是更喜欢跨域身份验证：您只需在一个网站上登录一次即可！ 是的，不是全部。 这是网站支持的情况。 <br> 所有这些方法都有缺点。 <br> 在不同的站点上使用一个密码-Moveton。 两个人都知道，猪也知道。 并非所有站点（甚至大型且信誉良好）都诚实地遵守存储密码的安全规则。 一些网站以开放形式存储密码，而另一些网站则认为存储密码哈希值已经足够保护了它们。 结果，经常发生客户的密码和其他个人数据的泄漏。 <br> 用密码管理器已经更好了。 是的，没有人保证您不会在某个地方合并您的密码。 然后找到一个可以在所有设备（家用上网本，电话，办公计算机）上同步您的帐户的经理。 我不排除存在这种情况。 <br> 但无论如何，这个想法本身就是：先在我们的网站上注册（同时发送电子邮件，手机，献血进行分析），然后发明/记住您的用户名和密码，并且要记住它们，但要保持秘密-方法，我告诉你，马马虎虎。 而且没有一个密码管理器可以解决这个问题。 但这解决了<abbr title="由各种协议（例如SAML，OAuth，Kerberos）实现的单点登录技术">SSO</abbr> 。 <br> 真是倒霉：如果您从SSO网站上丢失了密码而忘记了密码，或者密码被您窃取了……您一次失去了所有网站的访问权限，或者自愿将其泄露给任何人，而且意图不明。  <b>不要将所有鸡蛋都放在一个篮子里！</b> <br>  SSO站点可靠并非事实。 或者不以明文形式存储密码。 或者完全不自愿合并它们，而且它为其他人提供了在站点之间跟踪您的机会。 好吧，你明白了。 <br> 因此：登录名+密码=邪恶。 而且，世界上所有的邪恶都应该认真地长期喝下去。 还有一个饼干。 连同其会话鳄鱼PHPSESSIONID，JSESSIONID及其类似物。 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">怎么办？</b> <div class="spoiler_text"> 首先，您需要考虑一些典型情况，从中可以清楚地看出：为什么网站要记住他们的客户，对他们来说真的有必要吗？ <br><ol><li> 个人博客“ Vasya Pupkina”，例如，允许发表评论。 只有为了保护自己免受机器人攻击，进行免费投票，计算“赞”和其他“喵喵”并为评论员分配等级，才需要注册。 即 在此<b>，网站</b>仅<b>需要跟踪功能</b> ，而用户仅在很小的程度上<b>需要跟踪功能</b> （如果用户在此网站上对“评论员”评分很高）。 </li><li> 社交网络和其他网络对话者的站点（ICQ，skype-那里）。 需要注册才能实现命名（作者）内容，以识别彼此的访问者。 即 在此<b>，用户自身在更大程度上需要识别功能</b> 。 尽管社交网络的站点在“罪犯”列表中排名第一，但它会收集有关访问者的最完整信息，并长时间认真地记住您。 因此，尚不清楚谁需要更多身份识别。 </li><li> 具有封闭内容的公司网站。 这里需要注册或授权，主要是为了限制对内容的访问。 各种各样的：在线学校，图书馆，私人非公共站点等等。 在此<b>，站点更需要授权功能</b> 。 通常，没有公开的注册表。 凭证通过其他渠道共享。 </li><li> 在线商店和其他类似的平台，用于销售商品，服务或内容。 我还将包括付费/免费分类广告网站。 主要需要注册来存储客户订单的历史记录，以便他可以跟踪客户的当前状态，存储他们的偏好（收藏夹）； 为了根据购买历史和偏好向客户制定个人报价。 在这里<b>，识别功能对于顾客和商店都是同样必要的</b> 。 但是，当然还有更多。 蒸，蒸和蒸。 </li><li>  Internet服务用户的任何个人帐户：电子邮件，公共服务，Sberbank在线，megaphone在线，提供商办公室，托管者的CMS等。 在此<b>，用户本人首先对正确和可靠的标识感兴趣</b> 。 毕竟，他管理着对自己重要的信息，在某些情况下，这些信息会带来法律和财务后果。 它闻起来不像匿名。 她在这里有害。 </li><li> 路由器，管理控制台，用于管理家庭或公司网络中某些内容的Web版本。 </li></ol><br><br> 显然，在不同情况下，可能存在不同的风险。 在某些情况下，标识错误，认证数据丢失甚至被盗/伪造都不会对站点或用户造成任何重大后果。 在其他情况下，这将是令人不快的（我在哈布雷（Habré）上失去业力-“这是一场灾难...”）或会带来不便（我无法在尤拉（Yula）专心，看到我的广告；我已经在github上访问了我的项目，-好的新帐户，fork项目）。 第三，它可能带来法律和财务后果。 因此，必须假定提议的授权方案并非在所有情况下都是“灵丹妙药”，尤其是“裸露”的情况。  <b>在管理敏感信息的情况下，值得使用其他身份验证和身份验证方法</b>或其组合（两因素身份验证，非对称密钥加密，3D安全，eToken，OTP-Token等）。 <br><br> 哦好 你的TK是什么？ <br></div></div><br><div class="spoiler">  <b class="spoiler_title">新协议提供了什么？</b> <div class="spoiler_text"> 从最终用户的角度来看： <br><ol><li> 该网站应记住并认可访问者，而无需用户输入任何信息； 该网站应该在会话内以及会话之间识别您。 没有Cookie，密码或注册。 同时，不同的站点应该不能唯一地标识同一位访问者，也不能跟踪他们在这些站点和其他站点上的活动。 即 网站不应为访问者汇总信息。 </li><li> 用户应该能够随时“ <b>忘记任何站点</b> ”； 网站将忘记用户。 应该有可能在客户的主动下授予站点记住客户的权利（没有强制性弹出窗口）。 用户应该能够在不同的设备和浏览器之间安全地迁移其虚拟身份（如果需要），以便在自己喜欢的网站上获得单个授权。 </li></ol><br><br> 知道了 网站开发者应该从中获得什么奖励呢？ <br><ol><li> 识别过程更简单：无需千分之一地创建下一种登录，注销，注册，更改和密码恢复形式。 激活您最喜欢的框架的协议支持模块就足够了，该模块基于该标准实现。 </li><li> 设计人员无需绘制登录表单并考虑将其隐藏在小屏幕上的位置。 该协议使表格完全没有必要。 好吧，除了注册表。 那没有他们在哪里呢。  las </li></ol><br><br> 最后： <br><ol><li> 认证协议必须统一，规范； 由安全专家验证 网站标准化委员会批准并推荐。 结果，开发标准登录/注销表单，更改/恢复密码（以明文形式传输密码，不正确地使用哈希，在数据库中存储密码或“非盐分”哈希值，在数据库中劫持用户密码）时，网站管理员可能会犯经典错误。黑客网站）。 </li><li> 授权在某种程度上应该是可靠的（防止伪造，未经授权的访问以及有保证的认证）； 不要在网页和浏览器上创建新漏洞； 如果可能，立即降低已知网络攻击的风险。 好吧，或者至少是大大减少了成功实施它们的风险。 </li></ol><br><br> 基于这些要求，我们转向最有趣的：设计新协议。 <br></div></div><br><br><a name="part1"></a><h1>  1无密码认证概念 </h1><br><br><a name="tokens_vs_passwords"></a><h2>  1.1键和令牌，而不是登录名和密码 </h2><br> 对于每个域（包括子域），客户端浏览器都会随机生成一个唯一的256位密钥 <math></math><img src="https://habrastorage.org/getpro/habr/formulas/8b1/9d8/49a/8b19d849a66473b36d68c78d06462129.svg" alt="$ K $" data-tex="inline">  。  <b>此密钥从不发送。</b> 在用户会话中保持不变。 每个新会话都会创建一个新密钥。 <br> 基于密钥 <math></math><img src="https://habrastorage.org/getpro/habr/formulas/8b1/9d8/49a/8b19d849a66473b36d68c78d06462129.svg" alt="$ K $" data-tex="inline"> 浏览器使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">特殊算法</a>生成256位<sup>*</sup>令牌 <math></math><img src="https://habrastorage.org/getpro/habr/formulas/175/f98/839/175f98839ab732db76d5f20cd6ce2ce9.svg" alt="$ T $" data-tex="inline"> 识别具有特定域的用户。 识别令牌 <math></math><img src="https://habrastorage.org/getpro/habr/formulas/175/f98/839/175f98839ab732db76d5f20cd6ce2ce9.svg" alt="$ T $" data-tex="inline"> 用户（以下简称为令牌）代替了会话cookie（例如PHPSESSIONID和JSESSIONID）。 <br> 关键 <math></math><img src="https://habrastorage.org/getpro/habr/formulas/8b1/9d8/49a/8b19d849a66473b36d68c78d06462129.svg" alt="$ K $" data-tex="inline"> 可以由用户“ <b>固定</b> ”。 修复密钥将使用户可以在不同的浏览器会话中无限期地保留在站点上的授权，并返回以前存在的授权。 这<b>类似于“记住我”功能</b> 。 <br> 取消提交后，浏览器将“忘记”该密钥，并再次开始为每个新会话（从当前会话开始）为该域生成一个随机密钥， <b>类似于</b>用户从站点的<b>“退出”</b> 。 输出是即时的，不需要重新加载页面。 <br> 用户可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为域创建一个永久密钥</a> 。 永久密钥以及固定密钥将允许用户返回先前的授权。 实际上，该<b>密钥替代了登录密码连接。</b> <br> 用户有机会控制域的浏览器何时使用常数键，以及何时-随机。 这<b>类似于登录/注销功能</b> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下面的屏幕快照中介绍了</a>该概念。 <br> 生成永久域密钥的方法提供了不同设备之间用户帐户的移动性。 该协议定义以下内容： <br><ul><li> 根据用户主密钥生成域密钥 </li><li> 基于生物随机数传感器分别形成域密钥 </li><li> 从另一个设备的密钥文件导入现有密钥 </li></ul><br><br><a name="token_structure"></a><h2>  1.2代币结构 </h2><br> 令牌是256位结构，表示为十六进制字符串： <br><div class="scrollable-table"><table><tbody><tr><td>  84bc3da1b3e33a18e8d5e1bdd7a18d7a </td><td>  166d77ac1b46a1ec38aa35ab7e628ab5 </td></tr><tr><td> 识别部分 </td><td> 认证部分 </td></tr></tbody></table></div><br> 令牌的标识部分（最高128位）类似于登录名。 通过此位序列，服务器可以唯一地标识用户。 <br> 令牌的身份验证部分（低128位）类似于密码。 此位序列有助于服务器验证令牌。 <br> 令牌验证规则<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如下所述</a> 。 <br><br><a name="http_headers"></a><h2>  1.3 HTTP协议标头 </h2><br>  <b>客户端使用的标头：</b> <br><br>  <b>CSI-Token</b> ：&lt;Token&gt;用于将令牌发送到服务器 <br>  <b>CSI-Token</b> ：&lt; <b>令牌</b> 1&gt;;  <b>Changed-To</b> &lt;令牌2&gt;用于更改当前令牌： <br><ul><li> 在授权使用永久密钥时， </li><li> 注册永久密钥时， </li><li> 更改永久密钥时。 </li></ul><br>  <b>CSI-Token</b> ：&lt;Token&gt; <b>永久</b>由用户修复当前的随机密钥时使用。 <br>  <b>CSI-Token</b> ：&lt;Token&gt; <b>注销</b>用于过早结束当前会话。 <br><br>  <b>服务器使用的标头：</b> <br>  <b>CSI支持：yes</b>告诉客户端服务器支持CSI授权协议。 <br>  <b>CSI-Token-Action：CSI-Token-Action：成功</b>用于通知浏览器有关新用户令牌（Change-To密钥）的接受。 <br>  <b>CSI-Token-Action：CSI-Token-Action：中止会</b>取消更改令牌的过程（回滚到前一个令牌）。 <br>  <b>CSI-Token-Action：CSI-Token-Action：注册</b>告诉浏览器新用户令牌仍在注册过程中。 <br>  <b>CSI-Token-Action：无效的</b>服务器端令牌验证错误。 <br><br> 终于 <br> 交换用于保护令牌的“盐”（身份验证部分）时，浏览器和服务器<b>都会</b>发送<b>CSI-盐</b> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关</a>更多详细信息， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请参见下文</a> 。 <br><br><a name="how_site_identify_us"></a><h2>  1.4客户如何识别站点？ </h2><br> 网站可以使用令牌来标识网站访问者。 同时，令牌生成方案及其256位容量可<b>为每对</b>用户域<b>保证唯一的令牌</b> 。 另一个域将看到另一个用户令牌。 即使在目标站点的上下文中执行（通过IFRAME，IMG，LINK，SCRIPT）。 此外，一种特殊的令牌生成算法可保护用户免受XSS和SRF攻击，并使其无法在用户不知情的情况下进行跟踪。 但是与此同时， <abbr title="由各种协议（例如SAML，OAuth，Kerberos）实现的单点登录技术">SSO</abbr>技术<abbr title="由各种协议（例如SAML，OAuth，Kerberos）实现的单点登录技术">仍然</abbr>可以通过其许可和跨域标识来实现。 <br> 令牌<u>与每个</u>对任何域资源（页面，文档，图像，脚本，样式，字体，文件，ajax请求等）的<u>请求</u>一起<b>在CSI-Token HTTP标头中传输</b> ： <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ki/mv/0k/kimv0kx4wvesmftizvvlgpfe088.png"></div><br>  <b><i>在每个</i> HTTP（S）请求</b> ：页面，图片，ajax请求中都会<b>重新计算</b>令牌。 <br> 为了优化计算，允许浏览器对令牌进行缓存，但是仅在会话持续时间内并且仅在满足请求的条件保持不变的情况下才允许对令牌进行缓存。 <br> 如上所述，令牌可以替代会话cookie（例如PHPSESSIONID和JSESSIONID）。 唯一的区别是，如果该站点先前为访问者生成了一个标识符，以在其不同请求之间跟踪特定用户（毕竟，来自不同用户的数千个请求同时到达该站点），则客户端现在将执行此功能。 <br> 这样的识别足以让您在网上商店进行购买，在适当的网站上做广告，在论坛上，在社交网络上，在Wikipedia或Habré上写字。 <br> 是的，用户对该站点保持匿名。 但是它可能是该站点的匿名“熟悉”站点。 服务器可以将此类用户的令牌及其数据（带有购买，偏好，业力、,头，喜欢和其他奖励的个人帐户）连同其数据一起保存在其一边。 但仅在完成任何业务流程的条件下进行：购买，提交公告等。 条件由站点本身确定。 <br> 如您所见，对于不需要在向您采取任何行动之前进行注册的网站，该协议尽可能地简单。 但是那些需要它的人会遇到一些困难。 但是下面有更多关于它的内容。 <br><br><a name="how_we_know_what_sci_supported"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.4.2如何知道站点是否支持此协议？ </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该站点应</font><font style="vertical-align: inherit;">在其响应的“响应</font><font style="vertical-align: inherit;">标</font><font style="vertical-align: inherit;">头”部分中</font><font style="vertical-align: inherit;">通过“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CSI-Support：是”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> http标头</font><font style="vertical-align: inherit;">：</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ly/gs/zu/lygszusqavjk8yjnljig4pgojdm.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看到这样的标题，浏览器将毫不干扰地通知用户他可以将自己保存在网站上。</font><font style="vertical-align: inherit;">例如，地址栏中的钥匙符号：</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ar/ff/bt/arffbt4ibbg__wlp7eyvaei_gvq.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，点击一个键，将为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.youtube.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">域创建一个键</font><font style="vertical-align: inherit;">：</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fq/7c/4p/fq7c4piubz15qir9xtxchg9639o.jpeg"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 新密钥的形成不会导致其自动使用。 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 永久密钥仅在用户激活后才开始使用。 </font></font><br><br><a name="how_make_authorization"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.5客户如何授权网站？ </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要的是要了解令牌还不能使用户在特定站点上获得授权-只能被识别。</font><font style="vertical-align: inherit;">但是，正如已经说过的那样，现在您只是一个可以识别的“匿名者”。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果该站点需要将您的令牌与您个人相关联，那么请避免在该站点上注册。</font><font style="vertical-align: inherit;">但是在提议的协议中，这变得容易一些。</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于开发人员而言，重要的是要理解：大多数站点不需要问卷。</font><font style="vertical-align: inherit;">避免强迫访客注册。</font><font style="vertical-align: inherit;">在大多数典型情况下，您可以执行业务流程而无需收集PD访问者。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“有或没有”填写繁琐的注册表是不愉快的。</font><font style="vertical-align: inherit;">但是，使用新协议，不再需要提供另一个登录名和密码。</font><font style="vertical-align: inherit;">仅“确认并保存我”按钮：</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/__/0i/1x/__0i1xkyu82-ne_cnghuongzrfy.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，您必须首先为该站点创建一个永久密钥。</font><font style="vertical-align: inherit;">但这只是几次鼠标单击的问题。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而且，可以肯定的是，将要求您确认电话或邮寄地址。</font><font style="vertical-align: inherit;">但这已经取决于站点。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">授权成功后，服务器将通过特殊的HTTP标头</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CSI-Token-Action</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将通知浏览器它已接受新密钥。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二章有</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更多细节</font><font style="vertical-align: inherit;">。</font></font><br><br><a name="how_implement_reliable_identification"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.6如何实施可靠的客户识别？ </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在更严重的情况下（提供者，托管人，银行的个人帐户），应该并且可以进行两步验证，并且可以通过其他方式通过电子邮件的预先注册和身份确认来完成令牌拥有的证明：通过电子邮件，SMS甚至是通过固定用户令牌的书面方式。</font><font style="vertical-align: inherit;">（是的，是的。证书记录在纸上，为什么不是令牌）。</font></font><br><br><a name="user_view_concept"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.7通过用户的眼睛对网站的授权 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浏览器通过地址栏中的锁定图标通知用户该站点支持CSI授权。</font><font style="vertical-align: inherit;">如果您在网站上执行某些操作，则可以要求网站记住您。</font><font style="vertical-align: inherit;">从这一刻起，服务器将即使在不同的会话之间也可以识别用户：</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/up/et/3q/upet3q-qbs8ikn4ba9t0ycn8voy.gif"></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在插图中</font></font></b> <div class="spoiler_text">     ,  .       ,   ,  ,   .    ,   .    .    .   ,   , ,      .   .  . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户可以不固定密钥，而可以为站点创建永久密钥并在此处注册。</font><font style="vertical-align: inherit;">动画插图：</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/32/82/tm/3282tmri0zwdfx1jqi_zgd76zu0.gif"></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在插图中</font></font></b> <div class="spoiler_text">   .   .  .      . <br>     ,  « ».      . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 并且，当用户拥有该站点的永久密钥并且该密钥在此处注册时，登录过程将大大简化： </font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u4/cm/_g/u4cm_gdewg2j7ree3gq3phuz6x4.gif"></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在插图中</font></font></b> <div class="spoiler_text">   . ,    .  ,  «».   ,  . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当用户基于主密钥为站点创建密钥时，将体现出协议的最大功能。</font><font style="vertical-align: inherit;">在这种情况下，可以轻松</font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决在其他设备上的站点上进行标识的问题</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">以下动画对此进行了演示。</font><font style="vertical-align: inherit;">假设您之前曾在设备/浏览器之间分配过一次主密钥：</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xs/ye/tx/xsyetxguxoesirmridywcy-2rts.gif"></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在插图中</font></font></b> <div class="spoiler_text">      .       -.  .    (  ). <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 对于具有两要素授权的网站，“识别”可能如下所示： </font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/du/ab/cl/duabclss3t9nkxpnjygrqfxjdha.gif"></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在插图中</font></font></b> <div class="spoiler_text">   .   .       .   ;    .   . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">退出更加容易。</font><font style="vertical-align: inherit;">在浏览器中单击“注销”，仅此而已：</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/do/2r/fe/do2rfebsd3orgwphl0ujrt_o52q.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浏览器使用HEAD方法将请求发送到站点（在任何页面上），并在其中发送CSI-Token &lt;&gt;标头；</font><font style="vertical-align: inherit;">注销。</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mt/gj/s1/mtgjs1i1jmtbehjyus_hfukqsq4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务器看到这样的标头，将注销。</font><font style="vertical-align: inherit;">如果它是固定密钥，则该站点将删除有关该用户的所有信息（绝不会出现更多此类密钥）。</font><font style="vertical-align: inherit;">如果它是永久密钥，则中断会话。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该网站的任何进一步活动都会使用户变成该网站未知的匿名用户：重新加载页面，尝试发出ajax请求，下载文件等。</font><font style="vertical-align: inherit;">-浏览器将发送已经基于随机密钥生成的令牌。</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以在密钥管理器中管理密钥：更改永久密钥，将永久密钥导出到文件，从另一设备从文件导入。</font><font style="vertical-align: inherit;">关闭标签页或浏览器后，设置“自动退出”。</font><font style="vertical-align: inherit;">设置固定键的持续时间。</font></font></blockquote><br><br><a name="how_user_can_change_key"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.8站点密钥如何更改？ </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从技术上讲，替换站点的永久密钥与将随机密钥更改为永久密钥相同。</font><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二章中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对此进行了更详细的描述</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在更改站点的永久密钥的情况下，浏览器会通知站点令牌中的相应更改，并</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在随后的每个请求中</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送</font><font style="vertical-align: inherit;">带有</font><b><font style="vertical-align: inherit;">Changed-To</font></b><font style="vertical-align: inherit;">密钥</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CSI-Token</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标头</font><font style="vertical-align: inherit;">：</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xk/rp/75/xkrp75ivdr3kjj1_i2sh9iwfqaa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该站点必须正确处理此类请求。</font><font style="vertical-align: inherit;">并且，如果给定的用户令牌存储在其数据库中，则必须进行适当的替换。</font><font style="vertical-align: inherit;">同时，网站应就其一侧令牌的成功更改对浏览器做出响应。</font><font style="vertical-align: inherit;">他在Response Headers头中使用参数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CSI-Token-Action：success</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，指示所应用</font><b><font style="vertical-align: inherit;">的令牌来执行此操作</font></b><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该站点有权拒绝使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CSI-Token-Action：aborted参数</font></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改令牌的尝试（例如，如果其数据库中没有此类令牌或根本不保存它们）</font><b><font style="vertical-align: inherit;">。</font></b></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在浏览器收到CSI-Token-Action标头之前，它将向每个站点的CSI-Token请求添加Changed-To键。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类似于用户的“密码更改”。</font></font></b> <br><br><a name="how_make_cross_domain_auth"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.9如何实施跨域授权？ </font></font></h2><br> 使用<abbr title="由各种协议（例如SAML，OAuth，Kerberos）实现的单点登录技术">SSO</abbr>技术的经典跨域授权对用户而言具有许多优势。 您无需记住来自多个站点的一堆密码。 无需注册和填写沉闷的表格。 某些授权服务器询问授予请求SSO的站点的权限。 <br> 但是也有缺点。  <b>您取决于SSO提供程序。</b> 如果SSO服务器不起作用，您将无法到达目标站点。 如果您丢失密码或您的帐户被盗-您将一次失去所有站点的访问权限。 <br> 对于Web开发人员而言，事情要复杂一些。 从一开始，您需要在授权服务器上注册您的站点，获取密钥，学习如何使用协议（ <abbr title="在帐户提供商和服务提供商之间交换身份验证和授权数据的开放标准">SAML</abbr> ， <abbr title="一种开放式授权协议，该协议允许向第三方提供对用户受保护资源的有限访问权限，而不必将登录名和密码转移给第三方">OAuth</abbr>等）和相应的库，确保密钥不过期，并且授权服务器不会由于您的原因而阻止您的站点，并且等 您无需保留用户帐户，注册表格，登录等信息，这是收费的。 事实增加了维护成本（以修复突发故障的形式）。 同样，如果该服务器突然无法访问该站点，则可惜。 <br> 这种授权方案使SSO更加安全，并且对所有参与者的授权也更加容易。 关于安全性，将在下面的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ SSO的密钥妥协”</a>部分中讨论<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> <br><br> 看一下支持Google SSO的站点S。 假设您有一个Google帐户。 要登录，请单击“使用Google登录”链接，这将打开Goog​​le授权标签。 浏览器会告诉您您具有Google密钥。  Google会告诉您S.请求什么权利。 <br> 如果您同意，请在密钥管理器中单击“登录”。 页面将重新加载。  Google将已经收到其有效令牌，可以识别并授权您。 并通过服务器间请求，它将根据请求的字段将您的帐户信息通知站点S。 <br> 重新加载的页面将包含一个“下一步”按钮，可将您返回到目标站点。 <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w5/u1/aa/w5u1aahv-_os9k2d81c819d5zhg.gif"></div><br><div class="spoiler">  <b class="spoiler_title">在插图中</b> <div class="spoiler_text"> 当他通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">account.google.com</a>使用跨域授权在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.youtube.com上</a>注册时，他将提供此算法的示例。 <br></div></div><br> 站点S可能决定是否将有关您的数据保存在其数据库中。 此问题超出了建议的授权方案的范围。 但是，此外，在考虑丢失SSO密钥的风险的情况下，建议该站点将SSO的用户令牌和标识符保留在其一边，并建议用户为S创建永久密钥。 <br><blockquote>  <b>漏洞：</b>获得授权后，站点S1，S2，S3 ...（您通过Google登录的站点）将能够识别您（通过Google分配给您的标识符），从而跟踪您的活动。 </blockquote><br><blockquote>  <b>保护选项：</b>如果您通过同一提供商的SSO注册，则不能同时在站点上工作。 如果可能，在完成授权（域的“自动退出”）后立即从授权服务器注销。 </blockquote><br><br><a name="how_make_sub_domain_identify"></a><h2>  1.10如何实现跨域认证？ </h2><br> 当然，所有这些都是好的。 尽管工作是在一个浏览器上进行的，但是一切都很好。 但是，当一个人拥有两部手机，一部工作计算机和几台浏览器，一部家用计算机和另一台笔记本电脑时，现代现实又如何呢？ 以及为妻子/孩子准备的通用平板电脑。 <br> 我们必须以某种方式解决在浏览器，设备之间转移域密钥的问题。 并且还解决了它们正确同步的问题。 <br> 解决该问题的机制之一是基于公共主密钥来计算各种域密钥，而没有从已知域密钥反向恢复主密钥的可能性。 <br> 在一个设备上使用主密钥M为域D创建了个人密钥K之后，用户可以使用相同的主密钥M和单个算法在域D上以及在其他任何一个域上创建相同的密钥K。 更准确地说，这不是由用户而是由他的浏览器完成。 使用这种方法，用户就可以在他使用的所有浏览器之间分配他的主密钥，并且他可以立即“转移他的所有密钥”域。 同时以这种方式进行备份。 <br> 最大程度的用户便利。  <b>但是</b> ，如果万能钥匙失窃， <b>也将带来最大风险</b> 。 因此，后者必须得到相应的保护。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ 3安全建议”</a>一章中介绍了丢失或破坏主密钥的风险以及将此类风险降至最低的方法。 <br> 仅使用一个主密钥来生成所有域的所有密钥并不总是一种方便的选择。 首先，如果域密钥突然遭到破坏并需要更改，该怎么办？ 其次，如果您需要与他人共享域密钥怎么办？ 例如，在家庭成员之间。 还是公司的公共邮件访问帐户。 然后如何“领取”您的密钥（因为实际上它已被盗用）？ <br> 因此，浏览器必须支持使用生物随机数传感器生成单个域密钥。 但是，我们再次回到移动性和同步性问题，在浏览器中导出和导入密钥以及创建备份副本的功能。 <br><br><h3> 通过可转让的物理设备转移 </h3><br> 智能卡和USB令牌非常适合作为密钥信息的安全存储（因为它们是为此创建的）。 两因素身份验证通过直接访问设备来保护密钥免遭未经授权的访问。 <br> 的确，智能卡需要特殊的读取器（更不用说驱动程序了），这限制了它们只能用于配备有此类读取器的工作站。 <br> 使用USB令牌要容易一些。 只需要驱动程序。 但是您不能在手机中粘贴这样的令牌。 而且，尽管对于移动电话，有以SD卡形式生成的令牌，但这并不是说此解决方案增加了移动性。 尝试从手机中提取一张卡，但将其插入另一张中。 这不是不可能的。 问题是它不方便。 <br> 如果令牌破裂？ 然后，您所有的钥匙都将进入大克苏鲁。 <br> 因此，这种使用多个重复设备的方案很有吸引力。 但是，如果您有多个智能卡，则仍然需要解决密钥同步问题。 <br> 而且，坦率地说，此类设备不受键盘记录程序的保护。 现在，如果将通过卡/令牌本身输入密码。 然后另一件事。 但是我从没见过这样的天性。 <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gq/1g/js/gq1gjsgtxvfjjvs79syif5_u8_w.png"></div><br><blockquote>  <b>优点：</b>可以使用随机的256位密钥； 通过使用两因素身份验证实现高安全性； 防止直接篡改的最高级别的保护。 <br>  <b>缺点：</b>设备依赖性； 需要财务费用； 行动不便； 需要保留卡并因此在它们之间同步数据； 键盘记录程序仍然存在漏洞。 <br></blockquote><br><h3> 通过在线服务同步 </h3><br> 现在尽可能地推销“云技术”。 看来它们与区块链一起已成为“香蕉技术”的替代品。 自然地，希望使用某种因特网平台来交换关键信息。 一种智能卡“在线”。 <br> 什么啊 您在这样的站点上使用我们的计划匿名登录； 将用密码加密的密钥发送到该处； 您使用相同的密钥/密码从另一台设备转到相同的站点； 您从那里得到钥匙； 您可以按编辑日期同步更改。 与密码管理器类似，仅此功能在线。 <br> 就是说，没有人能保证在线服务不会被黑或不会合并您的（即使是加密的）“必要时”密钥。 谁将免费实施这种服务。 就是这样 <br> 当然，虽然密码可以防止密钥被直接使用。 但是您的密码可以抵抗暴力“离线”吗？ 那是另一个问题。 <br><blockquote>  <b>优点：</b>高凭据移动性； 设备和浏览器的独立性； 您只需要一个密码（尽管他们没有留下密码，但最好还是这样）。 <br>  <b>缺点：</b>安全性不如将密钥存储在可移动媒体上。 实际上，密钥的安全性取决于选择密码的强度。 <br></blockquote><br> 当然，您可以使用主密钥来加密其他密钥。 用于计算其他域密钥的密钥。 作为一种选择。 <br><br><a name="part2"></a><h1>  2协议的技术说明 </h1><br><br><a name="perm_key_algo"></a><h2>  2.0域密钥生成算法 </h2><br> 该协议仅定义了两种生成域密钥的方法。 <br><br><ul><li> 基于随机数生成器（最好是生物学的） </li><li> 基于256位主密钥 </li></ul><br> 在后一种情况下，域密钥的计算公式为： <br><p></p><p><math></math><img src="https://habrastorage.org/getpro/habr/formulas/3aa/d39/ac7/3aad39ac79fc322d157a9f4c58a793f2.svg" alt="$ K = HMAC_ {M_ {key}}（域）$" data-tex="display"></p> 在哪里 <math></math><img src="https://habrastorage.org/getpro/habr/formulas/0b7/f4d/5a6/0b7f4d5a6dcc0d36804bd9dfc0ff9403.svg" alt="$ M_ {key} $" data-tex="inline">  -256位主密钥，域-为其创建密钥的域名。 <br> 在下文中， <i>HMAC</i>是基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SHA-2</a>哈希函数的256位实现的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">哈希密码算法</a> 。 <br><blockquote> 妥协或自愿披露域密钥不会损害原始主密钥。 </blockquote><br> 主密钥提供了用于移动用户凭证的机制。 <br><div class="spoiler">  <b class="spoiler_title">注意事项</b> <div class="spoiler_text"> 在该协议的初始版本中，基于用户密码生成域密钥的选项被认为可确保用户移动性并防止黑客入侵站点时遭受密码泄露。 但是在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ 3条安全建议”</a>一章中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>将解释为什么决定拒绝这种方案。 </div></div><br> 如果破坏了基于“主”创建的密钥，或者破坏了根据此类密钥计算出的令牌（由于黑客入侵了站点），则必须更改密钥。 您可以将其更改为随机的256位密钥，或者从相同的“向导”生成它，并添加以下版本： <br><p></p><p><math></math><img src="https://habrastorage.org/getpro/habr/formulas/eae/301/46b/eae30146bac887a402418464641e617e.svg" alt="$ K = HMAC_ {Mkey}（域\ cup版本）$" data-tex="display"></p> 在下文中，符号 <math></math><img src="https://habrastorage.org/getpro/habr/formulas/a47/285/a28/a47285a2828b9a69edf64fea3e240a0d.svg" alt="$ \杯$" data-tex="inline"> 将用于字符串连接操作（字节数组）。 <br><br><a name="token_algo"></a><h2>  2.1计算源令牌的算法 </h2><br> 用户的身份验证令牌是与任何域资源的每个请求一起计算的。 要计算请求令牌，将获取以下数据： <br><br><ul><li>  <i>发送方</i> -请求发起<i>方</i>的域名（可以是带有iframe的页面或其他人的域中执行抓取的脚本）， </li><li>  <i>收件人</i> - <i>收件人的</i>域名（发送请求的位置）， </li><li>  <i>上下文</i> -请求执行上下文， </li><li>  <i>保护</i> -如果Context为空，则为32个字节（256位）的随机序列； 否则为空 </li></ul><br>  <b>在发起请求的域的密钥K上，</b>此数据被连接并用256位SHA-2 <b>进行</b>哈希处理： <br><p></p><p><math></math><img src="https://habrastorage.org/getpro/habr/formulas/8d1/bd1/cbc/8d1bd1cbc81815e0121976c9bb5e4ccc.svg" alt="$ K = HMAC_M（发件人\杯子收件人\杯子贝壳\杯子保护）$" data-tex="display"></p><blockquote> 当Context不为空时，将获得一个有效的令牌。 为了在目标站点上正确识别，必须满足条件“发件人=收件人=上下文”。 </blockquote><br> 上下文字段与保护一起用于防止<abbr title="跨站点脚本-“跨站点脚本”">XSS</abbr>和<abbr title="跨站点请求伪造-“跨站点请求伪造”">CSRF</abbr>攻击以及防止用户跟踪。 <br> 下面将给出有关确定发件人/收件人/上下文的规则的更详细说明。 <br><br><a name="token_validation_algo"></a><h2>  2.2传输期间的令牌保护算法 </h2><br> 原始客户端令牌很少被传输。 仅在创建会话时传输未注册的令牌时。 <br>  <b>如果令牌是</b>基于随机（非固定）密钥创建的， <b>则视为未注册</b> 。 发送“更改为”或“永久”密钥后，服务器未接受该密钥。 有关更多详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“在服务器上处理令牌”</a> 。 <br> 浏览器和服务器共同生成一对随机数，即所谓的 盐（Salt），令牌的低128位被散列。 两者都根据协议交换这些号码。 有关详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“盐交换过程浏览器-服务器”</a> 。 <br> 因此，站点服务器看到以下令牌： <br><p></p><p><math></math><img src="https://habrastorage.org/getpro/habr/formulas/8ea/b59/cc3/8eab59cc3e5060cfec9956f984807b5f.svg" alt="$ T =嗨（T_s）\杯子HMAC_ {盐}（Lo（T_s））$" data-tex="display"></p> 在哪里 <math></math><img src="https://habrastorage.org/getpro/habr/formulas/69c/826/a5b/69c826a5bc2d0953c3db1dbcc842a035.svg" alt="$嗨（T_s）$" data-tex="inline">  -高128位， <math></math><img src="https://habrastorage.org/getpro/habr/formulas/73a/cbf/6b4/73acbf6b426b5d3dff599b4cba44ebfd.svg" alt="$ Lo（T_s）$" data-tex="inline">  -原始令牌的低128位， <math></math><img src="https://habrastorage.org/getpro/habr/formulas/a47/285/a28/a47285a2828b9a69edf64fea3e240a0d.svg" alt="$ \杯$" data-tex="inline">  -字符串串联。 在这种情况下，初始令牌 <math></math><img src="https://habrastorage.org/getpro/habr/formulas/c39/070/036/c39070036bed1c9b371606081981a5fb.svg" alt="$ T_s $" data-tex="inline"> 服务器应该已经知道。 <br><br> 理想情况下，每次浏览器请求服务器时，CSI-Salt都应该更改。 但是，就计算资源而言，这可能是一项昂贵的要求。 此外，它可以“杀死”向服务器发送并行请求的功能。 <br> 因此，为了优化计算，允许在不同请求中将CSI-Salt值保持不变， <u>但不得超过一个会话</u> 。 这可以是时间限制（每5分钟更改一次CSI-Salt），或者是对请求强度的反应（每100个请求更改CSI-Salt），也可以是在一系列请求之后（在暂停时，客户端-服务器之间）或混合版本。 在这里，决定权留给浏览器开发人员。 <br> 长时间保持CSI-Salt不变会削弱对已传输令牌的保护，从而使攻击者可以在合法用户完成注销并代表受害者执行未经授权的请求时拦截令牌。 <br><br><a name="salt_exchange_algo"></a><h2>  2.3浏览器和服务器之间的盐交换程序 </h2><br>  2.3.1基于随机或未注册的<sup>[1]</sup>服务器密钥的令牌。 <br><div class="scrollable-table"><table><tbody><tr><th>  <b>浏览器</b> </th><th>  <b>伺服器</b> </th></tr><tr><td colspan="2">  <b>初始请求（用户会话初始化）</b> </td></tr><tr><td> 浏览器按原样发送令牌。 <br>  <b>您的请求缺少CSI-Salt。</b> <br></td><td> 服务器首先看到这样的令牌。 <br><div class="spoiler">  <b class="spoiler_title">顺便说一句</b> <div class="spoiler_text"> 服务器可能不是第一个看到这种令牌的人。 并且浏览器被认为是未注册的。  <u>当您在另一台设备上基于主密钥重新创建密钥时，</u>可能会发生这种情况。 因此，也应考虑这种情况。 </div></div><br> 照原样感知（认为它不受保护）。 使用此令牌作为会话标识符。 <br> 产生其<i>S <sub>盐</sub></i> 。 <br>  <b>在CSI-Salt标头中的响应中返回它。</b> <br></td></tr><tr><td colspan="2">  <b>第二个要求</b> </td></tr><tr><td> 用盐生成<i><sub>盐</sub></i> 。 <br> 浏览器将<sup>[3]</sup>它的盐与服务器的盐连接起来。 <br> 浏览器发送请求，并传递共享的盐令牌。 <br>  <b>发送CSI-Salt。</b> <br></td><td> 服务器接收到请求并<b>检索CSI-Salt客户端</b> 。 <br> 服务器将浏览器盐连接到自己的盐，并使用它来验证令牌。 <br><br> 如果令牌验证成功，它将根据用户的权限为用户提供内容。 <br><br> 在验证错误时，将<b>CSI-Token-Action：无效</b>标头返回给客户端。 返回内容或返回空响应：与服务器有关。 <br></td></tr><tr><td colspan="2">  <b>后续请求</b> </td></tr><tr><td> 浏览器发送请求，并传递共享的盐令牌。 <br>  <b>您的请求缺少CSI-Salt。</b> <br></td><td> 服务器收到请求并检查其令牌。 <br><br> 如果令牌验证成功，它将根据用户的权限为用户提供内容。 <br><br> 在验证错误时，将<b>CSI-Token-Action：无效</b>标头返回给客户端。 返回内容或返回空响应：与服务器有关。 <br></td></tr><tr><td colspan="2">  <b>一段时间后<sup>[2]</sup></b> </td></tr><tr><td> 生成新的盐<i>C <sub>盐</sub></i> 。 <br> 将新的盐连接到服务器盐。 <br> 发送请求，并传递受新的联合盐保护的令牌。 <br>  <b>发送CSI-Salt。</b> <br></td><td> 服务器接收到请求并<b>检索新的CSI-Salt客户端</b> 。 <br> 服务器将浏览器盐连接到自己的盐，并使用它来验证令牌。 <br><br> 如果令牌验证成功，它将根据用户的权限为用户提供内容。 <br><br> 在验证错误时，将<b>CSI-Token-Action：无效</b>标头返回给客户端。 返回内容或返回空响应：与服务器有关。 <br></td></tr></tbody></table></div><br>  2.3.2基于服务器<sup>[1]</sup>注册的密钥的令牌。 <br><div class="scrollable-table"><table><tbody><tr><th>  <b>浏览器</b> </th><th>  <b>伺服器</b> </th></tr><tr><td colspan="2">  <b>初始请求（用户会话初始化）</b> </td></tr><tr><td> 用盐生成<i><sub>盐</sub></i> 。 <br>  <b>发送CSI-Salt。</b> <br> 以受保护的形式传输令牌。 <br></td><td> 服务器接收到请求并<b>检索CSI-Salt客户端</b> 。 <br> 读取受保护的令牌。 <br> 在其数据库中查找完整的客户端令牌（使用在请求中收到的第一个128位令牌进行搜索）。 <br> 因为 这是最初的请求，服务器没有将盐发送给客户端，因此<b>此阶段</b>的<b>令牌验证仅由客户端的salt执行</b> 。 <br><br> 在验证错误时，将<b>CSI-Token-Action：无效</b>标头返回给客户端。 返回内容或返回空响应：与服务器有关。 <br><br> 如果令牌验证成功，它将根据用户的权限为用户提供内容。 <br><br> 产生其<i>S <sub>盐</sub></i> 。 <br>  <b>在CSI-Salt标头中的响应中返回它</b> 。 <br></td></tr><tr><td colspan="2">  <b>后续请求</b> </td></tr><tr><td> 浏览器将其盐和服务器盐结合在一起。 <br> 浏览器发送请求，并传递共享的盐令牌。 <br>  <b>您的请求缺少CSI-Salt</b> 。 <br></td><td> 服务器收到请求并检查其令牌。 <br><br> 如果令牌验证成功，它将根据用户的权限为用户提供内容。 <br><br> 在验证错误时，将<b>CSI-Token-Action：无效</b>标头返回给客户端。 返回内容或返回空响应：与服务器有关。 <br></td></tr><tr><td colspan="2">  <b>一段时间后<sup>[2]</sup></b> </td></tr><tr><td> 生成新的盐<i>C <sub>盐</sub></i> 。 <br> 浏览器将新的盐连接到服务器盐。 <br> 浏览器发送请求，并传递受新共享盐保护的令牌。 <br>  <b>发送CSI-Salt</b> 。 <br></td><td> 服务器接收到请求并<b>检索新的CSI-Salt客户端</b> 。 <br> 服务器将浏览器盐连接到自己的盐，并使用它来验证令牌。 <br><br> 如果令牌验证成功，它将根据用户的权限为用户提供内容。 <br><br> 在验证错误时，将<b>CSI-Token-Action：无效</b>标头返回给客户端。 返回内容或返回空响应：与服务器有关。 <br></td></tr></tbody></table></div><hr>  <sup>[1]如果令牌是：根据随机密钥创建的，则视为未注册。</sup>  <sup>发送带有CSI-Token-Action：成功响应的Change-To或Permanent密钥后，服务器不接受该密钥。</sup> <sup><br></sup>  <sup>[2]更改CSI-Salt的时间由浏览器本身确定。</sup>  <sup>在一系列请求之后，超时之后，一定数量的请求之后，可能会发生这种情况。</sup> <sup>  – <b>     CSI-Salt    </b> . <br> [3]     16-  128- .     ,   : <i> <sub>salt</sub></i> || <i>S <sub>salt</sub></i> .       –     ,    .      ,    ,    .</sup> <br><br><a name="context_rules"></a><h2> 2.4    Context </h2><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text">      .   ,  -  .            . <br>       ,   .      ,     . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的域名</font><font style="vertical-align: inherit;">称为</font><i><font style="vertical-align: inherit;">我们</font></i><font style="vertical-align: inherit;">正在加载其页面的域名（显示在浏览器的地址栏中）。其余域将称为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">external</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。即使这些是给定的子域。</font><font style="vertical-align: inherit;">如果</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源</font><font style="vertical-align: inherit;">是从外部域下载的，则</font><font style="vertical-align: inherit;">我们将其称为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外部</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果</font><font style="vertical-align: inherit;">资源</font><font style="vertical-align: inherit;">是从我们的域下载的，</font><font style="vertical-align: inherit;">我们将其称为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源</font><font style="vertical-align: inherit;">。该资源可以是脚本，图像，ajax请求和任​​何其他文件。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果脚本是从外部域下载的，则被视为外部脚本。放置在创建的&lt;script&gt;标记中的脚本（由外部脚本创建）也将被视为外部脚本。如果修改后的&lt;script&gt;标记中的脚本被外部脚本修改过，或者当其内容更改时在调用链中存在外部脚本，则该脚本将声明为外部脚本。即使此&lt;script&gt;最初同时在页面上，还是由内部脚本创建的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们呼吁LINK标签，SCRIPT，IMG，IFAME和其他需要在浏览器加载的资源，只要通过DOM解析器收到- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源标签</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将其命名为FORM，A，META等标签，它们可以在某些条件下（提交，点击，超时）- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动标签</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该标签</font><font style="vertical-align: inherit;">最初是在服务器首次发布时出现在页面上的，则</font><font style="vertical-align: inherit;">我们将其称为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静态</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标签</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果</font><font style="vertical-align: inherit;">标记</font><font style="vertical-align: inherit;">是在运行脚本的过程中创建的，则</font><font style="vertical-align: inherit;">我们将其称为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动态</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标记</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FORM标记被声明为动态的，即使不仅标记本身已更改，而且与该表单关联的所有INPUT字段的值都已更改。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们称之为动态标记</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自己</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果脚本创建属于我们的领域，如在催生这个标签是不属于外部脚本函数指令调用链。否则，我们认为这种动态标签</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不合适</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">页面加载是通过启动标签触发的。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发起标签可以由用户直接激活，也可以由脚本激活，可以通过执行click命令（对于链接）并提交（对于表单），也可以由脚本生成相应的onclick / onsubmit事件。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，启动标签可以由浏览器激活。</font><font style="vertical-align: inherit;">此类标签的示例是META，其参数为http-equiv =“ refresh” content =“ 0”。</font></font><br><br> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表P.不同页面打开条件下的上下文值</font></font></sup> <br><a name="context_table_P"></a><div class="scrollable-table"><table><tbody><tr><th colspan="3" rowspan="2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 开启方式 </font></font></th><th colspan="4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 谁触发了页面加载？ </font></font></th></tr><tr><th> 用户名 </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自己的。</font><font style="vertical-align: inherit;">s</font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分机 </font><font style="vertical-align: inherit;">s</font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 浏览器 </font></font></th></tr><tr><td rowspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标签</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sup> </td><td colspan="2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 静态的 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1。</font><font style="vertical-align: inherit;">推荐人</font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2。</font><font style="vertical-align: inherit;">Varariant </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3。</font><font style="vertical-align: inherit;">空的</font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P4。</font><font style="vertical-align: inherit;">继承</font></font></td></tr><tr><td rowspan="2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 动态的 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 自己的 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P5。</font><font style="vertical-align: inherit;">继承</font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P6。</font><font style="vertical-align: inherit;">Varariant </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P7 </font><font style="vertical-align: inherit;">空的</font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P8。</font><font style="vertical-align: inherit;">继承</font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 不当的 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P9。</font><font style="vertical-align: inherit;">空的</font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PA </font><font style="vertical-align: inherit;">空的</font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PB。</font><font style="vertical-align: inherit;">空的</font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电脑 </font><font style="vertical-align: inherit;">空的</font></font></td></tr><tr><td colspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 直接地 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PD。</font><font style="vertical-align: inherit;">域</font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PE。</font><font style="vertical-align: inherit;">Varariant </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f </font><font style="vertical-align: inherit;">空的</font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PG。</font><font style="vertical-align: inherit;">Varariant </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup> </td></tr></tbody></table></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同一张桌子，只有图像</font></font></b> <div class="spoiler_text">  <img src="https://habrastorage.org/webt/cq/l-/6e/cql-6eob6gouvsqsrdy5ltykhfg.gif" align="right"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果资源标签被脚本（例如IMG的SRC属性）更改，然后资源被浏览器自动加载，则我们认为内容/资源是由解析器触发的，加载方法是标签，但是此标签的状态变为``动态''。</font></font><br><br> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表R.在不同条件下</font><b><font style="vertical-align: inherit;">加载内容/资源的</font></b><font style="vertical-align: inherit;">上下文值</font></font><b><font style="vertical-align: inherit;"></font></b></sup> <br><a name="context_table_R"></a><div class="scrollable-table"><table><tbody><tr><th colspan="3" rowspan="2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 下载方式 </font></font></th><th colspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 谁导致内容下载？ </font></font></th></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 唐解析器 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自己的。</font><font style="vertical-align: inherit;">s</font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分机 </font><font style="vertical-align: inherit;">s</font></font></th></tr><tr><td rowspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标签</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup> </td><td colspan="2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 静态的 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R1。</font><font style="vertical-align: inherit;">页数</font></font></td><td></td><td></td></tr><tr><td rowspan="2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 动态的 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 自己的 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R4 </font><font style="vertical-align: inherit;">页数</font></font></td><td></td><td></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 不当的 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R7。</font><font style="vertical-align: inherit;">空的</font></font></td><td></td><td></td></tr><tr><td colspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 直接地 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RA。</font><font style="vertical-align: inherit;">推荐人</font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RB。</font><font style="vertical-align: inherit;">页数</font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">钢筋混凝土 </font><font style="vertical-align: inherit;">推荐人</font></font></td></tr></tbody></table></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同一张桌子，只有图像</font></font></b> <div class="spoiler_text">  <img src="https://habrastorage.org/webt/dl/zi/mn/dlzimnup-7etmrsysxzlxjw1zd8.gif" align="right"></div></div><br><hr> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1]正在启动标签</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2]资源标签</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3]对于自己的页面继承，在打开外部域的页面时为空</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4]在将服务器重定向到其页面时进行继承，在将服务器重定向到其他域或从外部源打开页面时为空（请参阅。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">澄清</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></sup> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缩略语</font></font></b> <div class="spoiler_text"> <b>Referrer</b> –     Referrer. <br> <b>Page</b> –   (Tab)      . <br> <b>Empty</b> –  . <br> <b>Domain</b> –  Context     <br> <b>Inherit</b> –  Context     <br> <b>Variant</b> –  Context    «-»   <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 分析特定情况时，将使用P1..PF，R1..RC形式的标记来引用表中的相应单元格。 </font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意</font><font style="vertical-align: inherit;">第一个表中</font><font style="vertical-align: inherit;">突出显示的“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引荐来源网址</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">域</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”。</font><font style="vertical-align: inherit;">仅当您自己在直接地址或通过其他站点的链接打开站点，然后自行重新加载页面时，才可以在站点上获得授权。</font></font></blockquote><br><br><a name="sender_recipient_rules"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.5定义发件人和收件人字段的规则 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送者是请求所来自的页面/脚本/样式的域。</font><font style="vertical-align: inherit;">该页面要求样式，图片，脚本。</font><font style="vertical-align: inherit;">脚本通过ajax请求内容。</font><font style="vertical-align: inherit;">样式可以加载其他样式。</font><font style="vertical-align: inherit;">这些是请求的发起者。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">收件人是请求真正到达的域。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了不遗余力，让我们考虑具体的例子。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让有一个site.net网站。</font><font style="vertical-align: inherit;">在该网站的主页上是：</font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 样式site.net/css/common.css </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> common.css样式导入fonts.google.com/fonts/Roboto.css样式 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Roboto.css样式导入字体fonts.google.com/fonts/Roboto.ttf </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 导致img.site.net/picture1.jpg的图片 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 从adriver.ru/frame加载的框架 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adm.site.net/admin.js中的脚本 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 让框架（与adriver.ru）连接： </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 来自adriver.ru/style.css的样式 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 图片来自img.adriver.ru/img/01.png </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 来自adriver.ru/libs.js的脚本 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> api.adriver.ru/v1/ad.js中的脚本 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用DOM解析器加载资源时的发件人/收件人值 </font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 可下载资源 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 发件人价值 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 收件人价值 </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> site.net/css/common.css </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> site.net </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> site.net </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonts.google.com/fonts/Roboto.css </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> site.net </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonts.google.com </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonts.google.com/fonts/Roboto.ttf </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonts.google.com </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonts.google.com </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> img.site.net/picture1.jpg </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> site.net </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> img.site.net </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adriver.ru/frame </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> site.net </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adriver.ru </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adm.site.net/admin.js </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> site.net </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adm.site.net </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adriver.ru/style.css </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adriver.ru </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adriver.ru </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> img.adriver.ru/img/01.png </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adriver.ru </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> img.adriver.ru </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adriver.ru/libs.js </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adriver.ru </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adriver.ru </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> api.adriver.ru/v1/ad.js </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adriver.ru </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> api.adriver.ru </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，让我们看一下在执行Ajax请求期间使用脚本加载内容时的发件人/收件人的值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用脚本加载内容时的发件人/收件人值</font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 可执行脚本 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 请求要去哪里？ </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 发件人 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 收件者 </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adm.site.net/admin.js </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> site.net/api/ </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adm.site.net </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> site.net </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adriver.ru/libs.js </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adriver.ru/api/ </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adriver.ru </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adriver.ru </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> api.adriver.ru/v1/ad.js </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> api.2gis.ru / ... </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> api.adriver.ru </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> api.2gis.ru </font></font></td></tr></tbody></table></div><br><br><a name="context_tables_comments"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.6上下文定义表的详细信息 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 让我们更详细地考虑我们拥有哪些打开页面的选项（浏览器中的选项卡），以及将获得哪些Context值。 </font></font><br><br><a name="P1"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前一页上的用户单击链接或单击表单上的提交按钮。链接/表单的标准事件浏览器处理程序将用户重定向到此页面。正常情况。域或不同域的页面之间的安全过渡。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从另一个google.com域切换到site.net时，上下文将等于先前的域（google.com）。并且新site.net域上的用户将被未经授权（即使打开了授权用户的该站点的相邻选项卡）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户通过链接重复访问同一站点（在没有脚本帮助的情况下）</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">将再次导致情况</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但上下文将已经等于域site.net，因为按照规则Context = Referrer。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旨在防止</font></font><abbr title="跨站点请求伪造-“跨站点请求伪造”"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CSRF</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">攻击。</font></font><br><br><a name="P5"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P5-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前一页的用户单击了从前一页的域下载的脚本创建/修改的链接；</font><font style="vertical-align: inherit;">或上一页的用户单击由脚本创建/修改的表单的提交按钮（更改FORM标记，包括其INPUT字段）。</font><font style="vertical-align: inherit;">链接/表单的标准事件浏览器处理程序将用户重定向到此页面。</font></font><br><br><a name="P9"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P9</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同</font><font style="vertical-align: inherit;">，只是脚本是外部的，或者调用链中有外部脚本的功能（防止第三方脚本编辑站点脚本的脚本功能）。</font></font><br><br><a name="PD"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PD-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户在直接地址打开页面。</font><font style="vertical-align: inherit;">安全开启。</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户必须通过在地址栏中输入URL来打开页面。</font><font style="vertical-align: inherit;">或通过浏览器书签打开网站。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从另一个程序的桌面快捷方式打开链接，在操作系统向浏览器发送命令以打开链接的任何其他情况下，都应将其视为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PG</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情况</font><font style="vertical-align: inherit;">（打开链接由浏览器启动）。即使用户按F5重新加载页面，也应将其视为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PG</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情况</font><font style="vertical-align: inherit;">。仅当用户进入地址栏并按Enter时，浏览器才会将其视为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样做是为了保护CSRF免受其他程序的攻击。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跟随另一个程序的链接，用户将获得带有无效令牌和空上下文的受攻击站点，即使用户按下F5（刷新页面），上下文也将被保存。在用户打开指向该网站页面的任何链接（情况</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">之前，您无法登录</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，如果来自另一个程序的攻击者决定向授权用户提供指向执行命令的site.net站点页面的链接，则他将无法轻松地做到这一点。有必要迫使用户单击此页面上的另一个链接，然后强制用户在此进行身份验证，然后才进行身份验证。然后，该用户很可能位于site.net的另一个页面上。</font></font><br><br><a name="P2"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在上一页中原本放置在页面上的链接或表单上一页中，上一页的本机脚本生成了单击/提交事件。</font><font style="vertical-align: inherit;">调用链中没有属于外部脚本的函数。</font><font style="vertical-align: inherit;">浏览器将用户重定向到此页面。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果新页面属于同一域，则上下文将从上一页继承。</font><font style="vertical-align: inherit;">如果新页面属于外部域，则上下文将为空白。</font></font><br><br><a name="P6"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P6</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同</font><font style="vertical-align: inherit;">，只是链接/表单是由其自己的脚本创建/修改的。</font></font><br><br><a name="PA"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同</font><font style="vertical-align: inherit;">，只是链接/表单是由外部脚本创建/修改的。</font></font><br><br><a name="PE"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PE-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前一页上的脚本使用window.location.href或window.open（...）命令引发了该页面的打开。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果site.net页面脚本将用户重定向到同一域的页面，则“上下文”字段将从继承的页面继承。在这种情况下，上下文= site.net。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果ya.ru页面已打开，并且脚本将我们转移到maps.ya.ru，则新页面的上下文将为空。在用户的后续操作中，上下文几乎总是保持为空，这会使用户在站点上的授权复杂化。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该协议意味着打开一个站点到另一个站点是不安全的操作。这样可以保护用户免受这些站点的未经授权的跟踪和CSRF攻击。</font></font><br><br><a name="P3"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相似</font><font style="vertical-align: inherit;">，只有外部脚本触发了click / submit事件。</font><font style="vertical-align: inherit;">上下文变为空（发送随机字节序列），这可以保护第三方站点免受跟踪该站点（横幅网络）。</font></font><br><br><a name="P7"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P7-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类似</font><font style="vertical-align: inherit;">，仅链接/表单是由外部脚本创建/修改的。</font></font><br><br><a name="PB"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PB-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类似</font><font style="vertical-align: inherit;">，只有链接/表单是由外部脚本创建/修改的。</font></font><br><br><a name="PF"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PF-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类似</font><font style="vertical-align: inherit;">，只有挑衅性脚本是外部的。</font></font><br><br><a name="P4"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P4-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于处理&lt;META&gt;标签，浏览器重新加载了页面。</font><font style="vertical-align: inherit;">标签最初在页面上。</font><font style="vertical-align: inherit;">合法重定向。</font><font style="vertical-align: inherit;">上下文将从原始页面保留。</font><font style="vertical-align: inherit;">与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PE一样</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><a name="P8"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P8-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于处理&lt;META&gt;标签，浏览器重新加载了页面。</font><font style="vertical-align: inherit;">但是标记是由其自己的脚本创建/修改的。</font><font style="vertical-align: inherit;">这是有效的，但上下文将从原始页面保留。</font><font style="vertical-align: inherit;">与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PE一样</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这样就不可能吸引用户的合法令牌。</font></font><br><br><a name="PC"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PC-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类似</font><font style="vertical-align: inherit;">，仅是外部脚本。</font><font style="vertical-align: inherit;">打开的站点将收到一个随机数字作为上下文。</font></font><br><br><a name="PG"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PG-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浏览器打开来自操作系统的命令链接。</font><font style="vertical-align: inherit;">可能是，您单击了另一个程序的链接，在桌面上打开了一个快捷方式。</font><font style="vertical-align: inherit;">这可能是来自另一个程序的命令，而您并不知道。</font><font style="vertical-align: inherit;">在这种情况下，源不受信任，并且在任何用户操作期间，“上下文”字段将保持为空。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样做是为了保护CSRF免受其他程序的攻击。</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果浏览器本身打开了先前保存的选项卡，则页面的上下文设置为等于关闭浏览器时此页面的值。 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，此类别还包括所有由于处理Header HTTP标头而将服务器将浏览器重定向到另一页（其域或其他人的域）的情况。</font><font style="vertical-align: inherit;">如果重定向转到您自己的页面，则将继承Context值。</font><font style="vertical-align: inherit;">如果重定向转到其他人，它将被重置。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样做是为了防止Web服务器受到跟踪攻击。</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺便说一句，这种规则可能会导致跨域授权的当前实现出现问题。</font><font style="vertical-align: inherit;">如果在授权后，SSO服务器将用户重定向回目标站点，则该目标站点将在该站点匿名。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了防止用户“丢失”目标站点上的原始授权，有必要在服务器请求之间传输身份验证信息。</font><font style="vertical-align: inherit;">该算法可以如下：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用户创建并激活目标站点的永久密钥； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 单击适当的链接从目标站点转到SSO服务器本身； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 从SSO服务器激活现有的永久密钥； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SSO服务器收到“更改至”密钥后，将服务器间请求发送到目标站点。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用户单击授权页面上的“继续”按钮，将其返回到目标站点； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了满足规则</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，目标站点为用户提供了再次单击链接按钮的链接，并指向该链接按钮（例如，指向授权参与者的起始页）。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用户单击链接按钮，页面将重新加载，并且该用户已在目标站点上获得授权。 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该算法的描述实际上看起来比其实现更为复杂。</font><font style="vertical-align: inherit;">UI实现可能如下所示：</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w5/u1/aa/w5u1aahv-_os9k2d81c819d5zhg.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重新进入目标站点不再需要用户的SSO授权。</font><font style="vertical-align: inherit;">激活永久密钥就足够了。</font></font></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，让我们仔细研究一下在页面上加载内容的选项，以及根据请求将获得哪些Context值。 </font></font><br><br><a name="R1"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R1-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源由浏览器作为解析页面的结果加载（浏览器符合资源标签）。</font><font style="vertical-align: inherit;">从包含资源标签的“上下文”页面获取生成资源请求时的“上下文”值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，如果site.net具有adriver.ru框架，其中加载了img.disk.com中的图像，则在生成对img.disk.com的HTTP请求时，浏览器会将为页面计算的值用作上下文。 site.net。</font></font><br><br><a name="R4"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同</font><font style="vertical-align: inherit;">。只有资源标记是由其自己的脚本创建/修改的，因此浏览器DOM Parser可以工作。例如，在site.net/index.html页面上，我们自己的site.net/require.js脚本插入了另一个自定义脚本（&lt;script src = ...&gt;标记）site.net/min.js，这迫使浏览器生成文件下载请求。 main.js。该请求中的“上下文”字段将设置为为site.net页面计算的值。</font></font><br><br><a name="R7"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R7</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同</font><font style="vertical-align: inherit;">。但是由于资源标签是由外部脚本创建/修改的，因此当请求资源时，浏览器将基于空的上下文和随机的256位序列生成令牌。结果，嵌入受攻击的site.net域页面上的攻击者evil.com/drop.js的外部脚本试图代表受害者完成对目标site.net的请求将失败，因为服务器将收到带有随机令牌的请求，并且将无法识别请求的发送者。</font></font><br><br><a name="RA"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RA-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解析器下载内容是对其他内容进行分析的结果。例如，为site.net/index.html页面下载的site.net/css/common.css样式表会导入fonts.google.com/fonts/Roboto.css样式表，这会强制浏览器请求fonts.google .com代表Referrer = site.net/css/common.css。在这种情况下，上下文值将等于Referrer。接下来，Roboto.css样式文件导入Roboto.ttf字体，这将强制浏览器代表Referrer = fonts.google.com/fonts/Roboto.css来请求fonts.google.com/fonts/Roboto.ttf。在这种情况下，“上下文”值将等于“引荐来源网址”，但这是不同的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设，假设Roboto.css文件（外部资源）没有导入字体/样式，而是尝试通过以下指令进行CSRF攻击：</font></font><pre><code class="css">@import "https://site.net/api/payment?victim_params"</code> </pre> 希望代表授权用户满足site.net上的要求。 但是攻击者面临的问题是site.net希望从用户那里收到令牌： <br><p></p><p><math></math><img src="https://habrastorage.org/getpro/habr/formulas/18c/ba0/6d3/18cba06d3ab48142219dbf3e3f4e2330.svg" alt="$ T_s ^ 1 = HMAC_k（site.net \ cup site.net \ cup site.net）$" data-tex="display"></p><br> 然后，与CSRF请求一样，浏览器将创建一个令牌： <br><p></p><p><math></math><img src="https://habrastorage.org/getpro/habr/formulas/466/929/b86/466929b86ade0b848996042a3ac12f25.svg" alt="$ T_s ^ 2 = HMAC_k（fonts.google.com \ cup site.net \ cup fonts.google.com）$" data-tex="display"></p><br> 并且对该站点的请求将代表一个没有执行这些操作访问权限的匿名站点。 <br><br><a name="RB"></a>  <b>RB-</b>内容是通过网站自己的脚本上传的。 在这种情况下，上下文用于计算请求令牌，该令牌等于包含脚本的页面。 对于site.net上下文页面中的site.net/1.js脚本，它将等于页面本身的上下文。 <br><blockquote> 请注意，页面本身的上下文并不总是等于页面的域名，而是取决于最初打开页面的方式。 </blockquote> 假设攻击者evil.com的网站打开了受攻击网站site.net的页面，其中site.net/util.js脚本使用通过页面URL传递的参数执行请求。 攻击者希望通过在URL上滑动“他的参数”，来迫使自己的site.net/util.js脚本执行ajax请求，以代表受害者执行重要的操作。 <br><br> 假设用户本人通过直接链接访问了evil.com。 那么evil.com的上下文将是evil.com。 然后evil.com使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">脚本</a>打开<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">site.net/api/payment?victim_params</a> ，希望发起攻击，但是site.net的上下文字段将为空（PE / PF情况）。 执行ajax请求的site.net/utils.js脚本将强制浏览器从site.net页面获取Context。 它对我们来说是空的。 但是，site.net将收到带有此令牌的ajax请求： <br><p></p><p><math></math><img src="https://habrastorage.org/getpro/habr/formulas/866/a41/990/866a41990a710d17dbe34a04ecb2e28c.svg" alt="$ T = HMAC_ {site.ru-key}（site.net \ cup site.net \ cup随机）$" data-tex="display"></p><br> 而对于授权用户，则期望： <br><p></p><p><math></math><img src="https://habrastorage.org/getpro/habr/formulas/025/1b3/fad/0251b3fadaf0e4f1535b6aa8a67df332.svg" alt="$ T_s = HMAC_ {site.ru-key}（site.net \ cup site.net \ cup site.net）$" data-tex="display"></p><br>  site.net将看到未知的令牌，并且将无法识别用户。 保护工作。 <br><blockquote> 顺便说一句，由于这种方案，通过弹出窗口进行跨域授权将是不现实的。 </blockquote> 要在协议下实施SSO，必须为授权服务器页面打开一个新选项卡。 同时，用户必须打开这样的选项卡。 最好的选择是从目标站点打开用户适当的链接。 <br><br><a name="RC"></a>  <b>RC-</b>内容加载有外部网站脚本。 在这种情况下，上下文用于计算请求令牌，该令牌等于“请求引荐来源”字段。 <br><br> 尽管<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RA</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RB</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RC</a>可以抵御CSRF攻击，但它们仍然导致生成常量令牌。  <b>这样，您就可以实现跨域身份验证和跨域</b>用户<b>身份验证</b> （当您需要确定对该用户发出的对不同服务器的多个请求时）。 可以采取哪些措施为他提供一组相关领域的平等权限。 <br><br> 如果该<b>站点页面是</b>从另一个站点<b>自动打开的</b> ，则即使您自己重新加载该站点，也将无法登录。 因为Source将继承自空值。 浏览器应向用户发出有关此事实的信号（来源=随机）： <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1h/pr/ew/1hprewdwumpuwpzmzkqfmbds104.jpeg"></div><br> 这样做是为了防止强制打开其他弹出窗口的站点（自身或其外部脚本），并且在打开的站点上，它们将重新引导或在通往同一站点的整个屏幕上创建假的“关闭”按钮。 即 这样可以防止尝试跟踪您，从而希望获得有效的令牌。 <br><br>  <b>如果站点尝试使用外部脚本模仿您的操作</b> ，或者试图通过外部脚本直接或间接创建启动标签并将其拖给您，都会导致源为空，并且在计算令牌哈希时会添加随机字节。 <br><br> 在DOM的受攻击页面中创建或修改&lt;script&gt;标记的技巧无济于事。  Source字段将保留为空白。 <br><br> 但是在相同条件下，内部脚本将导致查询Source等于其先前值的查询。 如果原始页面具有Source = Domain，那么一切都会好起来的。 用户将继续获得此类请求的授权。 <br><br> 但是，从第三方资源（CDN）下载脚本后，在某些情况下可能会出现问题。 是的，因为 不保证CDN代码的完整性。 如果不想丢失用户授权，请将脚本保留在您的站点上，然后从您的域中下载它们。 这类似于禁止在https页面上使用http链接。 <br><br> 我们描述了开发人员可能会遇到的情况。 作为用户操作的结果，您的脚本将授权用户重定向到站点的页面之一（例如，通过表单完成），要求该用户保持授权。 例如，您的脚本使用从CDN加载的jQuery脚本调用$（form）.submit（）。 在这种情况下，浏览器会看到在触发表单提交事件的调用堆栈中，有一个来自外部脚本的函数。 为了防止<abbr title="跨站点脚本-“跨站点脚本”">XSS</abbr> / <abbr title="跨站点请求伪造-“跨站点请求伪造”">CSRF</abbr>攻击，浏览器将Source字段设置为空，并向令牌的生成添加随机字节（案例<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P9</a> ）。 结果，新页面上的用户突然变得未经授权，无法完成操作。 这会使习惯于使用CDN的开发人员感到困惑。 <br><br><a name="protocol_scenario"></a><h2>  2.7协议场景 </h2><br> 这是用户使用网站的主要可能情况，影响所有可能的情况及其实施阶段（匿名登录，“记住我”，“忘记我”，切换到使用永久密钥，授权和退出，注册和两因素身份验证，导出/密钥导入，密钥替换等） <br><div class="scrollable-table"><table><tbody><tr><th colspan="3">  1个论坛，博客，维基百科 </th></tr><tr><th> 用户名 </th><th> 浏览器 </th><th> 站点服务器 </th></tr><tr><td>  1.1首次访问本网站。 </td><td> 生成一个随机密钥。 从随机密钥发送不安全的令牌。 </td><td> 我们认为用户是匿名的。 我们使用此令牌作为用户会话的标识符。 </td></tr><tr><td>  1.2查看页面。 </td><td> 针对随机密钥发送安全令牌。 </td><td> 提供公共内容。 检查低128位令牌位。 </td></tr><tr><td>  1.3尝试执行操作（添加评论等） </td><td> 针对随机密钥发送安全令牌。 </td><td> 告诉用户他们需要向系统自我介绍。 在此阶段，站点确信密钥是随机的。 </td></tr><tr><td>  1.4告诉浏览器使站点记住它。 </td><td> 修复当前密钥。 发送一个永久密钥。 与以前一样，令牌以受保护的形式传输。 发送此密钥，直到从服务器接收成功。 </td><td> 现在该站点知道该密钥是固定的。 发送CSI-Token-Action：成功。 它可以长时间使用用户的记忆技术：可以将令牌保存在数据库中，以便将来与用户进行会话恢复。 或者将会话保留更长的时间（保存到文件）。 </td></tr><tr><td>  1.5执行动作（添加帖子，投票等） </td><td> 从固定密钥发送安全的CSI令牌。 </td><td> 记录此用户的操作。 </td></tr><tr><td>  1.6关闭浏览器选项卡。 </td><td> 没事 </td><td> 它正在等待以下用户请求。 </td></tr><tr><td>  1.7返回站点。 </td><td> 发送安全的固定密钥。 </td><td> 继续与用户合作。 会话数据是通过令牌从数据库或临时文件中获取的。 </td></tr><tr><td>  1.8撤消密钥固定（在此站点上忘记我） </td><td> 发送注销密钥 </td><td> 删除数据库中的用户数据，如下 它是固定密钥，用户将永远无法恢复。 结束会话。 浏览器将不再发送此类令牌。 </td></tr><tr><td>  1.9注销后首次访问站点时。 </td><td> 生成一个随机密钥。 从随机密钥发送不安全的令牌。 </td><td> 该站点已经是新用户。 我们认为用户是匿名的。 我们使用令牌作为用户会话的标识符。 </td></tr><tr><td>  1.10浏览页面。 </td><td> 针对随机密钥发送安全令牌。 </td><td> 提供公共内容。 检查低128位令牌位。 </td></tr><tr><td>  1.11关闭浏览器选项卡。 </td><td> 没事 </td><td> 超时后中断会话。 </td></tr><tr><td>  1.12回到站点。 </td><td> 生成一个随机密钥。 从随机密钥发送不安全的令牌。 </td><td> 我们认为用户是匿名的。 我们使用此令牌作为用户会话的标识符。 </td></tr><tr><td>  1.13创建一个永久站点密钥。 </td><td> 没事 </td></tr><tr><td>  1.14激活永久密钥。 </td><td>  <b>问用户：您真的要网站记住您的密钥吗？</b>  <b>确保此网站是它声称的身份。</b> <br> 发送更改为。 仅在此刻，浏览器才将令牌传递给未受保护的令牌。 在接下来的所有时间中，浏览器在登录时始终会传输受保护的令牌。 但是为此，站点必须通过CSI-Token-Action：成功确认令牌的更改。 </td><td> 记住数据库中的新用户令牌。 更改会话ID。 继续等待来自新令牌的请求。 发送CSI-Token-Action：成功。 </td></tr><tr><td>  1.15执行动作（添加帖子，投票等） </td><td> 从永久密钥发送安全令牌 </td><td> 记录此用户的操作。 检查较低的128位令牌。 </td></tr><tr><td>  1.16进行“退出”。 </td><td> 发送注销密钥 </td><td> 中断会议 </td></tr><tr><td>  1.17返回站点。 </td><td> 生成一个随机密钥。 从随机密钥发送不安全的令牌。 </td><td> 我们认为用户是匿名的。 我们使用令牌作为用户会话的标识符。 </td></tr><tr><td>  1.18激活永久密钥。 </td><td> 发送更改为。 该令牌已受到保护，因为 该站点最后一次回答我们CSI-Token-Action：成功。 </td><td> 我们从数据库加载保存的用户数据。 更改会话ID。 我们使用保存的令牌。 我们知道令牌是基于永久密钥的。 </td></tr><tr><td>  1.19关闭浏览器选项卡。 </td><td> 没事 或注销键（如果在关闭选项卡时配置了“自动退出”）。 </td><td> 在超时后或收到注销键时中断会话。 </td></tr><tr><th colspan="3">  2在线商店或广告站点 </th></tr><tr><th> 用户名 </th><th> 浏览器 </th><th> 站点服务器 </th></tr><tr><td>  2.1首先包含在此站点中。 </td><td> 生成一个随机密钥。 从随机密钥发送不安全的令牌。 </td><td> 我们认为用户是匿名的。 我们使用此令牌作为用户会话的标识符。 </td></tr><tr><td>  2.2查看页面。 </td><td> 针对随机密钥发送安全令牌。 </td><td> 提供公共内容。 检查低128位令牌位。 </td></tr><tr><td>  2.3尝试执行操作（添加广告，购买等） </td><td> 针对随机密钥发送安全令牌。 </td><td> 告诉用户他们需要向系统自我介绍。 在此阶段，站点确信密钥是随机的。 </td></tr><tr><td>  2.4告诉浏览器使站点记住它。 </td><td> 修复当前密钥。 在第一个请求之前，它将发送带有永久密钥的安全CSI-Token。 收到成功后，它将停止发送此密钥。 </td><td> 现在该站点知道该密钥是固定的。 它可以应用长时间记住用户的技术：将令牌保存在数据库中，以便将来恢复与用户的会话。 或将会话保留更长的时间（几天）。 </td></tr><tr><td>  2.5执行操作（添加公告，购买等） </td><td> 从固定密钥发送安全的CSI令牌。 </td><td> 记录此用户的操作。 检查令牌。 </td></tr><tr><td>  2.6关闭浏览器选项卡。 </td><td> 没事 </td><td> 举行会议。 如果长时间不活动，它将会话数据从RAM保存到文件或数据库中。 </td></tr><tr><td>  2.7再次登录该站点。 </td><td> 发送安全的固定密钥。 </td><td> 会话继续。 我们与用户合作，好像什么也没发生。 </td></tr><tr><td>  2.8 <b>创建或导入</b>持久站点密钥。 </td><td> 没事 </td></tr><tr><td>  2.9激活永久密钥。 实际上，这里是从使用固定密钥到永久密钥的过渡。 </td><td> 发送更改至密钥。 对于新创建的密钥和未在服务器上注册的令牌，令牌的传输<b>不受保护</b> 。 令牌已针对导入的密钥进行<b>保护</b>转移。 </td><td>  2.9.A. 基于新密钥的令牌。 <br> 如果旧令牌已保存在数据库中-只需在数据库中更改令牌即可。 <br><br>  2.9.V. 基于导入密钥的令牌。 <br> 如果旧令牌已保存在数据库中，请删除它。 合并一个用户的两个配置文件时（您可以向他询问什么）-因为 实际上，用户在数据库中存储了两个令牌：一个固定密钥和一个导入密钥。 更改会话ID。 发送CSI-Token-Action：成功。 他继续等待来自新令牌的请求。 </td></tr><tr><td>  2.10执行动作（购买，张贴广告，购物车，收藏夹，评论，比较） </td><td> 从永久密钥发送安全令牌 </td><td> 记录此用户的操作。 检查较低的128位令牌。 </td></tr><tr><td>  2.11关闭浏览器选项卡。 </td><td> 没事 或注销键（如果在关闭选项卡时配置了“自动退出”）。 </td><td> 在超时后或收到注销键时中断会话。 </td></tr><tr><th colspan="3">  3个具有强制性预注册的站点（社交网络） </th></tr><tr><th> 用户名 </th><th> 浏览器 </th><th> 站点服务器 </th></tr><tr><td>  3.1包含在此站点中。 </td><td> 生成一个随机密钥。 从随机密钥发送不安全的令牌。 </td><td> 我们认为用户是匿名的。 我们使用此令牌作为用户会话的标识符。 我们只在公共区域出租。 当您尝试访问封闭的内容时，我们会翻译成授权表格。 </td></tr><tr><td>  3.2创建一个永久站点密钥 </td><td> 没事 </td></tr><tr><td>  3.3激活永久密钥。 </td><td>  <b>问用户：您真的要网站记住您的密钥吗？</b>  <b>确保此网站是它声称的身份。</b> <br><br> 发送更改为。 <br>  <b>令牌以明文形式传输</b> 。 </td><td> 记住新令牌。 在注册完成之前，我们不急于保存到数据库。 我们将用户保留在“注册”表格上，直到确认所有权（通过电话，邮件）为止。 发送CSI令牌操作：注册 </td></tr><tr><td>  3.4输入您的联系方式。 </td><td> 发送ajax请求。 发送更改为。 同一随机密钥上的旧令牌。 <br>  <b>新令牌已经以受保护的形式进行传输</b> 。 <br><br> 一旦收到成功，它将继续使用新令牌（永久密钥）。 </td><td> 检查联系方式。 如果一切成功，它将发送CSI-Token-Action：success。 否则：CSI-Token-Action：注册。 如果发送了CSI-Token-Action：中止，则注册不成功。 浏览器应返回使用随机数（取消输入）。 并将其报告给用户。 </td></tr><tr><td>  3.5转到站点的封闭部分 </td><td> 从永久密钥发送安全令牌。 </td><td> 通过检查较低的128位令牌来提供访问。 </td></tr><tr><td>  3.6执行动作（购买，张贴广告，购物车，收藏夹，评论，比较） </td><td> 从永久密钥发送安全令牌。 </td><td> 记录此用户的操作。 检查较低的128位令牌。 </td></tr><tr><td>  3.7关闭浏览器选项卡。 </td><td> 没事 或注销键（如果在关闭选项卡时配置了“自动退出”）。 </td><td> 在超时后或收到注销键时中断会话。 </td></tr><tr><td>  3.8包含在此站点中。 </td><td> 生成一个随机密钥。 从随机密钥发送不安全的令牌。 </td><td> 我们认为用户是匿名的。 我们使用此令牌作为用户会话的标识符。 我们只在公共区域出租。 当我们尝试访问封闭的内容时，我们会通知用户他是匿名用户。 </td></tr><tr><td>  3.9激活永久密钥。 </td><td> 发送更改为。 两个令牌均以安全方式传输。 </td><td> 我们通过令牌（最高128位）从数据库加载用户数据。 现在，该站点知道该用户是谁。 </td></tr><tr><td>  3.10将域永久密钥更改为另一个永久密钥 </td><td>  <b>问用户：您是否真的希望网站记住您的新密钥？</b>  <b>确保此网站是它声称的身份。</b> <br><br> 发送更改为。 <br>  <b>新令牌以明文形式传输；</b>  <b>旧-受保护</b> <br></td><td> 将数据库中的令牌更改为新令牌。 加载配置文件数据。 使用来自以下请求的新令牌。 发送CSI-Token-Action：成功 </td></tr><tr><td>  3.11执行动作（添加帖子，投票等） </td><td> 从新密钥发送安全令牌 </td><td> 记录此用户的操作。 检查较低的128位令牌。 </td></tr><tr><td>  3.12进行“退出”。 </td><td> 发送注销密钥 </td><td> 中断会议 </td></tr><tr><td>  3.13包含在此站点中。 </td><td> 生成一个随机密钥。 从随机密钥发送不安全的令牌。 </td><td> 我们认为用户是匿名的。 我们使用此令牌作为用户会话的标识符。 我们翻译成授权表格。 </td></tr><tr><td>  3.14激活永久密钥 </td><td> 发送更改为。 两个令牌均以安全方式传输。 </td><td> 我们通过令牌（最高128位）从数据库加载用户数据。 </td></tr><tr><td>  3.15为此域导入一个不同的密钥。 <br>  <b>重要提示：导入的密钥必须在服务器上注册。</b> <br></td><td> 发送密钥注销切换为使用随机密钥。 </td><td> 中断会议 </td></tr><tr><td>  3.16激活新密钥 </td><td> 发送更改为。 <br>  <b>两个令牌均以安全方式传输。</b> <br><br> 请注意，“上一个”键已经是一个随机键（请参阅3.15）。 </td><td> 该密钥必须是数据库已知的。 仅允许已注册令牌从浏览器<b>导出密钥</b> 。 因此，浏览器确定<b>导入的密钥对于服务器是已知的，</b>并且可以安全地发送它。 否则，服务器将无法识别用户令牌，也无法对其进行授权。 </td></tr><tr><td>  3.17执行动作（添加帖子，投票等） </td><td> 从新密钥发送安全令牌 </td><td> 记录此用户的操作。 检查较低的128位令牌。 </td></tr><tr><td>  3.18问世 </td><td> 发送注销密钥 </td><td> 中断会议 </td></tr><tr><th colspan="3">  4个具有两因素授权的站点（Sberbank Online） </th></tr><tr><th> 用户名 </th><th> 浏览器 </th><th> 站点服务器 </th></tr><tr><td>  4.1包含在此站点中。 </td><td> 生成一个随机密钥。 从随机密钥发送不安全的令牌。 </td><td> 我们认为用户是匿名的。 我们使用此令牌作为用户会话的标识符。 我们翻译成授权表格。 </td></tr><tr><td>  4.2创建一个永久站点密钥 </td><td> 没事 </td></tr><tr><td>  4.3激活永久密钥。 </td><td>  <b>问用户：您真的要网站记住您的密钥吗？</b>  <b>确保此网站是它声称的身份。</b> <br><br> 发送更改为。 <br>  <b>令牌以明文形式传输</b> 。 </td><td> 该令牌是站点未知的。 记住新令牌。     .  CSI-Token-Action: registration. </td></tr><tr><td> 4.4     .  «» </td><td>  Change-To      success.       . <br> <b>      .</b> <br></td><td>   .    . </td></tr><tr><td> 4.5      . </td><td>  ajax-.      Change-To. <br><br>    success,      ( ). </td><td>   .      ( ).  CSI-Token-Action: success <br>       . <br>    ,  CSI-Token-Action: registration. <br><br>      CSI-Token-Action: abort.    ,      . </td></tr><tr><td> 4.6    . </td><td>   Token    </td><td>        . </td></tr><tr><td> 4.7  «»   </td><td>   Logout </td><td>   </td></tr><tr><td> 4.8    . </td><td>   .      . </td><td>   .        .          «». </td></tr><tr><td> 4.9   . </td><td>  Change-To. <br> <b>    </b> (..   ;    ). </td><td>        ( 128-).  ,        .      ,   .    .   CSI-Token-Action: success </td></tr><tr><td> 4.10      . </td><td>  ajax-.         . </td><td>  .  .  .       . </td></tr><tr><td> 4.11    . </td><td>   Token   . </td><td>        . </td></tr><tr><td> 4.12  «»   </td><td>   Logout </td><td>   </td></tr><tr><td> 4.12     (). </td><td>    Logout,   «»   .  . </td><td>  ,     Logout.   . </td></tr><tr><th colspan="3"> 5  :   ESXi </th></tr><tr><th> 用户名 </th><th> 浏览器 </th><th>   </th></tr><tr><td> 5.1    . </td><td>   .      . </td><td>   .        .   . </td></tr><tr><td> 5.2    . </td><td></td><td></td></tr><tr><td> 5.3     ( ,   ).  ,   <i></i> . </td><td></td><td></td></tr><tr><td> 5.4     (SSH, RDP).      (  .htaccess – .  ) </td><td></td><td></td></tr><tr><td> 5.5   </td><td>  </td><td>     </td></tr><tr><td> 5.6    . </td><td>   .      . </td><td>   .        .   . </td></tr><tr><td> 5.7   . </td><td>  Change-To. <br> <b>    </b> (..  ,         ;     <i></i> ). </td><td>        (. ). <br><br>     ( 128-). <br>    128-.     . <br>   CSI-Token-Action: success. <br>   CSI-Token-Action: abort (    ),   403 – Forbidden. <br>     . </td></tr><tr><td> 5.8    </td><td>      . </td><td>        . </td></tr><tr><td> 5.9   </td><td>    Logout,   «»   .  . </td><td>  ,     Logout.   . </td></tr><tr><th colspan="3"> 6  :   </th></tr><tr><th> 用户名 </th><th> 浏览器 </th><th>   </th></tr><tr><td> 6.1    . </td><td>   .      . </td><td>   .        . <b>   .</b>   CSI-Support: yes; </td></tr><tr><td> 6.2   . </td><td></td><td></td></tr><tr><td> 6.3   . </td><td> <b> :   ,     ? ,     ,    .</b> <br><br>  Change-To. <br> <b>    </b> . </td><td>  ,   CSI-Token-Action: registration, ..   . </td></tr><tr><td> 6.4  /  « » </td><td>  / POST-  .      Change-To,    . </td><td>  /.    .    .  CSI-Token-Action: success </td></tr><tr><td> 6.5           «» </td><td>     Token    </td><td>    /.  . </td></tr><tr><td> 6.6  </td><td>   Logout </td><td>   </td></tr><tr><td> 6.7    . </td><td>   .      . </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">认为用户是匿名的。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示消息“访问被拒绝”</font></font></b> <br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.8激活永久密钥。 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送更改为。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">令牌以受保护的形式传输</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（因为设备已经知道</font><b><font style="vertical-align: inherit;">该令牌</font></b><font style="vertical-align: inherit;">；我们之前通过了注册）。</font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过最高的128位令牌来标识用户。</font><font style="vertical-align: inherit;">检查低位。</font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.9执行特权操作 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 从永久密钥发送安全令牌 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 根据用户权限执行操作。 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.10出来 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 发送注销密钥 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 中断会议 </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 基于.htaccess文件的令牌访问配置示例。 </font></font><br><pre> <code class="apache">&lt;Directory "/var/www/html"&gt; AuthType CSI AuthName "Restricted Content" AuthTokensFile /etc/apache2/.csi_keys Require valid-user &lt;/Directory&gt;</code> </pre><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 猫/etc/apache2/.csi_keys </font></font></pre><pre> <code class="bash"># # Client Self Identification tokens file # # CSI-Domain-Key UserName Role 84bc3da1b3e33a18e8d5e1bdd7a18d7a166d77ac1b46a1ec38aa35ab7e628ab5 MelnikovIN admin 6d7fce9fee471194aa8b5b6e47267f0348a24b70a0b376535542b996af517398 BoshirovAM user</code> </pre> <br><br><a name="token_algo_for_server"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.7.1使用已知密钥计算站点可能的用户令牌的算法 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们知道域密钥K，则可以轻松计算出将随其请求一起出现的用户的可能“有效”令牌T。</font><font style="vertical-align: inherit;">为此，必须满足条件：请求的发起者，请求的接收者以及执行上下文必须匹配并等于域。</font><font style="vertical-align: inherit;">换句话说，如果我们拥有vsphere.local域名，则：</font></font><br><pre> <code class="plaintext">Sender = Recipient = Context = vsphere.local</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 从这里开始，原始（原始）令牌的计算公式为： </font></font><br><p></p><p><math></math><img src="https://habrastorage.org/getpro/habr/formulas/af8/1c2/5b0/af81c25b054111db5d526fcfb8c4fb8c.svg" alt="$T_s = HMAC_{K}(Sender \cup Recipient \cup Context)$" data-tex="display"></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传输后，原始令牌将得到进一步保护。</font><font style="vertical-align: inherit;">令牌的低128位将与在CSI-Salt </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请求标头中传递的盐一起哈希</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，该站点将看到以下令牌：</font></font><br><p></p><p><math></math><img src="https://habrastorage.org/getpro/habr/formulas/8ea/b59/cc3/8eab59cc3e5060cfec9956f984807b5f.svg" alt="$T = Hi(T_s) \cup HMAC_{salt}( Lo(T_s) )$" data-tex="display"></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是高128位，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是原始令牌的低128位。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，对于公司网络上的封闭式管理控制台，Web控制台不会加载外部脚本，框架等。</font><font style="vertical-align: inherit;">因此，在大多数情况下将满足此条件。</font></font><br><hr> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*有关成盐的方法，请参阅</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“浏览器和服务器之间的盐交换过程”一节。</font></font></a></sup> <br><br><a name="server_token_processing"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.8在服务器上处理令牌 </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将令牌发送到服务器（无密钥） </font></font></h3><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 站点会话中的令牌T状态 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 站点服务器操作 </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 不明 </font></font></td><td>         ,              . <br><br>   .   . <br>   128       . <br>     .      CSI-Salt. <br><br></td></tr><tr><td>  ( 128 ) </td><td>   . <br>      CSI-Salt –   . <br>    .       CSI-Token. <br><br>   ,  CSI-Token-Action: invalid.    400. <br><br>    –  200. <br><br></td></tr></tbody></table></div><br><br><h3>     Permanent </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浏览器锁定客户端密钥。</font><font style="vertical-align: inherit;">用户希望站点记住一个以上会话的客户。</font><font style="vertical-align: inherit;">是否将用户令牌存储在其数据库中由服务器决定。</font><font style="vertical-align: inherit;">我们将CSI-Token-Action：成功或CSI-Token-Action：中止返回给客户端。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用注销密钥发送令牌 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指示当前令牌将不再被浏览器使用。</font><font style="vertical-align: inherit;">当用户单击浏览器中的“退出”，或关闭选项卡并且配置了选项（关闭选项卡时自动退出），或者拒绝使用固定键（“在此站点上忘记我”）时发送。</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺便说一句，不应该自动登录。</font><font style="vertical-align: inherit;">出于安全原因。</font></font></blockquote><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用更改至密钥发送令牌 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将旧令牌称为T，将新令牌称为T'。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要说明：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为新令牌T'，令牌的实际值被发送（对于未注册的令牌，是第一次），而旧令牌是散列的（低128位）。</font></font><br><div class="scrollable-table"><table><tbody><tr><td colspan="2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务器数据库中的令牌状态</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup> </td><td rowspan="2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 站点服务器操作 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ť </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ' </font></font></td></tr><tr><td> 没有啦 </td><td> 没有啦 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原因：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合法的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户</font><b><font style="vertical-align: inherit;">注册</font></b><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将用户会话标识符更改为T'。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送客户端CSI-Token-Action：成功。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户为该站点创建了永久密钥，并执行了“登录”。</font><font style="vertical-align: inherit;">服务器可以在其一侧存储这样的令牌。</font><font style="vertical-align: inherit;">在此之前，请提供填写注册表（如有必要）。</font></font><br><br>    CSI-Token-Action: registration,   ,     (        ).        Change-To (   )   ,     success  abort.   ,  ,     .   –      (  ). <br></td></tr><tr><td> 没有啦 </td><td>  </td><td> : <b> Login</b> . <br><br>    T'  .   .   .   CSI-Token-Action: success. <br><br> <b></b> .         Change-To   ,    CSI-Token-Action: success, <b>  </b>    Change-To   <b>  </b> . <br>    ,       .          . <br>  <b>     </b> ,       «» .    <b>      </b> ,       -. 因为    «  »,    . <br></td></tr><tr><td>  </td><td> 没有啦 </td><td> : <b>  </b>   . <br><br>    T     T'.   . <br>   CSI-Token-Action: success. <br></td></tr><tr><td> , <br>  <br>  <br></td><td>  </td><td> : <b>     </b> <br><br>  ,         ,      -.                  -     . <br><br>            (  ).      – . <br><br>   .   CSI-Token-Action: success <br></td></tr><tr><td> , <br>  <br>  <br> . <br></td><td>  </td><td>  .            .   .  CSI-Token-Action: abort.   . <br><br>  256-       SHA-2.      ( )         . <br><br>          : <ul><li>      ; </li><li>         ; </li><li>    </li></ul>      .   , –  -    . <br>     ,      .        Logout   .   Login  .  . <br></td></tr></tbody></table></div><hr> <sup>*        ,    .</sup> <br><br><a name="sub_domain_identify"></a><h2> 2.9 -  </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如前所述，站点可以与其他合作伙伴站点或其子域进行交互，以向用户提供某些功能。最常见的示例是，当在site.ru网站上某些资源是从img.site.ru子域加载的，一部分是download.site.ru的一部分，另一部分是其他资源的一部分。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，site.ru网站需要能够告知其合作伙伴域确切向谁发出了请求。实际上，如果您在site.ru上获得了授权，则不会自动使您在其他站点（包括该站点的子域）上得到授权。他们还会看到您的其他令牌。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们看看令牌是如何计算的，以及如何为我们提供帮助。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让用户使用永久密钥登录到site.ru并在其中拥有令牌：</font></font><br><p></p><p><math></math><img src="https://habrastorage.org/getpro/habr/formulas/a5a/e9b/500/a5ae9b500f4fd8f2600eafdb3a315d32.svg" alt="$T_1 = HMAC_{site.ru-key}(site.ru \cup site.ru \cup site.ru)$" data-tex="display"></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 从site.ru网站页面到site.ru域的所有请求都是由以下原因引起的： </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 页面资源标签（静态或本机动态） </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 自己的脚本 </font></font></li></ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将具有令牌T </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（请参阅规则</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">这些是对site.ru的合法请求。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，让客户端从site.ru页面下载受限制的文件，但是该链接指向download.site.ru。</font><font style="vertical-align: inherit;">在这种情况下，子域将收到以下令牌（规则</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br><p></p><p><math></math><img src="https://habrastorage.org/getpro/habr/formulas/445/897/361/445897361e99df033e11f354f37071af.svg" alt="$T_2 = HMAC_{site.ru-key}(site.ru \cup download.site.ru \cup site.ru)$" data-tex="display"></p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果在site.ru网站页面上执行了ajax请求（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">则将获得完全相同的download.site.ru令牌</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个域域将收到令牌：</font></font><br><p></p><p><math></math><img src="https://habrastorage.org/getpro/habr/formulas/231/d05/899/231d058996ea04e27a4a67dbdadf68ee.svg" alt="$T_3 = HMAC_{site.ru-key}(site.ru \cup domain \cup site.ru)$" data-tex="display"></p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，请注意，如果满足请求的条件没有改变，则对于给定的域A，B，C，浏览器将始终生成一个常量令牌。</font><font style="vertical-align: inherit;">因此，我们可以进行跨域识别。</font><font style="vertical-align: inherit;">像这样 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从site.ru，我们对子域进行ajax请求。</font><font style="vertical-align: inherit;">我们传递</font><font style="vertical-align: inherit;">由site.ru颁发给用户</font><font style="vertical-align: inherit;">的标识符ID！= T </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1。</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子域得到这个相同的用户ID令牌牛逼</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">每个子域都会使用用户ID生成一堆令牌。</font><font style="vertical-align: inherit;">子域将已经通过服务器到服务器的请求共享有关用户ID及其权限的信息。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一堆完成一次。</font><font style="vertical-align: inherit;">随后，子域将以其自己的令牌为导向，如 </font><font style="vertical-align: inherit;">它们对于site.ru永久密钥也将是永久的。</font></font><br><br><a name="part3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3安全建议 </font></font></h1><br><div class="spoiler">  <b class="spoiler_title">注意事项</b> <div class="spoiler_text">      .          . </div></div><br><br><a name="keys_NAA_protection"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.1保护关键信息免遭未经授权的访问 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提议的授权协议可保护用户免受键盘记录程序窃取您的密码的侵害，因为提议的方案根本不使用密码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，应该更详细地考虑保护密钥免受破坏的方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以通过以下方式破坏密钥：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 通过恶意软件复制关键信息（远程访问） </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 通过关键信息“离线”直接访问文件（直接访问） </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在设备之间分发时 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设密钥信息存储在智能卡上（我们在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“帐户移动性”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分中考虑了此选项</font><font style="vertical-align: inherit;">），则保护密钥信息的任务将转移到芯片上。没错，按键记录程序存在一个漏洞，可以拦截输入的PIN码。好吧，使用上不便。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除智能卡外，对称加密还可用于防止直接访问密钥信息。但是问题是：加密采用什么密钥？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果此密钥是根据用户的密码生成的，则首先，我们容易选择“脱机”密码，其次，实际上，他们留下的内容是：“再次输入了一些密码”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更加正确的选择是以</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特殊方式缝制</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浏览器程序集</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（或其专用库之一）中的</font><b><font style="vertical-align: inherit;">此类密钥</font></b><font style="vertical-align: inherit;">。每次浏览器更新都会更改密钥及其在已编译文件中的位置。这种方法不会提供100％的保护，但是会使解密任务严重复杂化。首先，攻击者将需要找出程序集的确切版本，然后找到它，将其拆解并找出密钥的组装方式。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样，域密钥本身应直接存储在单独的文件中，而不是与其使用配置一起存储（即仅密钥，仅此而已）。然后，将不可能通过密钥选择（从已知程序集中）对它们进行解密，因为不可能从随机字节序列中区分正确解密的密钥。然后，尝试在不知道浏览器程序集确切版本的情况下拿起主键，而直接反汇编其代码将变得根本不可能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以使用组合选项：使用浏览器的密钥加密+使用OS帐户的用户密码加密（如果OS API允许）。而且，密钥总是动态生成的。然后，离线暴力将变得更加昂贵。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，在操作系统中更改用户密码后，密钥也将更改。</font><font style="vertical-align: inherit;">而且，如果您不对旧密钥进行预解密，则可以防止计算机管理员更改密码以访问您的帐户并代表您执行操作时的情况。</font><font style="vertical-align: inherit;">类型的情况：辞职。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您将首先制作密钥的备份副本（将密钥导出到文件中）。</font><font style="vertical-align: inherit;">当然，除非您在将密钥分配给其他设备之前已经这样做。</font></font><br><hr> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*例如，一个32字节的密钥随机分布在可执行文件的64K部分中。</font><font style="vertical-align: inherit;">而且只有源代码知道如何从这些字节中收集珍贵的密钥。</font></font></sup> <br><br><a name="why_password_for_keys_not_good"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.2关于密码作为域密钥 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在协议的初始版本之一中，可以根据用户的密码生成域密钥。该算法非常棘手，它排除了针对同一密码的不同域的重复密钥。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这被定位为通行帐户的便捷方式。输入一个密码，不用担心。但是后来发现：</font></font><br><br><ol><li>     ,     «» ,        ,   .   ,       -,          . <br><br>  (),     8-  ,       ,    .: ~!@#$%^&amp;.   : 26 + 26 + 10 + 8 = 70 . 8-       70 <sup>8</sup> . <br><br> ,     ,         10 <sup>12</sup>   .      70 <sup>8</sup> / 10 <sup>12</sup> = ~576 . 即       ~10 .          5       . 10-      15 .      10 ,      1-2 . <br><br>           ,        . </li><li>       ,     . </li><li>                ,     . 即      (       SHA-2). </li><li>  , ,  ,      .        . </li></ol><br><br><a name="risks_loss_keys"></a><h2> 3.3  /     </h2><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我丢失了万能钥匙怎么办？</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您更改密码或重新安装操作系统，则可能发生这种情况。有什么风险？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，您将无法访问以前的站点。失去在线商店的购物记录，在线网站上的广告，论坛上的业力。没关系</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，谁阻止使用新令牌进行重新注册过程并通过同一公告中指示的电话号码进行确认？原来，该站点需要对令牌进行某种形式的重新注册（类似于“密码恢复”）吗？保证没有“各种”形式的地方在哪里？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，一个站点不仅需要识别访问者，而且还必须知道其真实身份，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制作注册表。</font><font style="vertical-align: inherit;">实际上，该表格可以用于重新注册。</font><font style="vertical-align: inherit;">您指定的数据与以前完全相同（电子邮件，移动电话）。</font><font style="vertical-align: inherit;">确认您具有这些数据（字母，SMS）。</font><font style="vertical-align: inherit;">系统看到这样的帐户已经存在，数据是您的100％，但是令牌不同-它重写了令牌。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，仍然最好不要丢失主密钥。</font></font><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何防止损失？</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建备份副本，使用密码保护它并将其存储在一次性介质上。</font><font style="vertical-align: inherit;">而且，实际上，就像比特币的密钥一样。</font><font style="vertical-align: inherit;">原则上，您可以将主密钥转换为印刷形式并将其保存在一张纸上。</font><font style="vertical-align: inherit;">为此。</font><font style="vertical-align: inherit;">然后通过手动输入还原。</font><font style="vertical-align: inherit;">但这是针对像我这样的“偏执狂”的人。</font></font><br></blockquote><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果万能钥匙被我偷走了怎么办？</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这已经很严重了。尽管此处描述的用于存储主密钥（未包含在协议中）的建议可以防止它们遭到直接篡改，但键盘记录程序和木马程序仍然可以避免损害主密钥的风险。不幸的是，不存在完善的保护措施。可以通过javascript引擎漏洞直接从浏览器内存中劫持密钥。举个例子。还是您丢失了手机... </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那么，窃取主密钥有什么风险？</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接收有关您的信息甚至代表您采取行动所必需。获得攻击者以您的身份并以读取模式登录以获取敏感信息的能力。</font></font>安静安静。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或一次下载来自同学的所有私人视频。对你来说很不愉快海豹爱好者很高兴。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，您需要快速在重要站点上使用新密钥重新注册。而且，如果发生了可怕的事情，那么以正确的方式在服务提供商的数据库中注册新令牌是唯一的正确选择。您可以想到许多注册方法：从正式信件中的纸张固定，到通过网站的技术支持服务进行的应用程序，以可接受的方式确认您的身份。但这仅适用于严重的网站，例如网上银行。</font></font><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小化风险的方法。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在域中使用单个密钥（但这会减少帐户的移动性）。</font><font style="vertical-align: inherit;">通过独立通道进行两因素身份验证。</font><font style="vertical-align: inherit;">该站点显示了上次连接的IP地址和设备，因此您至少会发现一个妥协。</font></font><br></blockquote><br><br><a name="part4"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4攻击授权方案 </font></font></h1><br><br><a name="attack_user_tracking"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.1用户跟踪 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您信任的站点可以无耻地将有关您的信息与其他站点合并。</font><font style="vertical-align: inherit;">在Internet上，有收集器站点，这些站点聚集了此类信息并将其出售给所有人。</font><font style="vertical-align: inherit;">Yandex指标，Google Analytics（分析）-一个罕见的网站没有它们。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使两个不同的站点可以确定它们正在使用同一客户端，使用了两种技术：</font></font><br><br><ol><li>              (     ,     ). </li><li>       (    )       . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方案2中有一个小缺点：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是标识用户</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而是浏览器。但通常是浏览器==客户端。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">似乎该令牌最适合在方案2中使用。毕竟，如果用户允许将自己“记住”到两个站点（作为一对），那么我们的永久令牌可以充当这样的“指纹”，不仅是浏览器，而且是用户本人。这里站点的问题在于它们</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将收到不同的令牌</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是站点可以尝试也应用方案1。然后将得出以下结论。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">站点1将从浏览器接收代码H </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且在站点1的上下文中执行的站点2 </font><font style="vertical-align: inherit;">将接收</font><font style="vertical-align: inherit;">代码H </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。现在看来站点可以形成一对（H </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，H</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），甚至将其传递到某个聚合器站点。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设有另一个站点3与站点2配对，试图跟踪您。</font><font style="vertical-align: inherit;">站点3将从浏览器接收H </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">令牌</font><font style="vertical-align: inherit;">，在站点3的上下文中执行的站点2 </font><font style="vertical-align: inherit;">将接收</font><font style="vertical-align: inherit;">H </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2'</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">令牌</font><font style="vertical-align: inherit;">！= H </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（请参阅令牌的形成方式）。</font><font style="vertical-align: inherit;">结果，不可能合并获得的数据，</font><font style="vertical-align: inherit;">他们没有重叠的部分。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但这</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并不意味着站点将无法使用指纹浏览器进行监视</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它仅说明令牌生成方案本身是非常可靠的，并且可以防止跟踪。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保护选项：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注销您已经使用完的网站。</font><font style="vertical-align: inherit;">关闭选项卡时，浏览器可以自动执行此操作。</font></font><br><br><a name="attack_XSS"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.2 XSS攻击 </font></font></h2><br><br> <abbr title="Cross-Site Scripting — « »"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XSS</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一种攻击，涉及将恶意代码引入受害者网站的页面。</font><font style="vertical-align: inherit;">例如，通过会员脚本或流行框架的被黑CDN。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">恶意代码可以使用站点上的用户授权来获得对该站点的授权访问或窃取用户身份验证数据。</font><font style="vertical-align: inherit;">可以通过Web服务器中的漏洞（琐碎的黑客攻击），会员网络（不可靠的来源），用户计算机上的漏洞（木马抓取）将恶意代码插入页面。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于我们的授权方案，防止此类攻击的主要保护措施是在计算令牌时生成Source字段的特殊规则。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">脆弱性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：对于存储的XSS（当脚本被黑客入侵服务器直接插入受攻击的站点并从中加载脚本时），保护将不起作用。</font><font style="vertical-align: inherit;">因为浏览器将无法将此类脚本标识为“外部”。</font><font style="vertical-align: inherit;">当攻击者代理客户端-服务器流量时，也会发生相同的问题。</font></font><br><br><a name="attack_CSRF"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.3 CSRF攻击 </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受害人访问了由攻击者创建的网站evil.com。代表她的请求（GET / POST / HEAD / PUT / DELETE）被执行到已经授权用户的站点（例如，支付系统服务器）。该请求本身执行某种恶意操作（例如，将资金转入攻击者的帐户）。根据开发人员的监督，该站点不会检查Referer字段，也不会向用户请求其他验证信息。结果，攻击成功。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拟议的站点授权方案可以抑制大多数</font><abbr title="ross Site Request Forgery — «  »"><font style="vertical-align: inherit;">CSRF</font></abbr><font style="vertical-align: inherit;">攻击情形</font></font><abbr title="ross Site Request Forgery — «  »"><font style="vertical-align: inherit;"></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这取决于令牌生成算法。</font><font style="vertical-align: inherit;">任何跨站点请求都将导致受攻击的站点从用户那里收到无效的令牌。</font><font style="vertical-align: inherit;">结果，在这种情况下，受攻击站点的用户将为匿名匿名。</font><font style="vertical-align: inherit;">即使尝试从攻击站点向受攻击站点执行无害GET请求（上传图片），也会导致后者收到无效令牌。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这将大大简化站点开发人员的工作。</font></font><br><br><a name="attack_SSO"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.4使用SSO进行跟踪 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户信任并为其拥有密钥的</font><font style="vertical-align: inherit;">两个站点S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">决定将类似于SSO的技术应用于用户跟踪。但是因为您无法将一个网站嵌入另一个网站（其中一个会收到无效的令牌），也无法使用脚本打开合作伙伴的网站（出于相同的原因），然后网站S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">决定使用棘手的技术。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在其中一页上，他放置了一个半透明标签A，覆盖了整个窗口。链接通向站点S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且用户标识符（来自S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和令牌H </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在地址</font><sub><font style="vertical-align: inherit;">中</font></sub><font style="vertical-align: inherit;">传输</font><font style="vertical-align: inherit;">。用户看不到链接。通过单击站点S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1的</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任何区域</font><font style="vertical-align: inherit;">，它将启动站点S </font><sub><font style="vertical-align: inherit;">2</font></sub><font style="vertical-align: inherit;">上新标签的打开</font></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目前，S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将不会收到有效令牌。</font><font style="vertical-align: inherit;">使用标签自动重新加载也不会帮助他</font></font><br><pre> <code class="xml">&lt;meta http-equiv="refresh" content="0"&gt;</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或脚本。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以伪造的“关闭”按钮的形式在其整个页面上使用A标签：</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/is/n5/jh/isn5jhlcnubhl580cvv6lgdloye.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此链接将首先重新加载该站点，然后将其关闭。</font><font style="vertical-align: inherit;">在重新启动时，浏览器会将</font><font style="vertical-align: inherit;">已经有效的H </font><sub><font style="vertical-align: inherit;">2</font></sub><font style="vertical-align: inherit;">令牌</font><font style="vertical-align: inherit;">发送到S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">站点</font><font style="vertical-align: inherit;">（因为已遵循2.4 P1规则：用户已亲自打开了两个链接）。</font><font style="vertical-align: inherit;">结果，S </font><sub><font style="vertical-align: inherit;">2</font></sub><font style="vertical-align: inherit;">将接收有关其用户在站点S </font><sub><font style="vertical-align: inherit;">1</font></sub><font style="vertical-align: inherit;">上的动作的信息</font><font style="vertical-align: inherit;">，将令牌H </font><sub><font style="vertical-align: inherit;">1</font></sub><font style="vertical-align: inherit;">与它的H </font><sub><font style="vertical-align: inherit;">2</font></sub><font style="vertical-align: inherit;">相关联</font><font style="vertical-align: inherit;">，并将</font><font style="vertical-align: inherit;">服务器间请求</font><font style="vertical-align: inherit;">发送给H </font><sub><font style="vertical-align: inherit;">2</font></sub><font style="vertical-align: inherit;">到S </font><sub><font style="vertical-align: inherit;">1</font></sub><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">将来，站点S </font><sub><font style="vertical-align: inherit;">1</font></sub><font style="vertical-align: inherit;">和S </font><sub><font style="vertical-align: inherit;">2</font></sub><font style="vertical-align: inherit;">将能够通过服务器交换来交换有关用户的任何信息，例如 </font><font style="vertical-align: inherit;">现在他们可以彼此</font><b><font style="vertical-align: inherit;">独立</font></b><font style="vertical-align: inherit;">地唯一标识它</font></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 。 </font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动用户特别容易受到这种攻击，因为 </font><font style="vertical-align: inherit;">试图关闭不必要的页面可能会意外地点击占据整个移动屏幕的虚假链接。</font></font></blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保护方法：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关闭选项卡时自动中断会话。</font><font style="vertical-align: inherit;">然后，站点S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在用户本人登录之前无法接收到有效令牌。</font><font style="vertical-align: inherit;">的确，当用户本人打开选项卡并登录到S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时，这将无法避免这种情况</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后站点才进行了这样的攻击。</font></font><br><br><a name="attack_sso_key_discredit"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.5 SSO的主要危害 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让支持SSO的身份验证服务器上的用户帐户受到损害。</font><font style="vertical-align: inherit;">我们将通过认证方案评估可能的风险。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个站点的令牌都是根据域密钥单独计算的。</font></font><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏一个域密钥不会自动破坏所有其他密钥。</font></font></b> </blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您以前使用SSO登录的大多数站点可能会将令牌和您的个人资料从SSO服务器保存在其数据库中。</font><font style="vertical-align: inherit;">在我们的方案中，站点将仅从数据库中提取令牌并识别您。</font></font>即<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此类站点上不再需要SSO服务器-它在注册阶段执行了其功能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">换句话说，您不会立即自动丢失所有访问权限。攻击者将与其他人在同一站点上被识别。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重新进行跨域身份验证的尝试也不会对攻击者有所帮助：站点应阻止尝试使用旧的SSO ID用户和新的站点令牌创建新帐户。或者，应阻止尝试为SSO进程中的现有ID重写用户令牌。这样的事实应该引起现场的合理怀疑。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户令牌只能以一种方式合法地更改（请参阅</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“协议操作方案”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">风险</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果该站点未将您的令牌和配置文件保存在其数据库中，而是完全依赖于SSO机制，则攻击者只需执行跨域身份验证即可使用您的名称登录。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在妥协的情况下将风险降至最低。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">奇怪的是，但这是令牌和用户个人资料站点在其侧面保留的。攻击者尝试进行跨域身份验证可能会导致旧ID用户与其新令牌之间发生冲突。当用户以协议中指定的方式以外的任何其他方式更改令牌时，这种情况本身应被可疑甚至拒绝。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大风险：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代表您在其他站点（您尚未去过的站点）进行授权。访问您的个人资料数据。代表您实施违法行为。为了使合法所有者无法返回任何东西，攻击者可以通过合法方式在授权服务器上更改其令牌。但是，这种风险与使用传统授权方案时的风险一致。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保护方式。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拒绝使用SSO（特别是因为提出的方案被认为是摆脱集中式身份验证方案的一种方式）。使用多个SSO（不要将所有鸡蛋都放在一个篮子中！）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果SSO支持通过其他属性（邮件，电话）进行身份验证的两因素身份验证，则可能会重新获得对授权服务器帐户的控制权。</font></font><br><br><a name="attack_token_compromise_due_transmit"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.6转让期间的代币泄露 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然，所提出的在传输期间对令牌进行哈希处理的机制</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并不能100％保证</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其受到保护。</font><font style="vertical-align: inherit;">例如，攻击者可以在转移不安全的令牌时（在永久密钥的初次注册时）拦截受害者的流量。</font><font style="vertical-align: inherit;">然后使用它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，鼓励使用SSL。</font><font style="vertical-align: inherit;">但不要将HTTPS视为灵丹妙药。</font><font style="vertical-align: inherit;">该协议以及HTTP也被公开。</font><font style="vertical-align: inherit;">仅难一点。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的确，开放令牌的这种罕见转移以及对每个域使用单独的令牌，降低了利用此漏洞的风险。</font><font style="vertical-align: inherit;">尽管如此。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个危险是在用户的当前会话中拦截和重用令牌。</font><font style="vertical-align: inherit;">就像我之前说的，理想情况下，应在每个客户请求时用新的盐对令牌进行散列。</font><font style="vertical-align: inherit;">但是，这将消除在服务器上并行处理请求的可能性，并使不可能从客户端发送并行请求。</font><font style="vertical-align: inherit;">计算和检查哈希值通常是一项昂贵的操作，会降低性能。</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，标头中传递的令牌永远不能从Javascript获得。</font><font style="vertical-align: inherit;">与带有HttpOnly标志的Cookie相似。</font><font style="vertical-align: inherit;">即使在通过脚本接收ajax请求时也是如此。</font></font></blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作方法：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拦截用户的请求，提取令牌的当前值，使用相同的令牌（代表同一用户）发送另一个操作。</font><font style="vertical-align: inherit;">的确，基于会话cookie的经典系统也容易受到此类攻击。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保护方法：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过其他通信渠道（例如，通过短信或邮件）确认重大操作；</font><font style="vertical-align: inherit;">通过其他通信渠道对令牌进行预注册（例如纸质证书）。</font></font><br><br><a name="attack_token_compromise_due_site_hacking"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.7入侵网站并破坏令牌 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">黑客网站不断发生。</font><font style="vertical-align: inherit;">即使是大型且受到良好保护的站点也会损坏。</font><font style="vertical-align: inherit;">黑客攻击的方式有很多：从琐碎的注入到内部人员“流失”。</font><font style="vertical-align: inherit;">因此，很可能会在任何站点上泄露令牌。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，提议的协议相同，这使网站黑客事件对您的痛苦最小。</font></font><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">令牌的泄露不会导致域密钥的泄露，而域密钥</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的计算是基于</font><b><font style="vertical-align: inherit;">令牌的</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">同样，此</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件不会导致其他令牌的损害</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果是这样，则无法访问其他站点。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当使用主密钥对大多数站点进行密钥时，这尤其令人愉悦：不可能通过反向工程来还原它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是同时，出于明显的原因，不可能使用令牌被泄露的域密钥。</font><font style="vertical-align: inherit;">必须更改密钥。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以使用一个随机数或一个主密钥（加上一个版本号）来为发生官​​方泄漏的域创建密钥：</font></font><br><p></p><p><math></math><img src="https://habrastorage.org/getpro/habr/formulas/b1c/9ee/9ac/b1c9ee9ac9a8f065c9a394045a24edb9.svg" alt="$DomainKey = HMAC_{M_{key}}( DomainName \cup VersionNumber )$" data-tex="display"></p><br><br><a name="epilog"></a><h1> 结论 </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我向我展示了这篇文章的几个朋友问我基本上相同的问题：“这里的主要内容是什么？” </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从高处看</font></font></b> <div class="spoiler_text">  ,        (     ),     (?)  ,   . <br><br> ,     ,  -  .  ,    ,       ,           .       (   ,   ).    ,        « »      «-». <br><br>  -    « ». <s>  </s>    ,  <s></s> «».     ,    .     (   Google ,  Facebook –       ).     (  DDOS-    . – <abbr title="            "><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a></abbr>  )   - .   ,     SSO       ,        .   ? <br><br>   , , ,       .  ,     -     -.  ,     .,     .     email,  .      .  ,             .    ? <br><br> <b>  -.  ?</b> SSO –    . <br><br> ,        « ».         .      .       .             .   , . <br><br>      -      «»  .    ,    « ».          ,    . <br><br>  -,         ? <br></div></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哦，没有主芯片！</font></font></b>  las<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是有许多细节使该协议比传统的登录/密码方案更有利可图。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.您可能在许多站点上注意到了这个烦人的弹出窗口。</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“我们的网站保存cookie！</font><font style="vertical-align: inherit;">戴上头盔并保持警惕，因为大哥在看着你！</font><font style="vertical-align: inherit;">单击“是”，因为您仍然别无选择。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一堆其他同样具有侵入性且非常必要的弹出窗口。</font><font style="vertical-align: inherit;">而这一切都要归功于欧洲GDPR（类似于我们的PD法律）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所以在这里。</font><font style="vertical-align: inherit;">在我们的方案中，出于识别目的，不再需要Cookie！</font><font style="vertical-align: inherit;">从单词“完全”开始。</font><font style="vertical-align: inherit;">用户决定是否允许站点识别它，以及何时以及持续多长时间。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">减去一个烦人的弹出窗口，为协议业力+1。</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.开发人员不再需要执行授权和密码恢复表格。</font><font style="vertical-align: inherit;">无需实施复杂的SSO算法并掌握复杂的库：OAuth，SAML，Kerberos等，无需完成注册网站，更改授权密钥，监视其安全性的过程；</font><font style="vertical-align: inherit;">如果SSO出了问题，请紧急了解：“出了什么问题以及原因。” </font><font style="vertical-align: inherit;">此外，授权服务器可能会出于未知原因阻止您的站点。</font><font style="vertical-align: inherit;">去弄清楚。</font><font style="vertical-align: inherit;">昨天一切正常，但是今天……这里足以从标题中读取令牌并检查数据库中是否存在令牌。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简单=可靠</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是说...</font></font></b> <div class="spoiler_text">      .     .       ,   -  -  .       . .  . <br><br>    -, -,  « »   . <br></div></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.用户不需要输入并记住一堆密码。使用第三方站点的服务，或者由谁以及如何编写程序尚不清楚。您不必担心第三方，键盘记录程序和特洛伊木马程序会访问计算机。制作主密钥的备份副本，用密码保护它并将其存储在USB闪存驱动器上就足够了。就像一个比特币钱包。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么不是功能？</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.如果该站点被黑客入侵，则无需承担任何风险。好了，再次生成密钥。虽然密码泄露给网站的破解者会造成很多麻烦。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.创建该协议时要考虑到已知网络攻击的经验。它的体系结构已经包括针对XSS，CSRF的基本保护。再次，网站管理员会发现开发站点更加容易。和他们的用户-更冷静。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.与特定服务提供商无关的协议及其异想天开。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该协议使您自由。</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.最后，拟议的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协议声明了未来的开放标准</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。并且，如果参与者采用了该标准，则该标准</font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将承担根据规范实施功能的义务</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且不要使集体农场脱离其自己的授权决定，而再次发明登录，注册，密码恢复，注销的形式。并且不要搞乱密码哈希或SQL注入。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最重要的是，像任何开放标准一样，它</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以并且应该得到验证</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独立专家。</font><font style="vertical-align: inherit;">即使协议的原始版本的作者被“搞砸了”，在线社区也可以及时识别此修复程序。</font><font style="vertical-align: inherit;">好吧，或者把我的协议寄给废话。</font><font style="vertical-align: inherit;">for对我来说，对其他所有人都是“维尼携带”。</font></font><br><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-我想我应该在这里停</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E.怀尔斯</font></font><br></blockquote><br><br><hr>  <b>聚苯乙烯</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以使自己熟悉离线格式全文文章的选项。</font><font style="vertical-align: inherit;">在Habr上排版材料时，我会打错字。</font><font style="vertical-align: inherit;">如果您有严重的评论，最好检查原始文件并将文章评论（审阅）保留</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此文件中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">将您的更改发送给我sergey201991 [] gmail。</font><font style="vertical-align: inherit;">我不是章鱼，但我会尽力回答。</font><font style="vertical-align: inherit;">我将在本文中添加多个匹配/有趣的评论。</font><font style="vertical-align: inherit;">连同答案。</font><font style="vertical-align: inherit;">不排除单独的评论文章的变体。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是的，我知道该协议可能存在问题：</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您手边没有钥匙，但无法使用别人的设备在您的帐户下登录，则非常需要；</font><font style="vertical-align: inherit;">密码在这里更方便</font></font></li><li>      ;           ,  SSO </li><li>       «», -  : -      (   ) </li><li>    -  </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于第1页-我正在认真考虑回到基于密码生成域密钥的想法，通过使生成密钥的过程复杂化来防止暴力破解：例如，将散列回合的数量增加到1000。该网站困扰着我。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于第2页-这是按时间处理的。</font><font style="vertical-align: inherit;">您需要习惯于新界面。</font><font style="vertical-align: inherit;">起初并不清楚，然后简单。</font><font style="vertical-align: inherit;">给80年代的一个人提供现代智能手机，他也不会想如何管理它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您读完了，非常感谢！</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN472310/">https://habr.com/ru/post/zh-CN472310/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN472296/index.html">洗衣机的泄漏保护系统</a></li>
<li><a href="../zh-CN472298/index.html">上周第385期来自前端世界的新鲜材料摘要（2019年10月14日至20日）</a></li>
<li><a href="../zh-CN472300/index.html">二元分类问题中对数损失函数（LogLoss）的随机梯度下降（SGD）</a></li>
<li><a href="../zh-CN472304/index.html">美国宇航局聘请工程师开发下一代人形机器人</a></li>
<li><a href="../zh-CN472306/index.html">PHP文摘166（2019年10月7日至21日）</a></li>
<li><a href="../zh-CN472312/index.html">将Maven项目转移到Multi-Release Jar的经验：已经可以，但仍然很困难</a></li>
<li><a href="../zh-CN472314/index.html">我喜欢硬纸板的人</a></li>
<li><a href="../zh-CN472318/index.html">分布于跟踪Istio</a></li>
<li><a href="../zh-CN472320/index.html">Zabbix访谈：12个坦率的答案</a></li>
<li><a href="../zh-CN472326/index.html">我们的航天工业……如果您从极客的角度看待航天工业的问题？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>