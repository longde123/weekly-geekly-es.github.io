<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌🏼 🎠 🐁 لغة البرمجة منعرج 👩🏿‍🚀 🐱 🚽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="تبين أن أول تعليق على المقال الرائع الرؤية الذاتية للغة برمجة مثالية هو إشارة إلى لغة البرمجة Zig . بطبيعة الحال ، أصبح من المثير للاهتمام نوع اللغة ا...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>لغة البرمجة منعرج</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435872/" style=";text-align:right;direction:rtl"><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/pq/fm/db/pqfmdbfclpie1tmlpudotsmvlbw.jpeg"></div><br>  تبين أن أول تعليق على المقال الرائع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الرؤية الذاتية للغة برمجة مثالية</a> هو إشارة إلى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لغة البرمجة Zig</a> .  بطبيعة الحال ، أصبح من المثير للاهتمام نوع اللغة التي تدعي أنها مكانة من C ++ و D و Rust.  نظرت - اللغة تبدو جميلة ومثيرة للاهتمام إلى حد ما.  بناء جملة لطيف يشبه si ، النهج الأصلي لمعالجة الأخطاء ، coroutines المضمنة.  هذه المقالة هي لمحة موجزة عن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الوثائق الرسمية التي</a> تتخللها أفكارهم وانطباعاتهم من أمثلة التعليمات البرمجية قيد التشغيل. <br><a name="habracut"></a><br><h2 style=";text-align:right;direction:rtl">  الابتداء </h2><br>  تثبيت برنامج التحويل البرمجي بسيط للغاية ، بالنسبة لنظام التشغيل Windows ، فقط قم بفك ضغط حزمة التوزيع في بعض المجلدات.  نقوم بإنشاء ملف نصي hello.zig في نفس المجلد ، وأدخل الرمز من الوثائق هناك وحفظه.  يتم التجميع بواسطة الأمر <br><br><pre style=";text-align:right;direction:rtl"><code class="plaintext hljs">zig build-exe hello.zig</code> </pre> <br>  بعد ذلك يظهر hello.exe في نفس الدليل. <br><br>  بالإضافة إلى التجميع ، يتوفر وضع اختبار الوحدة ، لذلك ، يتم استخدام كتل الاختبار في التعليمات البرمجية ، ويتم تنفيذ التجميع وإطلاق الاختبارات بواسطة الأمر <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">zig test hello.zig</code> </pre> <br><h3 style=";text-align:right;direction:rtl">  الشذوذ الأول </h3><br>  المحول البرمجي لا يدعم فواصل أسطر Windows (\ r \ n).  بطبيعة الحال ، فإن حقيقة أن فواصل الأسطر في كل نظام (وين ، نيكس ، ماك) هي بعض من تلقاء نفسها هي الوحشية وبقايا من الماضي.  ولكن لا يوجد شيء يجب القيام به ، لذلك حدد فقط ، على سبيل المثال ، في Notepad ++ التنسيق الذي تريده للمترجم. <br><br>  الغريب الثاني الذي صادفته عن طريق الصدفة - لا يتم دعم علامات التبويب في الكود!  المساحات فقط.  لكن هذا يحدث :) <br><br>  ومع ذلك ، يتم كتابة هذا بصراحة في الوثائق - الحقيقة هي بالفعل في النهاية. <br><br><h3 style=";text-align:right;direction:rtl">  تعليقات </h3><br>  الغريب الآخر هو أن Zig لا يدعم التعليقات متعددة الأسطر.  أتذكر أن كل شيء تم بشكل صحيح في توربو باسكال القديمة - تم دعم التعليقات المتداخلة متعددة الأسطر.  على ما يبدو ، منذ ذلك الحين لم يتقن أي مطور لغة واحدة مثل هذا الشيء البسيط :) <br><br>  ولكن هناك تعليقات وثائقية.  ابدأ بـ ///.  يجب أن يكون في أماكن معينة - أمام الكائنات المقابلة (المتغيرات والوظائف والفئات ...).  إذا كانوا في مكان آخر - خطأ ترجمة.  ليس سيئا <br><br><h3 style=";text-align:right;direction:rtl">  إعلان متغير </h3><br>  انتهيت من النمط المألوف الآن (والصحيح أيديولوجيًا) ، عند كتابة الكلمة الأساسية (const أو var) أولاً ، ثم الاسم ، ثم اختيارياً الكتابة ، ثم القيمة الأولية.  أي  نوع الاستنتاج التلقائي هو متاح.  يجب تهيئة المتغيرات - إذا لم تحدد قيمة أولية ، فسيحدث خطأ في التحويل البرمجي.  ومع ذلك ، يتم توفير قيمة خاصة غير محددة ، والتي يمكن استخدامها صراحة لتحديد المتغيرات غير مهيأة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">var i:i32 = undefined;</code> </pre> <br><h3 style=";text-align:right;direction:rtl">  إخراج وحدة التحكم </h3><br>  بالنسبة للتجارب ، نحتاج إلى الإخراج إلى وحدة التحكم - في جميع الأمثلة ، هذه هي الطريقة المستخدمة.  في مجال المكونات الإضافية <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const warn = std.debug.warn;</code> </pre> <br>  والرمز مكتوب مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">warn("{}\n{}\n", false, "hi");</code> </pre> <br>  يحتوي المحول البرمجي على بعض الأخطاء التي يقوم بإبلاغها بصدق عند محاولة إخراج عدد صحيح أو رقم الفاصلة العائمة بهذه الطريقة: <br><blockquote style=";text-align:right;direction:rtl">  خطأ: خطأ المحول البرمجي: يجب أن يتم صب حرفي عدد صحيح و تعويم في var args.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">github.com/ziglang/zig/issues/557</a> </blockquote><h2 style=";text-align:right;direction:rtl">  أنواع البيانات </h2><br><h3 style=";text-align:right;direction:rtl">  أنواع بدائية </h3><br>  يبدو أن أسماء الأنواع مأخوذة من Rust (i8 ، u8 ، ... i128 ، u128) ، وهناك أيضًا أنواع خاصة للتوافق الثنائي C ، 4 أنواع من أنواع الفاصلة العائمة (f16 ، f32 ، f64 ، f128).  هناك نوع منطقي.  هناك نوع من الفراغ بطول الصفر وقضاء وقت خاص ، والتي سأناقشها لاحقًا. <br><br>  يمكنك أيضًا إنشاء أنواع عدد صحيح من أي طول بالبت من 1 إلى 65535. يبدأ اسم النوع بالحرف i أو u ، ثم يتم كتابة الطول بالبت. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">//  ! var j:i65535 = 0x0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF;</code> </pre> <br>  ومع ذلك ، لم أستطع توصيل هذه القيمة إلى وحدة التحكم - حدث خطأ في LLVM أثناء عملية التحويل البرمجي. <br><br>  بشكل عام ، يعد هذا حلًا مثيرًا للاهتمام ، على الرغم من أنه غامض (IMHO: دعم القيم الحرفية الرقمية الطويلة تمامًا على مستوى المحول البرمجي صحيح ، ولكن أنواع التسمية بهذه الطريقة ليست جيدة جدًا ، من الأفضل القيام بذلك بأمانة من خلال نوع القالب).  ولماذا هو الحد 65535؟  لا يبدو أن المكتبات مثل GMP تفرض مثل هذه القيود؟ <br><br><h3 style=";text-align:right;direction:rtl">  حرفية السلسلة </h3><br>  هذه صفائف أحرف (بدون زائدة صفر في النهاية).  بالنسبة للحرف الحرفية التي تنتهي بصفر ، يتم استخدام البادئة "c". <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const normal_bytes = "hello"; const null_terminated_bytes = c"hello";</code> </pre> <br>  مثل معظم اللغات ، يدعم Zig تسلسل هروب قياسي وإدراج أحرف Unicode من خلال رموزهم (\ uNNNN ، \ UNNNNNN حيث N رقم سداسي عشري). <br>  يتم تشكيل القيم الحرفية متعددة الأسطر باستخدام خطين مائلين للخلف في بداية كل سطر.  لا توجد علامات اقتباس مطلوبة.  هذا هو ، بعض المحاولات لإنشاء سلاسل خام ، ولكن IMHO غير ناجح - ميزة السلاسل الأولية هي أنه يمكنك إدراج أي جزء من النص من أي مكان في التعليمات البرمجية - ومن الأفضل عدم تغيير أي شيء ، ولكن هنا يجب عليك إضافة \\ في بداية كل سطر. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const multiline = \\#include &lt;stdio.h&gt; \\ \\int main(int argc, char **argv) { \\ printf("hello world\n"); \\ return 0; \\} ;</code> </pre> <br><h3 style=";text-align:right;direction:rtl">  حرفي صحيح </h3><br>  كل شيء بلغات تشبه si.  لقد سررت جدًا لأنه بالنسبة للحرف الثمانية ، يتم استخدام البادئة 0o وليس الصفر فقط ، كما في C.  كما يتم دعم القيم الحرفية الثنائية مع بادئة 0b.  يمكن أن تكون القيم الفاصلة العائمة ست عشرية (كما هو الحال في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ملحق GCC</a> ). <br><br><h3 style=";text-align:right;direction:rtl">  العمليات </h3><br>  بالطبع ، هناك العمليات الحسابية القياسية والمنطقية و bitwise C.  يتم دعم العمليات المختصرة (+ = إلخ).  بدلاً من &amp;&amp; و ||  الكلمات الرئيسية و أو تستخدم.  نقطة مثيرة للاهتمام هو أن العمليات مع دلالات مضمونة مضمونة معتمدة بشكل إضافي.  تبدو مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">a +% b a +%= b</code> </pre> <br>  في هذه الحالة ، لا تضمن العمليات الحسابية العادية تجاوز السعة وتعتبر نتائجها أثناء تجاوز السعة غير محددة (ويتم إنشاء أخطاء التجميع للثوابت).  IMHO هذا غريب بعض الشيء ، لكن يبدو أنه مصنوع من بعض الاعتبارات العميقة للتوافق مع دلالات اللغة C. <br><br><h3 style=";text-align:right;direction:rtl">  المصفوفات </h3><br>  حرفية الصفيف تبدو كالتالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const msg = []u8{ 'h', 'e', 'l', 'l', 'o' }; const arr = []i32{ 1, 2, 3, 4 };</code> </pre> <br>  الأوتار صفائف من الأحرف ، كما في C.  الفهرسة الكلاسيكية مع الأقواس المربعة.  يتم توفير عمليات الجمع (تسلسل) وضرب الصفائف.  إنه شيء مثير للاهتمام للغاية ، وإذا كان كل شيء واضحًا مع تسلسل ، ثم الضرب - ظللت أنتظر حتى يقوم شخص ما بتنفيذ هذا ، والآن أنتظر :) في Assembler (!) هناك مثل هذه العملية المزدوجة التي تسمح لك بإنشاء بيانات مكررة.  الآن في منعرج: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const one = []i32{ 1, 2, 3, 4 }; const two = []i32{ 5, 6, 7, 8 }; const c = one ++ two; // { 1,2,3,4,5,6,7,8 } const pattern = "ab" ** 3; // "ababab"</code> </pre> <br><h3 style=";text-align:right;direction:rtl">  مؤشرات </h3><br>  بناء الجملة يشبه C. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">var x: i32 = 1234; //  const x_ptr = &amp;x; //  </code> </pre> <br>  لإلغاء التسجيل (أخذ القيم حسب المؤشر) ، يتم استخدام عملية postfix غير عادية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">x_ptr.* == 5678; x_ptr.* += 1;</code> </pre> <br>  يتم تعيين نوع المؤشر بشكل صريح عن طريق تعيين علامة النجمة أمام اسم النوع <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const x_ptr : *i32 = &amp;x;</code> </pre> <br><h3 style=";text-align:right;direction:rtl">  شرائح (شرائح) </h3><br>  بنية بيانات مضمنة في اللغة التي تتيح لك الرجوع إلى صفيف أو جزء منه.  يحتوي على مؤشر للعنصر الأول وعدد العناصر.  يبدو مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">var array = []i32{ 1, 2, 3, 4 }; const slice = array[0..array.len];</code> </pre> <br>  يبدو أن تؤخذ من الذهاب ، وليس متأكدا.  كما أنني لست متأكدًا مما إذا كان الأمر يستحق التضمين بلغة ، في حين أن تنفيذ أي شيء من هذا القبيل بلغة OOP أمر أساسي للغاية. <br><br><h3 style=";text-align:right;direction:rtl">  الهياكل </h3><br>  طريقة مثيرة للاهتمام لإعلان بنية: يتم الإعلان عن ثابت ، يتم عرض نوعه تلقائيًا كـ "type" (type) ، ويتم استخدامه كاسم للهيكل.  والهيكل نفسه (هيكل) هو "مجهول". <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const Point = struct { x: f32, y: f32, };</code> </pre> <br>  من المستحيل تحديد اسم بالطريقة المعتادة باللغات المشابهة لـ C ، ومع ذلك ، يعرض المترجم اسم النوع وفقًا لقواعد معينة - على وجه الخصوص ، في الحالة المذكورة أعلاه ، سيتزامن ذلك مع اسم ثابت "الكتابة". <br><br>  بشكل عام ، لا تضمن اللغة ترتيب الحقول ومواءمتها في الذاكرة.  إذا كانت هناك حاجة إلى ضمانات ، فيجب استخدام الهياكل "المعبأة". <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const Point2 = packed struct { x: f32, y: f32, };</code> </pre> <br>  التهيئة - بأسلوب تعيين Sishny: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const p = Point { .x = 0.12, .y = 0.34, };</code> </pre> <br>  الهياكل قد يكون لها طرق.  ومع ذلك ، فإن وضع طريقة في هيكل ما يستخدم ببساطة الهيكل كمساحة اسم ؛  على عكس C ++ ، لا يتم تمرير هذه المعلمات الضمنية. <br><br><h3 style=";text-align:right;direction:rtl">  التحويلات </h3><br>  بشكل عام ، هو نفسه كما في C / C ++.  هناك بعض الوسائل المضمنة المريحة للوصول إلى معلومات التعريف ، على سبيل المثال ، عدد الحقول وأسمائها ، التي يتم تنفيذها بواسطة وحدات ماكرو بناء الجملة المضمنة في اللغة (والتي تسمى وظائف مدمجة في الوثائق). <br><br>  من أجل "التوافق الثنائي مع C" يتم توفير بعض التعدادات الخارجية. <br><br>  للإشارة إلى النوع الذي يجب أن يكمن وراء التعداد ، بناء النموذج <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">packed enum(u8)</code> </pre> <br>  حيث u8 هو النوع الأساسي. <br>  يمكن أن تحتوي التعدادات على طرق مشابهة للبنيات (مثل استخدام اسم التعداد كمساحة اسم). <br><br><h3 style=";text-align:right;direction:rtl">  النقابات </h3><br>  كما أفهمها ، فإن الاتحاد في Zig عبارة عن نوع جبري ، أي  يحتوي على حقل علامة مخفي يحدد أي من حقول الاتحاد "نشط".  يتم تنفيذ "التنشيط" لحقل آخر عن طريق إعادة التعيين الكامل للرابطة بأكملها.  مثال التوثيق <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const assert = @import("std").debug.assert; const mem = @import("std").mem; const Payload = union { Int: i64, Float: f64, Bool: bool, }; test "simple union" { var payload = Payload {.Int = 1234}; // payload.Float = 12.34; // !    assert(payload.Int == 1234); //       payload = Payload {.Float = 12.34}; assert(payload.Float == 12.34); }</code> </pre> <br>  يمكن للنقابات أيضًا استخدام الأرقام بشكل صريح للعلامة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">// Unions can be given an enum tag type: const ComplexTypeTag = enum { Ok, NotOk }; const ComplexType = union(ComplexTypeTag) { Ok: u8, NotOk: void, };</code> </pre> <br>  يمكن للنقابات ، مثل التعدادات والهياكل ، توفير مساحة الاسم الخاصة بها للطرق. <br><br><h3 style=";text-align:right;direction:rtl">  أنواع اختياري </h3><br>  منعرج لديه دعم اختياري مدمج.  تتم إضافة علامة استفهام قبل اسم النوع: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const normal_int: i32 = 1234; // normal integer const optional_int: ?i32 = 5678; // optional integer</code> </pre> <br>  ومن المثير للاهتمام ، أن Zig ينفذ شيئًا واحدًا حول الاحتمال الذي اشتبهت فيه ، لكنه لم يكن متأكدًا مما إذا كان صحيحًا أم لا.  يتم جعل المؤشرات متوافقة مع الخيارات دون إضافة حقل مخفي إضافي ("علامة") ، والذي يخزن علامة على صحة القيمة ؛  و null يُستخدم كقيمة غير صالحة.  وبالتالي ، فإن أنواع المراجع الممثلة في Zig بواسطة مؤشرات لا تتطلب حتى ذاكرة إضافية لـ "الاختيارية".  في الوقت نفسه ، يُحظر تعيين القيم الخالية إلى مؤشرات عادية. <br><br><h3 style=";text-align:right;direction:rtl">  أنواع الأخطاء </h3><br>  تشبه الأنواع الاختيارية ، ولكن بدلاً من العلامة المنطقية ("غير صالحة حقًا") ، يتم استخدام عنصر التعداد المقابل لرمز الخطأ.  يشبه بناء الجملة الخيارات ، يتم إضافة علامة التعجب بدلاً من علامة الاستفهام.  وبالتالي ، يمكن استخدام هذه الأنواع ، على سبيل المثال ، للرجوع من الوظائف: إما أن يتم إرجاع نتيجة الكائن لعملية ناجحة للوظيفة ، أو يتم إرجاع خطأ في الكود المقابل.  تعد أنواع الأخطاء جزءًا مهمًا من نظام معالجة الأخطاء بلغة Zig ، لمزيد من التفاصيل ، انظر قسم معالجة الأخطاء. <br><br><h3 style=";text-align:right;direction:rtl">  اكتب الفراغ </h3><br>  متغيرات مثل الفراغ والعمليات معهم ممكنة في منعرج <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">var x: void = {}; var y: void = {}; x = y;</code> </pre> <br>  لا يتم إنشاء كود لمثل هذه العمليات ؛  هذا النوع مفيد بشكل رئيسي في metaprogramming. <br><br>  يوجد أيضًا نوع c_void للتوافق مع C. <br><br><h2 style=";text-align:right;direction:rtl">  مشغلي التحكم والوظائف </h2><br>  وتشمل هذه: الكتل ، التبديل ، بينما ، إذا ، وإلا ، فاصل ، تابع.  لتجميع التعليمات البرمجية ، يتم استخدام الأقواس المعقوفة القياسية.  فقط كتل ، كما هو الحال في C / C ++ ، وتستخدم للحد من نطاق المتغيرات.  يمكن اعتبار الكتل تعبيرات.  لا توجد غوتو في اللغة ، ولكن هناك تسميات يمكن استخدامها مع بيانات الاستراحة والمتابعة.  بشكل افتراضي ، يعمل هؤلاء المشغلون مع الحلقات ؛ ومع ذلك ، إذا كان للكتلة تسمية ، فيمكنك استخدامها. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">var y: i32 = 123; const x = blk: { y += 1; break :blk y; //   blk   y };</code> </pre> <br>  يختلف بيان التبديل عن المشغل لأنه لا يحتوي على "سقوط" ، أي  يتم تنفيذ شرط واحد فقط (الحالة) ويخرج المفتاح.  بناء الجملة أكثر إحكاما: بدلاً من الحالة ، يتم استخدام السهم "=&gt;".  يمكن أيضًا اعتبار التبديل تعبيرًا. <br><br>  في حين أن العبارات هي نفسها كما هو الحال في جميع اللغات تشبه C.  للبيان هو أشبه foreach.  يمكن اعتبار كل منهم تعبيرات.  من الميزات الجديدة ، في حين ولأجل ، وكذلك لو ، يمكن أن يكون لديك كتلة أخرى ينفذ إذا لم يكن هناك تكرار حلقة. <br><br>  وهنا حان الوقت للحديث عن ميزة شائعة للتبديل ، بينما يتم استعارتها بطريقة أو بأخرى من مفهوم حلقات foreach - "التقاط" المتغيرات.  يبدو مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">while (eventuallyNullSequence()) |value| { sum1 += value; } if (opt_arg) |value| { assert(value == 0); } for (items[0..1]) |value| { sum += value; }</code> </pre><br>  هنا ، تعتبر وسيطة "مصدر" معينة للبيانات ، والتي يمكن أن تكون اختيارية ، بالنسبة لصفيف أو شريحة ، ويحتوي متغير يقع بين خطين عموديين على قيمة "موسعة" - أي ،  العنصر الحالي للصفيف أو الشريحة (أو مؤشر إليه) ، والقيمة الداخلية للنوع الاختياري (أو مؤشر إليها). <br><br><h3 style=";text-align:right;direction:rtl">  تأجيل و errdefer البيانات </h3><br>  بيان التنفيذ المؤجل المقترض من Go.  إنه يعمل بنفس الطريقة - يتم تنفيذ وسيطة عامل التشغيل هذا عند مغادرة النطاق الذي يتم استخدام المشغل فيه.  بالإضافة إلى ذلك ، يتم توفير عامل التشغيل errdefer ، والذي يتم تشغيله إذا تم إرجاع نوع خطأ مع رمز خطأ نشط من الوظيفة.  هذا جزء من نظام Zig لمعالجة الأخطاء الأصلي. <br><br><h3 style=";text-align:right;direction:rtl">  مشغل غير قابل للوصول </h3><br>  عنصر برمجة العقد.  كلمة أساسية خاصة ، يتم وضعها حيث لا ينبغي أن تأتي الإدارة تحت أي ظرف من الظروف.  في حالة وصولها إلى هناك ، يتم إنشاء حالة من الذعر في أوضاع Debug و ReleaseSafe ، وفي ReleaseFast يقوم المحسن بإلقاء هذه الفروع بالكامل. <br><br><h3 style=";text-align:right;direction:rtl">  noreturn </h3><br>  من الناحية الفنية ، إنه نوع متوافق في التعبيرات مع أي نوع آخر.  هذا ممكن بسبب حقيقة أن كائن من هذا النوع لن يعود أبدا.  نظرًا لأن المشغلين عبارة عن تعبيرات في Zig ، يلزم وجود نوع خاص للتعبيرات التي لن يتم تقييمها أبدًا.  يحدث هذا عندما ينقل الجانب الأيمن من التعبير التحكم بشكل لا رجعة فيه إلى مكان خارج.  لكسر مثل هذه العبارات ، تابع ، أرجع ، لا يمكن الوصول إليه ، حلقات لانهائية ووظائف لا تُرجع السيطرة أبدًا.  للمقارنة ، فإن استدعاء وظيفة عادية (التحكم في العودة) ليس عامل تشغيل ظهرًا ، لأنه على الرغم من نقل التحكم إلى الخارج ، فإنه سيتم إرجاعه إلى نقطة الاتصال عاجلاً أم آجلاً. <br><br>  وبالتالي ، فإن التعبيرات التالية تصبح ممكنة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">fn foo(condition: bool, b: u32) void { const a = if (condition) b else return; @panic("do something with a"); }</code> </pre> <br>  يحصل المتغير a على القيمة التي يتم إرجاعها بواسطة عبارة if / else.  لهذا الغرض ، يجب أن تُرجع الأجزاء (كلاهما إذا كانت أو غير ذلك) تعبيرًا من نفس النوع.  إذا أعاد الجزء منطقيًا ، فسيكون الجزء الآخر هو نوع noreturn ، المتوافق تقنيًا مع أي نوع ، ونتيجة لذلك ، يتم تجميع التعليمات البرمجية دون أخطاء. <br><br><h3 style=";text-align:right;direction:rtl">  وظائف </h3><br>  بناء الجملة كلاسيكي للغات من هذا النوع: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">fn add(a: i8, b: i8) i8 { return a + b; }</code> </pre> <br>  بشكل عام ، وظائف تبدو جميلة القياسية.  لم ألاحظ حتى الآن علامات على وظائف من الدرجة الأولى ، لكن معرفتي باللغة سطحية للغاية ، فقد أكون مخطئًا.  على الرغم من أن هذا لم يحدث بعد. <br><br>  ميزة أخرى مثيرة للاهتمام هي أنه في Zig ، لا يمكن تجاهل القيم المعادة إلا صراحة باستخدام الشرطة السفلية _ <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> _ = foo();</code> </pre> <br>  هناك انعكاس يسمح لك بالحصول على معلومات متنوعة حول الوظيفة <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const assert = @import("std").debug.assert; test "fn reflection" { assert(@typeOf(assert).ReturnType == void); //    assert(@typeOf(assert).is_var_args == false); //    }</code> </pre> <br><h2 style=";text-align:right;direction:rtl">  تنفيذ التعليمات البرمجية في وقت الترجمة </h2><br>  يوفر Zig ميزة قوية - رمز التنفيذ المكتوب في منعرج في وقت الترجمة.  لكي يتم تنفيذ التعليمات البرمجية في وقت التحويل البرمجي ، قم فقط بلفها في كتلة باستخدام الكلمة الأساسية وقت التشغيل.  يمكن استدعاء نفس الوظيفة في وقت الترجمة وفي وقت التشغيل ، مما يسمح لك بكتابة رمز عالمي.  بالطبع ، هناك بعض القيود المرتبطة سياقات مختلفة من التعليمات البرمجية.  على سبيل المثال ، في الوثائق في العديد من الأمثلة ، يتم استخدام وقت التحقق من وقت الترجمة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">// array literal const message = []u8{ 'h', 'e', 'l', 'l', 'o' }; // get the size of an array comptime { assert(message.len == 5); }</code> </pre> <br>  ولكن بطبيعة الحال فإن قوة هذا المشغل أبعد ما يكون عن الكشف الكامل هنا.  لذلك ، في وصف اللغة ، يتم تقديم مثال كلاسيكي على الاستخدام الفعال لوحدات الماكرو النحوية - تنفيذ دالة مماثلة لـ printf ، ولكن تحليل سلسلة التنسيق وإجراء جميع أنواع التحقق اللازمة من الوسائط في مرحلة الترجمة. <br><br>  أيضًا ، يتم استخدام وقت الكلمة للإشارة إلى معلمات وظائف وقت الترجمة ، والتي تشبه وظائف قالب C ++. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">   fn max(comptime T: type, a: T, b: T) T { return if (a &gt; b) a else b; }</code> </pre> <br><h2 style=";text-align:right;direction:rtl">  خطأ في التعامل </h2><br>  اخترع Zig نظام معالجة الأخطاء الأصلي الذي لم يكن مثل اللغات الأخرى.  يمكن أن يسمى هذا "استثناءات صريحة" (في هذه اللغة ، يكون explic شاهد بشكل عام أحد المصطلحات).  يبدو أيضًا رموز العودة العودة ، لكنه يعمل بشكل مختلف. <br><br>  يعتمد نظام معالجة الأخطاء Zig على تعدادات خاصة لتنفيذ رموز الأخطاء المخصصة (خطأ) وبنيت على أساس "أنواع الأخطاء" الخاصة بهم (النوع الجبري-النوع ، والجمع بين نوع الوظيفة التي تم إرجاعها ورمز الخطأ). <br><br>  يتم الإعلان عن تعداد الأخطاء بنفس طريقة التعدادات العادية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const FileOpenError = error { AccessDenied, OutOfMemory, FileNotFound, }; const AllocationError = error { OutOfMemory, };</code> </pre> <br>  ومع ذلك ، تلقي كافة رموز الخطأ قيم أكبر من الصفر؛  أيضًا ، إذا أعلنت رمزًا يحمل الاسم نفسه في عددين ، فسيحصل على نفس القيمة.  ومع ذلك ، فإن التحويلات الضمنية بين الأعداد المختلفة للأخطاء محظورة. <br><br>  تعني الكلمة الرئيسية anyerror تعدادًا يشمل جميع رموز الأخطاء. <br><br>  مثل الأنواع الاختيارية ، تدعم اللغة إنشاء أنواع الأخطاء باستخدام بناء جملة خاص.  اكتب! U64 عبارة عن نموذج مختصر لأي إرهاب! U64 ، والذي بدوره يعني اتحاد (خيار) ، والذي يتضمن النوع u64 واكتب أي إرهاب (كما أفهمها ، يتم حجز الكود 0 للإشارة إلى عدم وجود خطأ وصلاحية حقل البيانات ، أما باقي الرموز فهي في الواقع رموز الخطأ). <br><br>  تتيح لك الكلمة الأساسية catch التقاط الخطأ وتحويله إلى قيمة افتراضية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const number = parseU64(str, 10) catch 13;</code> </pre> <br>  لذلك ، إذا حدث خطأ في وظيفة parseU64 تُرجع نوع! U64 ، فحينئذٍ سوف يقوم "catch" باعتراضها وإرجاع القيمة الافتراضية وهي 13. <br><br>  تتيح لك الكلمة الأساسية try "إعادة توجيه" الخطأ إلى المستوى العلوي (أي إلى مستوى وظيفة الاتصال).  عرض الكود <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">fn doAThing(str: []u8) !void { const number = try parseU64(str, 10); // ... }</code> </pre> <br>  أي ما يعادل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">fn doAThing(str: []u8) !void { const number = parseU64(str, 10) catch |err| return err; // ... }</code> </pre> <br>  هنا يحدث ما يلي: يتم استدعاء parseU64 ، إذا تم إرجاع خطأ منه - يتم اعتراضه بواسطة عبارة catch ، حيث يتم استخراج رمز الخطأ باستخدام بناء الجملة "الالتقاط" ، والذي تم وضعه في متغير err ، والذي يتم إرجاعه عبر! Void إلى وظيفة الاتصال. <br><br>  يشير عامل التشغيل Errdefer الموضح سابقًا أيضًا إلى معالجة الأخطاء.  يتم تنفيذ رمز وسيطة Errdefer فقط إذا أرجعت الدالة خطأ. <br><br>  بعض الاحتمالات أكثر.  باستخدام ||  يمكنك دمج مجموعات الأخطاء <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const A = error{ NotDir, PathNotFound, }; const B = error{ OutOfMemory, PathNotFound, }; const C = A || B;</code> </pre> <br>  يوفر Zig أيضًا ميزات مثل تتبع الأخطاء.  هذا شيء مشابه لتتبع المكدس ، ولكنه يحتوي على معلومات مفصلة حول الخطأ الذي حدث وكيفية انتشاره على امتداد سلسلة المحاولات من مكان التكرار إلى الوظيفة الرئيسية للبرنامج. <br><br>  ,     Zig     ,       C++,      Go.  ,        —  4 ,        ;   —    .    ++,        -    .     —      . <br><br><h2 style=";text-align:right;direction:rtl">  </h2><br>  Zig   .  ,      async,         (  ,   ). <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">test "create a coroutine and cancel it" { const p = try async&lt;std.debug.global_allocator&gt; simpleAsyncFn(); comptime assert(@typeOf(p) == promise-&gt;void); cancel p; assert(x == 2); } async&lt;*std.mem.Allocator&gt; fn simpleAsyncFn() void { x += 1; }</code> </pre> <br> async     promise-&gt;T ( T —   ).       . <br><br>       suspend, resume  cancel.   suspend        .    suspend,         . <br><br> resume    promise-&gt;T       ,     . <br><br> cancel   . <br><br>          (  )  .   : <br><br><img src="https://habrastorage.org/webt/yi/em/dv/yiemdv3ujvm-rodjnohawjtld68.png" alt="الصورة"><br><br>  ( )  —  await.   ,   ,  ,   (,    ).          ,      : <br><br><img src="https://habrastorage.org/webt/yo/gu/uq/yoguuqayvhwyxtrhcni-rjn-w7g.png" alt="الصورة"><br><br><h2 style=";text-align:right;direction:rtl">   </h2><br> builtin functions —    ,          . ,      «  »,         . builtin'      (sizeOf, tagName, TagType, typeInfo, typeName, typeOf),      (import).      builtin' C/C++ —     ,     sqrt, popCount, slhExact  ..  ,          . <br><br><h3 style=";text-align:right;direction:rtl">  في الختام </h3><br>        .      ,     ,              . ++ ,   ,       ,         -        . Rust ,      ,    . D —  ,     ,          Java,      -     .   Zig —    .  ,         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar435872/">https://habr.com/ru/post/ar435872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar435862/index.html">قاعة مشاهير إلكترونيات المستهلك: قصص أفضل الأدوات خلال الخمسين عامًا الماضية ، الجزء الرابع</a></li>
<li><a href="../ar435864/index.html">تعيين طلبات Netty</a></li>
<li><a href="../ar435866/index.html">إطلاق تكنولوجيا المعلومات: منصة جديدة لإطلاق المنتجات والخدمات كجزء من مهرجان SXSW 2019</a></li>
<li><a href="../ar435868/index.html">طين 2018. يوم المعاينة</a></li>
<li><a href="../ar435870/index.html">أوركسترا Cybernetic. Docker Container Orchestration مع .NET Core Applications في السحابة</a></li>
<li><a href="../ar435876/index.html">إعدادات متصفح فايرفوكس مفصلة</a></li>
<li><a href="../ar435878/index.html">الهواة في مفتوحة المصدر - الدروس المستفادة في 3 سنوات</a></li>
<li><a href="../ar435880/index.html">تغيير مخطط جداول PostgreSQL بدون أقفال طويلة. محاضرة ياندكس</a></li>
<li><a href="../ar435882/index.html">استعراض Xiaomi Mi Box S ومقارنة صغيرة مع Mi Box 3</a></li>
<li><a href="../ar435884/index.html">البحث عن المعادن و ... الشبكة العصبية</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>