<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏿 👠 🧝🏻 Einführung in Go-Module 🔊 ⏸️ 🤐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die bevorstehende Version 1.11 der Programmiersprache Go bietet experimentelle Unterstützung für Module - ein neues Abhängigkeitsmanagementsystem für ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in Go-Module</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421411/"><p>  Die bevorstehende Version 1.11 der Programmiersprache Go bietet experimentelle Unterstützung für <em>Module</em> - ein neues Abhängigkeitsmanagementsystem für Go.  (Anmerkung Übersetzung: <a href="">Veröffentlichung erfolgte</a> ) </p><br><p>  Kürzlich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich bereits einen kleinen Beitrag dazu geschrieben</a> .  Seitdem hat sich etwas leicht geändert, und wir sind der Veröffentlichung näher gekommen. Daher scheint es mir, dass die Zeit für einen neuen Artikel gekommen ist - lassen Sie uns mehr Übung hinzufügen. </p><br><p>  Also, hier ist, was wir tun werden: Erstellen Sie ein neues Paket und machen Sie dann ein paar Releases, um zu sehen, wie es funktioniert. </p><a name="habracut"></a><br><h2 id="sozdanie-modulya">  Modulerstellung </h2><br><p> Erstellen Sie zunächst unser Paket.  Nennen wir es testmod.  Wichtiges Detail: <strong>Das Paketverzeichnis sollte <em>außerhalb von</em> <code>$GOPATH</code> , da darin die <code>$GOPATH</code> standardmäßig deaktiviert ist</strong> .  Go-Module sind der erste Schritt in Richtung einer vollständigen Aufgabe von <code>$GOPATH</code> in der Zukunft. </p><br><pre> <code class="hljs dos">$ <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> testmod $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> testmod</code> </pre> <br><p>  Unser Paket ist ganz einfach: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> testmod <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-comment"><span class="hljs-comment">// Hi returns a friendly greeting func Hi(name string) string { return fmt.Sprintf("Hi, %s", name) }</span></span></code> </pre> <br><p>  Das Paket ist fertig, aber noch kein <em>Modul</em> .  Lass es uns reparieren. </p><br><pre> <code class="hljs go">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> mod init github.com/robteix/testmod <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: creating <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>.mod: module github.com/robteix/testmod</code> </pre> <br><p>  Wir haben eine neue Datei namens <code>go.mod</code> im Paketverzeichnis mit folgendem Inhalt: </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">github</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">robteix</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testmod</span></span></span></span></code> </pre> <br><p>  Ein bisschen, aber genau das macht unser Paket zu einem <em>Modul</em> . </p><br><p>  Jetzt können wir diesen Code in das Repository verschieben: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git init <span class="hljs-variable"><span class="hljs-variable">$</span></span> git add * <span class="hljs-variable"><span class="hljs-variable">$</span></span> git commit <span class="hljs-literal"><span class="hljs-literal">-am</span></span> <span class="hljs-string"><span class="hljs-string">"First commit"</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push <span class="hljs-literal"><span class="hljs-literal">-u</span></span> origin master</code> </pre> <br><p>  Bisher würde sich jeder bewerben <code>go get</code> unser Paket nutzen möchte: </p><br><pre> <code class="hljs swift">$ go <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> github.com/robteix/testmod</code> </pre> <br><p>  Und dieser Befehl würde den neuesten Code aus dem Hauptzweig bringen.  Diese Option funktioniert immer noch, aber es wäre besser, wenn wir es nicht mehr tun, denn jetzt "gibt es einen besseren Weg".  Das direkte Entnehmen von Code aus dem Hauptzweig ist in der Tat gefährlich, da wir nie sicher wissen, dass die Autoren des Pakets keine Änderungen vorgenommen haben, die unseren Code „beschädigen“.  Um dieses Problem zu lösen, wurden Go-Module erfunden. </p><br><h2 id="nebolshoe-otstuplenie-o-versionirovanii-moduley">  Ein kleiner Exkurs über Versionierungsmodule </h2><br><p>  Go-Module sind versioniert, und es gibt einige Besonderheiten einzelner Versionen.  Sie müssen sich mit den Konzepten vertraut machen, die der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">semantischen Versionierung</a> zugrunde liegen. </p><br><p>  Darüber hinaus verwendet Go bei der Suche nach Versionen Repository-Tags, und einige Versionen unterscheiden sich von den anderen: Beispielsweise müssen Versionen 2 und höher einen anderen Importpfad haben als die Versionen 0 und 1 (wir werden darauf zurückkommen). </p><br><p>  Standardmäßig lädt Go die neueste <em>Version</em> herunter <em>, für die ein Tag</em> im Repository verfügbar ist. <br>  Dies ist eine wichtige Funktion, da sie bei der Arbeit mit dem Hauptzweig verwendet werden kann. </p><br><p>  Für uns ist es jetzt wichtig, dass wir beim Erstellen der Version unseres Pakets ein Etikett mit der Version in das Repository einfügen. </p><br><p>  Lass es uns tun. </p><br><h2 id="delaem-svoy-pervyy-reliz">  Machen Sie Ihre erste Veröffentlichung </h2><br><p>  Unser Paket ist fertig und wir können es auf der ganzen Welt "ausrollen".  Wir tun dies mit versionierten Etiketten.  Die Versionsnummer sei 1.0.0: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git tag v1.<span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push -<span class="hljs-literal"><span class="hljs-literal">-tags</span></span></code> </pre> <br><p>  Diese Befehle erstellen ein Tag in meinem Github-Repository, das das aktuelle Commit als Release 1.0.0 kennzeichnet. </p><br><p>  Go besteht nicht darauf, aber es ist eine gute Idee, einen zusätzlichen neuen Zweig ("v1") zu erstellen, an den wir Patches senden können. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git checkout <span class="hljs-literal"><span class="hljs-literal">-b</span></span> v1 <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push <span class="hljs-literal"><span class="hljs-literal">-u</span></span> origin v1</code> </pre> <br><p>  Jetzt können wir in der Hauptniederlassung arbeiten, ohne uns Sorgen machen zu müssen, dass wir unsere Version brechen können. </p><br><h2 id="ispolzovanie-nashego-modulya">  Mit unserem Modul </h2><br><p>  Verwenden wir das erstellte Modul.  Wir werden ein einfaches Programm schreiben, das unser neues Paket importiert: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(testmod.Hi(<span class="hljs-string"><span class="hljs-string">"roberto"</span></span>)) }</code> </pre> <br><p>  Bis jetzt haben Sie <code>go get github.com/robteix/testmod</code> , um das Paket herunterzuladen, aber mit Modulen wird es interessanter.  Zunächst müssen wir die Modulunterstützung in unserem neuen Programm aktivieren. </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> init <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span></code> </pre> <br><p>  Wie Sie wahrscheinlich erwartet haben, wurde basierend auf dem, was Sie zuvor gelesen haben, eine neue <code>go.mod</code> Datei im Verzeichnis mit dem Namen des darin enthaltenen Moduls <code>go.mod</code> : </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mod</span></span></span></span></code> </pre> <br><p>  Die Situation wird noch interessanter, wenn wir versuchen, unser Programm zusammenzustellen: </p><br><pre> <code class="hljs go">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: finding github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: downloading github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Wie Sie sehen können, hat der Befehl <code>go</code> das von unserem Programm importierte Paket automatisch gefunden und heruntergeladen. <br>  Wenn wir unsere <code>go.mod</code> Datei überprüfen, werden wir <code>go.mod</code> , dass sich etwas geändert hat: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Und wir haben eine weitere neue Datei namens <code>go.sum</code> , die die Hashes der Pakete enthält, um die richtige Version und die richtigen Dateien zu überprüfen. </p><br><pre> <code class="hljs matlab">github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> h1:<span class="hljs-number"><span class="hljs-number">9</span></span>EdH0EArQ/rkpss9Tj8gUnwx3w5p0jkzJrd5tRAhxnA= github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/go.<span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> h1:UVhi5McON9ZLc5kl5iN2bTXlL6ylcxE9VInV71RrlO8=</code> </pre> <br><h2 id="delaem-reliz-reliz-s-ispravleniem-oshibki">  Erstellen einer Version zur Fehlerbehebung </h2><br><p>  Nehmen wir an, wir haben ein Problem in unserem Paket gefunden: Die Begrüßung enthält keine Interpunktion! <br>  Einige Leute werden wütend sein, weil unser freundlicher Gruß nicht mehr so ​​freundlich ist. <br>  Lassen Sie uns das beheben und eine neue Version veröffentlichen: </p><br><pre> <code class="hljs pgsql">// Hi <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> a friendly greeting func Hi(<span class="hljs-type"><span class="hljs-type">name</span></span> string) string { - <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf("Hi, %s", <span class="hljs-type"><span class="hljs-type">name</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf("Hi, %s!", <span class="hljs-type"><span class="hljs-type">name</span></span>) }</code> </pre> <br><p>  Wir haben diese Änderung direkt in der <code>v1</code> Verzweigung vorgenommen, da sie nichts mit dem zu tun hat, was wir als nächstes in der <code>v2</code> Verzweigung tun werden. Im wirklichen Leben sollten Sie diese Änderungen jedoch möglicherweise am <code>master</code> vornehmen und sie dann auf <code>v1</code> .  In jedem Fall sollte sich das <code>v1</code> Zweig <code>v1</code> und wir müssen dies als neue Version markieren. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git commit <span class="hljs-literal"><span class="hljs-literal">-m</span></span> <span class="hljs-string"><span class="hljs-string">"Emphasize our friendliness"</span></span> testmod.go <span class="hljs-variable"><span class="hljs-variable">$</span></span> git tag v1.<span class="hljs-number"><span class="hljs-number">0.1</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push -<span class="hljs-literal"><span class="hljs-literal">-tags</span></span> origin v1</code> </pre> <br><h2 id="obnovlenie-moduley">  Module aktualisieren </h2><br><p>  Standardmäßig aktualisiert Go Module nicht ohne Anforderung.  "Und das ist gut", da wir alle Vorhersehbarkeit in unseren Builds wünschen.  Wenn die Go-Module bei jeder Veröffentlichung einer neuen Version automatisch aktualisiert würden, würden wir zu den "dunklen Zeiten vor Go1.11" zurückkehren.  Aber nein, wir müssen Go <em>mitteilen</em> , dass die Module für uns aktualisiert werden sollen. </p><br><p>  Und wir werden es mit Hilfe unseres alten Freundes tun - <code>go get</code> : </p><br><ul><li><p>  Führen Sie <code>go get -u</code> , um die letzte <em>Neben- oder Patch-</em> Version zu verwenden (d. h. der Befehl wird von 1.0.0 auf beispielsweise 1.0.1 oder 1.1.0 aktualisiert, wenn eine solche Version verfügbar ist). </p><br></li><li><p>  Führen Sie <code>go get -u=patch</code> , um die neueste Patch-Version zu verwenden (d. h. das Paket wird auf 1.0.1 aktualisiert, jedoch <em>nicht</em> auf 1.1.0). </p><br></li><li><p>  Führen Sie <code>go get package@version</code> , um ein Upgrade auf eine bestimmte Version <code>github.com/robteix/testmod@v1.0.1</code> (z. B. <code>github.com/robteix/testmod@v1.0.1</code> ). </p><br></li></ul><br><p>  In dieser Liste gibt es keine Möglichkeit, auf die neueste <em>Hauptversion</em> zu aktualisieren.  Dafür gibt es einen guten Grund, wie wir gleich sehen werden. </p><br><p>  Da unser Programm Version 1.0.0 unseres Pakets verwendet hat und wir gerade Version 1.0.1 erstellt haben, aktualisiert uns <em>jeder</em> der folgenden Befehle auf 1.0.1: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> go get <span class="hljs-literal"><span class="hljs-literal">-u</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> go get <span class="hljs-literal"><span class="hljs-literal">-u</span></span>=patch <span class="hljs-variable"><span class="hljs-variable">$</span></span> go get github.com/robteix/testmod@v1.<span class="hljs-number"><span class="hljs-number">0.1</span></span></code> </pre> <br><p>  Nach dem Start (sagen wir <code>go get -u</code> ) hat sich unser <code>go.mod</code> geändert: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span></code> </pre> <br><h2 id="mazhornye-versii">  Hauptversion </h2><br><p>  Gemäß der Spezifikation der semantischen Versionierung unterscheidet sich die Hauptversion von der Nebenversion.  Hauptversionen können die Abwärtskompatibilität beeinträchtigen.  Aus Sicht der Go-Module ist die Hauptversion ein völlig <em>anderes Paket</em> . </p><br><p>  Es mag zunächst wild klingen, aber es macht Sinn: Zwei Versionen der Bibliothek, die nicht miteinander kompatibel sind, sind zwei verschiedene Bibliotheken. </p><br><p>  Nehmen wir eine wesentliche Änderung in unserem Paket vor.  Angenommen, im Laufe der Zeit wurde uns klar, dass unsere API zu einfach und zu begrenzt für die Benutzerfälle unserer Benutzer ist. Daher müssen wir die <code>Hi()</code> Funktion ändern, um die Begrüßungssprache als Parameter zu akzeptieren: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> testmod <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Hi returns a friendly greeting in language lang func Hi(name, lang string) (string, error) { switch lang { case "en": return fmt.Sprintf("Hi, %s!", name), nil case "pt": return fmt.Sprintf("Oi, %s!", name), nil case "es": return fmt.Sprintf("¡Hola, %s!", name), nil case "fr": return fmt.Sprintf("Bonjour, %s!", name), nil default: return "", errors.New("unknown language") } }</span></span></code> </pre> <br><p>  Bestehende Programme, die unsere API verwenden, werden unterbrochen, weil sie a) die Sprache nicht als Parameter übergeben und b) keine Fehlerrückgabe erwarten.  Unsere neue API ist nicht mehr mit Version 1.x kompatibel. Treffen Sie also Version 2.0.0. </p><br><p>  Ich habe bereits erwähnt, dass einige Versionen Funktionen haben, und jetzt ist dies der Fall. <br>  <strong>Version 2 <em>oder höher</em> sollte den Importpfad ändern.</strong>  Nun sind dies verschiedene Bibliotheken. </p><br><p>  Dazu fügen wir dem Namen unseres Moduls einen neuen <em>versionierten Pfad</em> hinzu. </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">github</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">robteix</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testmod</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2</span></span></span></span></code> </pre> <br><p>  Alles andere ist das gleiche: Drücken Sie, setzen Sie ein Etikett, das v2.0.0 ist (und lassen Sie optional einen Zweig v2 durchnässen) </p><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>git commit testmod.go -m <span class="hljs-comment"><span class="hljs-comment">"Change Hi to allow multilang"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git checkout -b v2 # optional but recommended <span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"module github.com/robteix/testmod/v2"</span></span> &gt; go.mod <span class="hljs-string"><span class="hljs-string">$ </span></span>git commit go.mod -m <span class="hljs-comment"><span class="hljs-comment">"Bump version to v2"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git tag v2<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git push --tags origin v2 # or master if we don<span class="hljs-string"><span class="hljs-string">'t have a branch</span></span></code> </pre> <br><h2 id="obnovlenie-mazhornoy-versii">  Hauptversions-Update </h2><br><p>  Obwohl wir eine neue inkompatible Version unserer Bibliothek veröffentlicht haben, sind die vorhandenen Programme <em>nicht kaputt gegangen</em> , da sie weiterhin Version 1.0.1 verwenden. <br>  <code>go get -u</code> <em>wird die</em> Version 2.0.0 <em>nicht</em> herunterladen. </p><br><p>  Aber irgendwann möchte ich als Bibliotheksbenutzer möglicherweise ein Upgrade auf Version 2.0.0 durchführen, da ich beispielsweise einer der Benutzer bin, die Unterstützung für mehrere Sprachen benötigen. </p><br><p>  Zum Aktualisieren muss ich mein Programm entsprechend ändern: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod/v2"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { g, err := testmod.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>, <span class="hljs-string"><span class="hljs-string">"pt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } fmt.Println(g) }</code> </pre> <br><p>  Wenn ich jetzt <code>go build</code> starte, wird es "beendet" und die Version 2.0.0 für mich heruntergeladen.  Beachten Sie, dass Go, obwohl der Importpfad jetzt mit "v2" endet, Go immer noch mit seinem richtigen Namen ("testmod") auf das Modul verweist. </p><br><p>  Wie gesagt, die Hauptversion ist in jeder Hinsicht ein anderes Paket.  Diese beiden Go-Module sind in keiner Weise miteinander verbunden.  Dies bedeutet, dass wir zwei inkompatible Versionen in einer Binärdatei haben können: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod"</span></span> testmodML <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod/v2"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(testmod.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>)) g, err := testmodML.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>, <span class="hljs-string"><span class="hljs-string">"pt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } fmt.Println(g) }</code> </pre> <br><p>  Dadurch wird das häufig auftretende Problem beim Abhängigkeitsmanagement beseitigt, wenn Abhängigkeiten von verschiedenen Versionen derselben Bibliothek abhängen. </p><br><h2 id="navodim-poryadok">  Wir bringen die Dinge in Ordnung </h2><br><p>  Kehren wir zur vorherigen Version zurück, die nur testmod 2.0.0 verwendet. Wenn wir <code>go.mod</code> den Inhalt von <code>go.mod</code> überprüfen, werden wir etwas bemerken: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod/v2 v2<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Standardmäßig entfernt Go Abhängigkeiten nicht aus <code>go.mod</code> bis Sie danach fragen.  Wenn Sie Abhängigkeiten haben, die nicht mehr benötigt werden, und diese bereinigen möchten, können Sie den neuen Befehl <code>tidy</code> : </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> tidy</code> </pre> <br><p>  Jetzt haben wir nur noch die Abhängigkeiten, die wir wirklich verwenden. </p><br><h2 id="vendoring">  Verkauf </h2><br><p>  Go-Module ignorieren standardmäßig den <code>vendor/</code> Verzeichnis.  Die Idee ist, den Verkauf nach und nach loszuwerden <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a></sup> .  Wenn wir jedoch weiterhin die "getrennten" Abhängigkeiten zu unserer Versionskontrolle hinzufügen möchten, können wir dies tun: </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> vendor</code> </pre> <br><p>  Das Team erstellt den <code>vendor/</code> Verzeichnis im Stammverzeichnis unseres Projekts, der den Quellcode aller Abhängigkeiten enthält. </p><br><p>  Beim standardmäßigen <code>go build</code> wird der Inhalt dieses Verzeichnisses jedoch weiterhin ignoriert.  Wenn Sie Abhängigkeiten vom <code>vendor/</code> Verzeichnis erfassen möchten, müssen Sie explizit danach fragen. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> go build <span class="hljs-literal"><span class="hljs-literal">-mod</span></span> vendor</code> </pre> <br><p>  Ich <code>go build</code> davon aus, dass viele Entwickler, die Vending verwenden möchten, wie gewohnt auf ihren Computern bauen und den <code>-mod vendor</code> auf ihrem CI verwenden werden. </p><br><p>  Wiederum entfernen sich Go-Module von der Idee des Verkaufs von Proxys für Module für diejenigen, die nicht direkt von vorgelagerten Versionskontrolldiensten abhängig sein möchten. </p><br><p>  Es gibt Möglichkeiten, um sicherzustellen, dass <code>go</code> Netzwerk nicht verfügbar ist (z. B. mit <code>GOPROXY=off</code> ). Dies ist jedoch das Thema des nächsten Artikels. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Der Artikel mag jemandem kompliziert erscheinen, aber das liegt daran, dass ich versucht habe, viel auf einmal zu erklären.  Die Realität ist, dass Go-Module heutzutage im Allgemeinen einfach sind - wir importieren das Paket wie üblich in unseren Code und das <code>go</code> Team erledigt den Rest für uns.  Abhängigkeiten werden beim Zusammenbau automatisch geladen. </p><br><p>  Die Module machen auch <code>$GOPATH</code> , was ein Stolperstein für neue Go-Entwickler war, die Probleme hatten zu verstehen, warum sie etwas in ein bestimmtes Verzeichnis stellen sollten. </p><br><p><del>  Der Verkauf (inoffiziell) wurde zugunsten der Verwendung eines Proxys abgelehnt. </del>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a></sup> <br>  Ich kann einen separaten Artikel über Proxys für Go-Module verfassen. </p><br><p>  Anmerkungen: </p><br><p>  <sup>1</sup> Ich denke, dies ist ein zu lauter Ausdruck, und einige haben möglicherweise den Eindruck, dass der Verkauf gerade entfernt wird.  Es ist nicht so.  Der Verkauf funktioniert immer noch, wenn auch etwas anders als zuvor.  Anscheinend besteht der Wunsch, den Verkauf durch etwas Besseres zu ersetzen, zum Beispiel einen Proxy (keine Tatsache).  Bisher ist dies einfach das Streben nach einer besseren Lösung.  Der Verkauf wird erst beendet, wenn ein guter Ersatz gefunden wurde (falls vorhanden). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421411/">https://habr.com/ru/post/de421411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421399/index.html">Turla Cybergroup Outlook Backdoor-Analyse</a></li>
<li><a href="../de421401/index.html">Anatomie von Empfehlungssystemen. Teil zwei</a></li>
<li><a href="../de421403/index.html">Sicherheitswoche 32: Fortnite-Android-Drama</a></li>
<li><a href="../de421407/index.html">Technisches Treffen in St. Petersburg 13. September - Wie man große Änderungen am Backend vornimmt</a></li>
<li><a href="../de421409/index.html">Spionage Dinge: Halten Sie ein Geheimnis</a></li>
<li><a href="../de421413/index.html">Richtiger Zugriff auf Standardschnittstellenmethoden durch Reflektion in Java 8, 9, 10</a></li>
<li><a href="../de421415/index.html">Magischer Sprung - trauriger Müll</a></li>
<li><a href="../de421417/index.html">Kaffeemaschine für Kaffeesüchtige oder mobile Wacaco-Kaffeemaschine</a></li>
<li><a href="../de421419/index.html">Ode an „geschäumtes“ Nickel, nicht existierende Saphire und den stellvertretenden sowjetischen Minister: die Ikone OTTO SX-P1 in Japan, den USA und der UdSSR</a></li>
<li><a href="../de421421/index.html">LAppS: Eine halbe Million 1 KB WebSocket-Nachrichten pro Sekunde mit TLS auf einer CPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>