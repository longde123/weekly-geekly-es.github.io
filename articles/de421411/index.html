<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèø üë† üßùüèª Einf√ºhrung in Go-Module üîä ‚è∏Ô∏è ü§ê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die bevorstehende Version 1.11 der Programmiersprache Go bietet experimentelle Unterst√ºtzung f√ºr Module - ein neues Abh√§ngigkeitsmanagementsystem f√ºr ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung in Go-Module</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421411/"><p>  Die bevorstehende Version 1.11 der Programmiersprache Go bietet experimentelle Unterst√ºtzung f√ºr <em>Module</em> - ein neues Abh√§ngigkeitsmanagementsystem f√ºr Go.  (Anmerkung √úbersetzung: <a href="">Ver√∂ffentlichung erfolgte</a> ) </p><br><p>  K√ºrzlich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich bereits einen kleinen Beitrag dazu geschrieben</a> .  Seitdem hat sich etwas leicht ge√§ndert, und wir sind der Ver√∂ffentlichung n√§her gekommen. Daher scheint es mir, dass die Zeit f√ºr einen neuen Artikel gekommen ist - lassen Sie uns mehr √úbung hinzuf√ºgen. </p><br><p>  Also, hier ist, was wir tun werden: Erstellen Sie ein neues Paket und machen Sie dann ein paar Releases, um zu sehen, wie es funktioniert. </p><a name="habracut"></a><br><h2 id="sozdanie-modulya">  Modulerstellung </h2><br><p> Erstellen Sie zun√§chst unser Paket.  Nennen wir es testmod.  Wichtiges Detail: <strong>Das Paketverzeichnis sollte <em>au√üerhalb von</em> <code>$GOPATH</code> , da darin die <code>$GOPATH</code> standardm√§√üig deaktiviert ist</strong> .  Go-Module sind der erste Schritt in Richtung einer vollst√§ndigen Aufgabe von <code>$GOPATH</code> in der Zukunft. </p><br><pre> <code class="hljs dos">$ <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> testmod $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> testmod</code> </pre> <br><p>  Unser Paket ist ganz einfach: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> testmod <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-comment"><span class="hljs-comment">// Hi returns a friendly greeting func Hi(name string) string { return fmt.Sprintf("Hi, %s", name) }</span></span></code> </pre> <br><p>  Das Paket ist fertig, aber noch kein <em>Modul</em> .  Lass es uns reparieren. </p><br><pre> <code class="hljs go">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> mod init github.com/robteix/testmod <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: creating <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>.mod: module github.com/robteix/testmod</code> </pre> <br><p>  Wir haben eine neue Datei namens <code>go.mod</code> im Paketverzeichnis mit folgendem Inhalt: </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">github</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">robteix</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testmod</span></span></span></span></code> </pre> <br><p>  Ein bisschen, aber genau das macht unser Paket zu einem <em>Modul</em> . </p><br><p>  Jetzt k√∂nnen wir diesen Code in das Repository verschieben: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git init <span class="hljs-variable"><span class="hljs-variable">$</span></span> git add * <span class="hljs-variable"><span class="hljs-variable">$</span></span> git commit <span class="hljs-literal"><span class="hljs-literal">-am</span></span> <span class="hljs-string"><span class="hljs-string">"First commit"</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push <span class="hljs-literal"><span class="hljs-literal">-u</span></span> origin master</code> </pre> <br><p>  Bisher w√ºrde sich jeder bewerben <code>go get</code> unser Paket nutzen m√∂chte: </p><br><pre> <code class="hljs swift">$ go <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> github.com/robteix/testmod</code> </pre> <br><p>  Und dieser Befehl w√ºrde den neuesten Code aus dem Hauptzweig bringen.  Diese Option funktioniert immer noch, aber es w√§re besser, wenn wir es nicht mehr tun, denn jetzt "gibt es einen besseren Weg".  Das direkte Entnehmen von Code aus dem Hauptzweig ist in der Tat gef√§hrlich, da wir nie sicher wissen, dass die Autoren des Pakets keine √Ñnderungen vorgenommen haben, die unseren Code ‚Äûbesch√§digen‚Äú.  Um dieses Problem zu l√∂sen, wurden Go-Module erfunden. </p><br><h2 id="nebolshoe-otstuplenie-o-versionirovanii-moduley">  Ein kleiner Exkurs √ºber Versionierungsmodule </h2><br><p>  Go-Module sind versioniert, und es gibt einige Besonderheiten einzelner Versionen.  Sie m√ºssen sich mit den Konzepten vertraut machen, die der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">semantischen Versionierung</a> zugrunde liegen. </p><br><p>  Dar√ºber hinaus verwendet Go bei der Suche nach Versionen Repository-Tags, und einige Versionen unterscheiden sich von den anderen: Beispielsweise m√ºssen Versionen 2 und h√∂her einen anderen Importpfad haben als die Versionen 0 und 1 (wir werden darauf zur√ºckkommen). </p><br><p>  Standardm√§√üig l√§dt Go die neueste <em>Version</em> herunter <em>, f√ºr die ein Tag</em> im Repository verf√ºgbar ist. <br>  Dies ist eine wichtige Funktion, da sie bei der Arbeit mit dem Hauptzweig verwendet werden kann. </p><br><p>  F√ºr uns ist es jetzt wichtig, dass wir beim Erstellen der Version unseres Pakets ein Etikett mit der Version in das Repository einf√ºgen. </p><br><p>  Lass es uns tun. </p><br><h2 id="delaem-svoy-pervyy-reliz">  Machen Sie Ihre erste Ver√∂ffentlichung </h2><br><p>  Unser Paket ist fertig und wir k√∂nnen es auf der ganzen Welt "ausrollen".  Wir tun dies mit versionierten Etiketten.  Die Versionsnummer sei 1.0.0: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git tag v1.<span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push -<span class="hljs-literal"><span class="hljs-literal">-tags</span></span></code> </pre> <br><p>  Diese Befehle erstellen ein Tag in meinem Github-Repository, das das aktuelle Commit als Release 1.0.0 kennzeichnet. </p><br><p>  Go besteht nicht darauf, aber es ist eine gute Idee, einen zus√§tzlichen neuen Zweig ("v1") zu erstellen, an den wir Patches senden k√∂nnen. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git checkout <span class="hljs-literal"><span class="hljs-literal">-b</span></span> v1 <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push <span class="hljs-literal"><span class="hljs-literal">-u</span></span> origin v1</code> </pre> <br><p>  Jetzt k√∂nnen wir in der Hauptniederlassung arbeiten, ohne uns Sorgen machen zu m√ºssen, dass wir unsere Version brechen k√∂nnen. </p><br><h2 id="ispolzovanie-nashego-modulya">  Mit unserem Modul </h2><br><p>  Verwenden wir das erstellte Modul.  Wir werden ein einfaches Programm schreiben, das unser neues Paket importiert: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(testmod.Hi(<span class="hljs-string"><span class="hljs-string">"roberto"</span></span>)) }</code> </pre> <br><p>  Bis jetzt haben Sie <code>go get github.com/robteix/testmod</code> , um das Paket herunterzuladen, aber mit Modulen wird es interessanter.  Zun√§chst m√ºssen wir die Modulunterst√ºtzung in unserem neuen Programm aktivieren. </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> init <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span></code> </pre> <br><p>  Wie Sie wahrscheinlich erwartet haben, wurde basierend auf dem, was Sie zuvor gelesen haben, eine neue <code>go.mod</code> Datei im Verzeichnis mit dem Namen des darin enthaltenen Moduls <code>go.mod</code> : </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mod</span></span></span></span></code> </pre> <br><p>  Die Situation wird noch interessanter, wenn wir versuchen, unser Programm zusammenzustellen: </p><br><pre> <code class="hljs go">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: finding github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: downloading github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Wie Sie sehen k√∂nnen, hat der Befehl <code>go</code> das von unserem Programm importierte Paket automatisch gefunden und heruntergeladen. <br>  Wenn wir unsere <code>go.mod</code> Datei √ºberpr√ºfen, werden wir <code>go.mod</code> , dass sich etwas ge√§ndert hat: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Und wir haben eine weitere neue Datei namens <code>go.sum</code> , die die Hashes der Pakete enth√§lt, um die richtige Version und die richtigen Dateien zu √ºberpr√ºfen. </p><br><pre> <code class="hljs matlab">github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> h1:<span class="hljs-number"><span class="hljs-number">9</span></span>EdH0EArQ/rkpss9Tj8gUnwx3w5p0jkzJrd5tRAhxnA= github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/go.<span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> h1:UVhi5McON9ZLc5kl5iN2bTXlL6ylcxE9VInV71RrlO8=</code> </pre> <br><h2 id="delaem-reliz-reliz-s-ispravleniem-oshibki">  Erstellen einer Version zur Fehlerbehebung </h2><br><p>  Nehmen wir an, wir haben ein Problem in unserem Paket gefunden: Die Begr√º√üung enth√§lt keine Interpunktion! <br>  Einige Leute werden w√ºtend sein, weil unser freundlicher Gru√ü nicht mehr so ‚Äã‚Äãfreundlich ist. <br>  Lassen Sie uns das beheben und eine neue Version ver√∂ffentlichen: </p><br><pre> <code class="hljs pgsql">// Hi <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> a friendly greeting func Hi(<span class="hljs-type"><span class="hljs-type">name</span></span> string) string { - <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf("Hi, %s", <span class="hljs-type"><span class="hljs-type">name</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf("Hi, %s!", <span class="hljs-type"><span class="hljs-type">name</span></span>) }</code> </pre> <br><p>  Wir haben diese √Ñnderung direkt in der <code>v1</code> Verzweigung vorgenommen, da sie nichts mit dem zu tun hat, was wir als n√§chstes in der <code>v2</code> Verzweigung tun werden. Im wirklichen Leben sollten Sie diese √Ñnderungen jedoch m√∂glicherweise am <code>master</code> vornehmen und sie dann auf <code>v1</code> .  In jedem Fall sollte sich das <code>v1</code> Zweig <code>v1</code> und wir m√ºssen dies als neue Version markieren. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git commit <span class="hljs-literal"><span class="hljs-literal">-m</span></span> <span class="hljs-string"><span class="hljs-string">"Emphasize our friendliness"</span></span> testmod.go <span class="hljs-variable"><span class="hljs-variable">$</span></span> git tag v1.<span class="hljs-number"><span class="hljs-number">0.1</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push -<span class="hljs-literal"><span class="hljs-literal">-tags</span></span> origin v1</code> </pre> <br><h2 id="obnovlenie-moduley">  Module aktualisieren </h2><br><p>  Standardm√§√üig aktualisiert Go Module nicht ohne Anforderung.  "Und das ist gut", da wir alle Vorhersehbarkeit in unseren Builds w√ºnschen.  Wenn die Go-Module bei jeder Ver√∂ffentlichung einer neuen Version automatisch aktualisiert w√ºrden, w√ºrden wir zu den "dunklen Zeiten vor Go1.11" zur√ºckkehren.  Aber nein, wir m√ºssen Go <em>mitteilen</em> , dass die Module f√ºr uns aktualisiert werden sollen. </p><br><p>  Und wir werden es mit Hilfe unseres alten Freundes tun - <code>go get</code> : </p><br><ul><li><p>  F√ºhren Sie <code>go get -u</code> , um die letzte <em>Neben- oder Patch-</em> Version zu verwenden (d. h. der Befehl wird von 1.0.0 auf beispielsweise 1.0.1 oder 1.1.0 aktualisiert, wenn eine solche Version verf√ºgbar ist). </p><br></li><li><p>  F√ºhren Sie <code>go get -u=patch</code> , um die neueste Patch-Version zu verwenden (d. h. das Paket wird auf 1.0.1 aktualisiert, jedoch <em>nicht</em> auf 1.1.0). </p><br></li><li><p>  F√ºhren Sie <code>go get package@version</code> , um ein Upgrade auf eine bestimmte Version <code>github.com/robteix/testmod@v1.0.1</code> (z. B. <code>github.com/robteix/testmod@v1.0.1</code> ). </p><br></li></ul><br><p>  In dieser Liste gibt es keine M√∂glichkeit, auf die neueste <em>Hauptversion</em> zu aktualisieren.  Daf√ºr gibt es einen guten Grund, wie wir gleich sehen werden. </p><br><p>  Da unser Programm Version 1.0.0 unseres Pakets verwendet hat und wir gerade Version 1.0.1 erstellt haben, aktualisiert uns <em>jeder</em> der folgenden Befehle auf 1.0.1: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> go get <span class="hljs-literal"><span class="hljs-literal">-u</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> go get <span class="hljs-literal"><span class="hljs-literal">-u</span></span>=patch <span class="hljs-variable"><span class="hljs-variable">$</span></span> go get github.com/robteix/testmod@v1.<span class="hljs-number"><span class="hljs-number">0.1</span></span></code> </pre> <br><p>  Nach dem Start (sagen wir <code>go get -u</code> ) hat sich unser <code>go.mod</code> ge√§ndert: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span></code> </pre> <br><h2 id="mazhornye-versii">  Hauptversion </h2><br><p>  Gem√§√ü der Spezifikation der semantischen Versionierung unterscheidet sich die Hauptversion von der Nebenversion.  Hauptversionen k√∂nnen die Abw√§rtskompatibilit√§t beeintr√§chtigen.  Aus Sicht der Go-Module ist die Hauptversion ein v√∂llig <em>anderes Paket</em> . </p><br><p>  Es mag zun√§chst wild klingen, aber es macht Sinn: Zwei Versionen der Bibliothek, die nicht miteinander kompatibel sind, sind zwei verschiedene Bibliotheken. </p><br><p>  Nehmen wir eine wesentliche √Ñnderung in unserem Paket vor.  Angenommen, im Laufe der Zeit wurde uns klar, dass unsere API zu einfach und zu begrenzt f√ºr die Benutzerf√§lle unserer Benutzer ist. Daher m√ºssen wir die <code>Hi()</code> Funktion √§ndern, um die Begr√º√üungssprache als Parameter zu akzeptieren: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> testmod <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Hi returns a friendly greeting in language lang func Hi(name, lang string) (string, error) { switch lang { case "en": return fmt.Sprintf("Hi, %s!", name), nil case "pt": return fmt.Sprintf("Oi, %s!", name), nil case "es": return fmt.Sprintf("¬°Hola, %s!", name), nil case "fr": return fmt.Sprintf("Bonjour, %s!", name), nil default: return "", errors.New("unknown language") } }</span></span></code> </pre> <br><p>  Bestehende Programme, die unsere API verwenden, werden unterbrochen, weil sie a) die Sprache nicht als Parameter √ºbergeben und b) keine Fehlerr√ºckgabe erwarten.  Unsere neue API ist nicht mehr mit Version 1.x kompatibel. Treffen Sie also Version 2.0.0. </p><br><p>  Ich habe bereits erw√§hnt, dass einige Versionen Funktionen haben, und jetzt ist dies der Fall. <br>  <strong>Version 2 <em>oder h√∂her</em> sollte den Importpfad √§ndern.</strong>  Nun sind dies verschiedene Bibliotheken. </p><br><p>  Dazu f√ºgen wir dem Namen unseres Moduls einen neuen <em>versionierten Pfad</em> hinzu. </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">github</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">robteix</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testmod</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2</span></span></span></span></code> </pre> <br><p>  Alles andere ist das gleiche: Dr√ºcken Sie, setzen Sie ein Etikett, das v2.0.0 ist (und lassen Sie optional einen Zweig v2 durchn√§ssen) </p><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>git commit testmod.go -m <span class="hljs-comment"><span class="hljs-comment">"Change Hi to allow multilang"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git checkout -b v2 # optional but recommended <span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"module github.com/robteix/testmod/v2"</span></span> &gt; go.mod <span class="hljs-string"><span class="hljs-string">$ </span></span>git commit go.mod -m <span class="hljs-comment"><span class="hljs-comment">"Bump version to v2"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git tag v2<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git push --tags origin v2 # or master if we don<span class="hljs-string"><span class="hljs-string">'t have a branch</span></span></code> </pre> <br><h2 id="obnovlenie-mazhornoy-versii">  Hauptversions-Update </h2><br><p>  Obwohl wir eine neue inkompatible Version unserer Bibliothek ver√∂ffentlicht haben, sind die vorhandenen Programme <em>nicht kaputt gegangen</em> , da sie weiterhin Version 1.0.1 verwenden. <br>  <code>go get -u</code> <em>wird die</em> Version 2.0.0 <em>nicht</em> herunterladen. </p><br><p>  Aber irgendwann m√∂chte ich als Bibliotheksbenutzer m√∂glicherweise ein Upgrade auf Version 2.0.0 durchf√ºhren, da ich beispielsweise einer der Benutzer bin, die Unterst√ºtzung f√ºr mehrere Sprachen ben√∂tigen. </p><br><p>  Zum Aktualisieren muss ich mein Programm entsprechend √§ndern: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod/v2"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { g, err := testmod.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>, <span class="hljs-string"><span class="hljs-string">"pt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } fmt.Println(g) }</code> </pre> <br><p>  Wenn ich jetzt <code>go build</code> starte, wird es "beendet" und die Version 2.0.0 f√ºr mich heruntergeladen.  Beachten Sie, dass Go, obwohl der Importpfad jetzt mit "v2" endet, Go immer noch mit seinem richtigen Namen ("testmod") auf das Modul verweist. </p><br><p>  Wie gesagt, die Hauptversion ist in jeder Hinsicht ein anderes Paket.  Diese beiden Go-Module sind in keiner Weise miteinander verbunden.  Dies bedeutet, dass wir zwei inkompatible Versionen in einer Bin√§rdatei haben k√∂nnen: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod"</span></span> testmodML <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod/v2"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(testmod.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>)) g, err := testmodML.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>, <span class="hljs-string"><span class="hljs-string">"pt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } fmt.Println(g) }</code> </pre> <br><p>  Dadurch wird das h√§ufig auftretende Problem beim Abh√§ngigkeitsmanagement beseitigt, wenn Abh√§ngigkeiten von verschiedenen Versionen derselben Bibliothek abh√§ngen. </p><br><h2 id="navodim-poryadok">  Wir bringen die Dinge in Ordnung </h2><br><p>  Kehren wir zur vorherigen Version zur√ºck, die nur testmod 2.0.0 verwendet. Wenn wir <code>go.mod</code> den Inhalt von <code>go.mod</code> √ºberpr√ºfen, werden wir etwas bemerken: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod/v2 v2<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Standardm√§√üig entfernt Go Abh√§ngigkeiten nicht aus <code>go.mod</code> bis Sie danach fragen.  Wenn Sie Abh√§ngigkeiten haben, die nicht mehr ben√∂tigt werden, und diese bereinigen m√∂chten, k√∂nnen Sie den neuen Befehl <code>tidy</code> : </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> tidy</code> </pre> <br><p>  Jetzt haben wir nur noch die Abh√§ngigkeiten, die wir wirklich verwenden. </p><br><h2 id="vendoring">  Verkauf </h2><br><p>  Go-Module ignorieren standardm√§√üig den <code>vendor/</code> Verzeichnis.  Die Idee ist, den Verkauf nach und nach loszuwerden <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a></sup> .  Wenn wir jedoch weiterhin die "getrennten" Abh√§ngigkeiten zu unserer Versionskontrolle hinzuf√ºgen m√∂chten, k√∂nnen wir dies tun: </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> vendor</code> </pre> <br><p>  Das Team erstellt den <code>vendor/</code> Verzeichnis im Stammverzeichnis unseres Projekts, der den Quellcode aller Abh√§ngigkeiten enth√§lt. </p><br><p>  Beim standardm√§√üigen <code>go build</code> wird der Inhalt dieses Verzeichnisses jedoch weiterhin ignoriert.  Wenn Sie Abh√§ngigkeiten vom <code>vendor/</code> Verzeichnis erfassen m√∂chten, m√ºssen Sie explizit danach fragen. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> go build <span class="hljs-literal"><span class="hljs-literal">-mod</span></span> vendor</code> </pre> <br><p>  Ich <code>go build</code> davon aus, dass viele Entwickler, die Vending verwenden m√∂chten, wie gewohnt auf ihren Computern bauen und den <code>-mod vendor</code> auf ihrem CI verwenden werden. </p><br><p>  Wiederum entfernen sich Go-Module von der Idee des Verkaufs von Proxys f√ºr Module f√ºr diejenigen, die nicht direkt von vorgelagerten Versionskontrolldiensten abh√§ngig sein m√∂chten. </p><br><p>  Es gibt M√∂glichkeiten, um sicherzustellen, dass <code>go</code> Netzwerk nicht verf√ºgbar ist (z. B. mit <code>GOPROXY=off</code> ). Dies ist jedoch das Thema des n√§chsten Artikels. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Der Artikel mag jemandem kompliziert erscheinen, aber das liegt daran, dass ich versucht habe, viel auf einmal zu erkl√§ren.  Die Realit√§t ist, dass Go-Module heutzutage im Allgemeinen einfach sind - wir importieren das Paket wie √ºblich in unseren Code und das <code>go</code> Team erledigt den Rest f√ºr uns.  Abh√§ngigkeiten werden beim Zusammenbau automatisch geladen. </p><br><p>  Die Module machen auch <code>$GOPATH</code> , was ein Stolperstein f√ºr neue Go-Entwickler war, die Probleme hatten zu verstehen, warum sie etwas in ein bestimmtes Verzeichnis stellen sollten. </p><br><p><del>  Der Verkauf (inoffiziell) wurde zugunsten der Verwendung eines Proxys abgelehnt. </del>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a></sup> <br>  Ich kann einen separaten Artikel √ºber Proxys f√ºr Go-Module verfassen. </p><br><p>  Anmerkungen: </p><br><p>  <sup>1</sup> Ich denke, dies ist ein zu lauter Ausdruck, und einige haben m√∂glicherweise den Eindruck, dass der Verkauf gerade entfernt wird.  Es ist nicht so.  Der Verkauf funktioniert immer noch, wenn auch etwas anders als zuvor.  Anscheinend besteht der Wunsch, den Verkauf durch etwas Besseres zu ersetzen, zum Beispiel einen Proxy (keine Tatsache).  Bisher ist dies einfach das Streben nach einer besseren L√∂sung.  Der Verkauf wird erst beendet, wenn ein guter Ersatz gefunden wurde (falls vorhanden). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421411/">https://habr.com/ru/post/de421411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421399/index.html">Turla Cybergroup Outlook Backdoor-Analyse</a></li>
<li><a href="../de421401/index.html">Anatomie von Empfehlungssystemen. Teil zwei</a></li>
<li><a href="../de421403/index.html">Sicherheitswoche 32: Fortnite-Android-Drama</a></li>
<li><a href="../de421407/index.html">Technisches Treffen in St. Petersburg 13. September - Wie man gro√üe √Ñnderungen am Backend vornimmt</a></li>
<li><a href="../de421409/index.html">Spionage Dinge: Halten Sie ein Geheimnis</a></li>
<li><a href="../de421413/index.html">Richtiger Zugriff auf Standardschnittstellenmethoden durch Reflektion in Java 8, 9, 10</a></li>
<li><a href="../de421415/index.html">Magischer Sprung - trauriger M√ºll</a></li>
<li><a href="../de421417/index.html">Kaffeemaschine f√ºr Kaffees√ºchtige oder mobile Wacaco-Kaffeemaschine</a></li>
<li><a href="../de421419/index.html">Ode an ‚Äûgesch√§umtes‚Äú Nickel, nicht existierende Saphire und den stellvertretenden sowjetischen Minister: die Ikone OTTO SX-P1 in Japan, den USA und der UdSSR</a></li>
<li><a href="../de421421/index.html">LAppS: Eine halbe Million 1 KB WebSocket-Nachrichten pro Sekunde mit TLS auf einer CPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>