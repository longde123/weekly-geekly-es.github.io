<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüè´ üì† ü§ù garbage.collect () üåí ü§ù üòÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um JavaScript auszuf√ºhren, ben√∂tigt der Browser etwas Speicher, aber irgendwo m√ºssen Sie Objekte, Grundelemente und Funktionen speichern, die f√ºr alle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>garbage.collect ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433318/"> Um JavaScript auszuf√ºhren, ben√∂tigt der Browser etwas Speicher, aber irgendwo m√ºssen Sie Objekte, Grundelemente und Funktionen speichern, die f√ºr alle Benutzeraktionen erstellt wurden.  Daher weist der Browser zuerst die erforderliche Menge an RAM zu, und wenn Objekte nicht verwendet werden, bereinigt er sie unabh√§ngig. <br><br>  Theoretisch klingt es gut.  In der Praxis √∂ffnet der Nutzer 20 Tabs von YouTube, sozialen Netzwerken, liest etwas, funktioniert, der Browser frisst Speicher, wie Hummer H2 - Benzin.  Der M√ºllsammler l√§uft wie dieses Monster mit einem Mopp durch den gesamten Speicher und sorgt f√ºr Verwirrung, alles verlangsamt sich und st√ºrzt ab. <br><br><img src="https://habrastorage.org/webt/uc/vx/ke/ucvxke3xzwiqngna7opkqwllmq4.jpeg"><br><br>  Um zu verhindern, dass solche Situationen auftreten und die Leistung unserer Websites und Anwendungen nicht beeintr√§chtigt wird, sollte der Front-End-Entwickler wissen, wie sich M√ºll auf Anwendungen auswirkt, wie der Browser ihn sammelt und die Speicherbehandlung optimiert und wie sich alles von der harten Realit√§t unterscheidet.  Dies ist nur der Bericht von <strong>Andrei Roenko ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Flapenguin</a> )</strong> auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frontend Conf 2018</a> . <br><br>  Wir verwenden den Garbage Collector (nicht zu Hause - in der Front-End-Entwicklung) jeden Tag, aber wir denken nicht wirklich dar√ºber nach, was es √ºberhaupt ist, was es uns kostet und welche M√∂glichkeiten und Einschr√§nkungen es hat. <br><br><blockquote>  Wenn die Garbage Collection wirklich in JavaScript funktioniert, l√∂schen sich die meisten npm-Module sofort nach der Installation. <br></blockquote><br>  Aber w√§hrend dies nicht so ist, werden wir dar√ºber sprechen, was ist - √ºber das Zusammensetzen unn√∂tiger Objekte. <br><br><a name="habracut"></a><iframe width="560" height="315" src="https://www.youtube.com/embed/tDbRVZqwxn4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√úber den Sprecher</strong> : <strong>Andrei Roenko hat</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Yandex.Map-API entwickelt</a> , ist seit sechs Jahren im Frontend und liebt es, seine eigenen hohen Abstraktionen zu erstellen und von Fremden zu Boden zu gehen. <br><br><h2>  Warum brauchen Sie M√ºllabfuhr? <br></h2><br>  Betrachten Sie das Beispiel von Yandex.Maps.  Yandex.Maps ist ein riesiger und komplexer Dienst, der viel JS und fast alle vorhandenen Browser-APIs verwendet, mit Ausnahme von Multimedia-APIs. Die durchschnittliche Sitzungszeit betr√§gt 5-10 Minuten.  Die F√ºlle an JavaScript erstellt viele Objekte.  Durch Ziehen der Karte, Hinzuf√ºgen von Organisationen, Suchergebnissen und vielen anderen Ereignissen, die jede Sekunde auftreten, wird eine Lawine von Objekten erzeugt.  F√ºgen Sie dieser Reaktion hinzu und Objekte werden noch mehr. <br><br>  JS-Objekte belegen jedoch nur 30‚Äì40 MB auf der Karte.  F√ºr lange Yandex.Maps-Sitzungen und die st√§ndige Zuweisung neuer Objekte reicht dies nicht aus. <br><br><blockquote>  Der Grund f√ºr das geringe Objektvolumen liegt darin, dass sie vom Garbage Collector erfolgreich erfasst und der Speicher wiederverwendet wird. <br></blockquote><br>  Heute werden wir √ºber die M√ºllabfuhr von vier Seiten sprechen: <br><br><ul><li>  <strong>Theorie</strong>  Beginnen wir mit ihr, um dieselbe Sprache zu sprechen und uns zu verstehen. </li><li>  <strong>Harte Realit√§t.</strong>  Letztendlich f√ºhrt der Computer Maschinencode aus, in dem nicht alle uns bekannten Abstraktionen vorhanden sind.  Versuchen wir herauszufinden, wie die Speicherbereinigung auf niedriger Ebene funktioniert. </li><li>  <strong>Browser Realit√§t.</strong>  Lassen Sie uns sehen, wie die Speicherbereinigung in modernen Engines und Browsern implementiert ist und welche Schlussfolgerungen wir daraus ziehen k√∂nnen. </li><li>  <strong>Alltag</strong> - Lassen Sie uns √ºber die praktische Anwendung des im Alltag gewonnenen Wissens sprechen. </li></ul><br>  Alle Aussagen sind mit Beispielen belegt, wie und wie man es nicht macht. <br><br><h2>  Warum das alles wissen? </h2><br>  Die M√ºllabfuhr ist f√ºr uns eine unsichtbare Sache. Wenn Sie jedoch wissen, wie sie angeordnet ist, werden Sie: <br><br><ul><li>  Machen Sie sich ein Bild von dem von Ihnen verwendeten Tool, das f√ºr Ihre Arbeit n√ºtzlich ist. </li><li>  Verstehen Sie, wo bereits ver√∂ffentlichte Anwendungen optimiert werden k√∂nnen und wie Sie zuk√ºnftige Anwendungen so gestalten k√∂nnen, dass sie besser und schneller funktionieren. </li><li>  Wissen, wie man keine h√§ufigen Fehler macht und keine Ressourcen mehr f√ºr nutzlose und sch√§dliche ‚ÄûOptimierungen‚Äú verschwendet. </li></ul><br><h2>  Theorie <br></h2><br>  Joel Spolsky hat einmal gesagt: <br><br><blockquote>  Alle nicht trivialen Abstraktionen sind undicht. <br></blockquote><br>  Der Garbage Collector ist eine gro√üe, nicht triviale Abstraktion, die von allen Seiten gepatcht wird.  Zum Gl√ºck flie√üt es sehr selten. <br><br>  Beginnen wir mit einer Theorie, aber ohne langweilige Definitionen.  Lassen Sie uns die Arbeit des Sammlers am Beispiel von einfachem Code analysieren: <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.Foo = <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span> }; } work(name) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = <span class="hljs-string"><span class="hljs-string">'z'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xy, z); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } };</code> </pre> <br><ul><li>  Der Code enth√§lt eine <strong>Klasse</strong> . </li><li>  Die Klasse hat einen <strong>Konstruktor</strong> . </li><li>  <strong>Die Arbeitsmethode</strong> gibt eine verwandte Funktion zur√ºck. </li><li>  Innerhalb der Funktion werden <strong>diese</strong> und einige Variablen aus dem Abschluss verwendet. </li></ul><br>  Mal sehen, wie sich dieser Code verh√§lt, wenn wir ihn so ausf√ºhren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); <span class="hljs-comment"><span class="hljs-comment">//C   window.worker = foo.work('Brendan Eich'); //     bind,   window.foo = null; //   window.Foo = null; //  ,   -  window.worker(); window.worker = null; //   ,  </span></span></code> </pre><br>  Lassen Sie uns den Code und seine Komponenten genauer analysieren und mit der Klasse beginnen. <br><br><h3>  Klassenerkl√§rung <br></h3><br><img src="https://habrastorage.org/webt/nd/yq/ie/ndyqietonv9ggcg45mvfmwnsyae.png"><br><br>  Wir k√∂nnen davon ausgehen, dass Klassen in ECMAScript 2015 nur syntaktischer Zucker f√ºr Funktionen sind.  Alle Funktionen haben: <br><br><ul><li>  <strong>Funktion. [[Prototyp]]</strong> ist der eigentliche Prototyp der Funktion. </li><li>  <strong>Foo.prototype</strong> ist ein Prototyp f√ºr frisch erstellte Objekte. </li><li>  Foo.prototype hat √ºber das Konstruktorfeld einen Link zur√ºck zum Konstruktor.  Dies ist ein Objekt, daher erbt es von <strong>Object.prototype</strong> . </li><li>  <strong>Die Arbeitsmethode ist eine</strong> separate Funktion, zu der es eine Verkn√ºpfung gibt, √§hnlich wie beim Konstruktor, da beide nur Funktionen sind.  Er kann auch einen Prototyp festlegen und ihn als neu bezeichnen, aber selten verwendet jemand dieses Verhalten. </li></ul><br>  Prototypen nehmen auf der Rennstrecke viel Platz ein. Denken Sie also daran, dass dies der Fall ist, entfernen Sie sie jedoch der Einfachheit halber. <br><br><h3>  Erstellen eines Klassenobjekts <br></h3><br><img src="https://habrastorage.org/webt/f_/ea/5u/f_ea5uuq01wygmqkdfbrj4a8oja.png"><br><br><ul><li>  Wir setzen unsere Klasse in ein Fenster, da Klassen standardm√§√üig nicht dort ankommen. </li><li>  Erstellen Sie ein Klassenobjekt. </li><li>  Durch das Erstellen eines Objekts wird der Prototyp des Klassenobjekts in Foo.prototype automatisch verf√ºgbar gemacht.  Wenn Sie versuchen, die Arbeitsmethode f√ºr ein Objekt aufzurufen, wei√ü es daher, um welche Art von Arbeit es sich handelt. </li><li>  Unser Konstruktor erstellt das Feld <em>x</em> im Objekt aus dem Objekt mit der Zeichenfolge. </li></ul><br>  Folgendes ist passiert: <br><br><img src="https://habrastorage.org/webt/nb/xx/d1/nbxxd11pg7bmutfnn4bqh3_ooxs.png"><br><br>  Die Methode gibt eine gebundene Funktion zur√ºck - dies ist ein solches spezielles "magisches" Objekt in JS, das aus einem gebundenen this und einer Funktion besteht, die aufgerufen werden muss.  Die zugeh√∂rige Funktion hat auch einen Prototyp und einen anderen Prototyp, aber wir sind an der Schlie√üung interessiert.  Gem√§√ü der Spezifikation wird der Verschluss in der Umgebung gespeichert.  H√∂chstwahrscheinlich kennen Sie das Wort Scope besser, aber <strong>in den Spezifikationen wird das Feld als Umgebung bezeichnet</strong> . <br><br><img src="https://habrastorage.org/webt/dv/zu/rn/dvzurne2uerkhr0vqxeahna5cum.png"><br><br>  Die Umgebung speichert einen Verweis auf LexicalEnvironment.  Dies ist ein komplexes Objekt, das komplizierter als auf einer Folie ist und Links zu allem speichert, auf das √ºber eine Funktion zugegriffen werden kann.  Zum Beispiel Fenster, Foo, Name und z.  Es werden auch Links zu dem gespeichert, was Sie nicht explizit verwenden.  Sie k√∂nnen beispielsweise eval verwenden und versehentlich nicht verwendete Objekte verwenden, JS sollte jedoch nicht besch√§digt werden. <br><br>  Also haben wir alle Objekte gebaut und jetzt werden wir alles zerst√∂ren. <br><br><h3>  L√∂schen Sie den Link zum Objekt <br></h3><br>  Beginnen wir mit dem Entfernen des Links zum Objekt. Dieser Link im Diagramm ist rot hervorgehoben. <br><br><img src="https://habrastorage.org/webt/zp/g_/mf/zpg_mfnx7pgoc1q46ruedg5oeve.png"><br><br>  Wir l√∂schen und nichts passiert, weil vom <strong>Fenster</strong> zum Objekt ein Pfad durch die <strong>gebundene</strong> Funktionsfunktion f√ºhrt. <br><br><img src="https://habrastorage.org/webt/_w/lv/v6/_wlvv6dpon2qnjgaukobadopmas.png"><br><br>  Dies bringt uns zu einem typischen Fehler. <br><br><h3>  H√§ufiger Fehler - vergessenes Abonnement <br></h3><br><pre> <code class="javascript hljs">externalElement.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shouldDoSomethingOnClick) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomething(); } })</code> </pre><br>  Tritt auf, wenn Sie sich anmelden: Verwenden Sie <strong>dies</strong> explizit √ºber Bind- oder Pfeilfunktionen.  Verwenden Sie etwas im Verschluss.  Dann vergessen Sie, sich abzumelden, und die Lebensdauer Ihres Objekts oder der in der Schaltung befindlichen Daten entspricht der Lebensdauer eines Abonnements.  Wenn dies beispielsweise ein DOM-Element ist, das Sie nicht ber√ºhren, ist dies h√∂chstwahrscheinlich die Zeit bis zum Ende der Lebensdauer der Seite. <br><br>  Um diese Probleme zu l√∂sen: <br><br><ul><li>  Abbestellen. </li><li>  Denken Sie √ºber die Laufzeit des Abonnements nach und wem geh√∂rt es. </li><li>  Wenn Sie sich aus irgendeinem Grund nicht abmelden k√∂nnen, setzen Sie die Links auf Null (was auch immer = null) oder bereinigen Sie alle Felder des Objekts.  Wenn Ihr Objekt undicht ist, ist es klein und es ist nicht schade. </li><li>  Verwenden Sie WeakMap. Vielleicht hilft dies in einigen Situationen. </li></ul><br><h3>  L√∂schen Sie die Klassenreferenz <br></h3><br>  Fahren Sie fort und versuchen Sie, den durch die Klasse hervorgehobenen roten Link zu entfernen. <br><br><img src="https://habrastorage.org/webt/px/sm/yf/pxsmyfvo0utc5d1wh3rfrqcpmlc.png"><br><br>  Wir l√∂schen den Link und nichts √§ndert sich f√ºr uns.  Der Grund daf√ºr ist, dass auf die Klasse √ºber BoundThis zugegriffen werden kann, in dem eine Verkn√ºpfung zum Prototyp besteht, und dass im Prototyp eine Verkn√ºpfung zum Konstruktor besteht. <br><br><h3>  Typischer <s>Fehler</s> nutzlose Arbeit <br></h3><br>  Warum werden all diese Demonstrationen ben√∂tigt?  Weil das Problem eine Kehrseite hat, wenn Leute den Rat befolgen, Links zu w√∂rtlich zu annullieren und alles im Allgemeinen zu annullieren. <br><br><pre> <code class="javascript hljs">destroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._x = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._y = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  10 this._foobar = null }</span></span></code> </pre><br>  Dies ist ein ziemlich wertloser Job.  Wenn das Objekt nur aus Verweisen auf andere Objekte besteht und dort keine Ressourcen vorhanden sind, wird kein destroy () ben√∂tigt.  Es reicht aus, den Bezug zum Objekt zu verlieren, und er wird von selbst sterben. <br><br>  Es gibt keinen universellen Rat.  Wenn es notwendig ist, annullieren Sie und wenn nicht, nicht annullieren.  Nullstellen ist kein Fehler, sondern einfach nutzlose Arbeit. <br><br>  Mach weiter.  Rufen Sie die gebundene Funktionsmethode auf und sie entfernt den Link von [Objekt Foo] zu [Objekt Objekt].  Dies f√ºhrt dazu, dass Objekte, die in einem blauen Rechteck auseinander liegen, im Diagramm angezeigt werden. <br><br><img src="https://habrastorage.org/webt/zl/ep/xc/zlepxcvklqpricdvth4gxnjp2ny.png"><br><br>  Diese Objekte sind JS-M√ºll.  Er l√§uft gro√üartig.  Es gibt jedoch M√ºll, der nicht gesammelt werden kann. <br><br><h3>  M√ºll, der nicht geht <br></h3><br>  In vielen Browser-APIs k√∂nnen Sie ein Objekt erstellen und zerst√∂ren.  Wenn das Objekt nicht zerst√∂rt wird, kann kein Sammler es zusammenbauen. <br><br>  Objekte mit Funktionen zum Erstellen / L√∂schen von Paaren: <br><br><ul><li>  createObjectURL (), revokeObjectURL (); </li><li>  WebGL: Programm / Shader / Puffer / Textur / etc erstellen / l√∂schen; </li><li>  ImageBitmap.close (); </li><li>  indexDb.close (). </li></ul><br>  Wenn Sie beispielsweise vergessen, ObjectURL aus einem 200-MB-Video zu l√∂schen, bleiben diese 200 MB bis zum Ende der Lebensdauer der Seite und sogar noch l√§nger im Speicher, da zwischen den Registerkarten Daten ausgetauscht werden.  √Ñhnlich in WebGL, indexDb und anderen Browser-APIs mit √§hnlichen Ressourcen. <br><br>  Gl√ºcklicherweise enth√§lt das blaue Rechteck in unserem Beispiel nur JavaScript-Objekte. Dies ist also nur M√ºll, der entfernt werden kann. <br><br>  Der n√§chste Schritt besteht darin, den letzten Link von links nach rechts zu l√∂schen.  Dies ist ein Verweis auf die Methode, die wir erhalten haben, eine verwandte Funktion. <br><br><img src="https://habrastorage.org/webt/5g/k5/h9/5gk5h96gg6zpw4bi64mq1guopom.png"><br><br>  Nach seiner Entfernung haben wir keine Links mehr links und rechts?  Tats√§chlich gibt es noch Links von der Schlie√üung. <br><br><img src="https://habrastorage.org/webt/hy/s0/vy/hys0vysevtslyjbht0gjngdaqaq.png"><br><br>  Es ist wichtig, dass es keine Links von links nach rechts gibt, daher ist alles au√üer Fenster M√ºll und es wird sterben. <br><br>  <strong>Wichtiger Hinweis</strong> : Der M√ºll enth√§lt Zirkelverweise, d. H. Objekte, die aufeinander verweisen.  Das Vorhandensein solcher Links hat keine Auswirkungen, da der Garbage Collector nicht einzelne Objekte, sondern den gesamten M√ºll sammelt. <br><br><img src="https://habrastorage.org/webt/hl/qq/4f/hlqq4fn3nlubl4aefqycqyi4v8u.png"><br><br>  Wir haben uns die Beispiele angesehen und verstehen nun auf einer intuitiven Ebene, was M√ºll ist, aber lassen Sie uns eine vollst√§ndige Definition des Konzepts geben. <br><br><blockquote>  M√ºll ist alles, was kein lebendes Objekt ist. <br></blockquote><br>  Alles wurde sehr klar.  Aber was ist ein lebendes Objekt? <br><br>  <strong>Ein lebendes Objekt ist ein Objekt, das √ºber Links vom Stammobjekt aus erreicht werden kann.</strong> <br><br>  Es erscheinen zwei neue Konzepte: "Links folgen" und "Stammobjekt".  Ein Stammobjekt, das wir bereits kennen, ist window. Beginnen wir also mit den Links. <br><br><h3>  Was bedeutet es, den Links zu folgen? <br></h3><br>  Es gibt viele Objekte, die miteinander in Beziehung stehen und sich aufeinander beziehen.  Wir werden ihnen entlang winken, beginnend mit dem Wurzelobjekt. <br><br>  Wir initialisieren den ersten Schritt und fahren dann mit dem folgenden Algorithmus fort: Nehmen wir an, alles auf dem Wellenkamm sind lebende Objekte und sehen, worauf sie sich beziehen. <br><br><img src="https://habrastorage.org/webt/qd/vc/gv/qdvcgvf0tjyk-i85yx9_yzivgs8.png"><br><br>  Wir initialisieren den ersten Schritt.  Dann werden wir nach dem folgenden Algorithmus handeln: Nehmen wir an, dass alles Gelbe auf dem Wellenkamm lebende Objekte sind, und sehen wir, worauf sie sich beziehen. <br><br>  Worauf sie sich beziehen, werden wir einen neuen Wellenkamm machen: <br><br><img src="https://habrastorage.org/webt/k-/5p/bz/k-5pbzevhodbxxsj1ktayvgio34.png"><br><br>  Fertig und von vorne anfangen: <br><br><ul><li>  Wir beleben wieder. </li><li>  Wir schauen uns an, worauf sie sich beziehen. </li><li>  Erstellen Sie einen neuen Wellenberg, animieren Sie Objekte. </li><li>  Wir schauen uns an, worauf sie sich beziehen. </li></ul><br><img src="https://habrastorage.org/webt/nd/bb/8d/ndbb8dwnwadhclwfucgkozu42ea.png"><br><br>  Wenn wir bemerken, dass ein Pfeil auf ein bereits lebendes Objekt zeigt, tun wir einfach nichts.  Weiter nach dem Algorithmus, bis die zu umlaufenden Objekte ersch√∂pft sind.  Dann sagen wir, dass wir alle lebenden Objekte gefunden haben und alles andere M√ºll ist. <br><br><img src="https://habrastorage.org/webt/pw/ms/6z/pwms6zisv2hasovzir04jtjna0k.png"><br><br>  Dieser Vorgang wird als <strong>Markierung bezeichnet</strong> . <br><br><h3>  Was bedeutet das Stammobjekt? <br></h3><br><br><ul><li>  Fenster </li><li>  Fast alle Browser-APIs. </li><li>  Alles Versprechen. </li><li>  Alles, was in Microtask und Macrotask enthalten ist. </li><li>  Mutationsbeobachter, RAF, Idle-Callbacks.  Alles, was von dem, was in der RAF liegt, erreicht werden kann, kann nicht gel√∂scht werden. Wenn Sie das in der RAF verwendete Objekt l√∂schen, wird wahrscheinlich etwas schief gehen. </li></ul><br>  Die Montage kann jederzeit erfolgen.  Jedes Mal, wenn geschweifte Klammern oder Funktionen angezeigt werden, wird ein neues Objekt erstellt.  M√∂glicherweise ist nicht gen√ºgend Speicher vorhanden, und der Sammler sucht kostenlos nach: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, z</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = {}; <span class="hljs-comment"><span class="hljs-comment">// nomem, run gc D: // ‚Ä¶ } while (whatever()) bar(); }</span></span></code> </pre><br>  In diesem Fall sind die Stammobjekte alles auf dem Aufrufstapel.  Wenn Sie beispielsweise an der Zeile mit X anhalten und l√∂schen, worauf sich Y bezieht, st√ºrzt Ihre Anwendung ab.  JS erlaubt uns solche Frivolit√§ten nicht, daher k√∂nnen Sie kein Objekt aus Y l√∂schen. <br><br>  Wenn der vorherige Teil kompliziert schien, wird es noch schwieriger. <br><br><h2>  Harte Realit√§t <br></h2><br>  Lassen Sie uns √ºber die Welt der Maschinen sprechen, in der wir uns mit Eisen und physischen Medien besch√§ftigen. <br><br>  Speicher ist ein gro√ües Array, in dem nur Zahlen liegen, zum Beispiel: neues Uint32Array (16 * 2 ** 30). <br><br>  Lassen Sie uns Objekte im Speicher erstellen und von links nach rechts hinzuf√ºgen.  Wir schaffen eine, zweite, dritte - sie haben alle unterschiedliche Gr√∂√üen.  Wir setzen Links auf den Weg. <br><img src="https://habrastorage.org/webt/rg/ly/oy/rglyoyk5kjjz0re9ktp1m7r0dtg.png"><br><br>  Beim siebten Objekt ist der Platz beendet, weil wir 2 freie Felder haben, aber wir brauchen 5. <br><br>  Was kann man hier machen?  Die erste Option ist ein Absturz.  Auf dem Hof ‚Äã‚Äãim Jahr 2018 hat jeder die neuesten MacBooks und 16 GB RAM.  Es gibt keine Situationen, in denen es keine Erinnerung gibt! <br><br>  Es ist jedoch eine schlechte Idee, die Dinge laufen zu lassen, da dies im Web zu einem √§hnlichen Bildschirm f√ºhrt: <br><br><img src="https://habrastorage.org/webt/un/lw/gn/unlwgnwcw1-7p5xunjhvo2hfwzg.png"><br><br>  Dies ist nicht das Verhalten, das wir vom Programm erwarten, aber im Allgemeinen ist es g√ºltig.  Es gibt eine Kategorie von Sammlern namens <strong>No-op</strong> . <br><br><h3>  No-Op-Sammler <br></h3><br>  Vorteile: <br><br><ul><li>  Der Sammler ist sehr einfach. </li><li>  Es gibt einfach keine Speicherbereinigung. </li><li>  Sie m√ºssen nicht schreiben oder √ºber das Ged√§chtnis nachdenken. </li></ul><br>  Nachteile: <br><br><ul><li>  Alles f√§llt so, dass es nie wieder steigt. </li></ul><br>  F√ºr das Frontend ist der No-Op-Collector irrelevant, wird aber im Backend verwendet.  Wenn sich beispielsweise mehrere Server hinter den Balancern befinden, erh√§lt die Anwendung 32 GB RAM und wird dann vollst√§ndig beendet.  Es ist einfacher und die Leistung wird nur durch einen einfachen Neustart verbessert, wenn der Speicher knapp wird. <br><br>  Im Web ist das unm√∂glich und Sie m√ºssen es bereinigen. <br><br><h3>  M√ºll suchen und l√∂schen <br></h3><br>  Wir fangen an mit M√ºll zu putzen.  Wir wissen bereits, wie es geht.  M√ºll - Objekte C und F im vorherigen Schema, da Sie sie nicht √ºber die Pfeile vom Stammobjekt aus erreichen k√∂nnen. <br><br>  Wir nehmen diesen M√ºll, f√ºttern ihn dem M√ºllliebhaber und Sie sind fertig. <br><br><img src="https://habrastorage.org/webt/g8/1l/s1/g81ls1ji6sco7buvbftj6xgr714.png"><br><br>  Nach der Reinigung ist das Problem nicht gel√∂st, da L√∂cher im Speicher verbleiben.  Bitte beachten Sie, dass es 7 freie Felder gibt, aber 5 davon k√∂nnen wir immer noch nicht zuweisen.  Es trat eine Fragmentierung auf und die Montage war beendet.  Ein solcher Algorithmus mit L√∂chern hei√üt <strong>Mark and Sweep</strong> . <br><br><h3>  Markieren und fegen <br></h3><br>  Vorteile: <br><br><ul><li>  Ein sehr einfacher Algorithmus.  Eine der ersten, die Sie kennenlernen werden, wenn Sie etwas √ºber Garbage Collector lernen. </li><li>  Es funktioniert proportional zur M√ºllmenge, kommt aber nur zurecht, wenn wenig M√ºll vorhanden ist. </li><li>  Wenn Sie nur lebende Objekte haben, verschwendet er keine Zeit und tut einfach nichts. </li></ul><br>  Nachteile: <br><br><ul><li>  Es erfordert eine komplexe Logik, um nach freiem Speicherplatz zu suchen, denn wenn der Speicher viele L√ºcken aufweist, m√ºssen Sie in jedem Objekt ein Objekt anprobieren, um zu verstehen, ob es passt oder nicht. </li><li>  Fragmente Erinnerung.  Es kann vorkommen, dass bei freien 200 MB der Speicher in kleine Teile aufgeteilt wird und wie im obigen Beispiel kein fester Speicher f√ºr das Objekt vorhanden ist. </li></ul><br>  Wir suchen nach anderen Ideen.  Wenn Sie sich das Bild ansehen und nachdenken, ist der erste Gedanke, alles nach links zu verschieben.  Dann gibt es rechts ein gro√ües und freies St√ºck, in das unser Objekt ruhig passt. <br><br>  Es gibt einen solchen Algorithmus, der als <strong>Mark and Compact bezeichnet wird</strong> . <br><br><h3>  Markieren und kompakt <br></h3><br>  Vorteile: <br><br><ul><li>  Speicher defragmentieren. </li><li>  Es arbeitet proportional zur Anzahl der lebenden Objekte, was bedeutet, dass es verwendet werden kann, wenn praktisch keine Ablagerungen vorhanden sind. </li></ul><br>  Nachteile: <br><br><ul><li>  Schwierig in Arbeit und Umsetzung. </li><li>  Verschiebt Objekte.  Wir haben das Objekt verschoben, kopiert, jetzt befindet es sich an einem anderen Ort und der gesamte Vorgang ist ziemlich teuer. </li><li>  Je nach Implementierung sind 2-3 Durchg√§nge im gesamten Speicher erforderlich - der Algorithmus ist langsam. </li></ul><br>  Hier kommen wir zu einer anderen Idee. <br><br><h3>  Die Speicherbereinigung ist nicht kostenlos <br></h3><br>  In den Hochleistungs-APIs wie WebGL, WebAudio und WebGPU, die sich noch in der Entwicklung befinden, werden Objekte in separaten Phasen erstellt und gel√∂scht.  Diese Spezifikationen sind so geschrieben, dass die Speicherbereinigung nicht durchgef√ºhrt wird.  Au√üerdem gibt es dort nicht einmal Promise, sondern pull () - Sie fragen einfach jeden Frame: "Ist etwas passiert oder nicht?". <br><br><h3>  Semispace aka Lisp 2 <br></h3><br>  Es gibt noch einen anderen Sammler, √ºber den ich sprechen m√∂chte.  Was ist, wenn Sie keinen Speicher freigeben, sondern alle lebenden Objekte an einen anderen Ort kopieren? <br><br>  Versuchen wir, das Stammobjekt "wie es ist" zu kopieren, das irgendwo verweist. <br><br><img src="https://habrastorage.org/webt/oe/ck/uc/oeckucvn6dpbz9hgbg3ykkzmylm.png"><br><br>  Und dann alle anderen. <br><br><img src="https://habrastorage.org/webt/rf/ds/9x/rfds9xc3v1tp6pvlpokawj8pkn0.png"><br><br>  Es gibt keine Ablagerungen oder L√∂cher im Speicher oben.  Alles scheint in Ordnung zu sein, aber es treten zwei Probleme auf: <br><br><ul><li>  Doppelte Objekte - wir haben zwei gr√ºne und zwei blaue Objekte.  Welches verwenden? </li><li>  Verkn√ºpfungen von neuen Objekten f√ºhren zu alten Objekten und nicht zueinander. </li></ul><br>  Mit Links wird alles mit Hilfe einer speziellen algorithmischen ‚ÄûMagie‚Äú gel√∂st, und wir k√∂nnen mit der Duplizierung von Objekten fertig werden, indem wir alles unten l√∂schen. <br><img src="https://habrastorage.org/webt/cq/sr/ur/cqsrurkhqp_b01qsxjhzndggryg.png"><br><br>  Infolgedessen haben wir freien Speicherplatz und nur lebende Objekte in der oben angegebenen normalen Reihenfolge.  Dieser Algorithmus wird als <strong>Semispace</strong> , <strong>Lisp 2</strong> oder einfach als " <strong>Kopiersammler</strong> " bezeichnet. <br><br>  Vorteile: <br><br><ul><li>  Speicher defragmentieren. </li><li>  Einfach. </li><li>  Kann mit einer Bypass-Phase kombiniert werden. </li><li>  Es funktioniert proportional zur Anzahl der lebenden Objekte im Laufe der Zeit. </li><li>  Funktioniert gut, wenn es viel M√ºll gibt.  Wenn Sie 2 GB Speicher und 3 Objekte haben, werden Sie nur 3 Objekte umgehen und die restlichen 2 GB scheinen weg zu sein. </li></ul><br>  Nachteile: <br><br><ul><li>  Doppelter Speicherverbrauch.  Sie verwenden 2 Mal mehr Speicher als n√∂tig. </li><li>  Das Bewegen von Objekten ist ebenfalls keine sehr billige Operation. </li></ul><br><blockquote>  Hinweis: Garbage Collectors k√∂nnen Objekte verschieben. <br></blockquote><br>  Im Web ist dies irrelevant, auf Node.js sogar sehr.  Wenn Sie die Erweiterung in C ++ schreiben, wei√ü die Sprache nichts dar√ºber. Daher gibt es dort doppelte Links, die als handle bezeichnet werden und ungef√§hr so ‚Äã‚Äãaussehen: v8 :: Local &lt;v8 :: String&gt;. <br><br>  Wenn Sie Plugins f√ºr Node.js schreiben, sind die Informationen daher hilfreich. <br><br>  Wir fassen die verschiedenen Algorithmen mit ihren Vor- und Nachteilen in der Tabelle zusammen.  Es hat auch einen Eden-Algorithmus, aber dar√ºber sp√§ter. <br><br><img src="https://habrastorage.org/webt/s9/zm/ec/s9zmecoite95yruxuvtafbzaimy.png"><br><br>  Ich m√∂chte wirklich einen Algorithmus ohne Nachteile, aber das ist nicht.  Deshalb nehmen wir das Beste aus allen Welten: Wir verwenden mehrere Algorithmen gleichzeitig.  In einem Speicher sammeln wir M√ºll mit einem Algorithmus und in einem anderen mit einem anderen Algorithmus. <br><br>  Wie kann man die Wirksamkeit des Algorithmus in einer solchen Situation verstehen? <br><br>  Wir k√∂nnen das Wissen kluger Ehem√§nner aus den 60er Jahren nutzen, die sich alle Programme angesehen und erkannt haben: <br><br><blockquote>  Schwache Generationshypothese: Die meisten Objekte sterben jung. <br></blockquote><br>  Diese wollten sie sagen, dass alle Programme nur M√ºll produzieren.  In dem Versuch, Wissen zu nutzen, werden wir zu dem kommen, was als ‚ÄûVersammlung nach Generationen‚Äú bezeichnet wird. <br><br><h3>  Generationsversammlung <br></h3><br>  Wir schaffen zwei Erinnerungsst√ºcke, die in keiner Weise miteinander verbunden sind: links Eden und rechts Mark and Sweep.  In Eden schaffen wir Objekte.  Viele Objekte. <br><br><img src="https://habrastorage.org/webt/_y/rt/tc/_yrttco6brh1zyz4sqkiuk4wrjo.png"><br><br>  Wenn Eden sagt, dass es voll ist, beginnen wir mit der M√ºllabfuhr.  Wir finden lebende Objekte und kopieren sie an einen anderen Sammler. <br><br><img src="https://habrastorage.org/webt/38/si/a5/38sia5sg1nhfx6elimcuitdpqok.png"><br><br>  Eden selbst ist vollst√§ndig gereinigt und wir k√∂nnen weitere Objekte hinzuf√ºgen. <br><br><img src="https://habrastorage.org/webt/pp/qc/3_/ppqc3_uk1okblort71qjndj7ije.png"><br><br>  Unter Berufung auf die Hypothese von Generationen haben wir entschieden, dass die Objekte c, g, i h√∂chstwahrscheinlich lange leben werden, und Sie k√∂nnen sie seltener auf M√ºll √ºberpr√ºfen.  Wenn Sie diese Hypothese kennen, k√∂nnen Sie Programme schreiben, die den Sammler t√§uschen.  Dies kann getan werden, aber ich rate Ihnen nicht, da dies fast immer zu unerw√ºnschten Wirkungen f√ºhren wird.  Wenn Sie langlebigen M√ºll erstellen, beginnt der Sammler zu glauben, dass er nicht gesammelt werden muss. <br><br>  Ein klassisches Beispiel f√ºr Betrug ist der LRU-Cache.  Ein Objekt liegt lange im Cache, der Sammler betrachtet es und glaubt, dass es es noch nicht sammeln wird, da das Objekt sehr lange leben wird.  Dann gelangt ein neues Objekt in den Cache, und ein gro√ües altes wird herausgeschoben, und es ist nicht mehr m√∂glich, dieses gro√üe Objekt sofort zusammenzusetzen. <br><br>  Wie man jetzt sammelt, wissen wir.  Sprechen Sie dar√ºber, wann Sie abholen m√ºssen. <br><br><h3>  Wann sammeln? <br></h3><br>  Die einfachste Option ist, wenn wir <strong>einfach alles stoppen</strong> , den Build starten und dann die JS-Arbeit erneut starten. <br><br><img src="https://habrastorage.org/webt/e-/1n/od/e-1nodx10w_v6q7x5w7xi9xdfvk.png"><br><br>  In modernen Computern mehr als ein Ausf√ºhrungsthread.  Im Web ist dies den Web Workern bekannt.  Warum nicht <strong>den Montageprozess</strong> √ºbernehmen und <strong>parallelisieren?</strong>  Das gleichzeitige Ausf√ºhren mehrerer kleiner Operationen ist schneller als eine gro√üe. <br><br><img src="https://habrastorage.org/webt/y6/yw/jh/y6ywjhxlis6qhu7kk5cumaruayu.png"><br><br>  Eine andere Idee ist es, sorgf√§ltig eine Momentaufnahme des aktuellen Status zu <strong>erstellen und parallel zu JS zu erstellen</strong> . <br><br><img src="https://habrastorage.org/webt/lm/fd/3w/lmfd3w2kiyhtxlwvp1wtlges6ia.png"><br><br><blockquote>  Wenn Sie dies interessiert, empfehle ich Ihnen zu lesen: <br><br><ul><li>  Das einzige und wichtigste Montagebuch, Garbage Collection Handbook. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> als universelle Ressource. </li><li>  Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">memorymanagement.org.</a> </li><li>  Berichte und Artikel von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexander Shepelev</a> .  Er spricht √ºber Java, aber in Bezug auf M√ºll funktionieren Java und V8 ungef√§hr gleich. </li></ul></blockquote><br><h2>  Browser Realit√§t <br></h2><br>  Kommen wir dazu, wie Browser alles verwenden, wor√ºber wir gesprochen haben. <br><br><h3>  IoT-Engines <br></h3><br>  Beginnen wir nicht mit Browsern, sondern mit Internet of Things-Engines: JerryScript und Duktape.  Sie verwenden Mark'n'sweep und Stop the World-Algorithmen. <br><br>  IoT-Engines arbeiten mit Mikrocontrollern, was bedeutet: Die Sprache ist langsam;  zweite h√§ngt;  Fragmentierung  und das alles f√ºr eine teekanne mit beleuchtung :) <br><br>  Wenn Sie Internet of Things in JavaScript schreiben, sagen Sie es uns in den Kommentaren?  Gibt es irgendeinen Punkt? <br><br>  Wir lassen IoT-Engines in Ruhe und interessieren uns f√ºr: <br><br><ul><li>  V8. </li><li>  SpiderMonkey  Tats√§chlich hat er kein Logo.  Selbstgemachtes Logo :) </li><li>  Von WebKit verwendeter JavaScriptCore. </li><li>  ChakraCore, der in Edge verwendet wird. </li></ul><br><img src="https://habrastorage.org/webt/vw/0q/nj/vw0qnjkmktvnd2z0_dhrvkw4y_u.png"><br><br>  Alle Motoren sind ungef√§hr gleich, daher werden wir √ºber V8 als den bekanntesten sprechen. <br><br><h3>  V8 <br></h3><br><ul><li>  Fast alles serverseitige JavaScript, weil es Node.js ist. </li><li>  Fast 80% des clientseitigen JavaScript. </li><li>  Die geselligsten Entwickler, es gibt viele Informationen und gute Quellcodes, die am einfachsten zu lesen sind. </li></ul><br>  Der V8 verwendet Generationsassemblierung. <br><img src="https://habrastorage.org/webt/u-/-7/r4/u--7r4ggek0kxgpscwhtzn8grfe.png"><br><br>  Der einzige Unterschied ist, dass wir fr√ºher zwei Sammler hatten und jetzt drei: <br><br><ul><li>  In Eden wird ein Objekt erstellt. </li><li>  Irgendwann in Eden gibt es zu viel M√ºll und das Objekt wird in Semispace √ºbertragen. </li><li>  Das Objekt ist jung und wenn der Sammler feststellt, dass es zu alt und langweilig ist, wirft es es in Mark and Sweep, in dem die M√ºllabfuhr √§u√üerst selten ist. </li></ul><br>  Sie k√∂nnen deutlich sehen, wie es auf der <strong>Speicherspur</strong> aussieht. <br><br><img src="https://habrastorage.org/webt/c7/s1/av/c7s1avnfboc9c57khyjw5xqjybm.png"><br><br>  Es fallen mehrere gro√üe Wellen mit kleinen Wellen auf.  Kleine sind kleine Baugruppen, und gro√üe sind gro√üe. <br><br>  Der Sinn unserer Existenz besteht nach der Generationshypothese darin, M√ºll zu erzeugen. Der n√§chste Fehler ist also die Angst, M√ºll zu erzeugen. <br><br><blockquote>  Papierkorb kann erstellt werden, wenn es sich wirklich um Papierkorb handelt.   ,         ,     ,    . <br></blockquote><br><h4>  mark <br></h4><br>    V8     . <br><img src="https://habrastorage.org/webt/40/dg/j5/40dgj5iiquv7dsag0mndget4s30.png"><br><br>     Stop the world,        ,       JS,        . <br><br><h4>     ? <br></h4><br>  1  3%,    . <br><br>  3% = 1/33     GameDev.  GameDev 3%  1 ,    .   GameDev     . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pool = [<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bullet(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bullet(), <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFromPool</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bullet = pool.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> !x.inUse); bullet.isUse = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bullet; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returnToPool</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bullet</span></span></span><span class="hljs-function">) </span></span>{ bullet.inUse = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Frame const bullet = getFromPool(); // ... returnToPool(bullet);</span></span></code> </pre><br>     , , 10 000        . <br><br>    ‚Äî    .          ,         .      ,     . <br><br><h3>   : Chromium <br></h3><br>      , ,  ,   Chromium. <br><br><pre> <code class="javascript hljs">&gt; performance.memory MemoryInfo { <span class="hljs-attr"><span class="hljs-attr">totalJSHeapSize</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span>, <span class="hljs-attr"><span class="hljs-attr">usedJSHeapSize</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span>, <span class="hljs-attr"><span class="hljs-attr">jsHeapSizeLimit</span></span>: <span class="hljs-number"><span class="hljs-number">2330000000</span></span> }</code> </pre><br>  Chromium  <strong>performance.memory</strong>   ,       ,      Chromium  . <br><br> <strong>:</strong> Chromium   2    JavaScript. <br><br>  ,           . <br><br><h3>   : Node <br></h3><br>  Node.js    <strong>process.memoryUsage</strong> ,      . <br><br><pre> <code class="javascript hljs">&gt; process.memoryUsage() { <span class="hljs-attr"><span class="hljs-attr">rss</span></span>: <span class="hljs-number"><span class="hljs-number">22839296</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapTotal</span></span>: <span class="hljs-number"><span class="hljs-number">10207232</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapUsed</span></span>: <span class="hljs-number"><span class="hljs-number">5967968</span></span>, <span class="hljs-attr"><span class="hljs-attr">external</span></span>: <span class="hljs-number"><span class="hljs-number">12829</span></span> }</code> </pre><br> ,  -         ,    .          .     . <br><br><h3>  Die Zukunft <br></h3><br> <strong> </strong> ‚Äî    ,         .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">proposal</a> ,      . <br><br>    Node.js,    c <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">node-weak</a>   , ,  . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cached = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeakRef(myJson); <span class="hljs-comment"><span class="hljs-comment">// 2   let json = cached.deref(); if (!json) { json = await fetchAgain(); }</span></span></code> </pre><br>     , ,    -  JS.         ,      ,      ,    . <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  WebAssembly</a> ,    .   ,              ,     ,      . <br><br><blockquote>     :  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">v8.dev</a>    JS. <br></blockquote><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/v8/v8/tree/7.0.237/src/heap</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/servo/mozjs/blob/master/mozjs/js/src/gc/</a> </li><li> <a href="">github.com/WebKit/webkit/.../JavaScriptCore/heap/MarkedSpace.cpp</a> </li><li> <a href="">github.com/Microsoft/ChakraCore/.../HeapAllocator.cpp</a> </li><li> <a href="">github.com/svaarala/duktape/.../duk_heap_markandsweep.c</a> </li><li> <a href="">github.com/jerryscript-project/jerryscript/.../ecma-gc.c</a> </li></ul><br>        ? <br><br><h2>  Tagesablauf <br></h2><br>    DevTools    : <strong>Performance</strong>  <strong>Memory</strong> .     Chromium,     ,   Firefox  Safari  . <br><br><h3>  Performance <br></h3><br>   Trace,   ¬´Memory¬ª    Performance,    JS     . <br><br><img src="https://habrastorage.org/webt/vm/8b/hn/vm8bhnnurkvza6cquinxa61ema8.png"><br><br>     JS      V8     ,   .     .  ,  GC    30   1200  JS,   1/40. <br><br><h3>  Memory <br></h3><br>          . <br><br><img src="https://habrastorage.org/webt/1i/cl/br/1iclbrk21tcz3lmj472ukb5jwqc.png"><br><br>    . <br><br><img src="https://habrastorage.org/webt/fy/6i/0v/fy6i0v3tu6yq2onfzuz7ma7moks.png"><br><br>     ,           .    , ,  ,  V8   ,      .     ,     . <br><br> , ,  Q (   compiled code) ‚Äî  React    .   ,   ? <br><br>    ,     ,             ,    . <br><br>     ,    . <br><br><img src="https://habrastorage.org/webt/-3/z_/si/-3z_si-wvtfdlbz87myro38qz1s.png"><br><br>     ,     ,   ,         .   ,    ‚Äî  4     .  ,  . <br><br><img src="https://habrastorage.org/webt/pr/un/bt/prunbtssbfjjsklugfzwp2mv778.png"><br><br>      React,       - :         . ,   JSX. <br><br>  Performance  Memory   ,   : <br><br><ul><li>  Chromium: about:tracing. </li><li>  Firefox: about:memory  about:performance,    . </li><li>   Node ‚Äî trace-gc, ‚Äîexpose-gc, require('trace_events').  trace_events    . </li></ul><br><h2>  Zusammenfassung <br></h2><br><ul><li>   ,    ,    ,   . </li><li>                . </li><li>    .   ,      ? </li><li>   ,       -        . </li><li>     SPA,     ,    1       ,   . </li><li>   ,       -   . </li></ul><br>    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">flapenguin.me</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> . <br><br><blockquote>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  -</a>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">++</a> .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong></strong></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>YouTube-</strong> <br></a> . <br><br>     ,     2018 ,     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frontend Conf</a> 2018. <br><br>     ,   :) <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433318/">https://habr.com/ru/post/de433318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433302/index.html">Erste Schritte f√ºr Rust</a></li>
<li><a href="../de433304/index.html">Lastpr√ºfung mit Heuschrecke. Teil 3</a></li>
<li><a href="../de433306/index.html">Visual Studio 2019</a></li>
<li><a href="../de433308/index.html">√úbertragen der PBX-Konfiguration an den 3CX PBX Express-Dienst</a></li>
<li><a href="../de433316/index.html">Design Digest: Onboarding, Feedback, Suche nach Ideen und Entscheidungsfindung</a></li>
<li><a href="../de433320/index.html">Rasterlayout als Basis moderner Layouts</a></li>
<li><a href="../de433322/index.html">JSON API - wir arbeiten gem√§√ü der Spezifikation</a></li>
<li><a href="../de433324/index.html">Mit Webpack das Traumb√ºndel sammeln</a></li>
<li><a href="../de433326/index.html">Codequalit√§t</a></li>
<li><a href="../de433328/index.html">Besser einen Tag verlieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>