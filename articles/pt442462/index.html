<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆 👨‍👦 🎲 Erros típicos ao trabalhar com o PostgreSQL. Parte 1 🚶🏿 ⚾️ 👰🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Há pouco mais de um mês, em Moscou, foi realizada a maior conferência da comunidade pós-gree PGConf.Russia 2019, que reuniu mais de 700 pessoas na Uni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erros típicos ao trabalhar com o PostgreSQL. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/442462/"> Há pouco mais de um mês, em Moscou, foi realizada a maior conferência da comunidade pós-gree PGConf.Russia 2019, que reuniu mais de 700 pessoas na Universidade Estadual de Moscou.  Decidimos postar um vídeo e uma transcrição dos melhores relatórios.  <b>A apresentação de Ivan Frolkov sobre erros típicos ao trabalhar com o PostgreSQL</b> foi apontada como a melhor da conferência, então vamos começar com ela. <br><br>  Por conveniência, dividimos a descriptografia em duas partes.  Neste artigo, falaremos sobre nomes inconsistentes, restrições, sobre onde é melhor concentrar a lógica - no banco de dados ou no aplicativo.  A segunda parte tratará do tratamento de erros, acesso simultâneo, operações não canceláveis, CTE e JSON. <br><br><img src="https://habrastorage.org/webt/f7/ro/mc/f7romcfk7jnjqrlwyalubebwxbo.jpeg"><br><br>  Em nossa empresa, estou envolvido no suporte ao cliente em questões relacionadas a aplicativos, ou seja, ajudo em casos de problemas com conexões, otimização de consultas e outras coisas semelhantes.  Já vi muitas das mais diversas aplicações.  O que eu simplesmente não vi!  Talvez até mais do que gostaríamos.  Parte do que vou dizer se aplica não apenas ao PostgreSQL, mas a qualquer banco de dados, mas algo principalmente ao PostgreSQL. <br><br>  A principal conclusão que pude tirar do que vi foi bastante inesperada: de fato, qualquer aplicativo com a devida persistência pode ser feito para funcionar.  Havia um projeto maravilhoso (não posso mencionar todas as empresas com as quais trabalhamos) em que um aplicativo ainda mais maravilhoso criava tabelas por milhões.  Era assim: na segunda-feira, o sistema funciona bem e na sexta-feira praticamente não funciona.  Nos fins de semana, eles lançam o VACUUM FULL, e na segunda-feira funciona novamente.  Acontece que você pode zombar do PostgreSQL assim, e tudo isso permanecerá e funcionará por algum tempo.  Outro camarada fez uma coisa estranha: tudo foi construído sobre ele, não havia procedimentos.  Ou seja, a maioria das tabelas não pode ser tocada, algo não pode ser feito, mas essa base também viveu. <br><a name="habracut"></a><br>  Ele explicou da seguinte maneira: “a base passa de um estado consistente para outro consistente.  Se eu voltar a carregar os dados, eles serão quebrados.  Mas como tenho gatilhos e uma chave exclusiva, não posso rever os dados. ”  A abordagem é selvagem, mas ao mesmo tempo faz algum sentido.  Talvez fosse necessário fazer diferente, mas também é necessário levar em consideração os recursos dos clientes.  O primeiro erro que falarei é: <br><br><img src="https://habrastorage.org/webt/4p/lf/qc/4plfqce37dhhwayo5nbkpl1uxxa.jpeg"><br><br>  Aqui está um exemplo real que me deparei.  No slide, você vê como a mesma entidade foi nomeada em colunas diferentes.  Pode-se também com espaços.  Outros objetos também foram nomeados inconsistentemente.  Se você precisar pegar algo em outra tabela, precisará ver como é chamado lá. É o mesmo.  Se você tiver id_user e user_id na mesma tabela, o trabalho começará com a pesquisa: o que tudo isso significaria. <br><br>  Para outros clientes, todos os objetos foram nomeados assim: duas letras e cinco dígitos.  Devo dizer que não era "1C".  Por que eles fizeram isso - não sei: não havia lógica nisso, mas é da minha conta otimizar as consultas. <br><br>  Outro exemplo: parte dos nomes em russo, parte em não russo, mas com algum tipo de sotaque russo.  Isso dificulta o entendimento e cria novos erros.  Eu mesmo tento nomear as colunas como se estivesse contando com um serviço, qual desses nomes de colunas criará automaticamente nomes de colunas normais em algum relatório.  Na vida real, infelizmente, não é muito bem-sucedido nomear de forma consistente - incluindo a minha.  Isso é especialmente difícil com o desenvolvimento coletivo.  Mas devemos nos esforçar. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/sdVfBkoz_Fc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Outro motivo importante para nomear sequencialmente: nomes de objetos estão disponíveis através de solicitações de metadados, ou seja, nomes também são dados.  Você poderá escrever uma solicitação e selecionar, por exemplo, todas as fotos - em geral, todas as fotos - no banco de dados. <br><br><img src="https://habrastorage.org/webt/0j/lj/2f/0jlj2fncre7udyrknycske7s8iw.jpeg"><br><br>  Metadados claros são muito convenientes.  Especialmente quando você considera os problemas típicos da documentação - e, na minha experiência, a documentação geralmente está ausente, incompleta ou incorreta, ou ambas: porque a tarefa de escrever boa documentação é comparável em complexidade à tarefa de escrever o próprio código.  Portanto, é melhor quando o código é auto-documentado.  E uma nomeação lógica e consistente de objetos contribui para isso e, quando algo não está claro, você precisa escrever um código de trecho e observar como ele funciona.  Uma vez que não é nada, dois nada, mas quando você faz o dia todo, é exaustivo. <br><br><img src="https://habrastorage.org/webt/10/zm/0k/10zm0kofn31dedkjwo8chc_ckp4.jpeg"><br><br>  O caso real: uma organização muito séria com a qual trabalhamos tinha um fluxo de trabalho básico no Oracle.  Nós o mudamos para o Postgres.  Um dos termos do contrato era a imposição de CHAVES ESTRANGEIRAS.  Eles não estavam lá e, infelizmente, não fomos capazes de impor: as tabelas tinham muitas linhas "deixadas" e ninguém sabe o que fazer com elas, incluindo o cliente. <br><br>  Quando você não precisa olhar as barras de progresso, mas trabalha com documentos para pagar, a situação é triste.  Ajuda muito quando, de acordo com o contrato, o programador paga pelos erros, e é desejável que as quantias sejam grandes - então a iluminação ocorre em minutos, provavelmente quinze.  As restrições aparecem imediatamente, imediatamente tudo começa a ser verificado. <br><br>  Você nem imagina (bem, talvez alguém já imagine) como é mais conveniente lidar com o caso quando o pagamento falhou, do que quando foi aprovado, mas não lá.  Especialmente se a quantidade for grande.  Isto é da experiência pessoal. <br><br><img src="https://habrastorage.org/webt/iz/iz/ng/izizngxvaxznqqn2xbc0alnxddq.jpeg"><br><br>  Por outro lado, pode-se ouvir com frequência que a restrição reduz o desempenho.  Sim, eles têm, mas se você deseja ter os dados corretos, simplesmente não há outras opções para você.  Se você possui um aplicativo que leva em conta o número de visitas à loja pelos clientes, pode haver imprecisões que não afetarão as estatísticas, especialmente, e se contarmos com dinheiro, serão necessárias restrições. <br><br>  Os nomes de restrições geralmente são gerados por um ORM ou sistema, e geralmente ninguém se incomoda especificamente em nomear restrições - mas em vão!  Quando você continuar processando o erro, em seguida, pelo nome da restrição, poderá dar uma mensagem clara ao usuário, classificar o erro e informar se você deve tentar executar a operação novamente ou se essa operação não é mais necessária ou simplesmente não pode ser repetida. <br><br>  Outra coisa que eu não vi, mas que eu recomendo: para todas as operações importantes de auditoria financeira (e não apenas financeira), deve haver pelo menos duas.  O fato é que, mais cedo ou mais tarde, você entrará em algo para alterar o código, e pode muito bem ser que você quebre uma das verificações.  Então o segundo vai te salvar.  Se você faz três, também não é ruim. <br><br><img src="https://habrastorage.org/webt/e1/qz/8a/e1qz8aawn39pl2koidzfe2ducvo.jpeg"><br><br>  Muitas vezes surge a questão: onde verificar a correção dos dados.  No cliente ou no servidor?  Na minha opinião, é óbvio que você precisa verificar lá e ali.  Você tem um erro no cliente, então o servidor não está <br>  sentirá falta ou você tiver um erro no servidor, pelo menos o cliente ajudará a rastreá-lo.  A questão é um tanto discutível, e passamos suavemente ao tópico: onde manter a lógica básica: no aplicativo ou no banco de dados? <br><br>  É conveniente no banco de dados porque, na minha experiência, uma empresa emite regularmente alterações urgentes: remova ou insira isto e aquilo neste exato momento.  Se você tiver lógica no código compilado, precisará coletar, implantar e ver o que aconteceu.  Muitas vezes isso é simplesmente impossível.  No banco de dados, isso é mais conveniente.  Mas existe um aforismo bem conhecido: programadores experientes do Fortran escrevem no Fortran em qualquer idioma.  Cerca de 80 códigos de servidor são escritos em um estilo completamente processual: temos a função "get_user ()" e retorna o tipo "user" e, se "get_list_users ()", retorna uma matriz de "users".  É realmente mais conveniente escrever essas coisas em Java do que em SQL ou pgsql. <br><br><img src="https://habrastorage.org/webt/6w/hw/nz/6whwnz-4moi5mhyce4v3b0ez5fy.jpeg"><br><br>  Por outro lado: por que você precisa da função "get_user ()"?  Você apenas o leva em uma tabela ou em uma exibição.  Como você possui um banco de dados relacional, precisa escrever, como me parece, relacional.  É importante, em primeiro lugar, determinar claramente com quais dados estamos trabalhando: se nossos dados são lixo ou meio lixo, o resultado será apropriado e provavelmente não deve ser eliminado.  Se os dados são importantes para nós, se são dinheiro, propriedade ou operações legais, então são necessárias restrições e quanto mais, melhor.  Repito: é melhor não executar a operação do que executá-la incorretamente.  E não escreva código de procedimento em um banco de dados relacional: você se arrependerá muito. <br><br><img src="https://habrastorage.org/webt/6-/gb/me/6-gbmeqxsupjei79il3wrnp_jts.jpeg"><br><br>  Vi uma tabela com 30 mil linhas (produtos), na qual a solicitação "mostrar uma lista de mercadorias relevantes" foi executada por cerca de um segundo.  Aparentemente, eles conseguiram criar um esquema de banco de dados "bonito e complexo".  Pessoalmente, acho que se você está fazendo algo muito complicado, provavelmente está fazendo algo errado ou realmente tem uma tarefa muito, muito difícil.  Se você possui algum tipo de loja ou aplicativo regular para pessoas da contabilidade, é improvável que haja relacionamentos muito complexos entre entidades. <br><br>  Quando iniciei minha carreira profissional, a tabela em um arquivo DBF de 60 megabytes no sistema bancário parecia muito grande e agora 60 megabytes não são nada - hardware é melhor, software é melhor, tudo funciona mais rápido, mas a pergunta permanece: onde você consegue tanto dados?  Bases muito grandes e inchadas geralmente se tornam assim devido a arquivos.  Em qualquer DBMS e no PostgreSQL, muito esforço foi gasto para garantir uma operação competitiva consistente dos aplicativos.  O arquivo provavelmente não muda, e a maioria dos recursos do DBMS para trabalhar com ele não é necessária.  Vale a pena pensar em retirá-lo do DBMS. <br><br><img src="https://habrastorage.org/webt/oa/sb/yr/oasbyrwvfcu8t8marxk3nx5xj98.jpeg"><br><br>  De vez em quando, com uma espécie de estrabismo do comissário, eles fazem a pergunta: o PostgreSQL fará uma base desse e daquele volume?  Mas aqui a pergunta em si é estranha: você pode colocar os dados no banco de dados o quanto quiser, desde que haja espaço em disco suficiente e muito ficará.  A questão é, por exemplo, como fazer backup de arquivos em petabytes, onde você coloca o backup completo e quanto será retirado.  Eu suspeito fortemente que pelo menos parcialmente esses requisitos de volume estejam relacionados ao desejo dos vendedores de equipamentos de vender mais. <br><br>  Se você armazena documentos no banco de dados, é improvável que os processe lá: a planilha do Excel pode, é claro, ser modificada no servidor, mas essa é uma ocupação estranha.  Muito provavelmente, esses arquivos geralmente serão apenas de leitura.  É melhor armazenar links para documentos e eles mesmos em algum armazenamento externo.  No final, você pode manter a assinatura digital da tabela - para que ela não seja alterada (se você decidir as questões legislativas relevantes). <br><br>  Outra observação: se você não tem um negócio mega-mega, não algum tipo, digamos, de uma empresa federal, é improvável que tenha uma base muito grande.  Se você não armazenar vídeo nele, é claro. <br><br><img src="https://habrastorage.org/webt/3c/ek/sv/3ceksvarvtdlaeb86hoycymgguu.jpeg"><br><br>  Outro motivo pelo qual o banco de dados é grande são os índices desnecessários.  Bases sem índices que não encontrei, mas muitas vezes encontrei bases em que vários índices nas mesmas colunas na mesma ordem.  A base permite que você faça isso.  Ao criar um índice, verifique se ele duplica um existente.  Para ver quais índices não são necessários, consulte pg_stat_user_indexes para ver com que intensidade o índice é usado.  Talvez ele não seja necessário. <br><br>  Me deparei com uma situação (a propósito, típica), quando uma tabela muito grande não é particionada.  Em todos os DBMSs, as tabelas grandes são melhor particionadas, mas no PostgreSQL isso é especialmente verdade devido ao nosso amado VACUUM.  Eu recomendaria particionar tabelas começando provavelmente com 100 gigabytes.  Talvez a partir dos 50 anos. Vi tabelas de terabytes não particionadas e elas viviam, no entanto, em SSDs.  Mas isso é um pouco demais, seria melhor cortá-los. <br><br><img src="https://habrastorage.org/webt/yf/lo/ug/yflougupmnnaudv4i823izyewmu.jpeg"><br><br>  E mais uma observação: quase todos os bancos de dados de um grande volume são apenas arquivos anexados.  Dados dinâmicos e alterados raramente são encontrados nesses bancos de dados.  Um determinante do que você tem - se o arquivo estiver arquivado, você poderá pensar em como levá-lo a algum lugar.  E, a propósito, você pode fornecer acesso a ele a partir do banco de dados.  Então o aplicativo não precisa ser alterado: nada mudará para ele. <br><br>  Algumas dessas observações são da categoria "é melhor ser rico e saudável do que pobre e doente".  Muitas vezes, em primeiro lugar, há código legado.  Em segundo lugar, algo inesperado aconteceu, eles não pensaram em algo e acontece que nem tudo é tão bonito quanto gostaríamos.  Mas, no entanto: não seja muito inteligente.  Lembre-se de que, se você é muito inteligente, provavelmente está fazendo algo errado. <br><br>  <i>[Para ser continuado.]</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt442462/">https://habr.com/ru/post/pt442462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt442452/index.html">Como efetuar login no NodeJS para que os meninos no quintal respeitem</a></li>
<li><a href="../pt442454/index.html">Magic Leap planeja complementar o mundo real com camadas digitais</a></li>
<li><a href="../pt442456/index.html">Como economizar recursos no navegador e não quebrar a web. Relatório Yandex</a></li>
<li><a href="../pt442458/index.html">Abismo ou caminho artificial desde um piloto de RPA até a implementação em toda a empresa</a></li>
<li><a href="../pt442460/index.html">Ajudando o Queryable Provider a classificar seqüências de caracteres interpoladas</a></li>
<li><a href="../pt442464/index.html">Como o "dragão" tripulado cresceu</a></li>
<li><a href="../pt442466/index.html">Como promover um jogo incremental? Grátis, rápido e eficiente *</a></li>
<li><a href="../pt442468/index.html">Em um experimento único, os ratos receberam visão infravermelha</a></li>
<li><a href="../pt442470/index.html">Frontend Weekly Digest (25 de fevereiro a 3 de março de 2019)</a></li>
<li><a href="../pt442472/index.html">O resumo de materiais frescos do mundo do front-end da última semana n ° 354 (25 de fevereiro a 3 de março de 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>