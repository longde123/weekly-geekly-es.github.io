<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👩🏾 🦏 🤶🏽 在Swift中编写网络层：面向协议的方法 🏵️ 📡 🐙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="现在，几乎100％的应用程序都使用网络，因此每个人都面对网络层的组织和使用。 解决此问题的方法主要有两种，要么使用第三方库，要么使用您自己的网络层实现。 在本文中，我们将考虑第二个选项，并尝试使用该语言的所有最新功能，使用协议和枚举来实现网络层。 这将以其他库的形式保存项目，避免不必要的依赖。 曾经...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Swift中编写网络层：面向协议的方法</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443514/"><img src="https://habrastorage.org/webt/gg/rb/pk/ggrbpkas55pf0eigg33hin46i0g.png"><br><br> 现在，几乎100％的应用程序都使用网络，因此每个人都面对网络层的组织和使用。 解决此问题的方法主要有两种，要么使用第三方库，要么使用您自己的网络层实现。 在本文中，我们将考虑第二个选项，并尝试使用该语言的所有最新功能，使用协议和枚举来实现网络层。 这将以其他库的形式保存项目，避免不必要的依赖。 曾经看过Moya的人会立即意识到实现和使用过程中的许多类似细节，只是这次，我们将自己动手做，而无需接触Moya和Alamofire。 <br><a name="habracut"></a><br><br> 在本指南中，我们将研究如何在不使用任何第三方库的情况下在纯Swift上实现网络层。 阅读本文后，您的代码将变为 <br><br><ul><li> 面向协议 </li><li> 使用方便 </li><li> 使用方便 </li><li> 输入安全 </li><li> 对于端点，将使用枚举 </li></ul><br><br> 以下示例说明了网络层实现后的使用情况： <br><br><img src="https://habrastorage.org/webt/zg/f5/jy/zgf5jybl_jika5ljlt-h3pcdg1e.png"><br><br> 通过简单地编写<i><b>router.request（。</b></i>并使用枚举的所有功能，我们将看到所有可能的查询选项及其参数。 <br><br>  <b>首先，关于项目的结构</b> <br><br> 每当您创建新内容时，为了将来能够轻松理解所有内容，正确组织和组织所有内容非常重要。 我相信正确组织的文件夹结构是构建应用程序体系结构时的重要细节。 为了使所有内容正确地排列在文件夹中，让我们提前创建它们。 这看起来像项目中的常规文件夹结构： <br><br><img src="https://habrastorage.org/webt/vw/fz/y0/vwfzy0nlpqmg6mccy85s2q6iqrg.png"><br><br>  <b>端点类型协议</b> <br><br> 首先，我们需要定义<i><b>EndPointType</b></i>协议。 该协议将包含配置请求的所有必要信息。 什么是请求（端点）？ 本质上，它是具有所有相关组件（例如标头，请求参数，请求主体）的URLRequest。  <i><b>EndPointType</b></i>协议是我们网络层实现中最重要的部分。 让我们创建一个文件并将其命名为<i><b>EndPointType</b></i> 。 将此文件放在Service文件夹中（而不是EndPoint文件夹中，为什么-稍后会清除） <br><br><img src="https://habrastorage.org/webt/-9/j0/ul/-9j0ulvgk-w_hftxxyqwolmbujy.png"><br><br>  <b>HTTP协议</b> <br><br> 我们的<i><b>EndPointType</b></i>包含创建请求所需的几种协议。 让我们看看这些协议是什么。 <br><br>  <b>HTTP方法</b> <br><br> 创建一个文件，将其命名为<i><b>HTTPMethod</b></i>并将其放在Service文件夹中。 此清单将用于设置我们请求的HTTP方法。 <br><br><img src="https://habrastorage.org/webt/j2/3x/nr/j23xnrcovqknw9dzxhf-xva898q.png"><br><br>  <b>HTTP任务</b> <br> 创建一个文件，将其命名为<i><b>HTTPTask</b></i>并将其放在Service文件夹中。  HTTPTask负责配置特定请求的参数。 您可以根据需要向其添加尽可能多的不同查询选项，但是我将依次进行常规查询，带参数的查询，带参数和标头的查询，因此，我将仅执行这三种类型的查询。 <br><br><img src="https://habrastorage.org/webt/v5/4m/j6/v54mj6yxsvdwuiossyq3em2biia.png"><br><br> 在下一节中，我们将讨论<i><b>参数</b></i>以及如何使用它们 <br><br>  <b>HTTP头</b> <br><br>  <i><b>HTTPHeaders</b></i>只是字典的别名。 您可以在<i><b>HTTPTask</b></i>文件的顶部创建它。 <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">HTTPHeaders</span></span> = [<span class="hljs-type"><span class="hljs-type">String</span></span>:<span class="hljs-type"><span class="hljs-type">String</span></span>]</code> </pre> <br><br>  <b>参数与编码</b> <br><br> 创建一个文件，将其命名为<i><b>ParameterEncoding</b></i>并将其放在Encoding文件夹中。 为<i><b>Parameters</b></i>创建typealias，它将再次成为常规词典。 我们这样做是为了使代码看起来更易于理解和可读。 <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Parameters</span></span> = [<span class="hljs-type"><span class="hljs-type">String</span></span>:<span class="hljs-type"><span class="hljs-type">Any</span></span>]</code> </pre> <br><br> 接下来，使用单个编码功能定义<i><b>ParameterEncoder</b></i>协议。  encode方法具有两个参数： <i><b>inout URLRequest</b></i>和<i><b>Parameters</b></i> 。  <b>INOUT</b>是一个Swift关键字，它将功能参数定义为引用。 通常，参数作为值传递给函数。 在调用中的函数参数之前写出<i><b>inout时</b></i> ，可以将此参数定义为引用类型。 要了解有关inout参数的更多信息，可以单击此链接。 简而言之， <i><b>inout</b></i>允许您更改传递给函数的变量本身的值，而不仅仅是在参数中获取其值并在函数内部使用它。  <i><b>ParameterEncoder</b></i>协议将在<i><b>JSONParameterEncoder</b></i>和<i><b>URLPameterEncoder中实现</b></i> 。 <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParameterEncoder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(urlRequest: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">inout</span></span></span></span><span class="hljs-function"><span class="hljs-params"> URLRequest, with parameters: Parameters)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> }</code> </pre> <br><br>  <i><b>ParameterEncoder</b></i>包含一个函数，其功能是对参数进行编码。 此方法可能会抛出需要处理的错误，因此我们使用throw。 <br><br> 产生标准错误而不是定制错误也可能很有用。 解密Xcode给您的东西总是很困难。 当您对所有错误进行了自定义和描述后，您始终会确切知道发生了什么。 为此，让我们定义一个继承自<i><b>Error</b></i>的枚举。 <br><br><img src="https://habrastorage.org/webt/tl/bj/dd/tlbjddm7l48ho1alexej8rrj15q.png"><br><br> 创建一个文件，将其命名为<i><b>URLParameterEncoder</b></i>并将其放在<i><b>Encoding</b></i>文件夹中。 <br><br><img src="https://habrastorage.org/webt/s-/eh/tg/s-ehtgdznm1pcdjyrhn3r4fibjs.png"><br><br> 此代码获取参数列表，对其进行转换和格式化以用作URL参数。 如您所知，URL中不允许使用某些字符。 参数也由“＆”符号分隔，因此我们必须注意这一点。 如果没有在请求中设置标头，我们还必须设置标头的默认值。 <br><br> 这是单元测试应该涵盖的代码部分。 构建URL请求是关键，否则我们会引发许多不必要的错误。 如果您使用开放式API，则显然您不希望将全部请求量用于失败的测试。 如果您想了解有关单元测试的更多信息，可以从本文开始。 <br><br>  <b>JSONParameterEncoder</b> <br><br> 创建一个文件，将其命名为<i><b>JSONParameterEncoder</b></i>并将其放在Encoding文件夹中。 <br><br><img src="https://habrastorage.org/webt/qf/nc/gp/qfncgpv0juhwx6xnvn4llxqv0eu.png"><br><br> 一切都与<i><b>URLParameter</b></i>的情况<i><b>相同</b></i> ，只是在这里，我们将转换JSON的参数，然后再次将定义编码“ application / json”的参数添加到标头中。 <br><br>  <b>网络路由器</b> <br><br> 创建一个文件，将其命名为<i><b>NetworkRouter</b></i>并将其放在Service文件夹中。 让我们开始定义闭包的类型别名。 <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">NetworkRouterCompletion</span></span> = (<span class="hljs-number"><span class="hljs-number">_</span></span> data: <span class="hljs-type"><span class="hljs-type">Data?</span></span>,<span class="hljs-number"><span class="hljs-number">_</span></span> response: <span class="hljs-type"><span class="hljs-type">URLResponse?</span></span>,<span class="hljs-number"><span class="hljs-number">_</span></span> error: <span class="hljs-type"><span class="hljs-type">Error?</span></span>)-&gt;()</code> </pre><br><br> 接下来，我们定义<i><b>NetworkRouter</b></i>协议。 <br><br><img src="https://habrastorage.org/webt/uf/zd/s0/ufzds0f3ci0fvx9mr0hingvxjtc.png"><br><br>  <i><b>NetworkRouter</b></i>有一个用于请求的<i><b>端点</b></i> ，并且在请求完成后，此请求的结果将传递到<i><b>NetworkRouterCompletion</b></i>闭包。 该协议还具有<i><b>取消</b></i>功能，可用于中断长期加载和卸载请求。 我们在这里也使用了<i><b>associatedtype</b></i> ，因为我们希望<i><b>路由器</b></i>支持任何类型的<i><b>EndPointType</b></i> 。 如果不使用associatedtype，则路由器必须具有实现<i><b>EndPointType的</b></i>某些特定类型。 如果您想了解有关associatedtype的更多信息，可以阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a> 。 <br><br>  <b>路由器</b> <br><br> 创建一个文件，将其命名为<i><b>Router</b></i>并将其放在Service文件夹中。 我们声明一个<i><b>URLSessionTask</b></i>类型的私有变量。 所有工作都在上面。 我们将其设为私有，因为我们不希望外部任何人都可以对其进行更改。 <br><br><img src="https://habrastorage.org/webt/gb/wk/cx/gbwkcxouam1y86i-sruvzyhub_c.png"><br><br>  <b>索取</b> <br><br> 在这里，我们使用<i><b>URLSession.shared</b></i>创建<i><b>URLSession</b></i> ，这是最简单的创建方法。 但是请记住，这种方法并非唯一。 您可以使用可以更改其行为的更复杂的<i><b>URLSession</b></i>配置。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文将</a>对此进行更多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">介绍</a> 。 <br><br> 该请求是通过调用<i>buildRequest</i>函数创建的，该函数调用包装在do-try-catch中，因为<i>buildRequest中</i>的编码函数可能会引发异常。  <i>Response</i> ， <i>data</i>和<i>error</i>传递到完成。 <br><br><img src="https://habrastorage.org/webt/oi/3c/jl/oi3cjllxhvs7n_m39kmy9r7q29k.png"><br><br>  <b>建立要求</b> <br><br> 我们使用<i>buildRequest</i>函数创建请求。 此功能负责我们网络层中的所有重要工作。 本质<i><b>上将EndPointType</b></i>转换为<i><b>URLRequest</b></i> 。 当<i><b>EndPoint</b></i>变成一个请求时，我们可以将其传递给<i><b>session</b></i> 。 这里发生了很多事情，所以让我们看一下这些方法。 首先， <i>让我们</i>检查<i>buildRequest</i>方法： <br><br>  1.我们初始化<i><b>URLRequest</b></i>请求变量。 我们在其中设置基本URL，并添加将用于它的特定请求的路径。 <br><br>  2.从我们的<i><b>EndPoint</b></i>分配<i>request.httpMethod</i> http方法。 <br><br>  3.我们创建了一个do-try-catch块，因为我们的编码器可能会抛出错误。 通过创建一个大型的do-try-catch块，我们无需为每次尝试创建一个单独的块。 <br><br>  4.在switch中，检查<i><b>route.task</b></i> 。 <br><br>  5.根据任务的类型，我们称为相应的编码器。 <br><br><img src="https://habrastorage.org/webt/pt/ij/58/ptij58jibcjvvawtyb44axo5mq4.png"><br><br>  <b>配置参数</b> <br><br> 在路由器中创建<i><b>configureParameters</b></i>函数。 <br><br><img src="https://habrastorage.org/webt/fb/gf/fy/fbgffycewgssxqrnxglvsvftl0w.png"><br><br> 该函数负责转换我们的查询参数。 由于我们的API假定使用JSON形式的<i><b>bodyParameters</b></i>和将<i><b>URLParameters</b></i>转换为URL格式，因此我们只需将适当的参数传递给相应的转换函数，我们将在本文开头进行介绍。 如果使用包含各种编码类型的API，那么在这种情况下，我建议添加<i><b>HTTPTask以及</b></i>编码类型的其他枚举。 此清单应包含所有可能的编码类型。 之后，在configureParameters中再添加一个带有此枚举的参数。 根据其值，使用switch进行切换并进行所需的编码。 <br><br>  <b>添加其他标题</b> <br><br> 在路由器中创建<i>addAdditionalHeaders</i>函数。 <br><br><img src="https://habrastorage.org/webt/ow/07/8a/ow078aeoow6qlavpxiobwl6nbh0.png"><br><br> 只需将所有必要的标头添加到请求中即可。 <br><br>  <b>取消</b> <br><br>  <i>取消</i>功能看起来非常简单： <br><br><img src="https://habrastorage.org/webt/v4/3t/mm/v43tmm1dlso_cwstw6sy444vyu4.png"><br><br>  <b>使用范例</b> <br><br> 现在，让我们尝试在一个真实示例中使用我们的网络层。 我们将连接到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TheMovieDB</a>以接收应用程序的数据。 <br><br>  <b>电影终点</b> <br><br> 创建一个<i><b>MovieEndPoint</b></i>文件，并将其放置在EndPoint文件夹中。  MovieEndPoint与 <br> 和Moya中的TargetType。 在这里，我们改为实现自己的EndPointType。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此链接中</a>可以找到一篇文章，介绍如何使用Moya作为类似示例。 <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation enum NetworkEnvironment { case qa case production case staging } public enum MovieApi { case recommended(id:Int) case popular(page:Int) case newMovies(page:Int) case video(id:Int) } extension MovieApi: EndPointType { var environmentBaseURL : String { switch NetworkManager.environment { case .production: return "https:<span class="hljs-comment"><span class="hljs-comment">//api.themoviedb.org/3/movie/" case .qa: return "https://qa.themoviedb.org/3/movie/" case .staging: return "https://staging.themoviedb.org/3/movie/" } } var baseURL: URL { guard let url = URL(string: environmentBaseURL) else { fatalError("baseURL could not be configured.")} return url } var path: String { switch self { case .recommended(let id): return "\(id)/recommendations" case .popular: return "popular" case .newMovies: return "now_playing" case .video(let id): return "\(id)/videos" } } var httpMethod: HTTPMethod { return .get } var task: HTTPTask { switch self { case .newMovies(let page): return .requestParameters(bodyParameters: nil, urlParameters: ["page":page, "api_key":NetworkManager.MovieAPIKey]) default: return .request } } var headers: HTTPHeaders? { return nil } }</span></span></code> </pre><br><br>  <b>电影模特</b> <br><br> 要将<i><b>MovieModel</b></i>和JSON数据模型解析为模型，使用了Decodable协议。 将此文件放在<i><b>模型</b></i>文件夹中。 <br><br>  <i>注意</i> ：要更详尽地了解Codable，Decodable和Encodable协议，可以阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我的另一篇文章</a> ，其中详细介绍了使用它们的所有功能。 <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation struct MovieApiResponse { let page: Int let numberOfResults: Int let numberOfPages: Int let movies: [Movie] } extension MovieApiResponse: Decodable { private enum MovieApiResponseCodingKeys: String, CodingKey { case page case numberOfResults = "total_results" case numberOfPages = "total_pages" case movies = "results" } init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: MovieApiResponseCodingKeys.self) page = try container.decode(Int.self, forKey: .page) numberOfResults = try container.decode(Int.self, forKey: .numberOfResults) numberOfPages = try container.decode(Int.self, forKey: .numberOfPages) movies = try container.decode([Movie].self, forKey: .movies) } } struct Movie { let id: Int let posterPath: String let backdrop: String let title: String let releaseDate: String let rating: Double let overview: String } extension Movie: Decodable { enum MovieCodingKeys: String, CodingKey { case id case posterPath = "poster_path" case backdrop = "backdrop_path" case title case releaseDate = "release_date" case rating = "vote_average" case overview } init(from decoder: Decoder) throws { let movieContainer = try decoder.container(keyedBy: MovieCodingKeys.self) id = try movieContainer.decode(Int.self, forKey: .id) posterPath = try movieContainer.decode(String.self, forKey: .posterPath) backdrop = try movieContainer.decode(String.self, forKey: .backdrop) title = try movieContainer.decode(String.self, forKey: .title) releaseDate = try movieContainer.decode(String.self, forKey: .releaseDate) rating = try movieContainer.decode(Double.self, forKey: .rating) overview = try movieContainer.decode(String.self, forKey: .overview) } }</code> </pre><br><br>  <b>网络经理</b> <br><br> 在管理器文件夹中创建一个<i><b>NetworkManager</b></i>文件。 目前，NetworkManager仅包含两个静态属性：API密钥和描述要连接到的服务器类型的枚举。  <i><b>NetworkManager</b></i>还包含类型为<i><b>MovieApi</b></i>的<i><b>路由器</b></i> 。 <br><br><img src="https://habrastorage.org/webt/yj/it/-b/yjit-b1afnahwsvjkkjnaezgpdu.png"><br><br>  <b>网络响应</b> <br><br> 在NetworkManager中创建<i><b>NetworkResponse</b></i>枚举。 <br><br><img src="https://habrastorage.org/webt/vv/fv/7s/vvfv7sl-q-dmnz289jdcntmhs0k.png"><br><br> 在处理对请求的响应时，我们将使用此枚举，并显示相应的消息。 <br><br>  <b>结果</b> <br><br> 在NetworkManager中创建一个<i><b>结果</b></i>枚举。 <br><br><img src="https://habrastorage.org/webt/en/oj/ad/enojad3e4jxk2jgkntgblqftivu.png"><br><br> 我们使用<i><b>Result</b></i>来确定请求是否成功。 如果不是，那么我们将返回一条错误消息并说明原因。 <br><br>  <b>请求响应处理</b> <br><br> 创建<i><b>handleNetworkResponse</b></i>函数。 此函数采用一个参数（例如<i><b>HTTPResponse），</b></i>并返回Result。 <br><br><img src="https://habrastorage.org/webt/wt/uv/5f/wtuv5f7cptiudu69o8mn16psbsy.png"><br><br> 在此函数中，根据从HTTPResponse接收到的statusCode，我们返回错误消息或请求成功的标志。 通常，范围为200..299的代码表示成功。 <br><br>  <b>发出网络请求</b> <br><br> 因此，我们已经完成了一切工作，开始使用我们的网络层，让我们尝试发出一个请求。 <br><br> 我们将索取新电影的清单。 创建一个函数并将其命名为<i><b>getNewMovies</b></i> 。 <br><br><img src="https://habrastorage.org/webt/ei/yn/fn/eiynfnoketqomcziq5nzv6ulaao.png"><br><br> 让我们逐步进行： <br><br>  1.我们用两个参数定义<i><b>getNewMovies</b></i>方法：分页页码和完成处理程序，它返回一个可选的<i><b>Movie</b></i>模型数组，或者一个可选的错误。 <br><br>  2.呼叫<i><b>路由器</b></i> 。 我们在关闭处传递页码和处理<i>完成</i> 。 <br><br>  3.如果没有网络或由于任何原因无法发出请求， <i><b>URLSession</b></i>将返回错误。 请注意，这不是API错误，此类错误在客户端上发生，通常是由于Internet连接质量差而发生的。 <br><br>  4.我们需要将<i><b>响应</b></i> <i><b>强制转换</b></i>为<i><b>HTTPURLResponse</b></i> ，因为我们需要访问<i>statusCode</i>属性。 <br><br>  5.声明<i><b>结果</b></i>并使用<i><b>handleNetworkResponse</b></i>方法对其进行初始化 <br><br>  6. <i><b>成功</b></i>表示请求成功，我们收到了预期的答复。 然后，我们检查数据是否带有答案，如果不是，则只需通过return结束方法即可。 <br><br>  7.如果答案与数据一起出现，则有必要将接收到的数据解析到模型中。 之后，我们将生成的模型数组传递给完成。 <br><br>  8.发生错误时，只需将错误传递给<i>完成即可</i> 。 <br><br> 就是这样，这就是我们自己的网络层在纯Swift上工作的方式，而无需使用任何第三方Pod和库形式的依赖项。 为了进行测试api请求以获取电影列表，请创建具有<i><b>NetworkManager</b></i>属性的MainViewController并通过它调用<i><b>getNewMovies</b></i>方法。 <br><br><pre> <code class="swift hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> networkManager: <span class="hljs-type"><span class="hljs-type">NetworkManager!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(networkManager: <span class="hljs-type"><span class="hljs-type">NetworkManager</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(nibName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, bundle: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.networkManager = networkManager } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"init(coder:) has not been implemented"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() view.backgroundColor = .green networkManager.getNewMovies(page: <span class="hljs-number"><span class="hljs-number">1</span></span>) { movies, error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> movies = movies { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(movies) } } } }</code> </pre> <br><br>  <b>小奖金</b> <br><br> 当您不了解在特定位置使用哪种占位符时，您在Xcode中遇到了一些情况？ 例如，查看我们刚刚为<i><b>Router</b></i>编写的代码。 <br><br><img src="https://habrastorage.org/webt/sd/cb/ga/sdcbgacxit9y-j4zk8w32slxqm8.png"><br><br> 我们自己确定了<i><b>NetworkRouterCompletion</b></i> ，但是即使在这种情况下，也很容易忘记它是什么类型以及如何使用它。 但是，我们钟爱的Xcode会处理所有事情，只需双击占位符就足够了，Xcode将替换所需的类型。 <br><br><img src="https://habrastorage.org/webt/la/wo/oj/lawoojq5qsvsdzzvfzarqc-wnsk.png"><br><br>  <b>结论</b> <br><br> 现在，我们已经实现了面向协议的网络层，该层非常易于使用，您可以随时对其进行自定义。 我们了解了它的功能以及所有机制的工作原理。 <br><br> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此存储库中</a>找到源代码。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN443514/">https://habr.com/ru/post/zh-CN443514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN443502/index.html">为什么正好4年前，NASA用Atlas V火箭拍摄了卡纳维拉尔角的夜空？</a></li>
<li><a href="../zh-CN443504/index.html">万维网已有三十年历史了-接下来会发生什么？</a></li>
<li><a href="../zh-CN443506/index.html">Google表格中YouTube的简单解析器</a></li>
<li><a href="../zh-CN443510/index.html">Compaq Armada 7700笔记本电脑-Compaq LTE产品线的发展</a></li>
<li><a href="../zh-CN443512/index.html">下诺夫哥罗德的数据分析黑客马拉松</a></li>
<li><a href="../zh-CN443516/index.html">黑客Geohot决定将人们从AI模拟中解放出来</a></li>
<li><a href="../zh-CN443518/index.html">深入了解RBKmoney付款-微服务，协议和平台配置</a></li>
<li><a href="../zh-CN443520/index.html">为IT专家选择汽车，或从茶壶中获取茶壶的提示</a></li>
<li><a href="../zh-CN443522/index.html">托管：选项，比较，用户统计信息</a></li>
<li><a href="../zh-CN443524/index.html">在Unity3D中自己动手制作Flash动画。 第一部分，抒情</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>