<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñºÔ∏è üë®üèΩ‚Äçüé§ üö∂üèæ GLSL: Centre ou Centroid? Ou quand les shaders attaquent ü•ù üö≠ ‚õΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En modifiant le shader pour le prochain jeu, je suis tomb√© sur un artefact d√©sagr√©able qui ne se manifeste que lorsque le mat√©riel MSAA est activ√©. Da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GLSL: Centre ou Centroid? Ou quand les shaders attaquent</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434046/">  En modifiant le shader pour le prochain jeu, je suis tomb√© sur un artefact d√©sagr√©able qui ne se manifeste que lorsque le mat√©riel MSAA est activ√©.  Dans la capture d'√©cran du paysage, vous pouvez voir quelques pixels trop lumineux.  Les valeurs chromatiques de plusieurs d'entre elles √©taient si grandes qu'apr√®s la floraison, elles se sont transform√©es en ¬´fant√¥mes¬ª multicolores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ta/gx/zy/tagxzyrj4t5z9godohkp1fgteya.png" alt="image"></div><br>  J'attire votre attention sur la traduction d'un article qui explique en d√©tail la raison de ce ph√©nom√®ne et la mani√®re de le g√©rer. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/526/948/f51/526948f51e45bbb855518c2cdf292d0e.jpg" alt="image"></div><br>  <i>Figure 1 - Images correctes (√† gauche) et incorrectes (√† droite).</i>  <i>Faites attention √† la barre jaune sur le bord gauche de l'image ¬´incorrecte¬ª.</i>  <i>Bien que la variable myMixer varie de 0 √† 1, elle d√©passe en quelque sorte cette plage dans l'image ¬´incorrecte¬ª.</i> <br><br>  Consid√©rons un shader de fragment simple avec une transformation non lin√©aire simple: <br><br><pre><code class="plaintext hljs">smooth in float myMixer; //      . //  sqrt    . void main( void ) { const vec3 blue = vec3( 0.0, 0.0, 1.0 ); const vec3 yellow = vec3( 1.0, 1.0, 0.0 ); float a = sqrt( myMixer ); //    myMixer &lt; 0.0 vec3 color = mix( blue, yellow, a ); //   gl_FragColor = vec4( color, 1.0 ); }</code> </pre> <br>  D'o√π vient la bande jaune √† gauche dans l'image incorrecte?  Pour mieux comprendre ce qui a mal tourn√©, examinons d'abord un cas dans lequel tout fonctionne correctement (presque) toujours. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83d/1fe/6fd/83d1fe6fdaaffaf185291655c0808542.png" alt="image"></div><br>  <i>Il s'agit d'une pixellisation classique avec un √©chantillon.</i>  <i>Les carr√©s gris sont des pixels et les points jaunes sont les centres des pixels situ√©s aux coordonn√©es de la fen√™tre demi-entier (par d√©faut, les coordonn√©es du pixel inf√©rieur gauche dans gl_FragCoord sont (0,5, 0,5) - <i>trans.</i> ).</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/854/0c1/3e58540c1bf747df60150e88d564d4a0.png" alt="image"></div><br>  <i>Dans l'image ci-dessus, la ligne s√©cante s√©pare le demi-espace de la primitive.</i>  <i>Au-dessus et √† gauche de cette ligne, la variable myMixer est positive, et en dessous et √† droite est n√©gative.</i> <br><br>  La pixellisation classique √† un √©chantillon classe les pixels en fonction de l'appartenance primitive et cr√©e des fragments uniquement pour les pixels dont le centre se trouve √† l'int√©rieur de la primitive.  Dans cet exemple, six fragments seront produits, montr√©s en haut √† gauche.  Les pixels marqu√©s en couleur att√©nu√©e ne tombent pas dans la primitive.  Aucun fragment ne sera g√©n√©r√© pour eux. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83f/b9b/37f/83fb9b37f2e978f18643f111af0e2eb8.png" alt="image"></div><br>  <i>Le vert indique les points auxquels le fragment shader sera calcul√©.</i>  <i>La valeur de myMixer sera calcul√©e pour le centre de chaque pixel.</i>  <i>Notez que les points verts sont au-dessus et √† gauche de la ligne, donc les valeurs de myMixer seront positives.</i>  <i>Toutes les donn√©es d'entr√©e associ√©es aux sommets (variables variables ou variables d'entr√©e / sortie) seront √©galement interpol√©es √† ces points.</i> <br><br>  Notre shader simple n'utilise pas de d√©riv√©s (explicites ou implicites, par exemple, lors de l'√©chantillonnage √† partir d'une texture avec des niveaux de mip), mais les d√©riv√©s dFdx (horizontal) et dFdy (vertical) sont marqu√©s de fl√®ches.  √Ä l'int√©rieur de la primitive, ils sont assez bien d√©finis et r√©guliers. <br><br>  Pour r√©sumer: dans une seule s√©lection, les fragments ne sont g√©n√©r√©s <i>que</i> si le centre du pixel tombe "√† l'int√©rieur" de la primitive, les donn√©es du fragment sont calcul√©es pour le centre du pixel, l'interpolation des donn√©es de sommet et le calcul du shader sont effectu√©s uniquement √† l'int√©rieur de la primitive.  Tout est bon et "correct".  (Presque toujours. Pour l'instant, omettons les inexactitudes de certains d√©riv√©s sur les pixels le long de la bordure de la primitive). <br><br>  Donc, tout est (presque) excellent pour la pixellisation avec une seule s√©lection.  Mais qu'est-ce qui peut mal tourner lorsque le multi-√©chantillonnage est activ√©? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acc/eee/dc2/acceeedc234b34993f3e284dd6a2dd81.png" alt="image"></div><br>  <i>Il s'agit d'une pixellisation classique √† √©chantillonnage multiple.</i>  <i>Les carr√©s gris indiquent les pixels.</i>  <i>Les points jaunes sont des centres de pixels en coordonn√©es demi-enti√®res.</i>  <i>Aux points bleus, l'√©chantillonnage a lieu.</i>  <i>Cet exemple montre un sch√©ma simple de deux √©chantillons tourn√©s.</i>  <i>Tous les arguments peuvent √™tre g√©n√©ralis√©s pour un nombre arbitraire d'√©chantillons.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f10/7f0/1bb/f107f01bb4df32a980543cb70e6b8e5c.png" alt="image"></div><br>  <i>La ligne s√©pare toujours le demi-espace de la primitive.</i>  <i>Au-dessus et √† gauche de celui-ci, la valeur de myMixer est positive.</i>  <i>Plus bas et √† droite - n√©gatif.</i> <br><br>  Lors de la pixellisation avec multi-√©chantillonnage, le classificateur de pixels g√©n√©rera un fragment si <i>au moins un</i> √©chantillon de pixels tombe √† l'int√©rieur de la primitive. <br><br>  Dans cet exemple, 10 fragments seront g√©n√©r√©s, affich√©s dans le demi-plan sup√©rieur gauche.  Notez les quatre fragments ajout√©s le long du visage, dans lesquels un √©chantillon tombe √† l'int√©rieur de la primitive, bien que le centre soit √† l'ext√©rieur.  Les pixels en dehors de la primitive sont toujours marqu√©s comme √©tant sombres. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3e/842/b67/f3e842b67809ec9efe1c8e0ff837ee7c.png" alt="image"></div><br>  <i>Que se passera-t-il lors du calcul au centre du pixel?</i> <br><br>  Le shader sera calcul√© en points verts <i>et</i> rouges pour chacun des fragments.  Les donn√©es associ√©es √† myMixer sont calcul√©es au centre de chaque pixel.  En points verts, ces valeurs seront positives, car elles sont au-dessus et √† gauche de la bordure.  Les points rouges sont en dehors de la primitive, car les valeurs de myMixer sont n√©gatives.  Aux points rouges, les donn√©es associ√©es sont extrapol√©es au lieu d'une interpolation. <br><br>  Dans notre shader, les valeurs sqrt (myMixer) ne sont pas d√©finies avec un myMixer n√©gatif.  M√™me lorsque les valeurs myMixer enregistr√©es par le vertex shader se situent dans l'intervalle de z√©ro √† un, dans le fragment shader myMixer peut d√©passer cet intervalle en raison de l'extrapolation.  Ainsi, avec un myMixer n√©gatif, le r√©sultat du fragment shader n'est pas d√©fini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f4/31d/854/8f431d8540787d70ae2fb27aede04f9f.png" alt="image"></div><br>  <i>Nous envisageons toujours de calculer le shader au centre des pixels, les fl√®ches de la figure montrent dFdx et dFdy.</i>  <i>Sur les fragments internes du polygone, ils sont assez bien d√©finis car tous les calculs sont effectu√©s au centre de pixels situ√©s √† intervalles √©gaux.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e02/f36/8fa/e02f368fae459f51896de647a98f23ab.png" alt="image"></div><br>  <i>Que se passera-t-il lors du calcul √† des points autres que les centres des pixels?</i> <br><br>  Les points verts sont les points auxquels le shader sera calcul√©.  La valeur associ√©e de myMixer est calcul√©e dans le <u>centre de gravit√© de</u> chaque pixel. <br><br>  Le centre de gravit√© d'un pixel est le centre de gravit√© de l'intersection du carr√© du pixel et de l'int√©rieur de la primitive.  Pour un pixel enti√®rement couvert, le centro√Øde est le centre.  Pour un pixel partiellement couvert, le centro√Øde est g√©n√©ralement diff√©rent du centre. <br><br>  Le standard OpenGL permet √† une impl√©mentation de s√©lectionner un point arbitraire √† l'intersection d'une primitive et d'un pixel au lieu d'un centro√Øde id√©al.  Par exemple, il pourrait s'agir d'un point d'√©chantillonnage. <br><br>  Dans cet exemple, si le centre se trouve √† l'int√©rieur de la primitive, les donn√©es de sommet sont calcul√©es pour le centre.  Sinon, ils sont calcul√©s √† l'un des points d'√©chantillonnage situ√©s √† l'int√©rieur de la primitive.  Cela se produit pour quatre pixels le long de la bordure.  Tous les points verts se trouvent au-dessus et √† gauche de la bordure, de sorte que les valeurs qu'ils contiennent sont toujours interpol√©es et jamais extrapol√©es. <br><br>  Pourquoi ne pas toujours calculer le shader centro√Øde?  En g√©n√©ral, c'est plus cher que l'informatique au centre.  Cependant, ce n'est pas le facteur principal. <br><br>  Tout tourne autour du calcul des d√©riv√©s.  Faites attention aux fl√®ches entre les points verts.  La distance entre eux n'est pas la m√™me pour diff√©rentes paires de points.  De plus, y n'est pas constant pour dFdx et x n'est pas constant pour dFdy.  <i>Les d√©riv√©s sont moins pr√©cis lorsqu'ils sont calcul√©s en centro√Ødes</i> . <br><br>  C'est un compromis, et donc OpenGL, √† partir de GLSL 1.20, offre au d√©veloppeur du shader un choix entre le centre et le centro√Øde en utilisant le qualificatif centro√Øde: <br><br><pre> <code class="plaintext hljs">centroid in float myMixer; //  centroid  smooth //      . //  sqrt    . void main( void ) { const vec3 blue = vec3( 0.0, 0.0, 1.0 ); const vec3 yellow = vec3( 1.0, 1.0, 0.0 ); float a = sqrt( myMixer ); //    myMixer &lt; 0.0 vec3 color = mix( blue, yellow, a ); //   gl_FragColor = vec4( color, 1.0 ); }</code> </pre><br>  Quand faut-il utiliser le centro√Øde? <br><br><ol><li>  Lorsqu'une valeur extrapol√©e peut conduire √† des r√©sultats vagues.  Portez une attention particuli√®re aux fonctions int√©gr√©es, dont la description indique "le r√©sultat n'est pas d√©fini si ..." </li><li>  Lorsqu'une valeur extrapol√©e est utilis√©e avec une fonction tr√®s non lin√©aire ou discontinue.  Ceux-ci incluent la fonction de pas ou le calcul de la fus√©e, en particulier lorsque l'exposant est suffisamment grand. </li></ol><br>  Quand ne devriez-vous pas utiliser un centro√Øde? <br><br><ol><li>  Si vous avez besoin de d√©riv√©s exacts.  Les d√©riv√©s peuvent √™tre explicites (appel dFdx) ou implicites, par exemple, des √©chantillons de textures avec des niveaux de mip ou avec un filtrage anisotrope.  Dans la sp√©cification GLSL, les d√©riv√©s dans les centro√Ødes sont consid√©r√©s comme si inutilisables qu'ils sont d√©clar√©s non d√©finis.  Dans de tels cas, essayez d'√©crire: <br><br><pre> <code class="plaintext hljs">centroid in float myMixer; //  ! smooth in float myCenterMixer; //     .</code> </pre><br></li><li>  Si une grille est rendue dans laquelle la plupart des fronti√®res des primitives sont internes et toujours bien d√©finies.  L'exemple le plus simple est une bande de 100 triangles (TRIANGLE_STRIP), dans laquelle seuls le premier et le dernier triangles sont soumis √† extrapolation.  Le qualificatif centro√Øde entra√Ænera une interpolation sur ces deux triangles au prix d'une perte de pr√©cision et de continuit√© sur les 98 triangles restants. </li><li>  Si vous savez que des artefacts peuvent appara√Ætre √† partir d'une fonction ind√©finie, non lin√©aire ou discontinue, mais en pratique, ces artefacts se r√©v√®lent presque invisibles.  Si le shader <i>n'attaque pas</i> - ne le corrigez pas! </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434046/">https://habr.com/ru/post/fr434046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434034/index.html">Bons tutoriels sur YouTube</a></li>
<li><a href="../fr434036/index.html">Happy and end - les bo√Ætes aux lettres sur les domaines du portail Qip.ru ont migr√© vers Yandex</a></li>
<li><a href="../fr434038/index.html">Ventes de v√©hicules √©lectriques rechargeables en Chine pour novembre 2018</a></li>
<li><a href="../fr434040/index.html">Recueil universitaire ITMO: parler des projets universitaires, des succ√®s et des r√©alisations de nos dipl√¥m√©s</a></li>
<li><a href="../fr434044/index.html">Authentification √† deux facteurs (2FA) r√©sistante au phishing</a></li>
<li><a href="../fr434048/index.html">Facebook d√©veloppe une crypto-monnaie pour WhatsApp</a></li>
<li><a href="../fr434050/index.html">Java Enterprise vs Android en 2019 - que choisir pour un d√©butant?</a></li>
<li><a href="../fr434052/index.html">Conf√©rence BLACK HAT. Comment faire un t√©l√©phone espion. Partie 1</a></li>
<li><a href="../fr434054/index.html">Conf√©rence BLACK HAT. Comment faire un t√©l√©phone espion. 2e partie</a></li>
<li><a href="../fr434056/index.html">Vous devez savoir o√π mettre le z√©ro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>