<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’¶ â›¸ï¸ â›¹ğŸ¼ Formula untuk bahasa Korea, atau mengenali Hangul dengan cepat, mudah dan tanpa kesalahan. ğŸ˜¢ ğŸŒ‹ âœ³ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sampai saat ini, setiap siswa yang telah mengambil kursus di jaringan saraf dapat membuat pengenalan karakter Korea. Berikan dia sampel dan komputer d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Formula untuk bahasa Korea, atau mengenali Hangul dengan cepat, mudah dan tanpa kesalahan.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/abbyy/blog/441938/"><img src="https://habrastorage.org/webt/ba/mt/v2/bamtv2b4kyxq8bt4-5hynwx0are.jpeg" align="right">  Sampai saat ini, setiap siswa yang telah mengambil kursus di jaringan saraf dapat membuat pengenalan karakter Korea.  Berikan dia sampel dan komputer dengan kartu video, dan setelah beberapa saat dia akan membawakan Anda jaringan yang akan mengenali karakter Korea dengan hampir tanpa kesalahan. <br><br>  Tetapi solusi semacam itu akan memiliki beberapa kelemahan: <br><br>  <b>Pertama</b> , sejumlah besar perhitungan yang diperlukan, yang memengaruhi waktu operasi atau energi yang diperlukan (yang sangat penting untuk perangkat seluler).  Memang, jika kita ingin mengenali setidaknya 3000 karakter, maka ini akan menjadi ukuran lapisan terakhir jaringan.  Dan jika input dari lapisan ini setidaknya 512, maka kita mendapatkan 512 * 3000 perkalian.  Terlalu banyak <br><br>  <b>Kedua</b> , ukurannya.  Lapisan terakhir yang sama dari contoh sebelumnya akan menimbang 512 * 3001 * 4 byte, mis. Sekitar 6 megabyte.  Ini hanya satu lapisan, seluruh jaringan akan menimbang puluhan megabyte.  Jelas bahwa ini bukan masalah besar untuk komputer desktop, tetapi tidak semua orang akan siap untuk menyimpan begitu banyak data pada smartphone untuk mengenali satu bahasa. <br><br>  <b>Ketiga</b> , jaringan semacam itu akan memberikan hasil yang tidak terduga pada gambar yang bukan karakter Korea, tetapi tetap digunakan dalam teks Korea.  Dalam kondisi laboratorium, ini tidak sulit, tetapi untuk aplikasi praktis teknologi, masalah ini harus dipecahkan. <br><br>  <b>Dan keempat</b> , masalahnya adalah jumlah karakter: 3.000 kemungkinan besar cukup untuk, misalnya, membedakan steak dari teripang goreng di menu restoran, tetapi kadang-kadang ada teks yang lebih kompleks.  Akan sulit untuk melatih jaringan untuk jumlah karakter yang lebih besar: itu tidak hanya akan lebih lambat, tetapi juga akan ada masalah dengan pengumpulan sampel pelatihan, karena frekuensi karakter menurun kira-kira secara eksponensial.  Tentu saja, Anda bisa mendapatkan gambar dari font dan memperbesarnya, tetapi ini tidak cukup untuk melatih jaringan yang baik. <br><br>  Dan hari ini saya akan memberi tahu Anda bagaimana kami berhasil menyelesaikan masalah ini. <br><a name="habracut"></a><br><h2>  Bagaimana cara kerja penulisan Korea? </h2><br>  Tulisan Korea, Hangul, adalah persilangan antara tulisan Cina dan Eropa.  Secara lahiriah, ini adalah karakter persegi menyerupai hieroglif, dan pada satu halaman teks Anda dapat menghitung lebih dari seratus yang unik.  Di sisi lain, itu adalah penulisan fonetik, yaitu, berdasarkan rekaman suara.  Ada alfabet yang berisi 24 huruf (ditambah Anda juga bisa menghitung diffraphs dan diftong).  Tetapi, tidak seperti alfabet Latin atau Sirilik, suara tidak ditulis dalam satu baris, tetapi digabungkan dalam beberapa blok.  Misalnya, jika kita menulis dengan cara yang sama, maka frasa "Halo, Habr" dapat ditulis dalam tiga blok seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/id/ya/wu/idyawulbnrayub1igw6bkpjwcca.png"></div><br>  Setiap blok dapat terdiri dari dua, tiga, atau empat huruf.  Dalam hal ini, konsonan selalu didahulukan, kemudian satu atau dua vokal, dan pada akhirnya bisa ada konsonan lain.  Ada beberapa cara berbeda untuk menggabungkan huruf menjadi blok, yaitu, di blok yang berbeda huruf kedua, misalnya, akan berdiri di tempat yang berbeda. <br><br>  Gambar di bawah ini menunjukkan dua blok yang bersama-sama membentuk kata "Hangul".  Huruf pertama dari setiap blok ditandai dengan warna merah, vokal disorot dengan warna biru, dan konsonan terakhir disorot dengan warna hijau. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4b/76/0p/4b760pyxzvlfy0wy0bigrlqgmaw.png"></div><br>  <i>Sumber gambar: Wikipedia.</i> <br><br><h2>  Ubah blok Hangul </h2><br>  Yaitu, ternyata satu blok Hangul dapat dijelaskan dengan rumus: Ci V [V] [Cf], di mana Ci adalah konsonan awal (mungkin ganda), V adalah vokal, dan Cf adalah konsonan akhir (juga bisa ganda).  Representasi seperti itu tidak nyaman untuk pengakuan, jadi kami mengubahnya. <br><br>  Pertama, gabungkan kedua vokal.  Kami mendapatkan rumus Ci V '[Cf], di mana V' - semua opsi yang memungkinkan untuk menggabungkan huruf, mengingat tidak adanya huruf kedua.  Karena ada 10 vokal dalam bahasa tersebut, orang akan berharap bahwa sebagai hasilnya kita mendapatkan 10 * (10 + 1) pilihan, tetapi dalam praktiknya tidak semuanya mungkin, hanya 21 yang diperoleh. <br><br>  Selanjutnya, surat terakhir mungkin tidak.  Tambahkan ke banyak surat yang diharapkan di akhir yang kosong.  Kemudian kita mendapatkan formula Ci V 'Cf *.  Jadi, ternyata sekarang simbol Korea selalu terdiri dari tiga "huruf".  Anda dapat mempelajari kisi. <br><br><h2>  Kami membangun jaringan </h2><br>  Idenya adalah bahwa alih-alih mengenali seluruh karakter, kita akan mengenali masing-masing huruf di dalamnya.  Jadi, alih-alih satu softmax besar di akhir, kami mendapatkan tiga yang kecil, masing-masing sekitar beberapa puluh ukuran.  Mereka sesuai dengan "huruf" pertama, kedua dan ketiga dalam suku kata.  Hasilnya, kami mendapatkan arsitektur berikut: <br><br>  <i>gambar yang bisa diklik</i> <br> <a href=""><img src="https://habrastorage.org/webt/oe/tx/la/oetxlav-phzctw_re0w02a982gq.png"></a> <br><br>  Kami berlatih, menjalankan sampel terpisah.  Kualitasnya bagus, gridnya cepat, dan beratnya kecil.  Mari kita coba membawanya keluar dari laboratorium ke dunia nyata. <br><br><h2>  Kami memecahkan masalah </h2><br>  Kami akan mendapatkan masalah pertama segera: kadang-kadang gambar yang bukan karakter Korea masuk ke input, dan jaringan di dalamnya berperilaku sangat tidak terduga.  Anda dapat, tentu saja, melatih jaringan lain yang akan membedakan blok Korea dari yang lainnya, tetapi kami akan membuatnya lebih mudah. <br><br>  Mari kita lakukan hal yang sama dengan yang kita lakukan dengan grup huruf ketiga: tambahkan output untuk ketiadaan huruf.  Maka rumus simbol akan terlihat seperti ini: Ci * V '* Cf *.  Dan di set pelatihan, kami akan menambahkan semua jenis sampah - karakter Cina, karakter yang dipotong salah, huruf Eropa, dan kami akan mengajarkan jaringan untuk menandai tiga huruf kosong di dalamnya. <br><br>  Kami berlatih, tes.  Ini bekerja, tetapi masalahnya tetap ada.  Ternyata cukup sering, misalnya, gambar seperti itu jatuh ke dalam kisi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bs/9o/wk/bs9owkuyyvxqhqgky8kea-51sxc.png"></div><br>  Ini adalah blok bahasa Korea yang tepat di mana satu kutipan terhenti.  Dan jelas bahwa pada mereka jaringan dengan sempurna menemukan ketiga huruf yang terdiri dari blok.  Itu hanya gambar yang tidak benar, dan kita perlu memberi sinyal tentang itu.  Adalah salah untuk mengembalikan huruf-huruf kosong di sini, karena terdapat pada gambar.  Mari kita coba terapkan apa yang sudah terbukti baik: tambahkan dua output lagi untuk mengenali punctuator lengket tersebut.  Masing-masing dari mereka akan memiliki satu output tambahan untuk situasi ketika tidak ada yang berlebihan dalam gambar, tetapi di samping itu perlu menambahkan satu output lagi untuk situasi "ada punctuator, tetapi tidak dikenali, mungkin sampah." <br><br>  Terlatih  Adalah buruk di grid seperti itu untuk mengenali punctuator: itu membedakan koma dari braket, tetapi sudah sulit dari satu titik.  Anda dapat meningkatkan kompleksitas grid, tetapi tidak mau.  Kami akan berurusan dengan pengakuan punctuator nanti, tetapi untuk saat ini kami hanya akan memberi tahu apakah ada sesuatu di sana atau tidak.  Grid ini belajar dengan baik. <br><br>  Kami menemukan punctuator terpaku, tetapi bagaimana jika, sebaliknya, bagian dari kunci hilang pada gambar?  Ada kata dua karakter seperti itu, tetapi kami memotongnya menjadi karakter yang salah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0k/0b/is/0k0bis_huro2eqavjxat7y2ztx8.png"></div><br>  Jaringan di sini tanpa masalah menentukan huruf pusat.  Ini akan menjadi kualitas yang sangat berguna jika tugas kita hanya mengenali pilihan karakter, tetapi di dunia nyata itu akan berbahaya: ketika kita salah memotong string menjadi karakter, kita harus meneruskan informasi ini di atas, karena kalau tidak, bagian yang tersisa kemudian diakui sebagai semacam tanda baca, dan dalam teks yang dihasilkan akan ada karakter tambahan. <br><br>  Untuk mengatasi masalah ini, kami akan menggunakan sisa beberapa eksperimen lama beberapa tahun yang lalu.  Gagasan mengenali karakter Korea melalui surat muncul sejak lama, dan upaya pertama dilakukan bahkan sebelum era jaringan saraf, tetapi mereka tidak menemukan aplikasi praktis.  Namun sejak itu, hal-hal menarik tetap ada: <br><br><ol><li>  Menandai di mana setiap blok memiliki surat. </li><li>  Berkualitas tinggi, meskipun cepat, memotong huruf-huruf ini dari simbol. </li></ol><br>  Setelah membersihkan debu, dengan bantuan barang ini, kami akan menghasilkan cukup banyak gambar bermasalah tanpa salah satu huruf dan kami akan secara khusus mengajarkan jaringan untuk menjawab bahwa itu adalah huruf kosong. <br><br>  Itu semua, tidak ada lagi masalah dengan mengenali karakter Korea, tetapi kehidupan menempatkan tongkat ke roda lagi. <br><br>  Faktanya adalah bahwa selain karakter Hangeul, teks Korea juga terdiri dari sejumlah besar karakter lain: punctuator, karakter Eropa (setidaknya angka) dan karakter Cina.  Tetapi mereka secara alami lebih jarang terjadi.  Kami akan membaginya menjadi dua kelompok: hieroglif dan yang lainnya, dan kami akan melatih kisi kami untuk masing-masing.  Dan kami akan membuat classifier sederhana, yang menurut hasil jaringan untuk mengenali karakter Korea dan beberapa tanda lainnya (geometris, di tempat pertama) akan menjawab apakah setidaknya salah satu dari mereka perlu diluncurkan, dan jika demikian, yang mana.  Anda perlu mengenali sedikit karakter Eropa, sehingga kisi-kisi akan kecil, tetapi untuk hieroglif ... Ini menyimpan bahwa mereka jarang ditemukan dalam teks, jadi mari kita putar classifier kita sehingga sangat jarang menyarankan mengenalinya. <br><br>  Secara umum, dengan dua kisi-kisi ini, masalah jawaban yang memadai muncul dalam gambar yang bukan simbol yang dilatihnya, tetapi kita akan berbicara tentang cara menyelesaikan masalah ini di lain waktu. <br><br><h2>  Lakukan eksperimen </h2><br>  <b>Yang pertama</b> .  Ada dua basis gambar, sebut saja mereka Nyata dan Sintetis.  Nyata terdiri dari gambar nyata yang diperoleh dari dokumen yang dipindai, dan Sintetis - gambar yang diperoleh dari font.  Di pangkalan pertama ada gambar untuk 2374 blok (sisanya sangat langka), dan dari font kami mendapatkan semua kemungkinan 1.172 karakter.  Mari kita coba latih jaringan pada blok-blok yang ada di Real (kita akan mengambil gambar dari kedua pangkalan), dan mengujinya pada mereka yang hanya di Sintetis.  Hasil: <br><br><img src="https://habrastorage.org/webt/ee/zf/-p/eezf-phs4-blg-lmo5zizle4yl4.png" alt="gambar"><br><br>  Yaitu, dalam sekitar 60% kasus, jaringan mampu mengenali blok-blok itu, contoh-contoh yang tidak terlihat sama sekali selama pelatihan.  Kualitasnya bisa lebih tinggi jika bukan karena satu masalah: di antara huruf terakhir ada yang sangat langka, dan selama pelatihan jaringan melihat sangat sedikit gambar balok di dalamnya.  Ini menjelaskan kualitas rendah di kolom terakhir.  Jika mungkin untuk memilih 2.374 blok yang kami pelajari, dengan cara yang berbeda, maka kualitasnya kemungkinan besar akan terasa lebih tinggi. <br><br>  <b>Yang kedua</b>  Bandingkan jaringan kami dengan jaringan "normal", yang memiliki softmax pada akhirnya.  Saya ingin membuatnya dalam ukuran 11172, tetapi kami tidak dapat menemukan jumlah gambar nyata yang cukup untuk blok langka, jadi kami membatasi diri hingga 2374.  Kualitas dan kecepatan jaringan ini tergantung pada ukuran lapisan yang disembunyikan.  Kami hanya akan mengajar di Real, mengujinya (di bagian lain, tentu saja). <br><br><img src="https://habrastorage.org/webt/hh/xg/uc/hhxgucuke45t66gchwdnmf6qft4.png" alt="gambar"><br><br>  Yaitu, bahkan jika kita membatasi diri kita hanya untuk mengenali 2374 blok, jaringan kita lebih cepat dan pada tingkat kualitas yang sama. <br><br>  <b>Ketiga</b>  Misalkan kita bisa mendapatkan basis besar dari semua 1.172 blok Korea.  Jika kita melatih jaringan dengan softmax di atasnya, berapa lama itu akan bekerja tepat waktu?  Semua eksperimen mahal untuk dilakukan, jadi kami hanya mempertimbangkan jaringan dengan 256 ukuran lapisan tersembunyi: <br><br><img src="https://habrastorage.org/webt/lr/8t/4s/lr8t4sb00ghq54azyowxnahpudo.png" alt="gambar"><br><br><h2>  Kami mendapatkan hasilnya </h2><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/d5/ig/gzd5ighx6_yl3655fpbh8j5fitu.png"></div><br><br><h2>  Tanpa mereka, tidak akan ada yang terjadi </h2><br>  Saya mengucapkan terima kasih kepada kolega saya Jura Chulinin, penulis asli gagasan itu.  Ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dipatenkan</a> di Rusia, dan, di samping itu, aplikasi serupa telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diajukan</a> ke Kantor Paten Amerika (USPTO).  Terima kasih banyak kepada pengembang Misha Zatsepin, yang mengimplementasikan semua ini dan melakukan semua percobaan. <br><br>  <i>Yuri Vatlin,</i> <i><br></i>  <i>Kepala kelompok Script Kompleks</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441938/">https://habr.com/ru/post/id441938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441918/index.html">Kami berada di UltraHD Morty! Cara menonton film apa pun dalam 4K</a></li>
<li><a href="../id441920/index.html">Strategi keamanan informasi: sudahkah Anda memutuskan cara untuk maju?</a></li>
<li><a href="../id441928/index.html">Luncurkan aplikasi di Openshift dan bandingkan alat yang ada</a></li>
<li><a href="../id441932/index.html">Cara menjadi yang terdepan dalam persaingan: SIBUR mengembangkan manufaktur aditif</a></li>
<li><a href="../id441934/index.html">7 langkah untuk menggunakan Kamar. Panduan untuk memigrasi aplikasi Anda ke Kamar</a></li>
<li><a href="../id441942/index.html">Melanggar - bukan membangun. Atau devolusi</a></li>
<li><a href="../id441944/index.html">Mengapa kami memilih Lexus RX450h</a></li>
<li><a href="../id441946/index.html">REST API pada Laravel dalam 100 baris kode</a></li>
<li><a href="../id441950/index.html">Eclipse Che 7 sudah ada di sini</a></li>
<li><a href="../id441952/index.html">Memilih sistem penyimpanan file untuk kerja tim</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>