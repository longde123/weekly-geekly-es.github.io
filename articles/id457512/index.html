<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏾 🛌🏽 🌇 Replikasi logis antara versi PostgreSQL 🆔 🛂 🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada berbagai pendekatan untuk memperbarui PostgreSQL, tetapi beberapa mengarah pada downtime. Jika Anda ingin menghindari downtime, gunakan replikasi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Replikasi logis antara versi PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/457512/"><p><img src="https://habrastorage.org/webt/yl/pr/hs/ylprhs3ilpoukerjhyvwdnj6kmu.png"></p><br><p>  Ada berbagai pendekatan untuk memperbarui PostgreSQL, tetapi beberapa mengarah pada downtime.  Jika Anda ingin menghindari downtime, gunakan replikasi untuk meningkatkan - logis atau fisik (streaming), tergantung pada skenario.  Pada artikel ini, kita akan melihat perbedaan antara replikasi logis dan fisik dalam PostgreSQL.  Lalu kami akan berbicara secara rinci cara memperbarui versi menggunakan replikasi logis sambil menghindari waktu henti aplikasi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel selanjutnya akan</a> membahas replikasi fisik. </p><br><p>  Pada artikel sebelumnya, kita telah berbicara tentang metode untuk memperbarui PostgreSQL ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memutakhirkan PostgreSQL menggunakan pg_dumpall</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memutakhirkan</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PostgreSQL menggunakan pg_dump / pg_restore</a> ) sebagai bagian dari seri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Upgrade atau Migrasi Versi PostgreSQL Lama</a> .  Tetapi kedua metode ini tidak mengecualikan downtime. </p><a name="habracut"></a><br><h2 id="tipy-logicheskoy-replikacii">  Jenis Replikasi Logis </h2><br><p>  Di sini kita membahas 2 jenis replikasi: </p><br><ul><li>  Replikasi antara PostgreSQL 10 dan 11 menggunakan replikasi logis bawaan. </li><li>  Replikasi antara PostgreSQL 9.4 (atau sebelum PG 11) dan PostgreSQL 11 menggunakan ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pglogical</a> . </li></ul><br><p>  Untuk meminimalkan waktu henti, Anda dapat memutakhirkan menggunakan replikasi.  Ketika semua data yang relevan direplikasi ke server PostgreSQL terbaru lainnya, Anda cukup mentransfer aplikasi ke server baru dengan downtime minimal - walaupun, tentu saja, semua itu tergantung pada kompleksitas tumpukan aplikasi. </p><br><p>  <strong>Replikasi logis</strong> dalam PostgreSQL memungkinkan pengguna untuk mereplikasi tabel secara selektif dan membuka server cadangan untuk operasi penulisan.  <strong>Replikasi fisik</strong> dalam PostgreSQL dilakukan dalam blok.  Dalam hal ini, setiap database dalam panduan direplikasi ke server cadangan, tidak dapat diakses untuk menulis operasi.  Selanjutnya, kita akan memanggil <strong>streaming</strong> replikasi fisik. </p><br><p>  Saat menggunakan replikasi logis pada server siaga, Anda dapat mengaktifkan replikasi dari beberapa master.  Ini berguna dalam situasi di mana Anda perlu mereplikasi data dari beberapa database PostgreSQL (OLTP) ke server PostgreSQL tunggal untuk pelaporan dan penyimpanan data. </p><br><p>  Keuntungan utama dari replikasi logis daripada streaming adalah bahwa dengan replikasi logis, Anda dapat mereplikasi perubahan dari versi PostgreSQL lama ke yang baru.  Replikasi aliran hanya berfungsi ketika master dan server cadangan memiliki versi utama yang sama.  Idealnya, versi tambahan juga harus cocok. </p><br><h3 id="replikaciya-mezhdu-versiyami-postgresql-10-i-11">  Replikasi antara PostgreSQL 10 dan 11 </h3><br><p>  Dimulai dengan PostgreSQL 10, replikasi logis tersedia secara default.  Oleh karena itu, Anda dapat dengan mudah mereplikasi database PostgreSQL 10 di PostgreSQL 11. Replikasi logis menggunakan model publikasikan dan berlangganan.  Node yang mengirimkan perubahan menjadi penerbit.  Dan node yang berlangganan perubahan ini menjadi pelanggan.  Mungkin ada beberapa langganan per publikasi. </p><br><h3 id="publikaciya">  Posting </h3><br><p>  Publikasi adalah serangkaian perubahan yang dibuat oleh sekelompok tabel.  Ini disebut <strong>set</strong> <strong>perubahan</strong> atau <strong>set replikasi</strong> .  Publikasi hanya dapat berisi tabel, tetapi bukan objek lain.  DML dalam tabel ini dapat direplikasi, tetapi DDL tidak bisa. </p><br><p>  Dalam publikasi, Anda dapat memilih tipe DML mana yang akan direplikasi: INSERT, DELETE, UPDATE, atau ALL.  Secara default, ALL dipilih.  Tabel harus memiliki pengidentifikasi replika untuk mereplikasi operasi UPDATE dan DELETE kepada pelanggan.  Pengidentifikasi replika membantu Anda menemukan baris yang diperbarui atau dihapus. </p><br><p>  Kunci utama tabel adalah pengidentifikasi replika default.  Atau Anda dapat membuat pengidentifikasi sebagai indeks unik dengan nilai TIDAK NULL.  Jika Anda tidak memiliki kunci utama atau indeks unik tanpa nilai NULL, atur replica_identity ke FULL.  Dalam hal ini, Postgres menggunakan seluruh string sebagai kuncinya.  Tapi ini tidak terlalu rasional. </p><br><p>  Jika tabel tanpa kunci utama dan pengidentifikasi replika ditambahkan ke publikasi secara default setelah operasi UPDATE atau DELETE, kesalahan dapat terjadi. </p><br><h3 id="podpiska">  Berlangganan </h3><br><p>  Pelanggan dapat berlangganan satu publikasi atau lebih.  Sebelum menambahkan langganan, pastikan bahwa tabel yang direplikasi dibuat pada node pelanggan.  Untuk melakukan ini, hanya buang skema dari penerbit ke pelanggan. </p><br><h3 id="primer-logicheskoy-replikacii">  Contoh Replikasi Logis </h3><br><p>  <strong>Contoh berikut ini menjelaskan replikasi logis hanya antara PostgreSQL versi 10 dan 11.</strong> </p><br><p>  Buat publikasi di situs penerbit.  Tambahkan semua atau hanya beberapa tabel ke publikasi. </p><br><pre><code class="plaintext hljs">-- For adding ALL Tables in Database CREATE PUBLICATION percpub FOR ALL TABLES; -- For adding Selected Tables in Database CREATE PUBLICATION percpub FOR TABLE scott.employee scott.departments;</code> </pre> <br><p>  Di situs pelanggan, buat berlangganan ke publikasi ini.  Lakukan dump DDL dari tabel ke pelanggan sebelum membuat langganan, seperti yang disebutkan di atas. </p><br><pre> <code class="plaintext hljs">$ pg_dump -h publisher_server_ip -p 5432 -d percona -Fc -s -U postgres | pg_restore -d percona -h subscriber_node_ip -p 5432 -U postgres CREATE SUBSCRIPTION percsub CONNECTION 'host=publisher_server_ip dbname=percona user=postgres password=secret port=5432' PUBLICATION percpub;</code> </pre> <br><p>  Perintah ini juga menyalin data yang ada di tabel.  Jika Anda ingin menonaktifkan penyalinan data yang ada, gunakan perintah berikut dan hanya perubahan pada penerbit yang akan disalin. </p><br><pre> <code class="plaintext hljs">CREATE SUBSCRIPTION percsub CONNECTION 'host=publisher_server_ip dbname=percona user=postgres password=oracle port=5432' PUBLICATION percpub WITH (copy_data = false);</code> </pre> <br><p>  Lacak replikasi menggunakan perintah berikut di simpul penerbit: </p><br><pre> <code class="plaintext hljs">$ psql \x select * from pg_stat_replication;</code> </pre> <br><h3 id="replikaciya-mezhdu-postgresql-94-i-postgresql-11">  Replikasi antara PostgreSQL 9.4 dan PostgreSQL 11 </h3><br><p>  Apa yang harus dilakukan dengan versi sebelum PostgreSQL 10?  Untuk versi 9.4 hingga 11 ada ekstensi khusus - <code>pglogical</code> .  Menggunakan pglogical, Anda dapat mereplikasi PostgreSQL 9.4 ke PostgreSQL 11 dengan dua cara. </p><br><p>  Berikut ini adalah petunjuk umum untuk mengatur replikasi antara PG 9.4 dan PG 11 menggunakan ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pglogical</a> . </p><br><p>  <strong>Langkah 1.</strong> Pertimbangkan pgserver_94 sebagai server sumber dengan basis data percona_94 pada PostgreSQL 9.4.  Buat ekstensi berikut. <br>  kode </p><br><pre> <code class="plaintext hljs">[pgserver_94:] $psql -d percona_94 -c "CREATE EXTENSION pglogical_origin" CREATE EXTENSION [pgserver_94:] $psql -d percona_94 -c "CREATE EXTENSION pglogical" CREATE EXTENSION</code> </pre> <br><p>  <strong>Langkah 2.</strong> Sekarang tambahkan semua atau beberapa tabel ke skema atau beberapa skema untuk replikasi.  Dalam contoh berikut, Anda melihat kesalahan karena salah satu tabel tidak memiliki kunci utama. </p><br><pre> <code class="plaintext hljs">[pgserver_94:] $psql -d percona_94 psql (9.4.21) Type "help" for help. percona_94=# SELECT pglogical.create_node(node_name := 'provider1',dsn := 'host=192.168.0.24 port=5432 dbname=percona_94'); create_node ------------- 2976894835 (1 row) percona_94=# SELECT pglogical.replication_set_add_all_tables('default', ARRAY['public']); ERROR: table pgbench_history cannot be added to replication set default DETAIL: table does not have PRIMARY KEY and given replication set is configured to replicate UPDATEs and/or DELETEs HINT: Add a PRIMARY KEY to the table percona_94=# ALTER TABLE pgbench_history ADD PRIMARY KEY (tid,aid,delta); ALTER TABLE percona_94=# SELECT pglogical.replication_set_add_all_tables('default', ARRAY['public']); replication_set_add_all_tables -------------------------------- t (1 row)</code> </pre> <br><p>  <strong>Langkah 3.</strong> Pada node pelanggan, yaitu, dalam database PostgreSQL 11, jalankan perintah berikut. </p><br><pre> <code class="plaintext hljs">[pgserver_11:] $psql -d percona_11 psql (11.2) Type "help" for help. percona_11=# SELECT pglogical.create_node(node_name := 'subscriber1',dsn := 'host=127.0.0.1 port=5432 dbname=percona_11 password=secret'); create_node ------------- 330520249 (1 row) percona_11=# SELECT pglogical.create_subscription(subscription_name := 'subscription1',provider_dsn := 'host=192.168.0.24 port=5432 dbname=percona_94 password=secret'); create_subscription --------------------- 1763399739 (1 row)</code> </pre> <br><p>  <strong>Langkah 4.</strong> Kemudian periksa status replikasi dengan mengirimkan permintaan ke beberapa tabel, yang selalu diperbarui: </p><br><pre> <code class="plaintext hljs">percona_11=# select * from pglogical.local_sync_status; sync_kind | sync_subid | sync_nspname | sync_relname | sync_status | sync_statuslsn -----------+------------+--------------+------------------+-------------+---------------- f | 1763399739 | public | pgbench_accounts | r | 0/2EB7D48 f | 1763399739 | public | pgbench_history | r | 0/2EB7D48 f | 1763399739 | public | pgbench_tellers | r | 0/2EB7D48 f | 1763399739 | public | pgbench_branches | r | 0/2EB7D48 d | 1763399739 | | | r | 0/0 (5 rows) percona_11=# select * from pglogical.subscription; sub_id | sub_name | sub_origin | sub_target | sub_origin_if | sub_target_if | sub_enabled | sub_slot_name | sub_rep lication_sets | sub_forward_origins | sub_apply_delay ------------+---------------+------------+------------+---------------+---------------+-------------+----------------------------------------+---------------- -----------------------+---------------------+----------------- 1763399739 | subscription1 | 2976894835 | 330520249 | 2402836775 | 2049915666 | t | pgl_percona_11_provider1_subscription1 | {default,defaul t_insert_only,ddl_sql} | {all} | 00:00:00 (1 row)</code> </pre> <br><h3 id="vybor-pervichnogo-klyucha">  Pemilihan Kunci Utama </h3><br><p>  Pada langkah kedua, Anda melihat bagaimana semua tabel dalam skema publik ditambahkan ke set replikasi dengan membuat kunci utama untuk tabel yang tidak memiliki satu.  Saya mungkin telah memilih kunci utama yang salah untuk tabel ini, tetapi ini hanya untuk demonstrasi.  Saat memilih kunci utama, pastikan itu benar.  Itu harus unik dan menggunakan kolom yang tidak mengandung nilai NULL.  Jika Anda tidak menemukan kunci utama yang benar, ini dapat menyebabkan penghentian aplikasi.  Berikut adalah contoh kesalahan yang mungkin terjadi: </p><br><pre> <code class="plaintext hljs">[pgserver_94:] $pgbench -c 10 -T 300 -n percona_94 Client 7 aborted in state 12: ERROR: duplicate key value violates unique constraint "pgbench_history_pkey" DETAIL: Key (tid, aid, delta)=(7, 63268, 2491) already exists.</code> </pre> <br><p>  Inilah cara menggunakan pglogical untuk membuat replikasi antara versi PostgreSQL lama dan baru.  Setelah mengatur replikasi, cukup alihkan aplikasi ke versi terbaru sehingga downtime menjadi minimal. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457512/">https://habr.com/ru/post/id457512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457500/index.html">Bagaimana kami melakukan autopilot untuk stasiun layanan</a></li>
<li><a href="../id457502/index.html">Bagaimana Model Penilaian RICE Meningkatkan Prioritas Fitur Produk</a></li>
<li><a href="../id457504/index.html">Mengapa menulis Kotak Data Bereaksi Anda pada tahun 2019</a></li>
<li><a href="../id457508/index.html">Parenting vs Machine Learning: membandingkan seorang ibu muda</a></li>
<li><a href="../id457510/index.html">Gunakan mcrouter untuk mengukur memcached secara horizontal</a></li>
<li><a href="../id457514/index.html">Nevanger</a></li>
<li><a href="../id457516/index.html">Menulis Model Ancaman</a></li>
<li><a href="../id457518/index.html">Rantai Kas Plasma sebagai solusi untuk trilemma skalabilitas blockchain</a></li>
<li><a href="../id457522/index.html">Naikkan layanan milis Anda atau gunakan solusi yang sudah jadi? Apa yang saya pelajari selama 5 tahun di UniSender</a></li>
<li><a href="../id457524/index.html">Kamera kedalaman - revolusi diam (saat robot akan melihat) Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>