<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗝️ 👨‍🏭 👩‍👩‍👧‍👧 DIY Clicker ✨ 😯 🧗🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kürzlich bat mich ein Freund, bei einer Aufgabe zu helfen: einen Computer mit einem auf einem Windows-Laptop installierten Audio-Player mit einer klei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DIY Clicker</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422203/"><p>  Kürzlich bat mich ein Freund, bei einer Aufgabe zu helfen: einen Computer mit einem auf einem Windows-Laptop installierten Audio-Player mit einer kleinen Hardware-Fernbedienung zu steuern.  Ich bat alle Arten von IR-Fernbedienungen, nicht anzubieten.  Und um den AVR-e herzustellen, von dem er noch eine beträchtliche Anzahl hat, muss er langsam angebracht werden. </p><a name="habracut"></a><br><h2 id="postanovka-zadachi">  Erklärung des Problems </h2><br><p>  Die Aufgabe ist offensichtlich in zwei Teile unterteilt: </p><br><ul><li>  Mikrocontroller-Hardware und </li><li>  Software, die auf einem Computer ausgeführt wird und steuert, was sich darauf befindet. </li></ul><br><p>  Warum nicht Arduino, da wir mit AVR arbeiten? </p><br><p>  Wir stellen das Problem. <br>  Hardwareplattform: <br>  HW1.  Die Verwaltung erfolgt über Tasten ohne Fixierung; <br>  HW2.  Wir bedienen 3 Knöpfe (im Allgemeinen, wie viele haben nichts dagegen); <br>  HW3.  Durch Drücken wird die Taste mindestens 100 Millisekunden lang gedrückt. <br>  HW4.  Längere Druckvorgänge werden ignoriert.  Es wird nicht mehr als eine Taste gleichzeitig verarbeitet. <br>  HW5.  Wenn eine Taste gedrückt wird, wird eine bestimmte Aktion auf dem Computer gestartet. <br>  HW6.  Bereitstellung einer Kommunikationsschnittstelle mit einem Computer über den integrierten Serial / USB-Konverter; <br>  Softwareplattform: <br>  SW1.  Bereitstellung einer Kommunikationsschnittstelle mit einem Computer über eine auswählbare serielle Schnittstelle; <br>  SW2.  Konvertieren Sie die über die Kommunikationsschnittstelle eingehenden Befehle in die Ereignisse des Betriebssystems, die an den gewünschten Audioplayer gesendet werden. <br>  SW3.  Unterbrechen Sie die Befehlsverarbeitung.  Einschließlich eines Befehls von der Fernbedienung. </p><br><p>  Nun, es gibt eine zusätzliche Anforderung: Wenn dies keinen ernsthaften Zeitaufwand bedeutet, machen Sie die Lösungen so universell wie möglich. </p><br><h2 id="proektirovanie-i-reshenie">  Design und Lösung </h2><br><h3 id="hw1">  Hw1 </h3><br><p>  Die Tasten der Taste bleiben für kurze Zeit in der Position "gedrückt".  Darüber hinaus können die Tasten klappern (dh aufgrund instabilen Kontakts in kurzer Zeit viele Auslöser erzeugen). <br>  Es macht keinen Sinn, sie mit Interrupts zu verbinden - dafür sind die falschen Antwortzeiten erforderlich.  Wir werden ihren Status von digitalen Pins lesen.  Um ein stabiles Ablesen der Taste im ungedrückten Zustand zu gewährleisten, muss der Eingangsstift über einen Pull-up-Widerstand mit Masse (Pulldown) oder Strom (Pull-Up) verbunden werden.  Mit dem eingebauten Pull-up-Widerstand wird kein zusätzliches diskretes Element in der Schaltung hergestellt.  Einerseits verbinden wir den Knopf mit unserem Eingang, andererseits - mit dem Boden.  Hier ist das Ergebnis: <br><img src="https://habrastorage.org/webt/7p/_o/so/7p_osowau3spzfyc9oob6bi4gku.png" alt="Schaltplan"><br>  Und so - für jeden Knopf. </p><br><h3 id="hw2">  Hw2 </h3><br><p> Es gibt mehrere Schaltflächen, daher benötigen wir eine bestimmte Anzahl einheitlicher Aufzeichnungen darüber, wie Schaltflächen abgefragt werden und was zu tun ist, wenn sie gedrückt werden.  Wir schauen auf die Kapselung und erstellen die <code>Button</code> Klasse des <code>Button</code> , die die Nummer des Pins enthält, von dem aus die Umfrage durchgeführt wird (und der sie selbst initialisiert), und den Befehl, der an den Port gesendet werden muss.  Wir werden uns später mit dem Team befassen. </p><br><p>  Die Button-Klasse sieht ungefähr so ​​aus: </p><br><div class="spoiler">  <b class="spoiler_title">Tastenklassencode</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Button(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pin, ::Command command) : pin(pin), command(command) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ pinMode(pin, INPUT); digitalWrite(pin, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !digitalRead(pin); } ::<span class="hljs-function"><span class="hljs-function">Command </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Command</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> command; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pin; ::Command command; };</code> </pre> </div></div><br><p>  Nach diesem Schritt sind unsere Tasten universell und gesichtslos geworden, aber Sie können auf die gleiche Weise damit arbeiten. </p><br><p>  Setzen Sie die Tasten zusammen und weisen Sie ihnen Stifte zu: </p><br><pre> <code class="cpp hljs">Button buttons[] = { Button(A0, Command::Previous), Button(A1, Command::PauseResume), Button(A2, Command::Next), };</code> </pre> <br><p>  Die Initialisierung aller Schaltflächen erfolgt durch Aufrufen der <code>Begin()</code> -Methode für jede Schaltfläche: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;button : buttons) { button.Begin(); }</code> </pre> <br><p>  Um festzustellen, welche Taste gedrückt wird, werden wir die Tasten durchlaufen und prüfen, ob etwas gedrückt wird.  Wir geben den Tastenindex oder einen der speziellen Werte zurück: "nichts wird gedrückt" und "mehr als eine Taste wird gedrückt".  Spezielle Werte dürfen sich natürlich nicht mit gültigen Tastennummern überschneiden. </p><br><div class="spoiler">  <b class="spoiler_title">GetPressed ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = PressedNothing; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ButtonsCount; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buttons[i].IsPressed()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index == PressedNothing) { index = i; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PressedMultiple; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index; }</code> </pre> </div></div><br><h3 id="hw3">  Hw3 </h3><br><p>  Die Tasten werden mit einem bestimmten Zeitraum (z. B. 10 ms) abgefragt, und wir gehen davon aus, dass das Drücken erfolgt ist, wenn dieselbe Taste (und genau eine) für eine bestimmte Anzahl von Abfragezyklen gedrückt wurde.  Teilen Sie die Fixierungszeit (100 ms) durch die Abfragezeit (10 ms), wir erhalten 10. <br>  Wir starten einen Dekrementierungszähler, in den wir bei der ersten Fixierung des Pressens 10 schreiben und in jeder Periode dekrementieren.  Sobald es von 1 auf 0 geht, beginnen wir mit der Verarbeitung (siehe HW5) </p><br><h3 id="hw4">  Hw4 </h3><br><p>  Wenn der Zähler bereits 0 ist, wird keine Aktion ausgeführt. </p><br><h3 id="hw5">  Hw5 </h3><br><p>  Wie oben erwähnt, ist jeder Schaltfläche ein ausführbarer Befehl zugeordnet.  Es muss über die Kommunikationsschnittstelle übertragen werden. </p><br><p>  In dieser Phase können Sie eine Tastaturstrategie implementieren. </p><br><div class="spoiler">  <b class="spoiler_title">Implementierung der Hauptschleife</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleButtons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentButton = PressedNothing; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> byte counter; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> button = GetPressed(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (button == PressedMultiple || button == PressedNothing) { CurrentButton = button; counter = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (button == CurrentButton) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (--counter == <span class="hljs-number"><span class="hljs-number">0</span></span>) { InvokeCommand(buttons[button]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CurrentButton = button; counter = PressInterval / TickPeriod; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ HandleButtons(); delay(TickPeriod); }</code> </pre> </div></div><br><h3 id="hw6">  Hw6 </h3><br><p>  Die Kommunikationsschnittstelle sollte sowohl für den Absender als auch für den Empfänger klar sein.  Da die serielle Schnittstelle eine Datenübertragungseinheit von 1 Byte und eine Bytesynchronisation hat, ist es wenig sinnvoll, etwas Kompliziertes einzuschränken und uns darauf zu beschränken, ein Byte pro Befehl zu übertragen.  Zur Vereinfachung des Debuggens übertragen wir ein ASCII-Zeichen pro Befehl. </p><br><h3 id="realizaciya-na-arduino">  Arduino-Implementierung </h3><br><p>  Jetzt sammeln wir.  Der vollständige Implementierungscode wird unten unter dem Spoiler angezeigt.  Um es zu erweitern, reicht es aus, den ASCII-Code des neuen Befehls anzugeben und eine Schaltfläche daran anzuhängen. <br>  Natürlich wäre es möglich, nur explizit einen Symbolcode für jede Schaltfläche anzugeben, aber wir werden dies nicht tun: Die Befehlsbenennung ist für uns nützlich, wenn wir einen Client für einen PC implementieren. </p><br><div class="spoiler">  <b class="spoiler_title">Vollständige Implementierung</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TickPeriod = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//ms const int PressInterval = 100; //ms enum class Command : char { None = 0, Previous = 'P', Next = 'N', PauseResume = 'C', SuspendResumeCommands = '/', }; class Button { public: Button(uint8_t pin, Command command) : pin(pin), command(command) {} void Begin() { pinMode(pin, INPUT); digitalWrite(pin, 1); } bool IsPressed() { return !digitalRead(pin); } Command GetCommand() const { return command; } private: uint8_t pin; Command command; }; Button buttons[] = { Button(A0, Command::Previous), Button(A1, Command::PauseResume), Button(A2, Command::Next), Button(12, Command::SuspendResumeCommands), }; const byte ButtonsCount = sizeof(buttons) / sizeof(buttons[0]); void setup() { for (auto &amp;button : buttons) { button.Begin(); } Serial.begin(9600); } enum { PressedNothing = -1, PressedMultiple = -2, }; int GetPressed() { int index = PressedNothing; for (byte i = 0; i &lt; ButtonsCount; ++i) { if (buttons[i].IsPressed()) { if (index == PressedNothing) { index = i; } else { return PressedMultiple; } } } return index; } void InvokeCommand(const class Button&amp; button) { Serial.write((char)button.GetCommand()); } void HandleButtons() { static int CurrentButton = PressedNothing; static byte counter; int button = GetPressed(); if (button == PressedMultiple || button == PressedNothing) { CurrentButton = button; counter = -1; return; } if (button == CurrentButton) { if (counter &gt; 0) { if (--counter == 0) { InvokeCommand(buttons[button]); return; } } } else { CurrentButton = button; counter = PressInterval / TickPeriod; } } void loop() { HandleButtons(); delay(TickPeriod); }</span></span></code> </pre> </div></div><br><p>  Und ja, ich habe eine weitere Schaltfläche erstellt, um die Übertragung von Befehlen an den Client anzuhalten. </p><br><h3 id="klient-dlya-pk">  Client für PC </h3><br><p>  Wir gehen zum zweiten Teil über. <br>  Da wir keine komplexe Benutzeroberfläche und keine Bindung an Windows benötigen, können wir auf verschiedene Arten vorgehen: WinAPI, MFC, Delphi, .NET (Windows Forms, WPF usw.) oder Konsolen auf denselben Plattformen ( gut, außer MFC). </p><br><h3 id="sw1">  SW1 </h3><br><p>  Diese Anforderung wird durch die Kommunikation mit der seriellen Schnittstelle auf der ausgewählten Softwareplattform geschlossen: Verbindung zur Schnittstelle herstellen, Bytes lesen, Bytes verarbeiten. </p><br><h3 id="sw2">  SW2 </h3><br><p>  Vielleicht hat jeder Tastaturen mit Multimedia-Tasten gesehen.  Jede Taste auf der Tastatur, einschließlich der Multimedia-Taste, verfügt über einen eigenen Code.  Die einfachste Lösung für unser Problem besteht darin, die Tastenanschläge von Multimedia-Tasten auf der Tastatur zu simulieren.  Schlüsselcodes finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalquelle - MSDN</a> .  Es bleibt zu lernen, wie man sie an das System sendet.  Dies ist auch nicht schwierig: In WinAPI gibt es eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SendInput-</a> Funktion. <br>  Jeder Tastendruck besteht aus zwei Ereignissen: Drücken und Loslassen. <br>  Wenn wir C / C ++ verwenden, können wir einfach die Header-Dateien einschließen.  In anderen Sprachen muss die Anrufweiterleitung erfolgen.  Wenn Sie beispielsweise in .NET entwickeln, müssen Sie die angegebene Funktion importieren und die Argumente beschreiben.  Ich habe mich für .NET entschieden, um eine Schnittstelle zu entwickeln. <br>  Ich habe aus dem Projekt nur den inhaltlichen Teil ausgewählt, der sich auf eine Klasse beschränkt: <code>Internals</code> . <br>  Hier ist sein Code: </p><br><div class="spoiler">  <b class="spoiler_title">Interna mit Klassencode</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Internals</span></span> { [StructLayout(LayoutKind.Sequential)] [DebuggerDisplay(<span class="hljs-string"><span class="hljs-string">"{Type} {Data}"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> INPUT { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Type; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KEYBDINPUT Data; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Keyboard = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Size = Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(INPUT)); } [StructLayout(LayoutKind.Sequential)] [DebuggerDisplay(<span class="hljs-string"><span class="hljs-string">"Vk={Vk} Scan={Scan} Flags={Flags} Time={Time} ExtraInfo={ExtraInfo}"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> KEYBDINPUT { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> Vk; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> Scan; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Flags; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Time; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IntPtr ExtraInfo; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> spare; } [DllImport(<span class="hljs-string"><span class="hljs-string">"user32.dll"</span></span>, SetLastError = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">uint</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numberOfInputs, INPUT[] inputs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sizeOfInputStructure</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> INPUT[] inputs = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> INPUT { Type = INPUT.Keyboard, Data = { Flags = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">// Push } }, new INPUT { Type = INPUT.Keyboard, Data = { Flags = 2 // Release } } }; public static void SendKey(Keys key) { inputs[0].Data.Vk = (ushort) key; inputs[1].Data.Vk = (ushort) key; SendInput(2, inputs, INPUT.Size); } }</span></span></code> </pre> </div></div><br><p>  Zunächst werden die Datenstrukturen (nur was mit der Tastatureingabe zusammenhängt, wird abgeschnitten, da wir sie simulieren) und der <code>SendInput</code> Import <code>SendInput</code> . <br>  Das <code>inputs</code> besteht aus zwei Elementen, mit denen Tastaturereignisse generiert werden.  Es macht keinen Sinn, es dynamisch zuzuweisen, wenn die Anwendungsarchitektur davon ausgeht, dass <code>SendKey</code> nicht in mehreren Threads <code>SendKey</code> wird. <br>  Eigentlich ist die technische Angelegenheit weiter: Wir füllen die entsprechenden Strukturfelder mit dem virtuellen Schlüsselcode aus und senden ihn an die Eingabewarteschlange des Betriebssystems. </p><br><h3 id="sw3">  SW3 </h3><br><p>  Die Anforderung schließt sehr einfach.  Das Flag wird gehisst und ein anderer Befehl wird auf besondere Weise verarbeitet: Das Flag wechselt in den entgegengesetzten logischen Zustand.  Wenn es gesetzt ist, werden die restlichen Befehle ignoriert. </p><br><h2 id="vmesto-zaklyucheniya">  Anstelle einer Schlussfolgerung </h2><br><p>  Verbesserungen können endlos durchgeführt werden, aber das ist eine andere Geschichte.  Ich präsentiere hier kein Windows-Client-Projekt, da es einen großen Vorstellungsspielraum bietet. <br>  Um den Media Player zu steuern, senden wir einen Satz Tastenanschläge, wenn Sie Präsentationen verwalten müssen, einen anderen.  Sie können Steuermodule erstellen, entweder statisch oder als Plug-Ins zusammenbauen.  Im Allgemeinen sind viele Dinge möglich.  Die Hauptsache ist das Verlangen. </p><br><p>  Vielen Dank für Ihre Aufmerksamkeit. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422203/">https://habr.com/ru/post/de422203/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422191/index.html">Wie ich eine profitable Android-Texterkennungsanwendung erstellt habe</a></li>
<li><a href="../de422195/index.html">Die Verwendung von ACS im Bergbau</a></li>
<li><a href="../de422197/index.html">Wir sagen ein Wort über die Staffel</a></li>
<li><a href="../de422199/index.html">Sicherheitswoche 33: Von wem schwingt der Monitor?</a></li>
<li><a href="../de422201/index.html">China, lass mich abschreiben?</a></li>
<li><a href="../de422205/index.html">Richard Hamming: Kapitel 13. Informationstheorie</a></li>
<li><a href="../de422207/index.html">Monster nach den Ferien: AMD Threadripper 2990WX 32-Core und 2950X 16-Core (Teil 4)</a></li>
<li><a href="../de422209/index.html">Monster nach den Ferien: AMD Threadripper 2990WX 32-Core und 2950X 16-Core (Teil 5)</a></li>
<li><a href="../de422211/index.html">Schöne Komponentenstruktur in der Microsoft Azure Cloud</a></li>
<li><a href="../de422213/index.html">Eines Tages ohne JavaScript: Was könnte schief gehen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>