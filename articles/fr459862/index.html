<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖüèæ üöµ üïó Interface Berkeley DB STL üë®üèª‚Äçüíª üßîüèø üåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, Habr. Il n'y a pas si longtemps, pour l'un de mes projets, j'avais besoin d'une base de donn√©es int√©gr√©e qui stockerait des √©l√©ments de valeur-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interface Berkeley DB STL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459862/"><p>  Salut, Habr.  Il n'y a pas si longtemps, pour l'un de mes projets, j'avais besoin d'une base de donn√©es int√©gr√©e qui stockerait des √©l√©ments de valeur-cl√©, fournirait un support de transaction et, √©ventuellement, des donn√©es chiffr√©es.  Apr√®s une courte recherche, je suis tomb√© sur un projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Berkeley DB</a> .  En plus des fonctionnalit√©s dont j'ai besoin, cette base de donn√©es fournit une interface compatible STL qui vous permet de travailler avec la base de donn√©es comme avec un conteneur STL normal (presque ordinaire).  En fait, cette interface sera discut√©e ci-dessous. </p><a name="habracut"></a><br><h2 id="berkeley-db">  Berkeley db </h2><br><p>  <strong>Berkeley DB</strong> est une base de donn√©es open source int√©gr√©e, √©volutive et hautes performances.  Il est disponible gratuitement pour une utilisation dans <strong>des</strong> projets <strong>open source</strong> , mais pour les projets propri√©taires, il existe des limitations importantes.  Fonctionnalit√©s prises en charge: </p><br><ul><li>  transactions </li><li>  journal de secours pour le basculement </li><li>  <strong>Cryptage des</strong> donn√©es <strong>AES</strong> </li><li>  r√©plication </li><li>  indices </li><li>  outils de synchronisation pour les applications multithread </li><li>  politique d'acc√®s - un √©crivain, plusieurs lecteurs </li><li>  mise en cache </li></ul><br><p>  Et bien d'autres. </p><br><p>  Une fois le syst√®me initialis√©, l'utilisateur peut sp√©cifier les sous-syst√®mes √† utiliser.  Cela √©limine le gaspillage de ressources sur des op√©rations telles que les transactions, la journalisation, les verrous lorsqu'ils ne sont pas n√©cessaires. </p><br><p>  Le choix de la structure de stockage et de l'acc√®s aux donn√©es est disponible: </p><br><ul><li>  <strong>Btree</strong> - impl√©mentation d'un arbre √©quilibr√© tri√© </li><li>  <strong>Hash</strong> - impl√©mentation de hachage lin√©aire </li><li>  <strong>Tas</strong> - utilise un <em>fichier tas</em> logiquement pagin√© pour le stockage.  Chaque entr√©e est identifi√©e par une page et un d√©calage √† l'int√©rieur.  Le stockage est organis√© de telle mani√®re que la suppression d'un enregistrement ne n√©cessite pas de compactage.  Cela vous permet de l'utiliser avec un manque d'espace physique. </li><li>  <strong>File d'attente</strong> - une file d'attente qui stocke des enregistrements d'une longueur fixe avec un num√©ro logique comme cl√©.  Il est con√ßu pour une insertion rapide √† la fin et prend en charge une op√©ration sp√©ciale qui supprime et renvoie une entr√©e de la t√™te de la file d'attente en un seul appel. </li><li>  <strong>Recno</strong> - vous permet de sauvegarder des enregistrements de longueurs fixes et variables avec un num√©ro logique comme cl√©.  Fournit l'acc√®s √† un √©l√©ment par son index. </li></ul><br><p>  Pour √©viter toute ambigu√Øt√©, il est n√©cessaire de d√©finir plusieurs concepts utilis√©s pour d√©crire le travail de <strong>Berkeley DB</strong> . </p><br><p>  <em>La base de donn√©es</em> est un stockage de <em>donn√©es</em> cl√©-valeur.  Un analogue de <em>la</em> base de donn√©es <strong>Berkeley DB</strong> dans d'autres SGBD peut √™tre un tableau. </p><br><p>  <em>Un environnement de base de donn√©es</em> est un wrapper pour une ou plusieurs <em>bases de donn√©es</em> .  D√©finit les param√®tres g√©n√©raux de toutes les <em>bases de donn√©es</em> , tels que la taille du cache, les chemins de stockage des fichiers, l'utilisation et la configuration des sous-syst√®mes de blocage, de transaction et de journalisation. </p><br><p>  Dans un cas d'utilisation typique, un <em>environnement</em> est cr√©√© et configur√©, et il poss√®de une ou plusieurs <em>bases de donn√©es</em> . </p><br><h2 id="stl-interfeys">  Interface STL </h2><br><p>  <strong>Berkeley DB</strong> est une biblioth√®que √©crite en <strong>C.</strong>  Il a des classeurs pour des langages tels que <strong>Perl</strong> , <strong>Java</strong> , <strong>PHP</strong> et autres.  L'interface pour <strong>C ++</strong> est un wrapper sur du code <strong>C</strong> avec des objets et l'h√©ritage.  Afin de permettre d'acc√©der √† la base de donn√©es de mani√®re similaire aux op√©rations avec des conteneurs <strong>STL</strong> , il existe une interface <strong>STL en</strong> tant que module compl√©mentaire sur <strong>C ++</strong> .  Sous une forme graphique, les couches d'interface ressemblent √† ceci: </p><br><p><img src="https://habrastorage.org/webt/k9/0u/gw/k90ugwajcb5xsts9zxn7e6urjew.png"></p><br><p> Ainsi, l'interface <strong>STL</strong> vous permet d'obtenir un √©l√©ment de la base de donn√©es par cl√© (pour <strong>Btree</strong> ou <strong>Hash</strong> ) ou par index (pour <strong>Recno</strong> ) de mani√®re similaire aux <code>std::map</code> ou <code>std::vector</code> , recherchez un √©l√©ment dans la base de donn√©es via l' <code>std::find_if</code> , parcourir toute la base de donn√©es via la <code>foreach</code> .  Toutes les classes et fonctions de l'interface <strong>Berkeley DB</strong> <strong>STL se</strong> trouvent dans l' <strong>espace de</strong> noms <strong>dbstl</strong> , pour faire court, <strong>dbstl</strong> signifiera √©galement l'interface <strong>STL</strong> . </p><br><h2 id="ustanovka">  L'installation </h2><br><p>  La base de donn√©es prend en charge la plupart <strong>des</strong> <strong>plates</strong> - <strong>formes</strong> <strong>Linux</strong> , <strong>Windows</strong> , <strong>Android</strong> , <strong>Apple iOS</strong> , etc. </p><br><p>  Pour <strong>Ubuntu 18.04,</strong> installez simplement les packages: </p><br><ul><li>  libdb5.3-stl-dev </li><li>  libdb5.3 ++ - dev </li></ul><br><p>  Pour construire √† partir de sources <strong>Linux</strong> , vous devez installer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autoconf</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libtool</a> .  Le dernier code source peut √™tre trouv√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Par exemple, j'ai t√©l√©charg√© l'archive avec la version <strong>18.1.32</strong> - db-18.1.32.zip.  Vous devez d√©compresser l'archive et aller dans le dossier source: </p><br><pre> <code class="plaintext hljs">unzip db-18.1.32.zip cd db-18.1.32</code> </pre> <br><p>  Ensuite, nous passons au r√©pertoire <strong>build_unix</strong> et <strong>ex√©cutons</strong> l'assemblage et l'installation: </p><br><pre> <code class="plaintext hljs">cd build_unix ../dist/configure --enable-stl --prefix=/home/user/libraries/berkeley-db make make install</code> </pre> <br><h2 id="dobavlenie-v-cmake-proekt">  Ajout au projet cmake </h2><br><p>  Le projet <strong>BerkeleyDBSamples</strong> est utilis√© pour illustrer des exemples avec <strong>Berkeley DB</strong> . </p><br><p>  La structure du projet est la suivante: </p><br><pre> <code class="plaintext hljs">+-- CMakeLists.txt +-- sample-usage | +-- CMakeLists.txt | +-- sample-map-usage.cpp | +-- submodules | +-- cmake | | +-- FindBerkeleyDB</code> </pre> <br><p>  La racine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CMakeLists.txt</a> d√©crit les param√®tres g√©n√©raux du projet.  Des exemples de fichiers source sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilis√©s</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sample-usage / CMakeLists.txt</a> recherche des biblioth√®ques, d√©finit l'assemblage d'exemples. </p><br><p>  Dans les exemples, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FindBerkeleyDB</a> est utilis√© pour connecter la biblioth√®que au projet <strong>cmake</strong> .  Il est ajout√© sous forme de sous-module <strong>git</strong> dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sous-modules / cmake</a> .  Lors de l'assemblage, vous devrez peut-√™tre sp√©cifier <code>BerkeleyDB_ROOT_DIR</code> .  Par exemple, pour la biblioth√®que ci-dessus install√©e √† partir des sources, vous devez sp√©cifier l'indicateur <strong>cmake</strong> <code>-DBerkeleyDB_ROOT_DIR=/home/user/libraries/berkeley-db</code> . </p><br><p>  Dans le fichier racine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CMakeLists.txt</a> , ajoutez le chemin d'acc√®s au module <strong>FindBerkeleyDB</strong> √† <strong>CMAKE_MODULE_PATH</strong> : </p><br><pre> <code class="plaintext hljs">list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/submodules/cmake/FindBerkeleyDB")</code> </pre> <br><p>  Apr√®s cela, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sample-usage / CMakeLists.txt</a> effectue une recherche de biblioth√®que de la mani√®re standard: </p><br><pre> <code class="plaintext hljs">find_package(BerkeleyDB REQUIRED)</code> </pre> <br><p>  Ensuite, ajoutez le fichier ex√©cutable et liez-le √† la biblioth√®que <strong>Oracle :: BerkeleyDB</strong> : </p><br><pre> <code class="plaintext hljs">add_executable(sample-map-usage "sample-map-usage.cpp") target_link_libraries(sample-map-usage PRIVATE Oracle::BerkeleyDB ${CMAKE_THREAD_LIBS_INIT} stdc++fs)</code> </pre> <br><h2 id="prakticheskiy-primer">  Exemple pratique </h2><br><p>  Pour d√©montrer l'utilisation de <strong>dbstl,</strong> examinons un exemple simple du fichier <a href="">sample-map-usage.cpp</a> .  Cette application montre <code>dbstl::db_map</code> travailler avec le <code>dbstl::db_map</code> dans un programme √† thread unique.  Le conteneur lui-m√™me est similaire √† <code>std::map</code> et stocke les donn√©es sous forme de paire cl√© / valeur.  La structure de base de donn√©es sous-jacente peut √™tre <strong>Btree</strong> ou <strong>Hash</strong> .  Contrairement √† <code>std::map</code> , pour le <code>dbstl::db_map&lt;std::string, TestElement&gt;</code> type de valeur r√©el est <code>dbstl::ElementRef&lt;TestElement&gt;</code> .  Ce type est retourn√©, par exemple, pour <code>dbstl::db_map&lt;std::string, TestElement&gt;::operator[]</code> .  Il d√©finit les m√©thodes de stockage d'un objet de type <code>TestElement</code> dans la base de donn√©es.  Une telle m√©thode est <code>operator=</code> . </p><br><p>  Dans l'exemple, le travail avec la base de donn√©es est le suivant: </p><br><ul><li>  application appelle les m√©thodes <strong>Berkeley DB</strong> pour acc√©der aux donn√©es </li><li>  ces m√©thodes acc√®dent au cache pour la lecture ou l'√©criture </li><li>  si n√©cessaire, l'acc√®s se fait directement au fichier de donn√©es </li></ul><br><p>  Graphiquement, ce processus est illustr√© dans la figure: </p><br><p><img src="https://habrastorage.org/webt/xm/em/or/xmemorwh73yw9mnue-h1lp0gmbo.png"></p><br><p>  Pour r√©duire la complexit√© de l'exemple, il n'utilise pas la gestion des exceptions.  Certaines <strong>m√©thodes de</strong> conteneur <strong>dbstl</strong> peuvent <strong>lever</strong> des exceptions lorsque des erreurs se produisent. </p><br><h2 id="razbor-koda">  Analyse de code </h2><br><p>  Pour travailler avec <strong>Berkeley DB,</strong> vous devez connecter deux fichiers d'en-t√™te: </p><br><pre> <code class="plaintext hljs">#include &lt;db_cxx.h&gt; #include &lt;dbstl_map.h&gt;</code> </pre> <br><p>  La premi√®re ajoute des primitives d'interface <strong>C ++</strong> et la seconde d√©finit des classes et des fonctions pour travailler avec la base de donn√©es, comme avec un conteneur associatif, ainsi que de nombreuses m√©thodes utilitaires.  <strong>L'</strong> interface <strong>STL</strong> est situ√©e dans l'espace de noms <strong>dbstl</strong> . </p><br><p>  Pour le stockage, la structure <strong>Btree</strong> est <strong>utilis√©e</strong> , <code>std::string</code> agit comme la cl√© et la valeur est la structure utilisateur <code>TestElement</code> : </p><br><pre> <code class="plaintext hljs">struct TestElement{ std::string id; std::string name; };</code> </pre> <br><p>  Dans la fonction <code>main</code> , initialisez la biblioth√®que en appelant <code>dbstl::dbstl_startup()</code> .  Il doit √™tre localis√© avant la premi√®re utilisation des primitives de l'interface <strong>STL</strong> . </p><br><p>  Apr√®s cela, nous initialisons et ouvrons <em>l'environnement de base de donn√©es</em> dans le r√©pertoire d√©fini par la variable <code>ENV_FOLDER</code> : </p><br><pre> <code class="plaintext hljs">auto penv = dbstl::open_env(ENV_FOLDER, 0u, DB_INIT_MPOOL | DB_CREATE);</code> </pre> <br><p>  L'indicateur <code>DB_INIT_MPOOL</code> responsable de l'initialisation du sous-syst√®me de mise en cache, <code>DB_CREATE</code> - pour cr√©er tous les fichiers n√©cessaires √† l'environnement.  L'√©quipe enregistre √©galement cet objet dans le gestionnaire de ressources.  Il est responsable de la fermeture de tous les objets enregistr√©s (les objets de base de donn√©es, les curseurs, les transactions, etc. y sont √©galement enregistr√©s) et de vider la m√©moire dynamique.  Si vous avez d√©j√† un objet d' <em>environnement de base de donn√©es</em> et que vous avez seulement besoin de l'enregistrer aupr√®s du gestionnaire de ressources, vous pouvez utiliser la fonction <code>dbstl::register_db_env</code> . </p><br><p>  Une op√©ration similaire est effectu√©e avec <em>la base de donn√©es</em> : </p><br><pre> <code class="plaintext hljs">auto db = dbstl::open_db(penv, "sample-map-usage.db", DB_BTREE, DB_CREATE, 0u);</code> </pre> <br><p>  Les donn√©es sur le disque seront √©crites dans le <strong>fichier sample-map-usage.db</strong> , qui sera cr√©√© en l'absence (gr√¢ce √† l'indicateur <code>DB_CREATE</code> ) dans le r√©pertoire <code>ENV_FOLDER</code> .  Une arborescence est utilis√©e pour le stockage (param√®tre <code>DB_BTREE</code> ). </p><br><p>  Dans <strong>Berkeley DB, les</strong> cl√©s et les valeurs sont stock√©es sous la forme d'un tableau d'octets.  Pour utiliser un type personnalis√© (dans notre cas <code>TestElement</code> ), vous devez d√©finir des fonctions pour: </p><br><ul><li>  recevoir le nombre d'octets pour stocker l'objet; </li><li>  marshaling d'un objet dans un tableau d'octets; </li><li>  d√©m√™ler. </li></ul><br><p>  Dans l'exemple, cette fonctionnalit√© est effectu√©e par les m√©thodes statiques de la classe <code>TestMarshaller</code> .  Il <code>TestElement</code> objets <code>TestElement</code> en m√©moire comme suit: </p><br><ul><li>  la longueur du champ <code>id</code> est copi√©e au d√©but du tampon </li><li>  octet suivant le contenu du champ <code>id</code> est plac√© </li><li>  apr√®s cela, la taille du champ de <code>name</code> est copi√©e </li><li>  puis le contenu lui-m√™me est plac√© dans le champ du <code>name</code> </li></ul><br><p><img src="https://habrastorage.org/webt/ko/ad/ul/koaduleknjbnfvapxlo6wff4qvm.png"></p><br><p>  Nous d√©crivons les fonctions de <code>TestMarshaller</code> : </p><br><ul><li>  <code>TestMarshaller::restore</code> - remplit l'objet <code>TestElement</code> avec les donn√©es du tampon </li><li>  <code>TestMarshaller::size</code> - retourne la taille du tampon qui est n√©cessaire pour enregistrer l'objet sp√©cifi√©. </li><li>  <code>TestMarshaller::store</code> - enregistre l'objet dans le tampon. </li></ul><br><p>  Pour enregistrer les fonctions de marshaling / <code>dbstl::DbstlElemTraits</code> , utilisez <code>dbstl::DbstlElemTraits</code> : </p><br><pre> <code class="plaintext hljs">dbstl::DbstlElemTraits&lt;TestElement&gt;::instance()-&gt;set_size_function(&amp;TestMarshaller::size); dbstl::DbstlElemTraits&lt;TestElement&gt;::instance()-&gt;set_copy_function(&amp;TestMarshaller::store); dbstl::DbstlElemTraits&lt;TestElement&gt;::instance()-&gt;set_restore_function( &amp;TestMarshaller::restore );</code> </pre> <br><p>  Initialisez le conteneur: </p><br><pre> <code class="plaintext hljs">dbstl::db_map&lt;std::string, TestElement&gt; elementsMap(db, penv);</code> </pre> <br><p>  Voici √† quoi ressemble la copie des √©l√©ments de <code>std::map</code> vers le conteneur cr√©√©: </p><br><pre> <code class="plaintext hljs">std::copy( std::cbegin(inputValues), std::cend(inputValues), std::inserter(elementsMap, elementsMap.begin()) );</code> </pre> <br><p>  Mais de cette fa√ßon, vous pouvez imprimer le contenu de la base de donn√©es sur la sortie standard: </p><br><pre> <code class="plaintext hljs">std::transform( elementsMap.begin(dbstl::ReadModifyWriteOption::no_read_modify_write(), true), elementsMap.end(), std::ostream_iterator&lt;std::string&gt;(std::cout, "\n"), [](const auto data) -&gt; std::string { return data.first + "=&gt; { id: " + data.second.id + ", name: " + data.second.name + "}"; });</code> </pre> <br><p>  L'appel de la m√©thode <code>begin</code> dans l'exemple ci-dessus semble un peu inhabituel: <code>elementsMap.begin(dbstl::ReadModifyWriteOption::no_read_modify_write(), true)</code> . <br>  Cette conception est utilis√©e pour obtenir <em>un</em> it√©rateur en <em>lecture seule</em> .  <strong>dbstl</strong> ne d√©finit pas la m√©thode <code>cbegin</code> ; √† la place, le param√®tre en <code>readonly</code> (le second) de la m√©thode <code>begin</code> est utilis√©.  Vous pouvez √©galement utiliser une <em>r√©f√©rence constante</em> au conteneur pour obtenir <em>un</em> it√©rateur en <em>lecture seule</em> .  Un tel it√©rateur ne permet qu'une op√©ration de lecture; lors de l'√©criture, il l√®vera une exception. </p><br><p>  Pourquoi l'it√©rateur en <em>lecture seule est-il</em> utilis√© dans le code ci-dessus?  Tout d'abord, il effectue <em>simplement</em> une op√©ration de lecture via un it√©rateur.  Deuxi√®mement, la documentation indique qu'elle a de <em>meilleures</em> performances par rapport √† la version r√©guli√®re. </p><br><p>  Ajouter une nouvelle paire cl√© / valeur ou, si la cl√© existe d√©j√†, mettre √† jour la valeur est aussi simple que dans <code>std::map</code> : </p><br><pre> <code class="plaintext hljs">elementsMap["added key 1"] = {"added id 1", "added name 1"};</code> </pre> <br><p>  Comme mentionn√© ci-dessus, l'instruction <code>elementsMap["added key 1"]</code> renvoie une classe wrapper avec <code>operator=</code> redefined, dont l'appel suivant stocke directement l'objet dans la base de donn√©es. </p><br><p>  Si vous devez ins√©rer un √©l√©ment dans un conteneur: </p><br><pre> <code class="plaintext hljs">auto [iter, res] = elementsMap.insert( std::make_pair(std::string("added key 2"), TestElement{"added id 2", "added name 2"}) );</code> </pre> <br><p>  L'appel √† <code>elementsMap.insert</code> renvoie <code>std::pair&lt;,  &gt;</code> .  Si l'objet ne peut pas √™tre ins√©r√©, l' <em>indicateur de r√©ussite</em> sera <strong>faux</strong> .  Sinon, <em>l'indicateur de r√©ussite</em> contient <strong>true</strong> et l' <em>it√©rateur</em> pointe vers l'objet ins√©r√©. </p><br><p>  Une autre fa√ßon de trouver la valeur par cl√© est d'utiliser la <code>dbstl::db_map::find</code> , similaire √† <code>std::map::find</code> : </p><br><pre> <code class="plaintext hljs">auto findIter = elementsMap.find("test key 1");</code> </pre> <br><p>  Gr√¢ce √† l'it√©rateur obtenu, vous pouvez acc√©der √† la cl√© - <code>findIter-&gt;first</code> , aux champs de l'√©l√©ment <code>findIter-&gt;second.id</code> - <code>findIter-&gt;second.id</code> et <code>findIter-&gt;second.name</code> .  Pour extraire une paire <em>cl√©</em> / <em>valeur</em> , l'op√©rateur de d√©r√©f√©rence est utilis√© - <code>auto iterPair = *findIter;</code>  . </p><br><p>  Lorsque l'op√©rateur de d√©r√©f√©rencement ( <strong>*</strong> ) ou l'acc√®s √† un membre de la classe ( <strong>-&gt;</strong> ) est appliqu√© √† l'it√©rateur, la base de donn√©es est accessible et les donn√©es en sont extraites.  De plus, les donn√©es extraites pr√©c√©demment, m√™me si elles ont √©t√© modifi√©es, sont effac√©es.  Cela signifie que dans l'exemple ci-dessous, les modifications apport√©es √† l'it√©rateur seront ignor√©es et la valeur stock√©e dans la base de donn√©es sera affich√©e sur la console. </p><br><pre> <code class="plaintext hljs">findIter-&gt;second.id = "skipped id"; findIter-&gt;second.name = "skipped name"; std::cout &lt;&lt; "Found elem for key " &lt;&lt; "test key 1" &lt;&lt; ": id: " &lt;&lt; findIter-&gt;second.id &lt;&lt; ", name: " &lt;&lt; findIter-&gt;second.name &lt;&lt; std::endl;</code> </pre> <br><p>  Pour √©viter cela, vous devez obtenir l'encapsuleur de l'objet stock√© √† partir de l'it√©rateur en appelant <code>findIter-&gt;second</code> et l'enregistrer dans une variable.  Ensuite, apportez toutes les modifications sur ce wrapper et √©crivez le r√©sultat dans la base de donn√©es en appelant la m√©thode de wrapper <code>_DB_STL_StoreElement</code> : </p><br><pre> <code class="plaintext hljs">auto ref = findIter-&gt;second; ref.id = "new test id 1"; ref.name = "new test name 1"; ref._DB_STL_StoreElement();</code> </pre> <br><p>  La mise √† jour des donn√©es peut √™tre encore plus facile - il suffit d'obtenir le wrapper avec l'instruction <code>findIter-&gt;second</code> et de lui affecter l'objet <code>TestElement</code> souhait√©, comme dans l'exemple: </p><br><pre> <code class="plaintext hljs">if(auto findIter = elementsMap.find("test key 2"); findIter != elementsMap.end()){ findIter-&gt;second = {"new test id 2", "new test name 2"}; }</code> </pre> <br><p>  Avant de terminer le programme, vous devez appeler <code>dbstl::dbstl_exit();</code>  pour fermer et supprimer tous les objets enregistr√©s dans le gestionnaire de ressources. </p><br><h2 id="v-zaklyuchenii">  En conclusion </h2><br><p>  Cet article fournit un bref aper√ßu des principales fonctionnalit√©s des conteneurs <code>dbstl::db_map</code> <strong>utilisant</strong> <code>dbstl::db_map</code> comme <code>dbstl::db_map</code> dans un programme simple √† thread unique.  Ceci n'est qu'une petite introduction et n'a pas couvert les fonctionnalit√©s telles que la transactionnalit√©, le verrouillage, la gestion des ressources, la gestion des exceptions et l'ex√©cution multithread. </p><br><p>  Je n'ai pas cherch√© √† d√©crire en d√©tail les m√©thodes et leurs param√®tres, pour cela il vaut mieux se r√©f√©rer √† la documentation correspondante sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interface C ++</a> et sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interface STL</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459862/">https://habr.com/ru/post/fr459862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459844/index.html">Pingouin dans la fen√™tre: sur le potentiel et les perspectives de WSL2</a></li>
<li><a href="../fr459850/index.html">Technologie radioamateur: comment j'ai command√© l'installation d'une carte de circuit imprim√© dans une usine chinoise</a></li>
<li><a href="../fr459852/index.html">La pratique de l'utilisation de la biblioth√®que Lottie dans l'application mobile de la banque</a></li>
<li><a href="../fr459858/index.html">Explorer les logiciels malveillants modernes Cerberus pour Android</a></li>
<li><a href="../fr459860/index.html">Configurer ClickHouse pour les tests d'int√©gration dans gitlab-ci</a></li>
<li><a href="../fr459866/index.html">R√©solution de probl√®mes avec pwnable.kr 02 - collision. Collision de hachage</a></li>
<li><a href="../fr459870/index.html">Exemple d'architecture Model-View-Update en F #</a></li>
<li><a href="../fr459872/index.html">Patton Jeff. Histoires personnalis√©es. L'art du d√©veloppement logiciel agile</a></li>
<li><a href="../fr459874/index.html">Tu as quelque chose √† cacher</a></li>
<li><a href="../fr459878/index.html">7 conseils d'optimisation CSS pour acc√©l√©rer le chargement des pages</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>