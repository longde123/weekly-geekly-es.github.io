<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤¢ ğŸ’¦ ğŸ‘§ğŸ¼ NL2API: Membuat Antarmuka Bahasa Alami untuk API Web ğŸ“ ğŸ˜ï¸ ğŸ•œ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Baru-baru ini, kami secara singkat berbicara tentang Antarmuka Bahasa Alami. Nah, hari ini kita belum sempat. Di bawah potongan Anda akan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NL2API: Membuat Antarmuka Bahasa Alami untuk API Web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/418559/">  Halo, Habr!  Baru-baru ini, kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara singkat berbicara</a> tentang Antarmuka Bahasa Alami.  Nah, hari ini kita belum sempat.  Di bawah potongan Anda akan menemukan cerita lengkap tentang membuat NL2API untuk Web-API.  Rekan-rekan kami dari Research telah mencoba pendekatan unik untuk mengumpulkan data pelatihan untuk kerangka kerja.  Bergabunglah sekarang! <br><br><img src="https://habrastorage.org/webt/ry/bd/kj/rybdkjnazdjarwxlrggugof4pja.jpeg"><a name="habracut"></a><br><br><h2>  Anotasi </h2><br>  Ketika Internet berevolusi menuju arsitektur berorientasi layanan, antarmuka perangkat lunak (API) menjadi semakin penting sebagai cara untuk menyediakan akses ke data, layanan, dan perangkat.  Kami sedang mengerjakan masalah membuat antarmuka bahasa alami untuk API (NL2API), dengan fokus pada layanan web.  Solusi NL2API memiliki banyak manfaat potensial, misalnya, membantu menyederhanakan integrasi layanan web menjadi asisten virtual. <br><br>  Kami menawarkan platform komprehensif pertama (kerangka kerja) yang memungkinkan Anda membuat NL2API untuk API web tertentu.  Tugas utamanya adalah mengumpulkan data untuk pelatihan, yaitu pasangan â€œperintah NL - panggilan APIâ€, memungkinkan NL2API mempelajari semantik dari kedua perintah NL yang tidak memiliki format yang ditentukan secara ketat dan panggilan API yang diformalkan.  Kami menawarkan pendekatan unik kami sendiri untuk mengumpulkan data pelatihan untuk NL2API menggunakan crowdsourcing - menarik banyak pekerja jarak jauh untuk menghasilkan berbagai tim NL.  Kami mengoptimalkan proses crowdsourcing itu sendiri untuk mengurangi biaya. <br><br>  Secara khusus, kami menawarkan model probabilistik hierarkis yang secara fundamental baru yang akan membantu kami mendistribusikan anggaran untuk crowdsourcing, terutama di antara panggilan API yang bernilai tinggi untuk mempelajari NL2API.  Kami menerapkan kerangka kerja kami pada API nyata dan menunjukkan bahwa ini memungkinkan Anda mengumpulkan data pelatihan berkualitas tinggi dengan biaya minimal, serta membuat NL2API berkinerja tinggi dari awal.  Kami juga menunjukkan bahwa model crowdsourcing kami meningkatkan efisiensi proses ini, yaitu, data pelatihan yang dikumpulkan dalam kerangka kerjanya memberikan kinerja NL2API yang lebih tinggi, yang secara signifikan melebihi baseline. <br><br><h2>  Pendahuluan </h2><br>  Antarmuka pemrograman aplikasi (API) memainkan peran yang semakin penting baik di dunia virtual maupun fisik, berkat pengembangan teknologi seperti arsitektur berorientasi layanan (SOA), komputasi awan, dan Internet of things (IoT).  Misalnya, layanan web yang dihosting di cloud (cuaca, olahraga, keuangan, dll.) Melalui API web menyediakan data dan layanan kepada pengguna akhir, dan perangkat IoT memungkinkan perangkat jaringan lain untuk menggunakan fungsionalitasnya. <br><br><img src="https://habrastorage.org/webt/tc/kd/fb/tckdfbxc1i4zg4km413wnducl_4.png"><br>  <i>Gambar 1. Pasangan "perintah NL (kiri) dan panggilan API (kanan)" berkumpul</i> <i><br></i>  <i>kerangka kerja kami, dan perbandingan dengan IFTTT.</i>  <i>GET-Messages dan GET-Events adalah dua API web untuk menemukan email dan acara kalender.</i>  <i>API dapat dipanggil dengan berbagai parameter.</i>  <i>Kami fokus pada panggilan API dengan parameter penuh, sementara IFTTT terbatas pada API dengan parameter sederhana.</i> <br><br>  Biasanya, API digunakan dalam berbagai perangkat lunak: aplikasi desktop, situs web, dan aplikasi seluler.  Mereka juga melayani pengguna melalui antarmuka pengguna grafis (GUI).  GUI telah memberikan kontribusi besar pada mempopulerkan komputer, tetapi seiring dengan perkembangan teknologi komputer, banyak keterbatasannya yang semakin nyata.  Di satu sisi, ketika perangkat menjadi lebih kecil, lebih mobile dan lebih pintar, persyaratan untuk tampilan grafik di layar terus meningkat, misalnya, terkait perangkat portabel atau perangkat yang terhubung ke IoT. <br><br>  Di sisi lain, pengguna harus beradaptasi dengan berbagai GUI khusus untuk berbagai layanan dan perangkat.  Dengan meningkatnya jumlah layanan dan perangkat yang tersedia, biaya pelatihan dan adaptasi pengguna juga meningkat.  Antarmuka bahasa alami (NLI), seperti Apple Siri dan asisten virtual Microsoft Cortana, juga disebut antarmuka percakapan atau percakapan (CUI), menunjukkan potensi signifikan sebagai alat tunggal yang cerdas untuk berbagai layanan dan perangkat server. <br><br>  Dalam makalah ini, kami mempertimbangkan masalah membuat antarmuka bahasa alami untuk API (NL2API).  Tapi, tidak seperti asisten virtual, ini bukan NLI tujuan umum, <br>  kami sedang mengembangkan pendekatan untuk membuat NLI untuk API web tertentu, mis. API layanan web seperti layanan multisports ESPN1.  NL2APIs seperti itu dapat memecahkan masalah skalabilitas NLI tujuan umum dengan memungkinkan pengembangan terdistribusi.  Kegunaan asisten virtual sangat tergantung pada luasnya kemampuannya, yaitu, pada jumlah layanan yang didukungnya. <br><br>  Namun, mengintegrasikan layanan web menjadi asisten virtual satu per satu adalah pekerjaan yang sangat melelahkan.  Jika masing-masing penyedia layanan web memiliki cara murah untuk membuat NLI untuk API mereka, biaya integrasi akan berkurang secara signifikan.  Asisten virtual tidak perlu memproses antarmuka yang berbeda untuk layanan web yang berbeda.  Akan cukup baginya untuk hanya mengintegrasikan NL2API individu, yang mencapai keseragaman berkat bahasa alami.  Di sisi lain, NL2API juga dapat menyederhanakan penemuan layanan web dan rekomendasi pemrograman dan sistem bantuan untuk API, menghilangkan kebutuhan untuk mengingat sejumlah besar API web yang tersedia dan sintaksisnya. <br><br>  <b>Contoh 1.</b> Dua contoh ditunjukkan pada Gambar 1. API dapat dipanggil dengan berbagai parameter.  Dalam kasus API pencarian email, pengguna dapat memfilter email berdasarkan properti tertentu atau mencari email dengan kata kunci.  Tugas utama NL2API adalah memetakan perintah NL ke panggilan API yang sesuai. <br><br>  <b>Tantangan.</b>  Pengumpulan data pelatihan adalah salah satu tugas paling penting yang terkait dengan penelitian dalam pengembangan antarmuka NLI dan aplikasi praktisnya.  NLI menggunakan data pelatihan terkontrol, yang dalam kasus NL2API terdiri dari pasangan "perintah NL - panggilan API" untuk mempelajari semantik dan memetakan perintah NL secara jelas ke representasi formal yang sesuai.  Bahasa alami sangat fleksibel, sehingga pengguna dapat mendeskripsikan panggilan API dengan cara yang berbeda secara sintaksis, yaitu, parafrase dilakukan. <br><br>  Pertimbangkan contoh kedua pada Gambar 1. Pengguna dapat mengulangi pertanyaan ini sebagai berikut: "Di mana pertemuan berikutnya akan diadakan" atau "Temukan tempat untuk pertemuan berikutnya".  Oleh karena itu, sangat penting untuk mengumpulkan data pelatihan yang memadai sehingga sistem dapat mengenali opsi-opsi tersebut lebih lanjut.  NLI yang ada biasanya mematuhi prinsip "sebaik mungkin" dalam pengumpulan data.  Sebagai contoh, analog terdekat dari metodologi kami untuk membandingkan perintah NL dengan panggilan API menggunakan konsep IF-This-Then-That (IFTTT) - "jika ya, maka kemudian" (Gambar 1).  Data pelatihan datang langsung dari situs web IFTTT. <br><br>  Namun, jika API tidak didukung atau tidak didukung sepenuhnya, tidak ada cara untuk memperbaiki situasi.  Selain itu, data pelatihan yang dikumpulkan dengan cara ini tidak berlaku untuk mendukung perintah lanjutan dengan beberapa parameter.  Sebagai contoh, kami menganalisis log panggilan Microsoft API anonim untuk mencari email untuk bulan itu dan menemukan bahwa sekitar 90% dari mereka menggunakan dua atau tiga parameter (kira-kira jumlah yang sama), dan parameter ini cukup beragam.  Oleh karena itu, kami berusaha keras untuk memberikan dukungan penuh untuk parameterisasi API dan mengimplementasikan perintah NL lanjutan.  Masalah penerapan proses yang aktif dan dapat disesuaikan untuk mengumpulkan data pelatihan untuk API tertentu saat ini masih belum terselesaikan. <br><br>  Masalah menggunakan NLI dalam kombinasi dengan representasi formal lainnya, seperti database relasional, basis pengetahuan dan tabel web, telah dikerjakan dengan baik, sementara hampir tidak ada perhatian diberikan pada pengembangan NLI untuk API web.  Kami menawarkan platform komprehensif pertama (kerangka kerja) yang memungkinkan Anda membuat NL2API untuk API web tertentu dari awal.  Dalam implementasi untuk API web, kerangka kerja kami mencakup tiga tahap: (1) Presentasi.  Format HTTP web API asli berisi banyak sekali redundan dan, karenanya, mengganggu rincian dari sudut pandang NLI. <br><br>  Kami menyarankan menggunakan representasi semantik perantara untuk API web, agar tidak membebani NLI dengan informasi yang tidak perlu.  (2) Satu set data pelatihan.  Kami menawarkan pendekatan baru untuk mendapatkan data pelatihan terkontrol berdasarkan crowdsourcing.  (3) NL2API.  Kami juga menawarkan dua model NL2API: model ekstraksi berbasis bahasa dan model jaringan saraf berulang (Seq2Seq). <br><br>  Salah satu hasil teknis utama dari pekerjaan ini adalah pendekatan baru yang fundamental pada pengumpulan aktif data pelatihan untuk NL2API berdasarkan crowdsourcing - kami menggunakan eksekutif jarak jauh untuk membubuhi keterangan panggilan API ketika membandingkannya dengan perintah NL.  Ini memungkinkan Anda untuk mencapai tiga tujuan desain dengan menyediakan: (1) Kustomisasi.  Anda harus dapat menentukan parameter mana untuk API mana yang akan digunakan dan berapa banyak data pelatihan untuk dikumpulkan.  (2) Biaya rendah.  Layanan pekerja crowdsourcing adalah urutan besarnya lebih murah daripada layanan spesialis khusus, itulah sebabnya mereka harus dipekerjakan.  (3) Kualitas tinggi.  Kualitas data pelatihan tidak boleh dikurangi. <br><br>  Saat merancang pendekatan ini, dua masalah utama muncul.  Pertama, panggilan API dengan parameterisasi lanjutan, seperti pada Gambar 1, tidak dapat dipahami oleh rata-rata pengguna, jadi Anda perlu memutuskan bagaimana merumuskan masalah anotasi sehingga karyawan crowdsourcing dapat dengan mudah mengatasinya.  Kami mulai dengan mengembangkan representasi semantik perantara untuk API web (lihat bagian 2.2), yang memungkinkan kami untuk menghasilkan panggilan API dengan parameter yang diperlukan. <br><br>  Kemudian kami memikirkan tata bahasa untuk secara otomatis mengubah setiap panggilan API menjadi perintah NL kanonik, yang bisa agak rumit, tetapi akan jelas bagi karyawan crowdsourcing rata-rata (lihat bagian 3.1).  Para pemain hanya perlu mengubah kata-kata tim kanonik agar terdengar lebih alami.  Pendekatan ini memungkinkan Anda untuk mencegah banyak kesalahan dalam pengumpulan data pelatihan, karena tugas pengubahan kata kata jauh lebih sederhana dan lebih mudah dipahami bagi karyawan crowdsourcing rata-rata. <br><br>  Kedua, Anda perlu memahami cara mendefinisikan dan membubuhi keterangan hanya panggilan API yang bernilai nyata untuk mempelajari NL2API.  â€œLedakan kombinatorialâ€ yang muncul selama parameterisasi mengarah pada fakta bahwa jumlah panggilan bahkan untuk satu API bisa sangat besar.  Tidak masuk akal untuk membubuhi keterangan semua panggilan.  Kami menawarkan model probabilistik hierarkis yang secara fundamental baru untuk implementasi proses crowdsourcing (lihat bagian 3.2).  Dengan analogi dengan pemodelan bahasa untuk tujuan memperoleh informasi, kami mengasumsikan bahwa perintah NL dihasilkan berdasarkan panggilan API yang sesuai, sehingga model bahasa harus digunakan untuk setiap panggilan API untuk mendaftarkan proses "generatif" ini. <br><br>  Model kami didasarkan pada sifat komposisi panggilan API atau representasi formal dari struktur semantik secara keseluruhan.  Pada tingkat intuitif, jika panggilan API terdiri dari panggilan yang lebih sederhana (misalnya, "email yang belum dibaca tentang kandidat untuk gelar sains" = "email yang belum dibaca" + "email untuk kandidat untuk gelar sains", kita dapat membangunnya model bahasa dari panggilan API sederhana bahkan tanpa anotasi, oleh karena itu, dengan menjelaskan sejumlah kecil panggilan API, kita dapat menghitung model bahasa untuk semua orang. <br><br>  Tentu saja, model-model bahasa yang dihitung jauh dari ideal, jika tidak kita akan sudah memecahkan masalah menciptakan NL2API.  Namun demikian, ekstrapolasi model bahasa untuk panggilan API yang tidak ditandai memberi kita pandangan menyeluruh tentang seluruh ruang panggilan API, serta interaksi bahasa alami dan panggilan API, yang memungkinkan kita untuk mengoptimalkan proses crowdsourcing.  Di Bagian 3.3, kami menjelaskan algoritme untuk membubuhi keterangan secara selektif panggilan API untuk membantu menjadikan panggilan API lebih mudah dibedakan, yaitu untuk memaksimalkan perbedaan di antara model bahasa mereka. <br><br>  Kami menerapkan kerangka kerja kami pada dua API yang digunakan dari paket Microsoft Graph API2.  Kami menunjukkan bahwa data pelatihan berkualitas tinggi dapat dikumpulkan dengan biaya minimal jika pendekatan yang diusulkan digunakan3.  Kami juga menunjukkan bahwa pendekatan kami meningkatkan crowdsourcing.  Dengan biaya yang sama, kami mengumpulkan data pelatihan yang lebih baik, secara signifikan melebihi baseline.  Hasilnya, solusi NL2API kami memberikan akurasi yang lebih tinggi. <br><br>  Secara umum, kontribusi utama kami meliputi tiga aspek: <br><br><ul><li>  Kami adalah salah satu yang pertama mempelajari masalah NL2API dan mengusulkan kerangka kerja yang komprehensif untuk membuat NL2API dari awal. </li><li>  Kami mengusulkan pendekatan unik untuk pengumpulan data pelatihan menggunakan crowdsourcing dan model probabilistik hierarkis baru untuk mengoptimalkan proses ini. </li><li>  Kami menerapkan kerangka kerja kami ke API web nyata dan menunjukkan bahwa solusi NL2API yang cukup efektif dapat dibuat dari awal. </li></ul><br><img src="https://habrastorage.org/webt/t4/fs/vl/t4fsvlxndjmziwbvzjh2rwqut2c.png"><br>  <i>Tabel 1. Parameter kueri OData.</i> <br><br><h2>  Pembukaan </h2><br><h4>  API tenang </h4><br>  Baru-baru ini, API web yang mematuhi gaya arsitektur REST, yaitu RESTful API, menjadi semakin populer karena kesederhanaannya.  API tenang juga digunakan pada smartphone dan perangkat IoT.  Restful API bekerja dengan sumber daya yang dialamatkan melalui URI dan menyediakan akses ke sumber daya ini untuk berbagai klien menggunakan perintah HTTP sederhana: GET, PUT, POST, dll. Kami terutama akan bekerja dengan RESTful API, tetapi metode dasar dapat digunakan dan API lainnya. <br><br>  Sebagai contoh, ambil Open Data Protocol (OData) populer untuk RESTful API dan dua web API dari paket Microsoft Graph API (Gambar 1), yang, masing-masing, digunakan untuk mencari email dan acara kalender pengguna.  Sumber daya di OData adalah entitas, yang masing-masing terkait dengan daftar properti.  Misalnya, entitas Pesan - email - memiliki properti seperti subjek (subjek), dari (dari), isRead (baca), diterimaDateTime (tanggal dan waktu penerimaan), dll. <br><br>  Selain itu, OData mendefinisikan satu set parameter kueri, memungkinkan Anda untuk melakukan manipulasi lanjutan pada sumber daya.  Misalnya, parameter FILTER memungkinkan Anda mencari email dari pengirim atau surat tertentu yang diterima pada tanggal tertentu.  Parameter permintaan yang akan kami gunakan disajikan pada Tabel 1. Kami memanggil setiap kombinasi perintah HTTP dan entitas (atau set entitas) sebagai API, misalnya, GET-Pesan - untuk mencari email.  Setiap permintaan parameter, misalnya, FILTER (isRead = False), disebut parameter, dan panggilan API adalah API dengan daftar parameter. <br><br><h4>  NL2API </h4><br>  Tugas utama NLI adalah membandingkan pernyataan (perintah dalam bahasa alami) dengan representasi formal tertentu, misalnya, formulir logis atau kueri SPARQL untuk basis pengetahuan atau API web dalam kasus kami.  Ketika perlu untuk fokus pada pemetaan semantik tanpa terganggu oleh detail yang tidak relevan, representasi semantik menengah biasanya digunakan agar tidak bekerja secara langsung dengan target.  Misalnya, tata bahasa kategori kombinatorial banyak digunakan dalam menciptakan NLI untuk basis data dan basis pengetahuan.  Pendekatan serupa dengan abstraksi juga sangat penting untuk NL2API.  Banyak detail, termasuk konvensi URL, header HTTP, dan kode respons, dapat "mengalihkan" NL2API dari penyelesaian masalah utama - pemetaan semantik. <br><br>  Oleh karena itu, kami membuat tampilan perantara untuk RESTful APIs (Gambar 2) dengan bingkai nama API, tampilan ini mencerminkan semantik dari frame.  Bingkai API terdiri dari lima bagian.  HTTP Verb (HTTP Command) dan Resource adalah elemen dasar untuk RESTful API.  Return Type memungkinkan Anda untuk membuat API komposit, yaitu, menggabungkan beberapa panggilan API untuk melakukan operasi yang lebih kompleks.  Parameter yang Diperlukan paling sering digunakan dalam panggilan PUT atau POST di API, misalnya, alamat, header, dan isi pesan adalah parameter yang diperlukan untuk mengirim email.  Parameter opsional sering hadir dalam GET panggilan di API, mereka membantu mempersempit permintaan informasi. <br><br>  Jika parameter yang diperlukan tidak ada, kami membuat serialisasi kerangka API, misalnya: GET-messages {FILTER (isRead = False), SEARCH ("aplikasi PhD"), COUNT ()}.  Frame API dapat bersifat deterministik dan dikonversi menjadi panggilan API yang nyata.  Selama proses konversi, data kontekstual yang diperlukan akan ditambahkan, termasuk ID pengguna, lokasi, tanggal dan waktu.  Dalam contoh kedua (Gambar 1), nilai sekarang dalam parameter FILTER akan diganti dengan tanggal dan waktu pelaksanaan perintah terkait selama konversi frame API menjadi panggilan API nyata.  Selanjutnya, konsep-konsep kerangka API dan panggilan API akan digunakan secara bergantian. <br><br><img src="https://habrastorage.org/webt/zq/ya/1s/zqya1s2fappwxv0soevosjshp6o.png"><br>  <i>Gambar 2. Frame API.</i>  <i>Atas: tim bahasa alami.</i>  <i>Di tengah: Frame API.</i>  <i>Bawah: Panggilan API.</i> <br><br><img src="https://habrastorage.org/webt/d1/4j/br/d14jbrsdzhethdl8tpvjlf0v7bq.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 3. Konveyor crowdsourcing.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengumpulan data pelatihan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian ini menjelaskan pendekatan baru yang secara mendasar kami tawarkan untuk pengumpulan data pelatihan untuk solusi NL2API menggunakan crowdsourcing. </font><font style="vertical-align: inherit;">Pertama, kami membuat panggilan API dan mengonversinya masing-masing menjadi tim kanonik, mengandalkan tata bahasa sederhana (bagian 3.1), dan kemudian kami menarik pekerja crowdsourcing untuk membentuk ulang tim kanonik (Gambar 3). </font><font style="vertical-align: inherit;">Mengingat sifat komposisi panggilan API, kami mengusulkan model crowdsourcing probabilistik hirarkis (bagian 3.2), serta algoritma untuk optimasi crowdsourcing (bagian 3.3). </font></font><br><br><img src="https://habrastorage.org/webt/-m/hx/zh/-mhxzhnfom3w3n8cck-nkazfwiu.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 4. Generasi perintah Canonical. </font><font style="vertical-align: inherit;">Kiri: leksikon dan tata bahasa. </font><font style="vertical-align: inherit;">Kanan: contoh derivasi.</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Panggilan API dan perintah kanonik </font></font></h4><br>    API     API.   ,       ,        API,   API  .      ,  Boolean,     (True/False). <br><br>      ,  Datetime,     ,  today  this_week  receivedDateTime.  ,        API           (,    )    API    API. <br><br>     ,        API .        . ,     TOP,         ORDERBY.  ,   Boolean,  isRead,  ORDERBY   .    Â« Â»         API   API. <br><br>      API.       API   .     API     API  ( 4).            ( HTTP, ,    ). ,   âŸ¨sender â†’ NP[from]âŸ© ,     from  Â«senderÂ»,    â€”   (NP),     . <br><br>       (V),   (VP),  (JJ), - (CP),   ,       (NP/NP),    (PP/NP),  (S)  . . <br><br>  ,       API     ,           RESTful API    OData â€” Â« Â»    . 17     4     API,     ( 5). <br><br>   ,          API.     âŸ¨t1, t2, ..., tn â†’ c[z]âŸ©,  <img src="https://habrastorage.org/webt/h5/rj/n2/h5rjn28vmc1twejoa5459flx0gm.png">    , z    API,  cz â€”   .     4.   API    ,     S,     G4,     API   . C    ,          ,               - Â«that is not readÂ». <br><br>  ,      . ,  VP[x = False]     B2,   B4,       x.  x     VP,   B2 (, x is hasAttachments â†’ Â«do not have attachmentÂ»);    JJ,    B4 (, x is isRead â†’ Â«is not readÂ»).       (Â«do not readÂ» or Â«is not have attachmentÂ»)       . <br><br><h4>   </h4><br>  Kami dapat menghasilkan sejumlah besar panggilan API menggunakan pendekatan di atas, tetapi menjelaskan semuanya menggunakan crowdsourcing tidak layak secara ekonomi.  Oleh karena itu, kami mengusulkan model probabilistik hierarkis untuk crowdsourcing yang membantu Anda memutuskan panggilan API mana yang harus dianotasi.  Sejauh yang kita tahu, ini adalah model probabilistik pertama menggunakan crowdsourcing untuk membuat antarmuka NLI, yang memungkinkan kita untuk menyelesaikan tugas yang unik dan menarik dari pemodelan interaksi antara representasi bahasa alami dan representasi struktur semantik yang diformalkan.  Representasi formal dari struktur semantik pada umumnya dan panggilan API pada khususnya bersifat komposisional.  Misalnya, z12 = GET-Pesan {COUNT (), FILTER (isRead = False)} terdiri dari z1 = GET-Pesan {FILTER (isRead = False)} dan z2 = GET-Pesan-pesan {COUNT ()} (contoh-contoh ini lebih rinci diskusikan lebih lanjut). <br><br><img src="https://habrastorage.org/webt/fa/w0/eh/faw0ehohhnasifwgtragzrqwg3o.png"><br>  <i>Gambar 5. Jaringan semantik.</i>  <i>Lapisan ke-i terdiri dari panggilan API dengan parameter i.</i>  <i>Iga adalah komposisi.</i>  <i>Distribusi probabilitas pada simpul mencirikan model bahasa yang sesuai.</i> <br><br>  Salah satu hasil utama dari penelitian kami adalah konfirmasi bahwa komposisi tersebut dapat digunakan untuk memodelkan proses crowdsourcing. <br><br>  Pertama, kami mendefinisikan komposisi berdasarkan pada set parameter panggilan API. <br><br>  <b>Definisi 3.1 (komposisi).</b>  Ambil API dan satu set panggilan API <br><img src="https://habrastorage.org/webt/jp/nd/rx/jpndrxembixwz20-sym5vtxyhaq.png">  jika kita mendefinisikan r (z) sebagai seperangkat parameter untuk z, maka <img src="https://habrastorage.org/webt/zq/ih/u5/zqihu5tkga6iigokecjod-cg5um.png">  adalah komposisi <img src="https://habrastorage.org/webt/_a/1x/jv/_a1xjvs9yduvatefhmfdk6xumq8.png">  jika dan hanya jika <img src="https://habrastorage.org/webt/0e/oy/hw/0eoyhwaahe8xlrbplt1nqajeego.png">  adalah bagian <img src="https://habrastorage.org/webt/np/q5/sy/npq5syhh47uv3yvyba_t1_4tqc0.png"><br><br>  Berdasarkan pada hubungan komposisi panggilan API, Anda dapat mengatur semua panggilan API ke dalam struktur hierarki tunggal.  Panggilan API dengan jumlah parameter yang sama direpresentasikan sebagai simpul dari satu layer, dan komposisi diwakili sebagai <br>  rusuk diarahkan antara lapisan.  Kami menyebut struktur ini sebagai jaringan sematic (atau SeMesh). <br><br>  Dengan analogi dengan pendekatan yang didasarkan pada pemodelan bahasa dalam pencarian informasi, kami mengasumsikan bahwa pernyataan yang berkaitan dengan satu panggilan API z dihasilkan menggunakan proses stokastik yang ditandai dengan model bahasa <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  .  Untuk mempermudah, kami fokus pada kemungkinan kata-kata <img src="https://habrastorage.org/webt/on/eh/p5/onehp5mxamc9ehgpsl1u4pbkfr4.png">  dimana <img src="https://habrastorage.org/webt/a-/v8/rh/a-v8rh1ddeh_ai-eawq8udhqe80.png">  menunjukkan kamus. <br><br>  Untuk alasan yang akan menjadi jelas beberapa saat kemudian, alih-alih model unigram bahasa standar, kami sarankan menggunakan satu set distribusi Bernoulli (Bag of Bernoulli, BoB).  Setiap distribusi Bernoulli sesuai dengan variabel acak W, menentukan apakah kata w muncul dalam kalimat yang dihasilkan berdasarkan z, dan distribusi BoB adalah seperangkat distribusi Bernoulli untuk semua kata <img src="https://habrastorage.org/webt/k0/gw/fj/k0gwfjeikxqircdxhndamv6xbba.png">  .  Kami akan gunakan <img src="https://habrastorage.org/webt/j1/vn/qm/j1vnqmhyhigxbdpj7s5irirmxae.png">  sebagai notasi singkat untuk <img src="https://habrastorage.org/webt/ub/xi/rx/ubxirxha2um6wer3obznfezis7w.png">  . <br><br>  Misalkan kita telah membentuk seperangkat pernyataan (multi) <img src="https://habrastorage.org/webt/m5/nb/sr/m5nbsrzyyxpfpzc6isj_qrjjxbs.png">  untuk z, <br>  estimasi kemungkinan maksimum (MLE) untuk distribusi BoB memungkinkan Anda memilih pernyataan yang mengandung w: <br><br><img src="https://habrastorage.org/webt/ix/gv/2q/ixgv2qua9ifqtxbp1mi3hf58izc.png"><br><br>  <b>Contoh 2.</b> Mengenai panggilan API di atas z1, misalkan kita mendapat dua pernyataan u1 = "temukan email yang belum dibaca" dan u2 = "email yang tidak dibaca", lalu u = {u1, u2}.  pb ("email" | z) = 1.0, karena "email" ada di kedua pernyataan.  Demikian pula, pb ("belum dibaca" | z) = 0,5 dan pb ("pertemuan" | z) = 0,0. <br><br>  Di jaringan semantik, ada tiga operasi dasar di tingkat verteks: <br>  Anotasi, tata letak, dan interpolasi. <br><br>  <b>ANNOTATE</b> (to annotate) artinya mengumpulkan pernyataan <img src="https://habrastorage.org/webt/m5/nb/sr/m5nbsrzyyxpfpzc6isj_qrjjxbs.png">  untuk memparafrasekan perintah kanonik dari simpul z menggunakan crowdsourcing dan mengevaluasi distribusi empiris <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">  metode kemungkinan maksimum. <br><br>  <b>KOMPOS</b> (susun) mencoba menurunkan model bahasa berdasarkan komposisi untuk menghitung distribusi yang diharapkan <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  .  Seperti yang kami tunjukkan secara eksperimental, <img src="https://habrastorage.org/webt/zq/ih/u5/zqihu5tkga6iigokecjod-cg5um.png">  Merupakan komposisi untuk z.  Jika kita melanjutkan dari asumsi bahwa pernyataan yang sesuai dicirikan oleh koneksi komposisi yang sama, maka <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  harus diletakkan di atas <img src="https://habrastorage.org/webt/xe/zj/vd/xezjvdelmyapzpsz-c-ubbyrowq.png">  : <br><br><img src="https://habrastorage.org/webt/1j/kw/gy/1jkwgy2cjdyy2tkd9fd94_vdtf0.png"><br><br>  di mana f adalah fungsi komposisi.  Untuk distribusi BoB, fungsi komposisi akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/-j/yo/yc/-jyoycveazjjahzb2va3w26sfv0.png"><br><br>  Dengan kata lain, jika ui adalah pernyataan zi, u adalah pernyataan <img src="https://habrastorage.org/webt/lr/ls/g_/lrlsg_9r0ga50mjkj47anmczlga.png">  secara komposisi membentuk u, maka kata w bukan milik u.  Jika dan hanya jika itu bukan milik ui.  Ketika z memiliki banyak komposisi, Î¸e x dihitung secara terpisah dan kemudian dirata-ratakan.  Model unigram bahasa standar tidak mengarah pada fungsi komposisi alami.  Dalam proses normalisasi probabilitas kata, panjang kalimat terlibat, yang, pada gilirannya, memperhitungkan kompleksitas panggilan API, melanggar dekomposisi dalam persamaan (2).  Itu sebabnya kami menawarkan distribusi BoB. <br><br>  <b>Contoh 3.</b> Misalkan kita menyiapkan anotasi untuk panggilan API yang disebutkan sebelumnya z1 dan z2, masing-masing memiliki dua pernyataan: <img src="https://habrastorage.org/webt/zy/pr/yx/zypryx-8unafep9q1_lu2bnwewi.png">  = {"Temukan email yang belum dibaca", "email yang belum dibaca"} dan <img src="https://habrastorage.org/webt/7n/4a/74/7n4a746gi-pf2_nf0ocy0dohdqm.png">  = {"Berapa banyak email yang saya miliki", "temukan jumlah email"}.  Kami memberi peringkat model bahasa <img src="https://habrastorage.org/webt/7a/uj/od/7aujod7s9qek21mw3zemkcgaake.png">  dan <img src="https://habrastorage.org/webt/vp/so/fn/vpsofnkfxhjn38dfcjpm6bqzzio.png">  .  Operasi komposisi sedang mencoba untuk mengevaluasi <img src="https://habrastorage.org/webt/qt/tm/ud/qttmudo6ekcwmdeptxfjigmmcck.png">  tanpa bertanya <img src="https://habrastorage.org/webt/hx/6c/sn/hx6csng8_0l_yqxgvteefbapkm0.png">  .  Misalnya, untuk kata "email", pb ("email" | z1) = 1.0 dan pb ("email" | z2) = 1.0, jadi berikut dari persamaan (3) bahwa pb ("email" | z12) = 1.0, yaitu, kami percaya bahwa kata ini akan dimasukkan dalam pernyataan apa pun dari z12.  Demikian pula, pb ("find" | z1) = 0,5 dan pb ("find" | z2) = 0,5, jadi pb ("find" | z12) = 0,75.  Sebuah kata memiliki peluang bagus dihasilkan dari z1 atau z2, jadi probabilitasnya untuk z12 harus lebih tinggi. <br><br>  Tentu saja, pernyataan tidak selalu digabungkan secara komposisi.  Sebagai contoh, beberapa elemen dalam representasi formal dari struktur semantik dapat disampaikan dalam satu kata atau frase dalam bahasa alami, fenomena ini disebut komposisionalitas sublexic.  Salah satu contoh tersebut ditunjukkan pada Gambar 3, di mana tiga parameter - TOP (1), FILTER (mulai&gt; sekarang), dan ORDERBY (mulai, naik) â€”direpresentasikan oleh satu kata "berikutnya".  Namun, tidak mungkin untuk mendapatkan informasi tersebut tanpa membuat anotasi panggilan API, sehingga masalahnya sendiri mirip dengan masalah ayam dan telur.  Dengan tidak adanya informasi tersebut, masuk akal untuk mematuhi asumsi default bahwa pernyataan dikarakteristikkan dengan hubungan komposisi yang sama dengan panggilan API. <br><br>  Ini adalah asumsi yang masuk akal.  Perlu dicatat bahwa asumsi ini hanya digunakan untuk memodelkan proses crowdsourcing dengan tujuan mengumpulkan data.  Pada tahap pengujian, pernyataan pengguna nyata mungkin tidak sesuai dengan asumsi ini.  Antarmuka bahasa alami akan dapat mengatasi situasi non-komposisi tersebut jika dicakup oleh data pelatihan yang dikumpulkan. <br><br>  <b>INTERPOLATE</b> (interpolasi) menggabungkan semua informasi yang tersedia tentang z, yaitu, ucapan beranotasi z dan informasi yang diperoleh dari komposisi, dan mendapatkan perkiraan yang lebih akurat <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  dengan interpolasi <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">  dan <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  . <br><br><img src="https://habrastorage.org/webt/s4/qk/00/s4qk00v3xupp-nglc-ge-mmgwxa.png"><br><br>  Parameter keseimbangan Î± mengontrol pertukaran antara anotasi <br>  puncak saat ini yang akurat tetapi memadai, dan informasi yang diperoleh dari komposisi berdasarkan asumsi komposisi mungkin tidak seakurat, tetapi memberikan cakupan yang lebih luas.  Dalam arti tertentu, <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  melayani tujuan yang sama dengan anti-aliasing dalam pemodelan bahasa, yang memungkinkan perkiraan distribusi probabilitas yang lebih baik dengan data yang tidak memadai (anotasi).  Lebih dari <img src="https://habrastorage.org/webt/xt/ml/w5/xtmlw5p16zioqn1amioucvjhe5o.png">  semakin berat di <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">  .  Untuk simpul akar yang tidak memiliki komposisi, <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  = <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">  .  Untuk bagian atas yang tidak ditandai <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  = <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  . <br><br>  Selanjutnya, kami menggambarkan algoritma pembaruan jaringan semantik, mis., Perhitungan <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  untuk semua z (algoritme 1), bahkan jika hanya sebagian kecil dari simpul diberi penjelasan.  Kami menganggap itu nilainya <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">  Sudah diperbarui untuk semua situs beranotasi.  Turun dari atas ke bawah, kami menghitung secara berurutan <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  dan <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  untuk setiap simpul z.  Pertama, Anda perlu memperbarui lapisan atas sehingga Anda dapat menghitung distribusi simpul yang diharapkan dari tingkat yang lebih rendah.  Kami menjelaskan semua simpul akar, sehingga kami dapat menghitung <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  untuk semua simpul. <br><br>  <i>Algoritma 1. Memperbarui Distribusi Node dari Semantic Mesh</i> <br><br><img src="https://habrastorage.org/webt/wd/ja/xx/wdjaxx4oqk_1rqniul9rnbc-fno.png"><br><br><h4>  3.3 Optimalisasi Crowdsourcing </h4><br>  Jaringan semantik membentuk pandangan holistik dari seluruh ruang panggilan API, serta interaksi pernyataan dan panggilan.  Berdasarkan tampilan ini, kami hanya dapat membubuhi keterangan selektif panggilan API bernilai tinggi.  Di bagian ini, kami menjelaskan strategi distribusi diferensial kami untuk mengoptimalkan crowdsourcing. <br><br>  Pertimbangkan jaringan semantik dengan banyak simpul Z. Tugas kita adalah menentukan subset simpul dalam proses berulang <img src="https://habrastorage.org/webt/ti/9x/ac/ti9xacqha0b1hbtkyeejh30f3sk.png">  untuk dijelaskan oleh pekerja crowdsourcing.  Verteks yang dianotasi sebelumnya akan disebut state state, <br>  maka kita perlu menemukan kebijakan kebijakan <img src="https://habrastorage.org/webt/9i/oc/9m/9ioc9mao9yuvhq7uhkiemeqet4g.png">  untuk mengevaluasi setiap simpul yang tidak ditandai berdasarkan kondisi saat ini. <br><br>  Sebelum membahas diskusi tentang pendekatan untuk menghitung kebijakan yang efektif, anggaplah kita sudah memiliki satu dan memberikan deskripsi tingkat tinggi dari algoritma crowdsourcing kami (Algoritma 2) untuk menggambarkan metode yang menyertainya.  Lebih khusus lagi, pertama-tama kita membubuhi keterangan semua simpul akar untuk mengevaluasi distribusi untuk semua simpul di Z (baris 3).  Pada setiap iterasi, kami memperbarui distribusi titik (baris 5), menghitung <br>  kebijakan yang didasarkan pada keadaan saat ini dari jaringan semantik (baris 6), pilih titik yang tidak ditandai dengan peringkat maksimum (baris 7), dan beri catatan pada titik dan hasil dalam keadaan baru (baris 8).  Secara praktis, Anda dapat membuat anotasi beberapa simpul sebagai bagian dari iterasi untuk meningkatkan efisiensi. <br><br><img src="https://habrastorage.org/webt/va/tz/hs/vatzhsjcogvaktg8wh4h0a8al70.png"><br>  <i>Gambar 6. Distribusi diferensial.</i>  <i>z12 dan z23 mewakili pasangan simpul yang diteliti.</i>  <i>w adalah estimasi yang dihitung berdasarkan d (z12, z23), dan secara iteratif merambat dari bawah ke atas, dua kali lipat dalam setiap iterasi.</i>  <i>Estimasi untuk vertex akan menjadi perbedaan absolut dari estimasi dari z12 dan z23 (oleh karena itu diferensial).</i>  <i>z2 mendapat skor 0 karena itu adalah entitas induk yang umum untuk z12 dan z23;</i>  <i>penjelasan dalam hal ini akan sedikit berguna dalam hal memastikan dibedakannya z12 dan z23.</i> <br><br>  Dalam arti luas, tugas-tugas yang kita selesaikan dapat dikaitkan dengan masalah pembelajaran aktif, kita menetapkan diri kita tujuan mengidentifikasi subset contoh untuk penjelasan untuk mendapatkan satu set pelatihan yang dapat meningkatkan hasil belajar.  Namun, beberapa perbedaan utama tidak memungkinkan aplikasi langsung dari metode pengajaran aktif klasik, seperti "ketidakpastian sampling".  Biasanya, dalam proses pembelajaran aktif, siswa, yang dalam kasus kami akan menjadi antarmuka NLI, mencoba mempelajari pemetaan f: X â†’ Y, di mana X adalah sampel ruang input, yang terdiri dari set kecil sampel bertanda dan sejumlah besar sampel yang tidak ditandai, dan Y biasanya satu set spidol kelas. <br><br>  Siswa mengevaluasi nilai informatif dari contoh yang tidak berlabel dan memilih yang paling informatif untuk mendapatkan nilai Y dari pekerja crowdsourcing.  Namun dalam kerangka masalah yang kami selesaikan, masalah anotasi diajukan secara berbeda.  Kita perlu memilih contoh dari Y, ruang panggilan API yang besar, dan meminta pekerja crowdsourcing untuk memberi label dengan menentukan pola dalam X, ruang kalimat.  Selain itu, kami tidak terikat dengan peserta pelatihan tertentu.  Jadi, kami mengusulkan solusi baru untuk masalah yang dihadapi.  Kami mengambil inspirasi dari berbagai sumber tentang pembelajaran aktif. <br><br>  Pertama, kita akan menentukan tujuan, di mana konten informasi dari node akan dievaluasi.  Jelas, kami ingin panggilan API yang berbeda dapat dibedakan.  Dalam jaringan semantik, ini berarti distribusi <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  puncak yang berbeda memiliki perbedaan yang jelas.  Untuk mulai dengan, kami menyajikan setiap distribusi <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  seperti vektor n-dimensi <img src="https://habrastorage.org/webt/nv/ky/pn/nvkypndwq-7j6xnikrteas3oiq4.png">  dimana n = | <img src="https://habrastorage.org/webt/a-/v8/rh/a-v8rh1ddeh_ai-eawq8udhqe80.png">  |  - ukuran kamus.  Dengan metrik tertentu dari jarak vektor d (dalam percobaan kami, kami menggunakan jarak antara vektor pL1) yang kami maksud <img src="https://habrastorage.org/webt/jc/z9/de/jcz9demx4drw0fsgz1niisgavd0.png">  , yaitu, jarak antara dua simpul sama dengan jarak antara distribusinya. <br><br>  Tujuan yang jelas adalah untuk memaksimalkan jarak total antara semua pasangan simpul.  Namun, optimasi semua jarak berpasangan mungkin terlalu rumit untuk perhitungan, dan bahkan ini tidak perlu.  Sepasang puncak yang jauh sudah memiliki perbedaan yang cukup, sehingga peningkatan jarak lebih jauh tidak masuk akal.  Sebagai gantinya, kita bisa fokus pada pasangan simpul yang paling membingungkan, yaitu jarak di antara mereka adalah yang terkecil. <br><br><img src="https://habrastorage.org/webt/of/tp/sl/oftpslo2cmmijyxtccepbyqsmsc.png"><br><br>  dimana <img src="https://habrastorage.org/webt/1g/-h/nh/1g-hnhpklydkghmo4z7pq7ujouu.png">  menunjuk ke K pasang simpul pertama jika kita memberi peringkat semua pasangan node berdasarkan jarak dalam urutan menaik. <br><br>  <i>Algoritma 2. Beranotasi dengan Semantic Mesh dengan Kebijakan</i> <br><br><img src="https://habrastorage.org/webt/5p/j2/2r/5pj22rp_c5npknusixp4k4ulfli.png"><br><br>  <i>Algoritma 3. Hitung Kebijakan berdasarkan Diferensial Propagasi</i> <br><br><img src="https://habrastorage.org/webt/s5/ee/zb/s5eezb7ls03ly9nfndyotsqhlva.png"><br><br>  <i>Algoritma 4. Menyebarkan Skor dari Node Sumber ke Semua Node Induknya secara Rekursif</i> <br><br><img src="https://habrastorage.org/webt/m9/ge/vt/m9gevt8-vlgwxxulaxyfxkovdmk.png"><br><br>  Simpul dengan konten informasi yang lebih tinggi setelah anotasi berpotensi meningkatkan nilai Î˜.  Untuk kuantifikasi dalam kasus ini, kami mengusulkan menggunakan strategi distribusi diferensial.  Jika jarak antara sepasang simpul kecil, kami memeriksa semua simpul induknya: jika simpul induk adalah umum untuk sepasang simpul, itu harus mendapatkan peringkat rendah, karena anotasi akan menyebabkan perubahan yang serupa untuk kedua simpul. <br><br>  Jika tidak, simpul harus diberi peringkat tinggi, dan semakin dekat pasangan simpul, semakin tinggi peringkatnya.  Misalnya, jika jarak antara simpul "email yang belum dibaca tentang aplikasi PhD" dan "berapa banyak email tentang aplikasi PhD" kecil, maka anotasi simpul orang tua mereka "email tentang aplikasi PhD" tidak masuk akal dari sudut pandang membedakan simpul ini.  Lebih disarankan untuk membuat anotasi node induk yang tidak akan umum bagi mereka: "email yang belum dibaca" dan "berapa banyak email". <br><br>  Contoh dari situasi seperti itu ditunjukkan pada Gambar 6, dan algoritmanya adalah algoritma 3. Sebagai perkiraan, kami mengambil kebalikan dari jarak simpul yang dibatasi oleh konstanta (garis 6), sehingga pasangan simpul terdekat memiliki dampak terbesar.  Ketika bekerja dengan sepasang simpul, kami secara bersamaan menetapkan penilaian setiap simpul untuk semua simpul induknya (baris 9, 10 dan algoritma 4).  Perkiraan dari simpul yang tidak dinotasikan adalah perbedaan mutlak dalam perkiraan pasangan simpul yang sesuai dengan penjumlahan atas semua pasangan simpul (baris 12). <br><br><h2>  Antarmuka Bahasa Alami </h2><br>  Untuk mengevaluasi kerangka yang diusulkan, perlu untuk melatih model NL2API menggunakan data yang dikumpulkan.  Saat ini, model NL2API yang sudah jadi tidak tersedia, tetapi kami mengadaptasi dua model NLI yang diuji dari area lain untuk menerapkannya ke API. <br><br><h4>  Model Ekstraksi Model Bahasa </h4><br>  Berdasarkan perkembangan terakhir di bidang NLI untuk basis pengetahuan, kita dapat mempertimbangkan pembuatan NL2API dalam konteks masalah ekstraksi informasi untuk menyesuaikan model ekstraksi berdasarkan model bahasa (LM) dengan kondisi kami. <br><br>  Untuk mengatakan Anda, Anda perlu menemukan panggilan z API di jaringan semantik dengan kecocokan terbaik untuk Anda.  Pertama kami mengubah distribusi BoB <img src="https://habrastorage.org/webt/rq/qs/9-/rqqs9-qn12-qsdd7mahxx5tg-si.png">  setiap panggilan API z ke model unigram bahasa: <br><br><img src="https://habrastorage.org/webt/lr/4f/pt/lr4fptel7voyxz2pelzjinbyu14.png"><br><br>  di mana kita menggunakan smoothing aditif, dan 0 â‰¤ Î² â‰¤ 1 adalah parameter smoothing.  Nilai lebih tinggi <img src="https://habrastorage.org/webt/rh/1e/wc/rh1ewczas_fvleaxd5za0qvury0.png">  , semakin besar bobot kata yang belum dianalisis.  Panggilan API dapat diberi peringkat berdasarkan probabilitas logaritmiknya: <br><br><img src="https://habrastorage.org/webt/3c/sf/fu/3csffus3jr7h6kpxq6czdyvhdtm.png"><br><br>  (dikenakan seragam distribusi probabilitas apriori) <br><br><img src="https://habrastorage.org/webt/0s/xu/y-/0sxuy-xon3k12zlsbn2f41wzyco.png"><br><br>  Panggilan API berperingkat tertinggi digunakan sebagai hasil simulasi. <br><br><h4>  Modul susun ulang Seq2Seq </h4><br>  Jaringan saraf menjadi lebih luas sebagai model untuk NLI, sedangkan model Seq2Seq lebih baik daripada yang lain untuk tujuan ini, karena memungkinkan Anda untuk secara alami memproses input dan output urutan panjang variabel.  Kami mengadaptasi model ini untuk NL2API. <br><br>  Untuk urutan input e <img src="https://habrastorage.org/webt/sl/zv/2w/slzv2wvhssrsrt-2cehxkcosmr0.png">  , model memperkirakan distribusi probabilitas bersyarat p (y | x) untuk semua urutan output yang mungkin <img src="https://habrastorage.org/webt/zz/ar/74/zzar74ttz1utynmp2qpkuprrhwc.png">  .  Panjang T dan T â€² dapat bervariasi dan mengambil nilai apa pun.  Dalam NL2API, x adalah pernyataan keluaran.  y dapat berupa panggilan API serial atau perintah kanoniknya.  Kami akan menggunakan perintah kanonik sebagai urutan output target, yang sebenarnya mengubah masalah kami menjadi masalah pengulangan kata. <br><br>  Encoder diimplementasikan sebagai jaringan saraf berulang (RNN) dengan unit perulangan terkontrol (GRU) pertama kali mewakili x sebagai vektor ukuran tetap, <br><br><img src="https://habrastorage.org/webt/_l/vv/ht/_lvvhtq3g73uajiwibi7r5xzspc.png"><br><br>  di mana RN N adalah representasi singkat untuk menerapkan GRU ke seluruh urutan input, penanda demi penanda, diikuti oleh output dari status tersembunyi terakhir. <br><br>  Dekoder, yang juga merupakan RNN dengan GRU, mengambil h0 sebagai keadaan awal dan memproses urutan keluaran y, penanda demi penanda, untuk menghasilkan urutan keadaan, <br><br><img src="https://habrastorage.org/webt/eo/lg/9l/eolg9ljwlyskjfurunypvlmswaa.png"><br><br>  Lapisan output mengambil setiap status dekoder sebagai nilai input dan menghasilkan distribusi kamus <img src="https://habrastorage.org/webt/a-/v8/rh/a-v8rh1ddeh_ai-eawq8udhqe80.png">  sebagai nilai output.  Kami hanya menggunakan transformasi affine diikuti oleh softmax fungsi logistik multi-variabel: <br><br><img src="https://habrastorage.org/webt/qr/ty/c9/qrtyc9lsayvqiczswbr-837_pba.png"><br><br>  Probabilitas kondisional akhir, yang memungkinkan kita untuk mengevaluasi seberapa baik perintah kanonik y mengulangi pernyataan input x, adalah <img src="https://habrastorage.org/webt/l5/yt/wn/l5ytwnga_iegxtspqogvabwe5g0.png"><img src="https://habrastorage.org/webt/ul/7k/ny/ul7knyk1imjwc0p_hrjisfmy8-e.png">  .  Panggilan API kemudian diberi peringkat berdasarkan probabilitas kondisional dari perintah kanonik mereka.  Kami menyarankan Anda membiasakan diri dengan sumbernya, di mana proses pembelajaran model dijelaskan secara lebih rinci. <br><br><h2>  Eksperimen </h2><br>  Secara eksperimental, kami mempelajari subjek penelitian berikut: [PI1]: Bisakah kita menggunakan kerangka kerja yang diusulkan untuk mengumpulkan data pelatihan berkualitas tinggi dengan harga yang wajar?  [PI2]: Apakah jaringan semantik memberikan penilaian model bahasa yang lebih akurat daripada penilaian kemungkinan maksimum?  [PI3]: Apakah strategi distribusi diferensial meningkatkan efisiensi crowdsourcing? <br><br><h4>  Crowdsourcing </h4><br>       -API  Microsoft â€” GET-Events  GET-Messages â€”              .       API,    API ( 3.1)      .   API    2.      ,  Amazon Mechanical Turk.    ,     API    . <br><br>             .   API  10 ,       10 .    201 ,        .          44 ,     82       ,    8,2 , ,   ,  .    ,    400    ,     17,4 %. <br><br>         (,     ORDERBY  a COUNT parameter)     (,    ,        ).       .            NLI.  ,  ,    [1] .           . <br><br>  ,      ,         ,   ,  API    (. 3).   API       .        ,    .     61  API  157   GET-Messages,   77  API  190   GET-Events.        ,  ,    API (,    )     , ,     . <br><br><img src="https://habrastorage.org/webt/dc/yk/nv/dcyknvmod2su0cutkru02tpklti.png"><br> <i> 2.   API.</i> <br><br><img src="https://habrastorage.org/webt/x9/dm/_b/x9dm_bbbgyua7xe0cl1fzjloc5o.png"><br> <i> 3.   :  ().</i> <br><br><h4>   </h4><br>       ,     ,      .    ,   Î± = 0,3,    LM Î² = 0,001.    K,    ,  100 000.    , ,      Seq2Seq â€” 500.           (  ). <br><br>                  NLI,     .          . <br><br><h4>    </h4><br>  .         ,  ,            .         LM:   ,   .     ,     . ROOT â€”   . TOP2 = ROOT +    2;  TOP3 = TOP2 +    3.            . <br><br>     4.      LM      (MLE)    ,     <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">    ,      . ,    ,      ,  MLE       . <br><br>    MLE,      <img src="https://habrastorage.org/webt/rz/hi/nv/rzhinvau9uyozj1iphz8idarw9m.png">   ,  <img src="https://habrastorage.org/webt/1d/h2/o8/1dh2o8om1hinyzi3r41ipp4pd3e.png"> -    ,    .     API    .    16   API (ROOT)   LM  SeMesh        Seq2Seq       API (TOP2)    ,   500   API (TOP3). <br><br>    ,   ,     ,  ,     ( 3.2)   .  ,    GET-Events    ,   GET-Messages.   ,  GET-Events  <br>  ,    ,        ,         . <br><br><img src="https://habrastorage.org/webt/pb/ym/e4/pbyme4xdpxcqabwlawu_bmkefkg.png"><br> <i> 4.    .        LM,       Seq2Seq,      .  ,        .</i> <br><br>  LM +  ,      ,       <img src="https://habrastorage.org/webt/1d/h2/o8/1dh2o8om1hinyzi3r41ipp4pd3e.png">     Î¸em with <img src="https://habrastorage.org/webt/rz/hi/nv/rzhinvau9uyozj1iphz8idarw9m.png">  .    <img src="https://habrastorage.org/webt/1d/h2/o8/1dh2o8om1hinyzi3r41ipp4pd3e.png">  dan <img src="https://habrastorage.org/webt/rz/hi/nv/rzhinvau9uyozj1iphz8idarw9m.png"> ,    ,    ROOT,          <img src="https://habrastorage.org/webt/1d/h2/o8/1dh2o8om1hinyzi3r41ipp4pd3e.png">  dan <img src="https://habrastorage.org/webt/rz/hi/nv/rzhinvau9uyozj1iphz8idarw9m.png">  .    ,        ,    .             MLE.  ,  ,    [2] . <br><br>        0,45  0,6:    ,           NLI   .    ,            API.        API (.   7)     ,    RNN   ,     .       . <br><br>  .        :   |u |    Î±.   -     LM ( 7).    ,  |u | &lt; 10,         10  .     GET-Events,  GET-Messages  . <br><br> ,         ,   ,    . ,    ,    .   ,       Î±,        ([0.1, 0.7]).   Î±      ,   ,      . <br><br><h4>   </h4><br>            (DP)   .       API  .       50  API,    ,    NL2API      . <br><br> ,     .     LM,      .             .           ,       ( 5.1),          API   . <br><br><img src="https://habrastorage.org/webt/lg/xz/z9/lgxzz9zznpwnk0c4vdqfnfaurrg.png"><br>  7.  . <br><br><img src="https://habrastorage.org/webt/ak/5p/da/ak5pda8vlogeadhfjphy-t33dcg.png"><br>  8.    . : GET-Events. : GET-Messages <br><br>       breadth first (BF),          .    .     .  API    ,       API  . <br><br>      8.    NL2API   API  DP      .     300    API,    Seq2Seq, DP      7 %   API.       ,  .  ,  DP    API,      NL2API.  ,  ,    [3] . <br><br><h2>    </h2><br> - .   -  (NLI)     .  NLI    . ,   ,       .                . <br><br>      NLI    ,    -,    API   .  NL2API     :      API ,   - ,   .      .      API    REST           . <br><br> <b>    NLI.</b>        NLI    Â«  Â». ,         Google Suggest API,        API   IFTTT.         NLI,       .        ,   . <br><br>          NLI,                  .        NLI   ,          .           ,           ,        . <br><br>                  API  .         ,          -API.                  . <br><br> <b>   -API.</b>     ,   -API. ,   -API      API,         -API   .  NL2API     , ,          API. <br><br><h2>      </h2><br>     -   -API (NL2API)       NL2API  .                NL2API   .       : (1)  .            , , ? (2)  . <br><br>      ? (3)  NL2API. ,               API. (4)  API.         API? (5)    :    NL2API        ? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418559/">https://habr.com/ru/post/id418559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418547/index.html">Pemrograman Asinkron dengan Contoh: Merekonstruksi java.util.concurrent.CompletableFuture Methods</a></li>
<li><a href="../id418549/index.html">Membuat bot untuk berpartisipasi dalam AI mini cup 2018 berdasarkan pada jaringan saraf berulang (bagian 3)</a></li>
<li><a href="../id418551/index.html">Berapa banyak yang harus diketahui seorang programmer matematika?</a></li>
<li><a href="../id418553/index.html">Kotlin + Bereaksi vs Javasript + Bereaksi</a></li>
<li><a href="../id418557/index.html">Perhitungan proses gelombang dalam saluran hidrolik menggunakan metode karakteristik</a></li>
<li><a href="../id418561/index.html">Mesin negara dalam layanan MVP. Kuliah Yandex</a></li>
<li><a href="../id418563/index.html">Intisari materi menarik untuk pengembang seluler # 263 (23 Juli - 29 Juli)</a></li>
<li><a href="../id418565/index.html">Dalam perjalanan ke cakupan kode 100% dengan tes di Go menggunakan sql-dumper sebagai contoh</a></li>
<li><a href="../id418567/index.html">Dell akan berhenti menjadi perusahaan swasta dan untuk pertama kalinya dalam 5 tahun akan menempatkan saham di bursa saham</a></li>
<li><a href="../id418569/index.html">Satelit baru - bug baru: Sensor inframerah satelit GOES-17 tidak sejuk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>