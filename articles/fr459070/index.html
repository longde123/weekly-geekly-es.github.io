<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë©üèæ üõåüèº üöÑ Cr√©ation de Tower Defense dans Unity: Tours et tir ennemis üë¶üèæ üé† ‚úåüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Les premi√®re et deuxi√®me parties du tutoriel] 



- Nous pla√ßons sur le terrain de la tour. 
- Nous visons les ennemis √† l'aide de la physique. 
- N...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ation de Tower Defense dans Unity: Tours et tir ennemis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459070/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les premi√®re</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxi√®me</a> parties du tutoriel] <br><br><ul><li>  Nous pla√ßons sur le terrain de la tour. </li><li>  Nous visons les ennemis √† l'aide de la physique. </li><li>  Nous les suivons autant que possible. </li><li>  Nous les photographions avec un faisceau laser. </li></ul><br>  Ceci est la troisi√®me partie d'une s√©rie de tutoriels sur la cr√©ation d'un genre de tower defense simple.  Il d√©crit la cr√©ation de tours, visant et tirant sur les ennemis. <br><br>  Le didacticiel a √©t√© cr√©√© dans Unity 2018.3.0f2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/470/ceb/183/470ceb1832b49ee7372fb79b8425b567.jpg" width="512" height="256"></div><br>  <i>R√©chauffons les ennemis.</i> <br><br><h2>  Cr√©ation de tour </h2><br>  Les murs ne font que ralentir les ennemis, augmentant ainsi la longueur du chemin √† parcourir.  Mais le but du jeu est de d√©truire les ennemis avant qu'ils n'atteignent le point final.  Ce probl√®me est r√©solu en pla√ßant des tours sur le terrain qui leur tireront dessus. <br><a name="habracut"></a><br><h3>  Contenu des tuiles </h3><br>  Les tours sont un autre type de contenu de tuiles, alors ajoutons une entr√©e pour elles dans <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall, SpawnPoint, Tower‚Ç¨ }</code> </pre> <br>  Dans ce didacticiel, nous prendrons en charge un seul type de tour, qui peut √™tre impl√©ment√© en fournissant √† <code>GameTileContentFactory</code> un lien vers le pr√©fabriqu√© de tour, dont une instance peut √©galement √™tre cr√©√©e via <code>Get</code> . <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Tower‚Ç¨: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(towerPrefab); } ‚Ä¶ }</code> </pre> <br>  Mais les tours doivent tirer, leur √©tat devra donc √™tre mis √† jour et ils auront besoin de leur propre code.  Cr√©ez une classe <code>Tower</code> √† cet effet qui √©tend la classe <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tower</span></span> : <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> {}</code> </pre> <br>  Vous pouvez faire en sorte que le pr√©fabriqu√© de tour ait son propre composant en rempla√ßant le type de champ d'usine par <code>Tower</code> .  √âtant donn√© que la classe est toujours consid√©r√©e comme un <code>GameTileContent</code> , rien d'autre ne doit √™tre chang√©. <br><br><pre> <code class="cs hljs"> Tower towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><h3>  Pr√©fabriqu√© </h3><br>  Cr√©ez un pr√©fabriqu√© pour la tour.  Vous pouvez commencer par dupliquer le pr√©fabriqu√© du mur et remplacer son composant <code>GameTileContent</code> par le composant <code>Tower</code> , puis changer son type en <em>Tower</em> .  Pour que la tour s'adapte aux murs, enregistrez le cube mural comme base de la tour.  Placez ensuite un autre cube dessus.  Je lui ai donn√© une √©chelle de 0,5.  Mettez un autre cube dessus, indiquant une tourelle, cette partie visera et tirera sur les ennemis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/e5d/633/392e5d63397672627c3b5ec018df0444.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/dec/c33/d92decc33036a1e973a7f20a3df2c00e.png" width="320" height="120"></div><br>  <i>Trois cubes formant une tour.</i> <br><br>  La tourelle tournera, et comme elle a un collisionneur, elle sera suivie par un moteur physique.  Mais nous n'avons pas besoin d'√™tre aussi pr√©cis, car nous n'utilisons des collisionneurs de tour que pour s√©lectionner les cellules.  Cela peut √™tre fait approximativement.  Retirez le collisionneur de cubes de tourelle et changez le collisionneur de cubes de tour afin qu'il couvre les deux cubes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/11e/3b7/e0111e3b7221bbbe4e5b0d23373e4b3a.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/857/09b/a1f85709bd504d176a18930240edea5a.png" width="320" height="152"></div><br>  <i>Collider cube tower.</i> <br><br>  La tour tirera un faisceau laser.  Il peut √™tre visualis√© de plusieurs fa√ßons, mais nous utilisons simplement un cube translucide, que nous allons √©tirer pour former un faisceau.  Chaque tour doit avoir sa propre poutre, alors ajoutez-la au pr√©fabriqu√© de la tour.  Placez-le √† l'int√©rieur de la tourelle pour qu'il soit cach√© par d√©faut et donnez-lui une √©chelle plus petite, par exemple 0,2.  Faisons-en un enfant de la racine pr√©fabriqu√©e, pas du cube de tourelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19a/1dc/29e/19a1dc29e70adb158e07f29653db2d66.png" width="190" height="260" alt="faisceau laser"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/273/081/45a273081365aa9e483f1aa97cbe39c8.png" width="226" height="108" alt="hi√©rarchie"></div><br>  <i>Cube cach√© d'un faisceau laser.</i> <br><br>  Cr√©ez un mat√©riau adapt√© au faisceau laser.  J'ai juste utilis√© le mat√©riau noir translucide standard et d√©sactiv√© tous les reflets, et lui ai √©galement donn√© une couleur rouge √©mise. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fb/e49/860/2fbe498604cc4cc4ed6ee60a45eea63d.png" width="320" height="284" alt="couleur"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/b46/483/0ebb4648376a7fe68c96b7a16ce27db9.png" width="320" height="56" alt="pas de reflets"></div><br>  <i>Le mat√©riau du faisceau laser.</i> <br><br>  V√©rifiez que le faisceau laser n'a pas de collisionneur, et d√©sactivez √©galement sa dominante et son ombre. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecf/f21/0ad/ecff210ad75ef4b12cb0a74102365492.png" width="320" height="162"></div><br>  <i>Le faisceau laser n'interagit pas avec les ombres.</i> <br><br>  Apr√®s avoir termin√© la cr√©ation de la tour pr√©fabriqu√©e, nous l'ajouterons √† l'usine. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/626/37c/935/62637c9353cf1e20e170e82bbefcdb11.png" width="320" height="114"></div><br>  <i>Usine avec une tour.</i> <br><br><h3>  Placement de la tour </h3><br>  Nous ajouterons et supprimerons des tours en utilisant une autre m√©thode de commutation.  Vous pouvez simplement dupliquer <code>GameBoard.ToggleWall</code> en modifiant le nom de la m√©thode et le type de contenu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower‚Ç¨) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower‚Ç¨); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } }</code> </pre> <br>  Dans <code>Game.HandleTouch</code> , maintenir la touche Maj enfonc√©e fera basculer les tours plut√¥t que les murs. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { board.ToggleTower(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.ToggleWall(tile); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/926/804/2ac/9268042acc19a28d6ff1a6d74d83144f.png" width="230" height="230"></div><br>  <i>Tours sur le terrain.</i> <br><br><h3>  Blocage de chemin </h3><br>  Jusqu'√† pr√©sent, seuls les murs peuvent bloquer la recherche d'un chemin, donc les ennemis se d√©placent √† travers les tours.  Ajoutons √† <code>GameTileContent</code> propri√©t√© auxiliaire qui indique si le contenu bloque le chemin.  Le chemin est bloqu√© s'il s'agit d'un mur ou d'une tour. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BlocksPath =&gt; Type == GameTileContentType.Wall || Type == GameTileContentType.Tower‚Ç¨;</code> </pre> <br>  Utilisez cette propri√©t√© dans <code>GameTile.GrowPathTo</code> au lieu de v√©rifier le type de contenu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor, Direction direction</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">//neighbor.Content.Type != GameTileContentType.Wall ? neighbor : null; neighbor.Content.BlocksPath ? null : neighbor; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/93f/eed/6fa93feedb4925ee12decb4233612a4c.png" width="230" height="230"></div><br>  <i>Maintenant, le chemin est bloqu√© par des murs et des tours.</i> <br><br><h3>  Remplacer les murs </h3><br>  Tr√®s probablement, le joueur remplacera souvent les murs par des tours.  Il sera g√™nant pour lui de retirer le mur en premier, et en outre, les ennemis peuvent p√©n√©trer dans cet espace temporairement apparu.  Vous pouvez impl√©menter un remplacement direct en for√ßant <code>GameBoard.ToggleTower</code> √† v√©rifier si le mur est actuellement sur la tuile.  Si c'est le cas, remplacez-le imm√©diatement par une tour.  Dans ce cas, nous n'avons pas √† chercher d'autres moyens, car la tuile les bloque toujours. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); } }</code> </pre> <br><h2>  Nous visons les ennemis </h2><br>  Une tour ne peut remplir sa t√¢che que lorsqu'elle trouve un ennemi.  Apr√®s avoir trouv√© l'ennemi, elle doit d√©cider quelle partie de celui-ci viser. <br><br><h3>  Point de vis√©e </h3><br>  Pour d√©tecter des cibles, nous utiliserons le moteur physique.  Comme dans le cas du collisionneur de tours, nous n'avons pas besoin que le collisionneur ennemi co√Øncide n√©cessairement avec sa forme.  Vous pouvez choisir le collisionneur le plus simple, c'est-√†-dire une sph√®re.  Apr√®s avoir d√©tect√© l'ennemi, nous utiliserons la position de l'objet de jeu avec le collisionneur attach√© comme point de vis√©e. <br><br>  Nous ne pouvons pas attacher le collisionneur √† l‚Äôobjet racine de l‚Äôennemi, car il ne co√Øncide pas toujours avec la position du mod√®le et fera viser la tour au sol.  Autrement dit, vous devez placer le collisionneur quelque part sur le mod√®le.  Le moteur physique nous fournira un lien vers cet objet, que nous pouvons utiliser pour viser, mais nous avons toujours besoin d'acc√©der au composant <code>Enemy</code> de l'objet racine.  Pour simplifier la t√¢che, cr√©ons le composant <code>TargetPoint</code> .  Donnons-lui une propri√©t√© pour affectation priv√©e et r√©ception publique du composant <code>Enemy</code> , et une autre propri√©t√© pour obtenir sa position dans le monde. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TargetPoint</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Enemy Enemy‚Ç¨ { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Position =&gt; transform.position; }</code> </pre> <br>  Donnons-lui une m√©thode <code>Awake</code> qui √©tablit un lien vers son composant <code>Enemy</code> .  Acc√©dez directement √† l'objet racine √† l'aide de <code>transform.root</code> .  Si le composant <code>Enemy</code> n'existe pas, alors nous avons fait une erreur lors de la cr√©ation de l'ennemi, alors ajoutons une d√©claration pour cela. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy‚Ç¨ = transform.root.GetComponent&lt;Enemy&gt;(); Debug.Assert(Enemy‚Ç¨ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  De plus, le collisionneur doit √™tre attach√© au m√™me objet de jeu auquel <code>TargetPoint</code> attach√©. <br><br><pre> <code class="cs hljs"> Debug.Assert(Enemy‚Ç¨ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Debug.Assert( GetComponent&lt;SphereCollider&gt;() != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without sphere collider!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> );</code> </pre> <br>  Ajoutez un composant et un collisionneur au cube pr√©fabriqu√© de l'ennemi.  Cela fera viser les tours au centre du cube.  Nous utilisons un collisionneur sph√©rique avec un rayon de 0,25.  Le cube a une √©chelle de 0,5, donc le vrai rayon du collisionneur sera de 0,125.  Gr√¢ce √† cela, l'ennemi devra traverser visuellement le cercle de port√©e de la tour, et seulement apr√®s un certain temps, le v√©ritable objectif devient.  La taille du collisionneur est √©galement affect√©e par l'√©chelle al√©atoire de l'ennemi, donc sa taille dans le jeu variera √©galement l√©g√®rement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85e/5ca/5e4/85e5ca5e47b8d59fa4211c78126bd512.png" width="176" height="176"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/a71/aec/7aea71aecbd64d4e045df141ecd1c711.png" width="320" height="176" alt="inspecteur"></div><br>  <i>Un ennemi avec un point de vis√©e et un collisionneur sur un cube.</i> <br><br><h3>  Couche ennemie </h3><br>  Les tours ne se soucient que des ennemis, et elles ne visent rien d'autre, nous allons donc mettre tous les ennemis dans une couche distincte.  Nous utiliserons la couche 9. Changez son nom pour <em>Enemy</em> dans la fen√™tre <em>Layers &amp; Tags</em> , qui peut √™tre ouverte via l'option <em>Edit Layers</em> dans le menu d√©roulant <em>Layers</em> dans le coin sup√©rieur droit de l'√©diteur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e6/9a5/762/8e69a5762e8eb1856175f9d9dc1ab388.png" width="320" height="308"></div><br>  <i>La couche 9 sera utilis√©e pour les ennemis.</i> <br><br>  Cette couche n'est n√©cessaire que pour la reconnaissance des ennemis, et non pour les interactions physiques.  Signalons-le en les d√©sactivant dans la <em>matrice de collision des couches</em> , qui se trouve dans le panneau <em>Physique</em> des param√®tres du projet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/876/06e/e7d/87606ee7dfc4777760d81219517125ce.png" width="200" height="200"></div><br>  <i>Matrice des collisions de couches.</i> <br><br>  Assurez-vous que l'objet de jeu du point de vis√©e se trouve sur la couche souhait√©e.  Le reste du pr√©fabriqu√© ennemi peut se trouver sur d'autres calques, mais il sera plus facile de tout coordonner et de placer le pr√©fabriqu√© entier dans le calque <em>ennemi</em> .  Si vous modifiez le calque de l'objet racine, vous serez invit√© √† modifier le calque de tous ses objets enfants. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/f75/062/6d1f75062420abadb285e9efca1e1a5e.png" width="320" height="44"></div><br>  <i>Ennemi sur la bonne couche.</i> <br><br>  Ajoutons la d√©claration que <code>TargetPoint</code> vraiment sur la bonne couche. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ Debug.Assert(gameObject.layer == <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point on wrong layer!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  De plus, les actions du joueur doivent √™tre ignor√©es par les collisionneurs ennemis.  Cela peut √™tre r√©alis√© en ajoutant un argument de masque de calque √† <code>Physics.Raycast</code> dans <code>GameBoard.GetTile</code> .  Cette m√©thode a une forme qui prend la distance au faisceau et au masque de calque comme arguments suppl√©mentaires.  Nous lui donnerons la distance maximale et le masque de calque par d√©faut, c'est-√†-dire 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.MaxValue, <span class="hljs-number"><span class="hljs-number">1</span></span>)) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Le masque de calque ne doit-il pas √™tre 0?</b> <div class="spoiler_text">  L'index de calque par d√©faut est z√©ro, mais nous passons le masque de calque.  Le masque change les bits individuels d'un entier en 1 si la couche doit √™tre activ√©e.  Dans ce cas, vous devez d√©finir uniquement le premier bit, c'est-√†-dire le moins significatif, ce qui signifie 2 <sup>0</sup> , ce qui √©quivaut √† 1. </div></div><br><h3>  Mise √† jour du contenu des vignettes </h3><br>  Les tours ne peuvent effectuer leur t√¢che que lorsque leur statut est mis √† jour.  La m√™me chose s'applique au contenu de toutes les tuiles, bien que le reste du contenu ne fasse rien jusqu'√† pr√©sent.  Par cons√©quent, ajoutez une m√©thode virtuelle <code>GameTileContent</code> √† <code>GameUpdate</code> , qui ne fait rien par d√©faut. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br>  Faisons en sorte que <code>Tower</code> red√©finisse, m√™me si pour l'instant il affiche simplement dans la console qu'il recherche une cible. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Searching for target..."</span></span>); }</code> </pre> <br>  <code>GameBoard</code> traite des tuiles et de leur contenu, il gardera donc √©galement la trace du contenu √† mettre √† jour.  Pour ce faire, ajoutez-y la liste et la m√©thode publique <code>GameUpdate</code> , qui met √† jour tout dans la liste. <br><br><pre> <code class="cs hljs"> List&lt;GameTileContent&gt; updatingContent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameTileContent&gt;(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; updatingContent.Count; i++) { updatingContent[i].GameUpdate(); } }</code> </pre> <br>  Dans notre tutoriel, il vous suffit de mettre √† jour les tours.  Modifiez <code>ToggleTower</code> pour qu'il ajoute et supprime du contenu si n√©cessaire.  Si d'autres contenus sont √©galement n√©cessaires, nous aurons besoin d'une approche plus g√©n√©rale, mais pour l'instant, cela suffit. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { updatingContent.Remove(tile.Content); tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower); <span class="hljs-comment"><span class="hljs-comment">//if (!FindPaths()) { if (FindPaths()) { updatingContent.Add(tile.Content); } else { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } else if (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); updatingContent.Add(tile.Content); } }</span></span></code> </pre> <br>  Pour que cela fonctionne, il nous suffit maintenant de simplement mettre √† jour le champ dans <code>Game.Update</code> .  Nous mettrons √† jour le champ apr√®s les ennemis.  Gr√¢ce √† cela, les tours pourront viser exactement o√π se trouvent les ennemis.  Si nous faisions autrement, les tours viseraient o√π se trouvaient les ennemis dans la derni√®re image. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.GameUpdate(); board.GameUpdate(); }</code> </pre> <br><h3>  Port√©e de vis√©e </h3><br>  Les tours ont un rayon de vis√©e limit√©.  Personnalisons-le en ajoutant un champ √† la classe <code>Tower</code> .  La distance est mesur√©e √† partir du centre de la tuile tour, donc √† une port√©e de 0,5, elle ne couvrira que sa propre tuile.  Par cons√©quent, une plage minimale et standard raisonnable serait de 1,5, couvrant la plupart des carreaux voisins. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1.5f, 10.5f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> targetingRange = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/ae4/ee8/c38ae4ee885cf5d89f24164b9c6bc5fe.png" width="320" height="74"></div><br>  <i>Port√©e de vis√©e 2.5.</i> <br><br>  Visualisons la plage avec gizmo.  Nous n'avons pas besoin de le voir constamment, nous allons donc cr√©er la m√©thode <code>OnDrawGizmosSelected</code> appel√©e uniquement pour les objets s√©lectionn√©s.  Nous dessinons le cadre jaune de la sph√®re avec un rayon √©gal √† la distance et centr√© par rapport √† la tour.  Placez-le l√©g√®rement au-dessus du sol afin qu'il soit toujours clairement visible. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Gizmos.color = Color.yellow; Vector3 position = transform.localPosition; position.y += <span class="hljs-number"><span class="hljs-number">0.01f</span></span>; Gizmos.DrawWireSphere(position, targetingRange); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/6b7/3cd/6746b73cd2e015fd599b770bb89e1c8a.png" width="230" height="230"></div><br>  <i>Port√©e de vis√©e du Gizmo.</i> <br><br>  Nous pouvons maintenant voir lequel des ennemis est une cible abordable pour chacune des tours.  Mais choisir des tours dans la fen√™tre de la sc√®ne n'est pas pratique, car nous devons s√©lectionner l'un des cubes enfants, puis basculer vers l'objet racine de la tour.  D'autres types de contenu de tuiles souffrent √©galement du m√™me probl√®me.  Nous pouvons forcer la s√©lection de la racine du contenu de la <code>GameTileContent</code> dans la fen√™tre de sc√®ne en ajoutant l'attribut <code>SelectionBase</code> au <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SelectionBase</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ }</code> </pre> <br><h3>  Capture de cible </h3><br>  Ajoutez un champ <code>TargetPoint</code> √† la classe <code>Tower</code> afin qu'il puisse suivre sa cible captur√©e.  Ensuite, nous <code>GameUpdate</code> pour appeler la nouvelle m√©thode <code>AquireTarget</code> , qui renvoie des informations <code>AquireTarget</code> si elle a trouv√© la cible.  Lors de la d√©tection, il affichera un message dans la console. <br><br><pre> <code class="cs hljs"> TargetPoint target; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Acquired target!"</span></span>); } }</code> </pre> <br>  Dans <code>AcquireTarget</code> nous obtenons toutes les cibles disponibles en appelant <code>Physics.OverlapSphere</code> avec une position et une plage de tour comme arguments.  Le r√©sultat sera un tableau de <code>Collider</code> contenant tous les collisionneurs en contact avec la sph√®re.  Si la longueur du tableau est positive, alors il y a au moins un point de vis√©e, et nous s√©lectionnons simplement le premier.  Prenez son composant <code>TargetPoint</code> , qui doit toujours exister, affectez-le au champ cible et signalez le succ√®s.  Sinon, nous effa√ßons la cible et signalons l'√©chec. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targets.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targets[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targets[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Nous sommes assur√©s d'obtenir les bons points de vis√©e, si nous ne prenons en compte les collisionneurs que sur la couche d'ennemis.  Ceci est le calque 9, nous allons donc passer le masque de calque correspondant. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enemyLayerMask = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange, enemyLayerMask ); ‚Ä¶ }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Comment fonctionne ce masque de bits?</b> <div class="spoiler_text">  Puisque la couche ennemie a un indice de 9, le dixi√®me bit du masque binaire doit avoir la valeur 1. Cela correspond √† un entier 2 <sup>9</sup> , soit 512. Mais un tel enregistrement de masque binaire n'est pas intuitif.  Nous pouvons √©galement √©crire un litt√©ral binaire, par exemple <code>0b10_0000_0000</code> , mais nous devons ensuite compter les z√©ros.  Dans ce cas, l'entr√©e la plus pratique serait d'utiliser l'op√©rateur de d√©calage gauche <code>&lt;&lt;</code> , qui d√©cale les bits vers la gauche.  ce qui correspond √† un nombre au pouvoir de deux. </div></div><br>  Vous pouvez visualiser la cible captur√©e en tra√ßant une ligne de gizmo entre les positions de la tour et de la cible. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Gizmos.DrawLine(position, target.Position); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a5/e99/4be/7a5e994be6b7d848c2d4bfe7d627c708.png" width="230" height="230"></div><br>  <i>Visualisation des objectifs.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Pourquoi ne pas utiliser des m√©thodes comme OnTriggerEnter?</b> <div class="spoiler_text">  L'avantage de la v√©rification manuelle des objectifs transversaux est que nous ne pouvons le faire qu'en cas de besoin.  Il n'y a aucune raison de v√©rifier les cibles si la tour en a d√©j√† une.  De plus, en obtenant tous les objectifs potentiels √† la fois, nous n'avons pas √† traiter une liste d'objectifs potentiels pour chaque tour, qui est en constante √©volution. </div></div><br><h3>  Verrouillage de cible </h3><br>  La cible choisie pour la capture d√©pend de l'ordre dans lequel ils sont repr√©sent√©s par le moteur physique, c'est-√†-dire en fait arbitraire.  Par cons√©quent, il appara√Ætra que la cible captur√©e change sans raison.  Une fois que la tour a re√ßu la cible, il est plus logique pour elle de la suivre et de ne pas passer √† une autre.  Ajoutez une m√©thode <code>TrackTarget</code> qui impl√©mente un tel suivi et renvoie des informations pour savoir si elle a r√©ussi.  Tout d'abord, nous vous informerons simplement si la cible est captur√©e. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Nous appellerons cette m√©thode dans <code>GameUpdate</code> et ce n'est qu'en renvoyant false que nous appellerons <code>AcquireTarget</code> .  Si la m√©thode est retourn√©e vraie, alors nous avons un objectif.  Cela peut √™tre fait en pla√ßant les deux appels de m√©thode dans une v√©rification <code>if</code> avec l'op√©rateur OR, car si le premier op√©rande renvoie <code>true</code> , le second ne sera pas v√©rifi√© et l'appel sera manqu√©.  L'op√©rateur AND agit de mani√®re similaire. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Locked on target!"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ec/27c/0a2/8ec27c0a2201434cba3725621b68aaa1.png" width="230" height="230"></div><br>  <i>Suivi des objectifs.</i> <br><br>  En cons√©quence, les tours sont fix√©es sur la cible jusqu'√† ce qu'elle atteigne le point final et soit d√©truite.  Si vous utilisez des ennemis √† plusieurs reprises, vous devez plut√¥t v√©rifier l'exactitude du lien, comme cela se fait avec les liens vers les figures trait√©es dans une s√©rie de didacticiels de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gestion</a> des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">objets</a> . <br><br>  Pour suivre les cibles uniquement lorsqu'elles sont √† port√©e, <code>TrackTarget</code> doit suivre la distance entre la tour et la cible.  S'il d√©passe la valeur de la plage, la cible doit √™tre r√©initialis√©e et renvoyer false.  Vous pouvez utiliser la m√©thode <code>Vector3.Distance</code> pour cette v√©rification. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Cependant, ce code ne prend pas en compte le rayon du collisionneur.  Par cons√©quent, en cons√©quence, la tour peut perdre la cible, puis la capturer √† nouveau, seulement pour arr√™ter de la suivre dans l'image suivante, etc.  Nous pouvons √©viter cela en ajoutant un rayon de collisionneur √† la plage. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span>) { ‚Ä¶ }</code> </pre> <br>  Cela nous donne les r√©sultats corrects, mais seulement si l'√©chelle de l'ennemi n'est pas modifi√©e.  Puisque nous donnons √† chaque ennemi une √©chelle al√©atoire, nous devons en tenir compte lors du changement de port√©e.  Pour ce faire, nous devons nous souvenir de l'√©chelle donn√©e par <code>Enemy</code> et l'ouvrir √† l'aide de la propri√©t√© getter. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Scale { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { Scale = scale; ‚Ä¶ }</code> </pre> <br>  Nous pouvons maintenant v√©rifier la plage correcte dans <code>Tower.TrackTarget</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy‚Ç¨.Scale) { ‚Ä¶ }</code> </pre> <br><h3>  Nous synchronisons la physique </h3><br>  Tout semble bien fonctionner, mais les tours qui peuvent viser au centre du champ sont capables de capturer des cibles qui devraient √™tre hors de port√©e.  Ils ne pourront pas suivre ces objectifs, ils ne sont donc fix√©s sur eux que pour une seule image. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e91/0a1/836/e910a1836ef729d95ebee121a67c3f2c.png" width="230" height="230"></div><br>  <i>Vis√©e incorrecte.</i> <br><br>  Cela se produit car l'√©tat du moteur physique est imparfaitement synchronis√© avec l'√©tat du jeu.  Des instances de tous les ennemis sont cr√©√©es √† l'origine du monde, qui co√Øncide avec le centre du champ.  Ensuite, nous les d√©pla√ßons au point de cr√©ation, mais le moteur physique ne le sait pas tout de suite. <br><br>  Vous pouvez activer la synchronisation instantan√©e qui se produit lorsque vous modifiez les transformations d'objets en d√©finissant <code>Physics.autoSyncTransforms</code> sur <code>true</code> .  Mais par d√©faut, il est d√©sactiv√©, car il est beaucoup plus efficace de tout synchroniser ensemble et si n√©cessaire.  Dans notre cas, la synchronisation n'est requise que lors de la mise √† jour de l'√©tat des tours.  Nous pouvons l'ex√©cuter en appelant <code>Physics.SyncTransforms</code> entre les mises √† jour ennemies et sur le terrain dans <code>Game.Update</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.GameUpdate(); Physics.SyncTransforms(); board.GameUpdate(); }</code> </pre> <br><h3>  Ignorer la hauteur </h3><br>  En fait, notre gameplay se d√©roule en 2D.  Par cons√©quent, changeons la <code>Tower</code> sorte que lors de la vis√©e et du suivi, elle ne prenne en compte que les coordonn√©es X et Z. Le moteur physique fonctionne dans l'espace 3D, mais en substance, nous pouvons effectuer <code>AcquireTarget</code> en 2D: √©tirez la sph√®re vers le haut afin qu'elle couvre tous les collisionneurs, quel que soit de leur position verticale.  Cela peut √™tre fait en utilisant une capsule au lieu d'une sph√®re, dont le deuxi√®me point sera √† plusieurs unit√©s au-dessus du sol (par exemple, trois). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">3f</span></span>; Collider[] targets = Physics.OverlapCapsule( a, b, targetingRange, enemyLayerMask ); ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title">    2D-?</b> <div class="spoiler_text">   ,       XZ,   2D-    XY.     ,     ,    2D-   .     3D-. </div></div><br>    <code>TrackTarget</code> . ,    2D-  <code>Vector2.Distance</code> ,            ,   .        . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = ax - bx; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = az - bz; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy‚Ç¨.Scale; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x * x + z * z &gt; r * r) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title">    ?</b> <div class="spoiler_text">     2D-   ,     .     ,       .  ,        ,    . </div></div><br><h3>    </h3><br>   <code>Physics.OverlapCapsule</code>   ,        .   ,         <code>OverlapCapsuleNonAlloc</code>      .       .       .        ,      1. <br><br>   <code>OverlapCapsuleNonAlloc</code>    ,    ,          . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">1</span></span>]; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hits = Physics.OverlapCapsuleNonAlloc( a, b, targetingRange, targetsBuffer, enemyLayerMask ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h2>    </h2><br> ,      ,     .    ,     . <br><br><h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour diriger la tourelle vers la cible, la classe </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit avoir un lien vers le composant </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tourelle. </font><font style="vertical-align: inherit;">Ajoutez un champ de configuration pour cela et connectez-le au pr√©fabriqu√© de la tour.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/3be/41b/e0f3be41b0936993268316b8f01e1f67.png" width="320" height="90"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tourelle attach√©e. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y a une vraie cible, alors nous devons la tirer. </font><font style="vertical-align: inherit;">Mettez le code de prise de vue dans une m√©thode distincte. </font><font style="vertical-align: inherit;">Faites-lui tourner la tourelle vers la cible, en appelant sa m√©thode </font></font><code>Transform.LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec le point de vis√©e comme argument.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { <span class="hljs-comment"><span class="hljs-comment">//Debug.Log("Locked on target!"); Shoot(); } } void Shoot () { Vector3 point = target.Position; turret.LookAt(point); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/5bb/e9d/00e5bbe9d98e739800bf47435ca574af.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visant juste.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous tirons un laser </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour positionner le faisceau laser, la classe a </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©galement besoin d'un lien vers celui-ci.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, laserBeam = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/c9c/86e/802c9c86eac24112cb2b4f072fd0f410.png" width="320" height="110"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons connect√© un faisceau laser. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour transformer un cube en un v√©ritable faisceau laser, vous devez suivre trois √©tapes. </font><font style="vertical-align: inherit;">Tout d'abord, son orientation doit correspondre √† l'orientation de la tourelle. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en copiant sa rotation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxi√®mement, nous mettons √† l'√©chelle le faisceau laser de sorte que sa longueur soit √©gale √† la distance entre le point d'origine local de la tourelle et le point de vis√©e. </font><font style="vertical-align: inherit;">Nous le mettons √† l'√©chelle le long de l'axe Z, c'est-√†-dire l'axe local dirig√© vers la cible. </font><font style="vertical-align: inherit;">Pour conserver l'√©chelle XY d'origine, nous notons l'√©chelle d'origine lorsque nous r√©veillons la tourelle Awake.</font></font><br><br><pre> <code class="cs hljs"> Vector3 laserBeamScale; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { laserBeamScale = laserBeam.localScale; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = Vector3.Distance(turret.position, point); laserBeamScale.z = d; laserBeam.localScale = laserBeamScale; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Troisi√®mement, nous pla√ßons le faisceau laser au milieu entre la tourelle et le point de vis√©e. </font></font><br><br><pre> <code class="cs hljs"> laserBeam.localScale = laserBeamScale; laserBeam.localPosition = turret.localPosition + <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * d * laserBeam.forward;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/288/d96/438/288d96438354bd732fd7a3bb84ead491.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prise de vue au laser.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N'est-il pas possible de faire d'un rayon laser un enfant d'une tourelle?</font></font></b> <div class="spoiler_text">     ,         ,       forward.       ,     .     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela fonctionne pendant que la tourelle est fix√©e sur la cible. </font><font style="vertical-align: inherit;">Mais quand il n'y a pas de cible, le laser reste actif. </font><font style="vertical-align: inherit;">Nous pouvons d√©sactiver l'affichage laser en </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©finissant </font><font style="vertical-align: inherit;">son √©chelle √† </font><font style="vertical-align: inherit;">0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Shoot(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { laserBeam.localScale = Vector3.zero; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/8c8/c23/39b8c8c239e0936137c646f91a4197de.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les tours inactives ne tirent pas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sant√© ennemie </font></font></h3><br>              .   ,     .      ,   <code>Enemy</code>  .       ,    100.   ,       ,     . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Health { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Health = <span class="hljs-number"><span class="hljs-number">100f</span></span> * scale; }</code> </pre> <br>     ,    <code>ApplyDamage</code> ,     .   ,   ,     . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyDamage</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> damage</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(damage &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-string"><span class="hljs-string">"Negative damage applied."</span></span>); Health -= damage; }</code> </pre> <br>       ,      .           <code>GameUpdate</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Health &lt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ }</code> </pre> <br>         ,    ,       ,     ,     . <br><br><h3>    </h3><br>    ,     .     <code>Tower</code>  .       ,        (damage per second).  <code>Shoot</code>     <code>Enemy</code>      . <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1f, 100f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> damagePerSecond = <span class="hljs-number"><span class="hljs-number">10f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ target.Enemy.ApplyDamage(damagePerSecond * Time.deltaTime); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/886/18f/199/88618f199c9c08e7eaeb89b16083f545.png" width="320" height="128" alt="inspecteur"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/vt/sf/gkvtsfa1ya4igbsjagqhtnzu0wq.gif"></div><br> <i>   ‚Äî 20   .</i> <br><br><h3>    </h3><br>        ,     ,       .     ,      ,    ,         .       ,     . <br><br>  ,      ,    .   ,     ,   100. ,              ,       . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">100</span></span>];</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, au lieu de choisir la premi√®re cible potentielle, nous allons s√©lectionner un √©l√©ment al√©atoire dans le tableau. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, hits)].GetComponent&lt;TargetPoint&gt;(); ‚Ä¶ } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/lt/hi/nvlthij_ixh6lsxgwujtoipjwg4.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vis√©e al√©atoire.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'autres crit√®res de choix des objectifs peuvent-ils √™tre utilis√©s?</font></font></b> <div class="spoiler_text"> , ,        .  ,      ,     .    .             . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, dans notre jeu de tower defense, des tours sont enfin apparues. </font><font style="vertical-align: inherit;">Dans la prochaine partie, le jeu prendra encore plus sa forme finale.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459070/">https://habr.com/ru/post/fr459070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459052/index.html">Comment comparer: ¬´voiture incroyable¬ª et ¬´hutte laide¬ª, dans une enqu√™te marketing et dans le big data</a></li>
<li><a href="../fr459054/index.html">Carte thermique des clics - comment les utilisateurs se comportent sur le site</a></li>
<li><a href="../fr459062/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 305 (du 1er au 7 juillet)</a></li>
<li><a href="../fr459066/index.html">√âquilibrage d'√©criture et de lecture de base de donn√©es</a></li>
<li><a href="../fr459068/index.html">Windows Server 2008 R2 - Le roi est mort, vive le roi</a></li>
<li><a href="../fr459074/index.html">Petite petite joie # 7: trois pour le prix d'un - animation sur console, algorithmes et d√©bogage</a></li>
<li><a href="../fr459078/index.html">Le CERN passe aux logiciels open source - pourquoi?</a></li>
<li><a href="../fr459080/index.html">Caract√©ristiques HttpUrlConnection de java.net</a></li>
<li><a href="../fr459082/index.html">Qui sont l'eid√©tique, comment fonctionnent les faux souvenirs et trois mythes populaires sur la m√©moire</a></li>
<li><a href="../fr459084/index.html">Un peu sur Google Home Hub, ou comment j'ai achet√© un cadre photo pour 130 euros</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>