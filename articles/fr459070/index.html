<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👩🏾 🛌🏼 🚄 Création de Tower Defense dans Unity: Tours et tir ennemis 👦🏾 🎠 ✌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Les première et deuxième parties du tutoriel] 



- Nous plaçons sur le terrain de la tour. 
- Nous visons les ennemis à l'aide de la physique. 
- N...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Création de Tower Defense dans Unity: Tours et tir ennemis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459070/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les première</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxième</a> parties du tutoriel] <br><br><ul><li>  Nous plaçons sur le terrain de la tour. </li><li>  Nous visons les ennemis à l'aide de la physique. </li><li>  Nous les suivons autant que possible. </li><li>  Nous les photographions avec un faisceau laser. </li></ul><br>  Ceci est la troisième partie d'une série de tutoriels sur la création d'un genre de tower defense simple.  Il décrit la création de tours, visant et tirant sur les ennemis. <br><br>  Le didacticiel a été créé dans Unity 2018.3.0f2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/470/ceb/183/470ceb1832b49ee7372fb79b8425b567.jpg" width="512" height="256"></div><br>  <i>Réchauffons les ennemis.</i> <br><br><h2>  Création de tour </h2><br>  Les murs ne font que ralentir les ennemis, augmentant ainsi la longueur du chemin à parcourir.  Mais le but du jeu est de détruire les ennemis avant qu'ils n'atteignent le point final.  Ce problème est résolu en plaçant des tours sur le terrain qui leur tireront dessus. <br><a name="habracut"></a><br><h3>  Contenu des tuiles </h3><br>  Les tours sont un autre type de contenu de tuiles, alors ajoutons une entrée pour elles dans <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall, SpawnPoint, Tower€ }</code> </pre> <br>  Dans ce didacticiel, nous prendrons en charge un seul type de tour, qui peut être implémenté en fournissant à <code>GameTileContentFactory</code> un lien vers le préfabriqué de tour, dont une instance peut également être créée via <code>Get</code> . <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { … <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Tower€: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(towerPrefab); } … }</code> </pre> <br>  Mais les tours doivent tirer, leur état devra donc être mis à jour et ils auront besoin de leur propre code.  Créez une classe <code>Tower</code> à cet effet qui étend la classe <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tower</span></span> : <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> {}</code> </pre> <br>  Vous pouvez faire en sorte que le préfabriqué de tour ait son propre composant en remplaçant le type de champ d'usine par <code>Tower</code> .  Étant donné que la classe est toujours considérée comme un <code>GameTileContent</code> , rien d'autre ne doit être changé. <br><br><pre> <code class="cs hljs"> Tower towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><h3>  Préfabriqué </h3><br>  Créez un préfabriqué pour la tour.  Vous pouvez commencer par dupliquer le préfabriqué du mur et remplacer son composant <code>GameTileContent</code> par le composant <code>Tower</code> , puis changer son type en <em>Tower</em> .  Pour que la tour s'adapte aux murs, enregistrez le cube mural comme base de la tour.  Placez ensuite un autre cube dessus.  Je lui ai donné une échelle de 0,5.  Mettez un autre cube dessus, indiquant une tourelle, cette partie visera et tirera sur les ennemis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/e5d/633/392e5d63397672627c3b5ec018df0444.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/dec/c33/d92decc33036a1e973a7f20a3df2c00e.png" width="320" height="120"></div><br>  <i>Trois cubes formant une tour.</i> <br><br>  La tourelle tournera, et comme elle a un collisionneur, elle sera suivie par un moteur physique.  Mais nous n'avons pas besoin d'être aussi précis, car nous n'utilisons des collisionneurs de tour que pour sélectionner les cellules.  Cela peut être fait approximativement.  Retirez le collisionneur de cubes de tourelle et changez le collisionneur de cubes de tour afin qu'il couvre les deux cubes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/11e/3b7/e0111e3b7221bbbe4e5b0d23373e4b3a.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/857/09b/a1f85709bd504d176a18930240edea5a.png" width="320" height="152"></div><br>  <i>Collider cube tower.</i> <br><br>  La tour tirera un faisceau laser.  Il peut être visualisé de plusieurs façons, mais nous utilisons simplement un cube translucide, que nous allons étirer pour former un faisceau.  Chaque tour doit avoir sa propre poutre, alors ajoutez-la au préfabriqué de la tour.  Placez-le à l'intérieur de la tourelle pour qu'il soit caché par défaut et donnez-lui une échelle plus petite, par exemple 0,2.  Faisons-en un enfant de la racine préfabriquée, pas du cube de tourelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19a/1dc/29e/19a1dc29e70adb158e07f29653db2d66.png" width="190" height="260" alt="faisceau laser"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/273/081/45a273081365aa9e483f1aa97cbe39c8.png" width="226" height="108" alt="hiérarchie"></div><br>  <i>Cube caché d'un faisceau laser.</i> <br><br>  Créez un matériau adapté au faisceau laser.  J'ai juste utilisé le matériau noir translucide standard et désactivé tous les reflets, et lui ai également donné une couleur rouge émise. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fb/e49/860/2fbe498604cc4cc4ed6ee60a45eea63d.png" width="320" height="284" alt="couleur"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/b46/483/0ebb4648376a7fe68c96b7a16ce27db9.png" width="320" height="56" alt="pas de reflets"></div><br>  <i>Le matériau du faisceau laser.</i> <br><br>  Vérifiez que le faisceau laser n'a pas de collisionneur, et désactivez également sa dominante et son ombre. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecf/f21/0ad/ecff210ad75ef4b12cb0a74102365492.png" width="320" height="162"></div><br>  <i>Le faisceau laser n'interagit pas avec les ombres.</i> <br><br>  Après avoir terminé la création de la tour préfabriquée, nous l'ajouterons à l'usine. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/626/37c/935/62637c9353cf1e20e170e82bbefcdb11.png" width="320" height="114"></div><br>  <i>Usine avec une tour.</i> <br><br><h3>  Placement de la tour </h3><br>  Nous ajouterons et supprimerons des tours en utilisant une autre méthode de commutation.  Vous pouvez simplement dupliquer <code>GameBoard.ToggleWall</code> en modifiant le nom de la méthode et le type de contenu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower€) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower€); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } }</code> </pre> <br>  Dans <code>Game.HandleTouch</code> , maintenir la touche Maj enfoncée fera basculer les tours plutôt que les murs. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { board.ToggleTower(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.ToggleWall(tile); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/926/804/2ac/9268042acc19a28d6ff1a6d74d83144f.png" width="230" height="230"></div><br>  <i>Tours sur le terrain.</i> <br><br><h3>  Blocage de chemin </h3><br>  Jusqu'à présent, seuls les murs peuvent bloquer la recherche d'un chemin, donc les ennemis se déplacent à travers les tours.  Ajoutons à <code>GameTileContent</code> propriété auxiliaire qui indique si le contenu bloque le chemin.  Le chemin est bloqué s'il s'agit d'un mur ou d'une tour. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BlocksPath =&gt; Type == GameTileContentType.Wall || Type == GameTileContentType.Tower€;</code> </pre> <br>  Utilisez cette propriété dans <code>GameTile.GrowPathTo</code> au lieu de vérifier le type de contenu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor, Direction direction</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">//neighbor.Content.Type != GameTileContentType.Wall ? neighbor : null; neighbor.Content.BlocksPath ? null : neighbor; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/93f/eed/6fa93feedb4925ee12decb4233612a4c.png" width="230" height="230"></div><br>  <i>Maintenant, le chemin est bloqué par des murs et des tours.</i> <br><br><h3>  Remplacer les murs </h3><br>  Très probablement, le joueur remplacera souvent les murs par des tours.  Il sera gênant pour lui de retirer le mur en premier, et en outre, les ennemis peuvent pénétrer dans cet espace temporairement apparu.  Vous pouvez implémenter un remplacement direct en forçant <code>GameBoard.ToggleTower</code> à vérifier si le mur est actuellement sur la tuile.  Si c'est le cas, remplacez-le immédiatement par une tour.  Dans ce cas, nous n'avons pas à chercher d'autres moyens, car la tuile les bloque toujours. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); } }</code> </pre> <br><h2>  Nous visons les ennemis </h2><br>  Une tour ne peut remplir sa tâche que lorsqu'elle trouve un ennemi.  Après avoir trouvé l'ennemi, elle doit décider quelle partie de celui-ci viser. <br><br><h3>  Point de visée </h3><br>  Pour détecter des cibles, nous utiliserons le moteur physique.  Comme dans le cas du collisionneur de tours, nous n'avons pas besoin que le collisionneur ennemi coïncide nécessairement avec sa forme.  Vous pouvez choisir le collisionneur le plus simple, c'est-à-dire une sphère.  Après avoir détecté l'ennemi, nous utiliserons la position de l'objet de jeu avec le collisionneur attaché comme point de visée. <br><br>  Nous ne pouvons pas attacher le collisionneur à l’objet racine de l’ennemi, car il ne coïncide pas toujours avec la position du modèle et fera viser la tour au sol.  Autrement dit, vous devez placer le collisionneur quelque part sur le modèle.  Le moteur physique nous fournira un lien vers cet objet, que nous pouvons utiliser pour viser, mais nous avons toujours besoin d'accéder au composant <code>Enemy</code> de l'objet racine.  Pour simplifier la tâche, créons le composant <code>TargetPoint</code> .  Donnons-lui une propriété pour affectation privée et réception publique du composant <code>Enemy</code> , et une autre propriété pour obtenir sa position dans le monde. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TargetPoint</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Enemy Enemy€ { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Position =&gt; transform.position; }</code> </pre> <br>  Donnons-lui une méthode <code>Awake</code> qui établit un lien vers son composant <code>Enemy</code> .  Accédez directement à l'objet racine à l'aide de <code>transform.root</code> .  Si le composant <code>Enemy</code> n'existe pas, alors nous avons fait une erreur lors de la création de l'ennemi, alors ajoutons une déclaration pour cela. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy€ = transform.root.GetComponent&lt;Enemy&gt;(); Debug.Assert(Enemy€ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  De plus, le collisionneur doit être attaché au même objet de jeu auquel <code>TargetPoint</code> attaché. <br><br><pre> <code class="cs hljs"> Debug.Assert(Enemy€ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Debug.Assert( GetComponent&lt;SphereCollider&gt;() != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without sphere collider!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> );</code> </pre> <br>  Ajoutez un composant et un collisionneur au cube préfabriqué de l'ennemi.  Cela fera viser les tours au centre du cube.  Nous utilisons un collisionneur sphérique avec un rayon de 0,25.  Le cube a une échelle de 0,5, donc le vrai rayon du collisionneur sera de 0,125.  Grâce à cela, l'ennemi devra traverser visuellement le cercle de portée de la tour, et seulement après un certain temps, le véritable objectif devient.  La taille du collisionneur est également affectée par l'échelle aléatoire de l'ennemi, donc sa taille dans le jeu variera également légèrement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85e/5ca/5e4/85e5ca5e47b8d59fa4211c78126bd512.png" width="176" height="176"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/a71/aec/7aea71aecbd64d4e045df141ecd1c711.png" width="320" height="176" alt="inspecteur"></div><br>  <i>Un ennemi avec un point de visée et un collisionneur sur un cube.</i> <br><br><h3>  Couche ennemie </h3><br>  Les tours ne se soucient que des ennemis, et elles ne visent rien d'autre, nous allons donc mettre tous les ennemis dans une couche distincte.  Nous utiliserons la couche 9. Changez son nom pour <em>Enemy</em> dans la fenêtre <em>Layers &amp; Tags</em> , qui peut être ouverte via l'option <em>Edit Layers</em> dans le menu déroulant <em>Layers</em> dans le coin supérieur droit de l'éditeur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e6/9a5/762/8e69a5762e8eb1856175f9d9dc1ab388.png" width="320" height="308"></div><br>  <i>La couche 9 sera utilisée pour les ennemis.</i> <br><br>  Cette couche n'est nécessaire que pour la reconnaissance des ennemis, et non pour les interactions physiques.  Signalons-le en les désactivant dans la <em>matrice de collision des couches</em> , qui se trouve dans le panneau <em>Physique</em> des paramètres du projet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/876/06e/e7d/87606ee7dfc4777760d81219517125ce.png" width="200" height="200"></div><br>  <i>Matrice des collisions de couches.</i> <br><br>  Assurez-vous que l'objet de jeu du point de visée se trouve sur la couche souhaitée.  Le reste du préfabriqué ennemi peut se trouver sur d'autres calques, mais il sera plus facile de tout coordonner et de placer le préfabriqué entier dans le calque <em>ennemi</em> .  Si vous modifiez le calque de l'objet racine, vous serez invité à modifier le calque de tous ses objets enfants. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/f75/062/6d1f75062420abadb285e9efca1e1a5e.png" width="320" height="44"></div><br>  <i>Ennemi sur la bonne couche.</i> <br><br>  Ajoutons la déclaration que <code>TargetPoint</code> vraiment sur la bonne couche. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … Debug.Assert(gameObject.layer == <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point on wrong layer!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  De plus, les actions du joueur doivent être ignorées par les collisionneurs ennemis.  Cela peut être réalisé en ajoutant un argument de masque de calque à <code>Physics.Raycast</code> dans <code>GameBoard.GetTile</code> .  Cette méthode a une forme qui prend la distance au faisceau et au masque de calque comme arguments supplémentaires.  Nous lui donnerons la distance maximale et le masque de calque par défaut, c'est-à-dire 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.MaxValue, <span class="hljs-number"><span class="hljs-number">1</span></span>)) { … } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Le masque de calque ne doit-il pas être 0?</b> <div class="spoiler_text">  L'index de calque par défaut est zéro, mais nous passons le masque de calque.  Le masque change les bits individuels d'un entier en 1 si la couche doit être activée.  Dans ce cas, vous devez définir uniquement le premier bit, c'est-à-dire le moins significatif, ce qui signifie 2 <sup>0</sup> , ce qui équivaut à 1. </div></div><br><h3>  Mise à jour du contenu des vignettes </h3><br>  Les tours ne peuvent effectuer leur tâche que lorsque leur statut est mis à jour.  La même chose s'applique au contenu de toutes les tuiles, bien que le reste du contenu ne fasse rien jusqu'à présent.  Par conséquent, ajoutez une méthode virtuelle <code>GameTileContent</code> à <code>GameUpdate</code> , qui ne fait rien par défaut. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br>  Faisons en sorte que <code>Tower</code> redéfinisse, même si pour l'instant il affiche simplement dans la console qu'il recherche une cible. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Searching for target..."</span></span>); }</code> </pre> <br>  <code>GameBoard</code> traite des tuiles et de leur contenu, il gardera donc également la trace du contenu à mettre à jour.  Pour ce faire, ajoutez-y la liste et la méthode publique <code>GameUpdate</code> , qui met à jour tout dans la liste. <br><br><pre> <code class="cs hljs"> List&lt;GameTileContent&gt; updatingContent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameTileContent&gt;(); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; updatingContent.Count; i++) { updatingContent[i].GameUpdate(); } }</code> </pre> <br>  Dans notre tutoriel, il vous suffit de mettre à jour les tours.  Modifiez <code>ToggleTower</code> pour qu'il ajoute et supprime du contenu si nécessaire.  Si d'autres contenus sont également nécessaires, nous aurons besoin d'une approche plus générale, mais pour l'instant, cela suffit. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { updatingContent.Remove(tile.Content); tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower); <span class="hljs-comment"><span class="hljs-comment">//if (!FindPaths()) { if (FindPaths()) { updatingContent.Add(tile.Content); } else { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } else if (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); updatingContent.Add(tile.Content); } }</span></span></code> </pre> <br>  Pour que cela fonctionne, il nous suffit maintenant de simplement mettre à jour le champ dans <code>Game.Update</code> .  Nous mettrons à jour le champ après les ennemis.  Grâce à cela, les tours pourront viser exactement où se trouvent les ennemis.  Si nous faisions autrement, les tours viseraient où se trouvaient les ennemis dans la dernière image. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … enemies.GameUpdate(); board.GameUpdate(); }</code> </pre> <br><h3>  Portée de visée </h3><br>  Les tours ont un rayon de visée limité.  Personnalisons-le en ajoutant un champ à la classe <code>Tower</code> .  La distance est mesurée à partir du centre de la tuile tour, donc à une portée de 0,5, elle ne couvrira que sa propre tuile.  Par conséquent, une plage minimale et standard raisonnable serait de 1,5, couvrant la plupart des carreaux voisins. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1.5f, 10.5f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> targetingRange = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/ae4/ee8/c38ae4ee885cf5d89f24164b9c6bc5fe.png" width="320" height="74"></div><br>  <i>Portée de visée 2.5.</i> <br><br>  Visualisons la plage avec gizmo.  Nous n'avons pas besoin de le voir constamment, nous allons donc créer la méthode <code>OnDrawGizmosSelected</code> appelée uniquement pour les objets sélectionnés.  Nous dessinons le cadre jaune de la sphère avec un rayon égal à la distance et centré par rapport à la tour.  Placez-le légèrement au-dessus du sol afin qu'il soit toujours clairement visible. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Gizmos.color = Color.yellow; Vector3 position = transform.localPosition; position.y += <span class="hljs-number"><span class="hljs-number">0.01f</span></span>; Gizmos.DrawWireSphere(position, targetingRange); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/6b7/3cd/6746b73cd2e015fd599b770bb89e1c8a.png" width="230" height="230"></div><br>  <i>Portée de visée du Gizmo.</i> <br><br>  Nous pouvons maintenant voir lequel des ennemis est une cible abordable pour chacune des tours.  Mais choisir des tours dans la fenêtre de la scène n'est pas pratique, car nous devons sélectionner l'un des cubes enfants, puis basculer vers l'objet racine de la tour.  D'autres types de contenu de tuiles souffrent également du même problème.  Nous pouvons forcer la sélection de la racine du contenu de la <code>GameTileContent</code> dans la fenêtre de scène en ajoutant l'attribut <code>SelectionBase</code> au <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SelectionBase</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … }</code> </pre> <br><h3>  Capture de cible </h3><br>  Ajoutez un champ <code>TargetPoint</code> à la classe <code>Tower</code> afin qu'il puisse suivre sa cible capturée.  Ensuite, nous <code>GameUpdate</code> pour appeler la nouvelle méthode <code>AquireTarget</code> , qui renvoie des informations <code>AquireTarget</code> si elle a trouvé la cible.  Lors de la détection, il affichera un message dans la console. <br><br><pre> <code class="cs hljs"> TargetPoint target; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Acquired target!"</span></span>); } }</code> </pre> <br>  Dans <code>AcquireTarget</code> nous obtenons toutes les cibles disponibles en appelant <code>Physics.OverlapSphere</code> avec une position et une plage de tour comme arguments.  Le résultat sera un tableau de <code>Collider</code> contenant tous les collisionneurs en contact avec la sphère.  Si la longueur du tableau est positive, alors il y a au moins un point de visée, et nous sélectionnons simplement le premier.  Prenez son composant <code>TargetPoint</code> , qui doit toujours exister, affectez-le au champ cible et signalez le succès.  Sinon, nous effaçons la cible et signalons l'échec. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targets.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targets[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targets[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Nous sommes assurés d'obtenir les bons points de visée, si nous ne prenons en compte les collisionneurs que sur la couche d'ennemis.  Ceci est le calque 9, nous allons donc passer le masque de calque correspondant. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enemyLayerMask = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange, enemyLayerMask ); … }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Comment fonctionne ce masque de bits?</b> <div class="spoiler_text">  Puisque la couche ennemie a un indice de 9, le dixième bit du masque binaire doit avoir la valeur 1. Cela correspond à un entier 2 <sup>9</sup> , soit 512. Mais un tel enregistrement de masque binaire n'est pas intuitif.  Nous pouvons également écrire un littéral binaire, par exemple <code>0b10_0000_0000</code> , mais nous devons ensuite compter les zéros.  Dans ce cas, l'entrée la plus pratique serait d'utiliser l'opérateur de décalage gauche <code>&lt;&lt;</code> , qui décale les bits vers la gauche.  ce qui correspond à un nombre au pouvoir de deux. </div></div><br>  Vous pouvez visualiser la cible capturée en traçant une ligne de gizmo entre les positions de la tour et de la cible. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Gizmos.DrawLine(position, target.Position); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a5/e99/4be/7a5e994be6b7d848c2d4bfe7d627c708.png" width="230" height="230"></div><br>  <i>Visualisation des objectifs.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Pourquoi ne pas utiliser des méthodes comme OnTriggerEnter?</b> <div class="spoiler_text">  L'avantage de la vérification manuelle des objectifs transversaux est que nous ne pouvons le faire qu'en cas de besoin.  Il n'y a aucune raison de vérifier les cibles si la tour en a déjà une.  De plus, en obtenant tous les objectifs potentiels à la fois, nous n'avons pas à traiter une liste d'objectifs potentiels pour chaque tour, qui est en constante évolution. </div></div><br><h3>  Verrouillage de cible </h3><br>  La cible choisie pour la capture dépend de l'ordre dans lequel ils sont représentés par le moteur physique, c'est-à-dire en fait arbitraire.  Par conséquent, il apparaîtra que la cible capturée change sans raison.  Une fois que la tour a reçu la cible, il est plus logique pour elle de la suivre et de ne pas passer à une autre.  Ajoutez une méthode <code>TrackTarget</code> qui implémente un tel suivi et renvoie des informations pour savoir si elle a réussi.  Tout d'abord, nous vous informerons simplement si la cible est capturée. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Nous appellerons cette méthode dans <code>GameUpdate</code> et ce n'est qu'en renvoyant false que nous appellerons <code>AcquireTarget</code> .  Si la méthode est retournée vraie, alors nous avons un objectif.  Cela peut être fait en plaçant les deux appels de méthode dans une vérification <code>if</code> avec l'opérateur OR, car si le premier opérande renvoie <code>true</code> , le second ne sera pas vérifié et l'appel sera manqué.  L'opérateur AND agit de manière similaire. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Locked on target!"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ec/27c/0a2/8ec27c0a2201434cba3725621b68aaa1.png" width="230" height="230"></div><br>  <i>Suivi des objectifs.</i> <br><br>  En conséquence, les tours sont fixées sur la cible jusqu'à ce qu'elle atteigne le point final et soit détruite.  Si vous utilisez des ennemis à plusieurs reprises, vous devez plutôt vérifier l'exactitude du lien, comme cela se fait avec les liens vers les figures traitées dans une série de didacticiels de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gestion</a> des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">objets</a> . <br><br>  Pour suivre les cibles uniquement lorsqu'elles sont à portée, <code>TrackTarget</code> doit suivre la distance entre la tour et la cible.  S'il dépasse la valeur de la plage, la cible doit être réinitialisée et renvoyer false.  Vous pouvez utiliser la méthode <code>Vector3.Distance</code> pour cette vérification. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Cependant, ce code ne prend pas en compte le rayon du collisionneur.  Par conséquent, en conséquence, la tour peut perdre la cible, puis la capturer à nouveau, seulement pour arrêter de la suivre dans l'image suivante, etc.  Nous pouvons éviter cela en ajoutant un rayon de collisionneur à la plage. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span>) { … }</code> </pre> <br>  Cela nous donne les résultats corrects, mais seulement si l'échelle de l'ennemi n'est pas modifiée.  Puisque nous donnons à chaque ennemi une échelle aléatoire, nous devons en tenir compte lors du changement de portée.  Pour ce faire, nous devons nous souvenir de l'échelle donnée par <code>Enemy</code> et l'ouvrir à l'aide de la propriété getter. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Scale { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { Scale = scale; … }</code> </pre> <br>  Nous pouvons maintenant vérifier la plage correcte dans <code>Tower.TrackTarget</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy€.Scale) { … }</code> </pre> <br><h3>  Nous synchronisons la physique </h3><br>  Tout semble bien fonctionner, mais les tours qui peuvent viser au centre du champ sont capables de capturer des cibles qui devraient être hors de portée.  Ils ne pourront pas suivre ces objectifs, ils ne sont donc fixés sur eux que pour une seule image. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e91/0a1/836/e910a1836ef729d95ebee121a67c3f2c.png" width="230" height="230"></div><br>  <i>Visée incorrecte.</i> <br><br>  Cela se produit car l'état du moteur physique est imparfaitement synchronisé avec l'état du jeu.  Des instances de tous les ennemis sont créées à l'origine du monde, qui coïncide avec le centre du champ.  Ensuite, nous les déplaçons au point de création, mais le moteur physique ne le sait pas tout de suite. <br><br>  Vous pouvez activer la synchronisation instantanée qui se produit lorsque vous modifiez les transformations d'objets en définissant <code>Physics.autoSyncTransforms</code> sur <code>true</code> .  Mais par défaut, il est désactivé, car il est beaucoup plus efficace de tout synchroniser ensemble et si nécessaire.  Dans notre cas, la synchronisation n'est requise que lors de la mise à jour de l'état des tours.  Nous pouvons l'exécuter en appelant <code>Physics.SyncTransforms</code> entre les mises à jour ennemies et sur le terrain dans <code>Game.Update</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … enemies.GameUpdate(); Physics.SyncTransforms(); board.GameUpdate(); }</code> </pre> <br><h3>  Ignorer la hauteur </h3><br>  En fait, notre gameplay se déroule en 2D.  Par conséquent, changeons la <code>Tower</code> sorte que lors de la visée et du suivi, elle ne prenne en compte que les coordonnées X et Z. Le moteur physique fonctionne dans l'espace 3D, mais en substance, nous pouvons effectuer <code>AcquireTarget</code> en 2D: étirez la sphère vers le haut afin qu'elle couvre tous les collisionneurs, quel que soit de leur position verticale.  Cela peut être fait en utilisant une capsule au lieu d'une sphère, dont le deuxième point sera à plusieurs unités au-dessus du sol (par exemple, trois). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">3f</span></span>; Collider[] targets = Physics.OverlapCapsule( a, b, targetingRange, enemyLayerMask ); … }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title">    2D-?</b> <div class="spoiler_text">   ,       XZ,   2D-    XY.     ,     ,    2D-   .     3D-. </div></div><br>    <code>TrackTarget</code> . ,    2D-  <code>Vector2.Distance</code> ,            ,   .        . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = ax - bx; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = az - bz; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy€.Scale; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x * x + z * z &gt; r * r) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title">    ?</b> <div class="spoiler_text">     2D-   ,     .     ,       .  ,        ,    . </div></div><br><h3>    </h3><br>   <code>Physics.OverlapCapsule</code>   ,        .   ,         <code>OverlapCapsuleNonAlloc</code>      .       .       .        ,      1. <br><br>   <code>OverlapCapsuleNonAlloc</code>    ,    ,          . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">1</span></span>]; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hits = Physics.OverlapCapsuleNonAlloc( a, b, targetingRange, targetsBuffer, enemyLayerMask ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h2>    </h2><br> ,      ,     .    ,     . <br><br><h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour diriger la tourelle vers la cible, la classe </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit avoir un lien vers le composant </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tourelle. </font><font style="vertical-align: inherit;">Ajoutez un champ de configuration pour cela et connectez-le au préfabriqué de la tour.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/3be/41b/e0f3be41b0936993268316b8f01e1f67.png" width="320" height="90"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tourelle attachée. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y a une vraie cible, alors nous devons la tirer. </font><font style="vertical-align: inherit;">Mettez le code de prise de vue dans une méthode distincte. </font><font style="vertical-align: inherit;">Faites-lui tourner la tourelle vers la cible, en appelant sa méthode </font></font><code>Transform.LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec le point de visée comme argument.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { <span class="hljs-comment"><span class="hljs-comment">//Debug.Log("Locked on target!"); Shoot(); } } void Shoot () { Vector3 point = target.Position; turret.LookAt(point); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/5bb/e9d/00e5bbe9d98e739800bf47435ca574af.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visant juste.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous tirons un laser </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour positionner le faisceau laser, la classe a </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">également besoin d'un lien vers celui-ci.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, laserBeam = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/c9c/86e/802c9c86eac24112cb2b4f072fd0f410.png" width="320" height="110"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons connecté un faisceau laser. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour transformer un cube en un véritable faisceau laser, vous devez suivre trois étapes. </font><font style="vertical-align: inherit;">Tout d'abord, son orientation doit correspondre à l'orientation de la tourelle. </font><font style="vertical-align: inherit;">Cela peut être fait en copiant sa rotation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxièmement, nous mettons à l'échelle le faisceau laser de sorte que sa longueur soit égale à la distance entre le point d'origine local de la tourelle et le point de visée. </font><font style="vertical-align: inherit;">Nous le mettons à l'échelle le long de l'axe Z, c'est-à-dire l'axe local dirigé vers la cible. </font><font style="vertical-align: inherit;">Pour conserver l'échelle XY d'origine, nous notons l'échelle d'origine lorsque nous réveillons la tourelle Awake.</font></font><br><br><pre> <code class="cs hljs"> Vector3 laserBeamScale; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { laserBeamScale = laserBeam.localScale; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = Vector3.Distance(turret.position, point); laserBeamScale.z = d; laserBeam.localScale = laserBeamScale; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Troisièmement, nous plaçons le faisceau laser au milieu entre la tourelle et le point de visée. </font></font><br><br><pre> <code class="cs hljs"> laserBeam.localScale = laserBeamScale; laserBeam.localPosition = turret.localPosition + <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * d * laserBeam.forward;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/288/d96/438/288d96438354bd732fd7a3bb84ead491.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prise de vue au laser.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N'est-il pas possible de faire d'un rayon laser un enfant d'une tourelle?</font></font></b> <div class="spoiler_text">     ,         ,       forward.       ,     .     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela fonctionne pendant que la tourelle est fixée sur la cible. </font><font style="vertical-align: inherit;">Mais quand il n'y a pas de cible, le laser reste actif. </font><font style="vertical-align: inherit;">Nous pouvons désactiver l'affichage laser en </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">définissant </font><font style="vertical-align: inherit;">son échelle à </font><font style="vertical-align: inherit;">0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Shoot(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { laserBeam.localScale = Vector3.zero; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/8c8/c23/39b8c8c239e0936137c646f91a4197de.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les tours inactives ne tirent pas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Santé ennemie </font></font></h3><br>              .   ,     .      ,   <code>Enemy</code>  .       ,    100.   ,       ,     . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Health { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { … Health = <span class="hljs-number"><span class="hljs-number">100f</span></span> * scale; }</code> </pre> <br>     ,    <code>ApplyDamage</code> ,     .   ,   ,     . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyDamage</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> damage</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(damage &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-string"><span class="hljs-string">"Negative damage applied."</span></span>); Health -= damage; }</code> </pre> <br>       ,      .           <code>GameUpdate</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Health &lt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } … }</code> </pre> <br>         ,    ,       ,     ,     . <br><br><h3>    </h3><br>    ,     .     <code>Tower</code>  .       ,        (damage per second).  <code>Shoot</code>     <code>Enemy</code>      . <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1f, 100f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> damagePerSecond = <span class="hljs-number"><span class="hljs-number">10f</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … target.Enemy.ApplyDamage(damagePerSecond * Time.deltaTime); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/886/18f/199/88618f199c9c08e7eaeb89b16083f545.png" width="320" height="128" alt="inspecteur"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/vt/sf/gkvtsfa1ya4igbsjagqhtnzu0wq.gif"></div><br> <i>   — 20   .</i> <br><br><h3>    </h3><br>        ,     ,       .     ,      ,    ,         .       ,     . <br><br>  ,      ,    .   ,     ,   100. ,              ,       . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">100</span></span>];</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, au lieu de choisir la première cible potentielle, nous allons sélectionner un élément aléatoire dans le tableau. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, hits)].GetComponent&lt;TargetPoint&gt;(); … } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/lt/hi/nvlthij_ixh6lsxgwujtoipjwg4.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visée aléatoire.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'autres critères de choix des objectifs peuvent-ils être utilisés?</font></font></b> <div class="spoiler_text"> , ,        .  ,      ,     .    .             . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, dans notre jeu de tower defense, des tours sont enfin apparues. </font><font style="vertical-align: inherit;">Dans la prochaine partie, le jeu prendra encore plus sa forme finale.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459070/">https://habr.com/ru/post/fr459070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459052/index.html">Comment comparer: «voiture incroyable» et «hutte laide», dans une enquête marketing et dans le big data</a></li>
<li><a href="../fr459054/index.html">Carte thermique des clics - comment les utilisateurs se comportent sur le site</a></li>
<li><a href="../fr459062/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 305 (du 1er au 7 juillet)</a></li>
<li><a href="../fr459066/index.html">Équilibrage d'écriture et de lecture de base de données</a></li>
<li><a href="../fr459068/index.html">Windows Server 2008 R2 - Le roi est mort, vive le roi</a></li>
<li><a href="../fr459074/index.html">Petite petite joie # 7: trois pour le prix d'un - animation sur console, algorithmes et débogage</a></li>
<li><a href="../fr459078/index.html">Le CERN passe aux logiciels open source - pourquoi?</a></li>
<li><a href="../fr459080/index.html">Caractéristiques HttpUrlConnection de java.net</a></li>
<li><a href="../fr459082/index.html">Qui sont l'eidétique, comment fonctionnent les faux souvenirs et trois mythes populaires sur la mémoire</a></li>
<li><a href="../fr459084/index.html">Un peu sur Google Home Hub, ou comment j'ai acheté un cadre photo pour 130 euros</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>