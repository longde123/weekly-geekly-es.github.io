<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🔧 👩‍🚒 👩🏼‍🔬 Zurück zu Microservices mit Istio. Teil 3 ⁉️ 🔽 🎭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : Der erste Teil dieser Reihe war der Einführung und Demonstration von Istio-Funktionen gewidmet, der zweite dem fein abgestimmten Rout...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zurück zu Microservices mit Istio. Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/443668/"><img src="https://habrastorage.org/webt/bj/j4/oy/bjj4oyjxqshrbjf5eks9sgsvbeg.png"><br><br>  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der erste Teil</a> dieser Reihe war der Einführung und Demonstration von Istio-Funktionen gewidmet, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweite</a> dem fein abgestimmten Routing und dem Netzwerkverkehrsmanagement.</i>  <i>Jetzt werden wir über Sicherheit sprechen: Um die damit verbundenen Grundfunktionen zu demonstrieren, verwendet der Autor den Auth0-Identitätsdienst, aber andere Anbieter können analog dazu konfiguriert werden.</i> <br><br>  Wir haben einen Kubernetes-Cluster eingerichtet, in dem Istio und die Mikroservice-Anwendung Sentiment Analysis bereitgestellt wurden. So wurde Istio demonstriert. <br><br>  Mit Istio konnten wir die Services klein halten, da sie keine „Ebenen“ wie Wiederholungsversuche, Retouts, Timeouts, Leistungsschalter, Ablaufverfolgung und Überwachung implementieren müssen .  Darüber hinaus verwendeten wir fortschrittliche Test- und Bereitstellungstechniken: A / B-Tests, Spiegelung und kanarische Rollouts. <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/bs/x7/sc/bsx7sci6cfghlpg8_crfjyutiuk.png"><br><br>  In dem neuen Material werden wir uns mit den letzten Schichten auf dem Weg zum Geschäftswert befassen: Authentifizierung und Autorisierung - und in Istio ist dies eine echte Freude! <br><br><h2>  Authentifizierung und Autorisierung in Istio </h2><br>  Ich hätte nie geglaubt, dass ich mich von Authentifizierung und Autorisierung inspirieren lassen würde.  Was kann Istio technologisch bieten, um diese Themen spannend zu machen und Sie noch mehr zu inspirieren? <br><br>  Die Antwort ist einfach: Istio überträgt die Verantwortung für diese Funktionen von Ihren Diensten auf Envoy-Proxys.  Wenn die Anforderungen die Dienste erreichen, sind sie bereits authentifiziert und autorisiert, sodass Sie nur noch Code schreiben müssen, der für Unternehmen nützlich ist. <br><br>  Hört sich gut an?  Schauen wir mal rein! <br><br><h2>  Authentifizierung mit Auth0 </h2><br>  Wir werden Auth0 als Server für die Identitäts- und Zugriffsverwaltung verwenden. Es gibt eine Testversion, die intuitiv zu bedienen ist und die mir einfach gefällt.  Dieselben Prinzipien können jedoch auf jede andere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenID Connect-Implementierung</a> angewendet werden: KeyCloak, IdentityServer und viele andere. <br><br>  Gehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie zunächst</a> mit Ihrem Konto zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auth0-Portal</a> , erstellen Sie einen Mandanten <i>(</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mandant</a> <i>- "</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mandant</a> <i>", logische Isolationseinheit, weitere Details finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> - ca. Übertragung)</i> und gehen Sie zu <i>Anwendungen&gt; Standard-App</i> und wählen Sie <i>Domäne</i> , wie im folgenden Screenshot gezeigt :: <br><br><img src="https://habrastorage.org/webt/1z/x1/ir/1zx1irb-9tqksk6gd8eb0feubdm.png"><br><br>  Geben Sie diese Domäne in der <code>resource-manifests/istio/security/auth-policy.yaml</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> ) an: <br><br><pre> <code class="plaintext hljs">apiVersion: authentication.istio.io/v1alpha1 kind: Policy metadata: name: auth-policy spec: targets: - name: sa-web-app - name: sa-feedback origins: - jwt: issuer: "https://{YOUR_DOMAIN}/" jwksUri: "https://{YOUR_DOMAIN}/.well-known/jwks.json" principalBinding: USE_ORIGIN</code> </pre> <br>  Mit einer solchen Ressource konfiguriert Pilot <i>(eine der drei Grundkomponenten von Control Plane in Istio - ca. Transl.) Envoys so</i> , dass Anforderungen authentifiziert werden, bevor sie an Dienste weitergeleitet werden: <b><code>sa-web-app</code></b> und <b><code>sa-feedback</code></b> .  Gleichzeitig gilt die Konfiguration nicht für die Gesandten des <b><code>sa-frontend</code></b> , sodass wir das Frontend nicht authentifiziert lassen können.  Führen Sie den folgenden Befehl aus, um eine Richtlinie anzuwenden: <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/istio/security/auth-policy.yaml policy.authentication.istio.io “auth-policy” created</code> </pre> <br>  Kehren Sie zur Seite zurück und stellen Sie eine Anfrage - Sie werden sehen, dass sie im Status <i>401 Nicht autorisiert</i> endet.  Jetzt leiten wir Front-End-Benutzer zur Authentifizierung mit Auth0 um. <br><br><h2>  Authentifizierung mit Auth0 anfordern </h2><br>  Um Endbenutzeranforderungen zu authentifizieren, müssen Sie in Auth0 eine API erstellen, die authentifizierte Dienste (Bewertungen, Details und Bewertungen) darstellt.  Um eine API zu erstellen, gehen Sie zu <i>Auth0 Portal&gt; APIs&gt; API erstellen</i> und füllen Sie das folgende Formular aus: <br><br><img src="https://habrastorage.org/webt/96/_g/b5/96_gb5wcteuxtvt-yakzlsu4a4g.png"><br><br>  Die wichtige Information hier ist <i>Identifier</i> , den wir später im Skript verwenden werden.  Schreiben wir es uns so aus: <br><br><ul><li>  <b>Zielgruppe</b> : {YOUR_AUDIENCE} </li></ul><br>  Die verbleibenden Details finden Sie im Auth0-Portal im Abschnitt <i>Anwendungen</i> - wählen Sie Testanwendung (sie wird automatisch mit der API erstellt). <br><br>  Hier schreiben wir: <br><br><ul><li>  <b>Domain</b> : {YOUR_DOMAIN} </li><li>  <b>Kunden-</b> ID: {YOUR_CLIENT_ID} </li></ul><br>  Scrollen Sie in der <i>Testanwendung zum</i> Textfeld <i>Zulässige</i> Rückruf- <i>URLs</i> (die zulässigen URLs für den Rückruf), in dem wir die URL angeben, an die der Anruf nach Abschluss der Authentifizierung gesendet werden soll.  In unserem Fall ist es: <br><br><pre> <code class="plaintext hljs">http://{EXTERNAL_IP}/callback</code> </pre> <br>  Fügen Sie für <i>zulässige Abmelde-URLs</i> (zulässige URLs zum Abmelden) <i>Folgendes</i> hinzu: <br><br><pre> <code class="plaintext hljs">http://{EXTERNAL_IP}/logout</code> </pre> <br>  Gehen wir weiter zum Frontend. <br><br><h2>  Frontend-Update </h2><br>  <code>auth0</code> Zweig <code>auth0</code> des Repositorys <code>[istio-mastery]</code> .  In diesem Thread wird der Front-End-Code geändert, um Benutzer zur Authentifizierung an Auth0 umzuleiten und das JWT-Token in Anforderungen für andere Dienste zu verwenden.  Letzteres wird wie folgt implementiert ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">App.js</a> ): <br><br><pre> <code class="javascript hljs">analyzeSentence() { fetch(<span class="hljs-string"><span class="hljs-string">'/sentiment'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: { <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>, <span class="hljs-string"><span class="hljs-string">'Authorization'</span></span>: <span class="hljs-string"><span class="hljs-string">`Bearer </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${auth.getAccessToken()}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-comment"><span class="hljs-comment">// Access Token }, body: JSON.stringify({ sentence: this.textField.getValue() }) }) .then(response =&gt; response.json()) .then(data =&gt; this.setState(data)); }</span></span></code> </pre> <br>  Um das Frontend in die Verwendung von Mandantendaten in Auth0 zu konvertieren, öffnen Sie <code>sa-frontend/src/services/Auth.js</code> und ersetzen Sie die oben geschriebenen Werte ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auth.js</a> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Config = { <span class="hljs-attr"><span class="hljs-attr">clientID</span></span>: <span class="hljs-string"><span class="hljs-string">'{YOUR_CLIENT_ID}'</span></span>, <span class="hljs-attr"><span class="hljs-attr">domain</span></span>:<span class="hljs-string"><span class="hljs-string">'{YOUR_DOMAIN}'</span></span>, <span class="hljs-attr"><span class="hljs-attr">audience</span></span>: <span class="hljs-string"><span class="hljs-string">'{YOUR_AUDIENCE}'</span></span>, <span class="hljs-attr"><span class="hljs-attr">ingressIP</span></span>: <span class="hljs-string"><span class="hljs-string">'{EXTERNAL_IP}'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br>  Die Anwendung ist fertig.  Geben Sie Ihre Docker-ID in den folgenden Befehlen an, wenn Sie die vorgenommenen Änderungen erstellen und bereitstellen: <br><br><pre> <code class="bash hljs">$ docker build -f sa-frontend/Dockerfile \ -t <span class="hljs-variable"><span class="hljs-variable">$DOCKER_USER_ID</span></span>/sentiment-analysis-frontend:istio-auth0 \ sa-frontend $ docker push <span class="hljs-variable"><span class="hljs-variable">$DOCKER_USER_ID</span></span>/sentiment-analysis-frontend:istio-auth0 $ kubectl <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> image deployment/sa-frontend \ sa-frontend=<span class="hljs-variable"><span class="hljs-variable">$DOCKER_USER_ID</span></span>/sentiment-analysis-frontend:istio-auth0</code> </pre> <br>  Probieren Sie die App!  Sie werden zu Auth0 weitergeleitet, wo Sie sich anmelden (oder registrieren) müssen. Anschließend werden Sie zu der Seite zurückgeschickt, von der aus bereits authentifizierte Anforderungen gestellt werden.  Wenn Sie die in den ersten Teilen des Artikels genannten Curl-Befehle ausprobieren, erhalten Sie einen <i>401-Statuscode</i> , der angibt, dass die Anforderung nicht autorisiert ist. <br><br>  Machen wir den nächsten Schritt - autorisieren Sie Anfragen. <br><br><h2>  Autorisierung mit Auth0 </h2><br>  Durch die Authentifizierung können wir verstehen, wer der Benutzer ist. Um jedoch herauszufinden, auf was er Zugriff hat, ist eine Autorisierung erforderlich.  Istio bietet auch hierfür Tools an. <br><br>  Als Beispiel erstellen wir zwei Benutzergruppen (siehe Abbildung unten): <br><br><ul><li>  <b>Benutzer</b> <i>(Benutzer)</i> - nur mit Zugriff auf die Dienste SA-WebApp und SA-Frontend; </li><li>  <b>Moderatoren</b> - mit Zugriff auf alle drei Dienste. </li></ul><br><img src="https://habrastorage.org/webt/01/i-/dc/01i-dccinr9i1aq81atcf_qze90.png"><br>  <i>Berechtigungskonzept</i> <br><br>  Um diese Gruppen zu erstellen, verwenden wir die Auth0-Autorisierungserweiterung und verwenden Istio, um ihnen verschiedene Zugriffsebenen bereitzustellen. <br><br><h2>  Installation und Konfiguration der Auth0-Autorisierung </h2><br>  Gehen Sie im Auth0-Portal zu <i>Erweiterungen</i> und installieren Sie die <i>Auth0-Autorisierung</i> .  Gehen Sie nach der Installation zur <i>Autorisierungserweiterung</i> und dort zur Konfiguration des Mandanten, indem Sie oben rechts klicken und die entsprechende Menüoption <i>(Konfiguration)</i> auswählen.  Aktivieren Sie <i>Gruppen</i> und klicken Sie auf die Schaltfläche <i>Regel veröffentlichen</i> . <br><br><img src="https://habrastorage.org/webt/qo/tz/5n/qotz5nt8hpt0jcoyjav3rhkrn9g.png"><br><br><h2>  Gruppenerstellung </h2><br>  Gehen Sie in der Autorisierungserweiterung zu <i>Gruppen</i> und erstellen Sie eine <i>Moderatorengruppe</i> .  Da wir alle authentifizierten Benutzer als normal betrachten, ist es nicht erforderlich, eine zusätzliche Gruppe für sie zu erstellen. <br><br>  Wählen Sie die Gruppe <i>Moderatoren</i> aus, klicken Sie auf <i>Mitglieder</i> hinzufügen und fügen Sie Ihr Hauptkonto hinzu.  Lassen Sie einige Benutzer ohne Gruppe, um sicherzustellen, dass ihnen der Zugriff verweigert wird.  (Neue Benutzer können manuell über <i>Auth0 Portal&gt; Benutzer&gt; Benutzer erstellen erstellt werden</i> .) <br><br><h2>  Gruppenanspruch zum Zugriffstoken hinzufügen </h2><br>  Benutzer werden zu Gruppen hinzugefügt, diese Informationen sollten jedoch in Zugriffstoken wiedergegeben werden.  Um OpenID Connect zu erfüllen und gleichzeitig die benötigten Gruppen zurückzugeben, muss das Token seinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierten Anspruch</a> hinzufügen.  Es wird durch die Regeln von Auth0 implementiert. <br><br>  Um eine Regel zu erstellen, rufen Sie das Auth0-Portal zu <i>Regeln auf</i> , klicken Sie auf <i>Regel erstellen</i> und wählen Sie eine leere Regel aus den Vorlagen aus. <br><br><img src="https://habrastorage.org/webt/k0/v6/di/k0v6diyfaeiftxaknnbfbnvfxq0.png"><br><br>  Kopieren Sie den folgenden Code und speichern Sie ihn als neue Regel zum <i>Hinzufügen von Gruppenansprüchen</i> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">namespacedGroup.js</a> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user, context, callback</span></span></span><span class="hljs-function">) </span></span>{ context.accessToken[<span class="hljs-string"><span class="hljs-string">'https://sa.io/group'</span></span>] = user.groups[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, user, context); }</code> </pre> <br>  <b>Hinweis</b> : Dieser Code verwendet die erste in der Autorisierungserweiterung definierte Benutzergruppe und fügt sie dem Zugriffstoken als benutzerdefinierten Anspruch hinzu (unter seinem Namespace, wie von Auth0 gefordert). <br><br>  Kehren Sie zur Seite <i>Regeln zurück</i> und vergewissern Sie sich, dass zwei Regeln in der folgenden Reihenfolge geschrieben wurden: <br><br><ul><li>  auth0-authorisation-extension </li><li>  Gruppenanspruch hinzufügen </li></ul><br>  Die Reihenfolge ist wichtig, da das Gruppenfeld asynchron die <i>Auth0-Authorization-Extension-</i> Regel empfängt und dann von der zweiten Regel als Anspruch hinzugefügt wird.  Das Ergebnis ist ein solches Zugriffstoken: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"https://sa.io/group"</span></span>: <span class="hljs-string"><span class="hljs-string">"Moderators"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"iss"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://sentiment-analysis.eu.auth0.com/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"sub"</span></span>: <span class="hljs-string"><span class="hljs-string">"google-oauth2|196405271625531691872"</span></span> // [  ] }</code> </pre> <br>  Jetzt müssen Sie den Envoy-Proxy konfigurieren, um den Benutzerzugriff zu überprüfen, für den die Gruppe aus dem Anspruch ( <code>https://sa.io/group</code> ) im zurückgegebenen Zugriffstoken abgerufen wird.  Dies ist das Thema für den nächsten Abschnitt des Artikels. <br><br><h2>  Istio-Berechtigungskonfiguration </h2><br>  Damit die Autorisierung funktioniert, müssen Sie RBAC für Istio aktivieren.  Verwenden Sie dazu die folgende Konfiguration: <br><br><pre> <code class="plaintext hljs">apiVersion: "rbac.istio.io/v1alpha1" kind: RbacConfig metadata: name: default spec: mode: 'ON_WITH_INCLUSION' # 1 inclusion: services: # 2 - "sa-frontend.default.svc.cluster.local" - "sa-web-app.default.svc.cluster.local" - "sa-feedback.default.svc.cluster.local"</code> </pre> <br>  Erklärungen: <br><ul><li>  1 - RBAC nur für Dienste und Namespaces aktivieren, die im Feld <code>Inclusion</code> sind; </li><li>  2 - Listen Sie die Liste unserer Dienstleistungen auf. </li></ul><br><br>  Wir wenden die Konfiguration mit diesem Befehl an: <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/istio/security/<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-rbac.yaml rbacconfig.rbac.istio.io/default created</code> </pre> <br>  Jetzt erfordern alle Dienste eine rollenbasierte Zugriffskontrolle.  Mit anderen Worten, der Zugriff auf alle Dienste wird verweigert und führt zu einer <code>RBAC: access denied</code> Antwort <code>RBAC: access denied</code> .  Erlauben Sie nun autorisierten Benutzern den Zugriff. <br><br><h2>  Zugriffskonfiguration für reguläre Benutzer </h2><br>  Alle Benutzer müssen Zugriff auf die Dienste SA-Frontend und SA-WebApp haben.  Implementiert mit den folgenden Istio-Ressourcen: <br><br><ul><li>  <b>ServiceRole</b> - definiert die Rechte, die der Benutzer hat; </li><li>  <b>ServiceRoleBinding</b> - Bestimmt, wem diese ServiceRole gehört. </li></ul><br>  Erlauben Sie normalen Benutzern den Zugriff auf bestimmte Dienste ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">servicerole.yaml</a> ): <br><br><pre> <code class="plaintext hljs">apiVersion: "rbac.istio.io/v1alpha1" kind: ServiceRole metadata: name: regular-user namespace: default spec: rules: - services: - "sa-frontend.default.svc.cluster.local" - "sa-web-app.default.svc.cluster.local" paths: ["*"] methods: ["*"]</code> </pre> <br>  Wenden Sie durch <code>regular-user-binding</code> eine ServiceRole auf alle Besucher der Seite an ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reguläre Benutzerservice-Rollenbindung.yaml</a> ): <br><br><pre> <code class="plaintext hljs">apiVersion: "rbac.istio.io/v1alpha1" kind: ServiceRoleBinding metadata: name: regular-user-binding namespace: default spec: subjects: - user: "*" roleRef: kind: ServiceRole name: "regular-user"</code> </pre> <br>  Bedeutet "alle Benutzer", dass nicht authentifizierte Benutzer Zugriff auf SA WebApp erhalten?  Nein, die Richtlinie überprüft die Gültigkeit des JWT-Tokens. <br><br>  Konfiguration anwenden: <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/istio/security/user-role.yaml servicerole.rbac.istio.io/regular-user created servicerolebinding.rbac.istio.io/regular-user-binding created</code> </pre> <br><h2>  Zugriffskonfiguration für Moderatoren </h2><br>  Für Moderatoren möchten wir den Zugriff auf alle Dienste ermöglichen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mod-service-role.yaml</a> ): <br><br><pre> <code class="plaintext hljs">apiVersion: "rbac.istio.io/v1alpha1" kind: ServiceRole metadata: name: mod-user namespace: default spec: rules: - services: ["*"] paths: ["*"] methods: ["*"]</code> </pre> <br>  Wir möchten solche Rechte jedoch nur für Benutzer, deren Zugriffstoken den Anspruch <code>https://sa.io/group</code> mit dem Wert <code>Moderators</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mod-service-role-binding.yaml</a> ) hat: <br><br><pre> <code class="plaintext hljs">apiVersion: "rbac.istio.io/v1alpha1" kind: ServiceRoleBinding metadata: name: mod-user-binding namespace: default spec: subjects: - properties: request.auth.claims[https://sa.io/group]: "Moderators" roleRef: kind: ServiceRole name: "mod-user"</code> </pre> <br>  Konfiguration anwenden: <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/istio/security/mod-role.yaml servicerole.rbac.istio.io/mod-user created servicerolebinding.rbac.istio.io/mod-user-binding created</code> </pre> <br>  Aufgrund des Zwischenspeicherns in Gesandten kann es einige Minuten dauern, bis die Autorisierungsregeln wirksam werden.  Danach können Sie sicherstellen, dass Benutzer und Moderatoren unterschiedliche Zugriffsebenen haben. <br><br><h2>  Fazit zu diesem Teil </h2><br>  Im Ernst: Haben Sie jemals einen einfacheren, mühelosen, skalierbaren und sicheren Ansatz für die Authentifizierung und Autorisierung gesehen? <br><br>  Es waren nur drei Istio-Ressourcen (RbacConfig, ServiceRole und ServiceRoleBinding) erforderlich, um eine genaue Kontrolle über die Authentifizierung und Autorisierung des Endbenutzerzugriffs auf Dienste zu erreichen. <br><br>  Darüber hinaus haben wir uns im Rahmen unserer Gesandtsdienste um diese Probleme gekümmert und Folgendes erreicht: <br><br><ul><li>  Reduzieren der Menge an Beispielcode, die Sicherheitsprobleme und Fehler enthalten kann; </li><li>  Reduzierung der Anzahl dummer Situationen, in denen ein Endpunkt von außen zugänglich war und vergessen hat, ihn zu melden; </li><li>  Sie müssen nicht mehr alle Dienste aktualisieren, wenn eine neue Rolle oder ein neues Recht hinzugefügt wird. </li><li>  dass die neuen Dienste einfach, sicher und schnell bleiben. </li></ul><br><h2>  Fazit </h2><br>  Mit Istio können Teams ihre Ressourcen auf geschäftskritische Aufgaben konzentrieren, ohne den Aufwand für die Services zu erhöhen, und sie wieder in den Mikrostatus versetzen. <br><br>  Der Artikel (in drei Teilen) enthielt Grundkenntnisse und vorgefertigte praktische Anweisungen für den Beginn der Arbeit mit Istio in realen Projekten. <br><br><h2>  PS vom Übersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  "Zurück zu Microservices mit Istio": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1 (Vertrautheit mit den Hauptfunktionen)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2 (Routing, Verkehrsmanagement)</a> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Conduit - ein leichtes Service-Mesh für Kubernetes</a> "; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist ein Service-Mesh und warum brauche ich es [für eine Cloud-Anwendung mit Microservices]?</a>  ". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443668/">https://habr.com/ru/post/de443668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443656/index.html">Auf den Spuren von Taschenrechnern: Qalculate</a></li>
<li><a href="../de443658/index.html">Konfigurieren des Kubernetes HA-Clusters auf Bare-Metal-, Überwachungs-, Protokoll- und Verwendungsbeispielen. Teil 3/3</a></li>
<li><a href="../de443660/index.html">Experten: „Ein 3D-Scanner kostet zehnmal weniger als ein Fehler bei der herkömmlichen Qualitätskontrolle.“</a></li>
<li><a href="../de443662/index.html">Grundlegendes zu Clean Code unter Android</a></li>
<li><a href="../de443664/index.html">Wetterstation Arduino</a></li>
<li><a href="../de443670/index.html">Fehler in der neuen Version von Google Chrome (73.0.3683.75)</a></li>
<li><a href="../de443672/index.html">Risikobasiertes Testen</a></li>
<li><a href="../de443676/index.html">Vinyl statt Briefmarke: ungewöhnliche Seltenheit</a></li>
<li><a href="../de443678/index.html">Lesbarkeit des Codes</a></li>
<li><a href="../de443680/index.html">Viertägige Arbeitswoche. Russische Erfahrung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>