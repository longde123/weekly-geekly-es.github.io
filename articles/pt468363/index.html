<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò∏ üöπ üöû Minha magnum opus do mundo dos jogos para celular üíÉüèæ üë¶üèª üòÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Hoje, 26 de setembro, √© meu anivers√°rio, o que significa para mim que esse √© um √≥timo motivo para publicar um artigo sobre a sequ√™ncia do me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Minha magnum opus do mundo dos jogos para celular</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468363/">  Ol√° Habr!  Hoje, 26 de setembro, √© meu anivers√°rio, o que significa para mim que esse √© um √≥timo motivo para publicar um artigo sobre a sequ√™ncia do meu quebra-cabe√ßa.  Eu aviso que sou amador, o que significa que haver√° muitos erros em TODOS os aspectos do desenvolvimento (se voc√™ o encontrar, escreva, terei prazer em levar em considera√ß√£o).  Neste artigo, eu gostaria de contar tudo (bem, ou quase tudo) sobre como eu fiz a sequ√™ncia, como fui para isso e para o que vim. <br><a name="habracut"></a><br>  Para n√£o ficar confuso, quero dizer aqui os significados dos termos que est√£o no artigo: <br>  O original √© a primeira parte, um jogo com um drive subterr√¢neo da demo tecno.  Voc√™ pode ler sobre isso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  A sequela √© a segunda parte da s√©rie, o jogo discutido neste artigo. <br><br>  Periodicamente, compararei o jogo original com a sequ√™ncia para enfatizar a diferen√ßa entre os dois. <br><br>  <i>Brevemente sobre desenvolvimento</i> <br><br>  Comecei a trabalhar no jogo no final de janeiro e no final de mar√ßo a parte t√©cnica estava conclu√≠da (2 meses).  Depois peguei outro jogo e voltei para continuar desenvolvendo esse jogo em meados de maio.  Terminei claramente no final do ver√£o e durante todo esse tempo (3,5 meses) enchi o jogo com conte√∫do.  E, como resultado, a sequ√™ncia foi feita ainda mais r√°pido por mim do que no jogo original (6 meses versus 5,5 meses). <br><br>  Eu fiz um jogo no mecanismo de unidade.  Eu gostaria que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esses caras</a> fizessem seu pr√≥prio mecanismo e avan√ßassem na programa√ß√£o, mas algo deu errado e ainda decidiram tornar o jogo em um padr√£o, mas testado por mim como instrumento. <br><br>  <i>Entre o original e a sequela</i> <br><br>  A id√©ia de criar uma sequela veio a mim um m√™s antes do lan√ßamento do jogo original (em algum lugar em agosto).  Vendo os erros que cometi, queria excluir tudo e come√ßar a trabalhar novamente com conquistas bem-sucedidas.  Mas n√£o comecei a mudar nada devido ao fato de haver muito c√≥digo de problema, todo o conte√∫do estava pronto e apenas adiei o desenvolvimento.  Era necess√°rio ir para o lan√ßamento. <br><br>  Ap√≥s o lan√ßamento, fui novamente atormentado pela id√©ia de uma sequ√™ncia.  Dessa vez eu n√£o comecei, porque eu era moralmente pregui√ßosa, ap√≥s o lan√ßamento foi completamente suave.  Eu queria algo novo e interessante.  Experimentos em massa come√ßaram. <br><br>  Nos pr√≥ximos 3 meses, tentei implementar qualquer id√©ia, qualquer configura√ß√£o, qualquer conceito nos jogos.  Apesar da escala de ambi√ß√µes, das dificuldades de execu√ß√£o e, √†s vezes, apesar da l√≥gica e do bom senso.  Como resultado, obtive cerca de 50 projetos.  Eles eram todos de g√™neros diferentes: de atiradores a estrat√©gias, de plataformas a jogos de RPG. <br><br>  Ent√£o, os experimentos continuariam, at√© eu me cansar.  E estou cansado de n√£o fazer jogos, mas da incompletude dos jogos que fiz.  Eu me dei um objetivo: fazer pelo menos algum tipo de jogo uma semana antes do fim.  E ent√£o meu segundo jogo apareceu. <br><br><div class="spoiler">  <b class="spoiler_title">Pro 2 game</b> <div class="spoiler_text">  Este jogo √© muito simples e complexo ao mesmo tempo.  √â necess√°rio cortar linhas e n√£o cortar gr√°ficos.  O significado do jogo √© que cada linha de corte foi dividida por 2 e um gr√°fico apareceu no centro.  A caracter√≠stica do jogo era que toda a geometria era din√¢mica.  Os gr√°ficos foram movidos e as linhas sempre conectaram certos gr√°ficos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fq/ey/fc/fqeyfcevpqtzh8uxu8xvmib4h0g.jpeg" width="400"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c-/xl/-j/c-xl-jj2fecfxp1d5eiofqybahg.jpeg" width="400"></div><br></div></div><br>  Depois disso, fiquei motivado (motivado) e pronto para um novo projeto.  Senti uma onda de for√ßa e ainda assumi a sequ√™ncia do meu jogo. <br><br>  <i>Id√©ia</i> <br><br>  Antes de come√ßar a fazer algo, decidi dar uma olhada no original na √≠ntegra.  E horrorizado.  De qualidade.  Acima de tudo, o jogo foi reduzido a quebra-cabe√ßas padr√£o: a necessidade de desbloquear n√≠veis, coletar estrelas, um cron√¥metro, finalizar, mas tudo isso foi feito sem um or√ßamento e com muito gosto.  O original realmente n√£o tinha anima√ß√µes!  Embora houvesse algo original nele, e algo, provavelmente, sincero.  Embora at√© aqui eles conseguissem me ultrapassar. <br><br><div class="spoiler">  <b class="spoiler_title">Eu encontrei algo parecido</b> <div class="spoiler_text">  Acontece que h√° um jogo muito semelhante com um nome quase id√™ntico.  E ela parece uma varia√ß√£o mais bem-sucedida do meu jogo.  Eu descobri sobre ela neste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√≠deo</a> . <br>  Depois que eu descobri que este jogo √© um exclusivo LG Smart TVs.  Foi criado pela divis√£o russa do LG R&amp;D Lab em 2014: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qs/r_/ro/qsr_rozxewpa190vstdrslntr9i.png" width="400"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h4/vt/3x/h4vt3xoolsh3l-rqqyxi7p52q7k.png" width="600"></div><br>  √â controlado pelas setas "esquerda" e "direita" no controle remoto.  Da mesma forma que no meu jogo (2 partes da tela).  O que posso dizer, o √¢ngulo de inclina√ß√£o √© o mesmo - 30 ¬∞.  Puramente tecnicamente, pode-se dizer que meu jogo √© plagiado por isso.  Embora eu tenha descoberto sobre ela cerca de 2 meses ap√≥s o lan√ßamento do primeiro jogo. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9k/8h/u6/9k8hu6sbmhqtlta1k8nnand7jkm.png" width="500"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/oa/dx/sdoadx3lb0kw-jx08nwmuszcewe.png" width="500"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wc/hj/b7/wchjb7a3e8pfykhr1kokfnxxslw.png" width="500"></div><br></div></div><br>  Compreendendo a posi√ß√£o muito deplor√°vel do original, decidi reviver o jogo com mudan√ßas radicais, para torn√°-lo melhor.  E ent√£o a fantasia voou: deixe haver um enredo e haver√° uma escolha nele, haver√° chefes com ataques ponderados, haver√° uma produ√ß√£o que o original estava t√£o carente, haver√° a sensa√ß√£o de uma √∫nica aventura conclu√≠da etc.  Em geral, todas as melhores ideias que me vieram durante o tempo entre o original e a sequ√™ncia.  E tudo o que n√£o funcionou ou deu errado estava destinado a ser jogado fora da sequ√™ncia. <br><br>  <i>Primeira demo</i> <br><br>  Tudo come√ßou, √© claro, com ele.  Eu decidi: "Se voc√™ resolver problemas, fa√ßa-o completamente".  E a primeira v√≠tima de tais mudan√ßas foi a administra√ß√£o.  Eu poderia roub√°-lo de um jogo semelhante (veja acima).  Esse √© exatamente o gerenciamento que eu originalmente queria, mas n√£o sabia como fazer.  Um complemento seria bem simples: basta adicionar anima√ß√µes de rota√ß√£o toda vez que voc√™ clicar.  Mas isso n√£o foi para mim.  Pelo menos para o controle ser percebido, bem como em um jogo semelhante, era necess√°rio fazer a mesma c√¢mera est√°tica e, obviamente, reduzir os n√≠veis, juntamente com o ritmo do jogo.  Mas eu queria a√ß√£o, din√¢mica e velocidade, ent√£o fiz um desenvolvimento l√≥gico do controle original.  Agora, em vez de pressionar e girar um certo grau, houve um aperto e o grau da rota√ß√£o final foi determinado pela sua dura√ß√£o.  Parecia claramente melhor do que no original. <br><br>  Foi porque eu normalmente controlava o controle que o bug principal do original desaparecia e agora era poss√≠vel tornar os n√≠veis MUITO mais carregados do que no original, sem medo de atrasos e frisos.  E ent√£o veio a parte experimental. <br><br>  <i>Demonstra√ß√£o gr√°fica</i> <br><br>  Eu nunca soube desenhar gr√°ficos normais e quase sempre era substitu√≠do pela parte tecnol√≥gica, ou melhor, pela execu√ß√£o normal.  E esse jogo n√£o foi exce√ß√£o.  Em vez de simples sprites normais, luz realista apareceu.  Era uma ilus√£o de luz 2d.  De fato, esta √© uma luz tridimensional, contra uma superf√≠cie de metal, e todos os objetos possuem materiais com shaders espec√≠ficos.  Parecia muito bom: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xr/y4/r7/xry4r7d7f2-qgnnrzxno2cbmpea.png" width="500"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5s/t7/9k/5st79k9tkdwa86zq4eg9xrcesc8.png" width="500"></div><br>  Nos testes, ele mostrou est√°veis ‚Äã‚Äã60 fps, mas no telefone, mesmo no meu sony xperia, ele estava em torno de 20 fps e afundou em 10 fps.  E eu corri para um teto de desempenho.  Eu tive que seguir um caminho diferente, o caminho da destrutibilidade ... <br><br>  <i>Destrutibilidade</i> <br><br>  Inicialmente, tudo parecia uma m√° ideia para mim.  Mas eu decidi tentar e agora este √© o meu principal programa de jogos.  De acordo com o plano, eu queria novamente mais realismo, a destrui√ß√£o dos fragmentos gerados, dependendo da dire√ß√£o e da for√ßa do impacto.  Mas o plano novamente repousou no teto, desta vez meu conhecimento.  Eu tive que simplificar para um mais simples. <br><br>  Agora, a destrutibilidade foi baseada em um princ√≠pio mais simples de opera√ß√£o, ou seja, criou uma c√≥pia de si mesmo, apenas a partir de fragmentos f√≠sicos, e o objeto original removeu os componentes do SpriteRenderer, Collider2D e, se houver, Rigidbody2D desativado. <br><br>  Mas outra quest√£o surgiu - colisores.  Por um lado, voc√™ poderia usar o PolygonCollider2D e n√£o ser atormentado, mas, por outro, teria que sofrer mais tarde no design e otimiza√ß√£o do jogo.  Portanto, todos os fragmentos dos blocos destru√≠dos tinham BoxCollider2D (mesmo fragmentos de objetos redondos). <br><br>  Al√©m disso, uma contribui√ß√£o significativa para a otimiza√ß√£o foi feita pela configura√ß√£o correta do par√¢metro time fixedstep (tornou-se igual a 0,0 (3) ou 30 por segundo).  Mas agora, em alta velocidade, o objeto voou atrav√©s dele, e isso definitivamente afetou o design do jogo. <br><br>  Esses elementos levaram a otimiza√ß√£o a um n√≠vel aceit√°vel e agora pode haver at√© centenas de objetos f√≠sicos no palco!  Ap√≥s o original, foi definitivamente um avan√ßo, revolu√ß√£o, etc.  Percebendo que estava seguindo na dire√ß√£o certa, decidi consertar outro problema de jogo de longa data: o hardcore avassalador.  Para de alguma forma provocar o jogo que eu fiz ... <br><br>  <i>Sistema de danos</i> <br><br>  Para mim, esta √© a parte mais obscura do desenvolvimento, que foi reescrita duas vezes.  O trabalho estava em andamento.  Como resultado, um sistema extremamente sofisticado foi lan√ßado, mas funcionou bastante. <br><br>  Mas primeiro, vale a pena mencionar como a percep√ß√£o de dano funciona aqui.  Pode parecer que funciona com o princ√≠pio "quanto mais voc√™ bate, mais forte o dano", mas n√£o √© assim.  Na maioria dos casos, funciona com o princ√≠pio de "quanto maior o contato - maior o dano", onde o lugar de algo t√£o importante como "for√ßa de impacto" foi substitu√≠do por um coeficiente de dano que foi configurado manualmente para cada objeto que causa dano, dependendo da situa√ß√£o.  Isso aconteceu devido ao fato de que o tempo fixado foi t√£o grande que um bug poderoso foi criado: o jogo n√£o conseguiu processar o Enter2D.  E isso criou situa√ß√µes como: caiu em alta velocidade - n√£o recebeu danos.  Por que n√£o consertei?  Nem eu posso dizer isso. <br><br>  Ent√£o, onde come√ßou o sistema de danos?  De sa√∫de.  O jogador tem uma sa√∫de igual a 1 (posteriormente aumentada para 2).  Sim, isso ainda n√£o √© suficiente, e no primeiro contato forte com a armadilha ele morrer√°, mas pelo menos em baixa velocidade, h√° uma chance de sobreviver (mesmo v√°rias vezes).  Eu n√£o queria mudar o original.  "Mas o que causar√° danos ao jogador?"  - pensei e inventei as principais armadilhas. <br><br>  <i>Armadilhas principais</i> <br><br>  A base do meu quebra-cabe√ßa consistia em armadilhas, mas elas contradiziam o nome do jogo.  Pelo nome, segue-se que o jogo deve ser sobre bolas que caem sob a influ√™ncia da gravidade.  Mas n√£o havia muitos deles.  Em vez disso, havia mais quebra-cabe√ßas padr√£o. <br><br>  O principal e o primeiro eram uma serra.  Quebra-cabe√ßa simples e claro.  Foi escrito de maneira n√£o muito otimizada, durante o per√≠odo de p√≥s-produ√ß√£o que eu o consertei. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1z/rd/12/1zrd120z2iybncavb97pa6khk_0.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Saw Script</b> <div class="spoiler_text"><pre><code class="plaintext hljs">using UnityEngine; public class Saw : GlobalFunctions { public AudioClip setClip; private TypePlaying typePlaying = TypePlaying.Sound; private AudioBase audioBase; private float speed = 4f; private Transform tr; private void Awake() { audioBase = GameObject.FindWithTag("MainCamera").GetComponent&lt;AudioBase&gt;(); tr = transform; } private void Update() { float s = Time.fixedDeltaTime / 0.03f * (Time.deltaTime / 0.03f); tr.localEulerAngles = new Vector3(0f, 0f, tr.localEulerAngles.z - speed * s); } private void OnCollisionEnter2D(Collision2D collision) { if (collision.collider.tag == "Player") { audioBase.SetSound(setClip, 1, 0.2f, typePlaying, false); } } public float GetSpeed() { return speed; } }</code> </pre> <br></div></div><br>  Em seguida, havia um laser, que, bem, carregava tudo muito pesado.  Se voc√™ colocar 40 pe√ßas no palco, o jogo come√ßar√° a ficar significativamente.  Mas eu tamb√©m desejava acrescentar leis f√≠sicas da luz, como reflex√£o ou at√© refra√ß√£o.  Mas n√£o houve tempo, eu n√£o terminei.  Embora eu tenha otimizado algumas coisas, n√£o ajudou muito. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ve/tr/yk/vetrykehlbbyyoiulruywx-ln2q.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Script a laser</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; public class Laser : MonoBehaviour { public Vector2 vector2; public bool active = true; public GameObject laserActive; public LineRenderer lr1; public Transform tr; public BoxCollider2D bcl; public Damage dmg; private void Start() { lr1.startColor = lr1.endColor = LaserColor(); } public Color LaserColor() { Color c = new Color(0f, 0f, 0f, 1f); switch (dmg.GetTypeLaser().Type2int()) { case 1: c = new Color(1f, 0f, 0f, 1f); break; case 2: c = new Color(0f, 1f, 0f, 1f); break; case 3: c = new Color(0f, 0f, 0f, 0.4901961f); break; case 4: c = new Color(1f, 0.8823529f, 0f, 1f); break; case 5: c = new Color(0.6078432f, 0.8823529f, 0f, 1f); break; case 6: c = new Color(1f, 0.2745098f, 0f, 1f); break; } return c; } private void Update() { LaserUpdate(); } private void LaserUpdate() { if (active == true) { Vector2[] act1 = Points(tr.position, -tr.up); lr1.SetPosition(0, act1[0]); lr1.SetPosition(1, act1[1]); bcl.size = new Vector2(0.1f, 0.1f); bcl.offset = act1[2]; } return; } private Vector2[] Points(Vector2 start, Vector2 end) { Vector2[] ret = new Vector2[3]; RaycastHit2D hit = Physics2D.Raycast(tr.position, -tr.up, 200f); ret[0] = tr.position; ret[1] = hit.point; vector2 = ret[1]; float distance = Vector2.Distance(tr.position, hit.point); bcl.size = new Vector2(0.1f, 0.1f); if (hit.collider == bcl) { ret[2] = new Vector2(0f, 0.5f); } else { ret[2] = new Vector2(0f, -distance - 0.2f); } return ret; } }</code> </pre><br></div></div><br><br>  A bomba foi a √∫ltima armadilha e, antes de adicion√°-la, reescrevi o sistema de danos, em particular, transferi tudo relacionado √† sa√∫de do jogador para um script HealthBar separado (√∫til para outros fins).  Depois que a bomba ainda apareceu, e sua f√≠sica deixou muito a desejar, no processo foi conclu√≠da novamente.  E, no final, acabou novamente digno. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zg/gn/so/zggnsolmlabdaf5gupqicjr3ih8.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Script de Explos√£o</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System.Collections; using UnityEngine; public class Explosion : GlobalFunctions { public float power = 1f; public float radius = 5f; public float health = 20f; public float timeOffsetExplosion = 1f; public GameObject[] contacts = new GameObject[0]; public Animator expAnim; public bool writeContacs = true; public AudioClip setClip; private float timeOffsetExplosionCount; private float alphaTimer; private bool isTimerOn = false; private bool firstAPEvirtual = true; private Collider2D cl; private Rigidbody2D rb; private SpriteRenderer sr; private AudioBase audioBase; private Explosion explosion; private void Awake() { audioBase = GameObject.FindWithTag("MainCamera").GetComponent&lt;AudioBase&gt;(); cl = GetComponent&lt;Collider2D&gt;(); rb = GetComponent&lt;Rigidbody2D&gt;(); sr = GetComponent&lt;SpriteRenderer&gt;(); explosion = GetComponent&lt;Explosion&gt;(); } private void Start() { alphaTimer = sr.color.a; StartCoroutineTimerOffsetExplosion(); } private void OnCollisionEnter2D(Collision2D collision) { if (writeContacs == true) { int cont = contacts.Length; GameObject[] n = new GameObject[cont + 1]; if (cont != 0) { for (int i = 0; i &lt; cont; i++) { n[i] = contacts[i]; } } n[cont] = collision.gameObject; contacts = n; } } private void OnCollisionExit2D(Collision2D collision) { if (writeContacs == true) { int cont = contacts.Length; if (cont != 1) { int counter = 0; GameObject[] n = new GameObject[cont - 1]; for (int i = 0; i &lt; cont; i++) { if (contacts[i] != collision.gameObject) { n[counter] = contacts[i]; counter++; } } contacts = n; } else { contacts = new GameObject[0]; } } } public void ActionExplosionEmulation(GameObject obj) { float damage = 0f; if (obj.CompareTag("Laser")) { damage = obj.GetComponent&lt;Damage&gt;().senDamage; } else { damage = obj.GetComponent&lt;Power&gt;().power; } health = health - damage; StartCoroutineTimerOffsetExplosion(); return; } public void StartCoroutineTimerOffsetExplosion() { if (health &lt;= 0f &amp;&amp; isTimerOn == false) { isTimerOn = true; timeOffsetExplosionCount = timeOffsetExplosion; StartCoroutine(TimerOffsetExplosion(0.1f)); } } private IEnumerator TimerOffsetExplosion(float timeTick) { yield return new WaitForSeconds(timeTick); timeOffsetExplosionCount = timeOffsetExplosionCount - timeTick; if (timeOffsetExplosionCount &gt; 0f) { float c = timeOffsetExplosionCount / timeOffsetExplosion; sr.color = new Color(1f, c, c, alphaTimer); StartCoroutine(TimerOffsetExplosion(timeTick)); } else { ExplosionAction(); } } private void ExplosionAction() { rb.gravityScale = 0f; rb.velocity = Vector2.zero; audioBase.SetSound(setClip, 2, 1f, TypePlaying.Sound, false); Destroy(cl); CircleCollider2D c = gameObject.AddComponent&lt;CircleCollider2D&gt;(); c.isTrigger = true; c.radius = radius; tag = "Explosion"; if (PlayerPrefs.GetString("graphicsquality") != "high") { Destroy(sr); StartCoroutine(Off()); } else { expAnim.enabled = true; StartCoroutine(Off2High()); } } public IEnumerator Off() { yield return new WaitForSecondsRealtime(0.1f); gameObject.SetActive(false); } public IEnumerator OffHigh(CircleCollider2D c) { yield return new WaitForSecondsRealtime(0.1f); c.enabled = false; } public IEnumerator Off2High() { yield return new WaitForSecondsRealtime(1.5f); gameObject.SetActive(false); } public void APEvirtual() { int cont = contacts.Length; if (cont != 0 &amp;&amp; firstAPEvirtual == true) { firstAPEvirtual = false; for (int i = 0; i &lt; cont; i++) { if (contacts[i] != null) { if (contacts[i].GetComponent&lt;PhysicsEmulation&gt;()) { contacts[i].GetComponent&lt;PhysicsEmulation&gt;().ExplosionPhysicsEmulation(explosion); } } } } } public void AnimFull() { sr.color = new Color(1f, 1f, 1f, 1f); sr.size = new Vector2(3f * radius, 3f * radius); return; } }</code> </pre><br></div></div><br>  Tendo examinado todo o sistema de danos, decidi reescrev√™-lo completamente.  E dessa vez, o Damage colocou todas as varia√ß√µes poss√≠veis de dano em um script de Damage e criou um m√©todo ActionPhysicsEmulation semelhante para blocos destrut√≠veis (no final, para cada tipo de dano individual, seu pr√≥prio m√©todo otimizado foi escrito).  Al√©m disso, a intensidade do dano foi determinada pela intensidade da "for√ßa" do objeto (o script estava apenas no jogador). <br><br>  E no final, apenas esses tr√™s quebra-cabe√ßas foram um corte acima do original.  Mas este n√£o foi um motivo para parar: eu tamb√©m n√£o esqueci de experimentar durante todo o desenvolvimento.  Assim apareceu. <br><br>  Campo de for√ßa (desativa a gravidade, diminui a velocidade e mata lentamente) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-d/ai/yk/-daiykfxbws9lxxsalwbop6xblg.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Script VelocityField</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; public class VelocityField : GlobalFunctions { public float percent = 10f; public float damage = 0.01f; public float heal = 0.01f; public GameObject[] contacts = new GameObject[0]; private HealthBar hb; private void Awake() { hb = GameObject.FindWithTag("MainCamera").GetComponent&lt;Management&gt;().healthBar; } private void FixedUpdate() { if (contacts.Length != 0) { for (int i = 0; i &lt; contacts.Length; i++) { if (contacts[i] != null) { if (contacts[i].GetComponent&lt;Rigidbody2D&gt;()) { float s = Time.fixedDeltaTime / 0.03f; Vector2 vel = contacts[i].GetComponent&lt;Rigidbody2D&gt;().velocity; contacts[i].GetComponent&lt;Rigidbody2D&gt;().velocity = vel / 100f * (100f - percent * s); } } else { contacts = Remove(contacts, i); } } } } private void OnTriggerEnter2D(Collider2D collision) { if (collision.GetComponent&lt;Rigidbody2D&gt;()) { Rigidbody2D rb2 = collision.GetComponent&lt;Rigidbody2D&gt;(); if (rb2.isKinematic == false) { VelocityInput vi = collision.GetComponent&lt;VelocityInput&gt;(); vi.fields = Add(vi.fields, gameObject); rb2.gravityScale = 0f; rb2.freezeRotation = true; vi.inVelocityField = true; if (collision.GetComponent&lt;Destroy&gt;()) { collision.GetComponent&lt;Destroy&gt;().ActiveTimerDeleteChange(300f); } if (collision.tag == "Player") { hb.StartVFRad(damage); } contacts = Add(contacts, collision.gameObject); } } } public void OnTriggerExit2D(Collider2D collision) { if (collision.GetComponent&lt;Rigidbody2D&gt;()) { Rigidbody2D rb2 = collision.GetComponent&lt;Rigidbody2D&gt;(); if (rb2.isKinematic == false) { VelocityInput vi = collision.GetComponent&lt;VelocityInput&gt;(); vi.fields = Remove(vi.fields, gameObject); if (vi.fields.Length != 0) { rb2.gravityScale = 0f; rb2.freezeRotation = true; vi.inVelocityField = true; } else { rb2.gravityScale = 1f; rb2.freezeRotation = false; vi.inVelocityField = false; } if (collision.GetComponent&lt;Destroy&gt;()) { collision.GetComponent&lt;Destroy&gt;().ActiveTimerDeleteChange(60f); } if (collision.tag == "Player") { hb.EndVFRad(heal); } contacts = Remove(contacts, collision.gameObject); } } } }</code> </pre><br></div></div><br>  Stomp (ele matou os jogadores, esmagando-os) <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ag/id/eu/agideu1-kir4r8z4xgmawwhcp_c.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Tramp Script</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; public class TrampAnim : MonoBehaviour { public float speed = 0.1f; public float speedOffset = 0.01f; public float damage = 1f; private float sc; private float maxDis; public Vector3 start; public Vector3 end; public TrampAnim ender; public bool active = true; public bool trigPlayer = false; private AudioSet audioSet; private bool audioAct; private Transform tr; private HealthBar hb; public int count = 0; public void Start() { if (active) { tr = transform; maxDis = Vector2.Distance(start, end); sc = Vector2.Distance(tr.localPosition, start) / maxDis; hb = Camera.main.GetComponent&lt;Management&gt;().healthBar; audioAct = GetComponent&lt;AudioSet&gt;(); if (audioAct) { audioSet = GetComponent&lt;AudioSet&gt;(); } } } public void Update() { if (active) { float s = Time.fixedDeltaTime / 0.03f * (Time.deltaTime / 0.03f); if (count == 0) { tr.localPosition = Vector2.MoveTowards(tr.localPosition, end, (speed * sc + speedOffset) * s); if (tr.localPosition == end) { count = 1; if (trigPlayer &amp;&amp; ender.trigPlayer) { hb.Damage(100f, tag, Vector2.zero); } if (audioAct) { audioSet.SetMusic(); } } } else { tr.localPosition = Vector2.MoveTowards(tr.localPosition, start, (speed * sc + speedOffset) * s); if (tr.localPosition == start) { count = 0; } } sc = Vector2.Distance(tr.localPosition, start) / maxDis; } } public void OnCollisionEnter2D(Collision2D collision) { Transform trans = collision.transform; string tag = trans.tag; if (tag == "Player") { trigPlayer = true; } else if (active == false) { if (trans.GetComponent&lt;PhysicsEmulation&gt;()) { trans.GetComponent&lt;PhysicsEmulation&gt;().TrampAnimPhysicsEmulation(GetComponent&lt;TrampAnim&gt;()); } } } public void OnCollisionExit2D(Collision2D collision) { string tag = collision.transform.tag; if (tag == "Player") { trigPlayer = false; } } }</code> </pre><br></div></div><br>  Radia√ß√£o (que reduz lentamente a sa√∫de) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bz/w2/mi/bzw2mi2pn0jk6lzbqiu4ze-we5u.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Radia√ß√£o de Script</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System.Collections; using UnityEngine; public class Radiation : MonoBehaviour { public bool isActiveRadiation = false; private Management m; private HealthBar hb; private void Awake() { gameObject.SetActive(PlayerPrefs.GetString("ai") == "off"); m = GameObject.FindWithTag("MainCamera").GetComponent&lt;Management&gt;(); hb = m.healthBar; } private void Start() { StartCoroutine(RadiationDamage()); } public IEnumerator RadiationDamage() { yield return new WaitForSeconds(0.0002f); if (isActiveRadiation) { hb.StraightDamage(0.0002f, "Radiation"); } StartCoroutine(RadiationDamage()); } public void OnTriggerEnter2D(Collider2D collision) { if (collision.tag == "Player") { isActiveRadiation = true; hb.animator.SetBool("isVisible", true); } } public void OnTriggerExit2D(Collider2D collision) { if (collision.tag == "Player") { isActiveRadiation = false; hb.animator.SetBool("isVisible", false); if (hb.healthBarImage.fillAmount == 0f) { m.StartGraphics(); } } } public void OnCollisionEnter2D(Collision2D collision) { if (collision.transform.tag == "Player") { hb.animator.SetBool("isVisible", false); PlayerPrefs.SetString("ai", "on"); gameObject.SetActive(false); } } }</code> </pre><br></div></div><br>  Armadilha (uma bola azul que mata quando tocada, que √© uma refer√™ncia ao jogo mais dif√≠cil do mundo) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oh/wg/6y/ohwg6ye0n_7lvpk_gt8igkknjye.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Script DeathlessScript</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; public class DeathlessScript : MonoBehaviour { private HealthBar hb; private void Awake() { hb = Camera.main.GetComponent&lt;Management&gt;().healthBar; } public void OnTriggerEnter2D(Collider2D collision) { if (collision.tag == "Player") { hb.Damage(10f, tag, Vector2.zero); } } }</code> </pre><br></div></div><br>  N√£o registrei todos esses tipos de danos no script Damage, mas eles geralmente funcionavam bem com muletas.  Depois disso, mec√¢nicos adicionais entraram na fila. <br><br>  <i>Mec√¢nica adicional</i> <br><br>  Eles foram feitos variados.  Havia alguns deles, de modo que todos eles eram de interesse e n√£o o suficiente para funcionarem para interagir com a maioria das mec√¢nicas de jogo. <br><br>  A primeira dessas mec√¢nicas foram os port√µes.  O primeiro e mais funcional de todos.  Definitivamente √∫til em todos os locais onde eram necess√°rias barreiras funcionais.  Ele tamb√©m possui fun√ß√µes adicionais: isActive para determinar o estado inicial e isState para corrigir a posi√ß√£o ap√≥s a ativa√ß√£o (os nomes s√£o misturados, mas quando se notou que era tarde demais para corrigir). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1j/by/if/1jbyifik8daournyzffkwxtubxk.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Script Gate</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; using System.Collections; public class Gate : MonoBehaviour { [Header("StartSet")] public Vector2 gateScale = new Vector2(1, 4); public float speed = 0.1f; public bool isReverse = false; public bool isEnd = true; public Vector2 animSetGateScale = new Vector2(); public Vector2 target = new Vector2(); [Header("SpriteEditor")] public Sprite mainSprite; [Header("Assets")] public GameObject door1; public GameObject door2; private IEnumerator fixUpdate; private void Start() { SpriteRenderer ds1 = door1.GetComponent&lt;SpriteRenderer&gt;(); SpriteRenderer ds2 = door2.GetComponent&lt;SpriteRenderer&gt;(); ds1.sprite = mainSprite; ds2.sprite = mainSprite; if (isReverse == false) { animSetGateScale = target = gateScale; } fixUpdate = FixUpdate(); SetGate(animSetGateScale); } private IEnumerator FixUpdate() { yield return new WaitForSeconds(0.03f); if (animSetGateScale != target) { float s = Time.fixedDeltaTime / 0.03f; animSetGateScale = Vector2.MoveTowards(animSetGateScale, target, speed * s); SetGate(animSetGateScale); StartCoroutine(FixUpdate()); } } private void SetGate(Vector2 scale) { SpriteRenderer ds1 = door1.GetComponent&lt;SpriteRenderer&gt;(); SpriteRenderer ds2 = door2.GetComponent&lt;SpriteRenderer&gt;(); Vector2 size = new Vector2(mainSprite.texture.width, mainSprite.texture.height); float k = size.x / size.y; ds1.size = new Vector2(gateScale.x, scale.y / 2f); ds2.size = new Vector2(gateScale.x, scale.y / 2f); BoxCollider2D d1 = door1.GetComponent&lt;BoxCollider2D&gt;(); BoxCollider2D d2 = door2.GetComponent&lt;BoxCollider2D&gt;(); d1.size = new Vector2(gateScale.x, scale.y / 2f); d2.size = new Vector2(gateScale.x, scale.y / 2f); door1.transform.localScale = new Vector3(1f, 1f, 1f); door2.transform.localScale = new Vector3(1f, 1f, 1f); door1.transform.localPosition = new Vector3(0f, (gateScale.y / 2f) - (scale.y / 4f), 0f); door2.transform.localPosition = new Vector3(0f, -(gateScale.y / 2f) + (scale.y / 4f), 0f); } public void OnTriggerEnter2D(Collider2D collision) { if (collision.CompareTag("Player")) { if (isReverse == false) { target = Vector2.zero; } else { target = gateScale; } StopCoroutine(fixUpdate); fixUpdate = FixUpdate(); StartCoroutine(fixUpdate); } } private void OnTriggerExit2D(Collider2D collision) { if (collision.CompareTag("Player") &amp;&amp; isEnd == true) { if (isReverse == false) { target = gateScale; } else { target = Vector2.zero; } StopCoroutine(fixUpdate); fixUpdate = FixUpdate(); StartCoroutine(fixUpdate); } } }</code> </pre><br></div></div><br>  Funcionalidade semelhante era possu√≠da por objetos f√≠sicos.  N√£o, n√£o s√£o objetos de destrui√ß√£o, s√£o apenas objetos f√≠sicos (embora tamb√©m possam ser destru√≠dos, mas n√£o usem essa mec√¢nica).  N√£o existem muitos deles em quebra-cabe√ßas, mas eles combinam bem com outras mec√¢nicas.  Por exemplo, com um port√£o: quando um objeto toca um gatilho, o port√£o se abre. <br><br>  Desde que aprendi a "possuir poder", tr√™s mec√¢nicos o controlavam.  Estes eram gatilhos com o mesmo c√≥digo para interagir com objetos, mas cada um executava tarefas √† sua maneira.  O primeiro foi um campo de for√ßa (diminuiu a velocidade do objeto, multiplicando a for√ßa por um determinado fator).  O segundo adicionou for√ßa na dire√ß√£o do ponto e o ponto teve "gravidade".  A terceira foi feita por acidente: quando o quebra-cabe√ßa relacionado √† gravidade zero n√£o funcionou, esse script o salvou.  Nele, o objeto muda a dire√ß√£o da for√ßa, sem alterar ela mesma, sua intensidade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5t/cs/f7/5tcsf7fu4hrzrspc8fdlph14zpk.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Como isso funciona</b> <div class="spoiler_text">  Primeiro, pelo teorema de Pit√°goras, a hipotenusa √© calculada, que √© o coeficiente do vetor e √© √∫til para restaurar a for√ßa.  O √¢ngulo √© ent√£o calculado usando a fun√ß√£o Atan2.  Depois disso, offsetAngle √© adicionado ao canto e um novo vetor √© constru√≠do com base no seno e no cosseno, que √© multiplicado por um coeficiente e uma dire√ß√£o alterada √© obtida sem uma for√ßa alterada. <br><pre> <code class="plaintext hljs">public Vector2 RotateVector(Vector2 a, float offsetAngle) { float power = Mathf.Sqrt(ax * ax + ay * ay); float angle = Mathf.Atan2(ay, ax) * Mathf.Rad2Deg - 90f + offsetAngle; return Quaternion.Euler(0, 0, angle) * Vector2.up * power; }</code> </pre><br></div></div><br>  Com isso, toda a minha fantasia de extras secou.  Sim, havia id√©ias como uma bomba em uma corda, um telef√©rico etc.  Mas ent√£o surgiu a id√©ia normal: voc√™ precisa renderizar o jogo novamente.  Ainda assim, vou ser sincero comigo mesmo: a grande maioria das pessoas joga jogos para celular, e quase nenhuma delas jogar√° meu jogo se o jogo for insuportavelmente complicado.  Decidi come√ßar com quebra-cabe√ßas que matavam o jogador com um golpe, mas n√£o queria mudar o dano por causa da destrutibilidade.  E ent√£o surgiu a id√©ia da mec√¢nica adicional normal: refor√ßadores ou modificadores. <br><br>  De acordo com o conceito, eles deram melhorias tempor√°rias associadas a alguns valores b√°sicos.  Houve 5 refor√ßos: tratamento, imortalidade, dilata√ß√£o do tempo (movimento lento), mudan√ßa na gravidade e mudan√ßa na massa do jogador. <br><br>  Mas parecia algum tipo de padr√£o: bolas de gatilho espalhadas pelo n√≠vel para ajudar a passar.  E ent√£o eu adicionei esses refor√ßos ao laser.  Mudou um pouco a mec√¢nica e funcionou. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rf/fe/b_/rffeb_rey0t4dhbhwupljorcyva.png" width="500"></div><br>  Agora, o laser possui 5 modos de intera√ß√£o com o jogador: dano e cura, imortalidade, dilata√ß√£o do tempo (movimento lento), mudan√ßa na gravidade e mudan√ßa na massa do jogador.  √â a mesma coisa, mas com uma diferen√ßa: o laser age constantemente no aparelho e, se voc√™ o deixar, o efeito desaparecer√° imediatamente (ou depois de um tempo).  Sim, os boosters t√™m quase o mesmo, mas os lasers n√£o s√£o padr√£o (e, portanto, o jogo inteiro). <br><br>  O tema f√≠sico do jogo tornou poss√≠vel criar um trampolim, que geralmente √© usado para dispersar o jogador com a subsequente destrui√ß√£o da parede (embora este seja um simples BoxCollider2D com PhysicsMaterial, no qual o par√¢metro de rejei√ß√£o foi torcido para diferentes for√ßas de rejei√ß√£o). <br><br>  E a areia do jogo permitiu criar seus pr√≥prios scripts para anima√ß√£o.  Basicamente, eles moveram o objeto de ponto a ponto ou giraram o objeto.  Anteriormente, eles tinham significativamente mais fun√ß√µes: a capacidade de girar um objeto animadamente (por pontos), escala (por pontos), r√≥tulos mais precisos para o in√≠cio e o fim da anima√ß√£o de um objeto etc.  Mas, devido ao fato de serem atavismos, que consumiam freneticamente a produtividade, tive que cort√°-los em nome da otimiza√ß√£o.  O script de anima√ß√£o √© usado sempre que voc√™ precisa mostrar uma anima√ß√£o simples, porque como eu disse: "O original estava com muita falta de anima√ß√µes!"  Existem apenas dois scripts: <br><br>  BasicAnimation e PointsAnimation. <br><br><div class="spoiler">  <b class="spoiler_title">Script BasicAnimation</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; using System.Collections; public class BasicAnimation : GlobalFunctions { public AnimationType animationType = AnimationType.Infinity; public float speedSpeed = 0.05f; public float rotation = 0f; private bool make = true; private bool animMake = false; private bool isMoved = false; private Transform tr; private float rotationActive = 0f; public void SetPos(bool pos, float m) { rotationActive = rotation * (pos ? 1 : m); } private void Start() { tr = transform; animMake = false; switch (animationType) { case AnimationType.Infinity: make = true; isMoved = true; rotationActive = rotation; break; case AnimationType.Start: make = false; isMoved = false; break; case AnimationType.End: make = true; isMoved = true; rotationActive = rotation; break; case AnimationType.All: make = false; isMoved = false; break; } } public void TimerAnim(float timer, bool anim) { StartAnim(anim); StartCoroutine(TimerTimerAnim(timer, anim)); } private IEnumerator TimerTimerAnim(float timer, bool anim) { yield return new WaitForSeconds(timer); EndAnim(anim); } public void StartAnim(bool anim) { make = true; if (anim == true) { animMake = true; isMoved = true; } else { rotationActive = rotation; } } public void EndAnim(bool anim) { if (anim == true) { animMake = true; isMoved = false; } else { make = false; rotationActive = 0f; } } private void FixedUpdate() { if (animMake == true) { if (isMoved == true) { if (rotationActive != rotation) { rotationActive = Mathf.MoveTowards(rotationActive, rotation, speedSpeed); } else { animMake = false; isMoved = false; } } else { if (rotationActive != 0f) { rotationActive = Mathf.MoveTowards(rotationActive, 0f, speedSpeed); } else { animMake = false; isMoved = true; } } } } private void Update() { if (make == true) { float rot = tr.localEulerAngles.z; float s = Time.fixedDeltaTime / 0.03f * (Time.deltaTime / 0.03f); tr.localEulerAngles = new Vector3(0f, 0f, rot + rotationActive * s); } } }</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Script de Anima√ß√£o</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; using System.Collections; public class PointsAnimation : GlobalFunctions { public AnimationType animationType = AnimationType.Infinity; public float speedSpeedPosition = 0.001f; public float speedPosition = 0.1f; public Vector3[] pointsPosition = new Vector3[0]; public int counterPosition = 0; private float speedPositionActive = 0f; private int pointsPositionLength = 0; private bool make = true; private bool animMake = false; private bool isMoved = false; private Transform tr; public void SetPos(bool pos, float m) { speedPositionActive = speedPosition * (pos ? 1 : m); } private void Awake() { pointsPositionLength = pointsPosition.Length; tr = transform; switch (animationType) { case AnimationType.Infinity: make = true; isMoved = true; speedPositionActive = speedPosition; break; case AnimationType.Start: make = false; isMoved = false; break; case AnimationType.End: make = true; isMoved = true; speedPositionActive = speedPosition; break; case AnimationType.All: make = false; isMoved = false; break; } } public void TimerAnim(float timer, bool anim) { StartAnim(anim); StartCoroutine(TimerTimerAnim(timer, anim)); } private IEnumerator TimerTimerAnim(float timer, bool anim) { yield return new WaitForSeconds(timer); EndAnim(anim); } public void StartAnim(bool anim) { make = true; if (anim == true) { animMake = true; isMoved = true; } else { speedPositionActive = speedPosition; } } public void EndAnim(bool anim) { if (anim == true) { animMake = true; isMoved = false; } else { make = false; speedPositionActive = 0f; } } private void FixedUpdate() { if (animMake == true) { if (isMoved == true) { if (speedPositionActive != speedPosition) { Vector2 ends = new Vector2(-speedPosition, speedPosition); speedPositionActive = Mathf.MoveTowards(speedPositionActive, speedPosition, speedSpeedPosition); } else { animMake = false; isMoved = false; } } else { if (speedPositionActive != 0f) { Vector2 ends = new Vector2(-speedPosition, speedPosition); speedPositionActive = Mathf.MoveTowards(speedPositionActive, 0f, speedSpeedPosition); } else { animMake = false; isMoved = true; } } } } private void Update() { if (make) { if (tr.localPosition == pointsPosition[counterPosition]) { counterPosition++; if (counterPosition == pointsPositionLength) { counterPosition = 0; } } else { float s = Time.fixedDeltaTime / 0.03f * (Time.deltaTime / 0.03f); tr.localPosition = Vector3.MoveTowards(tr.localPosition, pointsPosition[counterPosition], speedPositionActive * s); } } } }</code> </pre><br></div></div><br>  <i>UI</i> <br><br>  Comparado com o original, esta √© uma verdadeira obra-prima. <br><br>  Para compara√ß√£o, aqui est√° o original: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iu/i9/lz/iui9lzqmqtypz2cvs3cqacrz644.png" width="500"></div><br>  Aqui est√° a sequela: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tt/d9/7t/ttd97thjtgvskcddhk1qwo5zwdc.png" width="500"></div><br>  Aqui est√° o original: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9m/9n/is/9m9nisamgqedkkpx1ou8498vdqa.png" width="500"></div><br>  Aqui est√° a sequela: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yx/l7/3k/yxl73kah93pbxu8hjsckduyylh0.png" width="500"></div><br>  Aqui orig ... acho que est√° claro.  Minimalismo na sequ√™ncia que eu me lembrei, e em vez do bot√£o de pausa inapropriadamente colorido e do temporizador francamente interferente, agora existe um bot√£o de pausa lok√¢nico e de alguma forma percept√≠vel no canto inferior esquerdo.  A continua√ß√£o ainda ganha o menu.  Ao contr√°rio do original, existem anima√ß√µes em todos os lugares, e o fundo s√£o 11 shaders que acidentalmente escrevi no Shader Graph.  A funcionalidade tamb√©m est√° melhorando, h√° uma configura√ß√£o gr√°fica, configura√ß√µes separadas de som e m√∫sica, um console que permite alterar o salvamento - n√£o h√° nada disso no menu original. <br><br>  Ficou t√£o bom porque eu decidi olhar para outros jogos.  Aqui e ali, em geral, tirei (um pouco) o melhor de todos os lugares.  E aqui est√° o que eu tomei especial: <br><br><ol><li>  Menu Reproduzir <br>  Extra√≠do da aventura de Alto, apenas experi√™ncias transformadas em rid√≠culo, piadas, coment√°rios ir√¥nicos etc. </li><li>  Pausar <br>  Tamb√©m do Alto, mas n√£o t√£o funcional, mas se encaixa mais convenientemente e toca mais convenientemente. </li><li>  Configura√ß√µes <br>  Parcialmente retirado do Vetor 2, ou seja, a forma dos controles deslizantes de menu e volume. <br>  Ele demorou um pouco em geral, mas por outro lado fez tudo sozinho. </li></ol><br>  <i>Console</i> <br><br>  Primeiro, fa√ßa uma reserva sobre como funciona a conserva√ß√£o.  Existem duas vari√°veis ‚Äã‚Äãrespons√°veis ‚Äã‚Äãpela conserva√ß√£o global e local: esses s√£o os n√∫meros progress e elevatorsave, respectivamente.  A vari√°vel progress √© respons√°vel por salvar entre as cenas, e a vari√°vel elevatorsave √© respons√°vel por salvar dentro da cena.  Quando voc√™ pressiona o bot√£o "Iniciar" ou "Reiniciar", o jogo transfere o progresso para a cena e gera o jogador salvando sob o n√∫mero de salvador do elevador. <br><br>  O console permite alterar ou criar qualquer vari√°vel.  Uma ferramenta t√£o simples e poderosa foi muito √∫til para testar o jogo e identificar bugs nele.  O console em si √© um comando escrito √† m√£o que imita outros consoles. <br><br><div class="spoiler">  <b class="spoiler_title">Script DebugConsole</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; using UnityEngine.UI; using UnityEngine.SceneManagement; using System.Collections; public class DebugConsole : MonoBehaviour { public Animator animatorBlackScreen; public Language l; public InputField inputField; public Text textDebug; private bool access = false; public void AnalyzeText() { string txt = inputField.text.ToLower(); string[] output = new string[0]; string txtLoc = ""; for (int i = 0; i &lt; txt.Length; i++) { if (txt[i] == ' ') { if (txtLoc != "") { output = Add(output, txtLoc); txtLoc = ""; } } else { txtLoc = txtLoc + txt[i]; } } if (txtLoc != "") { output = Add(output, txtLoc); txtLoc = ""; } Analyze(output); } public void Analyze(string[] commands) { switch (commands[0]) { case "playerprefs": if (access == true) { if (commands.Length &lt; 2) { Log(l.ConsoleLanguage(1));//1 } else { switch (commands[1]) { case "f": case "float": float f = 0f; if (float.TryParse(commands[3], out f)) { PlayerPrefs.SetFloat(commands[2], float.Parse(commands[3])); Log(l.ConsoleLanguage(2, commands[2]));//2 } else { Log(l.ConsoleLanguage(3));//3 } break; case "i": case "int": int i = 0; if (int.TryParse(commands[3], out i)) { PlayerPrefs.SetInt(commands[2], int.Parse(commands[3])); Log(l.ConsoleLanguage(4, commands[2]));//4 } else { Log(l.ConsoleLanguage(5));//5 } break; case "s": case "string": PlayerPrefs.SetString(commands[2], commands[3]); Log(l.ConsoleLanguage(6, commands[2]));//6 break; case "clear": PlayerPrefs.DeleteAll(); SceneManager.LoadScene(0); break; default: Log(l.ConsoleLanguage(7, commands[1]));//7 break; } } } else { Log(l.ConsoleLanguage(8));//8 } break; case "next": if (access == true) { if (commands.Length &gt; 1) { switch (commands[1]) { case "level": int p = PlayerPrefs.GetInt("progress"); PlayerPrefs.SetInt("progress", p + 1); Log("ok level"); break; case "save": int s = PlayerPrefs.GetInt("elevatorsave"); PlayerPrefs.SetInt("elevatorsave", s + 1); Log("ok save"); break; case "start": PlayerPrefs.SetInt("elevatorsave", 0); Log("ok start"); break; case "end": PlayerPrefs.SetInt("elevatorsave", 1); Log("ok end"); break; } } } else { Log(l.ConsoleLanguage(8));//8 } break; case "echo": if (commands.Length == 1) { Log(l.ConsoleLanguage(9));//9 } else { switch (commands[1]) { case "vertogpro"://echo vertogpro access = true; Log(l.ConsoleLanguage(10));//10 break; default: Log(l.ConsoleLanguage(11));//11 break; } } break; case "restart": if (access == true) { SceneManager.LoadScene(0); } else { Log(l.ConsoleLanguage(12));//12 } break; case "authors": Log(l.ConsoleLanguage(13));//13 break; case "discharge": animatorBlackScreen.SetBool("isActive", true); PlayerPrefs.SetString("start", "key"); PlayerPrefs.SetString("language", "nothing"); PlayerPrefs.SetString("graphicsquality", "medium"); PlayerPrefs.SetFloat("sound", 0.5f); PlayerPrefs.SetFloat("music", 0.5f); PlayerPrefs.SetFloat("rotatenextlevel", 0f); PlayerPrefs.SetInt("elevatorsave", 0); PlayerPrefs.SetInt("progress", 1); PlayerPrefs.SetInt("deaths", 0); PlayerPrefs.SetInt("discharge", PlayerPrefs.GetInt("discharge") + 1); PlayerPrefs.SetInt("lastmenueffect", -1); PlayerPrefs.SetString("isshotmode", "false"); PlayerPrefs.SetString("boss1", "life"); PlayerPrefs.SetString("boss2", "life"); PlayerPrefs.SetString("ai", "off"); PlayerPrefs.SetString("boss3", "life"); PlayerPrefs.SetString("end", "none"); StartCoroutine(StartGame()); break; case "clear": Clear(); break; case "info": if (access == false) { Log(l.ConsoleLanguage(14));//14 } else { Log(l.ConsoleLanguage(15));//15 } break; default: Log(l.ConsoleLanguage(16, commands[0]));//16 break; } } public void Log(object message) { textDebug.text = message.ToString(); } public void Clear() { inputField.text = ""; textDebug.text = ""; } public string[] Add(string[] old, string addComponent) { string[] n = new string[old.Length + 1]; if (old.Length != 0) { for (int i = 0; i &lt; old.Length; i++) { n[i] = old[i]; } } n[old.Length] = addComponent; return n; } public IEnumerator StartGame() { yield return new WaitForSeconds(1f); SceneManager.LoadSceneAsync(0); } }</code> </pre><br></div></div><br>           : <br><br><ol><li> discharge ‚Äî    (    ) </li><li> echo vertogpro ‚Äî        </li><li> playerprefs [  (string, int, float)] [ ] [] ‚Äî     . : playerprefs int progress 14 </li><li> next ‚Äî      ,   : <br><ul><li> start ‚Äî     (next start) </li><li> end ‚Äî     (next end) </li><li> save ‚Äî     (next save) </li><li> level ‚Äî     (next level) </li></ul></li></ol><br> <i></i> <br><br>        ,       ,    :   30 -  ,         .          ,  ,        (,   .)    -  asset store.       ,     .  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/81/ap/oz/81apoz9lyvlrkz-zr73c2y54qjo.png" width="500"></div><br>   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jz/gl/h3/jzglh35mj-d5ymacylqigsnmphw.png" width="500"></div><br> <i></i> <br><br>     ,     .     3 : <br><br><ol><li> ElevatorBase ‚Äî ,     .     elevatorsave      . <br><br><div class="spoiler"> <b class="spoiler_title"> ElevatorBase</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; using System.Collections; public class ElevatorBase : MonoBehaviour { public GameObject[] savers = new GameObject[0]; public float inputStartBlock = 1f; private GameUI gameUI; public void Awake() { int l = savers.Length; if (l != 0) { for (int i = 0; i &lt; l; i++) { if (savers[i] != null) { if (savers[i].GetComponent&lt;Saving&gt;()) { Saving saving = savers[i].GetComponent&lt;Saving&gt;(); saving.isFirst = false; saving.idElevatorBase = i; } else if (savers[i].GetComponent&lt;Elevator&gt;()) { savers[i].GetComponent&lt;Elevator&gt;().isFirst = false; } } } int es = PlayerPrefs.GetInt("elevatorsave"); if (savers[es] != null) { if (savers[es].GetComponent&lt;Saving&gt;()) { savers[es].GetComponent&lt;Saving&gt;().isFirst = true; } else if (savers[es].GetComponent&lt;Elevator&gt;()) { savers[es].GetComponent&lt;Elevator&gt;().isFirst = true; } } else { gameUI = GameObject.FindWithTag("Canvas").GetComponent&lt;GameUI&gt;(); StartCoroutine(BlockEnabled()); GameObject.Find("TipsInput").GetComponent&lt;TipsGamePlayInput&gt;().active = true; } } else { gameUI = GameObject.FindWithTag("Canvas").GetComponent&lt;GameUI&gt;(); gameUI.ChangeisBlocked(); } } public IEnumerator BlockEnabled() { yield return new WaitForSeconds(inputStartBlock); GameObject block = gameUI.block.gameObject; block.SetActive(false); } }</code> </pre></div></div><br></li><li> Saving ‚Äî ,            ,   ,         elevatorsave  id. <br><br><div class="spoiler"> <b class="spoiler_title"> Saving</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System.Collections; using UnityEngine; public class Saving : MonoBehaviour { public Saving[] savings; public Vector2 startPos; public float startRot; public bool isActive = true; public bool isFirst = true; public int idElevatorBase = 0; public TipsGamePlayInput tgpi; private GameObject player; private GameObject cam; private Transform trp; private GameUI gameui; private Management m; private Saving self; private void Start() { self = GetComponent&lt;Saving&gt;(); cam = GameObject.FindWithTag("MainCamera"); m = cam.GetComponent&lt;Management&gt;(); gameui = GameObject.FindWithTag("Canvas").GetComponent&lt;GameUI&gt;(); player = m.player; trp = player.GetComponent&lt;Transform&gt;(); if (isFirst) { trp.position = startPos; m.Set(startRot); OfferSaves(); } isActive = !isFirst; tgpi.SetActive(!isFirst); StartCoroutine(BlockFalse()); } public IEnumerator BlockFalse() { yield return new WaitForSeconds(1f); gameui.block.gameObject.SetActive(false); } private void OnTriggerEnter2D(Collider2D collision) { if (collision.CompareTag("Player") &amp;&amp; isActive == true) { isActive = false; PlayerPrefs.SetInt("elevatorsave", idElevatorBase); OfferSaves(); } } public void OfferSaves() { if (savings.Length != 0) { for (int i = 0; i &lt; savings.Length; i++) { savings[i].isActive = false; savings[i].tgpi.SetActive(false); } } } }</code> </pre></div></div><br></li><li> Elevator ‚Äî   ,      .   :           (      ). <br><br><div class="spoiler"> <b class="spoiler_title"> Elevator</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System.Collections; using UnityEngine; public class Elevator : GlobalFunctions { public Vector2 endPos; public Vector2 startPos; public int nextScene = 1; public int nextElevatorSave = 0; public float speed = 0.1f; public bool isFirst = true; public bool isActive = true; public bool isReverse = false; public bool isMake = false; private GameObject player; private Rigidbody2D rb; private Transform tr; private Transform trp; private GameUI gameui; private AudioBase audioBase; private Transform cam; private void Start() { audioBase = GameObject.FindWithTag("MainCamera").GetComponent&lt;AudioBase&gt;(); gameui = GameObject.FindWithTag("Canvas").GetComponent&lt;GameUI&gt;(); player = gameui.m.player; rb = player.GetComponent&lt;Rigidbody2D&gt;(); trp = player.GetComponent&lt;Transform&gt;(); tr = GetComponent&lt;Transform&gt;(); cam = gameui.m.transform; startPos = tr.position; if (isFirst) { trp.position = startPos; rb.velocity = new Vector2(); rb.gravityScale = 0f; gameui.m.Set(); } else { tr.position = endPos; isMake = true; } isActive = isFirst; isReverse = false; } private void OnTriggerEnter2D(Collider2D collision) { if (collision.CompareTag("Player") &amp;&amp; isMake == true) { isReverse = true; isActive = true; rb.velocity = new Vector2(); rb.gravityScale = 0f; gameui.block.gameObject.SetActive(true); PlayerPrefs.SetInt("elevatorsave", nextElevatorSave); gameui.animatorBlackScreenGame.SetBool("isActive", true); audioBase.LowerSound(0.05f, 16, 0, TypePlaying.Music); StartCoroutine(NumSaveRotate()); StartCoroutine(gameui.StartGame(1.5f, nextScene)); } } private IEnumerator NumSaveRotate() { yield return new WaitForSeconds(1.5f); PlayerPrefs.SetFloat("rotatenextlevel", Stable(cam.localEulerAngles.z, -180f, 180f)); } private void FixedUpdate() { if (isActive == true) { float s = Time.fixedDeltaTime / 0.03f; if (isReverse == false) { rb.velocity = new Vector2(); tr.position = Vector2.MoveTowards(tr.position, endPos, speed * s); trp.position = tr.position; if ((Vector2)tr.position == endPos) { isMake = true; isActive = false; rb.gravityScale = 1f; gameui.block.gameObject.SetActive(false); } } else if (isReverse == true) { tr.position = Vector2.MoveTowards(tr.position, startPos, speed * s); trp.position = tr.position; if (tr.position == (Vector3)startPos) { isActive = false; rb.gravityScale = 1f; } } } } }</code> </pre></div></div></li></ol><br> <i> </i> <br><br>    .        4  6 .    34 : 30 , 3   1  ().     2-3 ,   2      .     ,    : 10  =&gt; 1  =&gt; 10  =&gt; 2  =&gt; 10  =&gt; 3  =&gt;  . <br><br>     .  ,     .     ,     .     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xv/1y/fx/xv1yfxu-5xf9nzogz1ffuzc8wc0.png" width="350"></div><br>      ,         .         ,  ,       . ,     1000x1000 ,       : 1  = 1  =  . <br><br>      .      ,       ,        .  ,         ,     10-15  . <br><br>       : <br><br><ol><li>  ,          <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iv/hk/bo/ivhkbo6wfuraf7ccfqsafxuwz44.png" width="500"></div></li><li>   (   -  ) <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zb/6j/1v/zb6j1vbcr_ok_-dnessoj2qgdxk.png" width="500"></div></li><li>   <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ze/na/l8/zenal8v8mt8fbfxqz3ne8xdyt-e.png" width="500"></div></li><li>   <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_k/nf/8k/_knf8kp4cndzcc7u3ldbux2anqg.png" width="500"></div></li><li> ,     <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nq/bp/2v/nqbp2vgeiaca4ydxollwdcxsjk8.png" width="500"></div></li></ol><br>    ,          .     100       ,  .     : <br><br> 1     :    ,  5   .  ,    : ,    .        .      4 : 3           ,   .    . <br><br><div class="spoiler"> <b class="spoiler_title"> BossManagement1</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; using System.Collections; public class BossManagement1 : GlobalFunctions { public float hp = 100f; public float speed = 0.2f; public bool startActivated = false; public bool activated = false; public bool activatedSaw = false; public bool activatedAngle = false; public bool activatedCoroutine = true; private bool active; private float maxhp; public Vector2 target; public Vector2 targetSaw1; public Vector2 targetSaw2; public Vector2 minBorder; public Vector2 maxBorder; public DeadBoss1 deadBoss; public GameObject backGround; public GameObject healthBar; public Transform tr; public Transform sawMain; public Transform saw1; public Transform saw2; public Arrow arrow; public AudioSet setStart; public AudioSet setEnd; public Transform player; public Power playerPower; private Transform bg, hb; private float targethp = 0f; private Vector2 startMove = new Vector2(-20f, 0f); public void Awake() { maxhp = hp; bg = backGround.transform; hb = healthBar.transform; } public void Start() { if (PlayerPrefs.GetString("boss1") == "death") { Dead(false); } } public void FixedUpdate() { if (startActivated &amp;&amp; !activatedCoroutine) { if ((Vector2)tr.position != startMove) { tr.position = Vector2.MoveTowards(tr.position, startMove, speed); saw1.position = Vector2.MoveTowards(saw1.position, startMove, speed); saw2.position = Vector2.MoveTowards(saw2.position, startMove, speed); } else { activatedCoroutine = true; startActivated = false; StartCoroutine(ActivatedOn()); } } if (activated) { if ((Vector2)tr.position != target) { tr.position = Vector2.MoveTowards(tr.position, target, speed); } else { activated = false; sawMain.localScale = new Vector2(0f, 0f); StartCoroutine(TargetRotate()); } } if (activatedSaw) { if ((Vector2)saw1.position != targetSaw1) { saw1.position = Vector2.MoveTowards(saw1.position, targetSaw1, speed); } else { float x = Random.Range(minBorder.x, maxBorder.x); float y = Random.Range(minBorder.y, maxBorder.y); targetSaw1 = new Vector2(x, y); } if ((Vector2)saw2.position != targetSaw2) { saw2.position = Vector2.MoveTowards(saw2.position, targetSaw2, speed); } else { float x = Random.Range(minBorder.x, maxBorder.x); float y = Random.Range(minBorder.y, maxBorder.y); targetSaw2 = new Vector2(x, y); } } if (activatedAngle) { Vector2 dir = player.position - tr.position; float angle = Mathf.Atan2(dir.y, dir.x) * Mathf.Rad2Deg; tr.localEulerAngles = new Vector3(0f, 0f, Mathf.LerpAngle(tr.localEulerAngles.z, angle, 0.1f)); } } public IEnumerator TargetRotate() { yield return new WaitForSeconds(3f + 3f * hp / maxhp); sawMain.localScale = new Vector2(6f, 6f); float x = Random.Range(minBorder.x, maxBorder.x); float y = Random.Range(minBorder.y, maxBorder.y); target = new Vector2(x, y); activated = true; } public IEnumerator ActivatedOn() { yield return new WaitForSeconds(3f); sawMain.localScale = new Vector2(6f, 6f); target = new Vector2(Random.Range(minBorder.x, maxBorder.x), Random.Range(minBorder.y, maxBorder.y)); targetSaw1 = new Vector2(Random.Range(minBorder.x, maxBorder.x), Random.Range(minBorder.y, maxBorder.y)); targetSaw2 = new Vector2(Random.Range(minBorder.x, maxBorder.x), Random.Range(minBorder.y, maxBorder.y)); activatedSaw = true; activated = true; arrow.isActive = true; } public IEnumerator ActivatedCoroutineOff() { yield return new WaitForSeconds(1f); activatedCoroutine = false; activatedAngle = true; } public void Update() { if (active == true) { if (hp != targethp) { float s = Time.fixedDeltaTime / 0.03f * (Time.deltaTime / 0.03f); hp = MoveToward(hp, targethp, speed * s, new Vector2(-0f, maxhp)); } else { active = false; if (targethp == 0f) { Dead(true); } } } UpdateHP(); } public void UpdateHP() { float h = hp / maxhp; bg.localScale = new Vector3(5f, 0.9f, 1f); hb.localScale = new Vector3(4.8f * h, 0.7f, 1f); hb.localPosition = new Vector3(-2.4f + 4.8f * h / 2f, 0f, 0f); } private bool oneTimeMusic = true; public void Damage(float damage) { if (oneTimeMusic == true) { oneTimeMusic = false; deadBoss.StartBoss(); deadBoss.Boom(); setStart.SetMusic(); startActivated = true; StartCoroutine(ActivatedCoroutineOff()); } if (hp != 0f) { targethp = Stable2(hp - damage, 0f, maxhp); speed = speed + damage * 0.02f; active = true; } } public void Dead(bool boom) { active = false; activated = false; activatedSaw = false; startActivated = false; activatedAngle = false; activatedCoroutine = false; backGround.SetActive(false); healthBar.SetActive(false); sawMain.gameObject.SetActive(false); saw1.gameObject.SetActive(false); saw2.gameObject.SetActive(false); setEnd.SetMusic(); arrow.obj.SetActive(false); PlayerPrefs.SetString("boss1", "death"); deadBoss.Dead(tr.position, boom); } public void OnCollisionEnter2D(Collision2D collision) { if (collision.transform.CompareTag("Player")) { Damage(playerPower.power); } } }</code> </pre><br></div></div><br> 2     ,      .    :       ,    .           .     :           : <br><br><ol><li> 2    </li><li> 2   ,     </li><li> 2    ,     </li><li> 2 ,     </li><li> 2 ,      2    </li></ol><br>       ,  :              ,      . <br><br><div class="spoiler"> <b class="spoiler_title"> BossManagement2</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System.Collections; using UnityEngine; public class BossManagement2 : GlobalFunctions { public float hp = 100f; public float speed = 0.5f; public float speedRotate = 0.5f; public int stage = 1; public bool isAlive = true; public bool isActivated = false; public bool isMove = false; public bool isWorkingLaser = true; private float timeStamina = 0f; private float timeRetarget = 0f; public Vector2 region = Vector2.zero; public Vector3 target = Vector3.zero; public GameObject player; public Transform saw; public Transform laser1; public Transform laser2; public Laser laserL1; public Laser laserL2; public Transform laserOffset1; public Transform laserOffset2; public Explosion explosion; public GameObject explosionAsset; public CircleCollider2D trigStart; public BoxCollider2D laserDetected1; public BoxCollider2D laserDetected2; public GameObject saw1; public GameObject saw2; public Transform health; public Transform stamina; public SpriteRenderer srStamina; private Transform pl; private Transform tr; public Transform state; public Laser state1; public Laser state2; public Laser state3; public Laser state4; private Coroutine coroutineStamina; public SpriteRenderer bossBase; public SpriteRenderer laserD1; public SpriteRenderer laserD2; public Gate gateStart; public Gate gateEnd; public GameObject blockWin; public GameObject physicsIn; public GameObject stateLasers; public GameObject expStart; public AudioSet setStart; public AudioClip setEnd; public AudioBase audioBase; public void Awake() { bool isDeath = PlayerPrefs.GetString("boss2") == "death"; blockWin.SetActive(false); if (isDeath) { isAlive = false; gateStart.isReverse = true; gateEnd.isReverse = true; physicsIn.SetActive(false); stateLasers.SetActive(false); expStart.SetActive(false); gameObject.SetActive(false); } else { tr = transform; pl = player.transform; timeStamina = 5.4f / speedRotate / 100f; timeRetarget = 5.4f / speedRotate; saw.localScale = Vector3.zero; stamina.localScale = Vector3.zero; srStamina.color = new Color(0f, 0.5f, 1f, 0f); saw1.SetActive(false); saw2.SetActive(false); LaserDisable(); LaserBlockEnable(); } } public void Update() { if (isAlive) { if (isActivated == true) { switch (stage) { case 1: if (isMove == true) { if (tr.position == target) { isMove = false; RotatePlayer(); saw1.SetActive(true); saw2.SetActive(true); stamina.localScale = Vector3.zero; srStamina.color = new Color(0f, 0.5f, 1f, 1f); if (coroutineStamina != null) { StopCoroutine(coroutineStamina); } coroutineStamina = StartCoroutine(StaminaAnim(timeStamina, 100)); StartCoroutine(Retarget1()); } else { tr.position = Vector2.MoveTowards(tr.position, target, speed); } } break; case 2: if (isMove == true) { if (tr.position == target) { isMove = false; RotatePlayer(); saw.localScale = Vector3.zero; saw1.SetActive(true); saw2.SetActive(true); stamina.localScale = Vector3.zero; srStamina.color = new Color(0f, 0.5f, 1f, 1f); if (coroutineStamina != null) { StopCoroutine(coroutineStamina); } coroutineStamina = StartCoroutine(StaminaAnim(timeStamina, 100)); StartCoroutine(Retarget2()); } else { tr.position = Vector2.MoveTowards(tr.position, target, speed); } } break; case 3: if (isMove == true) { if (tr.position == target) { isMove = false; RotatePlayer(); saw.localScale = Vector3.zero; LaserEnable(); stamina.localScale = Vector3.zero; srStamina.color = new Color(0f, 0.5f, 1f, 1f); if (coroutineStamina != null) { StopCoroutine(coroutineStamina); } coroutineStamina = StartCoroutine(StaminaAnim(timeStamina, 100)); StartCoroutine(Retarget3()); } else { tr.position = Vector2.MoveTowards(tr.position, target, speed); } } break; case 4: if (isMove == true) { if (tr.position == target) { isMove = false; RotatePlayer(); saw.localScale = Vector3.zero; LaserEnable(); stamina.localScale = Vector3.zero; srStamina.color = new Color(0f, 0.5f, 1f, 1f); if (coroutineStamina != null) { StopCoroutine(coroutineStamina); } coroutineStamina = StartCoroutine(StaminaAnim(timeStamina, 100)); StartCoroutine(Retarget4()); } else { tr.position = Vector2.MoveTowards(tr.position, target, speed); } } break; case 5: if (isMove == true) { if (tr.position == target) { isMove = false; RotatePlayer(); saw.localScale = Vector3.zero; LaserEnable(); saw1.SetActive(false); saw2.SetActive(false); stamina.localScale = Vector3.zero; srStamina.color = new Color(0f, 0.5f, 1f, 1f); if (coroutineStamina != null) { StopCoroutine(coroutineStamina); } coroutineStamina = StartCoroutine(StaminaAnim(timeStamina, 100)); StartCoroutine(Retarget5()); } else { tr.position = Vector2.MoveTowards(tr.position, target, speed); } } break; } } else { if (trigStart.enabled == false) { isActivated = true; float musicValue = PlayerPrefs.GetFloat("music"); audioBase.UpSound(0.01f, 5, 0, TypePlaying.Music); explosion.health = 0f; explosion.StartCoroutineTimerOffsetExplosion(); RegionDetected(); LaserDisable(); target = Target(); } } } } public void FixedUpdate() { if (!isMove &amp;&amp; isActivated) { laserOffset1.localEulerAngles = new Vector3(0f, 0f, laserOffset1.localEulerAngles.z + speedRotate); laserOffset2.localEulerAngles = new Vector3(0f, 0f, laserOffset2.localEulerAngles.z + speedRotate); if (isWorkingLaser) { state.localEulerAngles = new Vector3(0f, 0f, state.localEulerAngles.z + speedRotate); } } } public void RotatePlayer() { Vector2 p = pl.position; float angle = Mathf.Atan2(py, px) * Mathf.Rad2Deg; laserOffset1.localEulerAngles = new Vector3(0f, 0f, angle); laserOffset2.localEulerAngles = new Vector3(0f, 0f, angle - 180f); } private Vector3[] posLasers = new Vector3[] { Vector3.zero, Vector3.zero}; public void TriggerLaserDefect(int id) { switch (id) { case 1: state1.active = false; state1.lr1.SetPositions(posLasers); break; case 2: state2.active = false; state2.lr1.SetPositions(posLasers); break; case 3: state3.active = false; state3.lr1.SetPositions(posLasers); break; case 4: state4.active = false; state4.lr1.SetPositions(posLasers); break; } if (!state1.active &amp;&amp; !state2.active &amp;&amp; !state3.active &amp;&amp; !state4.active) { isWorkingLaser = false; state1.active = false; state2.active = false; state3.active = false; state4.active = false; laserL1.active = false; laserL2.active = false; laser1.localPosition = Vector2.zero; laser2.localPosition = Vector2.zero; } } public void OnCollisionEnter2D(Collision2D collision) { if (collision.transform.tag == "Player") { hp = hp - pl.GetComponent&lt;Power&gt;().power; health.localScale = new Vector2(hp / 50f, hp / 50f); stage = 5 - (int)(hp / 25f); if (stage == 4) { LaserBlockDisable(); } if (hp &lt;= 0f &amp;&amp; isAlive == true) { audioBase.LowerSound(0.1f, 50, 0, TypePlaying.Music); audioBase.SetSound(setEnd, 0, 0.8f, TypePlaying.Music, true, 1f); GameObject deadInside = Instantiate(explosionAsset, pl.position, Quaternion.identity); deadInside.GetComponent&lt;Rigidbody2D&gt;().isKinematic = true; deadInside.transform.localScale = new Vector2(2f, 2f); Explosion exp = deadInside.GetComponent&lt;Explosion&gt;(); exp.radius = 2f; exp.health = 0f; exp.timeOffsetExplosion = 3f; exp.StartCoroutineTimerOffsetExplosion(); gateStart.OnTriggerEnter2D(player.GetComponent&lt;Collider2D&gt;()); gateEnd.OnTriggerEnter2D(player.GetComponent&lt;Collider2D&gt;()); PlayerPrefs.SetString("boss2", "death"); blockWin.SetActive(false); gameObject.SetActive(false); } } } public void OnTriggerEnter2D(Collider2D collision) { if (collision.tag == "Player") { blockWin.SetActive(true); trigStart.enabled = false; } } public void LaserEnable() { if (isWorkingLaser) { laserL1.active = true; laserL2.active = true; state1.active = false; state2.active = false; state3.active = false; state4.active = false; } laser1.localPosition = new Vector2(0f, -1f); laser2.localPosition = new Vector2(0f, -1f); return; } public void LaserDisable() { if (isWorkingLaser) { state1.active = true; state2.active = true; state3.active = true; state4.active = true; laserL1.active = false; laserL2.active = false; } laser1.localPosition = Vector2.zero; laser2.localPosition = Vector2.zero; return; } public void LaserBlockEnable() { laserDetected1.enabled = true; laserDetected2.enabled = true; } public void LaserBlockDisable() { laserDetected1.enabled = false; laserDetected2.enabled = false; } public void RegionDetected() { Vector2 result = Vector2.zero; Vector2 pos = pl.position; if (pos.x &gt; -45f &amp; pos.x &lt;= -30f) { result.x = 1; } else if (pos.x &gt; -30f &amp; pos.x &lt; -5f) { result.x = 2; } else if (pos.x &gt;= -5f &amp; pos.x &lt;= 5f) { result.x = 3; } else if (pos.x &gt; 5f &amp; pos.x &lt;= 30f) { result.x = 4; } else if (pos.x &gt;= 30f &amp; pos.x &lt; 45f) { result.x = 5; } if (pos.y &gt; -45f &amp; pos.y &lt;= -30f) { result.y = 1; } else if (pos.y &gt; -30f &amp; pos.y &lt; -5f) { result.y = 2; } else if (pos.y &gt;= -5f &amp; pos.y &lt;= 5f) { result.y = 3; } else if (pos.y &gt; 5f &amp; pos.y &lt;= 30f) { result.y = 4; } else if (pos.y &gt;= 30f &amp; pos.y &lt; 45f) { result.y = 5; } region = result; return; } private readonly Vector2[] aroundCloser = new Vector2[] { new Vector2(2, 2), new Vector2(2, 3), new Vector2(2, 4), new Vector2(3, 2), new Vector2(3, 4), new Vector2(4, 2), new Vector2(4, 3), new Vector2(4, 4) }; public Vector2 Target() { Vector2 result = Vector2.zero; if (region == new Vector2(3, 3)) { region = aroundCloser[Random.Range(0, 8)]; } switch (region.x) { case 1: result.x = Random.Range(-45f, -32f); break; case 2: result.x = Random.Range(-29f, -5f); break; case 3: result.x = Random.Range(-5f, 5f); break; case 4: result.x = Random.Range(5f, 29f); break; case 5: result.x = Random.Range(32f, 45f); break; } switch (region.y) { case 1: result.y = Random.Range(-45f, -32f); break; case 2: result.y = Random.Range(-29f, -5f); break; case 3: result.y = Random.Range(-5f, 5f); break; case 4: result.y = Random.Range(5f, 29f); break; case 5: result.y = Random.Range(32f, 45f); break; } isMove = true; return result; } public IEnumerator StaminaAnim(float time, int count) { yield return new WaitForSeconds(time); float sc = hp * (100f - count) / 5000f; stamina.localScale = new Vector2(sc, sc); if (count &gt; 1) { count = count - 1; coroutineStamina = StartCoroutine(StaminaAnim(time, count)); } } public IEnumerator Retarget1() { yield return new WaitForSeconds(timeRetarget); srStamina.color = new Color(0f, 0.5f, 1f, 0f); RotatePlayer(); saw1.SetActive(false); saw2.SetActive(false); RegionDetected(); target = Target(); } public IEnumerator Retarget2() { yield return new WaitForSeconds(timeRetarget); srStamina.color = new Color(0f, 0.5f, 1f, 0f); RotatePlayer(); saw.localScale = new Vector2(2f, 2f); saw1.SetActive(false); saw2.SetActive(false); RegionDetected(); target = Target(); } public IEnumerator Retarget3() { yield return new WaitForSeconds(timeRetarget); srStamina.color = new Color(0f, 0.5f, 1f, 0f); RotatePlayer(); saw.localScale = new Vector2(2f, 2f); LaserDisable(); RegionDetected(); target = Target(); } public IEnumerator Retarget4() { yield return new WaitForSeconds(timeRetarget); srStamina.color = new Color(0f, 0.5f, 1f, 0f); RotatePlayer(); saw.localScale = new Vector2(2f, 2f); LaserDisable(); RegionDetected(); target = Target(); } public IEnumerator Retarget5() { yield return new WaitForSeconds(timeRetarget); srStamina.color = new Color(0f, 0.5f, 1f, 0f); RotatePlayer(); saw.localScale = new Vector2(2f, 2f); saw1.SetActive(true); saw2.SetActive(true); LaserDisable(); RegionDetected(); target = Target(); } }</code> </pre><br></div></div><br> 3        !     raycast'.       ,   12 raycast',    ,        raycast'.    ,     .   raycast'    ?      ,   2    ,   raycast'  ,         ,    ,   -   .     :      (  ‚Äî       )  ,    ,     .    5         3-4 .        ,          (    )    .        . <br><br>  : <br><br><ol><li>   ,         ,    . </li><li> 2 ,     Lerp     (    )       (      ,  -   ). </li><li> ,       ,   . </li><li> 2 ,          ,   . </li><li> 4 -,    </li></ol><br><div class="spoiler"> <b class="spoiler_title"> BossManagement3</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System.Collections; using UnityEngine; using UnityEngine.SceneManagement; public class BossManagement3 : MonoBehaviour { public float health = 100f; public Vector4[] boxs = new Vector4[0]; public int[] saw1Fields = new int[0]; public int[] saw2Fields = new int[0]; public int[] saw3Fields = new int[0]; public int[] laser1Fields = new int[0]; public int[] laser2Fields = new int[0]; public Transform trBoss; public SpriteRenderer srBoss; public BossTracing3 bt; public Transform saw1; public Transform saw2; public Transform saw3; public Transform laser; public Transform laser1; public Transform laser2; public Transform trap1; public Transform trap2; public Transform trap3; public Transform trap4; public LineRenderer lr1; public LineRenderer lr2; public TrailRenderer trail; public GameObject exp; public GameObject terminal1; public GameObject terminal2; public GameObject LaserTarget; public GameObject LaserMover; public GameObject TrapsMover; public GameObject SawMover; public GameObject SawsAroundMover; public Explosion explosion; public SpriteRenderer sr; public CircleCollider2D cc; public Animator animatorEnd; public bool isMove = false; public bool isMoveSaw1 = false; public bool isMoveSaw2 = false; public bool isMoveSaw3 = false; public bool isMoveLaser1 = false; public bool isMoveLaser2 = false; public bool isMoveTraps = false; public int loadScene = 35; public int fieldPlayer = 0; private bool isActive = true; private float maxHealth; private Vector2 target = Vector2.zero; private Vector2 saw1target = Vector2.zero; private Vector2 saw2target = Vector2.zero; private Vector2 saw3target = Vector2.zero; private Vector2 laser1target = Vector2.zero; private Vector2 laser2target = Vector2.zero; private Vector2 traptarget1 = Vector2.zero; private Vector2 traptarget2 = Vector2.zero; private Vector2 traptarget3 = Vector2.zero; private Vector2 traptarget4 = Vector2.zero; private Vector2 border = new Vector2(47f, 44.5f); private Vector2 borderSaw = new Vector2(46f, 43.5f); private Management m; public GameObject p { get; private set; } private HealthBar hb; private Transform tr; private Power ppl; private int lengthBoxs = 0; private bool isLife = true; public void Awake() { isActive = !(PlayerPrefs.GetString("boss1") == "life" &amp;&amp; PlayerPrefs.GetString("boss2") == "life"); terminal1.SetActive(!isActive); terminal2.SetActive(isActive); trail.enabled = PlayerPrefs.GetString("graphicsquality") != "low"; m = GameObject.FindWithTag("MainCamera").GetComponent&lt;Management&gt;(); lengthBoxs = boxs.Length; maxHealth = health; hb = m.healthBar; p = m.player; tr = p.transform; ppl = m.ppl; float c = health / maxHealth; srBoss.color = new Color(0f, 0f, c); } public void Start() { if (isActive == false) { return; } StartCoroutine(Mover()); fieldPlayer = bt.BoxPos(tr.position); if (fieldPlayer &gt;= 0) { Vector4 r = boxs[saw1Fields[fieldPlayer]]; saw1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[saw2Fields[fieldPlayer]]; saw2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[saw3Fields[fieldPlayer]]; saw3target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[laser1Fields[fieldPlayer]]; laser1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[laser2Fields[fieldPlayer]]; laser2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } else { Vector4 r = boxs[Random.Range(0, lengthBoxs)]; saw1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[Random.Range(0, lengthBoxs)]; saw2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[Random.Range(0, lengthBoxs)]; saw3target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[Random.Range(0, lengthBoxs)]; laser1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[Random.Range(0, lengthBoxs)]; laser2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } TrapMover(); StartCoroutine(Laser1AIM()); StartCoroutine(Laser2AIM()); isMoveSaw1 = true; isMoveSaw2 = true; isMoveSaw3 = true; isMoveLaser1 = true; isMoveLaser2 = true; return; } public void SawMover1() { fieldPlayer = bt.BoxPos(tr.position); if (fieldPlayer &gt;= 0) { Vector4 r = boxs[saw1Fields[fieldPlayer]]; saw1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } else { Vector4 r = boxs[Random.Range(0, lengthBoxs)]; saw1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } isMoveSaw1 = true; } public void SawMover2() { fieldPlayer = bt.BoxPos(tr.position); if (fieldPlayer &gt;= 0) { Vector4 r = boxs[saw2Fields[fieldPlayer]]; saw2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } else { Vector4 r = boxs[Random.Range(0, lengthBoxs)]; saw2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } isMoveSaw2 = true; } public void SawMover3() { fieldPlayer = bt.BoxPos(tr.position); if (fieldPlayer &gt;= 0) { Vector4 r = boxs[saw3Fields[fieldPlayer]]; saw3target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } else { Vector4 r = boxs[Random.Range(0, lengthBoxs)]; saw3target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } isMoveSaw3 = true; } public void LaserMover1() { fieldPlayer = bt.BoxPos(tr.position); if (fieldPlayer &gt;= 0) { Vector4 r = boxs[laser1Fields[fieldPlayer]]; laser1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } else { Vector4 r = boxs[Random.Range(0, lengthBoxs)]; laser1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } StartCoroutine(Laser1AIM()); isMoveLaser1 = true; } public void LaserMover2() { fieldPlayer = bt.BoxPos(tr.position); if (fieldPlayer &gt;= 0) { Vector4 r = boxs[laser2Fields[fieldPlayer]]; laser2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } else { Vector4 r = boxs[Random.Range(0, lengthBoxs)]; laser2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } StartCoroutine(Laser2AIM()); isMoveLaser2 = true; } public void TrapMover() { traptarget1 = new Vector2(Random.Range(-border.x, border.x), Random.Range(-border.y, border.y)); traptarget2 = new Vector2(-traptarget1.x, -traptarget1.y); traptarget3 = new Vector2(-traptarget1.x, traptarget1.y); traptarget4 = new Vector2(traptarget1.x, -traptarget1.y); isMoveTraps = true; } public IEnumerator Laser1AIM() { yield return new WaitForSeconds(0.5f); Vector2 diff = tr.position; float rot_z = Mathf.Atan2(diff.y, diff.x) * Mathf.Rad2Deg + 90f; laser1.rotation = Quaternion.Euler(0f, 0f, rot_z); } public IEnumerator Laser2AIM() { yield return new WaitForSeconds(0.5f); Vector2 diff = tr.position; float rot_z = Mathf.Atan2(diff.y, diff.x) * Mathf.Rad2Deg + 90f; laser2.rotation = Quaternion.Euler(0f, 0f, rot_z); } public IEnumerator Mover() { yield return new WaitForSeconds(7.5f); if (isLife) { Vector2 diff = tr.position; float rot_z = Mathf.Atan2(diff.y, diff.x) * Mathf.Rad2Deg + 90f; laser.rotation = Quaternion.Euler(0f, 0f, rot_z); target = bt.GetPosRaycast(); isMove = true; } } public void Update() { if (isActive == false) { return; } float s = Time.fixedDeltaTime / (0.03f / Time.timeScale); if (isMove) { trBoss.position = Vector2.MoveTowards(trBoss.position, target, s * 0.5f); if (trBoss.position == (Vector3)target) { isMove = false; if (isLife) { StartCoroutine(Mover()); } } } if (isMoveSaw1) { saw1.position = Vector2.MoveTowards(saw1.position, saw1target, s * 0.1f); if (saw1.position == (Vector3)saw1target) { isMoveSaw1 = false; if (isLife) { SawMover1(); } } } if (isMoveSaw2) { saw2.position = Vector2.MoveTowards(saw2.position, saw2target, s * 0.1f); if (saw2.position == (Vector3)saw2target) { isMoveSaw2 = false; if (isLife) { SawMover2(); } } } if (isMoveSaw3) { saw3.position = Vector2.MoveTowards(saw3.position, saw3target, s * 0.1f); if (saw3.position == (Vector3)saw3target) { isMoveSaw3 = false; if (isLife) { SawMover3(); } } } if (isMoveLaser1) { laser1.position = Vector2.Lerp(laser1.position, laser1target, s * 0.1f); if (laser1.position == (Vector3)laser1target) { isMoveLaser1 = false; if (isLife) { LaserMover1(); } } } if (isMoveLaser2) { laser2.position = Vector2.Lerp(laser2.position, laser2target, s * 0.1f); if (laser2.position == (Vector3)laser2target) { isMoveLaser2 = false; if (isLife) { LaserMover2(); } } } if (isMoveTraps) { trap1.position = Vector2.MoveTowards(trap1.position, traptarget1, s * 0.1f); trap2.position = Vector2.MoveTowards(trap2.position, traptarget2, s * 0.1f); trap3.position = Vector2.MoveTowards(trap3.position, traptarget3, s * 0.1f); trap4.position = Vector2.MoveTowards(trap4.position, traptarget4, s * 0.1f); lr1.SetPosition(0, trap1.position); lr1.SetPosition(1, trap2.position); lr2.SetPosition(0, trap3.position); lr2.SetPosition(1, trap4.position); if (trap1.position == (Vector3)traptarget1) { isMoveTraps = false; if (isLife) { TrapMover(); } } } } public void OnCollisionEnter2D(Collision2D collision) { if (collision.gameObject == p) { if (isActive == false) { isActive = true; Start(); } if (isMove == true) { hb.StraightDamage(10f, "Boss3"); } else { health = health - ppl.power; float c = health / maxHealth; srBoss.color = new Color(0f, 0f, c); trail.startColor = srBoss.color; if (health &lt;= 0f) { isLife = false; isMove = false; saw1target = trBoss.position; saw2target = trBoss.position; saw3target = trBoss.position; isMoveSaw1 = true; isMoveSaw2 = true; isMoveSaw3 = true; sr.enabled = false; cc.enabled = false; exp.SetActive(true); explosion.health = 0f; explosion.StartCoroutineTimerOffsetExplosion(); Vector2 diff = trBoss.position; float rot_z = Mathf.Atan2(diff.y, diff.x) * Mathf.Rad2Deg + 90f; laser.rotation = Quaternion.Euler(0f, 0f, rot_z); int fieldBoss = bt.BoxPos(trBoss.position); Vector4 r = boxs[laser1Fields[fieldBoss]]; laser1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[laser2Fields[fieldBoss]]; laser2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); StartCoroutine(Ended()); } } } } public void EndedCoroutine() { if (!isActive) { //Debug.Log("End"); isActive = true; StartCoroutine(Ended()); } } public IEnumerator Ended() { yield return new WaitForSeconds(6.5f); if (hb.healthBarImage.fillAmount != 0f) { animatorEnd.SetBool("isActive", true); StartCoroutine(EndedFunction()); } } public IEnumerator EndedFunction() { yield return new WaitForSeconds(1.5f); if (hb.healthBarImage.fillAmount != 0f) { PlayerPrefs.SetInt("progress", 35); SceneManager.LoadSceneAsync(loadScene); } } public void ControlDamagers(bool lt, bool lm, bool tm, bool sm, bool sam) { LaserTarget.SetActive(lt); LaserMover.SetActive(lm); TrapsMover.SetActive(tm); SawMover.SetActive(sm); SawsAroundMover.SetActive(sam); } }</code> </pre></div></div><br> <i>  </i> <br><br>      ,      ,    .           .       :  25 .     asset store.       freesound.org   . <br><br>         :    5  AudioSource   AudioBase   .       SetSound   , ,  (  )   .       (  )  IEnumerator  ,          . <br><br><div class="spoiler"> <b class="spoiler_title"> AudioBase</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; using System.Collections; public class AudioBase : GlobalFunctions { public AudioSource[] layerSounds = new AudioSource[0]; public GameObject music; private float musicValue, soundValue; private int lengthLayerSounds = 0; private bool soundActive = true; private Coroutine offsetActive; private int lowerSoundCoroutineCounter = 100; private int upSoundCoroutineCounter = 0; public void Awake() { soundActive = PlayerPrefs.GetString("graphicsquality") != "low"; musicValue = PlayerPrefs.GetFloat("music"); soundValue = PlayerPrefs.GetFloat("sound"); lengthLayerSounds = layerSounds.Length; for (int i = 0; i &lt; lengthLayerSounds; i++) { layerSounds[i].enabled = false; } } public void LowerSound(float timer, int upd, int id, TypePlaying typePlaying) { lowerSoundCoroutineCounter = upd; if (typePlaying == TypePlaying.Music) { StartCoroutine(LowerSoundCoroutine(timer, upd, id, musicValue)); } else { StartCoroutine(LowerSoundCoroutine(timer, upd, id, soundValue)); } } public void UpSound(float timer, int upd, int id, TypePlaying typePlaying) { upSoundCoroutineCounter = 0; if (typePlaying == TypePlaying.Music) { StartCoroutine(UpSoundCoroutine(timer, upd, id, musicValue)); } else { StartCoroutine(UpSoundCoroutine(timer, upd, id, soundValue)); } } public IEnumerator LowerSoundCoroutine(float timer, int upd, int id, float volumeSen) { yield return new WaitForSeconds(timer); layerSounds[id].volume = Stable2((layerSounds[id].volume / volumeSen - timer) * volumeSen, 0f, 1f); if (lowerSoundCoroutineCounter &gt; 1) { StartCoroutine(LowerSoundCoroutine(timer, upd, id, volumeSen)); lowerSoundCoroutineCounter -= 1; } } public IEnumerator UpSoundCoroutine(float timer, int upd, int id, float volumeSen) { yield return new WaitForSeconds(timer); layerSounds[id].volume = Stable2((layerSounds[id].volume / volumeSen + timer) * volumeSen, 0f, 1f); if (upSoundCoroutineCounter &lt; upd) { StartCoroutine(UpSoundCoroutine(timer, upd, id, volumeSen)); upSoundCoroutineCounter += 1; } } public void UpdateSound() { if (soundActive) { float time = Time.timeScale; for (int i = 0; i &lt; lengthLayerSounds; i++) { AudioSource audioSource = layerSounds[i]; if (audioSource.enabled == true) { audioSource.pitch = time; } } } } public void SetSound(AudioClip audioClip, int layerSound, float volume, TypePlaying typePlaying, bool loop, float time) { StartCoroutine(SetSoundTime(audioClip, layerSound, volume, typePlaying, loop, time)); } public IEnumerator SetSoundTime(AudioClip audioClip, int layerSound, float volume, TypePlaying typePlaying, bool loop, float time) { yield return new WaitForSeconds(time); SetSound(audioClip, layerSound, volume, typePlaying, loop); } public void SetSound(AudioClip audioClip, int layerSound, float volume, TypePlaying typePlaying, bool loop) { if (volume == 0f) { return; } if (soundActive) { AudioSource audioSource = layerSounds[layerSound]; audioSource.enabled = true; audioSource.clip = audioClip; audioSource.loop = loop; if (typePlaying == TypePlaying.Sound) { audioSource.volume = soundValue * volume; } else { audioSource.volume = musicValue * volume; } audioSource.Play(); if (offsetActive != null) { StopCoroutine(offsetActive); offsetActive = null; } if (!loop) { offsetActive = StartCoroutine(Offet(layerSound, audioClip.length, audioSource)); } } } public IEnumerator Offet(int layerSound, float length, AudioSource audioSource) { yield return new WaitForSeconds(length); if (audioSource.clip == layerSounds[layerSound].clip) { AudioSource audioSource2 = layerSounds[layerSound]; audioSource2.Stop(); audioSource2.enabled = false; } } }</code> </pre><br></div></div><br>    Tramp ()    :      ,    ,   .                 ,      .        ,      . <br><br> <i></i> <br><br> ,     .     2 :        ,    .     (,  ,      ). <br><br>    3 :        32.     :              .    32  :   ,         (   ).        ,     3 .        ,     .  ,  . <br><br>   4: , ,   .    2 :     3 .    : <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text">  ,  3        .     ,           (    ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ic/7y/5q/ic7y5qybvgsqkntsirrs0vo2x50.png" width="250"></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text">  Obrigada <br>     <br>      <br>       <br>     <br>   <br>   </div></div></div></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text">  ,  3        .      (¬´¬ª ),         ( ). <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zg/1y/ns/zg1yns6xsbmhbqw8ecailcmj9nc.png" width="250"></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text">    <br>      <br>    <br>         <br>   -1 </div></div></div></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text">  ,  3       .            ,  ,    ‚Ä¶ <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dt/up/xp/dtupxp-eviq15ssct_eyj-926dq.png" width="250"></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text">  <br>     <br> ,     <br>      <br>    <br>     <br>     <br>   </div></div></div></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text">  ,  3         .     ,     -   (!)    . ( ,    ) <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"> - <br> ,  -   <br> ,      <br>     <br> ,  ,    <br>    ‚Ä¶ <br> , , ,  ,   ... </div></div></div></div><br>      ?        - .     . ,    ¬´  ¬ª              . <br><br> <i></i> <br><br>       ,          , , ,   :   .      ,      (    ,  ).  ,             npc.        : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cp/wz/jn/cpwzjnsg2h0mgb72x1aj7hrrzu8.png" width="300"></div><br>  ,        ,       ,    .     4   ,  ,      .           . <br><br>  ,          .        (          ).     :     ,            . <br><br>      :   2-3       40-50 .        ,            2-3 ,     (   )     .           - 160   . <br><br>   :      ,           .             ,    ,      .       . <br><br> ,     ?   ,    Portal,          ( ). ,      :         ,       (   ).  -  ( ) ,          : <br><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text">  : <br> , ,   (3 ) <br>  (1 ) <br> ,  RLIS (2 ) <br><br>  : <br><br> [1]   . [3]    :   ,   ,  ,  ,    ..      . [3]       ,    ,        ,   ([2]   , ,           ).  4) <br><br> [4]         ,   . [5]     ,      . [6]          . [6]  ,    . [7]          .  (5) <br><br> [8]            :   . [9]      (- )      . [10]        (       ). (3) <br><br> [11]     . [12]   ,     ,  ,   . [13]           . [13]    ,           . (3) <br><br> [15]       ([14] ‚Äî          ,      ,      ). [15]   (     )             ([16]            ).  4) <br><br> [17]  . [18]     ¬´¬ª. [18]            . [19]-       .  4) <br><br> [20]      ¬´¬ª. [21]   ,         . [22]      ,    . (3) <br><br> [23]    . [24]          . [25]     ¬´ ¬ª. (3) <br><br> [26]    ,       . [27]        ,  -  ,   . [28]       ¬´ ¬ª. [29]      .  4) <br><br> [30] -   ( ?)            (     ,    ). [31]      . [32] ,          ([33]    ,         ),      - ,        . [34]     . [35]          ,  . [36]      (        ):     10  (10  = 1 )   . [X]- (  )        ,     (    2   1   ?). [37]   2 . (9) <br></div></div><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text">  (): <br><br> 1) {}    ¬´¬ª ,      .      ,       .   -   ,       . <br><br> 2) {} RLIS (reasonable likeness in simulation) ‚Äî      .     . RLIS   ( )       ‚Äî     . <br><br> 3) {}  RLIS     100  : , , , ,   ..    ,   , ,    .    ,       . <br><br> 4) {} ,        .     ,     ,    ,   ,       .    magnum opus      . <br><br> 5) {ARSotLotC}        ,       .    ,           .      ,      . <br><br> 6) {} -!!! -   ,       .    ,      ,     ,     .        ,  ,       ,      .        2 :      . <br><br> 7) {}       ,    backup       ,    .         :     ,       . ,          ,         . <br><br> 8) {}    .    ,              .    ,   ,         ,         (    ). <br><br> 9) {}   ,      ,   -.            ?  .          ,   .  ,    .   ‚Ä¶ <br><br> 10) {}    -   ,         .                  .      , ‚Ä¶ <br><br> 11) {ARSotLotC}      .  ,    ¬´¬ª   , ,    .            ,   ‚Ä¶              . <br><br> 12) {}      ,      ¬´¬ª    .  .         ¬´¬ª,   .          .      . <br><br> 13) {}               ,       .     ,            .      ,         .                 . <br><br> 14) {}      ,     ,       (             ).  ‚Äî   ,         .   :      ,           . <br><br> 15) {}  ‚Äî            .    ,         .           .        ,       ,           . <br><br> 16) {}     ?        ,          .                 . <br><br> 17) {}     .       .      ,   ¬´¬ª.         .       ,      ,       . <br><br> 18) {}       ¬´¬ª.  , ?    ,          ,          . <br><br> 19) {}    ¬´¬ª     ,      .      ,     ,   ,       ,     .     .                  . <br><br> 20) {}   ''           ''. ,   , ''      '',          ,      . <br><br> 21) {}  ''       :       ,        ''.  ,     .     . <br><br> 22) {ARSotLotC}          :    ,     .        ,         . <br><br> 23) {}       ,           .                    ' '.          ,            . <br><br> 24) {}     ,   ,      .           ,   .   ,          . <br><br> 25) {}  .         ,  -  .      ,    ,   '  '. <br><br> 26) {}  .   ,      .                 .      ' '    ! <br><br> 27) {}   ' '   ,      .              .     :    ,    ,     . <br><br> 28) {ARSotLotC} - &lt; &gt;     .             .        .  ,    . <br><br> 29) {ARSotLotC}         .   ? ,         (- ,          )    ARSotLotC (Automatic Recording System of the Logs of the Complex). <br><br> 30) {ARSotLotC}   ¬´¬ª  ,        .          ,     ,   .  -    ,  backup .    ,    ,         . <br><br> 31) {ARSotLotC}  :      .     ,       .           .          backup. <br><br> 32) {ARSotLotC}   .         .     ,   .           . <br><br> 33) {ARSotLotC}                  (       backup').          . <br><br> 34) {ARSotLotC}    ,      .    ,      ,     10     .      ,     . Ps:        ,           ,  . <br><br> 35.1) {}   .  .     ' '  .     ,      ,       ''.  ,          -   ,    .            ' '. <br><br> 35.2)                                                   <br></div></div><br> <i> </i> <br><br>    ‚Äî  ,        .      ,      2-3  (   ,       900  ,              GetChild()  ). <br><br>        ,      .       .        ,     . ,     .     : <br><br><pre> <code class="plaintext hljs">public class VelocityRotate : MonoBehaviour { public float rotate = 0f; public bool oneTime = true; private bool active = true; public void OnTriggerEnter2D(Collider2D collision) { if (active == true) { if (oneTime == true) { active = false; } Rigidbody2D rb = collision.GetComponent&lt;Rigidbody2D&gt;(); Vector2 vel = rb.velocity; rb.velocity = RotateVector(vel, rotate); } } public Vector2 RotateVector(Vector2 a, float offsetAngle) { float power = Mathf.Sqrt(ax * ax + ay * ay); float angle = Mathf.Atan2(ay, ax) * Mathf.Rad2Deg - 90f + offsetAngle; return Quaternion.Euler(0, 0, angle) * Vector2.up * power; } }</code> </pre><br>   ,     ?     : <br><br><pre> <code class="plaintext hljs">public class VelocityRotate : MonoBehaviour { //      public float rotate = 0f;//  public bool oneTime = true;//  private bool active = true;//  public void OnTriggerEnter2D(Collider2D collision) { if (active == true) { if (oneTime == true)//   { active = false; } //   Rigidbody2D rb = collision.GetComponent&lt;Rigidbody2D&gt;(); Vector2 vel = rb.velocity; rb.velocity = RotateVector(vel, rotate); } } public Vector2 RotateVector(Vector2 a, float offsetAngle)//   { float power = Mathf.Sqrt(ax * ax + ay * ay);//  float angle = Mathf.Atan2(ay, ax) * Mathf.Rad2Deg - 90f + offsetAngle; //    offset' return Quaternion.Euler(0, 0, angle) * Vector2.up * power; //        } }</code> </pre><br>       -      !         ,         . , ,   -    .  -,        ,  -,     -              -     .      :      ,       ,            . <br><br> <i>  </i> <br><br>   . !          ().    ,          (          ): <br><br><div class="spoiler"> <b class="spoiler_title">GB2 Checklist</b> <div class="spoiler_text"> : <br> // ‚Äî   <br> \ ‚Äî    <br><br> //1)     ,  ,  <br> //2)   :  <br> //3)        <br> //4)     TipsGamePlay <br> //5) ( )     <br> //6) 0:      <br> //7) 1:    () <br> //8)      <br> //9) 2:  2      <br> //10)                <br> //11) 4:    <br> //12)     layer Player <br> //13) 7:    ()      <br> //14) 8:           ( 1) <br> //15) 8:      <br> \16)         (    ) <br> \17) 8:           zero <br> //18)        <br> //19) 1:        <br> //20)    ,   <br> //21)        <br> //22)    timescale=0 <br> //23) 6:         <br> //24) 0:   <br> //25)     <br> //26) 7:    <br> //27) 7:    <br> //28)  AspectRatio <br> \29)      <br> //30)    <br> //31)    &lt;EXfgpy)b&gt;    //32) 7:    -  <br> //33)   ,       <br> //34) 9:     <br> //35) 9:      <br> //36) 'loop'   <br> //37) 10:   <br> //38) 11:   () <br> //39) 11:    <br> //40) 11:      <br> //41) 11:   <br> //42) 11:      <br> //43) 11:         <br> //44)    ( ) <br> /45) 12:    <br> \46)  Raycast   <br> \47)   ( static, dynamic, kinematic) <br> //48)     (next level, next start, next end) <br> \49) 1:          elevatorsave = 0 <br> \50)   offset angle,            <br> //51) 2:       <br> //52)    <br> //53) 7:       <br> //54)  next save <br> //55)      Dynamic Graph <br> //56) 11:        (    ) <br> 57) 11:   <br> //58) 9:    () <br> //59) 11: (  )    <br> //60) 12:   (   2 .     active   ,  .         . <br> 61) :     <br> //62) :  -   <br> //63)  :        <br> 64)    <br> //65)      (. ) <br> //66)      <br> //67)     HealthBar <br> 68) 0:          <br> //69)      localposition  position <br> 70) 14:    bool isPresentation <br> //71) 17:         2  4 <br> 72)    () <br> \73)      <br> //74)        <br> //75)      layer,     <br> //76)      <br> //77) 2:      1     <br> \78)     (     ) <br> //79)          <br> //80) 3:  ,         <br> //81)           <br> //82) 6:      ,      <br> //83) 6:     1  <br> //84) 6:       <br> //85) 7:    40.      . <br> //86)        <br> //87) 9:        <br> //88) 32:      <br> //89)  offsetAngle  elevator <br> //90) 11:     <br> //91)    (  ) <br> //92)      <br> //93)    <br> //94)    <br> //95) 13:     <br> //96) 15:      <br> /97)    3            isshotmode <br> //98) 17:       <br> //99) 18:  ,         <br> //100) 19:       (   ) <br> /101) 20:          <br> \102)    Tramp <br> //103) 20:         <br> \104)         <br> //105) 11:    ui   <br> //106)   text         arial <br> \107)              <br> //108)          <br> //109) 3:           <br> //110) 3:        <br> //111) 3:      ,    <br> //112)    ,     <br> //113)     () <br> //114) 4:     <br> //115)       (    ) <br> //116)       () <br> //117)  pointsAnimation  basicAnimation <br> //118) 7:   <br> //119) 9:      <br> //120)         AudioBase <br> //121)     pointsAnimation       <br> //122)       ,   ( ) <br> //123) 13:    HealthBar <br> //124) 13:  ,      <br> //125) 14:      kinematic (. ) <br> //126) 14:     <br> //127) 14:      ,    <br> //128)    velocityField   (     ,        ) <br> //129) 16:     velocityField <br> //130) 22:      <br> //131) 22:     <br> \132) 25:       <br> //133) 26:   <br> //134) 27:   <br> \135)       (  ) <br> //136)       <br> //137) :          <br> //138)    ( ) <br> //139)            <br> //140) 8:   <br> //141)      (  1.5-2,      -oneshot' <br> \142)  lerp         <br> //143)      ,  ,        (    ,         ) <br> //144) 22:       <br> //145) 11:          <br> //146) 11:      <br> //147) 11:     <br> //148)    <br> //149)  ¬´Home¬ª  ¬´Menu¬ª <br> //150)      <br> //151)       <br> //152)       <br> \153)        (  healthEnd) <br> //154) :       <br> //155) 33:    ,      <br> //156) 15:     (   0.1) <br> //157) 15:      velocityfield          healthbar <br> //158)     <br> //159)   basicAnimation (27) <br> //160)   (18, 27) <br> //161)     <br> \162) 19: -      <br> //163)     ( trigger  collision) <br> //164) 20:     50  250 <br> //165)      shotmode <br> //166) 27:        <br> //167) 28:     <br> //168) 17:    <br> //169) tag  boss3 <br> \170)   (  ,    ) <br> //171)    35 <br> //172)  :   ,  600    ¬´I'll come back¬ª <br> //173) 33:        <br><br> //174)      <br> //175) HealthBar       <br> //176)     (     damage- <br> //177) 27:         <br><br>    <br><br> 0) (0) <br> 1) (2) <br> 2) (2) <br> 3) (1) <br> 4) (1) <br> 5) (1) <br> 6) (1) <br> 7) (1) <br> 8) (2) <br> 9) (1) <br> 10) (0) <br> 11) (1) <br> (13) <br> 12) (0) <br> 13) (2) <br> 14) (2) <br> 15) (0) <br> 16) (0) <br> 17) (1) <br> 18) (1) <br> 19) (3) <br> 20) (0) <br> 21) (3) <br> 22) (1) <br> (13) <br> 23) (1) <br> 24) (1) <br> 25) (0) <br> 26) (0) <br> 27) (0) <br> 28) (3) <br> 29) (1) <br> 30) (2) <br> 31) (0) <br> 32) (0) <br> 33) (1) <br> 34) (1) <br> (10) <br><br></div></div><br>     ,   .   ,     ,  ,       .   ,        .    ,  ,      ,          . <br><br>       ? <br><br><ol><li>         .   ,           .    2       3-4 .     ,     ,    :               10 .        ,                  .             . </li><li>        ,    .   ,        ,     ,   ,       . </li><li>        .       ,   ¬´ ¬ª   60%     .       ,    . </li></ol><br> <i></i> <br><br> -         30 .        :    Google Translate,   .       ,     ,         .    :      18 ,        ,  google ,       10 :   ,     (       ). <br><br>   -        .  ,            : <br><br><div class="spoiler"> <b class="spoiler_title"> StringLanguageMinimize</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">[System.Serializable] public class StringLanguageMinimize { public string english = ""; public string spanish = ""; public string italian = ""; public string german = ""; public string russian = ""; public string french = ""; public string portuguese = ""; public string korean = ""; public string chinese = ""; public string japan = ""; public string GetString() { string ret = ""; switch (PlayerPrefs.GetString("language")) { case "english": ret = english; break; case "spanish": ret = spanish; break; case "italian": ret = italian; break; case "german": ret = german; break; case "russian": ret = russian; break; case "french": ret = french; break; case "portuguese": ret = portuguese; break; case "korean": ret = korean; break; case "chinese": ret = chinese; break; case "japan": ret = japan; break; } return ret; } }</code> </pre><br></div></div><br>       : <br><div class="spoiler"> <b class="spoiler_title"> Terminal</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">[System.Serializable] public class StringLanguage { [TextArea] public string english = ""; [TextArea] public string spanish = ""; [TextArea] public string italian = ""; [TextArea] public string german = ""; [TextArea] public string russian = ""; [TextArea] public string french = ""; [TextArea] public string portuguese = ""; [TextArea] public string korean = ""; [TextArea] public string chinese = ""; [TextArea] public string japan = ""; public string GetString() { string ret = ""; switch (PlayerPrefs.GetString("language")) { case "english": ret = english; break; case "spanish": ret = spanish; break; case "italian": ret = italian; break; case "german": ret = german; break; case "russian": ret = russian; break; case "french": ret = french; break; case "portuguese": ret = portuguese; break; case "korean": ret = korean; break; case "chinese": ret = chinese; break; case "japan": ret = japan; break; } return ret; } }</code> </pre><br></div></div><br>     : <br><br><div class="spoiler"> <b class="spoiler_title"> Tips Input</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; public class TipsInput : MonoBehaviour { public int idTips = 0; public bool isPress2Read = true; public bool oneTime = true; private bool active = true; public GameObject[] copys; private Data data; private Press2Read p2r; private TipsInput ti; private void Awake() { data = GameObject.FindWithTag("MainCamera").GetComponent&lt;Data&gt;(); p2r = GameObject.FindWithTag("Press2Read").GetComponent&lt;Press2Read&gt;(); ti = GetComponent&lt;TipsInput&gt;(); } public void OnCollisionEnter2D(Collision2D collision) { if (collision.transform.CompareTag("Player")) { if (isPress2Read == false &amp;&amp; active == true) { Disable(); data.SetDialoge(idTips); if (copys.Length != 0) { for (int i = 0; i &lt; copys.Length; i++) { copys[i].GetComponent&lt;TipsInput&gt;().Disable(); } } } else if (isPress2Read == true) { p2r.Active(ti); } } } public void OnCollisionExit2D(Collision2D collision) { if (isPress2Read == true) { p2r.DeActive(); } } public void Disable() { if (oneTime == true) { active = false; } return; } }</code> </pre><br></div></div><br>   Data: <br><br><div class="spoiler"> <b class="spoiler_title">Data</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; using UnityEngine.UI; using System.Collections; public class Data : GlobalFunctions { public Dialoge[] dialoges; public DeadPhrases[] deadPhrases; public GamePlay[] gameplay; [Space] public Tips tips; public AudioBase audioBase; public TipsGamePlay gamePlayTips; public Image slowmobonus; public Text fpsText; public float scaleTips = 1f; public float scaleGameUI = 1f; public float scaleSlowMo = 1f; private float speed = 0f; private float target = 1f; private float timeDuration = 1f; private int updFPS = 0; public void Awake() { scaleTips = scaleGameUI = scaleSlowMo = 1f; slowmobonus.color = new Color(0f, 0f, 0f, 0f); } public void Start() { StartCoroutine(SecFPSUpdate()); } public void SetDialoge(int id) { if (dialoges.Length != 0) { tips.SetActiveTrue(dialoges[id].dialogeStrings, dialoges[id].name); } } public void FalseP2R() { tips.SetFalse(); } public string GetDeadPhrase(string typeDead) { int idType = -1; for (int i = 0; i &lt; deadPhrases.Length; i++) { if (deadPhrases[i].typeDead == typeDead) { idType = i; break; } } if (idType == -1) { return typeDead; } int rand = Random.Range(0, deadPhrases[idType].deadPhrases.Length); return deadPhrases[idType].deadPhrases[rand].GetString(); } public string GetDeadPhrase2() { string ret = ""; switch (PlayerPrefs.GetString("language")) { case "english": ret = "Tap to continue"; break; case "spanish": ret = "Pulse para continuar"; break; case "italian": ret = "Tocca per continuare"; break; case "german": ret = "Tippen Sie, um fortzufahren"; break; case "russian": ret = "  "; break; case "french": ret = "Appuyez sur pour continuer"; break; case "portuguese": ret = "Clique para continuar"; break; case "korean": ret = "Í≥ÑÏÜçÌïòÎ†§Î©¥ ÌÉ≠ÌïòÏÑ∏Ïöî"; break; case "chinese": ret = "ÁÇπÊåâÂç≥ÂèØÁªßÁª≠"; break; case "japan": ret = "„Çø„ÉÉ„Éó„Åó„Å¶Á∂öË°å„Åó„Åæ„Åô"; break; } return ret; } public void PauseGameUI(float time) { scaleGameUI = time; Update(); audioBase.UpdateSound(); } public void SetGamePlayTips(int id) { if (id == -1) { gamePlayTips.SetActiveTrueSaved(); } else { gamePlayTips.SetActiveTrue(gameplay[id]); } } public void SlowMo(float timeDuration2, float setSlowMo, float speed2) { speed = speed2; target = setSlowMo; timeDuration = timeDuration2; Update(); audioBase.UpdateSound(); } public void SlowMo(float timeDuration2) { scaleSlowMo = 0.1f; float sb = (1f - scaleSlowMo) * 0.3921569f; slowmobonus.color = new Color(0f, 0f, 0f, sb); Update(); audioBase.UpdateSound(); } public IEnumerator EndAnim(float timeDuration) { yield return new WaitForSeconds(timeDuration); End(); } public void End() { scaleSlowMo = 1f; float sb = (1f - scaleSlowMo) * 0.3921569f; slowmobonus.color = new Color(0f, 0f, 0f, sb); Update(); audioBase.UpdateSound(); } public void End2(float timeDuration2) { if (timeDuration2 == 0) { End(); return; } StartCoroutine(EndAnim(timeDuration2)); } private void Update() { Time.timeScale = scaleTips * scaleSlowMo * scaleGameUI; Time.fixedDeltaTime = 0.03f * scaleSlowMo * scaleTips; updFPS = updFPS + 1; return; } private IEnumerator SecFPSUpdate() { yield return new WaitForSeconds(1f); fpsText.text = "FPS: " + updFPS; updFPS = 0; StartCoroutine(SecFPSUpdate()); } }</code> </pre><br></div></div><br>    Tips,    : <br><br><div class="spoiler"> <b class="spoiler_title"> Tips</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System.Collections; using UnityEngine.UI; using UnityEngine; public class Tips : GlobalFunctions { public Data data; public Press2Read p2r; public GameUI gameUI; public GameObject obj; public AudioClip setClip; public Text nameText; public Text txt; private int textID = 0; private int textsID = 0; private AudioBase audioBase; private DialogeString textActive; private DialogeString[] textsActive; private bool isMass = false; [TextArea] public string end = ""; [TextArea] public string endPast = ""; public void Start() { audioBase = GameObject.FindWithTag("MainCamera").GetComponent&lt;AudioBase&gt;(); data.scaleTips = 1f; obj.SetActive(false); txt.text = ""; } public void SetActiveTrue(DialogeString text, StringLanguageMinimize name) { data.scaleTips = 0.1f; audioBase.layerSounds[0].volume /= 10f; obj.SetActive(true); nameText.text = name.GetString(); gameUI.pauseButton.SetActive(false); textActive = text; isMass = false; StartCoroutine(TimerFalse()); } public void SetActiveTrue(DialogeString[] texts, StringLanguageMinimize name) { data.scaleTips = 0.1f; audioBase.layerSounds[0].volume /= 10f; obj.SetActive(true); nameText.text = name.GetString(); gameUI.pauseButton.SetActive(false); textsActive = texts; isMass = true; StartCoroutine(TimersFalse()); } public IEnumerator TimerFalse(float time = 0.02f) { yield return new WaitForSecondsRealtime(time); string ds = textActive.dialogeString.GetString(); if (textID &lt; ds.Length &amp;&amp; ds != end) { audioBase.SetSound(setClip, 1, 0.5f, TypePlaying.Sound, false); end = end + ds.Substring(textID, 1); txt.text = endPast + end; textID = textID + 1; if (textID + 1 != ds.Length &amp;&amp; ds != end) { if (ds.Substring(textID + 1, 1) == ",") { StartCoroutine(TimersFalse(0.1f)); } else if (ds.Substring(textID + 1, 1) == ".") { StartCoroutine(TimersFalse(0.15f)); } else if (ds.Substring(textID + 1, 1) == "?") { StartCoroutine(TimersFalse(0.15f)); } else if (ds.Substring(textID + 1, 1) == ".") { StartCoroutine(TimersFalse(0.15f)); } else { StartCoroutine(TimersFalse()); } } else { StartCoroutine(TimersFalse()); } } else { endPast = txt.text; if (textActive.isSkip) { if (textActive.skipOffset == 0f) { SetActiveFalse(); } else { IsSkip(textActive.skipOffset); } } } } public IEnumerator TimersFalse(float time = 0.02f) { yield return new WaitForSecondsRealtime(time); string ds = textsActive[textsID].dialogeString.GetString(); if (textID &lt; ds.Length &amp;&amp; ds != end) { audioBase.SetSound(setClip, 1, 0.5f, TypePlaying.Sound, false); end = end + ds.Substring(textID, 1); txt.text = endPast + end; textID = textID + 1; string ds1 = textsActive[textsID].dialogeString.GetString(); if (textID + 1 != ds1.Length &amp;&amp; ds1 != end) { if (ds1.Substring(textID + 1, 1) == ",") { StartCoroutine(TimersFalse(0.1f)); } else if (ds1.Substring(textID + 1, 1) == ".") { StartCoroutine(TimersFalse(0.15f)); } else if (ds1.Substring(textID + 1, 1) == "?") { StartCoroutine(TimersFalse(0.15f)); } else if (ds1.Substring(textID + 1, 1) == "!") { StartCoroutine(TimersFalse(0.15f)); } else { StartCoroutine(TimersFalse()); } } else { StartCoroutine(TimersFalse()); } } else { endPast = txt.text; if (textsActive[textsID].isSkip) { if (textsActive[textsID].skipOffset == 0f) { SetActiveFalse(); } else { IsSkip(textsActive[textsID].skipOffset); } } } } public IEnumerator IsSkip(float time) { yield return new WaitForSecondsRealtime(time); SetActiveFalse(); } public void SetFalse() { obj.SetActive(false); gameUI.pauseButton.SetActive(true); end = ""; endPast = ""; txt.text = ""; textID = textsID = 0; data.scaleTips = 1f; audioBase.layerSounds[0].volume *= 10f; } public void SetActiveFalse() { if (isMass == false) { if (textActive.dialogeString.GetString() != end) { end = textActive.dialogeString.GetString(); if (textActive.isSkip) { SetActiveFalse(); } } else { obj.SetActive(false); gameUI.pauseButton.SetActive(true); end = ""; data.scaleTips = 1f; audioBase.layerSounds[0].volume *= 10f; } } else { if (textsActive[textsID].dialogeString.GetString() != end) { if (textsActive[textsID].isStep == true) { txt.text = end = textsActive[textsID].dialogeString.GetString(); if (textsActive[textsID].isSkip) { SetActiveFalse(); } } else { end = textsActive[textsID].dialogeString.GetString(); txt.text = endPast + end; } } else { if (textsID != textsActive.Length - 1) { textsID = textsID + 1; textID = 0; end = ""; if (textsActive[textsID].isStep == true) { endPast = ""; } StartCoroutine(TimersFalse()); } else { obj.SetActive(false); gameUI.pauseButton.SetActive(true); p2r.UnTap(); end = ""; endPast = ""; txt.text = ""; textID = textsID = 0; data.scaleTips = 1f; audioBase.layerSounds[0].volume *= 10f; } } } } }</code> </pre><br></div></div><br>  ,        ,     IEnumerator      (      ). <br><br> <i></i> <br><br>        1 .     :    ,    4    (     ),       .  ,    7 ,      -   .     ,   ¬´¬ª      . <br><br>      ,    ,      ,    .    :     ,    Reddit,       ,       ..     : <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kj/u-/dd/kju-ddrnggd-val9oytmh3b9-pi.jpeg" width="400"></div><br><br> <i></i> <br><br> ,    ,     ,    IT  3 !     16- ,    ,    13 ,    :      .      -    . <br><br>     ?   . , ,    -         ,    .        ,   ,      .                   .     ,        <br><br>        .     ,      .         ,    .   ,        ,     :         unity. <br><br>    - .       , ,  . <br><br> PS:   - : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ia/cm/se/iacmseb355qijfw6g2lsexdrtow.png" width="300"></div><br>      : <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Whsn9B5t6Hc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt468363/">https://habr.com/ru/post/pt468363/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt468341/index.html">Shell de nuvem do Azure no terminal do Windows</a></li>
<li><a href="../pt468343/index.html">Jeff Bezos: "Indo para o espa√ßo para o bem da terra"</a></li>
<li><a href="../pt468345/index.html">GitHub lan√ßa seus tent√°culos no gerenciamento de CI / CD e artefatos</a></li>
<li><a href="../pt468347/index.html">MetricKit. An√°lise de desempenho de aplicativos iOS</a></li>
<li><a href="../pt468351/index.html">Microestrutura de mercado e sele√ß√£o adversa</a></li>
<li><a href="../pt468367/index.html">Amazon anuncia plano de aquecimento global</a></li>
<li><a href="../pt468369/index.html">Como eu criei o "WildMAN" - uma par√≥dia de muitos jogos de 8 bits e o portei recentemente para o Android</a></li>
<li><a href="../pt468377/index.html">8 hist√≥rias sobre o interior da China. O que n√£o √© mostrado aos estrangeiros</a></li>
<li><a href="../pt468379/index.html">Intelig√™ncia artificial de uso geral. TK, status atual, perspectivas</a></li>
<li><a href="../pt468381/index.html">De volta ao futuro? Borracha pendente Quantum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>