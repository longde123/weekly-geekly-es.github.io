<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí¶ üë©üèΩ‚Äçüî¨ üåª Suite √† la rencontre "Nouvelles fonctionnalit√©s de PostgreSQL 11" üîº üõµ üçÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, nous allons parler des fonctionnalit√©s les plus importantes de PostgreSQL 11. Pourquoi seulement √† leur sujet - parce que tout le monde n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Suite √† la rencontre "Nouvelles fonctionnalit√©s de PostgreSQL 11"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/414031/">  Aujourd'hui, nous allons parler des fonctionnalit√©s les plus importantes de PostgreSQL 11. Pourquoi seulement √† leur sujet - parce que tout le monde n'a pas besoin de certaines fonctionnalit√©s, nous avons donc choisi les plus populaires. <br><br><h3>  Table des mati√®res </h3><br><img src="https://habrastorage.org/webt/3l/ef/wk/3lefwko0funvsqwyvgcaqtf7ory.png" align="right" width="300"><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Compilation Jit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partitionnement</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Indices</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Indices de couverture</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SP GiST</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Performances</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WAL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sauvegarde et r√©plication</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pour dba</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ex√©cution parall√®le</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Optimiseurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctions de fen√™tre</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modifications de la recherche en texte int√©gral</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Json (b) et texte int√©gral</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Proc√©dures PL / *</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pgbench</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Am√©liorations PSQL</a> </li></ul><a name="habracut"></a><br><a name="1"></a><h3>  Compilation Jit </h3><br>  PostgreSQL a enfin introduit la compilation JIT, c'est-√†-dire la compilation de requ√™tes en code binaire.  Pour ce faire, compilez PostgreSQL avec le support de la compilation JIT <code>(Compile time 1 (--with-llvm))</code> .  Dans le m√™me temps, la machine doit avoir une version LLVM non inf√©rieure √† 3.9. <br><br>  Qu'est-ce qui peut acc√©l√©rer JIT? <br><br><ul><li>  Requ√™tes avec la clause WHERE, c'est-√†-dire tout ce qui vient apr√®s ce mot-cl√©.  Ce n'est pas toujours n√©cessaire, mais l'occasion est utile. </li><li>  Calcul de la liste cible: dans la terminologie PostgreSQL, c'est tout ce qui est entre select et from. </li><li>  Agr√©gats. </li><li>  Convertir des enregistrements d'une vue √† une autre (Projection).  Par exemple, lorsque vous appliquez la jointure √† deux tables, le r√©sultat est un nouveau tuple contenant des champs des deux tables. </li><li>  Tuple se d√©formant.  L'un des probl√®mes de toute base de donn√©es, au moins minuscule, relationnel, est de savoir comment obtenir un champ √† partir d'un enregistrement sur disque.  Apr√®s tout, il peut y avoir null, ils ont des enregistrements diff√©rents et en g√©n√©ral, ce n'est pas l'op√©ration la moins ch√®re. </li></ul><br>  <code>Compile time 2</code> signifie que JIT n'est pas utilis√©.  Dans PostgreSQL, il y a un moment de planification des requ√™tes, lorsque le syst√®me d√©cide ce qui vaut JIT et ce qui ne l'est pas.  √Ä ce stade, il ex√©cute les JIT, puis l'ex√©cuteur s'ex√©cute tel quel. <br><br>  JIT est rendu enfichable.  Par d√©faut, cela fonctionne avec LLVM, mais vous pouvez connecter n'importe quel autre JIT. <br><br><img src="https://habrastorage.org/webt/hm/pk/lk/hmpklkbpxsi1qzqyvyx3drcl6_y.png" width="600"><br><br>  Si vous avez compil√© PostgreSQL sans prise en charge JIT, la toute premi√®re configuration ne fonctionne pas.  Options mises en ≈ìuvre pour les d√©veloppeurs, il existe des param√®tres pour les fonctions JIT individuelles. <br><br>  Le prochain point subtil est li√© √† jit_above_cost.  JIT lui-m√™me n'est pas gratuit.  Par cons√©quent, PostgreSQL utilise par d√©faut l'optimisation JIT si le co√ªt d'une requ√™te d√©passe 100 000 perroquets conditionnels, dans lesquels l'explication, l'analyse, etc. sont mesur√©es.  Cette valeur est choisie au hasard, alors faites-y attention. <br><br>  Mais pas toujours apr√®s avoir activ√© JIT, tout fonctionne imm√©diatement.  Habituellement, tout le monde commence √† exp√©rimenter avec JIT en utilisant le tableau select * from o√π la requ√™te id = 600 et ils √©chouent.  Probablement, il est n√©cessaire de compliquer en quelque sorte la demande, puis tout le monde g√©n√®re une base de donn√©es g√©ante et compose la demande.  En cons√©quence, PostgreSQL repose sur les capacit√©s du disque, il lui manque la capacit√© des tampons et caches partag√©s. <br><br>  Voici un exemple compl√®tement abstrait.  Il y a 9 champs nuls avec des fr√©quences diff√©rentes, de sorte que vous pouvez remarquer l'effet de la d√©formation du tuple. <br><br> <code>select i as x1, <br> case when i % 2 = 0 then i else null end as x2, <br> case when i % 3 = 0 then i else null end as x3, <br> case when i % 4 = 0 then i else null end as x4, <br> case when i % 5 = 0 then i else null end as x5, <br> case when i % 6 = 0 then i else null end as x6, <br> case when i % 7 = 0 then i else null end as x7, <br> case when i % 8 = 0 then i else null end as x8, <br> case when i % 9 = 0 then i else null end as x9 <br> into t <br> from generate_series(0, 10000000) i; <br> <br> vacuum t; <br> analyze t;</code> <br> <br>  PostgreSQL a beaucoup de possibilit√©s, et pour voir les avantages de JIT, d√©sactivez les deux premi√®res lignes afin de ne pas interf√©rer et r√©initialisez les seuils. <br><br> <code>set max_parallel_workers=0; <br> set max_parallel_workers_per_gather=0; <br> set jit_above_cost=0; <br> set jit_inline_above_cost=0; <br> set jit_optimize_above_cost=0;</code> <br> <br>  Voici la demande elle-m√™me: <br><br> <code>set jit=off; <br> explain analyze <br> select count(*) from t where <br> sqrt(pow(x9, 2) + pow(x8,2)) &lt; 10000; <br> <br> set jit=on; <br> explain analyze <br> select count(*) from t where <br> sqrt(pow(x9, 2) + pow(x8,2)) &lt; 10000;</code> <br> <br>  Et voici le r√©sultat: <br><br> <code>Planning Time: 0.71 ms <br> Execution Time: <b>1986.323</b> ms <br> <br> VS <br> <br> Planning Time: 0.060 ms <br> JIT: <br> Functions: 4 <br> Generation Time: 0.911 ms <br> Inlining: true <br> Inlining Time: 23.876 ms <br> Optimization: true <br> Optimization Time: 41.399 ms <br> Emission Time: 21.856 ms <br> Execution Time: <b>949.112</b> ms</code> <br> <br>  JIT a contribu√© √† acc√©l√©rer la demande de moiti√©.  La planification du temps est √† peu pr√®s la m√™me chose, mais c'est probablement le r√©sultat de la mise en cache de PostgreSQL, alors ignorez-le. <br><br>  En r√©sum√©, il a fallu environ 80 ms √† la compilation JIT.  Pourquoi JIT n'est-il pas gratuit?  Avant d'ex√©cuter la demande, vous devez la compiler, ce qui prend √©galement du temps.  Et trois ordres de grandeur de plus que la planification.  Pas un plaisir cher, mais il est payant en raison de la dur√©e de l'ex√©cution. <br><br>  De cette fa√ßon, vous pouvez utiliser JIT, bien que ce ne soit pas toujours b√©n√©fique. <br><br><a name="2"></a><h3>  Partitionnement </h3><br>  Si vous avez fait attention au partitionnement dans PostgreSQL, vous avez probablement remarqu√© qu'il a √©t√© fait l√†-bas pour le show.  La situation s'est l√©g√®rement am√©lior√©e dans la version 10, lorsqu'une d√©claration d√©clarative des partitions (sections) est apparue.  En revanche, tout est rest√© le m√™me √† l'int√©rieur et a fonctionn√© √† peu pr√®s de la m√™me mani√®re que dans les versions pr√©c√©dentes, c'est-√†-dire mauvais. <br>  √Ä bien des √©gards, ce probl√®me a √©t√© r√©solu par le module pg_pathman, qui a permis de travailler avec des sections et de les couper au moment optimal au moment de l'ex√©cution. <br><br>  Dans la version 11, le partitionnement est grandement am√©lior√©: <br><br><ul><li>  Tout d'abord, la table de partition peut avoir une cl√© primaire, qui doit inclure la cl√© de partition.  En fait, il s'agit soit d'une cl√© semi-primaire, soit d'une demi-cl√© primaire.  Malheureusement, vous ne pouvez pas y cr√©er de cl√© √©trang√®re.  J'esp√®re que cela sera corrig√© √† l'avenir. </li><li>  De plus, il est d√©sormais possible de partitionner non seulement par plage, mais √©galement par liste et par hachage.  Le hachage est assez primitif, le reste de l'expression est pris pour lui. </li><li>  Lors de la mise √† jour, la ligne se d√©place entre les sections.  Auparavant, vous deviez √©crire un d√©clencheur, mais maintenant cela se fait automatiquement. </li></ul><br>  La grande question est: combien de sections puis-je avoir?  Honn√™tement, avec un grand nombre de sections (des milliers et des dizaines de milliers), la fonctionnalit√© ne fonctionne pas bien.  Pg_pathman fait mieux. <br><br>  √âgalement cr√©√© des sections par d√©faut.  Encore une fois, dans pg_pathman, vous pouvez cr√©er automatiquement des sections, ce qui est plus pratique.  Ici, tout ce qui n'a pu √™tre pouss√© quelque part tombe dans la section.  Si dans un vrai syst√®me pour faire cela par d√©faut, alors apr√®s un certain temps, vous obtenez un tel g√¢chis, que vous tourmentez pour ratisser. <br><br>  PostgreSQL 11 est d√©sormais en mesure d'optimiser le partitionnement si deux tables sont jointes par une cl√© de partition et que les sch√©mas de partitionnement correspondent.  Ceci est contr√¥l√© par un param√®tre sp√©cial, qui est d√©sactiv√© par d√©faut. <br><br>  Vous pouvez calculer des agr√©gats pour chaque section s√©par√©ment, puis additionner.  Enfin, vous pouvez cr√©er un index sur la table partitionn√©e parente, puis des index locaux sur toutes les tables qui y sont connect√©es seront cr√©√©s. <br><br>  Dans la section ¬´Quoi de neuf¬ª, une chose merveilleuse est mentionn√©e - la possibilit√© de jeter des sections lors de l'ex√©cution d'une demande.  V√©rifions comment cela fonctionne.  Le r√©sultat est un tel tableau: <br><br><img src="https://habrastorage.org/webt/pd/yq/og/pdyqogkeovn-af_egj5u8wlszne.png" width="500"><br><br>  Nous faisons un type et un tableau de deux colonnes avec une cl√© primaire, avec une grande colonne s√©rie, ins√©rons les donn√©es.  Nous cr√©ons la deuxi√®me table, qui sera partitionn√©e et sera une copie de la premi√®re.  Ajoutez la cl√© primaire √† la table partitionn√©e. <br><br><img src="https://habrastorage.org/webt/in/5h/gr/in5hgrummalku8i2gfizbjbt3hm.png" width="500"><br><br>  Le tableau comprendra deux types d'entr√©es: ¬´nounous femmes¬ª et ¬´conducteurs hommes¬ª.  Et il y aura une conductrice.  Nous faisons deux sections, divisons par liste, ajoutons la cl√© primaire et ins√©rons toutes les donn√©es de la table dans laquelle tout cela est g√©n√©r√©.  Le r√©sultat √©tait compl√®tement inint√©ressant: <br><br><img src="https://habrastorage.org/webt/r5/st/ax/r5staxao_opewadzu9wavch_w6w.png"><br><br>  Faites attention √† la demande.  Nous s√©lectionnons tout dans une table non partitionn√©e, nous nous connectons √† une table partitionn√©e.  Nous prenons un petit morceau et choisissons un seul type, ils en passent par un.  Nous indiquons que la colonne oss doit avoir une valeur.  Il s'av√®re qu'une s√©lection de pilotes solides. <br><br>  Lors de l'ex√©cution, nous d√©sactivons sp√©cifiquement la parall√©lisation, car PostgreSQL 11 par d√©faut parall√©lise tr√®s activement les requ√™tes plus ou moins complexes.  Si nous regardons le plan d'ex√©cution (expliquer l'analyse), alors on peut voir que le syst√®me a ajout√© les donn√©es dans les deux sections: dans la nounou et dans les chauffeurs, bien que les nounous n'√©taient pas l√†.  Il n'y a eu aucun appel au tampon.  Temps pass√©, condition utilis√©e, bien que PostgreSQL puisse tout comprendre.  Autrement dit, la d√©claration d'√©limination de partition ne fonctionne pas tout de suite.  Peut-√™tre que dans les versions suivantes, cela sera corrig√©.  Dans ce cas, le module pg_pathman dans ce cas fonctionne sans probl√®me. <br><br><a name="3"></a><h3>  Indices </h3><br><ul><li>  Optimisation des ench√®res de mani√®re monotone, c'est-√†-dire b-tree.  Tout le monde sait que lorsque vous ins√©rez des donn√©es √† croissance monotone, cela ne s'av√®re pas tr√®s rapide.  Maintenant, PostgreSQL est capable de mettre en cache la page de fin d'une mani√®re sp√©ciale et de ne pas aller de la racine √† l'insertion.  Cela acc√©l√®re consid√©rablement le travail. </li><li>  PostgreSQL 10 a permis d'utiliser un index de hachage car il a commenc√© √† utiliser WAL (√©criture anticip√©e du journal).  Auparavant, nous avons obtenu la valeur, d√©verrouill√© la page, renvoy√© la valeur.  Pour la valeur suivante, vous deviez √† nouveau bloquer la page, revenir, d√©verrouiller, etc.  Maintenant, le hachage est devenu beaucoup plus rapide.  Il vous permet de bloquer une page √† la fois pour r√©cup√©rer un enregistrement √† partir d'un index de hachage, retourner toutes les valeurs √† partir de l√† et le d√©verrouiller.  Maintenant, il est impl√©ment√© pour HASH, GiST et GIN.  √Ä l'avenir, cela sera probablement impl√©ment√© pour SP-GiST.  Mais pour BRIN avec sa logique min / max cela ne peut pas √™tre fait en principe. </li><li>  Si vous aviez l'habitude de cr√©er des index fonctionnels, la mise √† jour HOT (Heap Only Tuple) √©tait effectivement d√©sactiv√©e.  Lorsqu'un enregistrement est mis √† jour dans PostgreSQL, une nouvelle copie est r√©ellement cr√©√©e, ce qui n√©cessite de coller dans tous les index qui se trouvent dans la table afin que la nouvelle valeur pointe vers le nouveau tuple.  Une telle optimisation a √©t√© mise en ≈ìuvre depuis longtemps: si la mise √† jour ne change pas les champs qui ne sont pas inclus dans les index, et qu'il y a de l'espace libre sur la m√™me page, alors les index ne sont pas mis √† jour, et dans l'ancienne version de tuple, un pointeur vers la nouvelle version est plac√©.  Cela vous permet de r√©duire quelque peu la gravit√© du probl√®me avec les mises √† jour.  Cependant, une telle optimisation ne fonctionnait pas du tout si vous aviez des index fonctionnels.  Dans PostgreSQL 11, il a commenc√© √† fonctionner.  Si vous avez cr√©√© un index fonctionnel et mis √† jour un tuple qui ne change pas ce dont d√©pend l'index fonctionnel, la mise √† jour HOT fonctionnera. </li></ul><br><a name="4"></a><h3>  Indices de couverture </h3><br>  Cette fonctionnalit√© a √©t√© impl√©ment√©e par PostgresPro il y a trois ans, et pendant tout ce temps, PostgreSQL a essay√© de l'ajouter.  Les index de couverture signifient que vous pouvez ajouter des colonnes suppl√©mentaires √† l'index unique, directement dans le tuple d'index. <br><br>  Pourquoi?  Tout le monde aime la num√©risation index√©e uniquement pour son travail rapide.  Pour cela, des indices ¬´couvrant¬ª conditionnellement sont construits: <br><br><img src="https://habrastorage.org/webt/ep/s7/vf/eps7vfc5hddmnsu6occowc250kw.png" width="600"><br><br>  Mais en m√™me temps, vous devez maintenir l'unicit√©.  Par cons√©quent, deux index sont en cours de construction, √©troits et larges. <br>  L'inconv√©nient est que lorsque vous appliquez le vide, l'insertion ou la mise √† jour √† une table, vous devez mettre √† jour les deux index.  L'insertion dans un index est donc une op√©ration lente.  Et l'indice de couverture ne permettra de g√©rer qu'un seul indice. <br><br>  Certes, il a certaines limites.  Plus pr√©cis√©ment, les avantages qui peuvent ne pas √™tre imm√©diatement compris.  Les colonnes c et d du premier index de cr√©ation ne doivent pas n√©cessairement √™tre des types scalaires pour lesquels un index b-tree est d√©fini.  Autrement dit, ils n'ont pas n√©cessairement une comparaison plus ou moins.  Il peut s'agir de points ou de polygones.  La seule chose est que le tuple doit √™tre inf√©rieur √† 2,7 Kb, car il n'y a pas de grillage dans l'index, mais vous pouvez rentrer dans ce qui ne peut pas √™tre compar√©. <br><br>  Cependant, √† l'int√©rieur de l'index avec ces colonnes couvertes garanties, aucun calcul n'est effectu√© lors de la recherche.  Cela devrait √™tre fait par un filtre qui se trouve au-dessus de l'index.  D'une part, pourquoi ne pas le calculer √† l'int√©rieur de l'index, d'autre part, il s'agit d'un appel de fonction suppl√©mentaire.  Mais tout n'est pas aussi effrayant qu'il n'y para√Æt. <br><br>  Eh bien, en plus, vous pouvez ajouter ces colonnes couvertes √† la cl√© primaire. <br><br><a name="5"></a><h3>  SP GiST </h3><br>  Peu de gens utilisent cet indice car il est assez sp√©cifique.  N√©anmoins, il est devenu possible de stocker en elle pas tout √† fait ce qui a √©t√© ins√©r√©.  Cela fait r√©f√©rence √† l'index avec perte, la compression.  Prenons l'exemple des polygones.  Au lieu de cela, une bo√Æte englobante est plac√©e dans l'index, c'est-√†-dire le rectangle minimum qui contient le polygone souhait√©.  Dans ce cas, nous repr√©sentons le rectangle comme un point dans un espace √† quatre dimensions, puis nous travaillons avec le quad3 classique, dans un espace √† quatre dimensions. <br><br>  Le SP-GiST a √©galement introduit l'op√©ration "recherche de pr√©fixe".  Il retourne vrai si une ligne est le pr√©fixe d'une autre.  Ils l'ont pr√©sent√© non seulement comme √ßa, mais pour le bien d'une telle demande avec le support de SP-GiST. <br><br> <code>SELECT * FROM table WHERE c ^@ ‚Äûabc‚Äú</code> <br> <br>  Dans b-tree, il y a une limite de 2,7 Ko par ligne, mais pas SP-GiST.  Certes, PostgreSQL a une limitation: une seule valeur ne peut pas d√©passer 1 Go. <br><br><a name="6"></a><h3>  Performances </h3><br><ul><li>  <b>Un scan d'index bitmap uniquement est apparu</b> .  Il fonctionne de la m√™me mani√®re que l'analyse d'index classique, sauf qu'il ne peut garantir aucune commande.  Par cons√©quent, il n'est applicable que pour certains agr√©gats comme count (*), car le bitmap n'est pas en mesure de transf√©rer des champs de l'index vers l'ex√©cuteur.  Il ne peut que signaler le fait d'un dossier qui remplit les conditions. </li><li>  La prochaine innovation est la <b>mise √† jour de la carte de l'espace libre lors de l'application du vide</b> .  Malheureusement, aucun des d√©veloppeurs de syst√®mes travaillant avec PostgreSQL ne pense qu'il est n√©cessaire de supprimer √† la fin du tableau, sinon des trous, de l'espace non allou√© apparaissent.  Pour suivre cela, nous avons impl√©ment√© FSM, ce qui nous permet de ne pas agrandir la table, mais d'ins√©rer le tuple dans les vides.  Auparavant, cela se faisait avec le vide, mais √† la fin.  Et maintenant, le vide est capable de le faire dans le processus, et dans les syst√®mes fortement charg√©s, il aide √† garder la taille de la table sous contr√¥le. </li><li>  <b>Possibilit√© d'ignorer l'analyse d'index lors de l'ex√©cution sous vide</b> .  Le fait est que tous les index PostgreSQL, selon la th√©orie des bases de donn√©es, sont appel√©s secondaires.  Cela signifie que les index sont stock√©s loin de la table; les pointeurs y m√®nent.  Le scan d'index uniquement vous permet de ne pas faire ce saut sur des pointeurs, mais de le prendre directement depuis l'index.  Mais le vide, qui supprime les enregistrements, ne peut pas les consulter dans l'index et d√©cider de les supprimer ou non, simplement parce qu'il n'y a pas de telles donn√©es dans l'index.  Par cons√©quent, le vide est toujours effectu√© en deux passes.  Tout d'abord, il parcourt la table et d√©couvre ce qu'il doit supprimer.  Ensuite, il va aux index attach√©s √† cette table, supprime les enregistrements qui se r√©f√®rent aux trouv√©s, revient √† la table et supprime ce qu'il allait faire.  Et l'√©tape de passage aux indices n'est pas toujours requise. <br><br>  Si, depuis le dernier vide, il n'y a pas eu de suppression ou de mise √† jour, vous n'avez aucun enregistrement mort, vous n'avez pas besoin de les supprimer.  Dans ce cas, vous ne pouvez pas acc√©der √† l'index.  Il existe des subtilit√©s suppl√©mentaires, b-tree ne supprime pas ses pages imm√©diatement, mais en deux passes.  Par cons√©quent, si vous avez supprim√© un grand nombre de donn√©es dans le tableau, vous devez effectuer un vide.  Mais si vous voulez lib√©rer de l'espace dans les indices, passez l'aspirateur deux fois. <br><br>  Quelqu'un sera surpris, quel est ce tableau dans lequel il n'y a pas eu de suppression ou de mise √† jour?  En fait, beaucoup y font face, ne pense tout simplement pas.  Ce ne sont que des tableaux √† ajouter, o√π, par exemple, des journaux sont ajout√©s.  Chez eux, l'enl√®vement est extr√™mement rare.  Et cela √©conomise consid√©rablement la dur√©e de vide / autovacuum, r√©duit la charge sur le disque, l'utilisation de caches et ainsi de suite. </li><li>  <b>Engagez simultan√©ment des transactions concurrentielles</b> .  Ce n'est pas une innovation, mais une am√©lioration.  Maintenant, PostgreSQL d√©tecte qu'il va valider maintenant et retarde la validation de la transaction en cours, attendant le reste des validations.  Veuillez noter que cette fonction a peu d'effet si vous avez un petit serveur avec 2 √† 4 c≈ìurs. </li><li>  <b>postgres_fdw (wrappers de donn√©es √©trang√®res)</b> .  FDW est un moyen de connecter une source de donn√©es externe pour qu'elle ressemble √† un v√©ritable post-Congr√®s.  postgres_fdw vous permet de connecter une table d'une instance voisine √† votre instance, et elle ressemblera presque √† une vraie.  D√©sormais, l'une des restrictions de mise √† jour et de suppression a √©t√© supprim√©e.  PostgreSQL peut souvent deviner que vous devez envoyer des donn√©es brutes.  La fa√ßon d'ex√©cuter la demande de jointure est assez simple: nous l'ex√©cutons sur notre machine, nous retirons la table de l'instance √† l'aide de FDW, d√©couvrons la cl√© primaire id que nous devons supprimer, puis appliquons la mise √† jour et / ou la suppression, c'est-√†-dire les donn√©es que nous allons et venons .  Maintenant, c'est possible.  Bien s√ªr, si les tables sont sur des machines diff√©rentes, ce n'est pas si facile, mais FDW vous permet de faire effectuer des op√©rations √† la machine distante, et nous avons juste attendu. </li><li>  <b>toast_tuple_target</b> .  Il y a des situations o√π les donn√©es d√©passent l√©g√®rement les limites apr√®s lesquelles il est n√©cessaire de griller, mais en m√™me temps, le grillage de ces valeurs n'est pas toujours agr√©able.  Supposons que vous ayez une limite de 90 octets et que vous en ayez besoin de 100. Vous devez d√©marrer le toast pour 10 octets, les ajouter s√©par√©ment, puis lorsque vous s√©lectionnez ce champ, vous devez acc√©der √† l'index de toast, savoir o√π se trouvent les donn√©es n√©cessaires, aller √† la table de toasts, recueillir et donner. </li></ul><br>  Maintenant, avec l'aide d'un r√©glage fin, vous pouvez modifier ce comportement pour la base de donn√©es enti√®re ou une table distincte afin que ces petites sorties ne n√©cessitent pas l'utilisation de toast.  Mais vous devez comprendre ce que vous faites, sans cela, rien ne fonctionnera. <br><br><a name="7"></a><h3>  WAL </h3><br><ul><li>  WAL (Write ahead log) est un journal d'√©criture anticip√©e.  La taille du segment WAL est d√©sormais d√©finie dans initdb.  Dieu merci, pas lors de la compilation. </li><li>  La logique a √©galement chang√©.  Auparavant, l'ensemble des segments WAL √©tait enregistr√© √† partir de l'avant-dernier point de contr√¥le, et maintenant √† partir du dernier.  Cela peut r√©duire consid√©rablement la quantit√© de donn√©es stock√©es.  Mais si vous avez une base de donn√©es de 1 To et TPS = 1, c'est-√†-dire une demande par seconde, alors vous ne verrez pas la diff√©rence. </li></ul><br><a name="8"></a><h3>  Sauvegarde et r√©plication </h3><br><ul><li>  <b>Tronquer est apparu dans la r√©plication logique</b> .  C'√©tait la derni√®re des op√©rations DML qui ne se refl√©tait pas dans la r√©plication logique.  Maintenant r√©fl√©chi. </li><li>  <b>Un message sur la pr√©paration est apparu dans la r√©plication logique</b> .  Vous pouvez maintenant intercepter la transaction de pr√©paration, une validation en deux phases dans la r√©plication logique.  Ceci est mis en ≈ìuvre pour la construction de clusters - h√©t√©rog√®nes, homog√®nes, √©clat√©s et non ombr√©s, multima√Ætre et ainsi de suite. </li><li>  <b>Exception des tables temporaires et non enregistr√©es de pg_basebackup</b> .  Beaucoup se sont plaints que pg_basebackup inclut les tables list√©es.  Et en les excluant, nous r√©duisons la taille de la sauvegarde.  Mais √† condition que vous utilisiez des tables temporaires et non enregistr√©es, sinon cette option vous sera inutile. </li><li>  <b>Contr√¥le Checksumma dans la r√©plication en streaming (pour les tables)</b> .  Cela vous permet de comprendre ce qui est arriv√© √† votre r√©plique.  Jusqu'√† pr√©sent, la fonction n'est impl√©ment√©e que pour les tables. </li><li>  <b>Il y a eu une promotion des positions des emplacements de r√©plication</b> .  Comme toujours, vous ne pouvez avancer que vers l'arri√®re, uniquement s'il y a un WAL.  De plus, vous devez tr√®s bien comprendre ce que vous en faites et pourquoi.  √Ä mon avis, il s'agit davantage d'une option de d√©veloppement, mais ceux qui utilisent la r√©plication logique pour certaines applications exotiques peuvent en profiter. </li></ul><br><a name="9"></a><h3>  Pour dba </h3><br><ul><li>  <b>Modifier la table, ajouter une colonne, non null par d√©faut X</b> , √©crire la table enti√®re.  Il y a un petit suppl√©ment pour cela: la valeur par d√©faut est stock√©e s√©par√©ment.  Si vous choisissez un tuple et avez besoin de cette colonne, PostgreSQL est alors oblig√© de suivre un chemin de codage suppl√©mentaire pour extraire une valeur temporaire, la remplacer par tuple et vous la donner.  N√©anmoins, on peut vivre avec. </li><li>  <b>Vide / analyse</b> .  Auparavant, vous ne pouviez appliquer le vide ou analyser qu'√† une base de donn√©es enti√®re ou √† une seule table.  Maintenant, il est possible de le faire sur plusieurs tables, avec une seule commande. </li></ul><br><a name="10"></a><h3>  Ex√©cution parall√®le </h3><br><ul><li>  <b>Construction parall√®le d'index b-tree</b> .  Dans la version 11, il est devenu possible d'int√©grer des index b-tree dans plusieurs travailleurs.  Si vous avez une tr√®s bonne machine, de nombreux disques et de nombreux c≈ìurs, vous pouvez cr√©er des index en parall√®le, ce qui promet une augmentation notable des performances. </li><li>  <b>Hachage d'une connexion parall√®le √† l'aide d'une table de hachage partag√©e pour les ex√©cuteurs</b> .    ,           -.   ,     .   - ,     .     . </li><li>  , <b>      union, create table as, select  create materialized view!</b> </li><li> - <b>   (limit)   </b> .    . </li></ul><br>    : <br><br> <code>alter table usr reset (parallel_workers) <br> create index on usr(lower((so).occ)) ‚Äî 2  <br> alter table usr set (parallel_workers=2) <br> create index on usr(upper((so).occ)) ‚Äî 1.8 </code> <br> <br>     parallel worker.        .     16    4  (    )      2 .,    ‚Äî 1,8 .     ,   ,     .  ,         . <br><br>     : <br><br> <code>explain analyze <br> select u1.* from usr u, usr1 u1 where <br> u.id=u1.id+0</code> <br> <br>     ,      . , user ‚Äî   ,    .     .    ,      ,   . <br><br>     ,   PostgreSQL 11           . <br><br><img src="https://habrastorage.org/webt/a4/si/tw/a4sitw7cyqsulcovvmv--yueczs.png"><br><br>    1425 ,  1,5 .    1,4 .  2  .  ,   9.6   : 1      ‚Äî  1 .,   2   1 .    ,    10    tuple.    11    .       :      user,   batch,    x-scan      append   . <br><br>    : <br><br><img src="https://habrastorage.org/webt/7f/rx/2h/7frx2hwdbaxaq4asujz7aembelq.png"><br><br>   .         211 ,   702 .   ,    510     1473.    ,      2  . <br><br>     parallel hash join.       .     ‚Äî 4.     ,     . <br><br>   parallel index scan    .     batch  .  Qu'est-ce que cela signifie?        hash join,         .  user    .        ,  parallel hash,   . <br><br>     1 .  ,       OLAP-,  OLTP  .    OLTP  ,      . <br><br><a name="11"></a><h3>  </h3><br>      . <br><br><ul><li>       .   ,            .      ,    ¬´¬ª   ¬´¬ª,     index scan,     .    (highly skewed data),         ,    .      .    ,    ,    . </li><li>       ¬´¬ª,   . </li></ul><br><a name="12"></a><h3> Window- </h3><br>     SQL:2011,      . <br><br><a name="13"></a><h3>     </h3><br>   ,      ,    . ,   ,    ,  ,    ,    . <br><br>   websearch,     .      ,     .        ,   . <br><br> <code># select websearch_to_tsquery('dog or cat'); <br> ---------------------- <br> 'dor' | 'cat' <br> # select websearch_to_tsquery('dog -cat'); <br> ---------------------- <br> 'dor' &amp; !'cat' <br> # select websearch_to_tsquery('or cat'); <br> ---------------------- <br> 'cat'</code> <br> <br>   ‚Äî dog or cat ‚Äî   . Websearch      .     |  ,       .    ‚Äúor cat‚Äù.   ,   .    websearch  ‚Äúor‚Äù  .  ,    -,    . <br><br> Websearch ‚Äî     .       :        ,   .     ,   . <br><br><a name="14"></a><h3> Json(b)   </h3><br>  10-     ,   11-     .    json  json(b),   tsvector.   ( json(b))  -  .      ,    ,   ,  bull, numeric, string, .     . <br><br> <code># select jsonb_to_tsvector <br> ('{"a":"texts", "b":12}', '"string"'); <br> ------------------- <br> 'text':1 <br> # select jsonb_to_tsvector <br> ('{"a":"texts", "b":12}', '["string", "numeric"]'); <br> ------------------- <br> '12':3 'text':1</code> <br> <br>     json(b),        .      ,   ,   ,   . <br><br><a name="15"></a><h3> PL/*  </h3><br>     . <br><br> <code>CREATE PROCEDURE transaction_test1() <br> LANGUAGE plpgsql <br> AS $$ <br> BEGIN <br> FOR i IN 0..9 LOOP <br> INSERT INTO test1 (a) VALUES (i); <br> IF i % 2 = 0 THEN <br> COMMIT; <br> ELSE <br> ROLLBACK; <br> END IF; <br> END LOOP; <br> END <br> $$; <br> CALL transaction_test1();</code> <br> <br>      call,       ,         .        .     .      select, insert   . <br><br>    ,    ,   PostgreSQL    .    Perl, Python, TL  PL/pgSQL.    Perl    sp begin,         . <br><br> PL/pgSQL    :    ,    . <br><br><a name="16"></a><h3> pgbench </h3><br>     pgbench  ICSB bench ‚Äî ,   ,       .    if,     ,     .  case,       - .   <code>--init-steps</code> ,    ,   . <br><br>         random-seed.   zipfian- .    / ‚Äî   ,      .   -    ,      ,  - ,  . <br><br> ,  ,    - . <br><br><a name="17"></a><h3>  PSQL </h3><br>  ,    PSQL,        .    exit  quit. <br><br><ul><li>   ‚Äî    copy,      2 <sup>32</sup> .  copy      :      2 <sup>32</sup> - . ,     2 <sup>31</sup>  2 <sup>32</sup> copy     .    64-  ,      2 <sup>64</sup> . </li><li>  POSIX  :   NaN <sup>0</sup> = 1  1 <sup>NaN</sup> = 1. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414031/">https://habr.com/ru/post/fr414031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414019/index.html">Solution universelle pour UITableViewRowAction et UIContextualAction</a></li>
<li><a href="../fr414023/index.html">Demandez √† Ethan: √† quelle vitesse la vie aurait-elle pu appara√Ætre dans l'univers?</a></li>
<li><a href="../fr414025/index.html">Les employeurs suivent les ordinateurs, les voyages aux toilettes et maintenant aussi les √©motions; Votre patron vous suit-il?</a></li>
<li><a href="../fr414027/index.html">Mes amis peuvent-ils √™tre consid√©r√©s comme de vrais amis?</a></li>
<li><a href="../fr414029/index.html">Une lumi√®re myst√©rieuse autour d'une √©toile nouvellement form√©e et ce qu'en pensent les astronomes</a></li>
<li><a href="../fr414037/index.html">Une fois dans une entreprise HFT ...</a></li>
<li><a href="../fr414039/index.html">Contes de nuages</a></li>
<li><a href="../fr414043/index.html">Analyse des tables de routage, ou pourquoi un ing√©nieur r√©seau Python</a></li>
<li><a href="../fr414047/index.html">Comment fabriquer une √©chelle Jacob puissante √† partir d'un transformateur micro-ondes de vos propres mains</a></li>
<li><a href="../fr414049/index.html">Les principaux jeux de l'E3 2018: Fallout 76, Metro Exodus, Doom Eternal et autres</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>