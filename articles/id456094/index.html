<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏻 🗓️ 🃏 Kami membaca lembar data 2: SPI pada STM32; Pengatur waktu PWM dan interupsi pada STM8 👃 🌘 🏕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bagian pertama, saya mencoba memberi tahu penghobi elektronik yang tumbuh dari celana Arduino bagaimana dan mengapa mereka harus membaca lembar d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami membaca lembar data 2: SPI pada STM32; Pengatur waktu PWM dan interupsi pada STM8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/456094/"><p><img src="https://habrastorage.org/webt/zz/sh/fd/zzshfdfytuphbmlregcazfpxo2a.jpeg"></p><br><p>  Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama,</a> saya mencoba memberi tahu penghobi elektronik yang tumbuh dari celana Arduino bagaimana dan mengapa mereka harus membaca lembar data dan dokumentasi lain untuk mikrokontroler.  Teksnya ternyata besar, jadi saya berjanji untuk menunjukkan contoh-contoh praktis dalam artikel terpisah.  Yah, dia menyebut dirinya kargo ... </p><br><p>  Hari ini saya akan menunjukkan cara menggunakan lembar data untuk menyelesaikan tugas yang agak sederhana, tetapi diperlukan untuk banyak proyek, pada pengontrol STM32 (Blue Pill) dan STM8.  Semua proyek demo didedikasikan untuk LED favorit saya, kami akan menyalakannya dalam jumlah besar, dan untuk itu kami harus menggunakan semua jenis periferal yang menarik. </p><a name="habracut"></a><br><p>  Teks berubah menjadi besar lagi, jadi untuk kenyamanan saya melakukan konten: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">STM32 Blue Pill: 16 LED dengan Driver DM634</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">STM8: Mengkonfigurasi Enam Pin PWM</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">STM8: 8 RGB LED pada tiga pin, menyela</a> </p><br><p>  <em>Penafian: Saya bukan seorang insinyur, saya tidak berpura-pura memiliki pengetahuan yang mendalam di bidang elektronik, artikel ini ditujukan untuk pecinta seperti saya.</em>  <em>Bahkan, sebagai target audiens, saya menganggap diri saya dua tahun lalu.</em>  <em>Jika seseorang mengatakan kepada saya maka itu tidak menakutkan untuk membaca lembar data pada chip yang tidak dikenal, saya tidak akan menghabiskan banyak waktu mencari beberapa potongan kode di Internet dan menemukan kruk dengan gunting dan bantuan band.</em> </p><br><p>  <em>Di tengah-tengah artikel ini adalah lembar data, bukan proyek, sehingga kode mungkin tidak terlalu disisir dan sering dikruk.</em>  <em>Proyek-proyek itu sendiri sangat sederhana, meskipun cocok untuk kenalan pertama dengan chip baru.</em> </p><br><p>  <em>Saya berharap artikel saya akan membantu seseorang pada tahap yang sama dalam hobi menyelam.</em> </p><br><h1 id="stm32">  STM32 </h1><br><h1 id="16-svetodiodov-c-dm634-i-spi">  16 LED dengan DM634 dan SPI </h1><br><p>  Proyek kecil menggunakan Blue Pill (STM32F103C8T6) dan driver LED DM634.  Dengan bantuan lembar data kita akan berurusan dengan driver, IO-ports STM dan mengkonfigurasi SPI. </p><br><h2 id="dm634">  DM634 </h2><br><p>  Chip Taiwan dengan 16 output PWM 16-bit, dapat dihubungkan secara berantai.  Model 12-bit termuda dikenal untuk proyek domestik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lightpack</a> .  Pada suatu waktu, memilih antara DM63x dan TLC5940 yang terkenal, saya berhenti di DM karena beberapa alasan: 1) TLC pada Aliexpress benar-benar palsu, tetapi yang ini tidak;  2) DM memiliki PWM otonom dengan generator frekuensinya sendiri;  3) itu bisa dibeli dengan murah di Moskow, dan tidak menunggu paket dengan Ali.  Yah, tentu saja, itu menarik untuk belajar bagaimana mengelola chip sendiri, dan tidak menggunakan perpustakaan yang sudah jadi.  Chip sekarang terutama disajikan dalam paket SSOP24, mereka mudah disolder ke adaptor. </p><br><p>  Karena pabrikannya adalah orang Taiwan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lembar data</a> untuk chip ditulis dalam Bahasa Inggris China, yang artinya akan menyenangkan.  Pertama, lihat <em>koneksi pin</em> ( <em>Koneksi Pin</em> ) untuk memahami kaki mana yang terhubung dan deskripsi pin ( <em>Deskripsi Pin</em> ).  16 kesimpulan: </p><br><p><img src="https://habrastorage.org/webt/uj/n8/mo/ujn8mooelrxoxg7xzvvfsdh4er8.png"><br>  <sup>Sumber arus searah inflowing (drain terbuka)</sup> </p><br><p>  <strong>Sink</strong> / <strong>Output</strong> saluran terbuka - tiriskan;  sumber arus masuk;  output aktif terhubung ke ground - LED terhubung ke driver oleh katoda.  Secara elektrik, ini, tentu saja, bukan "saluran terbuka", tetapi dalam lembar data penunjukan ini untuk keluaran dalam mode saluran adalah umum. </p><br><p><img src="https://habrastorage.org/webt/yk/bq/p4/ykbqp4ivabirkgahd2d7l_9gjny.png"><br>  <sup>Resistor eksternal antara REXT dan GND untuk mengatur nilai arus keluaran</sup> </p><br><p>  Sebuah resistor referensi dipasang di antara pin REXT dan ground, yang memantau resistansi internal output, lihat grafik di halaman 9 dari lembar data.  Dalam DM634, hambatan ini juga dapat dikontrol secara terprogram dengan mengatur <em>kecerahan global</em> ;  Saya tidak akan masuk ke rincian dalam artikel ini, saya hanya meletakkan 2.2 - 3 kOhm resistor di sini. </p><br><p>  Untuk memahami cara mengontrol chip, lihat deskripsi antarmuka perangkat: </p><br><p><img src="https://habrastorage.org/webt/7s/5n/to/7s5ntogguqr1yb6fu2l5pchaob8.png"></p><br><p>  Ya, ini dia, Bahasa Inggris Tiongkok dengan segala kemuliaan.  Terjadi masalah saat menerjemahkan, Anda bisa memahaminya jika mau, tetapi ada cara lain - untuk melihat bagaimana koneksi dijelaskan dalam lembar data ke TLC5940 yang secara fungsional ditutup: </p><br><p><img src="https://habrastorage.org/webt/qi/za/j2/qizaj2wq08ppbzehiszsd2spqz8.png"><br>  <sub>... Hanya tiga pin yang diperlukan untuk memasukkan data ke perangkat.</sub>  <sub>Tepi depan sinyal SCLK menggeser data dari pin SIN ke register internal.</sub>  <sub>Setelah semua data diunduh, sinyal XLAT pendek tinggi menangkap data serial dalam register internal.</sub>  <sub>Register internal - katup gerbang yang dipicu XLAT.</sub>  <sub>Semua data ditransmisikan dalam bit ke depan yang paling signifikan.</sub> </p><br><p>  <strong>Kait</strong> - kait / kait / penjepit. <br>  <strong>Rising edge</strong> - <strong>edge</strong> terdepan dari impuls <br>  <strong>MSB pertama</strong> - bit <strong>paling signifikan</strong> (paling kiri) ke depan. <br>  <strong>to clock data</strong> - mengirimkan data secara berurutan (bitwise). </p><br><p>  Kata <em>kait</em> sering ditemukan dalam dokumentasi untuk chip dan diterjemahkan dengan berbagai cara, jadi saya akan membiarkan diri saya mengerti </p><div class="spoiler">  <b class="spoiler_title">program pendidikan kecil</b> <div class="spoiler_text">  Driver LED pada dasarnya adalah register geser.  "Shift" dalam namanya adalah gerakan bitwise data di dalam perangkat: setiap bit baru yang didorong ke dalam mendorong seluruh rantai di depannya.  Karena tidak ada yang ingin mengamati flashing kacau LED selama shift, proses berlangsung di register buffer dipisahkan dari yang bekerja dengan <em>kait</em> - ini adalah semacam ruang tunggu di mana bit diatur dalam urutan yang diinginkan.  Ketika semuanya sudah siap, rana terbuka, dan bit dikirim untuk bekerja, menggantikan batch sebelumnya.  Kata <em>latch</em> dalam dokumentasi untuk sirkuit mikro hampir selalu menyiratkan peredam seperti itu, tidak peduli di mana kombinasi itu digunakan. </div></div><br><p>  Jadi, transfer data ke DM634 adalah sebagai berikut: atur input DAI ke bit orde tinggi dari LED jauh, tarik DCK ke atas dan ke bawah;  atur input DAI ke bit berikutnya, tarik DCK;  dan seterusnya, sampai semua bit ditransmisikan ( <em>clocked in</em> ), setelah itu kita tarik LAT.  Ini dapat dilakukan secara manual ( <em>bit-bang</em> ), tetapi lebih baik menggunakan antarmuka SPI yang dipertajam khusus untuk ini, karena disajikan pada STM32 kami dalam dua salinan. </p><br><h2 id="sinyaya-tabletka-stm32f103">  Tablet Biru STM32F103 </h2><br><p>  Pendahuluan: Pengontrol STM32 jauh lebih rumit daripada Atmega328 daripada yang bisa mereka takuti.  Pada saat yang sama, untuk alasan penghematan energi, hampir semua periferal dinonaktifkan pada awalnya, dan frekuensi clock adalah 8 MHz dari sumber internal.  Untungnya, pemrogram STM menulis kode yang membawa chip ke 72 MHz yang "dihitung", dan penulis semua IDE yang saya kenal memasukkannya ke dalam prosedur inisialisasi, jadi kami tidak perlu clock (tapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda bisa, jika Anda benar-benar mau</a> ).  Tetapi Anda harus menghidupkan periferal. </p><br><p>  Dokumentasi: Chip STM32F103C8T6 yang populer dipasang pada Blue Pill, ada dua dokumen yang berguna untuknya: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lembar Data</a> untuk mikrokontroler STM32F103x8 dan STM32F103xB; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Manual Rujukan</a> untuk seluruh lini STM32F103 dan seterusnya. </li></ul><br><p>  Dalam lembar data kita mungkin tertarik pada: </p><br><ul><li>  Pinout - pinouts of chips - jika kita memutuskan untuk membuat papan sendiri; </li><li>  Memory Map - kartu memori untuk chip tertentu.  Dalam Manual Referensi ada kartu untuk seluruh baris, itu daftar register yang tidak ada pada kita. </li><li>  Table Pin Definition - daftar fungsi utama dan alternatif pin;  untuk "pil biru" di Internet Anda dapat menemukan gambar yang lebih nyaman dengan daftar pin dan fungsinya.  Karena itu, segera google pinout Pil Biru dan simpan gambar ini di tangan: </li></ul><br><p><img src="https://habrastorage.org/webt/_q/q_/o4/_qq_o4hwzc3k1nzqluqtaqpuye0.png"><br>  <em>NB: dalam gambar dari Internet ada kesalahan yang diperhatikan dalam komentar, terima kasih.</em>  <em>Gambar telah diganti, tapi ini pelajaran - lebih baik memeriksa informasi dari lembar data.</em> </p><br><p>  Kami menghapus lembar data, buka Manual Referensi, sekarang kami hanya menggunakannya. <br>  Prosedur: kita berurusan dengan input / output standar, konfigurasi SPI, nyalakan periferal yang diinginkan. </p><br><h3 id="vvod-vyvod">  Input-output </h3><br><p>  Atmega328 I / O sangat sederhana, itulah sebabnya banyaknya pilihan STM32 bisa membingungkan.  Sekarang kita hanya perlu kesimpulan, tetapi bahkan ada empat opsi: </p><br><p><img src="https://habrastorage.org/webt/qv/ao/t6/qvaot6ql0b4z6c0bvv71dumovji.png"><br>  <sub>open drain output, output push-pull, output push-pull alternatif, alternatif open drain</sub> </p><br><p>  " <em>Push-pull</em> " ( <em>push-pull</em> ) - kesimpulan biasa dari Arduina, pin bisa TINGGI atau RENDAH.  Tetapi dengan "saluran terbuka" ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesulitan</a> , meskipun sebenarnya semuanya sederhana di sini: </p><br><p><img src="https://habrastorage.org/webt/qa/e-/al/qae-alom88ushdmghd8wcu2l0q4.png"><br><img src="https://habrastorage.org/webt/en/oh/ny/enohnyxpb5u8cs4_t_m-cmtxbwy.png"><br>  <sub>Konfigurasi output / ketika port ditugaskan ke output: / buffer output aktif: / - mode drain terbuka: "0" mengaktifkan N-MOS di register output, "1" meninggalkan port dalam mode Hi-Z di register output (P-MOS tidak diaktifkan ) / - Mode "tarik-dorong": "0" pada register output mengaktifkan N-MOS, "1" pada register output mengaktifkan P-MOS.</sub> </p><br><p>  Seluruh perbedaan antara drain terbuka dan <em>push-pull</em> adalah bahwa pada pin pertama tidak dapat menerima status TINGGI: ketika menulis unit ke register output, ia beralih ke <em>impedansi tinggi</em> , <em>Hai -Z</em> ).  Saat merekam nol, pin di kedua mode berperilaku sama, baik secara logis maupun elektrik. </p><br><p>  Dalam mode output normal, pin hanya menerjemahkan isi register output.  Dalam "alternatif" itu dikendalikan oleh pinggiran yang sesuai (lihat 9.1.4): </p><br><p><img src="https://habrastorage.org/webt/wu/mz/fv/wumzfvlk-fueikoig1wg6npj59u.png"><br>  <sub>Jika bit port dikonfigurasikan sebagai output fungsi alternatif, register output dinonaktifkan dan pin terhubung ke sinyal output periferal</sub> </p><br><p>  Fungsi alternatif untuk setiap pin dijelaskan dalam lembar data <em>Pin Definition</em> dan ada pada gambar yang diunduh.  Ketika ditanya apa yang harus dilakukan jika pin memiliki beberapa fungsi alternatif, jawabannya memberikan catatan kaki di datasheet: </p><br><p><img src="https://habrastorage.org/webt/g1/hq/mi/g1hqmixkcdtdiius8u45hjfzagy.png"><br>  <sub>Jika beberapa blok periferal menggunakan pin yang sama, untuk menghindari konflik antara fungsi-fungsi alternatif, hanya satu blok periferal yang harus digunakan pada saat yang sama, beralih menggunakan bit aktivasi jam periferal (dalam register RCC yang sesuai).</sub> </p><br><p>  Akhirnya, pin dalam mode keluaran juga memiliki kecepatan clock.  Ini adalah fitur hemat energi lain, dalam kasus kami, kami cukup mengaturnya secara maksimal dan melupakannya. </p><br><p>  Jadi: kami menggunakan SPI, jadi dua pin (dengan data dan sinyal clock) harus menjadi "fungsi push-push alternatif", dan lainnya (LAT) harus "normal-push-push".  Tetapi sebelum kita menugaskan mereka, kita akan berurusan dengan SPI. </p><br><h3 id="spi">  SPI </h3><br><div class="spoiler">  <b class="spoiler_title">Program pendidikan kecil lainnya</b> <div class="spoiler_text"><p>  SPI atau Serial Peripherial Interface (antarmuka periferal serial) - antarmuka sederhana dan sangat efektif untuk komunikasi MK dengan MK lain dan dunia luar pada umumnya.  Prinsip operasinya telah dijelaskan di atas, di mana tentang driver LED Cina (dalam manual referensi, lihat bagian 25).  SPI dapat beroperasi dalam mode master ("master") dan slave ("slave").  SPI memiliki empat saluran dasar, yang tidak semuanya mungkin terlibat: </p><br><ul><li>  MOSI, Master Output / Slave Input: pin ini dalam mode master mengirim, tetapi dalam mode slave menerima data; </li><li>  MISO, Input Master / Output Slave: sebaliknya, di master menerima, di slave - beri; </li><li>  SCK, Serial Clock: mengatur frekuensi transfer data dalam master atau menerima sinyal clock dalam slave.  Pada dasarnya mengalahkan bit; </li><li>  SS, Slave Select: melalui saluran ini, budak mengetahui bahwa mereka menginginkan sesuatu darinya.  Pada STM32, ini disebut NSS, di mana N = negatif, mis.  controller menjadi budak jika ada ground di saluran ini.  Dikombinasikan dengan baik dengan mode Open Drain Output, tapi itu cerita yang berbeda. </li></ul></div></div><br><p>  Seperti yang lainnya, SPI pada STM32 kaya akan fungsionalitas, yang membuatnya agak sulit untuk dipahami.  Sebagai contoh, ini dapat bekerja tidak hanya dengan SPI, tetapi juga dengan antarmuka I2S, dan dalam dokumentasi deskripsi mereka tercampur, Anda perlu memotong kelebihannya secara tepat waktu.  Tugas kami sangat sederhana: Anda hanya perlu mengirim data hanya menggunakan MOSI dan SCK.  Kita pergi ke bagian 25.3.4 (komunikasi setengah dupleks), di mana kita menemukan <em>1 jam dan 1 kawat data searah</em> (1 sinyal jam dan 1 aliran data searah): </p><br><p><img src="https://habrastorage.org/webt/3o/wg/pm/3owgpmokhpahr9rkftf5ns2lclw.png"><br>  <sub>Dalam mode ini, aplikasi menggunakan SPI dalam mode hanya-kirim atau hanya-terima.</sub>  <sub>/ Mode hanya transmisi mirip dengan mode dupleks: data ditransmisikan pada pin transmisi (MOSI dalam mode master atau MISO dalam mode slave), dan pin penerima (masing-masing MISO atau MOSI) dapat digunakan sebagai pin input-output reguler.</sub>  <sub>Dalam hal ini, cukup bagi aplikasi untuk mengabaikan buffer Rx (jika Anda membacanya, tidak akan ada data yang dikirimkan).</sub> </p><br><p>  Nah, pin MISO bebas dari kita, mari sambungkan sinyal LAT ke sana.  Kami akan berurusan dengan Slave Select, yang dapat dikontrol secara terprogram pada STM32, yang sangat nyaman.  Kita membaca paragraf dengan nama yang sama di bagian 25.3.1 dari Uraian Umum SPI: </p><br><p><img src="https://habrastorage.org/webt/8t/ng/jf/8tngjfopfxskwyq_gl8tlogcp2o.png"><br>  <sub>Kontrol Program NSS (SSM = 1) / Informasi tentang pemilihan budak terkandung dalam bit SSI dari register SPI_CR1.</sub>  <sub>Pin NSS eksternal tetap gratis untuk kebutuhan aplikasi lain.</sub> </p><br><p>  Saatnya menulis di register.  Saya memutuskan untuk menggunakan SPI2, kami mencari alamat dasar di datasheet - di bagian 3.3 Memory Map: </p><br><p><img src="https://habrastorage.org/webt/os/xd/6p/osxd6pdv5zfwombf5xflzfikj5c.png"></p><br><p>  Baiklah, kita mulai: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI2_(mem_offset) (*(volatile uint32_t *)(0x40003800 + (mem_offset)))</span></span></code> </pre> <br><p>  Kami membuka bagian 25.3.3 dengan mengatakan "Mengonfigurasi SPI dalam mode master": </p><br><p><img src="https://habrastorage.org/webt/s8/ah/o5/s8aho5pbdv55j5vhhwecvewrm3m.png"></p><br><p>  <strong>1. Atur kecepatan jam seri dengan bit BR [2: 0] dalam register SPI_CR1.</strong> </p><br><p>  Register dikumpulkan di bagian manual referensi dengan nama yang sama.  CR1 memiliki <em>offset alamat</em> ( <em>Alamat offset</em> ) 0x00, secara default semua bit diatur ulang ( <em>Nilai</em> reset 0x0000): </p><br><p><img src="https://habrastorage.org/webt/vt/46/um/vt46umrvbimjon75durupo3zsao.png"></p><br><p>  Bit-bit BR mengatur pembagi frekuensi clock pengontrol, sehingga menentukan frekuensi di mana SPI akan beroperasi.  Kami akan memiliki frekuensi STM32 dari 72 MHz, driver LED, menurut datasheet-nya, bekerja dengan frekuensi hingga 25 MHz, oleh karena itu, perlu untuk membagi dengan empat (BR [2: 0] = 001). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_CR1 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_0 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_1 0x0010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_2 0x0020 _SPI2_ (_SPI_CR1) |= BR_0;</span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// pclk/4</span></span></span></span></code> </pre> <br><p>  <strong>2. Atur bit CPOL dan CPHA untuk menentukan hubungan antara transfer data dan clocking dari antarmuka serial (lihat diagram di halaman 240)</strong> </p><br><p>  Karena kita membaca lembar data di sini, dan tidak mempertimbangkan sirkuit, mari kita mempelajari deskripsi tekstual bit CPOL dan CPHA di halaman 704 (Deskripsi Umum SPI): </p><br><p><img src="https://habrastorage.org/webt/2h/pj/in/2hpjinoa65388hdfarcc9lwnqok.png"><br>  <sub>Fase Jam dan Polaritas</sub> <sub><br></sub>  <sub>Menggunakan bit CPOL dan CPHA dari register SPI_CR1, empat opsi untuk hubungan waktu dapat dipilih secara terprogram.</sub>  <sub>Bit CPOL (polaritas jam) mengontrol keadaan jam ketika tidak ada data yang dikirim.</sub>  <sub>Bit ini mengontrol mode master dan slave.</sub>  <sub>Jika CPOL diatur ulang, pin SCK rendah dalam mode siaga.</sub>  <sub>Jika bit CPOL diatur, pin SCK berada pada level tinggi dalam mode siaga.</sub> <sub><br></sub>  <sub>Jika bit CPHA (fase jam) diatur, tepi kedua dari sinyal SCK bertindak sebagai gerbang perangkap dari bit tinggi (turun jika CPOL dihapus, atau naik jika CPOL diatur).</sub>  <sub>Data ditangkap oleh perubahan kedua pada sinyal clock.</sub>  <sub>Jika bit CPHA dikosongkan, tepi depan sinyal SCK bertindak sebagai gerbang perangkap dari bit tinggi (ke bawah jika CPOL diatur, atau ke atas jika CPOL dihapus).</sub>  <sub>Data ditangkap oleh perubahan pertama pada sinyal clock.</sub> </p><br><p>  Setelah merokok pengetahuan ini, kami menyimpulkan bahwa kedua bit harus tetap nol, karena  kita membutuhkan sinyal SCK untuk tetap rendah ketika tidak digunakan, dan data yang akan ditransmisikan di sepanjang tepi utama pulsa (lihat <em>Tepi Meningkat</em> dalam lembar data DM634). </p><br><p>  Ngomong-ngomong, di sini kita pertama kali menemukan fitur kosa kata dalam lembar data ST: di dalamnya frasa "reset bit to zero" ditulis <em>untuk mengatur ulang sedikit</em> , dan tidak <em>menghapus sedikit</em> , seperti, misalnya, di Atmega. </p><br><p>  <strong>3. Atur bit DFF untuk menentukan format blok data 8-bit atau 16-bit.</strong> </p><br><p>  Saya secara khusus mengambil DM634 16-bit, agar tidak repot dengan transmisi data PWM 12-bit, seperti DM633.  DFF masuk akal untuk dimasukkan ke dalam unit: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DFF 0x0800 _SPI2_ (_SPI_CR1) |= DFF; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 16-bit mode</span></span></span></span></code> </pre> <br><p>  <strong>4. Konfigurasikan bit LSBFIRST dalam register SPI_CR1 untuk menentukan format blok</strong> </p><br><p>  LSBFIRST, seperti namanya, menetapkan bit orde rendah ke depan.  Tetapi DM634 ingin menerima data yang dimulai dengan bit tinggi.  Karenanya, kami membiarkannya dibuang. </p><br><p>  <strong>5. Dalam mode perangkat keras, jika input dari pin NSS diperlukan, kirim sinyal tinggi ke pin NSS selama seluruh urutan transfer byte.</strong>  <strong>Dalam mode program NSS, atur bit SSM dan SSI dalam register SPI_CR1.</strong>  <strong>Jika pin NSS harus bekerja pada output, hanya bit SSOE yang harus ditetapkan.</strong> </p><br><p>  Instal SSM dan SSI untuk melupakan mode perangkat keras NSS: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSI 0x0100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSM 0x0200 _SPI2_ (_SPI_CR1) |= SSM | SSI; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//enable software control of SS, SS high</span></span></span></span></code> </pre> <br><p>  <strong>6. Bit MSTR dan SPE harus diatur (mereka tetap hanya jika sinyal tinggi diterapkan ke NSS)</strong> </p><br><p>  Sebenarnya, dengan bit-bit ini kami menetapkan SPI kami sebagai master dan menyalakannya: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MSTR 0x0004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPE 0x0040 _SPI2_ (_SPI_CR1) |= MSTR; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//SPI master //  ,  SPI _SPI2_ (_SPI_CR1) |= SPE;</span></span></span></span></code> </pre> <br><p>  SPI dikonfigurasi, mari kita menulis fungsi yang mengirim byte ke driver segera.  Kami terus membaca 25.3.3 "Mengkonfigurasi SPI dalam mode master": </p><br><p><img src="https://habrastorage.org/webt/sb/rg/u5/sbrgu5xwvaj7vc8a9rk2guxfdeq.png"><br>  <sub>Prosedur Transfer Data</sub> <sub><br></sub>  <sub>Transmisi dimulai ketika byte ditulis ke buffer Tx.</sub> <sub><br></sub>  <sub>Byte data dimuat ke register geser dalam mode <strong>paralel</strong> (dari bus internal) selama transmisi bit pertama, setelah itu ditransmisikan dalam mode <strong>serial</strong> ke pin MOSI, bit pertama atau terakhir ke depan, tergantung pada pengaturan bit LSBFIRST dalam register CPI_CR1.</sub>  <sub>Bendera TXE diatur setelah data ditransfer <strong>dari buffer Tx ke register geser</strong> , dan interupsi juga dibuat jika bit TXEIE diatur dalam register CPI_CR1.</sub> </p><br><p>  Saya menyoroti beberapa kata dalam terjemahan untuk menarik perhatian pada satu fitur implementasi SPI pada pengontrol STM.  Pada Atmega, flag TXE ( <em>Tx Empty</em> , Tx kosong dan siap menerima data) ditetapkan hanya setelah seluruh byte <em>keluar</em> .  Dan di sini flag ini diatur setelah byte dimasukkan ke register geser internal.  Karena didorong di sana oleh semua bit secara bersamaan (paralel), dan kemudian data ditransmisikan secara berurutan, TXE diatur sebelum byte sepenuhnya dikirim.  Ini penting karena  dalam hal driver LED kami, kami perlu menarik pin LAT setelah mengirim <em>semua</em> data, mis.  Hanya bendera TXE tidak akan cukup bagi kami. </p><br><p>  Dan ini berarti kita perlu bendera lainnya.  Mari kita lihat di 25.3.7 - "Bendera status": </p><br><p><img src="https://habrastorage.org/webt/_d/vn/jj/_dvnjjudvkmdyutpylvwfkfknng.png"><br>  &lt;...&gt; <br><img src="https://habrastorage.org/webt/3y/wv/nd/3ywvndaij5blabzqfq2n6wzdbfe.png"><br>  <sub>Bendera sibuk</sub> <sub><br></sub>  <sub>Bendera BSY diatur dan diatur ulang oleh perangkat keras (menulis padanya tidak mempengaruhi apa pun).</sub>  <sub>Bendera BSY menunjukkan status lapisan komunikasi SPI.</sub> <sub><br></sub>  <sub>Sudah diatur ulang:</sub> <sub><br></sub>  <sub>ketika transfer selesai (kecuali untuk mode master, jika transfer berlanjut)</sub> <sub><br></sub>  <sub>ketika SPI dinonaktifkan</sub> <sub><br></sub>  <sub>ketika kesalahan mode wizard terjadi (MODF = 1)</sub> <sub><br></sub>  <sub>Jika transmisi tidak kontinu, bendera BSY dibersihkan antara setiap pengiriman data.</sub> </p><br><p>  Oke, berguna.  Kami mencari tahu di mana buffer Tx berada.  Untuk melakukan ini, baca "Daftar Data SPI": </p><br><p><img src="https://habrastorage.org/webt/sj/gk/o7/sjgko7dcnefgkio4jk9xrwt67bs.png"><br>  <sub>Bit 15: 0 DR [15: 0] Data Register</sub> <sub><br></sub>  <sub>Menerima data atau data untuk transmisi.</sub> <sub><br></sub>  <sub>Register data dibagi menjadi dua buffer - satu untuk menulis (mengirimkan buffer) dan yang kedua untuk membaca (menerima buffer).</sub>  <sub>Menulis ke register data menulis ke buffer Tx, dan membaca dari register data akan mengembalikan nilai yang terkandung dalam buffer Rx.</sub> </p><br><p>  Daftar status, di mana ada bendera TXE dan BSY: </p><br><p><img src="https://habrastorage.org/webt/-k/pi/q9/-kpiq96tkpbqvvr1vly6nlzpwoe.png"></p><br><p>  Kami menulis: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_DR 0x0C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_SR 0x08 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BSY 0x0080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TXE 0x0002 void dm_shift16(uint16_t value) { _SPI2_(_SPI_DR) = value; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//send 2 bytes while (!(_SPI2_(_SPI_SR) &amp; TXE)); //wait until they're sent }</span></span></span></span></code> </pre> <br><p>  Nah, karena kita perlu mengirimkan 16 byte dua kali, sesuai dengan jumlah output driver LED, kira-kira seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendLEDdata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LAT_low(); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> k = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { k--; dm_shift16(leds[k]); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_SPI2_(_SPI_SR) &amp; BSY); <span class="hljs-comment"><span class="hljs-comment">// finish transmission LAT_pulse(); }</span></span></code> </pre> <br><p>  Tapi kami masih belum tahu cara menarik pin LAT, jadi kami akan kembali ke I / O. </p><br><h3 id="naznachaem-piny">  Tetapkan pin </h3><br><p>  Dalam STM32F1, register yang bertanggung jawab untuk keadaan pin agak tidak biasa.  Jelas bahwa ada lebih banyak dari mereka daripada Atmega, tetapi mereka juga berbeda dari chip STM lainnya.  Bagian 9.1 Deskripsi Umum GPIO: </p><br><p><img src="https://habrastorage.org/webt/ky/w9/ks/kyw9ksdar6bepxsf1u7kvyejfwm.png"><br>  <sub>Setiap port input / output tujuan umum <em>(GPIO)</em> memiliki dua register konfigurasi 32-bit (GPIOx_CRL dan GPIOx_CRH), dua register data 32-bit (GPIOx_IDR dan GPIOx_ODR), register set / reset 32-bit (GPIOx_BSRR), 16-bit register reset (GPIOx_BRR) dan register blok 32-bit (GPIOx_LCKR).</sub> </p><br><p>  Tidak biasa, juga agak merepotkan, dua register pertama ada di sini, karena 16 pin port tersebar di atasnya dalam format "empat bit per saudara".  Yaitu  pin nol hingga ketujuh berada di CRL, dan sisanya di CRH.  Pada saat yang sama, sisa register berhasil masuk dalam bit semua pin port - sering kali tersisa setengah "dicadangkan". </p><br><p>  Untuk kesederhanaan, mulailah dari akhir daftar. </p><br><p>  Kami tidak perlu register blokir. </p><br><p>  Setup dan reset register cukup lucu karena mereka saling menduplikasi: Anda dapat menulis semuanya hanya dalam BSRR, di mana 16 bit tertinggi akan mengatur ulang pin ke nol, dan yang lebih rendah - set ke 1, atau gunakan juga BRR, 16 bit yang lebih rendah di mana hanya reset pin .  Saya suka opsi kedua.  Register ini penting karena memberikan akses atom ke pin: </p><br><p><img src="https://habrastorage.org/webt/tr/g9/tq/trg9tqg8ksmhfiaokjbslfvvhny.png"><br><img src="https://habrastorage.org/webt/yb/dm/da/ybdmdaayb-f0np1pawunxobfbaa.png"><br>  <sub>Instalasi atom atau reset</sub> <sub><br></sub>  <sub>Anda tidak perlu menonaktifkan interupsi ketika memprogram GPIOx_ODR pada tingkat bit: Anda dapat mengubah satu atau lebih bit dengan satu operasi penulisan atom APB2.</sub>  <sub>Ini dicapai dengan menulis "1" ke register set / reset (GPIOx_BSRR atau, hanya untuk reset, di GPIOx_BRR) bit yang ingin Anda ubah.</sub>  <sub>Bit lain akan tetap tidak berubah.</sub> </p><br><p>  Register data memiliki nama yang cukup berbicara - IDR = <em>Input</em> Direction Register, input register;  ODR = <em>Output</em> Direction Register, register keluaran.  Dalam proyek saat ini kami tidak akan membutuhkannya. </p><br><p>  Dan akhirnya, kontrol register.  Karena kami tertarik pada pin SPI kedua, yaitu PB13, PB14 dan PB15, kami segera melihat CRH: </p><br><p><img src="https://habrastorage.org/webt/ei/_v/it/ei_vitm85yhwasuf5zjbhksfsoq.png"></p><br><p>  Dan kita melihat bahwa perlu untuk menulis sesuatu dalam bit dari tanggal 20 hingga tanggal 31. </p><br><p>  Kami telah menemukan apa yang kami inginkan dari pin, jadi di sini saya dapat melakukannya tanpa tangkapan layar, cukup katakan bahwa MODE menentukan arah (input, jika kedua bit diatur ke 0) dan kecepatan pin (kita perlu 50MHz, mis. Keduanya pin di "1"), dan CNF menetapkan mode: normal "push-push" - 00, "alternative" - ​​10. Secara default, seperti yang kita lihat di atas, semua pin memiliki bit ketiga dari bawah (CNF0), itu menetapkan mereka untuk mode <em>input mengambang</em> . </p><br><p>  Karena saya berencana untuk melakukan hal lain dengan chip ini, untuk kesederhanaan, saya telah mendefinisikan semua nilai MODE dan CNF yang mungkin untuk register kontrol bawah dan atas. </p><br><div class="spoiler">  <b class="spoiler_title">Nah, kira-kira seperti ini</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_1 0x20000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_1 0x20000000</span></span></code> </pre> </div></div><br><p>  Pin kami terletak di port B (alamat dasar adalah 0x40010C00), kode: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _PORTB_(mem_offset) (*(volatile uint32_t *)(0x40010C00 + (mem_offset))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BRR 0x14 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BSRR 0x10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRL 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRH 0x04 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  SPI2: MOSI  B15, CLK  B13 //LAT     MISO – B14 //  ,      _PORTB_ (_CRH) &amp;= ~(CNF15_0 | CNF14_0 | CNF13_0 | CNF12_0); //   MOSI  SCK _PORTB_ (_CRH) |= CNF15_1 | CNF13_1; //50 , MODE = 11 _PORTB_ (_CRH) |= MODE15_1 | MODE15_0 | MODE14_1 | MODE14_0 | MODE13_1 | MODE13_0;</span></span></span></span></code> </pre> <br><p>  Dan, oleh karena itu, Anda dapat menulis definisi untuk LAT, yang akan menggerakkan register BRR dan BSRR: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*** LAT pulse – high, then low */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_pulse() _PORTB_(_BSRR) = (1&lt;&lt;14); _PORTB_(_BRR) = (1&lt;&lt;14) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_low() _PORTB_(_BRR) = (1&lt;&lt;14)</span></span></code> </pre> <br><p>  (LAT_low hanya dengan inersia, entah bagaimana itu selalu, biarkan diri Anda tetap) </p><br><p>  Sekarang semuanya sudah bagus, tidak berfungsi.  Karena STM32, ini menghemat listrik, yang berarti Anda harus mengaktifkan jam untuk periferal yang diperlukan. </p><br><h2 id="vklyuchaem-taktirovanie">  Hidupkan timing </h2><br><p>  Jam bertanggung jawab atas pencatatan jam kerja, mereka juga Jam.  Dan kita sudah bisa melihat singkatan RCC.  Kami mencarinya di dokumentasi: ini adalah Reset dan Kontrol Jam. </p><br><p>  Seperti yang dikatakan di atas, untungnya, orang-orang dari STM melakukan bagian yang paling sulit dari topik pengaturan waktu untuk kami, dan mereka sangat berterima kasih (sekali lagi saya akan memberikan tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web Di Halt</a> untuk menjelaskan betapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bingungnya</a> hal ini).  Kami hanya perlu register yang bertanggung jawab untuk mengaktifkan jam periferal (Peripheral Clock Enable Register).  Pertama, temukan alamat dasar RCC, itu di bagian paling awal "Kartu Memori": </p><br><p><img src="https://habrastorage.org/webt/r5/ad/jt/r5adjtnefym8toywwtuxwls-s8e.png"></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _RCC_(mem_offset) (*(volatile uint32_t *)(0x40021000 + (mem_offset)))</span></span></code> </pre> <br><p>  Dan kemudian klik pada tautan tempat mencoba menemukan sesuatu di piring, atau, jauh lebih baik, bacalah deskripsi register inklusi dari bagian <em>mengaktifkan register</em> .  Di mana kami menemukan RCC_APB1ENR dan RCC_APB2ENR: </p><br><p><img src="https://habrastorage.org/webt/bt/e7/_6/bte7_6icypsiop8tvagswdtfdpe.png"><br><img src="https://habrastorage.org/webt/pr/d0/l1/prd0l1e_vckbrxqk83wso_h9t5k.png"></p><br><p>  Dan di dalamnya, masing-masing, bit, termasuk clocking SPI2, IOPB (I / O Port B) dan fungsi alternatif (AFIO). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB2ENR 0x18 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB1ENR 0x1C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IOPBEN 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPI2EN 0x4000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AFIOEN 0x0001 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   B  .  _RCC_(_APB2ENR) |= IOPBEN | AFIOEN; //  SPI2 _RCC_(_APB1ENR) |= SPI2EN;</span></span></span></span></code> </pre> <br><p>  Kode terakhir dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Jika ada peluang dan keinginan untuk menguji, maka kami menghubungkan DM634 seperti ini: DAI ke PB15, DCK ke PB13, LAT ke PB14.  Kami memberi makan pengemudi dari 5 volt, jangan lupa untuk menggabungkan bumi. </p><br><p><img src="https://habrastorage.org/webt/sx/bz/va/sxbzvazmpgcgwsl0o5pt90gzlnm.jpeg"></p><br><h1 id="stm8-pwm">  STM8 PWM </h1><br><h1 id="shim-na-stm8">  PWM pada STM8 </h1><br><p>  Ketika saya merencanakan artikel ini, misalnya, saya memutuskan untuk mencoba mempelajari beberapa fungsionalitas dari chip yang tidak dikenal hanya dengan lembar data, sehingga saya tidak akan mendapatkan pembuat sepatu tanpa sepatu bot.  STM8 secara ideal cocok dengan peran ini: pertama, saya memiliki beberapa motherboard Cina dengan STM8S103, dan kedua, itu tidak terlalu populer, dan oleh karena itu godaan untuk membaca dan menemukan solusi di Internet terletak pada ketiadaan solusi yang sangat ini. </p><br><p>  Chip ini juga memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lembar data</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">referensi manual RM0016</a> , di pinout pertama dan mendaftarkan alamat, di detik - semuanya.  STM8 diprogram dalam C di IDE <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ST Visual Develop yang</a> jelek. </p><br><h3 id="taktirovanie-i-vvod-vyvod">  Clocking dan I / O </h3><br><p>  Secara default, STM8 beroperasi pada frekuensi 2 MHz, ini harus segera diperbaiki. </p><br><p><img src="https://habrastorage.org/webt/h-/w7/hc/h-w7hclj1kovrmig-mxtjj-n62k.png"><br>  <sub>Jam HSI (Kecepatan Internal)</sub> <sub><br></sub>  <sub>Jam HSI diperoleh dari osilator RC 16-MHz internal dengan pembagi yang dapat diprogram (1 hingga 8).</sub>  <sub>Sudah diatur dalam register pembagi jam (CLK_CKDIVR).</sub> <sub><br></sub>  <sub>Catatan: pada awalnya, osilator HSI RC dengan pembagi 8 dipilih sebagai sumber clock terkemuka.</sub> </p><br><p>  Kami menemukan alamat register di lembar data, deskripsi di refman dan melihat bahwa register perlu dibersihkan: </p><br><pre> <code class="plaintext hljs">#define CLK_CKDIVR *(volatile uint8_t *)0x0050C6 CLK_CKDIVR &amp;= ~(0x18);</code> </pre> <br><p>  Karena kita akan memulai PWM dan menghubungkan LED, kita melihat pinout: </p><br><p><img src="https://habrastorage.org/webt/uv/ii/kt/uviikt-bigbrftn_ivjxx681d8e.png"></p><br><p>  Chipnya kecil, banyak fungsi yang ditangguhkan pada pin yang sama.  Fakta bahwa dalam tanda kurung siku adalah "fungsionalitas alternatif", ia dialihkan oleh " <em>opsi byte</em> " - sesuatu seperti sekering Atmega.  Anda dapat mengubah nilai-nilai mereka secara terprogram, tetapi tidak perlu, karena  fungsi baru diaktifkan hanya setelah reboot.  Lebih mudah menggunakan ST Visual Programmer (unduhan bersama dengan Visual Develop) yang dapat mengubah byte ini.  Pinout menunjukkan bahwa kesimpulan CH1 dan CH2 dari timer pertama disembunyikan dalam tanda kurung;  perlu untuk menempatkan bit AFR1 dan AFR0 di STVP, dan yang kedua juga akan mentransfer output CH1 dari timer kedua dari PD4 ke PC5. </p><br><p>  Dengan demikian, 6 pin akan mengontrol LED: PC6, PC7 dan PC3 untuk timer pertama, PC5, PD3 dan PA3 untuk yang kedua. </p><br><p>  Mengkonfigurasi pin I / O sendiri pada STM8 lebih sederhana dan lebih logis daripada pada STM32: </p><br><ul><li>  akrab dengan Atmega <em>Data Direction Register</em> : 1 = output; </li><li>  register kontrol pertama CR1 pada output menetapkan mode push-pull (1) atau drain terbuka (0);  karena saya menghubungkan LED ke chip dengan katoda, saya meninggalkan nol di sini; </li><li>  register kontrol kedua CR2 pada output menetapkan kecepatan clock: 1 = 10 MHz </li></ul><br><pre> <code class="plaintext hljs">#define PA_DDR *(volatile uint8_t *)0x005002 #define PA_CR2 *(volatile uint8_t *)0x005004 #define PD_DDR *(volatile uint8_t *)0x005011 #define PD_CR2 *(volatile uint8_t *)0x005013 #define PC_DDR *(volatile uint8_t *)0x00500C #define PC_CR2 *(volatile uint8_t *)0x00500E PA_DDR = (1&lt;&lt;3); //output PA_CR2 |= (1&lt;&lt;3); //fast PD_DDR = (1&lt;&lt;3); //output PD_CR2 |= (1&lt;&lt;3); //fast PC_DDR = ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //output PC_CR2 |= ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //fast</code> </pre> <br><h2 id="nastroyka-shim">  Pengaturan PWM </h2><br><p>  Pertama, mari kita tentukan persyaratannya: </p><br><ul><li>  <strong>Frekuensi PWM</strong> - frekuensi yang digunakan oleh timer; </li><li>  <strong>Reload otomatis, AR</strong> - nilai pengisian otomatis yang akan dihitung penghitung waktu (periode pulsa); </li><li>  <strong>Perbarui Acara, UEV</strong> - suatu peristiwa <strong>yang terjadi</strong> ketika penghitung waktu telah dihitung untuk AR; </li><li>  <strong>PWM Duty Cycle</strong> - siklus tugas PWM, sering disebut sebagai "duty cycle"; </li><li>  <strong>Capture / Compare Value</strong> - nilai untuk capture / perbandingan, setelah dihitung sampai kapan timer <em>akan melakukan sesuatu</em> (dalam kasus PWM, itu membalikkan sinyal output); </li><li>  <strong>Nilai Preload</strong> - nilai preload.  <em>Nilai</em> perbandingan tidak dapat berubah saat timer terus berdetak, jika tidak siklus PWM akan terputus.  Oleh karena itu, nilai-nilai yang dikirimkan baru ditempatkan di buffer dan ditarik keluar dari sana ketika timer mencapai akhir hitungan dan direset; </li><li>  <strong>Mode</strong> <strong>Edge-aligned</strong> dan <strong>Center-aligned</strong> - penjajaran di perbatasan dan di tengah, sama seperti <em>PWM Cepat</em> Atmelovskie dan <em>PWM yang benar-fase</em> . </li><li>  <strong>OCiREF, Output Reference Reference Signal</strong> - sinyal keluaran referensi, pada kenyataannya, dalam mode PWM ada pada pin yang sesuai. </li></ul><br><p>  Seperti yang sudah jelas dari pinout, dua timer memiliki kemampuan PWM - pertama dan kedua.  Keduanya 16-bit, yang pertama memiliki banyak fitur tambahan (khususnya, dapat menghitung naik dan turun).  Kita perlu keduanya bekerja dengan cara yang sama, jadi saya memutuskan untuk memulai dengan yang kedua jelas lebih miskin, agar tidak sengaja menggunakan sesuatu yang tidak ada di dalamnya.  Beberapa masalah adalah bahwa deskripsi fungsi PWM dari semua timer dalam manual referensi ada di bab pada timer pertama (17.5.7 Mode PWM), jadi Anda harus melompat-lompat di seluruh dokumen. </p><br><p>  PWM pada STM8 memiliki keunggulan penting dibandingkan PWM Atmega: </p><br><p><img src="https://habrastorage.org/webt/pk/_-/za/pk_-za7gnzo77lvwyw-gvkts1y0.png"><br>  <sub>PWM dengan perataan tepi</sub> <sub><br></sub>  <sub>Konfigurasi akun dari bawah ke atas</sub> <sub><br></sub>  <sub>Hitungan bottom-up aktif jika bit DIR dalam register TIM_CR1 dihapus</sub> <sub><br></sub>  <sub>Contoh</sub> <sub><br></sub>  <sub>Contohnya menggunakan mode PWM pertama.</sub>  <sub>Sinyal referensi PWM OCiREF bertahan tinggi sementara TIM1_CNT &lt;TIM1_CCRi.</sub>  <sub>Kalau tidak, dibutuhkan level rendah.</sub>  <sub>Jika nilai perbandingan di TIM1_CCRi lebih besar dari nilai awal (register TIM1_ARR), sinyal OCiREF ditahan di 1. <strong>Jika nilai perbandingannya adalah 0, OCiREF ditahan di nol.</strong></sub>  <sub>...</sub> </p><br><p>  Timer STM8 selama <em>acara pembaruan</em> pertama memeriksa nilai <em>perbandingan</em> , dan hanya kemudian memberikan sinyal referensi.  Timer Atmega pertama kali mengocok, dan kemudian membandingkan, sebagai hasilnya, ketika <code>compare value == 0</code> output menghasilkan jarum yang perlu diperangi entah bagaimana (misalnya, dengan logika pembalik terprogram). </p><br><p>  Jadi, apa yang ingin kita lakukan: 8-bit PWM ( <code>AR == 255</code> ), kami pertimbangkan dari bawah ke atas, penjajaran di sepanjang perbatasan.  Karena bola lampu terhubung ke chip dengan katoda, PWM harus menampilkan 0 (LED menyala) sebelum <em>membandingkan nilai</em> dan 1 setelah. </p><br><p>  Kami sudah membaca tentang beberapa <em>mode PWM</em> , jadi kami menemukan register yang diinginkan dari timer kedua dengan mencari di manual referensi untuk frasa ini (18.6.8 - TIMx_CCMR1): </p><br><p><img src="https://habrastorage.org/webt/tt/_3/7s/tt_37syfd9-bib2-ymdxijus9qi.png"><br>  <sub>110: Mode PWM pertama - saat menghitung dari bawah ke atas, saluran pertama aktif saat TIMx_CNT &lt;TIMx_CCR1.</sub>  <sub>Jika tidak, saluran pertama tidak aktif.</sub>  <sub>[lebih lanjut dalam dokumen ini salah-tempel dari pengatur waktu 1]</sub> <sub><br></sub>  <sub>111: Mode PWM kedua - saat menghitung dari bawah ke atas, saluran pertama tidak aktif sementara TIMx_CNT &lt;TIMx_CCR1.</sub>  <sub>Jika tidak, saluran pertama aktif.</sub> </p><br><p>  Karena LED terhubung ke katoda MK, mode kedua cocok untuk kami (yang pertama juga, tapi kami belum tahu). </p><br><p><img src="https://habrastorage.org/webt/go/ap/x_/goapx_hk5neeok4phdkas_nnfzu.png"><br>  <sub>Bit 3 OC1PE: Mengaktifkan Output 1 Preload</sub> <sub><br></sub>  <sub>0: Preload register pada TIMx_CCR1 off.</sub>  <sub>Anda dapat menulis ke TIMx_CCR1 kapan saja.</sub>  <sub>Nilai baru segera berfungsi.</sub> <sub><br></sub>  <sub>1: Preload register di TIMx_CCR1 diaktifkan.</sub>  <sub>Operasi baca / tulis mengakses register preload.</sub>  <sub>Nilai yang dimuat sebelumnya TIMx_CCR1 dimuat ke dalam register bayangan selama setiap acara pembaruan.</sub> <sub><br></sub>  <sub>* Catatan: agar mode PWM berfungsi dengan benar, register preload harus dihidupkan.</sub> <sub>      (  TIMx_CR1   OPM).</sub> <br></p><p> ,  ,  ,     : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCMR1 *(volatile uint8_t *)0x005307 #define TIM2_CCMR2 *(volatile uint8_t *)0x005308 #define TIM2_CCMR3 *(volatile uint8_t *)0x005309 #define PWM_MODE2 0x70 //PWM mode 2, 0b01110000 #define OCxPE 0x08 //preload enable TIM2_CCMR1 = (PWM_MODE2 | OCxPE); TIM2_CCMR2 = (PWM_MODE2 | OCxPE); TIM2_CCMR3 = (PWM_MODE2 | OCxPE);</code> </pre> <br><p> AR     ,   : </p><br><pre> <code class="plaintext hljs">#define TIM2_ARRH *(volatile uint8_t *)0x00530F #define TIM2_ARRL *(volatile uint8_t *)0x005310 TIM2_ARRH = 0; TIM2_ARRL = 255;</code> </pre> <br><p>      -,   ,    .   , ,  256.        TIM2_PSCR     : </p><br><pre> <code class="plaintext hljs">#define TIM2_PSCR *(volatile uint8_t *)0x00530E TIM2_PSCR = 8;</code> </pre> <br><p>       .     <em>Capture/Compare <strong>Enable</strong></em> :  ,      .     ,     , ..       PWM Mode 1. : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCER1 *(volatile uint8_t *)0x00530A #define TIM2_CCER2 *(volatile uint8_t *)0x00530B #define CC1E (1&lt;&lt;0) // CCER1 #define CC2E (1&lt;&lt;4) // CCER1 #define CC3E (1&lt;&lt;0) // CCER2 TIM2_CCER1 = (CC1E | CC2E); TIM2_CCER2 = CC3E;</code> </pre> <br><p>  , ,     TIMx_CR1: </p><br><p><img src="https://habrastorage.org/webt/u8/rj/5v/u8rj5vb2h3oxtgnoe1zzz90fnfm.png"></p><br><pre> <code class="plaintext hljs">#define TIM2_CR1 *(volatile uint8_t *)0x005300 TIM2_CR1 |= 1;</code> </pre> <br><p>    AnalogWrite(),        .    <em>Capture/Compare registers</em> ,      :  8   TIM2_CCRxL    TIM2_CCRxH.    8- ,     : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCR1L *(volatile uint8_t *)0x005312 #define TIM2_CCR2L *(volatile uint8_t *)0x005314 #define TIM2_CCR3L *(volatile uint8_t *)0x005316 void setRGBled(uint8_t r, uint8_t g, uint8_t b) { TIM2_CCR1L = r; TIM2_CCR2L = g; TIM2_CCR3L = b; }</code> </pre> <br><p>   ,       ,   100%  (   255      ).      ,      ,   . </p><br><p>     ,   . </p><br><p>            (  ,   «»   ,        ).            .      , ..       ,   16-     <em>Prescaler High</em>  <em>Low</em> .   …    .   ? </p><br><p>             1,   ,     .  <em>17.7.30 Break register (TIM1_BKR)</em> ,    : </p><br><p><img src="https://habrastorage.org/webt/kb/h8/ue/kbh8ueavruur-vxcqo4fe0c2pdy.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM1_BKR *(volatile uint8_t *)0x00526D TIM1_BKR = (1&lt;&lt;7);</code> </pre> <br><p>    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . </p><br><p><img src="https://habrastorage.org/webt/b9/hb/tn/b9hbtn6retrnp1vpnzxjsjaayoq.jpeg"></p><br><h1 id="stm8-multiplex"> STM8 Multiplex </h1><br><h1 id="multipleksing-na-stm8">   STM8 </h1><br><p>  -   ,          RGB-      .   –  LED-,   ,   -     ,   ,     ( <em>persistence of vision</em> ,   ). -   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">-   </a> . </p><br><p>    : </p><br><ul><li>    RGB LED; </li><li>  ,     ; </li><li>    ; </li><li>    RGB LED; </li><li>  ... </li></ul><br><p>   .. ,    ,     «»   .   .   ,    ,         ,   UEV          RGB-. </p><br><p>   LED  ,   «»,      .   : </p><br><pre> <code class="plaintext hljs">uint8_t colors[8][3];</code> </pre> <br><p>  ,     ,        .         </p><br><pre> <code class="plaintext hljs">uint8_t cnt;</code> </pre> <br><h3 id="demuks">  </h3><br><p>     ,   ,  CD74HC238.  – ,    <code>&lt;&lt;</code> .     ( 0, 1  2)      X,        ( <code>1&lt;&lt;X</code> ).        .            ,     –      ,  ,    .   ,       . </p><br><p> CD74HC238      ,       .           P-MOSFET,       , ..   20 ,  <em>absolute maximum ratings</em>  .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> CD74HC238</a>       : </p><br><p><img src="https://habrastorage.org/webt/b3/lz/rv/b3lzrv4xyavibkiwekm3lbvkays.png"><br> <sub>H =   , L =   , X –  </sub> </p><br><p>  E2  E1  , E3, A0, A1  A3   PD5, PC3, PC4  PC5 STM8.      ,   ,     push-pull . </p><br><h2 id="shim">  </h2><br><p>       ,    ,   : </p><br><p> -,      <em>Update Event</em> (UEV),    ,   LED.     <em>Update Interrupt Enable</em>      </p><br><p><img src="https://habrastorage.org/webt/me/kx/6p/mekx6pckxk6qmhkegaudnneach4.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM2_IER *(volatile uint8_t *)0x005303 //enable interrupt TIM2_IER = 1;</code> </pre> <br><p>       ,  <em>ghosting</em> –   .       - ,  ,    UEV,   ,       LED      -   .        (0 =  , 255 =   )      .  Yaitu  ,   UEV       . </p><br><p>  : </p><br><pre> <code class="plaintext hljs">//set polarity TIM2_CCER1 |= (CC1P | CC2P); TIM2_CCER2 |= CC3P;</code> </pre> <br><p>   r, g  b  255       . </p><br><h3 id="preryvaniya">  </h3><br><p>    ,            -  .   -    ,     . </p><br><p>         ST Visual Develop,   <code>main.c</code>       <code>stm8_interrupt_vector.c</code> ,    .         <code>NonHandledInterrupt</code> .        . </p><br><p>      ,    : </p><br><p><img src="https://habrastorage.org/webt/ly/ra/gy/lyragyga5skmcrzjojlftjit1qg.png"><br> <sub>13 TIM2 / <br> 14 TIM2 /</sub> </p><br><p>    LED  UEV,     №13. </p><br><p> , -,   <code>stm8_interrupt_vector.c</code>   ,    №13 (IRQ13)    : </p><br><pre> <code class="plaintext hljs">{0x82, TIM2_Overflow}, /* irq13 */</code> </pre> <br><p> -,     <code>main.h</code>  : </p><br><pre> <code class="plaintext hljs">#ifndef __MAIN_H #define __MAIN_H @far @interrupt void TIM2_Overflow (void); #endif</code> </pre> <br><p>  , ,      <code>main.c</code> : </p><br><pre> <code class="plaintext hljs">@far @interrupt void TIM2_Overflow (void) { PD_ODR &amp;= ~(1&lt;&lt;5); //   PC_ODR = (cnt&lt;&lt;3); //      PD_ODR |= (1&lt;&lt;5); //   TIM2_SR1 = 0; //   Update Interrupt Pending cnt++; cnt &amp;= 7; //   LED TIM2_CCR1L = ~colors[cnt][0]; //      TIM2_CCR2L = ~colors[cnt][1]; //     TIM2_CCR3L = ~colors[cnt][2]; // return; }</code> </pre> <br><p>   .     <code>rim</code> –     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Programming Manual</a> : </p><br><pre> <code class="plaintext hljs">//enable interrupts _asm("rim");</code> </pre> <br><p>    – <code>sim</code> –  .          «»,         . </p><br><p>   – <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . </p><br><p><img src="https://habrastorage.org/webt/ri/ul/qs/riulqsjmsnehvg5fb_iofcnjl3u.jpeg"></p><br><p>   -   , ,     .     ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456094/">https://habr.com/ru/post/id456094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456084/index.html">Kubernet 1.15: Ikhtisar Sorotan</a></li>
<li><a href="../id456086/index.html">iOS Storyboards: analisis pro dan kontra, praktik terbaik</a></li>
<li><a href="../id456088/index.html">Masalah Analisis Data Besar</a></li>
<li><a href="../id456090/index.html">Pengantar Unit Testing in Unity</a></li>
<li><a href="../id456092/index.html">Tujuh tanda yang merisaukan bahwa Anda bergantung pada cuaca, meskipun Anda tidak mengira begitu</a></li>
<li><a href="../id456096/index.html">Apa yang pembaca geektimes rata-rata lakukan sambil melayang di awan</a></li>
<li><a href="../id456100/index.html">Sekarang dalam kemasan baru - Kingston A400 dalam format M.2 bergegas ke pasar</a></li>
<li><a href="../id456102/index.html">Pelaporan mudah dalam C / C ++</a></li>
<li><a href="../id456104/index.html">Ezblock Pi - pemrograman tanpa pemrograman, kali ini untuk penggemar Raspberry Pi</a></li>
<li><a href="../id456108/index.html">Habr Weekly # 5 / Dark topik ada di mana-mana, pabrik-pabrik Cina di Federasi Rusia, di mana bank telah mengalir, Pixel 4, ML mencemari atmosfer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>