<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔠 🧘🏾 🦍 Wie gut kennen Sie CSS? (+ Minitest) 👩🏼‍🍳 🔚 🛐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Unterschied zwischen der erfolgreichen Verwendung von CSS und schmerzhaften Versuchen, damit umzugehen, hängt häufig von kleinen Details ab. In de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie gut kennen Sie CSS? (+ Minitest)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467555/"><img src="https://habrastorage.org/webt/dz/qp/ty/dzqptyyxjsszvi4aqmupeqyqw98.png" alt="Bild"><br><br>  Der Unterschied zwischen der erfolgreichen Verwendung von CSS und schmerzhaften Versuchen, damit umzugehen, hängt häufig von kleinen Details ab.  In der Tat hat CSS viele Nuancen.  Einer der häufigsten Bereiche, in denen ich einen solchen Kampf oft bemerke, ist das Stylen von Layouts.  Persönlich lerne ich gerne CSS-Muster.  Mir ist aufgefallen, dass ich dazu neige, eine kleine Anzahl davon zu verwenden, um die meisten Probleme mit dem Layout zu lösen.  In diesem Artikel geht es um die CSS-Muster, mit denen ich Layoutprobleme überwinde.  Situationen werden unabhängig von der verwendeten CSS-Methodik berücksichtigt: sei es SMACSS, BEM oder sogar ein heißes CSS-in-JS-Thema, da sie sich alle auf die CSS-Eigenschaften selbst konzentrieren und nicht auf die Architektur, Organisation oder Strategie. <br><a name="habracut"></a><br><hr><br><h2>  Beginnen wir zum Spaß mit dem Test. </h2><br>  Wir werden die von mir entwickelte Plattform mit dem Namen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Questionable.io</a> verwenden und damit einen Test erstellen, auf den wir weiter unten eingehen werden.  Keine Sorge, es werden keine persönlichen Daten gesammelt, die Ergebnisse sind anonym und absolut kostenlos. <br><br>  Der Zweck des Testens besteht darin, festzustellen, ob Sie ein bestimmtes CSS-Verhalten und einige Probleme erkennen können, ohne den Artikel zuerst zu lesen.  Ich wollte das Testen nicht schwierig machen, aber die Nuancen des CSS-Stils können ziemlich kompliziert sein.  Denken Sie daran, diese Tests sind nur zum Spaß.  Die Testergebnisse zeigen nicht Ihre Coolness, aber ich hoffe, sie werden immer noch nützlich sein. <br><br>  Der Test besteht aus 10 Fragen und sollte nicht länger als 10 Minuten dauern <br><blockquote>  <b>Vom Übersetzer:</b> <br><br>  Am Ende des Artikels über Habr wird eine Umfrage über die Anzahl der im Test erzielten Punkte hinzugefügt. <br></blockquote><br><h4>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bestehen Sie den Test</a> </h4><br>  <b>Hinweis:</b> Wenn Sie keine Zeit verschwenden möchten, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier einen Link</a> zu Fragen mit den richtigen Antworten. <br><br>  Hast du den Test bestanden?  Großartig!  Lassen Sie uns die Fragen einzeln durchgehen, um eine bessere Vorstellung von den im Test betroffenen Styling-Mustern zu erhalten. <br><br><h2>  Frage 1: Blockmodell </h2><br>  Das Studium des Blockmodells sollte eine Priorität in der Liste aller FrontEnd-Entwickler sein.  Vielleicht ist der Artikel „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das CSS-Box-Modell</a> “ etwas alt, unterschätzen Sie nicht seinen Wert und seine Relevanz für modernes CSS.  Das Blockmodell ist die Grundlage für fast alle Probleme im Zusammenhang mit CSS-Layouts. <br><br>  Diese spezielle Frage prüft, wie die Breite anhand der Prinzipien des Blockmodells ermittelt werden kann.  Ein Block hat eine explizite Breite durch die <code>width: 100px</code> , es stellt sich jedoch heraus, dass die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standardregeln für Blockmodelle die</a> <code>width: 100px</code> auf die Ebene „content“ dieses Blocks anwenden.  Die resultierende Breite (wie breit der Block auf der Seite gezeichnet wird) ist die Summe aus Inhalt, Abstand und Rahmenebenen.  Aus diesem Grund lautet die Antwort 112px. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.box</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">100px</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Take this */</span></span> <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">50px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">5px</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Plus this x2 for left and right */</span></span> <span class="hljs-attribute"><span class="hljs-attribute">border</span></span>: <span class="hljs-number"><span class="hljs-number">1px</span></span> solid red; <span class="hljs-comment"><span class="hljs-comment">/* Plus this x2 for left and right */</span></span> <span class="hljs-attribute"><span class="hljs-attribute">background-color</span></span>: red; <span class="hljs-comment"><span class="hljs-comment">/* = 112px of computed width */</span></span> }</code> </pre><br>  Wenn Sie mit einer Situation konfrontiert sind, in der die letzte Spalte oder Registerkarte in der Benutzeroberfläche in die nächste Zeile verschoben wird, obwohl Sie für alle <code>width: 20%;</code> Folgendes angegeben haben <code>width: 20%;</code>  und waren sich sicher, dass sie zu 100% in das übergeordnete Element passen würden, wahrscheinlich wurde dies zu einem Problem.  Fünf Spalten mit einer Breite von 20% werden in 100% platziert. Wenn sie jedoch zusätzlich aufgefüllt und / oder umrandet werden, wird die Breite jeder Spalte erhöht, sodass in der aktuellen Zeile nicht genügend Platz für die letzte Spalte bleibt. <br><br>  Als CSS3 eingeführt wurde, erschien ein neues Tool namens <code>box-sizing</code> .  Damit können wir steuern, auf welche Ebene des Blockmodells wir die Eigenschaft <code>width</code> anwenden möchten.  Zum Beispiel können wir die <code>box-sizing: border-box</code> festlegen <code>box-sizing: border-box</code> .  Dies bedeutet, dass alle Breitenregeln auf die äußere Randebene anstelle der Inhaltsebene angewendet werden sollen.  In der Frage aus dem Test betrug die resultierende Blockbreite 100px, wenn die Eigenschaft <code>box-sizing: border-box</code> angewendet wurde. <br><br>  Für einige von Ihnen ist dies eine bekannte Tatsache, aber dennoch eine gute Erinnerung für Profis und Anfänger. <br><br>  Es gibt eine Reihe von Artikeln zum Blockmodell und zur Verwendung der Box-Sizing-Eigenschaft als Reset, um sie sofort auf das gesamte Projekt anzuwenden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Box Sizing</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inheriting Box Sizing Wahrscheinlich etwas bessere Best-Practice</a> sind zwei gute CSS-Tricks-Artikel zu lesen. <br><br><h2>  Frage 2: Elementgrenzen </h2><br>  Die zweite Testfrage kann teilweise als Fortsetzung der ersten angesehen werden.  Denken Sie daran, es ist eine Sache zu lesen: "Das Blockmodell hat Ebenen (Inhalt, Abstand, Rand) und alle wirken sich auf die Gesamtbreite und -höhe des Elements aus." Eine andere Sache ist, die Probleme des Blockmodells in einer realen Situation erkennen zu können.  Dieses spezielle Problem ist ein Klassiker unter denen, die seit einiger Zeit mit CSS arbeiten.  Daraus folgt, dass die Rahmen einen bestimmten zusätzlichen Platz einnehmen und die umgebenden Elemente wegschieben, da sie Teil des Blockmodells sind.  Das Hinzufügen von Frames beim Ändern des Status eines Elements, z. <code>:hover</code> , bedeutet, dass die Blöcke größer werden und die folgenden Blöcke nach unten gedrückt werden.  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kann ärgerlich sein</a> : <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/bradwestfall/embed/preview/pqNoav" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Von allen in der Testfrage genannten möglichen Lösungen ist das Hinzufügen von <code>border: 2px solid transparent</code> zum ursprünglichen Zustand (ohne Schwebeflug) die einzig mögliche Lösung für das Problem.  <code>box-sizing</code> löst dieses Problem nicht, da wir die Höhe nicht explizit festlegen.  Wenn wir dies tun würden, würde der Rahmen Teil der Gesamthöhe des Elements werden und die Verschiebung würde nicht auftreten, aber dies ist nicht unser Fall. <br><br>  Es gibt andere Lösungen, die wir in den Antwortoptionen nicht erwähnt haben.  Eine davon ist das Hinzufügen eines Pseudorandes mithilfe der <code>box-shadow</code> Eigenschaft oder die Verwendung eines <code>outline</code> anstelle eines <code>border</code> .  Jeder von ihnen führt nicht zu einer Verzerrung, da es sich nicht um eine Schicht des Blockmodells handelt.  Hier ist ein weiterer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel über CSS-Tricks,</a> in dem Sie mehr über solche Lösungen lesen können. <br><br>  Hinweis: <br>  Denken Sie daran, dass die <code>outline</code> Randradius nicht unterstützt <br><br><h2>  Frage 3: Positionierung - absolut vs fest </h2><br>  Neben dem Verständnis, wann die einzelnen Typen verwendet werden müssen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie sie sich in der visuellen Darstellung unterscheiden</a> , ist es auch sehr wichtig, die Regeln zu kennen, wie jede der Positionierungsmethoden mithilfe der Eigenschaften oben, rechts, unten oder links an das übergeordnete Element gebunden wird. <br><br>  Schauen wir uns zunächst den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">enthaltenen Block an</a> .  Eine kurze Definition ist, dass der enthaltende Block meistens das übergeordnete Element eines fraglichen Elements ist.  Die Regeln für den enthaltenden Block unterscheiden sich jedoch für absolut und fest positionierte Elemente. <br><br>  <b>1) Für absolute Elemente</b> .  Der enthaltende Block ist der nächste Vorfahr, dessen Positionierung nicht <code>static</code> .  Wenn ein Element beispielsweise absolut positioniert ist und die Eigenschaften <code>top</code> , <code>right</code> , <code>bottom</code> oder <code>left</code> , werden sie relativ zu allen übergeordneten Elementen positioniert, die eine <code>absolute</code> , <code>relative</code> , <code>fixed</code> oder <code>sticky</code> Position haben. <br>  <b>2) Für feste Elemente</b> .  Der enthaltende Block ist das Ansichtsfenster, obwohl übergeordnete Elemente mit einer anderen als der <code>static</code> Position vorhanden sind.  Außerdem unterscheidet sich das Bildlaufverhalten von absolut positionierten Elementen.  Feste Elemente bleiben im Anzeigebereich „fest“, daher der Name. <br><br>  Viele Entwickler denken, dass absolut positionierte Elemente nur nach dem nächsten übergeordneten Element mit relativer Positionierungsposition suchen <code>position: relative</code> .  Dieses Missverständnis ist einfach deshalb weit verbreitet, weil <code>position: relative</code> am häufigsten zusammen mit <code>position: absolute</code> , um einen enthaltenden Block zu erstellen.  Der Grund, warum dies häufig verwendet wird, ist, dass die relative Positionierung des übergeordneten Blocks ihn <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Stream</a> belässt, was häufig bevorzugt wird.  Es gibt Situationen, in denen das übergeordnete Element eines absolut positionierten Elements selbst absolut positioniert ist.  Das ist völlig normal.  Wenn alle übergeordneten Elemente statisch sind, wird ein absolut positioniertes Element an das Ansichtsfenster angehängt, das jedoch zusammen mit dem Ansichtsfenster gescrollt wird. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/bradwestfall/embed/preview/pqybLw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Es gibt eine wenig bekannte Ergänzung zu den oben genannten Regeln: In Situationen, in denen das übergeordnete Element die <code>transform</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unter anderem</a> ) mit einem anderen Wert als <code>none</code> , wird es zu einem enthaltenden Block für absolut und fest positionierte Elemente.  Die Bestätigung hierzu ist in CodePen zu sehen, wo das Element mit dem Text "Hinweis!"  Ist ein festes Element und das übergeordnete Element verfügt über die Transformationseigenschaft, jedoch nur, wenn sich der Mauszeiger darüber befindet (im Status <code>:hover</code> ). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/bradwestfall/embed/preview/EGKmZK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Frage 4: Rand der übergeordneten und untergeordneten Elemente reduzieren </h2><br>  Dies ist eines dieser kleinen CSS-Dinge, die viele Probleme verursachen können, wenn Sie nicht wissen, wie es funktioniert.  Es gibt ein Konzept, das als Kollapsränder bezeichnet wird, und viele Menschen sind mit der Manifestation dieses Konzepts vertraut, das als Kollapsränder benachbarter Geschwister bezeichnet wird.  Es gibt jedoch eine andere Form, die so genannten Collapse-Ränder des Elternteils und des ersten / letzten Kindes, die weniger bekannt ist.  Das Folgende ist eine Demonstration beider Fälle: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/bradwestfall/embed/preview/JwXEdp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Jedes Absatz-Tag hat einen oberen und unteren Rand von 1em, der vom Browser festgelegt wird.  Bisher ist dies der einfachste Teil der Situation.  Aber warum ist der Abstand zwischen den Absätzen nicht 2em (die Summe von oben und unten)?  Dies wird als kollabierende Ränder benachbarter Geschwister bezeichnet.  Die Ränder überlappen sich so, dass der größere der beiden Ränder die Größe der Lücke hat. In diesem Fall beträgt die Lücke also 1em. <br><br>  Es passiert jedoch noch etwas Seltsames.  Haben Sie bemerkt, dass der obere Rand des ersten Absatzes keine Lücke zwischen ihm und dem blauen Container div schafft?  Anstatt zu brechen, scheint es einen Rand in das übergeordnete Div einzubetten, als ob das Div einen oberen Rand hätte.  Dies wird als Reduzieren der Ränder des Elternteils und des ersten / letzten Kindes bezeichnet.  Diese Art von Kollapsrändern tritt unter bestimmten Umständen nicht auf, wenn Folgendes für das Elternteil charakteristisch ist: <br><br><ul><li>  Es gibt eine obere / untere Polsterung größer als Null <br></li><li>  Es gibt einen oberen / unteren Rand größer als Null <br></li><li>  Es wird ein Blockformatierungskontext angegeben, der mit <code>overflow: hidden</code> oder <code>overflow: auto</code> <br></li><li>  Anzeige: Flow-Root-Eigenschaftssatz (schlechte Browserunterstützung) <br></li></ul><br>  Wenn ich den Leuten gerne dieses kleine CSS-Detail erkläre und es mit Auffüllen oder Rahmen löse, lautet die Antwort fast immer: „Was ist mit Auffüllen oder Rand gleich 0?“.  Nun, das funktioniert nicht, weil der Wert eine positive ganze Zahl sein muss. <br><br>  Im vorherigen Beispiel können wir mit 1px-Auffüllung zwischen dem Verwenden von Reduzieren und dem Verhindern des Reduzierens der Ränder von Eltern und Kind wechseln.  Der Abstand zwischen dem ersten / letzten Absatz und dem übergeordneten Absatz beträgt 1 Pixel, aber jetzt wird der Rand als das Innere des Containers betrachtet, da die Polsterschicht eine Barriere bildet, um ein Zusammenfallen der Ränder zu verhindern. <br><br>  Ich bin mir sicher, dass Sie in dieser Benutzeroberfläche sehen können, wo das Problem liegt: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/bradwestfall/embed/preview/BvKLpZ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Das erste Element mit der <code>.comment</code> Klasse (ohne die <code>.moderator</code> Klasse) <code>.moderator</code> Ränder.  Auch ohne den Code zu betrachten, können wir sehen, dass das Element mit der <code>.moderator</code> Klasse einen Rahmen hat und das Element ohne diese Klasse nicht.  Es gab tatsächlich drei Antworten auf diese Frage, die als richtig angesehen wurden. Jede von ihnen ist tatsächlich bereits in der CodePen-Quelle angewendet, sie werden nur auskommentiert. <br><br>  Einer der Gründe, warum diese Art von Kollapsrändern nicht so bekannt ist wie die anderen, ist, dass es viele Situationen gibt, in denen wir sie versehentlich vermeiden können.  Flexbox- und Grid-Elemente erstellen einen Blockformatierungskontext. Wenn Sie sie verwenden, treten diese Arten von Reduzierungsrändern nicht auf.  Wenn die Schnittstelle unserer Kommentare ein echtes Projekt war, stehen die Chancen gut, dass auf allen vier Seiten Polsterungen angebracht wurden, um Platz zu lassen, und dies hat wiederum den Zusammenbruch der Ränder für uns behoben. <br><br><h2>  Frage 5: Prozentsatz von was? </h2><br>  Wenn prozentuale Einheiten verwendet werden, basieren Prozentsätze auf der Breite oder Höhe des enthaltenen Blocks (normalerweise des übergeordneten Blocks).  Wie bereits erwähnt, wird ein Element mit der <code>transform</code> Eigenschaft zu einem enthaltenden Block. Wenn das Element also transform verwendet, <code></code> die Einheiten in Prozent (nur für die <code>transform</code> ) auf der eigenen Größe des Elements und nicht auf der übergeordneten Größe. <br><br>  Im folgenden Beispiel sehen wir, dass 50% je nach Kontext zwei unterschiedliche Werte annehmen.  Der erste rote Block hat die Eigenschaft <code>margin-left: 50%</code> , und der zweite rote Block verwendet <code>transform: translateX(50%)</code> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/bradwestfall/embed/preview/Kbzyrq" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Frage 6: Das Blockmodell schlägt wieder zu ... </h2><br>  Nur Sie dachten, wir hätten das Gespräch über das Blockmodell beendet ... <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/bradwestfall/embed/preview/maOJmO" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Das Problem ist auf die Tatsache zurückzuführen, dass wir <code>width: 100%</code> für die Fußzeile verwenden und gleichzeitig Polster hinzufügen.  Die Breite des Containers beträgt 500 Pixel, was bedeutet, dass die Fußzeile (100%) ebenfalls 500 Pixel beträgt, bevor dieser Größe Auffüllungen hinzugefügt werden. <br><br>  Das Problem kann durch eine von zwei gängigen Techniken behoben werden: <br><br><ol><li>  Verwenden Sie die Box-Sizing-Eigenschaft für die Fußzeile direkt oder über den zuvor genannten Reset <br></li><li>  Entfernen Sie die Eigenschaft <code>width</code> aus dem Element und verwenden Sie stattdessen die Eigenschaften <code>left: 0</code> und <code>right: 0</code> .  Dies ist ein gutes Beispiel für die gleichzeitige Verwendung der <code>left</code> und <code>right</code> Eigenschaften.  Dieser Ansatz vermeidet die Probleme des Blockmodells, da die <code>width</code> Eigenschaft ihren Standardwert <code>auto</code> , um den verfügbaren Platz zwischen Auffüllung und Rahmen zu füllen, wenn <code>left: 0</code> und <code>right:0</code> . <br></li></ol><br>  <b>Hinweis:</b> Eine Möglichkeit bestand darin, die Polsterung aus der Fußzeile zu entfernen.  Technisch würde dies das Problem beheben, da die Inhaltsschicht zu 100% besteht und keine Auffüllung oder Umrandung aufweist, um über die Breite des Containers hinaus zu expandieren.  Ich denke jedoch, dass diese Lösung der falsche Ansatz ist, da wir unsere Schnittstelle nicht ändern müssen, um uns an die Probleme des Blockmodells anzupassen, die ohne sie leicht behoben werden können. <br><br>  Die Realität für mich ist, dass ich immer die Eigenschaft <code>box-sizing: border-box</code> als Teil meines allgemeinen Stil-Resets festgelegt habe.  Wenn Sie dasselbe tun, tritt dieses Problem höchstwahrscheinlich selten auf.  Aber ich mag immer noch die Technik, bei der die Eigenschaften <code>left:0</code> und <code>right:0</code> gleichzeitig eingestellt werden, da sie, wie die Zeit zeigt, zuverlässiger ist (nach meiner Erfahrung auf jeden Fall), als die Probleme des Blockmodells zu lösen, die aufgrund der Breite auftreten 100% <br><br><h2>  Frage 7: Absolute und feste Elemente zentrieren </h2><br>  Jetzt fangen wir wirklich an, das gesamte oben beschriebene Material mit der Zentrierung der absoluten und festen Elemente zu kombinieren: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/bradwestfall/embed/preview/Orbywd" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Da wir den größten Teil des Materials in dieser Testfrage bereits behandelt haben, möchte ich lediglich darauf hinweisen, dass die horizontale und vertikale Zentrierung mithilfe der Old-School-Methode durch negative Ränder oder neuer mithilfe der Transformationseigenschaft erfolgen kann.  Ich mache Sie auch auf eine ausgezeichnete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anleitung zur CSS-Tricks-Elementzentrierung aufmerksam</a> . <br><br>  <b>Hinweis</b> : Vor einiger Zeit wurde argumentiert, dass wir negative Ränder verwenden sollten, wenn wir die Breite und Höhe des Blocks kennen, da diese stabiler funktionieren als die neue Transformationseigenschaft.  Im Moment funktioniert die Transformation stabil und ich verwende diese Eigenschaft fast immer, es sei denn, ich muss vermeiden, den Block in den enthaltenden zu konvertieren. <br><br><h2>  Frage 8: Zentrieren von Elementen in einem normalen Fluss </h2><br>  Flexbox brachte uns viele erstaunliche Werkzeuge, um komplexe Layoutprobleme zu lösen.  Vor seiner Veröffentlichung wurde berichtet, dass die vertikale Zentrierung eine der komplexesten Funktionen war, die in CSS implementiert wurden.  Mit dem Aufkommen von Flexbox ist die vertikale Zentrierung zur Routine geworden: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: flex; } <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: auto; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://codepen.io/bradwestfall/pen/GPNmbM</a> <br>  <b>Hinweis</b> : Beachten Sie, dass bei Flex-Elementen der Rand: auto auf die obere, untere, rechte und linke Seite angewendet wird, um das Element vertikal und horizontal zu zentrieren.  Bisher funktionierte die vertikale Zentrierung für Blockelemente nicht, daher ist der <code>margin: 0 auto;</code> häufig <code>margin: 0 auto;</code> <br><br><h2>  Frage 9: Berechnungen mit verschiedenen Einheiten </h2><br>  Die Verwendung der Funktion calc () ist ideal, wenn Sie mit zwei Maßeinheiten arbeiten müssen, die wir nicht alleine addieren können, oder wenn wir Brüche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">leichter verständlich machen müssen</a> .  Diese Testfrage bietet uns die Möglichkeit herauszufinden, wie das Ergebnis des Ausdrucks <code>calc(100% + 1em)</code> aussehen wird, ausgehend von der Tatsache, dass die Breite des div-Elements 100px beträgt.  Dies kann etwas verwirrend sein, da es in der Tat keine Rolle spielt, dass die Breite des div-Elements 100px beträgt.  Die Prozentsätze beginnen immer mit der Breite des übergeordneten Elements, daher lautete die richtige Antwort: „100% des enthaltenden (übergeordneten) Blocks plus 1em“. <br><br>  Es gibt verschiedene Situationen, in denen ich regelmäßig <code>calc()</code> .  Erstens, wann immer ich etwas um 100% verschieben möchte, aber auch eine feste Menge zusätzlichen Speicherplatzes hinzufügen möchte.  Dropdown-Menüs können ein gutes Beispiel dafür sein: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/bradwestfall/embed/preview/Jwbgzm" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die Besonderheit hierbei ist, dass wir ein Dropdown-Menü erstellen möchten, das zusammen mit den aufrufenden Elementen unterschiedlicher Größe (in diesem Fall zwei verschiedenen Größen von Schaltflächen) verwendet werden kann.  Wir wissen nicht, wie hoch das Element sein wird, das dieses Menü aufruft, aber wir wissen, dass <code>top: 100%</code> den oberen Rand des Dropdown-Menüs am unteren Rand der aufrufenden Schaltfläche platzieren.  Sollte sich jedes Menü am unteren Rand der entsprechenden Schaltfläche plus 0,5em befinden, kann dies mit <code>calc(100% + 0.5em)</code> .  Natürlich könnten wir auch <code>top: 110%</code> , aber diese zusätzlichen 10% würden von der Höhe der Ruftaste und des Containers abhängen. <br><br><h2>  Frage 10: Negative Margen </h2><br>  Im Gegensatz zu positiven Rändern, die Geschwister abstoßen, ziehen negative Ränder sie näher aneinander, <b>ohne Geschwister zu verschieben</b> .  Diese letzte Testfrage bietet zwei Lösungen, die beide den doppelten Rand in unserer Schaltflächengruppe technisch beseitigen. Ich bevorzuge jedoch die Technik mit negativem Rand, da das Löschen der Frames die Ausführung bestimmter Techniken, wie z. B. des Mouseover-Effekts, erschweren würde. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/bradwestfall/embed/preview/ZVBgGp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Der resultierende Effekt ist ein „gemeinsamer Rand“, der zwischen den Schaltflächen angezeigt wird.  Tatsächlich können Schaltflächen keinen gemeinsamen Rand haben, daher müssen wir eine Technik mit negativem Rand verwenden, damit ein Frame einen anderen überlappt.  Dann benutze ich den <code>z-index</code> um festzulegen, welcher Frame über einen anderen angepasst werden soll, basierend auf dem Status des Maus-Hovers.  Beachten Sie, dass der <code>z-index</code> hier auch ohne absolute Positionierung nützlich ist, Sie jedoch die <code>position: relative</code> einstellen mussten.  Wenn ich die Technik zum Entfernen des linken Rahmens der zweiten Schaltfläche verwenden würde, wäre dieser Effekt viel schwieriger zu implementieren. <br><br><h2>  Das alles macht Sinn. </h2><br>  Ich möchte Ihnen eine weitere aktuelle Demo zeigen, die viele der zuvor diskutierten Tricks verwendet.  Die Aufgabe besteht darin, Kacheln zu erstellen, die sich unter Berücksichtigung der Einrückung zum linken und rechten Rand des Containers erstrecken.  Mit Kacheln meine ich die Möglichkeit, eine Liste von Blöcken zu haben, die in die nächste Zeile umgebrochen werden, wenn nicht genügend Platz in der Breite vorhanden ist.  Bewegen Sie den Mauszeiger über die Kacheln, um das Ergebnis zu sehen: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/bradwestfall/embed/preview/JwbVRp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ein Hindernis bei der Ausführung dieser Aufgabe ist das Einrücken.  Ohne Polsterung wäre es einfach, Fliesen neben dem linken und rechten Rand des Behälters zu erhalten.  Das Problem ist, dass Einzüge mit Rändern erstellt werden. Wenn wir Ränder auf allen Seiten der Kachel hinzufügen, entstehen zwei Probleme: <br><br><ol><li>  Das Vorhandensein von drei Kacheln mit einer Breite von <code>33.33%</code> in Verbindung mit dem Rand kann nicht in eine Reihe passen.  Obwohl die <code>.tile</code> der <code>.tile</code> es uns ermöglicht, das <code>.tile</code> Element mit <code>.tile</code> und Rändern zu <code>.tile</code> und in <code>33.33%</code> passen, hilft uns dies bei Rändern nicht weiter. Dies bedeutet, dass die berechnete Breite der drei Kacheln mehr als 100% <code>.tile</code> , wodurch die letzte Kachel gezwungen wird, zur nächsten zu wechseln Zeichenfolge. <br></li><li>  Die linken und rechten Kacheln liegen nicht mehr am Rand des Behälters an. <br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das erste Problem kann mit gelöst werden </font></font><code>calc((100% / 3) - 1em)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies bedeutet 33,33% abzüglich des linken und rechten Randes jeder Kachel. Der Zusammenbruch benachbarter Schwesterelemente tritt hier nicht auf, da dies nur am oberen und unteren Rand möglich ist. Infolgedessen ist der horizontale Abstand zwischen zwei Kacheln die Summe zweier Ränder (1em). In diesem Fall gilt der Zusammenbruch auch nicht für den oberen und unteren Rand, da die erste und die letzte Kachel technisch nicht benachbart sind, auch wenn sich optisch eine unter der anderen befindet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit nehmen</font></font><code>calc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drei Kacheln können in eine Reihe passen, berühren jedoch immer noch nicht die Ränder des Behälters. Dazu können wir negative Ränder in der Größe verwenden, die dem linken und rechten Rand jeder Kachel entspricht. Die grün gepunktete Linie im Beispiel ist ein Container, in dem wir negative Ränder anwenden, um Kacheln zu zeichnen, die dem Rand des umgebenden Inhalts entsprechen. Wir können sehen, wie sie in den Auffüllbereich des übergeordneten Elements passen. Dies ist normal, da negative Ränder umgebende benachbarte Elemente nicht abstoßen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Ergebnis erhalten wir Kacheln mit ausreichenden Abständen, die sich von Kante zu Kante ausdehnen, sodass sie an benachbarten Absatz-Tags außerhalb der Kacheln ausgerichtet sind.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt viele Möglichkeiten, Fliesen herzustellen (und normalerweise haben sie ihre Vor- und Nachteile). Zum Beispiel gibt es eine ziemlich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elegante CSS-Grid-Lösung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , über die Haydon Pickering gesprochen hat. Diese Lösung wird mithilfe einer Technik implementiert, die Anforderungen für Container simuliert (jedoch mithilfe von Grid Magic). Letztendlich ist seine Lösung mit Grid besser als die Flexbox, die ich demonstriert habe, aber eine schlechtere Browserunterstützung hat.</font></font><br><br><h2>  Zusammenfassung </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Anfang gab ich an, dass ich geneigt war, nach Mustern bei der Lösung von Problemen zu suchen. </font><font style="vertical-align: inherit;">In diesem Artikel geht es nicht so sehr um die oben gezeigten Szenarien. </font><font style="vertical-align: inherit;">Es geht mehr um eine Reihe von Werkzeugen, mit denen diese und viele andere Satzprobleme gelöst werden können, mit denen wir alle konfrontiert sind. </font><font style="vertical-align: inherit;">Ich hoffe, diese Tools helfen Ihnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übrigens gibt es eine Reihe hervorragender Ressourcen, die das Thema des Blockmodells sorgfältig untersuchen. </font><font style="vertical-align: inherit;">Zunächst Artikel von Rachel Andrew und Jen Simmons, die auf jeden Fall lesenswert sind.</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Box Alignment Cheatsheet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein großartiges Material mit visuellen Elementen, die verschiedene Eigenschaften hervorheben, die sich darauf auswirken, wie die Elemente entweder alleine oder relativ zu anderen Elementen ausgerichtet werden.</font></font><br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jen Simmons Labs</a> —   ,        . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467555/">https://habr.com/ru/post/de467555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467543/index.html">Ssh-Chat, Teil 2</a></li>
<li><a href="../de467545/index.html">ShIoTiny: eine Uhr ohne Feder oder Echtzeit und wie man damit arbeitet</a></li>
<li><a href="../de467547/index.html">ILV-Sperren mit DNSTap und BGP umgehen</a></li>
<li><a href="../de467549/index.html">SpaceX plant, das Satelliten-Internet-Netzwerk früher als geplant bereitzustellen</a></li>
<li><a href="../de467551/index.html">Frontend Weekly Digest (9. - 15. September 2019)</a></li>
<li><a href="../de467557/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 380 (8. - 15. September 2019)</a></li>
<li><a href="../de467559/index.html">Digitale Veranstaltungen in Moskau vom 16. bis 22. September</a></li>
<li><a href="../de467561/index.html">Ein Tag vom PVS-Studio User Support</a></li>
<li><a href="../de467563/index.html">Ein Tag von der PVS-Studio-Benutzerunterstützung</a></li>
<li><a href="../de467567/index.html">Unterstützung für 24-Bit-Farben im Terminal in einer Reihe von ssh + tmux + neovim</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>