<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüåæ üåø ‚ô†Ô∏è Meine erste Erfahrung mit der Wiederherstellung einer Postgres-Datenbank nach einem Absturz (ung√ºltige Seite in Block 4123007 von relatton base / 16490) üåø üê¢ üí§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich m√∂chte Ihnen meine ersten erfolgreichen Erfahrungen mit der Wiederherstellung der vollst√§ndigen Funktionalit√§t der Postgres-Datenbank mitteilen. I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meine erste Erfahrung mit der Wiederherstellung einer Postgres-Datenbank nach einem Absturz (ung√ºltige Seite in Block 4123007 von relatton base / 16490)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477248/">  Ich m√∂chte Ihnen meine ersten erfolgreichen Erfahrungen mit der Wiederherstellung der vollst√§ndigen Funktionalit√§t der Postgres-Datenbank mitteilen.  Ich habe Postgres DBMS vor einem halben Jahr getroffen, bevor ich √ºberhaupt keine Erfahrung in der Datenbankadministration hatte. <br><br><img src="https://habrastorage.org/webt/zf/35/tb/zf35tb0kz_lvnsdbyagxaueaffy.jpeg"><br><br>  Ich arbeite als Semi-DevOps-Ingenieur in einem gro√üen IT-Unternehmen.  Unser Unternehmen entwickelt Software f√ºr hochgeladene Dienste, aber ich bin f√ºr die Leistung, Wartung und Bereitstellung verantwortlich.  Sie haben eine Standardaufgabe f√ºr mich festgelegt: Aktualisieren Sie die Anwendung auf einem Server.  Die Anwendung ist in Django geschrieben, w√§hrend des Upgrades werden Migrationen durchgef√ºhrt (√Ñnderung der Datenbankstruktur) und vor diesem Vorgang wird der vollst√§ndige Datenbankspeicherauszug durch das Standardprogramm pg_dump f√ºr alle F√§lle entfernt. <br><br>  Beim Entfernen des Dumps ist ein unerwarteter Fehler aufgetreten (Postgres-Version 9.5): <br><br><pre><code class="plaintext hljs">pg_dump: Oumping the contents of table ‚Äúws_log_smevlog‚Äù failed: PQgetResult() failed. pg_dump: Error message from server: ERROR: invalid page in block 4123007 of relatton base/16490/21396989 pg_dump: The command was: COPY public.ws_log_smevlog [...] pg_dunp: [parallel archtver] a worker process dled unexpectedly</code> </pre> <br>  Der Fehler <i>"Ung√ºltige Seite im Block"</i> weist auf Probleme auf Dateisystemebene hin, die sehr schlimm sind.  In verschiedenen Foren wurde vorgeschlagen, <i>FULL</i> <i>VACUUM</i> mit der Option <i>zero_damaged_pages</i> zu <i>erstellen</i> , um dieses Problem zu l√∂sen.  Nun, Popprobeum ... <br><a name="habracut"></a><br><h4>  Vorbereitung der Wiederherstellung </h4><br>  <b>ACHTUNG!</b>  Sichern Sie Postgres unbedingt, bevor Sie versuchen, die Datenbank wiederherzustellen.  Wenn Sie √ºber eine virtuelle Maschine verf√ºgen, stoppen Sie die Datenbank und erstellen Sie einen Snapshot.  Wenn es nicht m√∂glich ist, einen Schnappschuss zu erstellen, stoppen Sie die Datenbank und kopieren Sie den Inhalt des Postgres-Verzeichnisses (einschlie√ülich der Wal-Dateien) an einen sicheren Ort.  Die Hauptsache in unserem Gesch√§ft ist es, die Dinge nicht noch schlimmer zu machen.  Lesen Sie <a href="https://wiki.postgresql.org/wiki/Corruption">dies</a> . <br><br>  Da die Datenbank f√ºr mich insgesamt funktionierte, beschr√§nkte ich mich auf den √ºblichen Datenbankspeicherauszug, schloss jedoch die Tabelle mit besch√§digten Daten aus (Option <i>-T, --exclude-table = TABLE</i> in pg_dump). <br><br>  Der Server war physisch, es war unm√∂glich, einen Schnappschuss zu machen.  Die Sicherung wird entfernt, fahren Sie fort. <br><br><h4>  Dateisystempr√ºfung </h4><br>  Bevor Sie versuchen, die Datenbank wiederherzustellen, m√ºssen Sie sicherstellen, dass im Dateisystem selbst alles in Ordnung ist.  Und korrigieren Sie sie im Fehlerfall, sonst k√∂nnen Sie es nur noch schlimmer machen. <br><br>  In meinem Fall wurde das Dateisystem mit der Datenbank in <i>"/ srv" eingebunden</i> und der Typ war ext4. <br><br>  Wir stoppen die Datenbank: <i>systemctl stop postgresql@9.5-main.service</i> und √ºberpr√ºfen, ob das Dateisystem von niemandem verwendet wird und ob es mit dem <i>Befehl lsof</i> <i>ausgeh√§ngt werden</i> kann: <br>  <i>lsof + D / srv</i> <br><br>  Ich musste die Redis-Datenbank immer noch stoppen, da sie auch <i>"/ srv" verwendete</i> .  Als n√§chstes habe ich <i>/ srv</i> (umount) <i>abgeh√§ngt</i> . <br><br>  Das √úberpr√ºfen des Dateisystems wurde mit dem Dienstprogramm <i>e2fsck</i> mit der Option -f durchgef√ºhrt ( <i>√úberpr√ºfung</i> <i>erzwingen</i> <i>, auch wenn das Dateisystem als sauber markiert ist</i> ): <br><br><img src="https://habrastorage.org/webt/8_/zj/d_/8_zjd_jjdoiq_kg_qgndbq3mjpm.png"><br><br>  Anschlie√üend k√∂nnen Sie mit dem Dienstprogramm <i>dumpe2fs</i> ( <i>sudo dumpe2fs / dev / mapper / gu2 - sys-srv | grep checked</i> ) <i>√ºberpr√ºfen</i> , ob die Pr√ºfung tats√§chlich durchgef√ºhrt wurde: <br><br><img src="https://habrastorage.org/webt/i7/on/oe/i7onoelytrz8ihbjndgqrmkn37i.png"><br><br>  <i>e2fsck</i> gibt an, dass auf der Ebene des ext4-Dateisystems keine Probleme <i>aufgetreten sind.</i> Sie k√∂nnen also weiterhin versuchen, die Datenbank wiederherzustellen, oder stattdessen zu <i>Vakuum zur√ºckkehren</i> (nat√ºrlich m√ºssen Sie das Dateisystem wieder einbinden und die Datenbank starten). <br><br>  Wenn Ihr Server physisch ist, √ºberpr√ºfen Sie <i>unbedingt</i> den Status der Festplatten (√ºber <i>smartctl -a / dev / XXX</i> ) oder des RAID-Controllers, um sicherzustellen, dass sich das Problem nicht auf der Hardwareebene befindet.  In meinem Fall stellte sich heraus, dass das RAID "iron" war, und ich bat den lokalen Administrator, den Status des RAID zu √ºberpr√ºfen (der Server war mehrere hundert Kilometer von mir entfernt).  Er sagte, dass es keine Fehler gab, was bedeutet, dass wir definitiv mit der Restaurierung beginnen k√∂nnen. <br><br><h4>  Versuch 1: zero_damaged_pages </h4><br>  Wir stellen √ºber das psql-Konto mit Superuser-Rechten eine Verbindung zur Datenbank her.  Wir brauchen genau den Superuser, weil  Nur er kann die Option <i>zero_damaged_pages</i> √§ndern.  In meinem Fall ist dies postgres: <br><br>  <i>psql -h 127.0.0.1 -U postgres -s [Datenbankname]</i> <br><br>  Die Option <i>zero_damaged_pages wird</i> ben√∂tigt, um Lesefehler (von der postgrespro-Website) zu ignorieren: <br><blockquote>  Wenn ein besch√§digter Seitentitel erkannt wird, meldet Postgres Pro normalerweise einen Fehler und bricht die aktuelle Transaktion ab.  Wenn der Parameter zero_damaged_pages aktiviert ist, gibt das System stattdessen eine Warnung aus, l√∂scht die besch√§digte Seite im Speicher und setzt die Verarbeitung fort.  Dieses Verhalten zerst√∂rt Daten, n√§mlich alle Zeilen in der besch√§digten Seite. </blockquote>  Aktivieren Sie die Option und versuchen Sie, vollst√§ndige Vakuumtabellen zu erstellen: <br><br><pre> <code class="plaintext hljs">VACUUM FULL VERBOSE</code> </pre> <br><img src="https://habrastorage.org/webt/ft/ym/m1/ftymm1cwyqwpdunlfmecfa1seas.png"><br>  Leider gescheitert. <br><br>  Wir sind auf einen √§hnlichen Fehler gesto√üen: <br><br><pre> <code class="plaintext hljs">INFO: vacuuming "‚Äúpublic.ws_log_smevlog‚Äù WARNING: invalid page in block 4123007 of relation base/16400/21396989; zeroing out page ERROR: unexpected chunk number 573 (expected 565) for toast value 21648541 in pg_toast_106070</code> </pre> <br>  <i><a href="https://postgrespro.ru/docs/postgrespro/9.5/storage-toast">pg_toast</a></i> - der Mechanismus zum Speichern von "langen Daten" in Postgres, wenn diese nicht auf dieselbe Seite passen (standardm√§√üig 8 KB). <br><br><h4>  Versuch 2: Neu indizieren </h4><br>  Der erste Google-Tipp hat nicht geholfen.  Nach ein paar Minuten der Suche fand ich einen zweiten Tipp - <i>eine</i> besch√§digte Tabelle neu <i>indizieren</i> zu lassen.  Ich habe diesen Rat an vielen Stellen erhalten, aber er hat kein Vertrauen geweckt.  Neu indizieren: <br><br><pre> <code class="plaintext hljs">reindex table ws_log_smevlog</code> </pre> <br><img src="https://habrastorage.org/webt/km/kx/ny/kmkxnywf16bm7hywt5wu-zchofq.png"><br><br>  <i>Neuindizierung</i> ohne Probleme abgeschlossen. <br><br>  Dies half jedoch nicht, <i>VACUUM FULL</i> st√ºrzte mit einem √§hnlichen Fehler ab.  Da ich an Ausf√§lle gew√∂hnt war, suchte ich im Internet weiter nach Rat und stie√ü auf einen recht interessanten <a href="https://newbiedba.wordpress.com/2015/07/07/postgresql-missing-chunk-0-for-toast-value-in-pg_toast/">Artikel</a> . <br><br><h4>  Versuch 3: SELECT, LIMIT, OFFSET </h4><br>  In dem obigen Artikel wurde vorgeschlagen, die Tabelle zeilenweise zu betrachten und die problematischen Daten zu l√∂schen.  Zu Beginn war es notwendig, alle Zeilen zu betrachten: <br><br><pre> <code class="plaintext hljs">for ((i=0; i&lt;"Number_of_rows_in_nodes"; i++ )); do psql -U "Username" "Database Name" -c "SELECT * FROM nodes LIMIT 1 offset $i" &gt;/dev/null || echo $i; done</code> </pre> <br>  In meinem Fall enthielt die Tabelle <i>1.628.991</i> Zeilen!  In guter Weise war es notwendig, die <a href="https://postgrespro.ru/docs/postgresql/10/ddl-partitioning">Partitionierung der Daten zu gew√§hrleisten</a> , aber dies ist ein Thema f√ºr eine separate Diskussion.  Es war Samstag, ich habe diesen Befehl in tmux ausgef√ºhrt und bin schlafen gegangen: <br><br><pre> <code class="plaintext hljs">for ((i=0; i&lt;1628991; i++ )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog LIMIT 1 offset $i" &gt;/dev/null || echo $i; done</code> </pre> <br>  Am Morgen beschloss ich zu √ºberpr√ºfen, wie es lief.  Zu meiner √úberraschung stellte ich fest, dass in 2 Stunden nur 2% der Daten gescannt wurden!  Ich wollte nicht 50 Tage warten.  Ein weiterer v√∂lliger Misserfolg. <br><br>  Aber ich habe nicht aufgegeben.  Ich fragte mich, warum der Scan so lange dauerte.  Aus der Dokumentation (wieder auf postgrespro) habe ich herausgefunden: <br><blockquote>  OFFSET gibt an, dass die angegebene Anzahl von Zeilen √ºbersprungen werden soll, bevor mit der Erzeugung von Zeilen begonnen wird. <br>  Wenn sowohl OFFSET als auch LIMIT angegeben sind, √ºberspringt das System zuerst OFFSET-Zeilen und beginnt dann, Zeilen zu z√§hlen, um LIMIT zu begrenzen. <br><br>  Bei Verwendung von LIMIT ist es auch wichtig, die ORDER BY-Klausel zu verwenden, damit die Ergebniszeilen in einer bestimmten Reihenfolge zur√ºckgegeben werden.  Andernfalls werden unvorhersehbare Teilmengen von Zeichenfolgen zur√ºckgegeben. </blockquote>  Offensichtlich war der obige Befehl fehlerhaft: Erstens gab es keine <i>Reihenfolge</i> , das Ergebnis konnte fehlerhaft sein.  Zweitens musste Postgres zuerst OFFSET-Zeilen scannen und √ºberspringen, und mit einer Zunahme von <i>OFFSET</i> w√ºrde die Leistung noch mehr sinken. <br><br><h4>  Versuch 4: Entfernen Sie den Speicherauszug in Textform </h4><br>  Au√üerdem kam mir eine scheinbar brillante Idee in den Sinn, den Dump in Textform zu entfernen und die letzte aufgezeichnete Zeile zu analysieren. <br><br>  Aber zuerst schauen <i>wir</i> uns die Tabellenstruktur von <i>ws_log_smevlog an</i> : <br><br><img src="https://habrastorage.org/webt/hv/_u/qk/hv_uqkxblnoxsivawvjrwepqyz8.png"><br><br>  In unserem Fall haben wir eine Spalte <i>‚Äûid‚Äú</i> , die einen eindeutigen Bezeichner (Z√§hler) f√ºr die Zeile enth√§lt.  Der Plan war: <br><br><ol><li>  Wir fangen an, den Dump in Textform (in Form von SQL-Befehlen) zu entfernen. </li><li>  Zu einem bestimmten Zeitpunkt wurde der Speicherauszug aufgrund eines Fehlers unterbrochen, die Textdatei wurde jedoch weiterhin auf der Festplatte gespeichert </li><li>  Wir schauen uns das Ende der Textdatei an und finden dabei den Identifier (id) der letzten Zeile, die erfolgreich aufgenommen wurde </li></ol><br>  Ich habe begonnen, den Dump in Textform zu entfernen: <br><br><pre> <code class="plaintext hljs">pg_dump -U my_user -d my_database -F p -t ws_log_smevlog -f ./my_dump.dump</code> </pre> <br>  Der Dump Dump wurde wie erwartet mit demselben Fehler unterbrochen: <br><br><pre> <code class="plaintext hljs">pg_dump: Error message from server: ERROR: invalid page in block 4123007 of relatton base/16490/21396989</code> </pre> <br>  Au√üerdem habe ich durch <i>tail</i> auf das Ende des Dumps ( <i>tail -5 ./my_dump.dump</i> ) <i>geschaut</i> und festgestellt, dass der Dump auf der Leitung mit der ID <i>186 525</i> unterbrochen wurde.  "Das Problem liegt also in der ID 186 526, es ist kaputt und muss gel√∂scht werden!", Dachte ich.  Aber indem Sie eine Anfrage an die Datenbank stellen: <br>  " <i>W√§hlen Sie * aus ws_log_smevlog, wobei id = 186529</i> ". Es stellte sich heraus, dass mit dieser Zeile alles in Ordnung war. Zeilen mit den Indizes 186 530 - 186 540 funktionierten ebenfalls problemlos.  Eine weitere ‚Äûgeniale Idee‚Äú ist gescheitert.  Sp√§ter habe ich verstanden, warum dies passiert ist: Beim L√∂schen / √Ñndern von Daten aus der Tabelle werden diese nicht physisch gel√∂scht, sondern als "tote Tupel" markiert. Anschlie√üend wird <i>automatisch ein Vakuum erzeugt,</i> das diese Zeilen als gel√∂scht markiert und die erneute Verwendung dieser Zeilen erm√∂glicht.  Wenn die Daten in der Tabelle ge√§ndert und das automatische Vakuum aktiviert werden, werden sie nicht nacheinander gespeichert. <br><br><h4>  Versuch 5: SELECT, FROM, WHERE id = </h4><br>  Misserfolge machen uns st√§rker.  Du solltest niemals aufgeben, du musst bis zum Ende gehen und an dich und deine F√§higkeiten glauben.  Aus diesem Grund habe ich mich f√ºr eine weitere Option entschieden: Zeigen Sie alle Eintr√§ge in der Datenbank einzeln an.  Wenn wir die Struktur meiner Tabelle kennen (siehe oben), haben wir ein eindeutiges ID-Feld (Prim√§rschl√ºssel).  In der Tabelle haben wir 1.628.991 Zeilen und <i>id</i> geht in Reihenfolge, was bedeutet, dass wir sie einfach einzeln durchlaufen k√∂nnen: <br><br><pre> <code class="plaintext hljs">for ((i=1; i&lt;1628991; i=$((i+1)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id=$i" &gt;/dev/null || echo $i; done</code> </pre> <br>  Wenn jemand nicht versteht, funktioniert der Befehl wie folgt: Er durchsucht die Tabelle zeilenweise und sendet stdout an <i>/ dev / null</i> . Wenn der SELECT-Befehl jedoch fehlschl√§gt, wird der Fehlertext angezeigt (stderr wird an die Konsole gesendet) und eine Zeile mit dem Fehler ausgegeben (dank ||, der) bedeutet, dass select Probleme hatte (der Befehlsr√ºckgabecode ist nicht 0)). <br><br>  Ich hatte Gl√ºck, ich hatte Indizes auf dem <i>ID-</i> Feld erstellt: <br><br><img src="https://habrastorage.org/webt/k2/yf/tp/k2yftpsxvdq0rtcq_vvrscn0xoq.png"><br><br>  Das bedeutet, dass das Auffinden der Zeile mit der gew√ºnschten ID nicht viel Zeit in Anspruch nehmen sollte.  Theoretisch sollte es funktionieren.  F√ºhren Sie den Befehl in <i>tmux aus</i> und schlafen Sie ein. <br><br>  Am Morgen stellte ich fest, dass ungef√§hr 90.000 Datens√§tze angezeigt wurden, was etwas mehr als 5% entspricht.  Hervorragendes Ergebnis im Vergleich zur vorherigen Methode (2%)!  Aber ich wollte nicht 20 Tage warten ... <br><br><h4>  Versuch 6: SELECT, FROM, WHERE id&gt; = und id &lt; </h4><br>  Unter der Datenbank wurde dem Kunden ein ausgezeichneter Server zugewiesen: <i>Intel Xeon E5-2697 v2 mit</i> zwei Prozessoren, an unserem Standort gab es bis zu 48 Threads!  Die Serverauslastung war durchschnittlich, wir konnten problemlos ca. 20 Threads aufnehmen.  RAM war auch genug: 384 Gigabyte! <br><br>  Daher musste der Befehl parallelisiert werden: <br><br><pre> <code class="plaintext hljs">for ((i=1; i&lt;1628991; i=$((i+1)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id=$i" &gt;/dev/null || echo $i; done</code> </pre> <br>  Hier war es m√∂glich, ein sch√∂nes und elegantes Skript zu schreiben, aber ich habe den schnellsten Weg f√ºr die Parallelisierung gew√§hlt: Teilen Sie den Bereich 0-1628991 manuell in Intervalle von 100.000 Datens√§tzen auf und f√ºhren Sie 16 Befehle des Formulars separat aus: <br><br><pre> <code class="plaintext hljs">for ((i=N; i&lt;M; i=$((i+1)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id=$i" &gt;/dev/null || echo $i; done</code> </pre> <br>  Das ist aber noch nicht alles.  Theoretisch erfordert das Herstellen einer Verbindung zu einer Datenbank auch einige Zeit und Systemressourcen.  1.628.991 zu verbinden war nicht sehr vern√ºnftig, stimme zu.  Extrahieren wir daher 1000 Zeilen in einer Verbindung anstelle von einer.  Infolgedessen hat sich das Team in Folgendes verwandelt: <br><br><pre> <code class="plaintext hljs">for ((i=N; i&lt;M; i=$((i+1000)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id&gt;=$i and id&lt;$((i+1000))" &gt;/dev/null || echo $i; done</code> </pre> <br>  √ñffne 16 Fenster in der tmux-Sitzung und f√ºhre die folgenden Befehle aus: <br><blockquote><pre> <code class="plaintext hljs">1) for ((i=0; i&lt;100000; i=$((i+1000)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id&gt;=$i and id&lt;$((i+1000))" &gt;/dev/null || echo $i; done 2) for ((i=100000; i&lt;200000; i=$((i+1000)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id&gt;=$i and id&lt;$((i+1000))" &gt;/dev/null || echo $i; done ‚Ä¶ 15) for ((i=1400000; i&lt;1500000; i=$((i+1000)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id&gt;=$i and id&lt;$((i+1000))" &gt;/dev/null || echo $i; done 16) for ((i=1500000; i&lt;1628991; i=$((i+1000)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id&gt;=$i and id&lt;$((i+1000))" &gt;/dev/null || echo $i; done</code> </pre> </blockquote>  Einen Tag sp√§ter bekam ich die ersten Ergebnisse!  N√§mlich (die Werte XXX und ZZZ wurden nicht beibehalten): <br><br><pre> <code class="plaintext hljs">ERROR: missing chunk number 0 for toast value 37837571 in pg_toast_106070 829000 ERROR: missing chunk number 0 for toast value XXX in pg_toast_106070 829000 ERROR: missing chunk number 0 for toast value ZZZ in pg_toast_106070 146000</code> </pre> <br>  Dies bedeutet, dass drei Zeilen einen Fehler enthalten.  Die ID des ersten und zweiten Problemdatensatzes lag zwischen 829.000 und 830.000, die ID des dritten zwischen 146.000 und 147.000. Als N√§chstes mussten wir nur den genauen ID-Wert der Problemdatens√§tze ermitteln.  Durchsuchen Sie dazu unser Sortiment mit Problemaufzeichnungen in Schritt 1 und identifizieren Sie die ID: <br><blockquote><pre> <code class="plaintext hljs">for ((i=829000; i&lt;830000; i=$((i+1)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id=$i" &gt;/dev/null || echo $i; done 829417 ERROR: unexpected chunk number 2 (expected 0) for toast value 37837843 in pg_toast_106070 829449 for ((i=146000; i&lt;147000; i=$((i+1)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id=$i" &gt;/dev/null || echo $i; done 829417 ERROR: unexpected chunk number ZZZ (expected 0) for toast value XXX in pg_toast_106070 146911</code> </pre> </blockquote><h4>  Happy End </h4><br>  Wir haben die problematischen Linien gefunden.  Wir gehen √ºber psql in die Datenbank und versuchen, sie zu entfernen: <br><br><pre> <code class="plaintext hljs">my_database=# delete from ws_log_smevlog where id=829417; DELETE 1 my_database=# delete from ws_log_smevlog where id=829449; DELETE 1 my_database=# delete from ws_log_smevlog where id=146911; DELETE 1</code> </pre> <br>  Zu meiner √úberraschung wurden die Eintr√§ge ohne Probleme gel√∂scht, auch ohne die Option <i>zero_damaged_pages</i> . <br><br>  Dann stellte ich eine Verbindung zur Datenbank her, machte <i>VACUUM FULL</i> (ich glaube, es war nicht notwendig, dies zu tun) und entfernte schlie√ülich erfolgreich die Sicherung mit <i>pg_dump</i> .  Der Dump war fehlerfrei!  Das Problem wurde auf so bl√∂de Weise gel√∂st.  Der Freude waren keine Grenzen gesetzt, nach so vielen Misserfolgen gelang es uns, eine L√∂sung zu finden! <br><br><h4>  Danksagung und Schlussfolgerungen </h4><br>  Dies ist meine erste Erfahrung bei der Wiederherstellung einer echten Postgres-Datenbank.  Ich werde mich noch lange an diese Erfahrung erinnern. <br><br>  Abschlie√üend m√∂chte ich mich bei PostgresPro f√ºr die √ºbersetzte Dokumentation ins Russische und f√ºr die <a href="https://postgrespro.ru/education/courses/DBA1">v√∂llig kostenlosen Online-Kurse</a> bedanken, die bei der Analyse des Problems sehr hilfreich waren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477248/">https://habr.com/ru/post/de477248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477234/index.html">Die Maus, die den Drahtbr√ºdern ein Ende gesetzt hat</a></li>
<li><a href="../de477236/index.html">Das US-Gericht gestattet den Staaten, die Netzneutralit√§t wiederherzustellen</a></li>
<li><a href="../de477238/index.html">Pluspunkt f√ºr Karma: Wof√ºr Stapel√ºberlauf kritisiert wird und warum sich viele √ºber die Toxizit√§t in der Gemeinschaft beschweren</a></li>
<li><a href="../de477242/index.html">Wie wir uns f√ºr ServiceDesk entschieden haben. Teil 3</a></li>
<li><a href="../de477244/index.html">Verst√§ndliches RayTracing in 256 Zeilen C ++</a></li>
<li><a href="../de477250/index.html">Sie m√∂chten Windows 10 auf einem Taschenrechner ausf√ºhren? okay</a></li>
<li><a href="../de477252/index.html">Wie sich Business Incubators und Accelerators entwickelten: Vom Thomas Edison Labor zum Y Combinator</a></li>
<li><a href="../de477254/index.html">XSS-, CSRF- und Flash-Authentifizierung. Probleml√∂sung mit r0ot-mi Web - Client. Teil 2</a></li>
<li><a href="../de477256/index.html">Der erste vollst√§ndige Start von OneWeb mit der Tr√§gerrakete Sojus wird im n√§chsten Jahr verschoben, ebenso wie der Start der Tr√§gerrakete Angara</a></li>
<li><a href="../de477262/index.html">Androiden der Firma Promobot. Seitenansicht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>