<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìµ üë¥üèΩ üëÇüèΩ Engenharia reversa do firmware do dispositivo usando o exemplo de um "rinoceronte" intermitente. Parte 2 üëºüèª ‚ÅâÔ∏è üèÇüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apresentamos a sua aten√ß√£o a segunda parte do artigo sobre engenharia reversa do firmware do dispositivo Flashing Rhino, com base na classe principal ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Engenharia reversa do firmware do dispositivo usando o exemplo de um "rinoceronte" intermitente. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/inforion/blog/412561/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ny/yo/jz/nyyojzktr_-hcfv4j7ygq_eaiuu.png"></div><br>  Apresentamos a sua aten√ß√£o a segunda parte do artigo sobre engenharia reversa do firmware do dispositivo Flashing Rhino, com base na classe principal da confer√™ncia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SMARTRHINO-2018</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Na primeira parte do</a> artigo, o firmware do dispositivo foi carregado no desmontador IDA e uma an√°lise inicial dos comandos do protocolo do dispositivo foi realizada.  Comandos individuais foram testados em um dispositivo em funcionamento. <br><br>  Na segunda parte, uma an√°lise das tarefas restantes do firmware ser√° realizada. <br><br>  Deixe-me lembr√°-lo, depois de analisar a tarefa Bluetooth em termos de controle de LEDs, foi decidido mudar para a tarefa de LED, pois a tarefa inicial √© criar um aplicativo para controlar LEDs e, para isso, √© necess√°rio um entendimento detalhado da opera√ß√£o do firmware. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O arquivo de firmware</a> est√° dispon√≠vel para estudo independente. <br><br>  <i>Todas as informa√ß√µes s√£o fornecidas apenas para fins educacionais.</i> <br><br>  Sob o gato, h√° muitos rinocerontes piscando. <br><a name="habracut"></a><br><h2>  Tarefa de LED </h2><br>  <i>Resumidamente: uma an√°lise completa da tarefa respons√°vel pela troca de LEDs.</i>  <i>An√°lise de tipos de dados e vari√°veis ‚Äã‚Äãglobais.</i> <br><br>  A tarefa do LED √© representada pela fun√ß√£o <b>x_leds_task</b> , localizada em <code>0x08005A08</code> . <br><br>  Al√©m das linhas estranhas "Eu tenho uma super pot√™ncia ..." na fun√ß√£o principal da tarefa de LED, voc√™ pode prestar aten√ß√£o √† linha <b>"matiz&gt; max: mudar o brilho \ r \ n"</b> . <br><br><img src="https://habrastorage.org/webt/6j/7u/qv/6j7uqvcupizmfsbqca81as5dwlw.png"><br><br>  Ao mesmo tempo, vemos uma situa√ß√£o familiar - (PALAVRA *) (v26 + 4).  No menu de contexto da vari√°vel v26, selecione o item "Converter em struct *" e indique a estrutura criada anteriormente: <br><br><img src="https://habrastorage.org/webt/6a/2i/jv/6a2ijvqm631yl3ce5z6uom02znw.png"><br><br>  Dado que <code>v5 = v26</code> , repetimos a opera√ß√£o <i>‚ÄúConvert to struct *‚Äù</i> para a vari√°vel v5. <br><br>  Continuamos a estruturar o c√≥digo e os dados.  Defina a representa√ß√£o hexadecimal em qualquer lugar.  Renomear: <br><br><ul><li>  v5 - <b>led</b> ; </li><li>  v6 - <b>idx</b> ; </li><li>  v8 - <b>matiz_1</b> ; </li><li>  v9 - <b>matiz_2</b> ; </li><li>  v26 - <b>_led</b> ; </li></ul><br>  O c√≥digo est√° melhorando.  Mas algumas vari√°veis ‚Äã‚Äãainda machucam os olhos, por exemplo, a vari√°vel v23: <br><br><img src="https://habrastorage.org/webt/pz/cp/ch/pzcpchfjgrlwgwwtbun85x6weve.png"><br><br><img src="https://habrastorage.org/webt/k1/4k/fi/k14kfil99uzjgtwdpimtjcrl-ye.png"><br><br><div class="spoiler">  <b class="spoiler_title">Aparentemente, a v23 √© uma matriz de 4 bytes.</b> <div class="spoiler_text">  idx √© o √≠ndice do LED;  esse √≠ndice √© adicionado ao endere√ßo base;  dessa maneira, o acesso √© feito a elementos com os mesmos deslocamentos - √© assim que as matrizes se comportam. <br></div></div><br>  N√≥s atribu√≠mos o tipo <code>char v23[4]</code> e o renomeamos para <b>leds_smth</b> , o c√≥digo se torna mais bonito: <br><br><img src="https://habrastorage.org/webt/3a/zp/vv/3azpvvasy-8oabd8be6tshcy6z8.png"><br><br>  Voc√™ tamb√©m pode observar que o resultado da fun√ß√£o x_queue_recv √© retornado para a vari√°vel v25: <br><br><pre> <code class="cpp hljs">x_queue_recv(&amp;v25, leds_queue, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  Mas pode n√£o estar claro como os dados necess√°rios est√£o na estrutura <i>_led</i> .  O fato √© que as vari√°veis ‚Äã‚Äãv25 e _led <b><i>est√£o localizadas</i></b> uma <b><i>na outra na pilha</i></b> - isso pode ser entendido pelo fato de que na descompila√ß√£o elas s√£o escritas em linhas adjacentes.  A localiza√ß√£o das vari√°veis ‚Äã‚Äãna pilha pode ser vista em uma janela separada se voc√™ clicar duas vezes na vari√°vel: <br><br><img src="https://habrastorage.org/webt/gm/1z/qs/gm1zqsoxvvppvneguj76arsppdu.png"><br><br>  Eles provavelmente s√£o uma estrutura ou o compilador fez alguma otimiza√ß√£o.  Assim, pode-se argumentar que os dados da tarefa Bluetooth s√£o transmitidos para a tarefa LED.  Para saber com mais precis√£o, vou verificar o dispositivo - para o LED zero via Bluetooth, enviarei os valores <b>0x208</b> , <b>0x2D0</b> , <b>0x398</b> , <b>0x3E9</b> , que podem ser observados no c√≥digo: <br><br><img src="https://habrastorage.org/webt/f-/1k/ds/f-1kdsphlzdbhuc4q6dwtfk6zge.png"><br><br>  Os resultados da verifica√ß√£o do valor da matiz no dispositivo: <br><br><ul><li>  0x208 - os LEDs pararam de alternar suavemente e foram configurados nas cores: vermelho, verde, azul, roxo; </li><li>  0x2D0 - os LEDs come√ßaram a mudar novamente; </li><li>  0x398 - nada mudou; </li><li>  0x3E9 - nada mudou. </li></ul><br>  Se voc√™ olhar o c√≥digo novamente, poder√° ver que o valor 0x398 pode ser associado logicamente a um valor menor que 0x167 (valores diferentes s√£o definidos para o elemento da matriz <i>leds_smth</i> ).  Portanto, executarei esta verifica√ß√£o: primeiro, <code>LED 010078FF20</code> o primeiro LED para verde (matiz = <code>LED 010078FF20</code> ), enquanto os outros tr√™s LEDs continuar√£o mudando de cor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5h/mp/dc/5hmpdckwscpkhlgvth05w1xvmuy.gif"></div><br>  Agora, <code>LED 010398FFFF</code> protocolo Bluetooth - depois disso, o primeiro LED passou para o modo geral de troca de cores. <br><br>  Portanto, o valor de matiz 0x398 redefine o valor est√°tico da cor, o que significa que a matriz leds_smth cont√©m sinalizadores (0 ou 1) para os LEDs serem ocupados: <br><br><ul><li>  0 - o LED n√£o est√° ocupado, participa da altern√¢ncia suave de cores ( <b>matiz = 0x398</b> ); </li><li>  1 - o LED est√° ocupado, o usu√°rio define uma cor est√°tica ( <b>matiz &lt;= 0x167</b> ). </li></ul><br>  Renomeie leds_smth para <b>leds_busy</b> . <br><br>  Agora, o objetivo do seguinte bloco de c√≥digo deve ficar claro: <br><br><img src="https://habrastorage.org/webt/sb/x8/mf/sbx8mfnnah6gziclrsqmgdcmpu0.png"><br><br>  O ciclo nas linhas 83-101 executa um mosaico de cores suave com uma etapa de troca de cores de 5: <code>v12 += 5</code> .  Se o LED estiver com uma cor est√°tica acesa, esse LED n√£o participar√° do mosaico.  Ap√≥s o ciclo, existem linhas de inclus√£o a curto prazo de todos os LEDs. <br><br>  Renomear: <br><br><ul><li>  sub_800678A - <b>x_led_set_hsv</b> ; </li><li>  v12 - <b>hue_step</b> ; </li><li>  v13, v17, v18, v19 - <b>led0_busy</b> , <b>led1_busy</b> , <b>led2_busy</b> , <b>led3_busy</b> ; </li><li>  v11, v20, v21, v22 - <b>matiz0</b> , <b>matiz1</b> , <b>matiz2</b> , <b>matiz3</b> ; </li><li>  dword_200004C4 - <b>led_control</b> . </li></ul><br>  A fun√ß√£o sub_80039FE presumivelmente executa um tempo limite (caso contr√°rio, os LEDs n√£o mudaram suavemente, mas instantaneamente), vamos cham√°-lo de <b>x_sleep</b> e a vari√°vel v16 √© <b>led_timeout</b> . <br><br>  O objetivo da fun√ß√£o sub_8006934 ainda n√£o √© √≥bvio, mas √© usado em todos os lugares ap√≥s a configura√ß√£o da cor nos LEDs - voc√™ pode cham√°-lo de <b>x_led_fix_color</b> . <br><br>  Ap√≥s a renomea√ß√£o, √© f√°cil entender a fun√ß√£o <b>sub_8006944</b> (chamada na tonalidade &lt;= 0x167 branch): <br><br><img src="https://habrastorage.org/webt/nf/8a/j-/nf8aj-jzfsk9livqh_zxpwtojgq.png"><br><br>  Simplesmente realiza uma verifica√ß√£o adicional para determinar a cor do LED.  Renomeie a fun√ß√£o sub_8006944 para <b>x_led_set_hsv_wrap</b> (sufixo <i>_wrap</i> - uma explica√ß√£o de que este √© um "inv√≥lucro" sobre outra fun√ß√£o) e defina o seguinte prot√≥tipo para ela: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_led_set_hsv_wrap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_control, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">signed</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span></span></code> </pre> <br>  Vamos voltar um n√≠vel para a fun√ß√£o x_leds_task.  Mais uma vez olhando para o c√≥digo, voc√™ pode descobrir que o ramo "matiz&gt; 0x3E8" come√ßou a ficar assim: <br><br><img src="https://habrastorage.org/webt/sh/tm/5j/shtm5jrmecd3quimykrcgognngs.png"><br><br>  Ou seja, um valor de matiz maior que 0x3E8 deve alterar o tempo limite do mosaico colorido.  Vou verificar enviando alguns valores para o dispositivo: <br><br><ul><li>  matiz = 0x3E9 - os LEDs come√ßaram a mudar rapidamente: <br><br><img src="https://habrastorage.org/webt/1z/an/to/1zantozqcbgf0ho69jmgbvdd8v8.gif"><br></li><li>  matiz = 0xFFFF - os LEDs come√ßaram a mudar muito lentamente: <br><br><img src="https://habrastorage.org/webt/jr/ty/sn/jrtysngekw8_1ise6uwd0kikrhc.gif"><br></li></ul><br>  Ao sair do ciclo principal da tarefa de LED, a fun√ß√£o <b>sub_8003C44</b> √© <b>usada</b> , que tamb√©m √© usada na fun√ß√£o sub_8005070: <br><br><img src="https://habrastorage.org/webt/ow/ws/ql/owwsqly9wu0bhmwzhu3r7buky5s.png"><br><br>  Renomear: <br><br><ul><li>  sub_8005070 - <b>x_freeMsg</b> ; </li><li>  sub_8003C44 - <b>x_free_queue</b> . </li></ul><br>  Al√©m disso, na tarefa de LED, o seguinte ramo n√£o pode deixar de atrair aten√ß√£o: <br><br><img src="https://habrastorage.org/webt/iu/q6/rr/iuq6rrf54hzoupmpslmnp0r8pcu.png"><br><br>  Voc√™ pode tentar executar o comando de <code>LED B816D8D90000FFFF</code> .  Mas se voc√™ se lembrar de que apenas 2 caracteres s√£o usados ‚Äã‚Äãcomo √≠ndice de LED, uma tentativa de alcan√ßar esse c√≥digo ser√° obviamente malsucedida.  Deixe este t√≥pico para mais tarde.  Renomeie a fun√ß√£o sub_8004AE8 para <b>x_mad_blinking</b> e √© hora de corrigir a assinatura da fun√ß√£o <b>x_printf</b> (da √∫ltima vez que escrevi a assinatura errada): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_printf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *format, ...)</span></span></span></span></code> </pre> <br>  O ciclo principal da tarefa de LED foi desmontado, mas ainda h√° um c√≥digo no in√≠cio da tarefa. <br><br>  Vamos dar uma olhada no c√≥digo: <br><br><img src="https://habrastorage.org/webt/kt/xx/wn/ktxxwnzjvx9eqkkuiydzlro3vz4.png"><br><br>  Na linha 49, √© mais prov√°vel que os LEDs sejam verificados quanto √† disponibilidade e, no caso de um erro, seja feita uma chamada para a fun√ß√£o sub_8004BBC, que desliga as interrup√ß√µes e inicia um loop infinito no qual a linha "../Drivers/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_gpio.c" √© usada.  Provavelmente, √© uma fun√ß√£o de <b>asser√ß√£o</b> ou similar. <br><br>  Renomear: <br><br><ul><li>  sub_8004BBC - <b>x_gpio_assert</b> ; </li><li>  sub_800698C - <b>x_check_gpio</b> . </li></ul><br>  O objetivo da fun√ß√£o <b>sub_8006968</b> ficar√° claro se voc√™ observar atentamente o dispositivo quando ele estiver ligado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i8/ap/t4/i8apt4kjg6rrbu73wzya5noyx6m.gif"></div><br>  Todos os quatro LEDs juntos acendem primeiro vermelho, depois verde e depois azul.  Depois disso, eles s√£o definidos por cor: 0-vermelho, 1-verde, 2-azul, 3-violeta.  E s√≥ ent√£o eles come√ßam a trocar os mosaicos. <br><br>  Como o mosaico inicia no ciclo principal de tarefas, √© l√≥gico que as linhas 58-61 antes do ciclo principal sejam respons√°veis ‚Äã‚Äãpela inclus√£o de curto prazo de cores diferentes nos LEDs, e as linhas 52-56 sejam respons√°veis ‚Äã‚Äãpor definir vermelho-verde-azul em todos os LEDs de uma s√≥ vez.  Renomeie a fun√ß√£o sub_8006968 para <b>x_led_all_set_rgb</b> (RGB - apenas em um palpite, de acordo com os argumentos passados). <br><br><h2>  Extravag√¢ncias na tarefa de LED </h2><br>  <i>Resumidamente: definindo a funcionalidade do c√≥digo que cont√©m linhas estranhas.</i>  <i>Gerando uma senha para o dispositivo.</i> <br><br>  Agora vamos para o in√≠cio da fun√ß√£o x_leds_task: <br><br><img src="https://habrastorage.org/webt/k1/64/2j/k1642jmvbxu5d0a7vs5lrtd3pru.png"><br><br>  <b>"Eraze"</b> , <b>"gen"</b> , <b>"flash"</b> , <b>"redefinir"</b> - por que tudo isso ??? <br><br>  Vamos tentar descobrir. <br><br>  Seja sub_80066BC <b>x_leds_task_init</b> . <br><br>  Vejamos sub_8006B38: <br><br><img src="https://habrastorage.org/webt/qa/80/ez/qa80ezojcnsyo_vz_q1hru7whz8.png"><br><br>  Memset de √°gua pura, concorda? <br><br><img src="https://habrastorage.org/webt/pf/oa/tf/pfoatfwwwasjk338b3lphqiiya4.png"><br><br>  Voltar para x_leds_task.  Algo est√° errado com o tipo de vari√°vel v24: <br><br><img src="https://habrastorage.org/webt/vg/ag/8u/vgag8ujkoylag2iryzujjvjldfu.png"><br><br>  A IDA cometeu um pequeno erro com o tipo, mas um coment√°rio com uma marca de pilha nos ajuda.  Entre as vari√°veis ‚Äã‚Äãv24 e v25 at√© 12 bytes (0x44 - 0x38).  Portanto, renomeamos a v24 para <b>buf</b> e atribu√≠mos o tipo <code>unsigned __int8 buf[12]</code> (Ida <code>unsigned __int8 buf[12]</code> que o novo tipo de dados √© maior que o antigo - concordamos). <br><br>  Pr√≥ximo.  Fun√ß√£o sub_8004CE4: <br><br><img src="https://habrastorage.org/webt/sc/qg/tw/scqgtwrqr1vzlaubtsqstydsqmu.png"><br><br>  Renomeie <i>a1</i> para <b>buf</b> , <i>v1</i> para <b>_buf</b> . <br><br>  Fun√ß√£o sub_8006B26: <br><br><img src="https://habrastorage.org/webt/gs/du/ff/gsduffmdls272wqpmmv6_klqxdm.png"><br><br>  Voc√™ a reconheceu? <br><br><div class="spoiler">  <b class="spoiler_title">E se sem maquiagem?</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/8k/1d/p9/8k1dp9nmxkl0xjktjtsk_cp2vem.png"><br>  Claro <b>memcpy</b> .  Renomeie. <br></div></div><br>  O objetivo da fun√ß√£o sub_8004CE4 √© obter alguns dados no endere√ßo <b>0x08007C00</b> .  A prop√≥sito, esse endere√ßo est√° no intervalo de endere√ßos da mem√≥ria flash do microcontrolador (e firmware, em particular).  Renomeie sub_8004CE4 para <b>x_read_data_0x08007C00</b> . <br><br>  Linha de Fun√ß√£o X_leds_task 36: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">65</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0x19</span></span> )</code> </pre> <br>  Altere a exibi√ß√£o dos dados (tecla R no n√∫mero 65, tecla H no n√∫mero 0x19): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'A'</span></span> &gt; <span class="hljs-number"><span class="hljs-number">25</span></span> )</code> </pre> <br>  Depois de um pouco de reflex√£o, voc√™ pode entender que esse √© um teste do alcance do alfabeto latino AZ. <br><br>  Em seguida, usando os prompts na forma de cadeias de formato, renomeie: <br><br><ul><li>  sub_8004C10 - <b>x_erase</b> ; </li><li>  sub_80059C8 - <b>x_gen</b> ; </li><li>  sub_8004C84 - <b>x_flash</b> . </li></ul><br>  A fun√ß√£o sub_8003C66 n√£o faz nada not√°vel - apenas aumenta alguma vari√°vel global - renomeie sub_8003C66 para <b>x_smth_inc</b> . <br><br>  A fun√ß√£o <b>x_erase</b> n√£o aceita nenhum argumento - isso pode ser verificado no desmontador: <br><br><img src="https://habrastorage.org/webt/rv/p3/_i/rvp3_iqmhzsegjqyi3mugvpxnis.png"><br><br>  Dentro do x_erase, o endere√ßo familiar 0x08007C00 √© usado e tr√™s fun√ß√µes desconhecidas s√£o acessadas: <br><br><img src="https://habrastorage.org/webt/ys/nb/_b/ysnb_bfgd19htkrnmbyo5hudr0m.png"><br><br>  Uma <b>r√°pida olhada</b> nessas tr√™s fun√ß√µes, vemos que elas est√£o acessando endere√ßos no intervalo <b>0x40022000 - 0x400223FF</b> .  A documenta√ß√£o para o microcontrolador afirma claramente que essa √© a faixa da <b>"Interface FLASH"</b> .  Ou seja, a fun√ß√£o x_erase apaga um pouco da mem√≥ria flash - √≥timo! <br><br>  Aparentemente, a fun√ß√£o x_flash grava na mem√≥ria flash, depois de verificar o comprimento da linha para escrever (a prop√≥sito, os argumentos a2 e a3 s√£o sup√©rfluos aqui - ajudaremos o Idea): <br><br><img src="https://habrastorage.org/webt/ki/di/zi/kidizigfv5lb6bwg24aspkgvxmw.png"><br><br>  E tudo isso acontece no "dispositivo de ilumina√ß√£o" ??? <br><br>  Bem, e a fun√ß√£o <b>x_gen</b> ?  Ap√≥s uma r√°pida olhada e renomea√ß√£o de vari√°veis, ficar√° assim: <br><br><img src="https://habrastorage.org/webt/v3/js/nb/v3jsnb8jb36wstn3obcln2c3pvk.png"><br><br>  A fun√ß√£o <b>sub_8006CB4</b> tem a seguinte apar√™ncia: <br><br><img src="https://habrastorage.org/webt/ub/h1/rk/ubh1rki0ikjrygsiqcx9vuwylxc.png"><br><br>  E <b>sub_8006D10</b> - assim: <br><br><img src="https://habrastorage.org/webt/gp/qy/oc/gpqyocts_ubcd4u3ep9koyrcb0o.png"><br><br>  N√£o retenha o desejo de pesquisar na Internet essas constantes indecentemente bonitas: <b>0xABCD</b> , <b>0x1234</b> , <b>0xE66D</b> , <b>0xDEEC</b> , <b>0x4C957F2D</b> e <b>0x5851F42D</b> .  Se a Internet ainda n√£o estiver completamente proibida, voc√™ provavelmente encontrar√° essas constantes na fonte para <b>fun√ß√µes aleat√≥rias</b> .  N√£o √© de admirar que a fun√ß√£o pai seja chamada x_gen. <br><br>  Essa tamb√©m √© uma situa√ß√£o muito t√≠pica: chame srand () antes do loop e chame random () no loop, ent√£o renomeie-o: <br><br><ul><li>  sub_8006D10 - x_rand; </li><li>  sub_8006CB4 - x_srand. </li></ul><br>  Um leitor curioso, examinando a fun√ß√£o <b>sub_8005098</b> , pode descobrir de <i>onde vem a semente da</i> fun√ß√£o srand. <br><br>  Assim, a fun√ß√£o x_gen gera <b>uma sequ√™ncia aleat√≥ria do tamanho especificado</b> . <br><br>  Depois que a linha gerada √© gravada na mem√≥ria flash, o dispositivo √© reinicializado: <br><br><img src="https://habrastorage.org/webt/a9/ta/rr/a9tarrhqqc-jj7g-e-dplvr67py.png"><br><br>  Parece algum tipo de reinicializa√ß√£o estranha.  Mas se olharmos para a lista de tarefas deste dispositivo, encontraremos "watchdogTask" entre elas.  Obviamente, se houver uma "tarefa emperrada", o watchdog ser√° reiniciado. <br><br>  A tarefa de LED, exceto o modo MadBlinking, pode ser considerada analisada. <br><br>  Vamos analisar atrav√©s das linhas que outras tarefas existem no sistema: <br><br><img src="https://habrastorage.org/webt/fz/yj/yk/fzyjykt6djuq8v20hjpuw5l0xow.png"><br><br>  Depois de restaurar os links para as strings no c√≥digo, voc√™ pode ver esta figura: <br><br><img src="https://habrastorage.org/webt/ha/bl/ks/hablksetvyb0rskx6veqrxbt_z0.png"><br><br>  Primeiro, h√° um link para uma string com o nome task, depois um link para a fun√ß√£o principal da tarefa.  E eles s√£o usados ‚Äã‚Äãna fun√ß√£o <b>principal</b> , onde essas tarefas s√£o iniciadas: <br><br><img src="https://habrastorage.org/webt/oc/ah/qd/ocahqdn8usagpkr-isbabunuwms.png"><br><br>  Vamos executar as renomea√ß√µes ausentes: <br><br><ul><li>  sub_80050FC - <b>x_sensor_task</b> ; </li><li>  sub_8004AAC - <b>x_watchdogTask</b> ; </li><li>  sub_8005440 - <b>x_uartRxTask</b> . </li></ul><br><h2>  Tarefa Watchdog </h2><br>  O watchdog de tarefas n√£o faz nada particularmente interessante: <br><br><img src="https://habrastorage.org/webt/m-/65/5w/m-655wpo6oboqmrob1tonwaoska.png"><br><br>  Renomear: <br><br><ul><li>  dword_200003F8 - <b>wd_variable</b> ; </li><li>  sub_8001050 - <b>x_update_wd_var</b> . </li></ul><br><h2>  Tarefa UART </h2><br>  <i>Resumidamente: pesquise dados e fun√ß√µes que possuem links de diferentes fun√ß√µes.</i>  <i>Determina√ß√£o da sua finalidade.</i> <br><br>  Uma r√°pida olhada na tarefa UART permite detectar o envio de dados para uma fila desconhecida definida pela vari√°vel <b>unk_200003EC</b> : <br><br><img src="https://habrastorage.org/webt/8j/ei/zz/8jeizzxpvgu5opijgopamebser0.png"><br><br>  Ap√≥s restaurar os links para essa vari√°vel por meio de pesquisa bin√°ria, veremos que, al√©m do x_uartRxTask, ele √© usado no principal (l√°, a fila √© criada, aparentemente) e na fun√ß√£o desconhecida at√© o momento <b>sub_80051EC</b> : <br><br><img src="https://habrastorage.org/webt/g2/md/sg/g2mdsgx9wwhzpklgcacelye8rb8.png"><br><br>  Renomear: <br><br><ul><li>  sub_80051EC - <b>x_recvMsg_uart_queue</b> ; </li><li>  unk_200003EC - <b>uart_queue</b> . </li></ul><br>  Consulte as refer√™ncias cruzadas para x_recvMsg_uart_queue: <br><br><ul><li>  sub_8005250; </li><li>  x_bluetooth_task. </li></ul><br>  Primeiro, consulte a fun√ß√£o <b>sub_8005250</b> : <br><br><img src="https://habrastorage.org/webt/z1/8z/yj/z18zyj09grly6nwhuycpftjbrcu.png"><br><br>  Depois de pensar, renomeie: <br><br><ul><li>  unk_2000034C - <b>cmd_count</b> ; </li><li>  a1 - <b>cmd</b> ; </li><li>  v4 - <b>_cmd</b> ; </li><li>  v6 √© <b>rsp</b> ; </li><li>  sub_8005250 - <b>x_bluetooth_cmd</b> . </li></ul><br>  Vamos ver agora onde o x_bluetooth_cmd ainda √© usado.  Todos os links adicionais somente da tarefa Bluetooth, √© hora de retornar a ela. <br><br><h2>  Voltar √† tarefa bluetooth </h2><br>  <i>Resumidamente: a an√°lise final da tarefa Bluetooth.</i>  <i>Procure autoriza√ß√£o sem uma senha.</i> <br><br><img src="https://habrastorage.org/webt/mb/2b/-e/mb2b-eatekfev7dil5vfk3_s-es.png"><br><br>  Se voc√™ observar os locais em que a fun√ß√£o <b>sub_8006A84</b> √© <b>usada</b> e n√£o for muito pregui√ßoso e observar as entranhas, n√£o h√° d√∫vida de que isso √© <b>cal√≥rico</b> .  √â l√≥gico - para receber dados no buffer, voc√™ deve primeiro criar esse buffer. <br><br>  Agora <b>sub_8006DBC</b> .  Vamos dar uma olhada (as vari√°veis ‚Äã‚Äãj√° foram renomeadas): <br><br><img src="https://habrastorage.org/webt/kt/hw/31/kthw31aeqzwyae4jvnoqf5u6yl4.png"><br><br>  Recordando as fun√ß√µes da biblioteca C padr√£o para trabalhar com seq√º√™ncias de caracteres, veremos <b>strstr</b> (procure uma substring) aqui e renome√°-laemos com ousadia. <br><br>  Vamos analisar o c√≥digo da fun√ß√£o x_bluetooth_task - <i>talvez algo tenha mudado aqui desde a √∫ltima visita</i> .  No processo, nomeamos as vari√°veis: <br><br><ul><li>  v2 - <b>estado</b> ; </li><li>  v3 - <b>data_len</b> . </li></ul><br>  H√° uma fun√ß√£o <b>sub_80052E2 ao</b> lado dela.  Por analogia com fun√ß√µes que extraem n√∫meros de um comando Bluetooth, ele extrai uma sequ√™ncia de um comprimento especificado - vamos cham√°-lo de <b>x_get_str</b> . <br><br>  Continuamos: <br><br><ul><li>  v26 - <b>isEcho</b> ; </li><li>  v6 - <b>meow_str</b> ; </li><li>  v10 - <b>uart_cmd_byte</b> ; </li><li>  v11 - <b>uart_cmd_str</b> ; </li><li>  v12 - <b>str_0</b> ; </li><li>  v13 - <b>str_1</b> ; </li><li>  v14 - <b>format_str</b> ; </li><li>  sub_8000F5C - <b>x_blink_small_led</b> . </li></ul><br>  Termine com uma renomea√ß√£o r√°pida: <br><br><ul><li>  v19 - <b>senha</b> ;  (como existem linhas sobre autoriza√ß√£o e senha ao lado) </li><li>  sub_8004CC0 - <b>x_check_password</b> ; </li><li>  sub_8006AF4 - <b>x_free</b> (como senha, cmd e bt_args s√£o ponteiros para objetos din√¢micos (marque isso!), a mem√≥ria deve ser liberada ap√≥s us√°-los); </li><li>  sub_8006DAC - <b>x_strcpy</b> (confira!). </li></ul><br>  Agora explore os ramos <b>READ</b> , <b>WRIT</b> , <b>AUTP</b> , <b>SETP</b> . <br><br>  Como um teste em um dispositivo em execu√ß√£o mostrou, √© necess√°ria autoriza√ß√£o para os comandos READ, WRIT, SETP.  Uma tentativa de autoriza√ß√£o com o comando AUTP nos leva √† fun√ß√£o <b>x_check_password</b> para verificar a senha: <br><br><img src="https://habrastorage.org/webt/vt/pw/6b/vtpw6b3h64bivcvzdlalldoo45k.png"><br><br>  Acontece que o comprimento da senha deve ter 8 caracteres e a senha √© comparada (na fun√ß√£o sub_8006B08) com bytes no endere√ßo <b>0x08007C00</b> - onde a cadeia gerada de caracteres aleat√≥rios AZ √© armazenada. <br><br>  Acontece que, sem saber a senha, n√£o podemos fazer login no dispositivo.  Bem, ou quase n√£o pode ... <br><br>  Preste aten√ß√£o em onde a vari√°vel <b>auth_flag</b> √© <b>usada</b> : <br><br><img src="https://habrastorage.org/webt/8h/ng/l0/8hngl0dqritcx8yzk1jbvkqpq34.png"><br><br>  Acontece que ele √© usado n√£o apenas na tarefa Bluetooth.  E aqui apenas n√£o analisamos a tarefa Sensor ainda.  N√≥s vamos l√°. <br><br><h2>  Tarefa do sensor </h2><br>  <i>Resumidamente: o que o bot√£o de toque faz?</i> <br><br>  De acordo com as melhores pr√°ticas de programa√ß√£o, toda a tarefa do sensor se encaixa em uma tela da IDA.  E isso n√£o pode deixar de se alegrar: <br><br><img src="https://habrastorage.org/webt/mq/13/3v/mq133vs_uxqmyldfhmicajpxiak.png"><br><br>  Linha a linha ... <br><br><ul><li>  ‚ÄúTSC% d \ r \ n‚Äù - esta linha deve fazer voc√™ pensar no controlador de sensor de toque para microcontroladores STM32; </li><li>  "AUTH BTN \ r \ n" - bot√£o de autoriza√ß√£o ??? </li><li>  "SET AUTH% d \ r \ n" - define o sinalizador de autoriza√ß√£o? </li></ul><br>  Vamos ver como o dispositivo se comportar√° se voc√™ pressionar o bot√£o de toque (voc√™ percebeu que o rinoceronte na perna tem um bot√£o de toque?): <br><br><img src="https://habrastorage.org/webt/0p/ig/bp/0pigbpj4pj5gdrn1onololc_zfk.gif"><br><br>  Quando pressionado brevemente, o pequeno LED vermelho acende.  Com uma press√£o longa, esse LED acende por um longo tempo. <br><br>  Se correlacionarmos isso com o c√≥digo, podemos assumir que a fun√ß√£o <b>sub_8000708</b> √© uma fun√ß√£o para obter a hora atual.  Ent√£o, se a diferen√ßa entre a hora atual e o in√≠cio do toque no sensor for superior a 1000 (1 segundo), o LED acender√° por <b>0xEA60</b> milissegundos (1 minuto).  Mas a vari√°vel auth_flag √© de grande interesse, que √© definida como 1 com um toque longo no bot√£o de toque, dando ao <s>invasor o</s> acesso ao administrador do ‚Äúdispositivo de ilumina√ß√£o‚Äù e acesso a fun√ß√µes privilegiadas. <br><br>  Assim, ap√≥s a autoriza√ß√£o ‚Äúpor bot√£o‚Äù, voc√™ pode ler a senha armazenada no dispositivo (comando READ), gravar na RAM (fun√ß√£o WRIT) ou definir uma nova senha (SETP). <br><br><h2>  Louco piscando </h2><br>  <i>Resumidamente: pode ser executado um ramo estranho do c√≥digo Mad Blinking?</i> <br><br>  Vamos voltar √† tarefa Bluetooth e renomear um pouco mais. <br><br><ul><li>  v21 - <b>vip_smth</b> (ainda n√£o est√° claro o que existe); </li><li>  v22 - <b>vip_str</b> (sequ√™ncia de tamanho desconhecido, extra√≠da dos argumentos); </li><li>  v23 - <b>mad_led</b> - atribua "Convert to struct *" e especifique <i>struct_LED</i> . </li></ul><br>  E aqui vemos o n√∫mero <b>0xB816D8D9</b> (encontrado na primeira parte do artigo na tarefa Bluetooth) como o √≠ndice do LED.  Este c√≥digo ser√° executado se a verifica√ß√£o for realizada: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( sub_8005520(vip_str, vip_smth) == <span class="hljs-number"><span class="hljs-number">0x46F70674</span></span> )</code> </pre> <br>  Renomeie sub_8005520 para <b>x_vip_check</b> e d√™ uma olhada nele: <br><br><img src="https://habrastorage.org/webt/dl/h9/tx/dlh9txqyu5n1t4orgprpptbk8oc.png"><br><br>  Dado que o primeiro argumento √© uma string (pelo menos a string √© passada para essa fun√ß√£o), esse c√≥digo mostra que o segundo argumento √© o comprimento dessa string (ou o comprimento que deve ser processado).  Renomear: <br><br><ul><li>  a1 - <b>str</b> ; </li><li>  a2 - <b>len</b> . </li></ul><br>  Vamos dar uma olhada na fun√ß√£o <b>sub_8000254</b> : <br><br><img src="https://habrastorage.org/webt/y-/ql/js/y-qljsey4clq4lowsdbrblnkyf8.png"><br><br>  Agora veja <b>sub_8000148</b> .  Aqui est√° o seu come√ßo: <br><br><img src="https://habrastorage.org/webt/l7/xz/cr/l7xzcrdgjq0n5a82enkalsukqse.png"><br><br>  Este √© apenas um ter√ßo da fun√ß√£o ... Mmmm ... Gostoso!  Um escavador experiente ver√° facilmente aqui ... <br><br><div class="spoiler">  <b class="spoiler_title">O que?</b> <div class="spoiler_text">  opera√ß√£o de divis√£o inteira. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Como pode ser desenterrado?</b> <div class="spoiler_text">  Se voc√™ fizer um esfor√ßo, a partir da fun√ß√£o <b>sub_8000254,</b> voc√™ poder√° <b>acessar x_printf</b> (atrav√©s de v√°rias outras fun√ß√µes).  Um ponto importante a ser destacado neste momento √© que geralmente todas <i>as fun√ß√µes padr√£o s√£o razoavelmente padr√£o</i> .  Isso significa que voc√™ pode tentar encontrar no dom√≠nio p√∫blico pelo menos algum c√≥digo-fonte da fun√ß√£o que est√° sendo investigada, para que o estudo seja mais produtivo. <br><br>  Ent√£o, pegamos a fonte do printf, depois olhamos para o <b>vfprintf</b> , comparando-o com o c√≥digo do firmware estudado.  <b>Usando o</b> c√≥digo fonte, sa√≠mos para a fun√ß√£o <b>itoa</b> e conclu√≠mos que a fun√ß√£o <b>sub_8000254</b> √© o operador <b>operador%</b> (considerando o restante da divis√£o), e essa terr√≠vel fun√ß√£o longa nada mais √© do que pegar a parte inteira da divis√£o (opera√ß√£o div). <br></div></div><br>  Uma pergunta leg√≠tima pode surgir - por que?  O fato √© que n√£o pode haver opera√ß√µes DIV, MOD em um microcontrolador espec√≠fico; portanto, o compilador substitui a chamada de fun√ß√µes individuais em vez desses operadores.  A prop√≥sito, aqui est√£o algumas outras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fun√ß√µes matem√°ticas</a> . <br><br>  N√£o se esque√ßa de renomear durante a escava√ß√£o. <br><br>  Assim, a fun√ß√£o <b>x_vip_check</b> calcula ... E essa ser√° sua <b><i>li√ß√£o de casa</i></b> . <br><br>  A prop√≥sito, se voc√™ executar o comando <b>VIP</b> correto, obteremos um "rinoceronte na discoteca": <br><br><img src="https://habrastorage.org/webt/ah/ty/sc/ahtyscents-3j77aqcxfa0_hrtq.gif"><br><br><h2>  Breve relat√≥rio sobre firmware </h2><br>  O firmware do dispositivo √© baseado no sistema operacional FreeRTOS em tempo real.  O sistema possui as seguintes tarefas: <br><br><ol><li>  <b>Tarefa Bluetooth</b> .  Processa comandos que v√™m em forma de texto via Bluetooth. </li><li>  <b>Tarefa de LED</b> .  Controla os LEDs coloridos de acordo com os comandos do Bluetooth. </li><li>  <b>Tarefa do sensor</b> .  Acende o LED vermelho, permite uma autoriza√ß√£o de curto prazo sem uma senha no dispositivo. </li><li>  <b>Tarefa UART</b> .  Permite que voc√™ interaja com o m√≥dulo Bluetooth atrav√©s da porta UART interna (usada para inicializar o Bluetooth). </li><li>  <b>Tarefa Watchdog</b> .  Mant√©m o controle de congelamentos. </li></ol><br>  O estudo n√£o levou em considera√ß√£o a capacidade de ler dados da porta UART (contatos Tx / GND). <br><br><h2>  Sum√°rio </h2><br>  Durante a aula principal na confer√™ncia, apenas a principal funcionalidade de controle de LED foi desmontada.  Os participantes mais ativos foram apresentados com seus ‚Äúrinocerontes‚Äù experimentais. <br><br>  Na minha opini√£o, o ‚Äúrinoceronte‚Äù produziu um layout decente para um curso de treinamento em engenharia reversa e pesquisa de vulnerabilidades.  Um recurso do layout pode ser a capacidade de alterar o firmware quantas vezes voc√™ quiser, cada curso possui seu pr√≥prio firmware.  Ao contr√°rio de analisar um arquivo execut√°vel, o firmware reverso permite que voc√™ entenda melhor: <br><br><ul><li>  como trabalhar com a IDA; </li><li>  princ√≠pios de intera√ß√£o entre o firmware e o dispositivo; </li><li>  Princ√≠pios operacionais do RTOS. </li></ul><br>  Muito obrigado a todos que leram at√© o fim! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt412561/">https://habr.com/ru/post/pt412561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt412551/index.html">Copie o texto da √°rea de transfer√™ncia para dispositivos Android via ADB</a></li>
<li><a href="../pt412553/index.html">O resumo de eventos para profissionais de RH na √°rea de TI em junho de 2018</a></li>
<li><a href="../pt412555/index.html">Engrenagem magn√©tica para motor sem escova</a></li>
<li><a href="../pt412557/index.html">Como criar seu pr√≥prio bot sem habilidades de programa√ß√£o e conect√°-lo ao Yandex.</a></li>
<li><a href="../pt412559/index.html">Contrato inteligente como uma amea√ßa de seguran√ßa para inicializa√ß√£o de blockchain</a></li>
<li><a href="../pt412565/index.html">Quadrinhos sobre administradores de sistemas: toda a vida brilhou diante dos meus olhos</a></li>
<li><a href="../pt412571/index.html">Kubernetes hist√≥rias de sucesso em produ√ß√£o. Parte 9: Clusters CERN e 210 K8s</a></li>
<li><a href="../pt412573/index.html">O que h√° de errado com o Geektimes retornar a Habr</a></li>
<li><a href="../pt412575/index.html">Todos os anos, a m√∫sica pop se torna cada vez mais mon√≥tona, porque as mesmas pessoas a comp√µem</a></li>
<li><a href="../pt412579/index.html">Marvel: Infinity War ou Como coletar dados para o seu projeto em alguns minutos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>