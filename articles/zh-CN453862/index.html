<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏾 🌷 ➖ 为什么要使用pathlib 🚶🏽 👏🏼 👨🏾‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="来自译者：您好，Habr！ 我向您介绍了文章为什么您应该使用pathlib及其后续文章的翻译， 真的，pathlib很棒 。 现在，人们已经非常关注诸如asyncio 、: =运算符和可选类型等Python新功能。 同时，雷达的风险不是那么大（尽管：： = =称呼一项重大创新，一种语言并没有证明这是...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>为什么要使用pathlib</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453862/"><p>  <em>来自译者：您好，Habr！</em>  <em>我向您介绍了文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为什么您应该使用pathlib</a>及其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">后续</a>文章的翻译， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">真的，pathlib很棒</a> 。</em>  <em>现在，人们已经非常关注诸如asyncio 、: =运算符和可选类型等Python新功能。</em>  <em>同时，雷达的风险不是那么大（尽管：： = =称呼一项重大创新，一种语言并没有证明这是一项重大创新），但它却是一种非常有用的语言创新。</em>  <em>特别是，在专门讨论某个主题的文章中，我没有找到（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>只有一段），因此我决定纠正这种情况。</em> </p><br><p>几年前，当我发现当时新的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pathlib</a>模块时，我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下意识地</a>决定它只是<code>os.path</code>模块的一个有点尴尬的面向对象版本。 我错了  <code>pathlib</code>真的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">很棒</a> ！ </p><br><p> 在本文中，我将尝试爱上<code>pathlib</code> 。 我希望本文能<strong><code>pathlib</code></strong>您在<strong>使用Python处理文件的任何情况下使用<code>pathlib</code></strong> 。 </p><a name="habracut"></a><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>os.path</code>尴尬</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>os</code>超载</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>   glob</code></a> </li> <li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>pathlib</code>使简单的事情变得更加容易</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">路径对象使您的代码更明显</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>    pathlib</code> ？</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>    pathlib</code> ？</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分。问题的答案。</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">老实<code> os.path</code>和<code>pathlib</code></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您不必担心标准化路径。</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code> ,     ,    pathlib</code> ！</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">但是我最喜欢的库的Path比标准库好！</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>  pathlib.Path</code>和<code>str</code>不能混合使用，对吗？</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>pathlib</code>太慢</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可读性提高</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>   pathlib.Path</code></a> </li> </ul></li></ul><br><h2 id="chast-1"> 第一部分 </h2><br><h3 id="ospath-neuklyuzh">  <code>os.path</code>尴尬 </h3><br><p>  <code>os.path</code>模块一直是我们使用Python路径时使用的模块。 原则上，您需要任何东西，但通常看起来并不那么优雅。 </p><br><p> 我应该这样导入吗？ </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) TEMPLATES_DIR = os.path.join(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p> 大概吧 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abspath, dirname, join BASE_DIR = dirname(dirname(abspath(__file__))) TEMPLATES_DIR = join(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p> 也许<code>join</code>函数的名称太笼统，我们应该执行以下操作： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abspath, dirname, join <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> joinpath BASE_DIR = dirname(dirname(abspath(__file__))) TEMPLATES_DIR = joinpath(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p> 对我来说，以上所有选项似乎都不方便。 我们将字符串传递给返回字符串的函数，然后传递给下一个使用字符串的函数。 碰巧它们都包含路径，但它们仍然只是线。 </p><br><p> 在<code>os.path</code>函数中使用字符串作为输入和输出非常不便，因为您必须从内而外读取代码。 我想将这些调用从嵌套转换为顺序。 这就是<code>pathlib</code>允许您执行的操作！ </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path BASE_DIR = Path(__file__).resolve().parent.parent TEMPLATES_DIR = BASE_DIR.joinpath(<span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  <code>os.path</code>模块需要嵌套的函数调用，但是<code>pathlib</code> <strong>允许我们创建对<code>Path</code>类的方法和属性的连续调用的链，</strong>并获得等效的结果。 </p><br><p> 我知道您的想法：停止，这些<code>Path</code>对象与以前不同，我们不再对路径行进行操作！ 我们稍后会再讨论这个问题（提示：在几乎任何情况下，这两种方法都是可以互换的）。 </p><br><h3 id="os-peregruzhen">  <code>os</code>超载 </h3><br><p> 经典的<code>os.path</code>模块设计用于路径。 但是，要对路径<em>进行某些操作</em> （例如，创建目录）后，需要访问另一个模块，通常是<code>os</code> 。 </p><br><p>  <code>os</code>包含一堆用于处理文件和目录的实用程序： <code>mkdir</code> ， <code>getcwd</code> ， <code>chmod</code> ， <code>stat</code> ， <code>remove</code> ， <code>rename</code> ， <code>rmdir</code> 。 还可以使用<code>chdir</code> ， <code>link</code> ， <code>walk</code> ， <code>listdir</code> ， <code>makedirs</code> ， <code>renames</code> ， <code>removedirs</code> ， <code>unlink</code> ， <code>symlink</code> 。 还有一堆根本不与文件系统相关的东西： <code>fork</code> ， <code>getenv</code> ， <code>putenv</code> ， <code>environ</code> ， <code>getlogin</code> ， <code>system</code> ……还有几十个我在这里不会提及的东西。 </p><br><p>  <strong><code>os</code>模块设计用于多种任务。</strong>  <strong>这是一个包含与操作系统相关的所有内容的盒子。</strong>  <code>os</code>有许多用途，但是导航并不总是那么容易：在找到所需内容之前，经常有必要深入研究模块。 </p><br><p>  <code>pathlib</code>将大多数文件系统功能转移到<code>Path</code>对象。 </p><br><p> 这是创建<code>src/__pypackages__</code>并将我们的<code>.editorconfig</code>文件重命名为<code>src/.editorconfig</code> ： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path os.makedirs(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pypackages__'</span></span>), exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) os.rename(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>, os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>))</code> </pre> <br><p> 这是使用<code>Path</code>类似代码 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>).mkdir(parents=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).rename(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p> 请注意，第二个代码示例更容易阅读，因为它是从左到右组织的-这一切都归功于方法链。 </p><br><h3 id="ne-zabyvayte-pro-glob"> 不要忘了全球 </h3><br><p> 不仅<code>os</code>和<code>os.path</code>包含与文件系统相关的方法。 值得一提的是<code>glob</code> ，不能称之为无用。 </p><br><p> 我们可以使用<code>glob.glob</code>函数按特定模式搜索文件： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob top_level_csv_files = glob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>) all_csv_files = glob(<span class="hljs-string"><span class="hljs-string">'**/*.csv'</span></span>, recursive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  <code>pathlib</code>模块还提供了类似的方法： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path top_level_csv_files = Path.cwd().glob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>) all_csv_files = Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>)</code> </pre> <br><p> 切换到<code>pathlib</code>模块后，对<strong><code>glob</code></strong>的<strong>需求完全消失了</strong> ：您所需的一切已经是<code>Path</code>对象的组成部分 </p><br><h3 id="pathlib-delaet-prostye-veschi-esche-prosche">  <code>pathlib</code>使简单的事情变得更加容易 </h3><br><p>  <code>pathlib</code>简化了许多困难的情况，但也<strong>使一些简单的代码片段更加容易</strong> 。 </p><br><p> 是否想读取一个或多个文件中的所有文本？ </p><br><p> 您可以使用<code>with</code>块打开文件，读取内容并关闭文件： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob file_contents = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> glob(<span class="hljs-string"><span class="hljs-string">'**/*.py'</span></span>, recursive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(filename) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> python_file: file_contents.append(python_file.read())</code> </pre> <br><p> 或者，您可以在<code>Path</code>对象上使用<code>read_text</code>方法并生成列表以在一个表达式中获得相同的结果： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path file_contents = [ path.read_text() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">'*.py'</span></span>) ]</code> </pre> <br><p> 但是，如果您需要写入文件怎么办？ </p><br><p> 这是使用<code>open</code>样子： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p> 或者，您可以使用<code>write_text</code>方法： </p><br><pre> <code class="python hljs">Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).write_text(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p> 如果出于某种原因需要将<code>open</code>用作上下文管理器或出于个人喜好， <code>Path</code>可以提供<code>open</code>方法作为替代方法： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path path = Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> path.open(mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p> 或者，从Python 3.6开始，您可以直接将<code>Path</code>传递给<code>open</code> ： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path path = Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><h3 id="obekty-path-delayut-vash-kod-ochevidnee"> 路径对象使您的代码更明显 </h3><br><p> 以下变量表示什么？ 它们的含义是什么？ </p><br><pre> <code class="python hljs">person = <span class="hljs-string"><span class="hljs-string">'{"name": "Trey Hunner", "location": "San Diego"}'</span></span> pycon_2019 = <span class="hljs-string"><span class="hljs-string">"2019-05-01"</span></span> home_directory = <span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span></code> </pre> <br><p> 每个变量都指向一行。 但是它们每个都有不同的含义：第一个是JSON，第二个是日期，第三个是文件路径。 </p><br><p> 对象的这种表示稍微有用： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> date <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path person = {<span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Trey Hunner"</span></span>, <span class="hljs-string"><span class="hljs-string">"location"</span></span>: <span class="hljs-string"><span class="hljs-string">"San Diego"</span></span>} pycon_2019 = date(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) home_directory = Path(<span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span>)</code> </pre> <br><p>  JSON对象可以反序列化为字典，日期可以使用<code>datetime.date</code>本地表示， <strong>文件路径对象可以表示为<code>Path</code></strong> </p><br><p> 使用<code>Path</code>对象可使您的代码更加明确。 如果要使用日期，请使用<code>date</code> 。 如果要使用文件路径，请使用<code>Path</code> 。 </p><br><p> 我不是OOP的大力支持者。 类增加了额外的抽象层，抽象有时会使系统复杂而不是简化系统。 同时，我相信<code>pathlib.Path</code>是<strong>有用的抽象</strong> 。 很快，这成为一个可以接受的决定。 </p><br><p> 借助<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PEP 519</a> ， <code>Path</code>成为使用路径的标准。 在Python 3.6发行时，大多数<code>os</code> ， <code>shutil</code>和<code>os.path</code>可以与这些对象一起正常工作。  <strong>您可以立即切换到<code>pathlib</code> ，对您的代码库而言是透明的！</strong> </p><br><h3 id="chego-ne-hvataet-v-pathlib">  <code>pathlib</code>缺少什么？ </h3><br><p> 尽管<code>pathlib</code>很酷，但并不全面。  <strong>我肯定希望将其包含在模块中</strong> 。 </p><br><p> 首先想到的是缺少等同于<code>shutil</code>的路径方法。 尽管您可以将<code>Path</code>作为<code>shutil</code>参数传递给复制/删除/移动文件和目录，但是您不能将它们作为<code>Path</code>对象的方法来调用。 </p><br><p> 因此，要复制文件，您需要执行以下操作： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> copyfile source = Path(<span class="hljs-string"><span class="hljs-string">'old_file.txt'</span></span>) destination = Path(<span class="hljs-string"><span class="hljs-string">'new_file.txt'</span></span>) copyfile(source, destination)</code> </pre> <br><p>  <code>os.chdir</code>方法也没有类似物。 这意味着如果需要更改当前目录，则需要将其导入： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chdir parent = Path(<span class="hljs-string"><span class="hljs-string">'..'</span></span>) chdir(parent)</code> </pre> <br><p> 也没有等效的<code>os.walk</code>函数。 尽管您可以本着<code>walk</code>的精神编写自己的函数，但没有太多困难。 </p><br><p> 我希望有一天<code>pathlib.Path</code>对象将包含上述某些操作的方法。 但是即使在这种情况下， <strong>我发现将<code>pathlib</code>与其他东西一起使用比使用<code>os.path</code>和其他所有东西要容易得多</strong> 。 </p><br><h3 id="vsegda-li-nuzhno-ispolzovat-pathlib"> 是否总是需要使用<code>pathlib</code> ？ </h3><br><p> 从Python 3.6开始， <strong>路径几乎可以在使用string的任何地方工作</strong> 。 因此，如果您使用的是Python 3.6及更高版本，我认为没有理由<em>不</em>使用<code>pathlib</code> 。 </p><br><p> 如果使用的是Python 3的早期版本，则需要返回行所在的国家/地区时，可以随时将<code>Path</code>对象包装在<code>str</code>调用中以获取字符串。 这不是太优雅，但是它可以工作： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chdir <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path chdir(Path(<span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">#   Python 3.6+ chdir(str(Path('/home/trey'))) #     </span></span></code> </pre> <br><h2 id="chast-2-otvety-na-voprosy"> 第2部分。问题的答案。 </h2><br><p> 第一部分出版后，有些人提出了一些问题。 有人说我不诚实地比较了<code>os.path</code>和<code>pathlib</code> 。 有人说使用<code>os.path</code>在Python社区中根深蒂固，以至于迁移到新库将花费很长时间。 我还看到了一些有关性能的问题。 </p><br><p> 在这一部分中，我想对这些问题发表评论。 这既可以视为<code>pathlib</code>保护，也可以看作是给<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PEP 519的</a>一封情书。 </p><br><h3 id="sravnenie-ospath-i-pathlib-po-chestnomu"> 老实比较<code>os.path</code>和<code>pathlib</code> </h3><br><p> 在最后一部分中，我比较了以下两个代码片段： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path os.makedirs(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pypackages__'</span></span>), exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) os.rename(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>, os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>))</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>).mkdir(parents=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).rename(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p> 这似乎是不公平的比较，因为在第一个示例中使用<code>os.path.join</code>确保在所有平台上使用正确的定界符，而在第二个示例中则没有。 实际上，一切都井井有条，因为<strong>Path会自动规范化路径分隔符</strong> </p><br><p> 我们可以通过在Windows上将<code>Path</code>对象转换为字符串来证明这一点： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>str(Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src\\__pypackages__'</span></span></code> </pre> <br><p> 无论我们使用<code>joinpath</code>方法，路径行中的<code>'/'</code> ， <code>/</code>运算符（ <code>Path</code>另一个不错的功能）还是将单独的参数传递给Path构造函数，都没有什么区别： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>) / <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span> WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>).joinpath(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p> 最后一个例子引起了一些人的困惑，他们认为<code>pathlib</code>不够聪明，无法在路径字符串中用<code>\</code>替换<code>/</code> 。 幸运的是，一切都井然有序！ </p><br><p> 使用<code>Path</code>对象，您不再需要担心斜线的方向：使用<code>/</code>定义所有路径，并且结果对于任何平台都是可预测的。 </p><br><h3 id="vy-ne-dolzhny-bespokoitsya-o-normalizacii-putey"> 您不必担心标准化路径。 </h3><br><p> 如果您使用的是Linux或Mac，则很容易在代码中意外添加仅影响Windows用户的错误。 如果您不仔细监视<code>os.path.join</code>和\或<code>os.path.normcase</code>以将斜杠转换为适合当前平台的斜杠，则<strong>可以编写在Windows上无法正常工作的代码</strong> 。 </p><br><p> 这是Windows特定错误的示例： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path directory = <span class="hljs-string"><span class="hljs-string">'.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] new_file = os.path.join(directory, <span class="hljs-string"><span class="hljs-string">'new_package/__init__.py'</span></span>)</code> </pre> <br><p> 而且，这样的代码将在任何地方正确工作： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path directory = <span class="hljs-string"><span class="hljs-string">'.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] new_file = Path(directory, <span class="hljs-string"><span class="hljs-string">'new_package/__init__.py'</span></span>)</code> </pre> <br><p> 以前，程序员负责连接和规范化路径，就像在Python 2中一样，程序员负责决定在哪里使用unicode而不是字节。 这不再是您的任务<code>Path</code>为您解决所有此类问题。 </p><br><p> 我不使用Windows，也没有Windows计算机。 但是，很多将使用我的代码的人很可能会使用Windows，我希望所有内容都能为他们正常工作。 </p><br><p>  <strong>如果您的代码有可能在Windows上运行，则应认真考虑切换到<code>pathlib</code> 。</strong> </p><br><p>  <strong>不用担心规范化</strong> ：涉及文件路径时，请<strong>务必</strong>使用<code>Path</code> 。 </p><br><h3 id="zvuchit-klassno-no-u-menya-storonnyaya-biblioteka-kotoraya-ne-ispolzuet-pathlib"> 听起来很酷，但是我有一个不使用<code>pathlib</code>的第三方库！ </h3><br><p> 您有一个大型代码库，可以将字符串作为路径使用。 如果那意味着所有内容都需要重写，为什么要切换到<code>pathlib</code> ？ </p><br><p> 假设您具有以下功能： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filename."""</span></span> filename = os.path.join(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(filename): os.makedirs(dir_path, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) open(filename, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>).write(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filename</code> </pre> <br><p> 该函数获取目录并在其中创建一个<code>.editorconfig</code>文件，如下所示： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path &gt;&gt;&gt; make_editorconfig(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'my_package'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span></code> </pre> <br><p> 如果将行替换为<code>Path</code> ，那么一切也将正常工作： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; make_editorconfig(Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span></code> </pre> <br><p> 但是...如何？ </p><br><p>  <code>os.path.join</code>接受<code>Path</code>对象（自Python 3.6起）。  <code>os.makedirs</code>也可以这样说。 <br> 实际上，内置的<code>open</code>函数接受<code>Path</code> ， <code>shutil</code>接受<code>Path</code>并且标准库中用于接受字符串的所有内容现在都应同时适用于<code>Path</code>和字符串。 </p><br><p> 我们应该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为此</a>感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PEP 519</a> ，它提供了抽象类<code>os.PathLike</code>并宣布所有用于处理文件路径的内置实用程序现在都应同时适用于string和<code>Path</code> 。 </p><br><h3 id="no-v-moey-lyubimoy-biblioteke-est-path-luchshe-standartnogo"> 但是我最喜欢的库具有Path，比标准库更好！ </h3><br><p> 您可能已经在使用提供其<code>Path</code>实现的第三方库，该库与标准库不同。 也许您更喜欢她。 </p><br><p> 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">django-environ</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">path.py</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">plumbum</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">visidata各自</a>包含自己的<code>Path</code>对象。 其中一些库比<code>pathlib</code> ，并且决定从<code>str</code>继承，以便可以将它们传递<code>pathlib</code>字符串为路径的函数。 借助PEP 519，将第三方库集成到您的代码中将变得更加容易，并且无需继承<code>str</code> 。 </p><br><p> 假设您不想使用<code>pathlib</code> ，因为<code>Path</code>是不可变的对象，并且您确实真的想更改它们的状态。 使用PEP 519，可以创建<code>Path</code>最佳可变版本。 为此，只需实现<code>__fspath__</code>方法 </p><br><p> 现在，任何自写的<code>Path</code>实现都可以在本机中与需要文件路径的Python内置函数一起使用。  <strong>即使您不喜欢<code>pathlib</code> ，它的存在对于具有自己的<code>Path</code>的第三方库也是一大优势</strong> </p><br><h3 id="no-ved-pathlibpath-i-str-ne-smeshivayutsya-pravda"> 但是<code>pathlib.Path</code>和<code>str</code>不能混合使用，对吗？ </h3><br><p> 您可能会认为：这当然很好，但是这种有时使用行有时路径的方法会给我的代码增加一些复杂性吗？ </p><br><p> 在某种程度上，这个问题的答案是肯定的。 但是这个问题有一个非常简单的解决方法。 </p><br><p>  PEP 519除了<code>PathLike</code>之外还添加了其他一些<code>PathLike</code> ：首先，这是一种将<code>PathLike</code>转换为字符串的方法，其次，这是一种将<code>PathLike</code>转换为<code>Path</code> 。 </p><br><p> 让我们接受两个对象-字符串和<code>Path</code> （或使用<strong>fspath</strong>方法的任何对象）： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path p1 = os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'my_package'</span></span>) p2 = Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)</code> </pre> <br><p>  <code>os.fspath</code>函数对两个对象进行规范化并将它们转换为字符串： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fspath &gt;&gt;&gt; fspath(p1), fspath(p2) (<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>, <span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)</code> </pre> <br><p> 在这种情况下， <code>Path</code>可以将这两个对象都带入构造函数并将其转换为<code>Path</code> ： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Path(p1), Path(p2) (PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>), PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>))</code> </pre> <br><p> 这意味着您可以根据需要将<code>make_editorconfig</code>的结果转换回<code>Path</code> ： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; Path(make_editorconfig(Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>))) PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span>)</code> </pre> <br><p> 当然，最好的解决方案是使用<code>pathlib</code>重写<code>pathlib</code> 。 </p><br><h3 id="pathlib-slishkom-medlennyy">  <code>pathlib</code>太慢 </h3><br><p> 我已经看过几次有关<code>pathlib</code>性能的信息。 没错<code>pathlib</code>可能很慢。 创建数千个<code>Path</code>对象会严重影响程序行为。 </p><br><p> 我决定使用两个不同的程序在当前目录中查找所有<code>.py</code>文件的方式来测量我的计算机上<code>pathlib</code>和<code>os.path</code>的性能。 </p><br><p> 这是<code>os.walk</code>的版本： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getcwd, walk extension = <span class="hljs-string"><span class="hljs-string">'.py'</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, directories, filenames <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> walk(getcwd()): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filenames: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> filename.endswith(extension): count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{count}</span></span></span><span class="hljs-string"> Python files found"</span></span>)</code> </pre> <br><p> 这是<code>Path.rglob</code>的版本： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path extension = <span class="hljs-string"><span class="hljs-string">'.py'</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">f'*</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{extension}</span></span></span><span class="hljs-string">'</span></span>): count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{count}</span></span></span><span class="hljs-string"> Python files found"</span></span>)</code> </pre> <br><p> 测试与文件系统一起使用的程序的性能是一项艰巨的任务，因为操作时间可能会发生很大变化。 我决定将每个脚本运行10次，并比较每个程序的最佳结果。 </p><br><p> 这两个程序都在我运行它们的目录中找到了97507个文件。 第一个完成了1.914秒，第二个完成了3.430秒。 </p><br><p> 当我设置<code>extension=''</code>参数时，这些程序将找到大约600,000个文件，并且差异增加。 第一个程序耗时1.888秒，第二个程序耗时7.485秒。 </p><br><p> 因此，以<code>.py</code>扩展名的文件， <code>pathlib</code>速度大约是它的<strong>两倍</strong> ，而在我的主目录中启动时， <code>pathlib</code>速度<code>pathlib</code>是它的<strong>四倍</strong> 。  <code>pathlib</code>和<code>os</code>之间的相对性能差距很大。 </p><br><p> 就我而言，这个速度变化不大。 我搜索了目录中的所有文件，并丢失了6秒钟。 如果我要处理1000万个文件，则很可能会重写它。 但是尽管没有这种需要，您可以等待。 </p><br><p> 如果您有一段热门代码，而<code>pathlib</code>显然会对它的操作产生负面影响，那么用替代方法替换它就没有错。  <strong>您不应该优化代码，这不是瓶颈</strong> ，这是浪费时间，这通常也会导致代码可读性差，而不会造成很多浪费。 </p><br><h3 id="uluchshenie-chitaemosti"> 可读性提高 </h3><br><p> 我想用一些使用<code>pathlib</code>重构示例来结束这一思路。 我拿了一些小示例代码来处理文件，并使其与<code>pathlib</code>一起工作。 我将大部分代码保留在法庭上，而无需评论-确定您最喜欢的版本。 </p><br><p> 这是我们之前看到的<code>make_editorconfig</code>函数： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filename."""</span></span> filename = os.path.join(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(filename): os.makedirs(dir_path, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) open(filename, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>).write(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filename</code> </pre> <br><p> 这是在<code>pathlib</code>重写的版本： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filepath."""</span></span> path = Path(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> path.exists(): path.parent.mkdir(exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, parent=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) path.touch() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br><p> 这是一个控制台程序，该程序使用目录行并打印<code>.gitignore</code>文件的内容（如果存在）： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys directory = sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] ignore_filename = os.path.join(directory, <span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.path.isfile(ignore_filename): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(ignore_filename, mode=<span class="hljs-string"><span class="hljs-string">'rt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ignore_file: print(ignore_file.read(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p> 与<code>pathlib</code>相同： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys directory = Path(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ignore_path = directory / <span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ignore_path.is_file(): print(ignore_path.read_text(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p> 这是一个打印当前文件夹和子文件夹中所有重复文件的程序： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> defaultdict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> md5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getcwd, walk <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filepath)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, directories, filenames <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> walk(filepath): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filenames: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> os.path.join(root, filename) file_hashes = defaultdict(list) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> find_files(getcwd()): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path, mode=<span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> my_file: file_hash = md5(my_file.read()).hexdigest() file_hashes[file_hash].append(path) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> paths <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file_hashes.values(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(paths) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Duplicate files found:"</span></span>) print(*paths, sep=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre> <br><p> 与c <code>pathlib</code>相同： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> defaultdict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> md5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filepath)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path(filepath).rglob(<span class="hljs-string"><span class="hljs-string">'*'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.is_file(): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> path file_hashes = defaultdict(list) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> find_files(Path.cwd()): file_hash = md5(path.read_bytes()).hexdigest() file_hashes[file_hash].append(path) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> paths <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file_hashes.values(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(paths) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Duplicate files found:"</span></span>) print(*paths, sep=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre><br><p>  , , -,     .       <code>pathlib</code> . </p><br><h3 id="nachnite-ispolzovat-obekty-pathlibpath">    <code>pathlib.Path</code> </h3><br><p>  . </p><br><p>  <code>/</code>   <code>pathlib.Path</code>         .   ,    <strong>      </strong> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>path1 = Path(<span class="hljs-string"><span class="hljs-string">'dir'</span></span>, <span class="hljs-string"><span class="hljs-string">'file'</span></span>) &gt;&gt;&gt; path2 = Path(<span class="hljs-string"><span class="hljs-string">'dir'</span></span>) / <span class="hljs-string"><span class="hljs-string">'file'</span></span> &gt;&gt;&gt; path3 = Path(<span class="hljs-string"><span class="hljs-string">'dir/file'</span></span>) &gt;&gt;&gt; path3 WindowsPath(<span class="hljs-string"><span class="hljs-string">'dir/file'</span></span>) &gt;&gt;&gt; path1 == path2 == path3 <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><p>   Python  (. <code>open</code> )   <code>Path</code> ,  ,  <strong>   <code>pathlib</code> ,        !</strong> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> move <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rename_and_redirect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(old_filename, new_filename)</span></span></span><span class="hljs-function">:</span></span> move(old, new) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(old, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: f.write(<span class="hljs-string"><span class="hljs-string">f'This file has moved to </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{new}</span></span></span><span class="hljs-string">'</span></span>)</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; old, new = Path(<span class="hljs-string"><span class="hljs-string">'old.txt'</span></span>), Path(<span class="hljs-string"><span class="hljs-string">'new.txt'</span></span>) &gt;&gt;&gt; rename_and_redirect(old, new) &gt;&gt;&gt; old.read_text() <span class="hljs-string"><span class="hljs-string">'This file has moved to new.txt'</span></span></code> </pre> <br><p>      <code>pathlib</code> ,     ,    <code>PathLike</code> .  ,   <strong>      ,       ,   PEP 519</strong> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> plumbum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; my_path = Path(<span class="hljs-string"><span class="hljs-string">'old.txt'</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(my_path) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: ... print(f.read()) ... This file has moved to new.txt</code> </pre> <br><p>   <code>pathlib</code>    ,      (  ,    ),    <strong>         ,   </strong> . </p><br><p>  , <code>pathlib</code>     .       Python     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path gitignore = Path(<span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gitignore.is_file(): print(gitignore.read_text(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  <code>pathlib</code> — .    ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN453862/">https://habr.com/ru/post/zh-CN453862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN453846/index.html">IT领域HR专业人员的事件摘要（2019年6月）</a></li>
<li><a href="../zh-CN453848/index.html">AlphaFold：使用AI进行科学发现</a></li>
<li><a href="../zh-CN453850/index.html">中国社会信用体系-魔鬼是如此可怕吗？</a></li>
<li><a href="../zh-CN453852/index.html">微生物群。 如何保养肠道细菌</a></li>
<li><a href="../zh-CN453860/index.html">AMD推出了其新的定制7纳米处理器第三代Ryzen</a></li>
<li><a href="../zh-CN453864/index.html">在控制台上使用鼠标和键盘会欺骗吗？</a></li>
<li><a href="../zh-CN453866/index.html">具有React Hooks，HOC或Render Prop的API请求</a></li>
<li><a href="../zh-CN453868/index.html">带nRF52832玻璃面板的触摸式迷你开关</a></li>
<li><a href="../zh-CN453870/index.html">我们在powershell上编写Reverse socks5代理。第1部分</a></li>
<li><a href="../zh-CN453872/index.html">使用神经网络还原照片</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>