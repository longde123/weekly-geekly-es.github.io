<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🎤 👴🏽 🙏🏿 Wir generieren wunderschöne SVG-Platzhalter auf Node.js. 🐭 🔕 👩🏾‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Verwendung von SVG-Bildern als Platzhalter ist eine sehr gute Idee, insbesondere in unserer Welt, wenn fast alle Websites aus einer Reihe von Bild...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir generieren wunderschöne SVG-Platzhalter auf Node.js.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431232/"><p><img src="https://habrastorage.org/webt/ko/6n/vo/ko6nvoj9m3q1bdzvbeogrcbt09i.jpeg"></p><br><p> Die Verwendung von SVG-Bildern als Platzhalter ist eine sehr gute Idee, insbesondere in unserer Welt, wenn fast alle Websites aus einer Reihe von Bildern bestehen, die wir asynchron laden möchten.  Je mehr Bilder und je umfangreicher sie sind, desto höher ist die Wahrscheinlichkeit, dass verschiedene Probleme auftreten, angefangen bei der Tatsache, dass der Benutzer nicht genau versteht, was dort geladen wird, bis hin zum berühmten Sprung der gesamten Benutzeroberfläche nach dem Laden der Bilder.  Besonders bei schlechtem Internet von Ihrem Telefon aus kann es auf mehreren Bildschirmen wegfliegen.  In solchen Momenten kommen Stummel zur Rettung.  Eine weitere Option für ihre Verwendung ist die Zensur.  Es gibt Zeiten, in denen Sie ein Bild vor dem Benutzer verbergen müssen, aber ich möchte den Gesamtstil der Seite, die Farben und den Platz, den das Bild einnimmt, beibehalten. </p><br><p>  In den meisten Artikeln wird jedoch über die Theorie gesprochen, dass es schön wäre, all diese Stichbilder in Seiten in Reihe einzufügen, und heute werden wir in der Praxis sehen, wie Sie sie mit Node.js nach Ihrem Geschmack und Ihrer Farbe erzeugen können.  Wir werden Lenkervorlagen aus SVG-Bildern erstellen und auf verschiedene Arten ausfüllen, von der einfachen Füllung mit Farbe oder Farbverlauf bis zur Triangulation, dem Voronoi-Mosaik und der Verwendung von Filtern.  Alle Aktionen werden in Schritten sortiert.  Ich glaube, dieser Artikel wird für Anfänger interessant sein, die daran interessiert sind, wie dies gemacht wird, und eine detaillierte Analyse der Aktionen benötigen, aber erfahrene Entwickler mögen möglicherweise auch einige Ideen. </p><a name="habracut"></a><br><h2 id="podgotovka">  Vorbereitung </h2><br><p> Zunächst werden wir zu einem bodenlosen Repository aller Arten von Dingen gehen, die NPM genannt werden.  Da die Generierung unserer Stub-Images eine einmalige Generierung auf der Serverseite (oder sogar auf dem Computer des Entwicklers, wenn es sich um eine mehr oder weniger statische Site handelt) umfasst, werden wir uns nicht mit vorzeitiger Optimierung befassen.  Wir werden alles verbinden, was wir mögen.  Wir beginnen also mit dem <code>npm init</code> Zauber und fahren mit der Auswahl der Abhängigkeiten fort. </p><br><p>  Für den Anfang ist dies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ColorThief</a> .  Sie haben wahrscheinlich schon von ihm gehört.  Eine wunderbare Bibliothek, die die Farbpalette der am häufigsten verwendeten Farben im Bild isolieren kann.  Wir brauchen nur so etwas für den Anfang. </p><br><pre> <code class="plaintext hljs">npm i --save color-thief</code> </pre> <br><p>  Bei der Installation dieses Pakets unter Linux gab es ein Problem - ein fehlendes Cairo-Paket, das sich nicht im NPM-Verzeichnis befindet.  Dieser seltsame Fehler wurde durch die Installation von Entwicklungsversionen einiger Bibliotheken behoben: </p><br><pre> <code class="plaintext hljs">sudo apt install libcairo2-dev libjpeg-dev libgif-dev</code> </pre> <br><p>  Wie dieses Tool funktioniert, wird dabei beobachtet.  Es ist jedoch nicht überflüssig, das rgb-hex-Paket sofort anzuschließen, um das Farbformat von RGB in Hex zu konvertieren, was aus dem Namen hervorgeht.  Wir werden uns nicht mit so einfachen Funktionen auf das Radfahren einlassen. </p><br><pre> <code class="plaintext hljs">npm i --save rgb-hex</code> </pre> <br><blockquote>  Unter dem Gesichtspunkt der Schulung ist es nützlich, solche Dinge selbst zu schreiben. Wenn es jedoch darum geht, schnell einen minimal funktionierenden Prototyp zusammenzubauen, ist es eine gute Idee, alles aus dem NPM-Katalog zu verbinden.  Spart eine Menge Zeit. </blockquote><p>  Einer der wichtigsten Parameter für Stecker sind die Proportionen.  Sie müssen den Proportionen des Originalbildes entsprechen.  Dementsprechend müssen wir seine Größe kennen.  Wir werden das Paket in Bildgröße verwenden, um dieses Problem zu beheben. </p><br><pre> <code class="plaintext hljs">npm i --save image-size</code> </pre> <br><p>  Da wir versuchen werden, verschiedene Versionen der Bilder zu erstellen, die alle im SVG-Format vorliegen, stellt sich auf die eine oder andere Weise die Frage nach den Vorlagen für sie.  Sie können natürlich mit Musterzeichenfolgen in JS ausweichen, aber warum das alles?  Es ist besser, eine "normale" Vorlagen-Engine zu verwenden.  Zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lenker</a> .  Einfach und geschmackvoll, denn unsere Aufgabe wird genau richtig sein. </p><br><pre> <code class="plaintext hljs">npm i --save handlebars</code> </pre> <br><p>  Wir werden für dieses Experiment nicht sofort eine komplexe Architektur arrangieren.  Wir erstellen die Datei main.js und importieren dort alle unsere Abhängigkeiten sowie ein Modul für die Arbeit mit dem Dateisystem. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ColorThief = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'color-thief'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Handlebars = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'handlebars'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rgbHex = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'rgb-hex'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sizeOf = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'image-size'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>);</code> </pre> <br><p>  ColorThief erfordert eine zusätzliche Initialisierung </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> thief = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ColorThief();</code> </pre> <br><p>  Mit den Abhängigkeiten, die wir verbunden haben, ist es nicht schwierig, die Probleme zu lösen, ein Bild in ein Skript hochzuladen und seine Größe zu ermitteln.  Nehmen wir an, wir haben ein Bild 1.jpg: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> image = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'1.jpg'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> size = sizeOf(<span class="hljs-string"><span class="hljs-string">'1.jpg'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> height = size.height; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> width = size.width;</code> </pre> <br><p>  Für Leute, die mit Node.js nicht vertraut sind, ist es erwähnenswert, dass fast alles, was mit dem Dateisystem zu tun hat, synchron oder asynchron ablaufen kann.  Bei synchronen Methoden wird am Ende des Namens "Sync" hinzugefügt.  Wir werden sie verwenden, um nicht auf unnötige Komplikationen zu stoßen und unser Gehirn nicht aus heiterem Himmel zu zerbrechen. </p><br><p>  Fahren wir mit dem ersten Beispiel fort. </p><br><h2 id="zalivka-cvetom">  Farbfüllung </h2><br><p><img src="https://habrastorage.org/webt/xa/1p/7g/xa1p7gmnqwkm9rcdntn9qbtnrjm.jpeg"></p><br><p>  Zunächst lösen wir das Problem des einfachen Füllens des Rechtecks.  Unser Bild hat drei Parameter - Breite, Höhe und Füllfarbe.  Wir erstellen ein SVG-Bild mit einem Rechteck, ersetzen jedoch anstelle dieser Werte Klammerpaare und die Namen der Felder, die die vom Skript übertragenen Daten enthalten.  Sie haben diese Syntax wahrscheinlich bereits mit herkömmlichem HTML gesehen (zum Beispiel verwendet Vue etwas Ähnliches), aber niemand stört sich daran, sie mit einem SVG-Bild zu verwenden - der Template-Engine ist es egal, wie sie auf lange Sicht aussehen wird.  Der Text ist er und der Text in Afrika. </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'1.1'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'http://www.w3.org/2000/svg'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">viewBox</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0 0 100 100'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">preserveAspectRatio</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'none'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ height }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ width }}'</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rect</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ color }}'</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Weiter ColorThief gibt uns eine der häufigsten Farben, im Beispiel ist es grau.  Um die Vorlage zu verwenden, lesen wir die Datei damit, sagen wir Lenker, damit diese Bibliothek sie kompiliert, und generieren dann eine Zeile mit dem fertigen SVG-Stub.  Die Template-Engine selbst ersetzt unsere Daten (Farbe und Größe) an den richtigen Stellen. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateOneColor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rgb = thief.getColor(image); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...rgb); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> template = Handlebars.compile(fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'template-one-color.svg'</span></span>, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> svg = template({ height, width, color }); fs.writeFileSync(<span class="hljs-string"><span class="hljs-string">'1-one-color.svg'</span></span>, svg, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>); }</code> </pre> <br><p>  Es bleibt nur das Ergebnis in eine Datei zu schreiben.  Wie Sie sehen können, ist die Arbeit mit SVG ziemlich gut - alle Dateien sind Textdateien, Sie können sie leicht lesen und schreiben.  Das Ergebnis ist ein Rechteckbild.  Nichts Interessantes, aber zumindest haben wir sichergestellt, dass der Ansatz funktioniert (ein Link zu den vollständigen Quellen befindet sich am Ende des Artikels). </p><br><h2 id="zalivka-gradientom">  Verlaufsfüllung </h2><br><p>  Die Verwendung von Verläufen ist ein interessanterer Ansatz.  Hier können wir einige gängige Farben aus dem Bild verwenden und einen reibungslosen Übergang von einer zur anderen vornehmen.  Dies kann manchmal auf Websites gefunden werden, die lange Bildbänder laden. </p><br><p><img src="https://habrastorage.org/webt/_e/hk/dp/_ehkdpgdhchgknqkcvbadu8dwpq.jpeg"></p><br><p>  Unsere SVG-Vorlage wurde jetzt mit genau diesem Farbverlauf erweitert.  Als Beispiel verwenden wir den üblichen linearen Gradienten.  Wir interessieren uns nur für zwei Parameter - die Farbe am Anfang und die Farbe am Ende: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">defs</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">linearGradient</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'my-gradient'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x1</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y1</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x2</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y2</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">gradientTransform</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'rotate(45)'</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">stop</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">offset</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'stop-color:{{ startColor }};stop-opacity:1'</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">stop</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">offset</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'stop-color:{{ endColor }};stop-opacity:1'</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">linearGradient</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">defs</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rect</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'url(#my-gradient)'</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  Die Farben selbst werden mit demselben ColorThief erhalten.  Es gibt zwei Betriebsarten - entweder eine Primärfarbe oder eine Palette mit der von uns angegebenen Anzahl von Farben.  Bequem genug.  Für den Verlauf benötigen wir zwei Farben. </p><br><p>  Ansonsten ähnelt dieses Beispiel dem vorherigen: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateGradient</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> palette = thief.getPalette(image, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> startColor = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...palette[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> endColor = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...palette[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> template = Handlebars.compile(fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'template-gradient.svg'</span></span>, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> svg = template({ height, width, startColor, endColor }); <span class="hljs-comment"><span class="hljs-comment">// . . .</span></span></code> </pre> <br><p>  Auf diese Weise können Sie alle Arten von Verläufen erstellen - nicht unbedingt linear.  Trotzdem ist dies ein ziemlich langweiliges Ergebnis.  Es wäre großartig, eine Art Mosaik zu erstellen, das dem Originalbild aus der Ferne ähnelt. </p><br><h2 id="mozaika-iz-pryamougolnikov">  Rechteckmosaik </h2><br><p>  Lassen Sie uns zunächst viele Rechtecke erstellen und sie mit Farben aus der Palette füllen, die dieselbe Bibliothek uns geben wird. </p><br><p><img src="https://habrastorage.org/webt/l6/w2/hd/l6w2hd1l4bgc-pand_tz2gixe3s.jpeg"></p><br><p>  Lenker können viele verschiedene Dinge tun, insbesondere hat er Zyklen.  Wir werden ihm eine Reihe von Koordinaten und Farben übergeben, und dann wird er es herausfinden.  Wir wickeln einfach unser Rechteck in die Vorlage in jedem: </p><br><pre> <code class="xml hljs">{{# each rects }} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rect</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ x }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ y }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'11'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'11'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ color }}'</span></span></span><span class="hljs-tag"> /&gt;</span></span> {{/each }}</code> </pre> <br><p>  Dementsprechend haben wir im Skript selbst jetzt eine vollwertige Farbpalette, durchlaufen die X / Y-Koordinaten und erstellen ein Rechteck mit einer zufälligen Farbe aus der Palette.  Alles ist ganz einfach: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateMosaic</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> palette = thief.getPalette(image, <span class="hljs-number"><span class="hljs-number">16</span></span>); palette.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">color, index</span></span></span><span class="hljs-function">) </span></span>{ palette[index] = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...color); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rects = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; x += <span class="hljs-number"><span class="hljs-number">10</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; y += <span class="hljs-number"><span class="hljs-number">10</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = palette[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">15</span></span>)]; rects.push({ x, y, color }); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> template = Handlebars.compile(fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'template-mosaic.svg'</span></span>, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> svg = template({ height, width, rects }); <span class="hljs-comment"><span class="hljs-comment">// . . .</span></span></code> </pre><br><p>  Offensichtlich ist das Mosaik zwar farblich ähnlich wie das Bild, aber mit der Anordnung der Farben ist überhaupt nicht alles so, wie wir es gerne hätten.  Die Funktionen von ColorThief in diesem Bereich sind begrenzt.  Ich hätte gerne ein Mosaik, in dem das Originalbild erraten würde, und nicht nur ein Satz Steine ​​mit mehr oder weniger gleichen Farben. </p><br><h2 id="uluchshaem-mozaiku">  Das Mosaik verbessern </h2><br><p>  Hier müssen wir etwas tiefer gehen und die Farben aus den Pixeln im Bild erhalten ... </p><br><p><img src="https://habrastorage.org/webt/qf/mt/60/qfmt60p4wqhi0yil0r28wtdjskq.jpeg"></p><br><p>  Da wir offensichtlich keinen Canvas in der Konsole haben, von dem wir normalerweise diese Daten erhalten, werden wir die Hilfe in Form eines get-pixels-Pakets verwenden.  Er kann die notwendigen Informationen mit einem Bild, das wir bereits haben, aus dem Puffer ziehen. </p><br><pre> <code class="plaintext hljs">npm i --save get-pixels</code> </pre> <br><p>  Es wird ungefähr so ​​aussehen: </p><br><pre> <code class="javascript hljs">getPixels(image, <span class="hljs-string"><span class="hljs-string">'image/jpg'</span></span>, (err, pixels) =&gt; { <span class="hljs-comment"><span class="hljs-comment">// . . . });</span></span></code> </pre> <br><p>  Wir erhalten ein Objekt, das das Datenfeld enthält - ein Array von Pixeln, genau wie wir es von der Leinwand erhalten.  Ich möchte Sie daran erinnern, dass Sie einfache Berechnungen durchführen müssen, um die Farbe eines Pixels anhand der Koordinaten (X, Y) zu erhalten: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixelPosition = <span class="hljs-number"><span class="hljs-number">4</span></span> * (y * width + x); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rgb = [ pixels.data[pixelPosition], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">1</span></span>], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">2</span></span>] ];</code> </pre> <br><p>  Somit können wir für jedes Rechteck die Farbe nicht aus der Palette, sondern direkt aus dem Bild nehmen und verwenden.  Sie erhalten so etwas (die Hauptsache hier ist nicht zu vergessen, dass sich die Koordinaten im Bild von unseren "normalisierten" von 0 bis 100 unterscheiden): </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateImprovedMosaic</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ getPixels(image, <span class="hljs-string"><span class="hljs-string">'image/jpg'</span></span>, (err, pixels) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rects = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; x += <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> realX = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(x * width / <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; y += <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> realY = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(y * height / <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixelPosition = <span class="hljs-number"><span class="hljs-number">4</span></span> * (realY * width + realX); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rgb = [ pixels.data[pixelPosition], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">1</span></span>], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">2</span></span>] ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...rgb); rects.push({ x, y, color }); } } <span class="hljs-comment"><span class="hljs-comment">// . . .</span></span></code> </pre> <br><p>  Für mehr Schönheit können wir die Anzahl der "Steine" leicht erhöhen und ihre Größe verringern.  Da wir diese Größe nicht an die Vorlage übergeben (es lohnt sich natürlich, sie als Parameter wie die Breite oder Höhe des Bildes festzulegen), ändern wir die Größenwerte in der Vorlage selbst: </p><br><pre> <code class="xml hljs">{{# each rects }} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rect</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ x }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ y }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'6'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'6'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ color }}'</span></span></span><span class="hljs-tag"> /&gt;</span></span> {{/each }}</code> </pre> <br><p>  Jetzt haben wir ein Mosaik, das wirklich wie das Originalbild aussieht, aber gleichzeitig eine Größenordnung weniger Platz einnimmt. </p><br><blockquote>  Vergessen Sie nicht, dass GZIP solche sich wiederholenden Sequenzen in Textdateien gut komprimiert, damit beim Übertragen in den Browser die Größe einer solchen Vorschau noch kleiner wird. </blockquote><p>  Aber lass uns weitermachen. </p><br><h2 id="triangulyaciya">  Triangulation </h2><br><p><img src="https://habrastorage.org/webt/by/h7/dq/byh7dqqiigv_3v5ayf-1lw8deyw.jpeg"></p><br><p>  Rechtecke sind gut, aber Dreiecke liefern normalerweise viel interessantere Ergebnisse.  Versuchen wir also, aus einem Stapel Dreiecke ein Mosaik zu machen.  Es gibt verschiedene Ansätze für dieses Problem. Wir werden die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Delaunay-Triangulation verwenden</a> : </p><br><pre> <code class="plaintext hljs">npm i --save delaunay-triangulate</code> </pre> <br><p>  Der Hauptvorteil des Algorithmus, den wir verwenden werden, besteht darin, dass Dreiecke mit sehr scharfen und stumpfen Winkeln nach Möglichkeit vermieden werden.  Für ein schönes Bild benötigen wir keine schmalen und langen Dreiecke. </p><br><blockquote>  Dies ist einer dieser Momente, in denen es nützlich ist zu wissen, welche mathematischen Algorithmen auf unserem Gebiet existieren und was der Unterschied darin ist.  Es ist nicht notwendig, sich alle Implementierungen zu merken, aber es ist zumindest nützlich zu wissen, was zu googeln ist. </blockquote><p>  Teilen Sie unsere Aufgabe in kleinere auf.  Zuerst müssen Sie Punkte für die Eckpunkte der Dreiecke generieren.  Und es wäre schön, ihren Koordinaten etwas Zufälligkeit hinzuzufügen: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateTriangulation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// . . . const basePoints = []; for (let x = 0; x &lt;= 100; x += 5) { for (let y = 0; y &lt;= 100; y += 5) { const point = [x, y]; if ((x &gt;= 5) &amp;&amp; (x &lt;= 95)) { point[0] += Math.floor(10 * Math.random() - 5); } if ((y &gt;= 5) &amp;&amp; (y &lt;= 95)) { point[1] += Math.floor(10 * Math.random() - 5); } basePoints.push(point); } } const triangles = triangulate(basePoints); // . . .</span></span></code> </pre> <br><p>  Nachdem wir die Struktur des Arrays mit Dreiecken überprüft haben (console.log, um uns zu helfen), finden wir uns Punkte, an denen wir die Farbe des Pixels annehmen werden.  Sie können einfach das arithmetische Mittel für die Koordinaten der Eckpunkte der Dreiecke berechnen.  Dann verschieben wir die zusätzlichen Punkte vom äußersten Rand, damit sie nicht herauskriechen, und nachdem wir echte, nicht normalisierte Koordinaten erhalten haben, erhalten wir die Farbe des Pixels, die zur Farbe des Dreiecks wird. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> polygons = []; triangles.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">triangle</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((basePoints[triangle[<span class="hljs-number"><span class="hljs-number">0</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>] + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">1</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>] + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">2</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>]) / <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((basePoints[triangle[<span class="hljs-number"><span class="hljs-number">0</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>] + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">1</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>] + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">2</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>]) / <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x === <span class="hljs-number"><span class="hljs-number">100</span></span>) { x = <span class="hljs-number"><span class="hljs-number">99</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y === <span class="hljs-number"><span class="hljs-number">100</span></span>) { y = <span class="hljs-number"><span class="hljs-number">99</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> realX = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(x * width / <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> realY = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(y * height / <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixelPosition = <span class="hljs-number"><span class="hljs-number">4</span></span> * (realY * width + realX); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rgb = [ pixels.data[pixelPosition], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">1</span></span>], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">2</span></span>] ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...rgb); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> points = <span class="hljs-string"><span class="hljs-string">' '</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">0</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">','</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">0</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-string"><span class="hljs-string">' '</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">1</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">','</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">1</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-string"><span class="hljs-string">' '</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">2</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">','</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">2</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>]; polygons.push({ points, color }); });</code> </pre> <br><p>  Es bleibt nur, die Koordinaten der gewünschten Punkte in einer Zeichenfolge zu sammeln und sie zusammen mit der Farbe zur Verarbeitung an den Lenker zu senden, wie wir es zuvor getan haben. </p><br><p>  In der Vorlage selbst haben wir jetzt keine Rechtecke mehr, sondern Polygone: </p><br><pre> <code class="xml hljs">{{# each polygons }} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">polygon</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">points</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ points }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'stroke-width:0.1;stroke:{{ color }};fill:{{ color }}'</span></span></span><span class="hljs-tag"> /&gt;</span></span> {{/each }}</code> </pre> <br><p>  Triangulation ist eine sehr interessante Sache.  Wenn Sie die Anzahl der Dreiecke erhöhen, erhalten Sie nur schöne Bilder, da niemand sagt, dass wir sie nur als Stummel verwenden dürfen. </p><br><h2 id="mozaika-voronogo">  Mosaik von Voronoi </h2><br><p>  Es gibt ein Problem, den Spiegel des vorherigen - eine Trennwand oder ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mosaik von Voronoi</a> .  Wir haben es bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bei der Arbeit mit Shadern verwendet</a> , aber hier kann es auch nützlich sein. </p><br><p><img src="https://habrastorage.org/webt/ij/-y/4m/ij-y4mnhq9tlbbkewlmfeyn-q0k.jpeg"></p><br><p>  Wie bei anderen bekannten Algorithmen haben wir eine vorgefertigte Implementierung: </p><br><pre> <code class="plaintext hljs">npm i --save voronoi</code> </pre> <br><p>  Weitere Aktionen werden denen im vorherigen Beispiel sehr ähnlich sein.  Der einzige Unterschied besteht darin, dass wir jetzt eine andere Struktur haben - anstelle einer Anordnung von Dreiecken haben wir ein komplexes Objekt.  Und die Optionen sind etwas anders.  Ansonsten ist fast alles gleich.  Ein Array von Basispunkten wird auf die gleiche Weise generiert. Überspringen Sie es, um die Auflistung nicht zu lang zu machen: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateVoronoi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// . . . const box = { xl: 0, xr: 100, yt: 0, yb: 100 }; const diagram = voronoi.compute(basePoints, box); const polygons = []; diagram.cells.forEach((cell) =&gt; { let x = cell.site.x; let y = cell.site.y; if (x === 100) { x = 99; } if (y === 100) { y = 99; } const realX = Math.floor(x * width / 100); const realY = Math.floor(y * height / 100); const pixelPosition = 4 * (realY * width + realX); const rgb = [ pixels.data[pixelPosition], pixels.data[pixelPosition + 1], pixels.data[pixelPosition + 2] ]; const color = '#' + rgbHex(...rgb); let points = ''; cell.halfedges.forEach((halfedge) =&gt; { const endPoint = halfedge.getEndpoint(); points += endPoint.x.toFixed(2) + ',' + endPoint.y.toFixed(2) + ' '; }); polygons.push({ points, color }); }); // . . .</span></span></code> </pre> <br><p>  Als Ergebnis erhalten wir ein Mosaik aus konvexen Polygonen.  Auch ein sehr interessantes Ergebnis. </p><br><blockquote>  Es ist nützlich, alle Zahlen entweder auf ganze Zahlen oder auf mindestens ein paar Dezimalstellen abzurunden.  Eine übermäßige Genauigkeit in SVG ist hier völlig unnötig, sondern vergrößert nur die Bilder. </blockquote><br><h2 id="razmytaya-mozaika">  Verschwommenes Mosaik </h2><br><p>  Das letzte Beispiel, das wir sehen werden, ist ein verschwommenes Mosaik.  Wir haben die ganze Kraft von SVG in unseren Händen. Warum also nicht Filter verwenden? </p><br><p><img src="https://habrastorage.org/webt/xt/us/k1/xtusk1lqy7g9zsolqqanjrmqcva.jpeg"></p><br><p>  Nehmen Sie das erste Mosaik aus Rechtecken und fügen Sie den Standardfilter "Unschärfe" hinzu: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">defs</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'my-filter'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">feGaussianBlur</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">in</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'SourceGraphic'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">stdDeviation</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'2'</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">defs</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">g</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">filter</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'url(#my-filter)'</span></span></span><span class="hljs-tag">&gt;</span></span> {{# each rects }} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rect</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ x }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ y }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'6'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'6'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ color }}'</span></span></span><span class="hljs-tag"> /&gt;</span></span> {{/each }} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">g</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Das Ergebnis ist eine verschwommene, „zensierte“ Vorschau unseres Bildes. Es nimmt fast zehnmal weniger Platz (ohne Komprimierung), Vektor und erstreckt sich auf jede Bildschirmgröße.  Auf die gleiche Weise können Sie den Rest unserer Mosaike verwischen. </p><br><blockquote>  Wenn Sie einen solchen Filter auf ein normales Mosaik aus Rechtecken anwenden, kann sich der "Jeep-Effekt" herausstellen. Wenn Sie also in der Produktion so etwas verwenden, insbesondere bei großen Bildern, ist es möglicherweise schöner, Unschärfe nicht darauf, sondern auf Voronois Aufteilung anzuwenden. </blockquote><br><h2 id="vmesto-zaklyucheniya">  Anstelle einer Schlussfolgerung </h2><br><p>  In diesem Artikel haben wir uns angesehen, wie Sie auf Node.js alle Arten von SVG-Stub-Bildern generieren können, und sichergestellt, dass dies keine so schwierige Aufgabe ist, wenn Sie nicht alles von Hand schreiben und wenn möglich vorgefertigte Module zusammenstellen.  Vollständige Quellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sind auf Github verfügbar</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431232/">https://habr.com/ru/post/de431232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431220/index.html">Der Blick eines Biologen auf die Wurzeln unseres Alterns</a></li>
<li><a href="../de431222/index.html">Website-Archivierung</a></li>
<li><a href="../de431226/index.html">Das Snake-Spiel für FPGA Cyclone IV (mit VGA- und SPI-Joystick)</a></li>
<li><a href="../de431228/index.html">Hindernislauf für Licht: Flüssigkristalle helfen</a></li>
<li><a href="../de431230/index.html">Speicher für HPC-Infrastruktur oder wie wir 65 PB-Speicher im RIKEN Japan Research Center gesammelt haben</a></li>
<li><a href="../de431234/index.html">11. Dezember, Moskau - Alfa JS MeetUp</a></li>
<li><a href="../de431236/index.html">Wie schreibe ich 2018 auf Objective-C? Teil 1</a></li>
<li><a href="../de431238/index.html">Die Zusammenfassung der Ereignisse für HR-Experten im Bereich IT für Dezember 2018</a></li>
<li><a href="../de431242/index.html">TLS- und Webzertifikate</a></li>
<li><a href="../de431244/index.html">"Zwei ungefiltert" oder eine einfache Möglichkeit, ein Bein zu schießen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>