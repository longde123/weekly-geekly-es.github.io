<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßïüèΩ üïã üßê Kunci PostgreSQL: 2. Kunci string üíª üë®üèæ‚Äçüöí üõ∞Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terakhir kali, kami berbicara tentang kunci tingkat objek , khususnya, tentang kunci pada hubungan. Hari ini kita akan melihat bagaimana kunci baris d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kunci PostgreSQL: 2. Kunci string</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/463819/">  Terakhir kali, kami berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kunci tingkat objek</a> , khususnya, tentang kunci pada hubungan.  Hari ini kita akan melihat bagaimana kunci baris diatur dalam PostgreSQL dan bagaimana mereka digunakan bersama dengan kunci objek, mari kita bicara tentang antrian menunggu dan mereka yang memanjat keluar dari belokan. <br><br><img src="https://habrastorage.org/webt/6x/u5/jj/6xu5jj3edymfhel21v9obwhsxai.png"><br><br><h1>  Kunci baris </h1><br><h2>  Perangkat </h2><br>  Biarkan saya mengingatkan Anda pada beberapa kesimpulan penting dari artikel terakhir. <br><br><ul><li>  Kunci harus ada di suatu tempat di memori bersama server. </li><li>  Semakin tinggi rincian kunci, semakin sedikit kompetisi (pertengkaran) di antara proses yang berjalan secara bersamaan. </li><li>  Di sisi lain, semakin tinggi rinciannya, semakin banyak ruang memori ditempati oleh kunci. </li></ul><br>  Kami tentu menginginkan perubahan satu baris untuk tidak memblokir baris lain dari tabel yang sama.  Tetapi kita tidak mampu memulai setiap baris dengan kunci kita sendiri. <br><br>  Ada berbagai cara untuk mengatasi masalah ini.  Dalam beberapa DBMS, ada peningkatan tingkat penguncian: jika ada terlalu banyak kunci tingkat baris, mereka digantikan oleh satu kunci yang lebih umum (misalnya, tingkat halaman atau seluruh tabel). <br><br>  Seperti yang akan kita lihat nanti, PostgreSQL juga menggunakan mekanisme ini, tetapi hanya untuk kunci predikat.  Kunci garis berbeda. <br><a name="habracut"></a><br>  Dalam PostgreSQL, informasi bahwa suatu baris dikunci disimpan hanya dan secara eksklusif dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi baris</a> di dalam halaman data (dan bukan dalam RAM).  Artinya, ini bukan blok sama sekali dalam arti biasa, tetapi hanya sebuah pertanda.  Tanda ini sebenarnya adalah nomor transaksi xmax dikombinasikan dengan bit informasi tambahan;  sedikit kemudian kita akan melihat secara detail bagaimana ini bekerja. <br><br>  <strong>Nilai tambahnya</strong> adalah kita dapat memblokir sebanyak mungkin jalur tanpa menggunakan sumber daya apa pun. <br><br>  Tetapi ada <strong>kekurangannya</strong> : karena informasi tentang kunci tidak disajikan dalam RAM, proses lain tidak dapat dilakukan.  Dan tidak ada kemungkinan pemantauan (untuk menghitung kunci, Anda perlu membaca seluruh tabel). <br><br>  Yah, pemantauan baik-baik saja, tetapi ada sesuatu yang harus dilakukan dengan antrian.  Untuk melakukan ini, Anda masih harus menggunakan kunci "biasa".  Jika kita perlu menunggu sampai baris dilepaskan, pada kenyataannya, kita harus menunggu sampai akhir transaksi pemblokiran - semua kunci dilepaskan ketika melakukan atau memutar kembali.  Dan untuk ini, Anda dapat meminta nomor pemblokiran transaksi pemblokiran (yang, saya ingat, dipegang oleh transaksi itu sendiri dalam mode luar biasa).  Dengan demikian, jumlah kunci yang digunakan sebanding dengan jumlah proses yang berjalan secara bersamaan, dan tidak dengan jumlah baris yang diubah. <br><br><h2>  Mode Luar Biasa </h2><br>  Total ada 4 mode di mana Anda dapat mengunci garis.  Dari jumlah tersebut, dua mode mewakili kunci <em>eksklusif</em> yang hanya dapat dimiliki oleh satu transaksi dalam satu waktu. <br><br><ul><li>  Mode FOR UPDATE menyiratkan perubahan lengkap (atau penghapusan) dari suatu baris. </li><li>  FOR NO KEY UPDATE mode - hanya mengubah bidang-bidang yang tidak termasuk dalam indeks unik (dengan kata lain, dengan perubahan seperti itu, semua kunci asing tetap tidak berubah). </li></ul><br>  Perintah UPDATE sendiri memilih mode kunci minimum yang sesuai;  biasanya baris dikunci dalam mode TANPA KUNCI KUNCI. <br><br>  Seperti yang Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ingat</a> , ketika menghapus atau mengubah baris, nomor versi transaksi saat ini ditulis dalam bidang xmax dari versi saat ini.  Ini menunjukkan bahwa versi baris telah dihapus oleh transaksi ini.  Jadi, nomor xmax yang sama digunakan sebagai tanda pemblokiran.  Faktanya, jika xmax dalam versi baris sesuai dengan transaksi aktif (belum selesai) dan kami ingin memperbarui jalur khusus ini, maka kami harus menunggu transaksi selesai, sehingga tidak diperlukan tanda tambahan. <br><br>  Ayo lihat.  Buat tabel akun, sama seperti di artikel sebelumnya. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( acc_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">300.00</span></span>);</code> </pre> <br>  Untuk melihat halaman-halamannya, tentu saja, kita perlu ekstensi pagepage yang sudah akrab. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect;</code> </pre><br>  Untuk kenyamanan, buat tampilan yang hanya menampilkan informasi yang kami minati: xmax dan beberapa bit informasi. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">128</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> lock_only, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">4096</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> is_multi, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask2 &amp; <span class="hljs-number"><span class="hljs-number">8192</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> keys_upd, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">16</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> keyshr_lock, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">16</span></span>+<span class="hljs-number"><span class="hljs-number">64</span></span>) = <span class="hljs-number"><span class="hljs-number">16</span></span>+<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> shr_lock <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> lp;</code> </pre><br>  Jadi, kami memulai transaksi dan memperbarui jumlah akun pertama (kunci tidak berubah) dan jumlah akun kedua (kunci perubahan): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Kami melihat ke tampilan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530492 | | | | | (0,2) | 530492 | | | t | | (2 rows)</code> </pre><br>  Mode kunci ditentukan oleh bit informasi keys_updated. <br><br>  Kolom xmax yang sama juga digunakan saat mengunci baris dengan perintah SELECT FOR UPDATE, tetapi dalam kasus ini bit informasi tambahan (xmax_lock_only) diletakkan, yang menunjukkan bahwa versi baris hanya dikunci, tetapi tidak dihapus dan masih relevan. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR NO KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530493 | t | | | | (0,2) | 530493 | t | | t | | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><br><h2>  Mode Bersama </h2><br>  Dua mode lagi mewakili kunci bersama yang dapat ditahan oleh beberapa transaksi. <br><br><ul><li>  Mode FOR SHARE digunakan ketika Anda perlu membaca sebuah string, tetapi Anda tidak boleh memperbolehkannya diubah dengan cara apa pun oleh transaksi lain. </li><li>  Mode FOR KEY SHARE memungkinkan perubahan string, tetapi hanya bidang non-kunci.  Mode ini, khususnya, secara otomatis digunakan oleh PostgreSQL saat memeriksa kunci asing. </li></ul><br>  Ayo lihat. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><br>  Dalam versi baris kita melihat: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530494 | t | | | t | (0,2) | 530494 | t | | | t | t (2 rows)</code> </pre><br>  Dalam kedua kasus, bit keyshr_lock diatur, dan mode SHARE dapat dikenali dengan melihat satu bit informasi lagi. <br><br>  Inilah yang tampak seperti matriks kompatibilitas mode umum. <br><br><div class="scrollable-table"><table><tbody><tr><th>  mode </th><th>  UNTUK SHARE KUNCI </th><th>  UNTUK SAHAM </th><th>  TANPA PEMBARUAN KUNCI </th><th>  UNTUK PEMBARUAN </th></tr><tr><td>  UNTUK SHARE KUNCI </td><td></td><td></td><td></td><td>  X </td></tr><tr><td>  UNTUK SAHAM </td><td></td><td></td><td>  X </td><td>  X </td></tr><tr><td>  TANPA PEMBARUAN KUNCI </td><td></td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td>  UNTUK PEMBARUAN </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr></tbody></table></div><br>  Itu menunjukkan bahwa: <br><br><ul><li>  mode luar biasa saling bertentangan; </li><li>  mode bersama kompatibel satu sama lain; </li><li>  mode FOR KEY SHARE bersama yang dibagikan kompatibel dengan mode FOR FOR KEY UPDATE (yaitu, Anda dapat memperbarui bidang non-kunci secara bersamaan dan memastikan bahwa kunci tersebut tidak berubah). </li></ul><br><h2>  Multi-transaksi </h2><br>  Sampai sekarang, kami berpikir bahwa kunci diwakili oleh jumlah transaksi pemblokiran di bidang xmax.  Tetapi kunci bersama dapat disimpan oleh beberapa transaksi, dan beberapa nomor tidak dapat ditulis ke bidang xmax yang sama.  Bagaimana menjadi <br><br>  Untuk kunci bersama, yang disebut <em>multi-</em> transaksi (MultiXact) digunakan.  Ini adalah grup transaksi yang diberi nomor terpisah.  Nomor ini memiliki dimensi yang sama dengan nomor transaksi reguler, tetapi angka-angka tersebut dialokasikan secara independen (yaitu, sistem dapat memiliki nomor transaksi dan multi-transaksi yang sama).  Untuk membedakan satu dari yang lain, bit informasi lain (xmax_is_multi) digunakan, dan informasi terperinci tentang anggota grup tersebut dan mode kunci terletak di file dalam direktori $ PGDATA / pg_multixact /.  Secara alami, data yang terakhir digunakan disimpan dalam buffer dalam memori bersama server untuk akses yang lebih cepat. <br><br>  Tambahkan ke kunci yang ada satu lagi yang luar biasa yang dieksekusi oleh transaksi lain (kita bisa melakukan ini, karena mode FOR KEY SHARE dan FOR NO KEY UPDATE kompatibel satu sama lain): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 61 | | t | | | (0,2) | 530494 | t | | | t | t (2 rows)</code> </pre><br>  Di baris pertama, kita melihat bahwa nomor yang biasa telah digantikan oleh nomor multitransaksi - ini dibuktikan dengan bit xmax_is_multi. <br><br>  Agar tidak mempelajari internal implementasi multitransaksi, Anda dapat menggunakan ekstensi lain yang memungkinkan Anda melihat semua informasi tentang semua jenis kunci baris dengan cara yang mudah. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgrowlocks; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------------------------- locked_row | (0,1) locker | 61 multi | t xids | {530494,530495} modes | {"Key Share","No Key Update"} pids | {5892,5928} -[ RECORD 2 ]----------------------------- locked_row | (0,2) locker | 530494 multi | f xids | {530494} modes | {"For Share"} pids | {5892}</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h2>  Pengaturan beku </h2><br>  Karena angka-angka yang terpisah dialokasikan untuk multitransaksi, yang ditulis dalam bidang xmax versi baris, karena batas kapasitas digit penghitung, mereka mengalami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah</a> sampul xid yang sama dengan angka biasa. <br><br>  Oleh karena itu, untuk nomor multi-transaksi, perlu juga melakukan analog pembekuan - ganti nomor lama dengan yang baru (atau dengan nomor transaksi reguler, jika pada saat pembekuan kunci dipegang oleh hanya satu transaksi). <br><br>  Perhatikan bahwa pembekuan nomor transaksi biasa dilakukan hanya untuk bidang xmin (karena jika versi baris memiliki bidang xmax non-kosong, maka itu adalah versi yang tidak relevan dan akan dihapus, atau transaksi xmax dibatalkan dan jumlahnya tidak menarik bagi kami).  Tetapi untuk multi-transaksi, kita berbicara tentang bidang xmax dari versi baris saat ini, yang dapat tetap relevan, tetapi itu terus-menerus diblokir oleh transaksi yang berbeda dalam mode bersama. <br><br>  Untuk pembekuan <em>transaksi</em> multi, parameter yang mirip dengan parameter pembekuan biasa <em>bertanggung jawab</em> : <em>vacuum_multixact_freeze_min_age</em> , <em>vacuum_multixact_freeze_table_age</em> , <em>autovacuum_multixact_freeze_max_age</em> . <br><br><h1>  Siapa yang ekstrem? </h1><br>  Perlahan mendekati si manis.  Mari kita lihat apa gambar kunci ketika beberapa transaksi akan memperbarui baris yang sama. <br><br>  Mari kita mulai dengan membangun view di pg_locks.  Pertama, kami akan membuat kesimpulan sedikit lebih kompak, dan kedua, kami akan membatasi diri kami pada kunci yang menarik (pada kenyataannya, kami membuang kunci nomor transaksi virtual, indeks pada tabel akun, pg_locks dan tampilan itu sendiri - secara umum, segala sesuatu yang tidak relevan dan hanya mengganggu). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, locktype, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> locktype <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'relation'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'transactionid'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> transactionid::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'tuple'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>||<span class="hljs-string"><span class="hljs-string">':'</span></span>||tuple::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> lockid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> locktype <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'relation'</span></span>,<span class="hljs-string"><span class="hljs-string">'transactionid'</span></span>,<span class="hljs-string"><span class="hljs-string">'tuple'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (locktype != <span class="hljs-string"><span class="hljs-string">'relation'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><br>  Sekarang mulailah transaksi pertama dan perbarui baris. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> txid_current | pg_backend_pid --------------+---------------- 530497 | 5892 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br>  Bagaimana dengan kunci? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5892</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5892 | relation | accounts | RowExclusiveLock | t 5892 | transactionid | 530497 | ExclusiveLock | t (2 rows)</code> </pre><br>  Transaksi memegang kunci meja dan sendiri.  Sejauh ini semuanya diharapkan. <br><br>  Kami memulai transaksi kedua dan mencoba memperbarui jalur yang sama. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| txid_current | pg_backend_pid | --------------+---------------- | 530498 | 5928 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Bagaimana dengan kunci transaksi kedua? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | transactionid | 530498 | ExclusiveLock | t 5928 | transactionid | 530497 | ShareLock | f 5928 | tuple | accounts:1 | ExclusiveLock | t (4 rows)</code> </pre><br>  Dan ini dia lebih menarik.  Selain mengunci meja dan nomor sendiri, kita melihat dua kunci lagi.  Transaksi kedua menemukan bahwa baris dikunci terlebih dahulu dan "digantung" menunggu nomornya (diberikan = f).  Tetapi dari mana dan mengapa kunci versi baris (locktype = tuple) berasal? <br><br><blockquote>  Jangan bingung kunci versi baris (kunci tuple) dan kunci baris (kunci baris).  Yang pertama adalah kunci tipe tuple biasa, yang terlihat di pg_locks.  Yang kedua adalah tanda di halaman data: xmax dan bit informasi. <br></blockquote><br>  Ketika suatu transaksi hendak mengubah baris, ia melakukan urutan tindakan berikut: <br><br><ol><li>  Menangkap kunci eksklusif pada versi string yang dapat diubah (tuple). </li><li>  Jika xmax dan bit informasi menunjukkan bahwa saluran terkunci, maka ia meminta untuk mengunci nomor transaksi xmax. </li><li>  Menentukan bit xmax dan informasi yang diperlukan. </li><li>  Merilis kunci versi baris. </li></ol><br>  Ketika baris diperbarui oleh transaksi pertama, baris itu juga meraih kunci versi baris (langkah 1), tetapi segera melepaskannya (langkah 4). <br><br>  Ketika transaksi kedua tiba, dia menangkap kunci versi baris (item 1), tetapi terpaksa meminta kunci pada nomor transaksi pertama (item 2) dan menggantungnya. <br><br>  Apa yang terjadi jika transaksi serupa yang ketiga muncul?  Dia akan mencoba menangkap kunci versi baris (item 1) dan akan menggantung pada langkah ini.  Lihat itu. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| txid_current | pg_backend_pid || --------------+---------------- || 530499 | 5964 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5964</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 5964 | relation | accounts | RowExclusiveLock | t 5964 | tuple | accounts:1 | ExclusiveLock | f 5964 | transactionid | 530499 | ExclusiveLock | t (3 rows)</code> </pre><br>  Transaksi keempat, kelima, dll. Yang ingin memperbarui baris yang sama tidak akan berbeda dari transaksi 3 - semuanya akan "hang" pada kunci versi baris yang sama. <br><br>  Tambahkan transaksi lain ke heap. <br><br><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; ||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">||| txid_current | pg_backend_pid ||| --------------+---------------- ||| 530500 | 6000 ||| (1 row)</code> </pre><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">6000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 6000 | relation | accounts | RowExclusiveLock | t 6000 | transactionid | 530500 | ExclusiveLock | t 6000 | tuple | accounts:1 | ExclusiveLock | f (3 rows)</code> </pre><br>  Gambaran umum dari harapan saat ini dapat dilihat pada tampilan pg_stat_activity, menambahkan informasi tentang proses pemblokiran: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, wait_event_type, wait_event, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | wait_event_type | wait_event | pg_blocking_pids ------+-----------------+---------------+------------------ 5892 | | | {} 5928 | Lock | transactionid | {5892} 5964 | Lock | tuple | {5928} 6000 | Lock | tuple | {5928,5964} (4 rows)</code> </pre><br>  Ternyata semacam "antrian", di mana ada yang pertama (orang yang memegang versi kunci dari string) dan semua yang lain berbaris di belakang yang pertama. <br><br>  Mengapa kita membutuhkan desain yang begitu canggih?  Misalkan kita tidak akan memiliki kunci versi untuk string.  Kemudian transaksi kedua dan ketiga (dan seterusnya) akan menunggu pemblokiran jumlah transaksi pertama.  Pada saat penyelesaian transaksi pertama, sumber daya yang diblokir menghilang ( <em>dan apa yang Anda lakukan di sini, eh? Transaksi telah berakhir</em> ) dan sekarang semuanya tergantung pada proses menunggu mana yang pertama kali dibangunkan oleh sistem operasi dan, karenanya, akan memiliki waktu untuk mengunci saluran.  Semua proses lain juga akan dibangunkan, tetapi mereka harus mengantri lagi - sekarang setelah proses lain. <br><br>  Ini penuh dengan fakta bahwa beberapa transaksi dapat menunggu tanpa batas untuk gilirannya jika, karena kombinasi keadaan yang tidak menguntungkan, ia akan selalu berkeliling transaksi lainnya.  Dalam bahasa Inggris, situasi ini disebut kelaparan kunci. <br><br>  Dalam kasus kami, ternyata hampir sama, tetapi masih sedikit lebih baik: transaksi yang datang di kedua dijamin bahwa itu akan mendapatkan akses ke sumber daya berikutnya.  Tetapi apa yang terjadi pada yang berikut (ketiga dan seterusnya)? <br><br>  Jika transaksi pertama berakhir dengan rollback, semuanya akan baik-baik saja: transaksi masuk akan berjalan sesuai urutan. <br><br>  Tapi - ini nasib buruk - jika transaksi pertama selesai dengan komit, maka tidak hanya nomor transaksi menghilang, tetapi juga versi garis!  Artinya, versi itu, tentu saja, tetap ada, tetapi tidak lagi relevan, dan perlu memperbarui versi terbaru yang sama sekali berbeda (dari baris yang sama).  Sumber daya, yang pada gilirannya, menghilang, dan semua orang mengatur perlombaan untuk memiliki sumber daya baru. <br><br>  Biarkan transaksi pertama selesai dengan komit. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Transaksi kedua akan dibangunkan dan menjalankan paragraf.  3 dan 4. <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | transactionid | 530498 | ExclusiveLock | t (2 rows)</code> </pre><br>  Bagaimana dengan transaksi ketiga?  Dia melewatkan langkah 1 (karena sumber daya telah hilang) dan terjebak pada langkah 2: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5964</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5964 | relation | accounts | RowExclusiveLock | t 5964 | transactionid | 530498 | ShareLock | f 5964 | transactionid | 530499 | ExclusiveLock | t (3 rows)</code> </pre><br>  Dan hal yang sama terjadi pada transaksi keempat: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">6000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 6000 | relation | accounts | RowExclusiveLock | t 6000 | transactionid | 530498 | ShareLock | f 6000 | transactionid | 530500 | ExclusiveLock | t (3 rows)</code> </pre><br>  Artinya, transaksi ketiga dan keempat sedang menunggu penyelesaian transaksi kedua.  Garis berubah menjadi kerumunan <strike>labu</strike> . <br><br>  Kami menyelesaikan semua transaksi yang dimulai. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">|| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">||| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><blockquote>  Rincian lebih lanjut tentang memblokir string dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">README.tuplock</a> . <br></blockquote><br><h1>  Anda tidak berdiri di sini </h1><br>  Jadi, ide skema pemblokiran dua tingkat adalah untuk mengurangi kemungkinan penantian abadi untuk transaksi "nasib buruk".  Namun demikian, seperti yang telah kita lihat, situasi seperti itu sangat mungkin terjadi.  Dan jika aplikasi menggunakan kunci bersama, semuanya bisa menjadi lebih sedih. <br><br>  Biarkan transaksi pertama mengunci baris dalam mode bersama. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> txid_current | pg_backend_pid --------------+---------------- 530501 | 5892 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><pre> <code class="plaintext hljs"> acc_no | amount --------+-------- 1 | 100.00 (1 row)</code> </pre><br>  Transaksi kedua mencoba memperbarui baris yang sama, tetapi tidak bisa - mode SHARE dan NO KEY UPDATE tidak kompatibel. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| txid_current | pg_backend_pid | --------------+---------------- | 530502 | 5928 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Transaksi kedua menunggu penyelesaian yang pertama dan memegang kunci versi baris - untuk saat ini, semuanya seperti yang terakhir kali. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+-------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | tuple | accounts:10 | ExclusiveLock | t 5928 | transactionid | 530501 | ShareLock | f 5928 | transactionid | 530502 | ExclusiveLock | t (4 rows)</code> </pre><br>  Dan kemudian transaksi ketiga muncul yang menginginkan kunci bersama.  Masalahnya adalah ia tidak mencoba menangkap kunci pada versi baris (karena tidak akan mengubah baris), tetapi hanya merangkak keluar dari belokan - itu kompatibel dengan transaksi pertama. <br><br><pre> <code class="pgsql hljs">|| <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| txid_current | pg_backend_pid || --------------+---------------- || 530503 | 5964 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><pre> <code class="plaintext hljs">|| acc_no | amount || --------+-------- || 1 | 100.00 || (1 row)</code> </pre><br>  Dan sekarang dua transaksi memblokir baris: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]--------------- locked_row | (0,10) locker | 62 multi | t xids | {530501,530503} modes | {Share,Share} pids | {5892,5964}</code> </pre><br>  Apa yang terjadi sekarang ketika transaksi pertama selesai?  Transaksi kedua akan dibangunkan, tetapi akan melihat bahwa kunci baris tidak menghilang di mana pun, dan akan kembali berdiri di "antrian" - kali ini untuk transaksi ketiga: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+-------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | tuple | accounts:10 | ExclusiveLock | t 5928 | transactionid | 530503 | ShareLock | f 5928 | transactionid | 530502 | ExclusiveLock | t (4 rows)</code> </pre><br>  Dan hanya ketika transaksi ketiga selesai (dan jika tidak ada kunci bersama lainnya muncul selama waktu ini), yang kedua akan dapat melakukan pembaruan. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Mungkin sudah waktunya untuk menarik beberapa kesimpulan praktis. <br><br><ul><li>  Memperbarui baris yang sama dalam sebuah tabel pada saat yang sama dalam banyak proses paralel bukanlah ide yang baik. </li><li>  Jika Anda menggunakan kunci bersama tipe SHARE dalam aplikasi, maka diam-diam. </li><li>  Memeriksa kunci asing tidak boleh mengganggu, karena bidang kunci biasanya tidak berubah, dan mode KEY SHARE dan NO KEY UPDATE kompatibel. </li></ul><br><br><h1>  Diminta untuk tidak meminjam </h1><br>  Biasanya, perintah SQL berharap untuk mengeluarkan sumber daya yang mereka butuhkan.  Tetapi terkadang Anda ingin menolak untuk mengeksekusi perintah jika kunci tidak dapat diperoleh dengan segera.  Untuk melakukan ini, perintah seperti SELECT, LOCK, ALTER, memungkinkan Anda untuk menggunakan frase NOWAIT. <br><br>  Sebagai contoh: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOWAIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| ERROR: could not obtain lock on row in relation "accounts"</code> </pre><br>  Perintah segera gagal jika sumber daya sibuk.  Dalam kode aplikasi, kesalahan seperti itu dapat dicegat dan diproses. <br><br>  Anda tidak dapat menentukan frasa NOWAIT untuk perintah UPDATE dan DELETE, tetapi Anda dapat terlebih dahulu menjalankan SELECT FOR UPDATE NOWAIT, dan kemudian, jika mungkin, perbarui atau hapus baris. <br><br>  Ada pilihan lain untuk tidak menunggu - gunakan perintah SELECT FOR dengan frasa SKIP LOCKED.  Perintah seperti itu akan melewati garis yang terkunci, tetapi memproses yang gratis. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> acc_no <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SKIP LOCKED</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs">| acc_no | amount | --------+-------- | 2 | 200.00 | (1 row)</code> </pre><br>  Dalam contoh ini, baris pertama - yang diblokir dilewati dan kami segera menerima (dan memblokir) yang kedua. <br><br>  Dalam praktiknya, ini memungkinkan Anda untuk mengatur pemrosesan antrian multi-threaded.  Anda seharusnya tidak membuat aplikasi lain untuk perintah ini - jika Anda ingin menggunakannya, kemungkinan besar Anda akan kehilangan beberapa solusi yang lebih sederhana. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><pre> <code class="plaintext hljs">| =&gt; ROLLBACK;</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Untuk dilanjutkan</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463819/">https://habr.com/ru/post/id463819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463805/index.html">Tujuh buku untuk mereka yang ingin menjadi desainer game</a></li>
<li><a href="../id463811/index.html">Mempersiapkan aplikasi untuk Android Q. Bagian 1</a></li>
<li><a href="../id463813/index.html">Multivan dan perutean pada Mikrotik RouterOS</a></li>
<li><a href="../id463815/index.html">Mengapa bank asing tertarik dengan sumber dana Anda?</a></li>
<li><a href="../id463817/index.html">20 manajer produk dan struktur matriks paling multi-dimensi dari semua. Percakapan dengan Skyeng</a></li>
<li><a href="../id463821/index.html">AMO, Bitrix, 1C, dan lainnya: bagaimana memilih di mana untuk memulai?</a></li>
<li><a href="../id463823/index.html">Rilis Rust 1.37.0: Optimalisasi Terpandu Profil, konstanta tanpa nama dan vendor kargo</a></li>
<li><a href="../id463825/index.html">Alat Manajemen Proyek Google Sheets</a></li>
<li><a href="../id463829/index.html">FreePBX Mengkonfigurasi Asterisk untuk pemberitahuan e-mail tentang panggilan masuk yang terlewat dalam antrian</a></li>
<li><a href="../id463831/index.html">Apa yang salah dengan pendidikan IT di Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>