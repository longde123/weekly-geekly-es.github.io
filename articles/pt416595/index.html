<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍼 👩🏼‍🎤 🚣🏻 Dagaz: Horde 👎🏾 🚢 🎌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Você é milhões. Nós - trevas e trevas e trevas. 
 Experimente, lute conosco! 
 Sim, citas - nós somos! Sim, asiáticos - nós ... 

 Alexander Block " C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dagaz: Horde</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416595/"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="imagem">  <b><i>Você é milhões.</i></b>  <b><i>Nós - trevas e trevas e trevas.</i></b> <b><i><br></i></b>  <b><i>Experimente, lute conosco!</i></b> <b><i><br></i></b>  <b><i>Sim, citas - nós somos!</i></b>  <b><i>Sim, asiáticos - nós ...</i></b> <b><i><br><br></i></b>  <b><i>Alexander Block " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Citas</a> "</i></b> <br><br>  Em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> anterior <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">,</a> falei muito sobre minhas descobertas no campo do design e da interface do usuário dos jogos de tabuleiro, mas tive que interromper essa história, você pode dizer no meio, em parte por causa do grande volume do artigo, em parte simplesmente porque naquele momento eu não estava pronto para continuar. próximo.  Desde então, muita coisa mudou.  Novos problemas interessantes foram resolvidos e os jogos que os geraram (não menos interessantes) foram adicionados ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lançamento</a> .  Eu quero falar sobre isso hoje. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/nWSawKsdTlQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Se alguém se lembra, era sobre o jogo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Abalon</a> ", desenvolvido por Michel Lale e Laurent Levy em 1988.  Sua essência é empurrar as bolas do inimigo para fora do campo.  Duas bolas podem empurrar uma e três bolas - um par de bolas de uma cor diferente.  O jogador pode mover suas bolas no tabuleiro, uma de cada vez, ou em grupos, duas ou três bolas cada (além disso, três bolas devem formar uma “linha”).  O que me impediu de fazer este jogo da última vez? <br><br>  Obviamente não é o próprio movimento do grupo.  O movimento simultâneo de várias peças, dentro de um movimento, é uniforme no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">xadrez</a> .  E os " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quebra-cabeças deslizantes</a> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">são</a> construídos simplesmente para garantir que esse movimento ocorra de maneira síncrona e suave.  Vejamos um jogo desenvolvido por Robert Abbott em 1975: <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/kv/fp/d-/kvfpd-kf--0kt2sproxmbidswpi.png"></a> </div><br>  Parece um Abalon.  A única diferença é que a "linha" não "empurra" a peça do oponente de seu lugar, mas simplesmente a remove do tabuleiro usando uma captura de "xadrez".  A vitória é concedida a um dos jogadores que conseguiu desenhar mais na última linha do tabuleiro de suas peças do que seu oponente conseguiu no mesmo momento.  Todo o jogo é construído sobre o movimento de "linhas".  É improvável que consiga ganhar apenas peças solitárias.  É assim que uma simples jogada de empurrão se parece. <br><br><div class="spoiler">  <b class="spoiler_title">Zrf</b> <div class="spoiler_text"><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> push-1 ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> friend?) (<span class="hljs-name"><span class="hljs-name">while</span></span> friend? cascade $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-friend?) add ))</code> </pre> </div></div><br>  Trata-se da <b>cascata de</b> palavras mágicas - força o intérprete a "liberar" a figura movida para o campo atual, retirando daí "na mão" outra figura (não é importante para o seu ou o oponente) e continuar em movimento, já com a nova figura "na mão".  Em uma jogada, essa operação pode ser executada repetidamente, movendo assim um número ilimitado de peças por vez.  Tais casos (e um pouco mais complexos) também são encontrados em outros jogos - " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guns</a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dameo</a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Leutwayite Game</a> ", ... <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/ts/cz/0-/tscz0-t_xblqjzzxeolgpa-7cjm.gif"></a> </div><br>  Do ponto de vista da interface do usuário, movimentos "push" também são implementados de maneira bastante trivial.  O rótulo conhecido do campo de destino (círculo verde) aparece na figura.  Se (de acordo com as regras do jogo) pudermos comer essa peça - comemos (captura de xadrez), caso contrário - empurramos.  Você pode avançar uma linha e mais de um campo (como no jogo Epaminondas).  Obviamente, codificar essa mudança será um pouco mais complicado: <br><br><div class="spoiler">  <b class="spoiler_title">Zrf</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> push-2 ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> friend?) (<span class="hljs-name"><span class="hljs-name">while</span></span> friend? mark $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-enemy?) to back cascade $<span class="hljs-number"><span class="hljs-number">1</span></span> ) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-friend?) add ))</code> </pre></div></div><br>  A palavra-chave to (e seu par <b>de</b> ) atua em conjunto com a <b>cascata</b> .  Isso significa que a figura “fora de mão” deve ser colocada no tabuleiro agora, e a nova figura “pega na mão” um pouco mais tarde, depois de navegar para outro campo.  Em geral, “empurrar” os movimentos é simples, mas há outro tipo de movimento de grupo no Abalon: <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/ta/hn/js/tahnjsqbpx_m2hmguohqdiannb4.gif"></a> </div><br>  Eu os chamo de movimentos "transversais".  Do ponto de vista da codificação ZRF, não há nada complicado nelas.  O problema está na interface do usuário.  Como "dizer" ao programa que o jogador deseja mover não uma bola, mas um grupo, se ambos os movimentos são permitidos pelas regras?  Eu uso o mesmo "piscar", que foi tão útil para mim em damas, para marcar a figura "atual".  Somente agora existem várias figuras "atuais" no conjunto. <br><br>  Um clique em uma figura "livre" o adiciona ao grupo se houver uma mudança na qual todas as figuras adicionadas ao grupo estejam envolvidas (é ainda mais fácil não soltar o botão, destacando o grupo inteiro com um clique do mouse).  Se não houver tais movimentos, apenas um novo grupo será criado, até agora constituído por uma peça.  Círculos verdes sempre são mostrados para a última figura adicionada (isso pode não ser muito óbvio, mas você pode se acostumar).  O clique repetido em qualquer figura "ofuscante" redefine imediatamente todo o grupo. <br><br><div class="spoiler">  <b class="spoiler_title">By the way</b> <div class="spoiler_text">  Os círculos verdes não aparecerão necessariamente simplesmente na presença de figuras "ofuscantes".  Em alguns casos, é possível uma situação em que todas as peças selecionadas sejam incluídas em algum movimento válido, mas não há movimento válido, limitado a mover apenas essas formas selecionadas.  Parece um pouco confuso, mas aqui está uma ilustração: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d_/3h/me/d_3hmeibopemfxnzcfpmwmvztty.gif"></div><br>  Neste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jogo,</a> apenas movimentos simultâneos de grupos de três peças são permitidos (se houver menos peças, todos devem se mover).  Todas as figuras selecionadas se movem um passo e na mesma direção.  Captura de xadrez, suas peças interferem no movimento.  Para ganhar, você deve segurar pelo menos uma de suas peças na última linha, no campo do inimigo. <br><br>  O jogo em si, na minha opinião, não é muito interessante, mas, do ponto de vista da codificação, isso é loucura real.  Qualquer tentativa de "honestamente" gerar todos os movimentos possíveis de grupos de três figuras leva a uma explosão combinatória.  Você precisa enganar (o benefício do Dagaz permite isso).  Para começar, geramos todos os movimentos válidos de peças únicas.  É simples: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> step ( $<span class="hljs-number"><span class="hljs-number">1</span></span> add ))</code> </pre><br>  Até que você possa verificar a possível luta de sua própria figura, tudo isso mais tarde!  Apenas seguimos em todas as direções, sempre que possível.  Em seguida, ative a " <a href="">mágica</a> ".  Simplesmente combinamos todas as combinações possíveis de três movimentos de várias peças em uma direção, criando um produto cartesiano.  Depois disso, <a href="">descartamos</a> movimentos que se deparam com nossas próprias peças. <br><br>  Por que não largá-los imediatamente?  Por uma razão muito simples - uma peça tem o direito de mover-se para um campo ocupado se for liberada como parte do mesmo movimento do grupo e, no momento de gerar os movimentos "elementares", não há informações sobre a composição dos grupos movidos!  É por isso que amo tanto esse projeto.  De vez em quando, ele joga esses quebra-cabeças interessantes aqui! <br></div></div><br>  A mudança não precisa ocorrer em apenas um campo, como no Abalone.  No jogo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ordo</a> (e especialmente no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ordo X</a> ), inventado por Dieter Stein em 2009, grupos de figuras podem se mover muito mais longe.  A única condição é que as peças de sua cor, no final do turno, não sejam separadas (esta é a mesma invariante do jogo que a necessidade do rei deixar a ameaça no xadrez).  O jogador que vencer a primeira linha do tabuleiro vence. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/e9/es/o2/e9eso2wtosdaokcmbftoppjdwqq.gif"></a> </div><br>  Neste jogo, existem movimentos longitudinais e transversais das “linhas” de peças de qualquer tamanho e a qualquer distância (dentro do tabuleiro, é claro).  Existem tantos modelos usados ​​para gerar movimentos que leva mais de 5 minutos para processar um <a href="">arquivo ZRF</a> desenvolvido por mim com um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conversor</a> (a maioria dos jogos é processada em segundos)!  Pode-se supor que isso levaria a problemas na fase de geração dos movimentos, mas não é assim.  A grande maioria dos movimentos é cortada pela <a href="">invariante do</a> jogo. <br><br><div class="spoiler">  <b class="spoiler_title">Mais uma tarefa de quebra-cabeça cerebral apareceu aqui</b> <div class="spoiler_text">  O fato é que o mecanismo de seleção alternada de figuras que desenvolvi para executar um movimento de grupo, de um modo geral, é incompatível com a interface de movimentos de “empurrar”, implementada por versões antigas do controlador.  É simples: para fazer um movimento de "empurrar", você precisa selecionar uma figura com capacidade de ir para o campo, até agora ocupada por outra figura do grupo movido.  Mas não podemos exibir seu campo de destino, já que a formação do grupo não está completa, e a mudança de uma única figura para o campo ocupado é provavelmente proibida pelas regras do jogo. <br><br>  Em geral, se tudo for feito "de acordo com as regras", é necessário clicar em todas as figuras do grupo movido uma por uma e somente depois disso a interface exibirá os campos de destino para a última figura adicionada.  Mesmo em Abalon, com seus grupos de no máximo três figuras, isso é um pouco cansativo, mas em Ordo é geralmente impensável!  Eu tive que inventar um método especial que “expande” automaticamente o grupo quando ele detecta os conflitos descritos acima. <br><br><div class="spoiler">  <b class="spoiler_title">Aqui está o que parece para Abalone</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Dagaz.Model.closure = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">board, move, group</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = []; _.each(group, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ r.push(pos); }); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; r.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = r[i]; _.each(move.actions, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((a[<span class="hljs-number"><span class="hljs-number">0</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (a[<span class="hljs-number"><span class="hljs-number">1</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (a[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] == pos)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = a[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (piece.player == board.player) &amp;&amp; (_.indexOf(r, p) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { r.push(p); } } }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre></div></div><br>  Mas movimentos longos de "empurrar" são permitidos no Ordo e esse algoritmo não funciona!  Não importa - todas as funções definidas no Dagaz.Model podem ser redefinidas. <br><br><div class="spoiler">  <b class="spoiler_title">Desta forma</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Dagaz.Model.closure = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">board, move, group</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> design = board.game.design; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = []; _.each(group, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ r.push(pos); }); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; r.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = r[i]; _.each(move.actions, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((a[<span class="hljs-number"><span class="hljs-number">0</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (a[<span class="hljs-number"><span class="hljs-number">1</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (a[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] == pos)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = a[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = Dagaz.Model.getX(pos); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = Dagaz.Model.getY(pos); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dx = sign(Dagaz.Model.getX(target) - x); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dy = sign(Dagaz.Model.getY(target) - y); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dir = design.findDirection(pos, pos + (dy * Dagaz.Model.WIDTH) + dx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dir !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((pos !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (pos != target)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((piece === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || (piece.player != board.player)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.indexOf(r, pos) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { r.push(pos); } pos = design.navigate(board.player, pos, dir); } } } }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre></div></div><br>  Essa sobrecarga é mais fácil para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Takoka</a> .  Como não há movimentos de empurrar (é sempre necessário destacar claramente todas as peças incluídas no grupo), basta bloquear essa funcionalidade, ou seja, simplesmente não expandir o grupo: <br><br><pre> <code class="javascript hljs">Dagaz.Model.closure = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">board, move, group</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> group; }</code> </pre><br>  Peço desculpas pelo nome da função que não diz nada a ninguém.  Eu simplesmente não conseguia criar um nome melhor para a ação. <br></div></div><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/w0/ao/0l/w0ao0ly48ozfetiaojn5ilq9wum.png"></a> </div><br>  Este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jogo</a> também implementa o movimento do grupo, mas sua mecânica é completamente diferente!  Aqui as figuras se movem em grupos 3x3. Além disso, os campos vazios do grupo também fazem parte do “padrão” movido.  A presença de figuras em um dos oito campos externos mostra as direções nas quais você pode se mover, e o preenchimento do campo central determina se você pode mover o "padrão" para uma distância arbitrária ou apenas a uma curta distância, não mais que 3 etapas.  Para vencer, é necessário destruir o "anel" do inimigo - um análogo da figura real (este é um campo vazio, cercado de oito lados por todos os lados).  Você tem que ter muito cuidado para não destruir seu anel também. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O GESS</a> acabou sendo um pesadelo real, tanto em termos de " <a href="">mágica</a> " quanto em termos do próprio <a href="">protótipo</a> - o esqueleto do jogo.  Basta dizer que o quadro (20x20, levando em consideração vários campos fora do quadro) consiste em duas camadas.  Toda a camada superior é completamente preenchida com formas invisíveis que controlam o movimento.  O movimento das pedras que compõem os “padrões” dos jogadores são apenas efeitos colaterais desses movimentos.  Infelizmente, ainda não consegui desenvolver um bot para este jogo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/hBuolYNV1Oo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  No final do artigo, quero apresentar uma outra coisa que não está diretamente relacionada ao tópico do movimento de figuras em grupo.  Foi-me pedido que este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jogo</a> fosse um dos assinantes da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">página do</a> meu projeto - Sultan Ratrout.  Em geral, esses são <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">verificadores</a> comuns de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pilar</a> em uma placa hexagonal.  Mesmo sem as damas.  O conceito de revolução é diferente!  O próprio campo de jogo é transformável!  Aproveite. <br><br>  <b><i>Vou de férias ...</i></b> <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416595/">https://habr.com/ru/post/pt416595/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416585/index.html">Extensão da Web entre navegadores para scripts personalizados Parte 3</a></li>
<li><a href="../pt416587/index.html">Algumas palavras sobre os subwoofers e por que eles são adequados para quase todos</a></li>
<li><a href="../pt416589/index.html">Células mortas: usando o pipeline 3D para animação 2D</a></li>
<li><a href="../pt416591/index.html">"Apertando as porcas": por que todos começaram a falar sobre a regulamentação mais rígida do setor de TI</a></li>
<li><a href="../pt416593/index.html">Minha participação no desenvolvimento do Uncharted 4</a></li>
<li><a href="../pt416597/index.html">IBM Watson Build - experimente o concurso de desenvolvedores</a></li>
<li><a href="../pt416599/index.html">O que é eCPM e como aumentá-lo?</a></li>
<li><a href="../pt416601/index.html">Vertex Impress Play review: corpo esbelto + bateria de 5000 mAh + boas câmeras de 16 megapixels</a></li>
<li><a href="../pt416605/index.html">@Pythonetc junho de 2018</a></li>
<li><a href="../pt416607/index.html">Post-mortem emparelhado: como derrotar Cthulhu e outras 2.000 pessoas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>