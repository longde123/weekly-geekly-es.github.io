<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜🏾 ⛎ 😉 Optimalisasi Kinerja untuk Aplikasi .NET (C #) 🏢 ⏏️ 😶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada banyak artikel dengan tajuk yang serupa, jadi saya akan mencoba menghindari topik yang biasa. Saya harap bahkan pengembang yang sangat berpengalam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimalisasi Kinerja untuk Aplikasi .NET (C #)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466931/"><img src="https://habrastorage.org/webt/gs/yu/jc/gsyujcvzccxootdcxkywpaida0k.jpeg" alt="gambar"><br><br>  Ada banyak artikel dengan tajuk yang serupa, jadi saya akan mencoba menghindari topik yang biasa.  Saya harap bahkan pengembang yang sangat berpengalaman pun akan menemukan sesuatu yang bermanfaat di sini.  Artikel ini hanya akan mempertimbangkan mekanisme dan pendekatan optimasi sederhana yang akan memungkinkan mereka untuk diterapkan dengan upaya minimal.  Dan perubahan ini tidak akan meningkatkan entropi kode Anda.  Artikel tidak akan memperhatikan apa dan kapan untuk mengoptimalkan, artikel ini lebih tentang pendekatan penulisan kode secara umum. <br><a name="habracut"></a><br><h4>  1. ToArray vs ToList </h4><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItems</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _storage.Items.Where(...).ToList(); }</code> </pre> <br>  Setuju, kode yang sangat khas untuk proyek industri.  Tapi apa yang salah dengannya?  Antarmuka IEnumerable mengembalikan koleksi yang dapat Anda “datangi”, antarmuka ini tidak menyiratkan bahwa kita dapat menambah / menghapus elemen.  Oleh karena itu, tidak perlu mengakhiri ekspresi LINQ dengan casting ke Daftar (Daftar).  Dalam hal ini, casting ke Array (ToArray) lebih disukai.  Karena List adalah pembungkus di atas Array, dan semua fitur tambahan yang disediakan oleh pembungkus ini, kami memotong antarmuka.  Array mengkonsumsi lebih sedikit memori, dan akses ke nilainya lebih cepat.  Karena itu, mengapa membayar lebih.  Di satu sisi, optimasi ini tidak signifikan, karena mereka mengatakan "optimasi pada kecocokan", tetapi ini tidak sepenuhnya benar.  Faktanya adalah bahwa dalam aplikasi khas di mana layanan mengembalikan model untuk lapisan presentasi, mungkin ada segudang panggilan ToList tersebut.  Dalam contoh yang dijelaskan di atas, antarmuka IEnumerable diperkenalkan hanya untuk tujuan ilustrasi.  Pendekatan ini relevan untuk semua kasus ketika Anda harus mengembalikan koleksi yang tidak akan Anda ubah nanti. <br><br>  Saya memperkirakan komentar bahwa Array dan Daftar tidak akan berfungsi secara setara dalam hal akses multi-utas ke koleksi.  Memang benar.  Tetapi jika Anda, sebagai pengembang, sedang mempertimbangkan kemungkinan akses multi-threaded ke koleksi tersebut dengan kemungkinan mengubahnya, maka dengan tingkat probabilitas yang tinggi, Array atau List tidak akan cocok untuk Anda. <br><br><h4>  2. Parameter “jalur file” tidak selalu merupakan pilihan terbaik untuk metode Anda </h4><br>  Saat mengembangkan API, hindari tanda tangan metode yang menerima jalur file sebagai input (untuk diproses nanti oleh metode Anda).  Alih-alih, berikan kemampuan untuk melewatkan array byte ke input, atau <b>sebagai</b> Stream <b>upaya terakhir</b> .  Faktanya adalah bahwa seiring waktu, metode Anda dapat diterapkan tidak hanya untuk file dari disk, tetapi juga ke file yang ditransfer melalui jaringan, ke file dari arsip, ke file dari database, ke file yang isinya dihasilkan secara dinamis dalam memori, dll. e. Dengan memberikan metode dengan parameter input "jalur file", Anda mewajibkan pengguna API Anda untuk menyimpan data ke disk sebelum membacanya lagi.  Operasi yang tidak berarti ini sangat memengaruhi kinerja.  Drive adalah hal yang sangat lambat.  Untuk kenyamanan, Anda dapat memberikan metode dengan parameter input "path ke file", tetapi di dalamnya selalu menggunakan metode overload publik dengan array byte atau streaming pada input.  Ada "penanda" yang dapat membantu menemukan operasi penulisan / baca disk tambahan, coba temukan di proyek Anda menggunakan metode standar: <code>Path.GetTempPath()</code> dan <code>Path.GetRandomFileName()</code> (dari System.IO).  Dengan tingkat probabilitas yang tinggi, Anda akan menemukan solusi untuk masalah di atas atau yang serupa. <br><br>  Pembaca yang penuh perhatian dan berpengalaman akan memperhatikan bahwa dalam beberapa kasus, menulis ke disk dapat, sebaliknya, meningkatkan kinerja, misalnya, jika kita berurusan dengan file yang sangat besar.  Ini benar, harus diperhitungkan, tetapi saya berasumsi bahwa ini adalah situasi yang sangat langka dengan implementasi yang spesifik. <br><br><h4>  3. Hindari menggunakan utas sebagai parameter dan hasil pengembalian metode Anda </h4><br>  Apa masalahnya di sini ... ketika kita mendapatkan aliran dari "kotak hitam", kita harus mengingat kondisinya.  Yaitu  Apakah alirannya terbuka?  Di mana penanda baca / tulis?  Bisakah kondisinya berubah terlepas dari kode kita?  Jika streaming dinyatakan sebagai kelas dasar Stream, kami bahkan tidak memiliki informasi tentang operasi apa yang tersedia.  Semua ini diselesaikan dengan pemeriksaan tambahan, dan ini adalah kode dan biaya tambahan.  Juga, saya berulang kali menemukan situasi di mana, ketika menerima Stream dari beberapa metode "tidak jelas", pengembang lebih suka memainkannya dengan aman dan "mentransfer" data darinya ke MemoryStream lokal baru yang sepenuhnya terkontrol.  Meskipun, aliran sumber bisa sangat aman.  Mungkin bahkan ini sudah disiapkan untuk membaca MemoryStream.  Kadang-kadang dapat mencapai titik absurditas - di dalam suatu metode, array byte dimasukkan ke dalam MemoryStream, maka MemoryStream ini dikembalikan sebagai hasil dari metode yang dinyatakan sebagai aliran dasar.  Di luar, Stream ini berubah menjadi MemoryStream baru, dan kemudian ToArray () mengembalikan array byte, yang awalnya kami miliki.  Lebih tepatnya, itu akan menjadi salinan selanjutnya.  Ironinya adalah bahwa di dalam dan di luar metode kami, kode tersebut sepenuhnya benar.  Menurut pendapat saya, contoh ini tidak keluar dari kepala saya, tetapi ditemukan di suatu tempat dalam kode komersial. <br><br>  Akibatnya, jika Anda memiliki kemampuan untuk mengirim / menerima data "bersih", jangan gunakan stream untuk ini - jangan membuat jebakan bagi mereka yang akan menggunakannya.  Jika aplikasi Anda sudah memiliki aliran transfer / balik, analisis penggunaannya berdasarkan hal tersebut di atas. <br><br><h4>  4. Warisan enum </h4><br>  Optimalisasi ini biasa, semua orang tahu itu, bahkan siswa.  Tapi dari pengalaman saya, ini sangat jarang digunakan.  Jadi, secara default, enum mewarisi dari int.  Namun, ini dapat diwarisi dari byte, yang memiliki 256 nilai (atau 8 nilai "flaggable").  Yang hampir selalu mencakup fungsionalitas "menengah" enum.  Perubahan minimal dalam kode dan semua nilai enum Anda menghabiskan lebih sedikit memori selamanya.  Di bawah ini adalah ilustrasi tolok ukur untuk mengisi koleksi dengan nilai enum yang diwarisi dari int dan byte. <br><br><img src="https://habrastorage.org/webt/e-/ir/q2/e-irq2g_r9iorxjbadfqyxuc9ei.png"><br><br><div class="spoiler">  <b class="spoiler_title">Kode benchmark</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CollectEnums</span></span> { [Params(<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">100000</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N; [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> EnumFromInt[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnumOfInt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EnumFromInt[] results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnumFromInt[N]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) { results[i] = EnumFromInt.Value1; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> results; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> EnumFromByte[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnumOfByte</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EnumFromByte[] results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnumFromByte[N]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) { results[i] = EnumFromByte.Value1; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> results; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EnumFromInt { Value1, Value2 } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EnumFromByte: <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> { Value1, Value2 }</code> </pre> <br></div></div><br><h4>  5. Beberapa kata lagi tentang kelas Array dan Daftar </h4><br>  Mengikuti logika, iterasi pada array selalu lebih efisien daripada iterasi pada "sheet", karena "sheet" adalah pembungkus atas array.  Juga, mengikuti logika, "untuk" selalu lebih cepat dari "foreach", karena "foreach" melakukan banyak tindakan yang diperlukan oleh implementasi antarmuka IEnumerable.  Semuanya logis di sini, tapi salah!  Mari kita lihat hasil benchmark: <br><br><img src="https://habrastorage.org/webt/p7/7z/ih/p77zihj1drhzs84wcik9vtyq4qg.png"><br><br><div class="spoiler">  <b class="spoiler_title">Kode benchmark</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IterationBenchmark</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _list; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] _array; [Params(<span class="hljs-number"><span class="hljs-number">100000</span></span>, <span class="hljs-number"><span class="hljs-number">10000000</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N; [GlobalSetup] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MIN = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MAX = <span class="hljs-number"><span class="hljs-number">10</span></span>; Random rnd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); _list = Enumerable.Repeat(<span class="hljs-number"><span class="hljs-number">0</span></span>, N).Select(i =&gt; rnd.Next(MIN, MAX)).ToList(); _array = _list.ToArray(); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _list.Count; i++) { total += _list[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForeachList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _list) { total += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForeachArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _array) { total += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _array.Length; i++) { total += _array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } }</code> </pre> <br></div></div><br>  Faktanya adalah bahwa untuk mengulangi lebih dari satu array, "foreach" tidak menggunakan implementasi IEnumerable.  Dalam kasus khusus ini, iterasi paling optimal berdasarkan indeks dilakukan, tanpa memeriksa out-of-bound array, karena konstruk "foreach" tidak beroperasi dengan indeks, sehingga pengembang tidak memiliki kesempatan untuk "mengacaukan" dalam kode.  Itulah pengecualian dari aturan.  Oleh karena itu, jika di beberapa bagian penting dari kode Anda mengganti penggunaan "foreach" dengan "for" demi optimasi, Anda menembak diri sendiri.  Harap dicatat bahwa ini <b>hanya</b> relevan <b>untuk array</b> .  Ada beberapa cabang di StackOverflow di mana fitur ini dibahas. <br><br><h4>  6. Apakah mencari melalui tabel hash selalu dibenarkan? </h4><br>  Semua orang tahu bahwa tabel hash sangat efektif untuk pencarian.  Tetapi mereka sering lupa bahwa harga untuk pencarian cepat adalah tambahan yang lambat untuk tabel hash.  Apa yang mengikuti dari ini?  Agar penggunaan tabel hash dapat dibenarkan, perlu bahwa jumlah elemen tabel hash setidaknya 8 (sekitar).  Dan agar jumlah operasi pencarian setidaknya urutan besarnya lebih besar dari jumlah operasi penambahan.  Jika tidak, gunakan koleksi yang lebih sederhana.  Kualitas fungsi hash akan membuat penyesuaian sendiri untuk efisiensi, tetapi artinya ini tidak akan berubah.  Dalam praktik saya, ada kasus ketika bottleneck dalam kode dimuat adalah memanggil metode Dictionary.Add ().  Kuncinya adalah string biasa, dengan panjang pendek.  Mengingat ini dan menjadi pemicu untuk menulis paragraf ini.  Sebagai ilustrasi, contoh kode yang sangat buruk: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numberStr</span></span></span><span class="hljs-function">)</span></span> { Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; dictionary = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; { {<span class="hljs-string"><span class="hljs-string">"One"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Two"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Three"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} }; dictionary.TryGetValue(numberStr, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Mungkin hal serupa terjadi di proyek Anda? <br><br><h4>  7. Metode penanaman </h4><br>  Kode ini dibagi menjadi beberapa metode yang paling sering karena 2 alasan.  Pastikan penggunaan kembali dan pembusukan kode ketika satu tugas dibagi menjadi beberapa subtugas.  Lebih mudah bagi seseorang.  Inlining adalah proses kebalikan dari dekomposisi, mis.  kode metode tertanam di tempat di mana metode harus dipanggil, sebagai hasilnya, kita menghemat tumpukan panggilan dan melewati parameter.  Saya sama sekali tidak merekomendasikan mendorong semuanya menjadi satu metode.  Tetapi metode-metode yang secara teoritis dapat kita “sebaris” dapat ditandai dengan atribut yang sesuai: <br><br><pre> <code class="plaintext hljs">[MethodImpl(MethodImplOptions.AggressiveInlining)]</code> </pre> <br>  Atribut ini akan memberi tahu sistem bahwa metode ini dapat disematkan.  Ini tidak berarti bahwa metode yang ditandai dengan atribut ini akan selalu built-in.  Misalnya, tidak mungkin untuk menanamkan metode rekursif atau virtual.  Penting juga dicatat bahwa mekanisme penanaman sangat “halus”.  Ada banyak alasan lain mengapa sistem akan menolak untuk menanamkan metode Anda.  Namun, tim Microsoft yang mengerjakan .NET Core secara aktif menggunakan atribut ini.  Kode sumber untuk .NET Core memiliki banyak contoh penggunaannya. <br><br><h4>  8. Kapasitas Perkiraan </h4><br>  Saya (dan saya berharap sebagian besar pengembang juga) telah mengembangkan refleks: Saya menginisialisasi koleksi - saya memikirkan apakah mungkin untuk mengatur Kapasitas untuk itu.  Namun, jumlah pasti elemen koleksi tidak selalu diketahui sebelumnya.  Tapi ini bukan alasan untuk mengabaikan parameter ini.  Misalnya, jika, berbicara tentang berapa banyak elemen yang akan ada di koleksi Anda, Anda menganggap "beberapa ribu" buram, ini adalah kesempatan untuk mengatur Kapasitas menjadi 1000. Sebuah teori kecil, misalnya, untuk Daftar secara default, Kapasitas = 16, sehingga hanya mencapai 1000, sistem akan membuat 1008 (16 + 32 + 64 + 128 + 256 + 512) elemen tambahan dan membuat 7 array sementara untuk panggilan GC berikutnya.  Yaitu  semua pekerjaan ini akan sia-sia.  Juga, sebagai Kapasitas, tidak ada yang melarang menggunakan rumus.  Jika ukuran koleksi Anda diperkirakan sepertiga dari koleksi lainnya, Anda dapat mengatur Kapasitas sama dengan Koleksi lainnya. Penghitungan / 3. Saat mengatur Kapasitas, ada baiknya memahami kisaran ukuran koleksi yang mungkin dan seberapa dekat nilainya didistribusikan.  Selalu ada kemungkinan bahaya, tetapi jika digunakan dengan benar, perkiraan Kapasitas akan memberi Anda kemenangan yang baik. <br><br><h4>  9. Selalu tentukan kode Anda. </h4><br>  Secara aktif menggunakan (sekilas pandang, opsional) kata kunci C #, seperti: statis, const, hanya baca, disegel, abstrak, dll.  Secara alami, di mana mereka masuk akal.  Dan ini kinerjanya?  Faktanya adalah bahwa semakin rinci Anda menggambarkan sistem Anda ke kompiler, semakin optimal kode yang dapat dihasilkannya.  Pembaca yang penuh perhatian dan berpengalaman mungkin memperhatikan bahwa, misalnya, kata kunci yang disegel tidak mempengaruhi kinerja.  Sekarang ini benar, tetapi dalam versi yang akan datang semuanya dapat berubah.  Beri kesempatan pada kompiler dan mesin virtual!  Dapatkan bonus, mengidentifikasi banyak kesalahan penggunaan kode Anda yang tidak tepat pada tahap kompilasi.  Aturan umum: semakin jelas sistem dijelaskan, semakin optimal hasilnya.  Rupanya, dengan orang-orang juga. <br><br><div class="spoiler">  <b class="spoiler_title">Kisah nyata menegaskan aturan ini, tetapi jika Anda membaca kemalasan, Anda dapat melewati</b> <div class="spoiler_text">  Suatu malam, saat terlibat dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">proyek hobinya</a> , ia mengatur sendiri tugas untuk meningkatkan kinerja bagian kode di atas level tertentu.  Tetapi situs ini singkat dan ada beberapa pilihan untuk apa yang harus dilakukan dengannya.  Saya menemukan dalam dokumentasi bahwa, dimulai dengan versi C # 7.2, kata kunci "readonly" dapat digunakan untuk struktur.  Dan dalam kasus saya, struktur abadi digunakan, dengan menambahkan satu kata "readonly" Saya mendapatkan apa yang saya inginkan, bahkan dengan margin!  Sistem, mengetahui bahwa struktur saya tidak dimaksudkan untuk diubah, dapat menghasilkan kode yang lebih baik untuk kasus saya. <br></div></div><br><h4>  10. Jika memungkinkan, gunakan satu versi .NET untuk semua proyek Solusi </h4><br>  Anda harus berusaha untuk memastikan bahwa semua rakitan dalam aplikasi Anda milik versi .NET yang sama.  Ini berlaku untuk kedua paket NuGet (diedit di package.config / json) dan rakitan Anda sendiri (diedit di properti Project).  Ini akan menghemat RAM dan mempercepat awal "dingin", karena dalam memori aplikasi Anda tidak akan ada salinan perpustakaan yang sama untuk versi .NET yang berbeda.  Perlu dicatat bahwa tidak dalam semua kasus, berbagai versi. NET akan menghasilkan salinan dalam memori.  Tapi anggaplah bahwa aplikasi yang dibangun di versi yang sama. NET selalu lebih baik.  Juga, ini menghilangkan sejumlah masalah potensial yang berada di luar ruang lingkup artikel ini.  Versi konsolidasi semua paket NuGet yang Anda gunakan juga akan berkontribusi untuk meningkatkan kinerja aplikasi Anda. <br><br><h4>  Beberapa alat yang bermanfaat </h4><br>  <b>ILSpy</b> adalah alat gratis yang memungkinkan Anda untuk melihat kode sumber perakitan yang dipulihkan.  Jika saya memiliki pertanyaan tentang mekanisme .NET mana yang lebih efisien, pertama-tama saya buka ILSpy (dan bukan Google atau StackOverflow), dan sudah ada di sana saya melihat bagaimana penerapannya.  Misalnya, untuk mengetahui apa yang paling baik digunakan dalam hal kinerja untuk menerima data melalui HTTP, kelas HttpWebRequest atau WebClient, lihat saja implementasinya melalui ILSpy.  Dalam kasus khusus ini, WebClient adalah pembungkus atas HttpWebRequest, masing-masing, jawabannya jelas.  Kode sumber .NET tidak layak untuk ditakuti, mereka ditulis oleh programmer biasa yang sama. <br><br>  <b>BenchmarkDotNet</b> adalah perpustakaan tolok ukur gratis.  Ada StopWatch yang sederhana dan intuitif (dari System.Diagnostics).  Tetapi terkadang itu tidak cukup.  Karena dengan cara yang baik perlu diperhitungkan bukan hasil tunggal, tetapi rata-rata dari beberapa perbandingan, lebih baik membandingkan median mereka untuk meminimalkan pengaruh OS.  Juga, Anda perlu memperhitungkan "mulai dingin" dan jumlah memori yang dialokasikan.  Untuk pengujian yang rumit seperti itu, BenchmarkDotNet telah dibuat.  Perpustakaan inilah yang digunakan para pengembang .NET Core dalam pengujian resmi.  Perpustakaan mudah digunakan, tetapi jika penulisnya tiba-tiba membaca posting ini, tolong beri kesempatan yang lebih nyaman untuk mempengaruhi struktur tabel hasil. <br><br>  <b>U2U Consult Performance Analyzers</b> adalah plug-in gratis untuk Visual Studio yang memberikan tips tentang peningkatan kode dalam hal kinerja.  100% mengandalkan saran dari analis ini tidak sepadan.  Karena saya menemukan sebuah situasi di mana satu saran sedikit mengejutkan saya dan setelah analisis terperinci ternyata benar-benar keliru.  Sayangnya, contoh ini hilang, jadi ambil satu kata.  Namun, jika Anda menggunakannya dengan serius, itu adalah alat yang sangat berguna.  Misalnya, ia akan menyarankan bahwa alih-alih <code>myStr.Replace("*", "-")</code> lebih efisien menggunakan <code>myStr.Replace('*', '-')</code> .  Dan dua ekspresi Dimana di LINQ lebih baik digabungkan menjadi satu.  Ini semua adalah "optimisasi saat pertandingan", tetapi mudah diterapkan dan tidak menyebabkan peningkatan kode / kompleksitas. <br><br><h4>  Kesimpulannya </h4><br>  Jika setiap orang ke-10 yang membaca artikel menerapkan pendekatan di atas untuk proyeknya saat ini (atau bagian penting dari itu), dan juga menganut pendekatan ini di masa depan, maka bersama-sama kita dapat menyelamatkan seluruh hutan!  Hutan ???  Yaitu  sumber daya yang tersimpan dari sistem komputer, dalam bentuk listrik yang diperoleh dari pembakaran kayu, akan tetap tidak digunakan.  Dalam hal ini, "hutan" hanya semacam setara.  Mungkin kesimpulan aneh keluar, tapi saya harap Anda terinspirasi oleh pemikiran itu. <br><br><h4>  Pembaruan PS berdasarkan komentar posting </h4><br>  Keuntungan dari ToArray dibandingkan ToList relevan untuk .NET Core.  Tetapi jika Anda menggunakan .NET Framework lama, maka ToList mungkin akan lebih disukai untuk Anda.  Masalahnya adalah bahwa dalam .NET Framework, panggilan ToArray itu sendiri jauh lebih lambat daripada panggilan ToList.  Dan kerugian ini mungkin tidak dapat dikompensasi oleh akses yang lebih cepat ke elemen dan penyimpanan array yang lebih sedikit.  Secara umum, masalah ini ternyata lebih rumit, karena kelas yang berbeda yang mengimplementasikan IEnumerable mungkin memiliki implementasi ToArray dan ToList yang berbeda, dengan tingkat efisiensi yang berbeda. <br><br>  Jika enum yang diwarisi dari byte digunakan sebagai anggota kelas (struktur), dan tidak secara terpisah, maka mungkin tidak ada penghematan memori.  Karena keselarasan memori yang ditempati semua anggota kelas (struktur).  Poin ini tidak ada dalam artikel.  Namun demikian, potensi keuntungan lebih baik daripada ketidakhadirannya, karena selain memori yang digunakan, enum juga digunakan.  Karena itu, paragraf 4 masih relevan, tetapi dengan reservasi penting ini. <br><br>  Terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">KvanTTT</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">epetrukhin</a> untuk komentar konstruktif tentang masalah ini. <br><br>  Juga, seperti yang dicatat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Taritsyn</a> , optimisasi pada tahap kompilasi JIT untuk kata kunci “disegel” masih ada.  Tetapi, ini hanya menegaskan semua tesis dari paragraf ke-9. <br><br>  Tampaknya semua komentar konstruktif telah diperhitungkan.  Saya sangat senang dengan komentar ini.  Karena saya sendiri, sebagai penulis, menerima umpan balik dan saya juga belajar sesuatu yang baru untuk diri saya sendiri. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466931/">https://habr.com/ru/post/id466931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466917/index.html">Ketika standar HTTP tidak cukup. Micronaut melakukan</a></li>
<li><a href="../id466921/index.html">5 masalah dari setiap perusahaan jasa dan solusinya menggunakan platform otomatisasi</a></li>
<li><a href="../id466923/index.html">Bagaimana cara IT pro di bank asing untuk membuktikan asal dana</a></li>
<li><a href="../id466925/index.html">Bagaimana menjalankan VDS Hi-CPU untuk Bitrix, bubarkan burung beo dan jangan sampai bangkrut</a></li>
<li><a href="../id466929/index.html">Tambahkan Segarkan Token</a></li>
<li><a href="../id466933/index.html">Cara berteman industri dan data besar</a></li>
<li><a href="../id466937/index.html">Bagaimana kami melakukan Olimpiade online All-Rusia dalam bahasa Inggris, matematika, dan ilmu komputer</a></li>
<li><a href="../id466941/index.html">Mengapa Windows membaca satu file seratus ribu kali untuk membuka menu?</a></li>
<li><a href="../id466949/index.html">Prospek untuk jaringan kuantum: siapa yang terlibat di dalamnya dan mengapa</a></li>
<li><a href="../id466955/index.html">Teka-teki resume. Bagian 3. Tabir rahasia dihapus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>