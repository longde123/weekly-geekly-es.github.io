<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóûÔ∏è üë∞ üóíÔ∏è Desenvolvemos camar√£o: controlamos solicita√ß√µes paralelas, registramos atrav√©s do spdlog e muito mais ... üë∏üèΩ üö¥üèø ü¶ç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na semana passada, falamos sobre o nosso pequeno projeto de demonstra√ß√£o, Shrimp , que mostra claramente como voc√™ pode usar as bibliotecas C ++ RESTi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desenvolvemos camar√£o: controlamos solicita√ß√µes paralelas, registramos atrav√©s do spdlog e muito mais ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417527/"><img src="https://habrastorage.org/webt/6p/er/na/6pernaqwjoqg3picsc4pz2d1xba.jpeg"><br><br>  Na semana passada, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">falamos sobre o nosso pequeno projeto de demonstra√ß√£o, Shrimp</a> , que mostra claramente como voc√™ pode usar as bibliotecas C ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RESTinio</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SObjectizer</a> em condi√ß√µes mais ou menos semelhantes.  O Shrimp √© um pequeno aplicativo C ++ 17 que, atrav√©s do RESTinio, aceita solicita√ß√µes HTTP para dimensionamento de imagens e atende a essas solicita√ß√µes no modo multithread atrav√©s do SObjectizer e ImageMagick ++. <br><br>  O projeto acabou sendo mais do que √∫til para n√≥s.  O cofrinho de lista de desejos para expandir a funcionalidade do RESTinio e SObjectizer foi reabastecido significativamente.  Algo que j√° foi incorporado em uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vers√£o</a> muito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recente do RESTinio-0.4.7</a> .  Por isso, decidimos n√£o nos debru√ßar sobre a primeira e mais trivial vers√£o do Shrimp, mas fazer mais uma ou duas itera√ß√µes em torno deste projeto.  Se algu√©m estiver interessado no que e como fizemos durante esse per√≠odo, voc√™ √© bem-vindo sob cat. <br><blockquote>  Como um spoiler: falaremos sobre como nos livramos do processamento paralelo de solicita√ß√µes id√™nticas, como adicionamos o log ao Shrimp usando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">excelente biblioteca spdlog</a> e tamb√©m fizemos um comando para for√ßar a restaura√ß√£o do cache das imagens transformadas. </blockquote><a name="habracut"></a><h1>  v0.3: controle do processamento paralelo de pedidos id√™nticos </h1><br>  A primeira vers√£o do Shrimp, descrita em um artigo anterior, continha uma s√©ria simplifica√ß√£o: n√£o havia controle sobre se a mesma solicita√ß√£o est√° sendo processada ou n√£o. <br><br>  Imagine que, pela primeira vez, o Shrimp receba uma solicita√ß√£o no formato "/demo.jpg?op=resize&amp;max=1024".  Ainda n√£o existe uma imagem no cache de imagem transformada, portanto, a solicita√ß√£o est√° sendo processada.  O processamento pode levar um tempo consider√°vel, digamos, algumas centenas de milissegundos. <br><br>  O processamento da solicita√ß√£o ainda n√£o foi conclu√≠do e o Shrimp novamente recebe a mesma solicita√ß√£o "/demo.jpg?op=resize&amp;max=1024", mas de outro cliente.  Ainda n√£o h√° resultado de transforma√ß√£o no cache, portanto, essa solicita√ß√£o tamb√©m ser√° processada. <br><br>  O primeiro e o segundo pedidos ainda n√£o foram conclu√≠dos, e o Shrimp pode novamente receber o mesmo pedido "/demo.jpg?op=resize&amp;max=1024".  E essa solicita√ß√£o tamb√©m ser√° processada.  Acontece que a mesma imagem √© dimensionada para o mesmo tamanho em paralelo v√°rias vezes. <br><br>  Isso n√£o √© bom.  Portanto, a primeira coisa que decidimos no Shrimp foi nos livrar de um batente t√£o s√©rio.  Fizemos isso devido a dois cont√™ineres complicados no agente transform_manager.  O primeiro cont√™iner √© uma fila de espera para solicita√ß√µes gratuitas de transformadores.  Este √© um cont√™iner chamado m_pending_requests.  O segundo cont√™iner armazena solicita√ß√µes que j√° foram processadas (ou seja, transformadores espec√≠ficos foram alocados a essas solicita√ß√µes).  Este √© um cont√™iner chamado m_inprogress_requests. <br><br>  Quando transform_manager recebe a pr√≥xima solicita√ß√£o, ele verifica a presen√ßa da imagem finalizada no cache de imagens transformadas.  Se n√£o houver imagem convertida, os cont√™ineres m_inprogress_requests e m_pending_requests ser√£o verificados.  E se n√£o houver uma solicita√ß√£o com esses par√¢metros em nenhum desses cont√™ineres, apenas uma tentativa ser√° feita para colocar a solicita√ß√£o na fila m_pending_requests.  √â <a href="">assim</a> : <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::handle_not_transformed_image( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> request_key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> store_to = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request_key), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_inprogress_requests.has_key( request_key ) ) { <span class="hljs-comment"><span class="hljs-comment">//    . //         . store_to( m_inprogress_requests ); } else if( m_pending_requests.has_key( request_key ) ) { //      . store_to( m_pending_requests ); } else if( m_pending_requests.unique_keys() &lt; max_pending_requests ) { //           . store_to( m_pending_requests ); //    transformer-     . try_initiate_pending_requests_processing(); } else { //  ,   . do_503_response( std::move(cmd-&gt;m_http_req) ); } }</span></span></code> </pre> <br>  Foi dito acima que m_inprogress_requests e m_pending_requests s√£o cont√™ineres complicados.  Mas qual √© o truque? <br><br>  O truque √© que esses cont√™ineres combinam as propriedades de uma fila FIFO regular (na qual a ordem cronol√≥gica de adi√ß√£o de elementos √© preservada) e o multimap, ou seja,  Um cont√™iner associativo no qual v√°rios valores podem ser mapeados para uma √∫nica chave. <br><br>  Manter a ordem cronol√≥gica √© importante, porque os elementos mais antigos em m_pending_requests precisam ser verificados periodicamente e removidos de m_pending_requests aqueles pedidos para os quais o tempo limite m√°ximo foi excedido.  E o acesso efetivo aos elementos por chave √© necess√°rio para verificar a presen√ßa de solicita√ß√µes id√™nticas nas filas e para que todas as solicita√ß√µes duplicadas possam ser removidas da fila por vez. <br><br>  Na Shrimp, pedalamos <a href="">nosso pequeno cont√™iner</a> para esses fins.  Embora, se o Boost fosse usado no camar√£o, o Boost.MultiIndex poderia ser usado.  E, provavelmente, com o tempo, uma pesquisa eficaz em m_pending_requests precisar√° ser organizada por alguns outros crit√©rios; o Boost.MultiIndex no Shrimp ter√° que ser ativado. <br><br><h1>  v0.4: registrando com spdlog </h1><br>  Tentamos deixar a primeira vers√£o do Shrimp o mais simples e compacta poss√≠vel.  Por causa disso, na primeira vers√£o do Shrimp, n√£o usamos log.  Geralmente. <br><br>  Por um lado, isso tornou poss√≠vel manter o c√≥digo da primeira vers√£o conciso, contendo nada al√©m da l√≥gica de neg√≥cios necess√°ria do Shrimp.  Mas, por outro lado, a falta de explora√ß√£o madeireira complica tanto o desenvolvimento do camar√£o quanto sua opera√ß√£o.  Portanto, assim que colocamos nossas m√£os nele, imediatamente arrastamos para o Shrimp uma excelente biblioteca C ++ moderna para registro - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">spdlog</a> .  Respirar imediatamente se tornou mais f√°cil, embora o c√≥digo de alguns m√©todos tenha aumentado em volume. <br><br>  Por exemplo, o c√≥digo acima do m√©todo handle_not_transformed_image () com registro come√ßa com a seguinte apar√™ncia: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::handle_not_transformed_image( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> request_key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> store_to = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request_key), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_inprogress_requests.has_key( request_key ) ) { <span class="hljs-comment"><span class="hljs-comment">//    . m_logger-&gt;debug( "same request is already in progress; request_key={}", request_key ); //         . store_to( m_inprogress_requests ); } else if( m_pending_requests.has_key( request_key ) ) { //      . m_logger-&gt;debug( "same request is already pending; request_key={}", request_key ); store_to( m_pending_requests ); } else if( m_pending_requests.unique_keys() &lt; max_pending_requests ) { //           . m_logger-&gt;debug( "store request to pending requests queue; request_key={}", request_key ); store_to( m_pending_requests ); //    transformer-     . try_initiate_pending_requests_processing(); } else { //  ,   . m_logger-&gt;warn( "request is rejected because of overloading; " "request_key={}", request_key ); do_503_response( std::move(cmd-&gt;m_http_req) ); } }</span></span></code> </pre> <br><h2>  Configurando registradores spdlog </h2><br>  O login no Shrimp √© feito no console (ou seja, no fluxo de sa√≠da padr√£o).  Em princ√≠pio, pode-se seguir um caminho muito simples e criar no Shrimp a √∫nica inst√¢ncia do spd-logger.  I.e.  pode-se chamar <a href="">stdout_color_mt</a> (ou <a href="">stdout_logger_mt</a> ) e depois passar esse registrador para todas as entidades no Shrimp.  Mas fomos um pouco mais complicados: criamos manualmente o chamado  coletor (ou seja, o canal em que o spdlog emitir√° as mensagens geradas) e, para as entidades de camar√£o, eles criaram registradores separados anexados a esse coletor. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     . [[nodiscard]] spdlog::sink_ptr make_logger_sink() { auto sink = std::make_shared&lt; spdlog::sinks::ansicolor_stdout_sink_mt &gt;(); return sink; } [[nodiscard]] std::shared_ptr&lt;spdlog::logger&gt; make_logger( const std::string &amp; name, spdlog::sink_ptr sink, spdlog::level::level_enum level = spdlog::level::trace ) { auto logger = std::make_shared&lt; spdlog::logger &gt;( name, std::move(sink) ); logger-&gt;set_level( level ); logger-&gt;flush_on( level ); return logger; } //        : auto manager = coop.make_agent_with_binder&lt; a_transform_manager_t &gt;( create_one_thread_disp( "manager" )-&gt;binder(), make_logger( "manager", logger_sink ) ); ... const auto worker_name = fmt::format( "worker_{}", worker ); auto transformer = coop.make_agent_with_binder&lt; a_transformer_t &gt;( create_one_thread_disp( worker_name )-&gt;binder(), make_logger( worker_name, logger_sink ), app_params.m_storage );</span></span></code> </pre><br>  H√° um ponto sutil na configura√ß√£o de registradores no spdlog: por padr√£o, o registrador ignora mensagens com n√≠veis de gravidade de rastreamento e depura√ß√£o.  Ou seja, eles provam ser mais √∫teis ao depurar.  Portanto, no make_logger, ativamos por padr√£o o log para todos os n√≠veis, incluindo rastreamento / depura√ß√£o. <br><br>  Devido ao fato de que cada entidade no Shrimp tem seu pr√≥prio logger com seu pr√≥prio nome, podemos ver quem faz o que no log: <br><br><img src="https://habrastorage.org/webt/1o/jh/yx/1ojhyxgywovfstlfsybe19h0lb0.png"><br><br><h2>  Rastreando SObjectizer com spdlog </h2><br>  Os tempos de log, que s√£o executados como parte da l√≥gica comercial principal de um aplicativo SObjectizer, n√£o s√£o suficientes para depurar o aplicativo.  N√£o est√° claro por que alguma a√ß√£o √© iniciada em um agente, mas na verdade n√£o √© executada em outro agente.  Nesse caso, o mecanismo msg_tracing embutido no SObjectizer ajuda muito (sobre o qual falamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em um artigo separado</a> ).  Mas entre as implementa√ß√µes padr√£o msg_tracing para SObjectizer, n√£o h√° uma que use spdlog.  Faremos essa implementa√ß√£o para o Shrimp: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spdlog_sobj_tracer_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::msg_tracing::<span class="hljs-keyword"><span class="hljs-keyword">tracer_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; m_logger; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; logger ) : m_logger{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(logger) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; what )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> override </span></span>{ m_logger-&gt;trace( what ); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> so_5::msg_tracing::<span class="hljs-keyword"><span class="hljs-keyword">tracer_unique_ptr_t</span></span> make( spdlog::sink_ptr sink ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>&gt;( make_logger( <span class="hljs-string"><span class="hljs-string">"sobjectizer"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(sink) ) ); } };</code> </pre> <br>  Aqui vemos a implementa√ß√£o da interface especial do SObjectizer tracer_t, na qual o principal √© o m√©todo virtual trace ().  √â ele quem realiza o rastreamento das partes internas do SObjectizer por meio do spdlog. <br><br>  Em seguida, esta implementa√ß√£o √© instalada como um rastreador ao iniciar o SObjectizer: <br><br><pre> <code class="cpp hljs">so_5::<span class="hljs-keyword"><span class="hljs-keyword">wrapped_env_t</span></span> sobj{ [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) {...}, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">sobj_tracing_t</span></span>::on == sobj_tracing ) params.message_delivery_tracer( <span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>::make( logger_sink ) ); } };</code> </pre> <br><h2>  Rastreio RESTinio atrav√©s do spdlog </h2><br>  Al√©m de rastrear o que acontece dentro do SObjectizer, √†s vezes pode ser muito √∫til rastrear o que acontece dentro do RESTinio.  Na vers√£o atualizada do Shrimp, esse rastreamento tamb√©m √© adicionado. <br><br>  Esse rastreamento √© implementado atrav√©s da defini√ß√£o de uma classe especial que pode executar o log no RESTinio: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_server_logger_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">http_server_logger_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; logger ) : m_logger{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( logger ) } {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::trace, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::info, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">warn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::warn, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::err, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log_if_enabled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( spdlog::level::level_enum lv, Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_logger-&gt;should_log(lv) ) { m_logger-&gt;<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( lv, msg_builder() ); } } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; m_logger; };</code> </pre> <br>  Essa classe n√£o √© herdada de nada, uma vez que o mecanismo de registro no RESTinio √© baseado em programa√ß√£o generalizada e n√£o na abordagem tradicional orientada a objetos.  Isso permite que voc√™ se livre de qualquer sobrecarga nos casos em que o log n√£o √© necess√°rio (abordamos esse t√≥pico com mais detalhes quando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">falamos sobre o uso de modelos no RESTinio</a> ). <br><br>  Em seguida, precisamos indicar que o servidor HTTP usar√° a classe http_server_logger_t mostrada acima como seu logger.  Isso √© feito esclarecendo as propriedades do servidor HTTP: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_server_traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">http_server_logger_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_handler_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span>; };</code> </pre> <br>  Bem, n√£o h√° mais o que fazer - crie uma inst√¢ncia espec√≠fica do spd-logger e envie-o para o servidor HTTP criado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> restinio_logger = make_logger( <span class="hljs-string"><span class="hljs-string">"restinio"</span></span>, logger_sink, <span class="hljs-keyword"><span class="hljs-keyword">restinio_tracing_t</span></span>::off == restinio_tracing ? spdlog::level::off : log_level ); restinio::run( asio_io_ctx, shrimp::make_http_server_settings( thread_count.m_io_threads, params, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(restinio_logger), manager_mbox_promise.get_future().get() ) );</code> </pre> <br><h1>  v0.5: redefini√ß√£o for√ßada do cache de imagem transformado </h1><br>  No processo de depura√ß√£o do Shrimp, uma pequena coisa foi descoberta: um pouco irritante: para liberar o conte√∫do do cache de imagem transformado, era necess√°rio reiniciar todo o Shrimp.  Parece um pouco, mas desagrad√°vel. <br><br>  Como √© desagrad√°vel, voc√™ deve se livrar dessa falha.  Felizmente, isso n√£o √© nada dif√≠cil. <br><br>  Primeiro, definiremos outra URL no Shrimp para a qual voc√™ pode enviar solicita√ß√µes HTTP DELETE: "/ cache".  Conseq√ºentemente, colocaremos nosso manipulador neste URL: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span> &gt; make_router( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">app_params_t</span></span> &amp; params, so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> req_handler_mbox ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt; <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span> &gt;(); add_transform_op_handler( params, *router, req_handler_mbox ); add_delete_cache_handler( *router, req_handler_mbox ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router; }</code> </pre> <br>  onde a fun√ß√£o add_delete_cache_handler () se parece com isso: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_delete_cache_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">http_req_router_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; router, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_handler_mbox )</span></span></span><span class="hljs-function"> </span></span>{ router.http_delete( <span class="hljs-string"><span class="hljs-string">"/cache"</span></span>, [req_handler_mbox]( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-comment"><span class="hljs-comment">/*params*/</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> qp = restinio::parse_query( req-&gt;header().query() ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> token = qp.get_param( <span class="hljs-string"><span class="hljs-string">"token"</span></span>sv ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !token ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_403_response( req, <span class="hljs-string"><span class="hljs-string">"No token provided\r\n"</span></span> ); } <span class="hljs-comment"><span class="hljs-comment">// Delegate request processing to transform_manager. so_5::send&lt; so_5::mutable_msg&lt;a_transform_manager_t::delete_cache_request_t&gt; &gt;( req_handler_mbox, req, restinio::cast_to&lt;std::string&gt;(*token) ); return restinio::request_accepted(); } ); }</span></span></code> </pre> <br>  Um pouco detalhado, mas nada complicado.  A cadeia de consulta da consulta deve ter um par√¢metro de token.  Este par√¢metro deve conter uma sequ√™ncia com um valor especial para o token administrativo.  Voc√™ s√≥ pode redefinir o cache se o valor do token do par√¢metro token corresponder ao que foi definido quando o Shrimp foi iniciado.  Se n√£o houver par√¢metro de token, a solicita√ß√£o de processamento n√£o ser√° aceita.  Se houver token, o agente transform_manager, dono do cache, receber√° uma mensagem de comando especial, executando o qual o pr√≥prio agente transform_manager responder√° √† solicita√ß√£o HTTP. <br><br>  Em segundo lugar, implementamos o novo manipulador de mensagens delete_cache_request_t no agente transform_manager_t: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_delete_cache_request( <span class="hljs-keyword"><span class="hljs-keyword">mutable_mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">delete_cache_request_t</span></span>&gt; cmd ) { m_logger-&gt;warn( <span class="hljs-string"><span class="hljs-string">"delete cache request received; "</span></span> <span class="hljs-string"><span class="hljs-string">"connection_id={}, token={}"</span></span>, cmd-&gt;m_http_req-&gt;connection_id(), cmd-&gt;m_token ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> delay_response = [&amp;]( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> response_text ) { so_5::send_delayed&lt; so_5::mutable_msg&lt;<span class="hljs-keyword"><span class="hljs-keyword">negative_delete_cache_response_t</span></span>&gt; &gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds{<span class="hljs-number"><span class="hljs-number">7</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response_text) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * env_token = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getenv( <span class="hljs-string"><span class="hljs-string">"SHRIMP_ADMIN_TOKEN"</span></span> ); <span class="hljs-comment"><span class="hljs-comment">// Token must be present and must not be empty. env_token &amp;&amp; *env_token ) { if( cmd-&gt;m_token == env_token ) { m_transformed_cache.clear(); m_logger-&gt;info( "cache deleted" ); do_200_plaintext_response( std::move(cmd-&gt;m_http_req), "Cache deleted\r\n" ); } else { m_logger-&gt;error( "invalid token value for delete cache request; " "token={}", cmd-&gt;m_token ); delay_response( "Token value mismatch\r\n" ); } } else { m_logger-&gt;warn( "delete cache can't performed because there is no " "admin token defined" ); // Operation can't be performed because admin token is not avaliable. delay_response( "No admin token defined\r\n" ); } }</span></span></code> </pre> <br>  H√° dois pontos aqui que devem ser esclarecidos. <br><br>  O primeiro ponto na implementa√ß√£o de on_delete_cache_request () √© a verifica√ß√£o do pr√≥prio valor do token.  O token administrativo √© definido atrav√©s da vari√°vel de ambiente SHRIMP_ADMIN_TOKEN.  Se essa vari√°vel estiver configurada e seu valor corresponder ao valor do par√¢metro token da solicita√ß√£o HTTP DELETE, o cache ser√° limpo e uma resposta positiva √† solicita√ß√£o ser√° gerada imediatamente. <br><br>  E o segundo ponto na implementa√ß√£o de on_delete_cache_request () √© o atraso for√ßado de uma resposta negativa ao HTTP DELETE.  Se o valor incorreto do token administrativo chegar, voc√™ deve adiar a resposta ao HTTP DELETE para que n√£o haja desejo de selecionar o valor do token por for√ßa bruta.  Mas como fazer esse atraso?  Afinal, chamar std :: thread :: sleep_for () n√£o √© uma op√ß√£o. <br><br>  √â aqui que as mensagens pendentes do SObjectizer s√£o resgatadas.  Em vez de gerar imediatamente uma resposta negativa dentro de on_delete_cache_request (), o agente transform_manager simplesmente envia a si mesmo uma mensagem negativa_delete_cache_response_t pendente.  O temporizador do SObjectizer contar√° o tempo definido e entregar√° esta mensagem ao agente ap√≥s o atraso especificado.  E agora no manipulador negative_delete_cache_response_t, voc√™ j√° pode gerar imediatamente uma resposta √† solicita√ß√£o HTTP DELETE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_negative_delete_cache_response( <span class="hljs-keyword"><span class="hljs-keyword">mutable_mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">negative_delete_cache_response_t</span></span>&gt; cmd ) { m_logger-&gt;debug( <span class="hljs-string"><span class="hljs-string">"send negative response to delete cache request; "</span></span> <span class="hljs-string"><span class="hljs-string">"connection_id={}"</span></span>, cmd-&gt;m_http_req-&gt;connection_id() ); do_403_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_response_text) ); }</code> </pre> <br>  I.e.  acontece o seguinte cen√°rio: <br><br><ul><li>  O servidor HTTP recebe uma solicita√ß√£o HTTP DELETE, converte essa solicita√ß√£o em uma mensagem delete_cache_request_t no agente transform_manager; </li><li>  O agente transform_manager recebe a mensagem delete_cache_request_t e imediatamente gera uma resposta positiva √† solicita√ß√£o ou envia uma mensagem negativa_delete_cache_response_t pendente; </li><li>  transform_manager recebe uma mensagem negative_delete_cache_response_t e gera imediatamente uma resposta negativa para a solicita√ß√£o HTTP DELETE correspondente. </li></ul><br><h1>  Fim da segunda parte </h1><br>  No final da segunda parte, √© bastante natural fazer a pergunta: "O que vem depois?" <br><br>  Al√©m disso, provavelmente haver√° outra itera√ß√£o e outra atualiza√ß√£o do nosso projeto de demonstra√ß√£o.  Eu gostaria de fazer uma coisa como converter uma imagem de um formato para outro.  Por exemplo, no servidor, a imagem est√° em jpg e, ap√≥s a transforma√ß√£o, √© enviada ao cliente no webp. <br><br>  Tamb√©m seria interessante anexar uma "p√°gina" separada com a exibi√ß√£o das estat√≠sticas atuais sobre o trabalho do Camar√£o.  Primeiro de tudo, √© apenas curioso.  Mas, em princ√≠pio, essa p√°gina tamb√©m pode ser adaptada √†s necessidades de monitoramento da viabilidade do camar√£o. <br><br>  Se algu√©m tiver sugest√µes sobre o que eu gostaria de ver em Camar√£o ou em artigos sobre Camar√£o, teremos prazer em ouvir qualquer pensamento construtivo. <br><br>  Separadamente, quero observar um aspecto na implementa√ß√£o do Camar√£o, que nos surpreendeu um pouco.  Este √© um uso ativo de mensagens mut√°veis ‚Äã‚Äãao se comunicar com o servidor HTTP.  Geralmente, em nossa pr√°tica, acontece o oposto - mais frequentemente os dados s√£o trocados por mensagens imunes.  N√£o √© assim aqui.  Isso sugere que ouvimos conscientemente os desejos dos usu√°rios no devido tempo e adicionamos mensagens mut√°veis ‚Äã‚Äãao SObjectizer.  Portanto, se voc√™ gostaria de ver algo no RESTinio ou no SObjectizer, fique √† vontade para compartilhar suas id√©ias.  Temos a certeza de ouvir os bons. <br><br>  Bem, e em conclus√£o, gostaria de agradecer a todos que se interessaram e falaram sobre a primeira vers√£o do Shrimp, tanto aqui em Habr√© quanto atrav√©s de outros recursos.  Obrigada <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para continuar ...</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt417527/">https://habr.com/ru/post/pt417527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt417511/index.html">Intel adquire eASIC - desenvolvedor estrutural de ASIC</a></li>
<li><a href="../pt417513/index.html">An√°logos em Python e JavaScript. Parte dois</a></li>
<li><a href="../pt417515/index.html">O que aprendi criando 100 jogos em 5 anos</a></li>
<li><a href="../pt417517/index.html">P√°ginas da hist√≥ria da Intel. Photo Chronicle and Quiz</a></li>
<li><a href="../pt417521/index.html">Revise certificados SSL para revoga√ß√£o</a></li>
<li><a href="../pt417529/index.html">Tr√™s tend√™ncias tecnol√≥gicas que mudam com√©rcio e consumidor</a></li>
<li><a href="../pt417531/index.html">Como vencemos no SmartMailHack 2</a></li>
<li><a href="../pt417533/index.html">O bloco de notas no Windows recebeu a primeira atualiza√ß√£o significativa em duas d√©cadas</a></li>
<li><a href="../pt417535/index.html">O desenvolvimento do CUBA est√° a um grande passo do Spring?</a></li>
<li><a href="../pt417537/index.html">"Seu jogo √© chato" ou como aumentar a j√° alta reten√ß√£o do primeiro dia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>