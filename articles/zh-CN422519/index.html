<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸🏾 🐯 ✌🏿 免费赠品发行：Java中的非编织线程。 项目织机 👏🏽 ⛹🏿 🔈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您是否要在Java线程中不消耗内存，就好像它们本身并不会减慢速度一样？ 信誉良好，这个问题回答了这个问题。 


 我们在披萨盒上解释Loom项目的工作！ 加油！ 


 所有这些都已删除并专门为Habr编写。 





 呼号 


 您是否经常在Web服务上看到此图片：起初一切都很好，然后有一...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>免费赠品发行：Java中的非编织线程。 项目织机</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/422519/"><p> 您是否要在Java线程中不消耗内存，就好像它们本身并不会减慢速度一样？ 信誉良好，这个问题回答了这个问题。 </p><br><p> 我们在披萨盒上解释Loom项目的工作！ 加油！ </p><br><p> 所有这些<b>都已</b>删除并<b>专门为Habr</b>编写。 </p><br><br><p><br clear="all"></p><a name="habracut"></a><br><h1 id="pozyvnye"> 呼号 </h1><br><p> 您是否经常在Web服务上看到此图片：起初一切都很好，然后有一百万中国人来找您，该服务创建了一百万个线程并淹没在地狱中？ </p><br><p><img src="https://habrastorage.org/webt/ym/_-/3r/ym_-3rq8a8g56hsmrvjhprnih8y.png"><br><br></p><br><p> 你想要这么漂亮的照片吗？ </p><br><p><img src="https://habrastorage.org/webt/38/s-/04/38s-04z5nak6trs_p2lei9chjku.png"><br><br></p><br><p> 换句话说，您是否要在Java线程中不占用内存但又不在内存中并且不会减慢速度？ 信誉良好，这个问题回答了这个问题。 </p><br><p> 实际上，我们将参与<em>拆解新框架</em> 。 还记得Wylsacom如何打开iPhone包装吗？ 有些人已经不记得以前的评论者了，但是为什么呢？ 因为哈勃（Habr）是主流据点，而对不起，付费的vidos就是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">腹泻</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">光芒</a> 。 在这篇文章中，我们将专门讨论技术核心。 </p><br><p> 首先，两分钟到眼球，免责声明和其他垃圾，必须要说。 如果您太懒，可以跳过它。 </p><br><p> 首先，视频中所说的一切只是我的个人想法，与雇主或光荣的甲骨文公司，蜥蜴世界政府以及在砂浆中的该死的东西无关。 我什至在凌晨三点写下这封信，这很明显是我的个人主动性，也是我的个人垃圾。  <em>所有比赛完全是随机的。</em> </p><br><p> 但是还有另一个奖励目标。 我们经常谈论科特林的协程。 最近，对Corutin的神<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">罗姆·</a>伊利扎罗夫（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Roma Elizarov）</a>以及将要为其编写后端的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Pasha Finkelstein</a>进行了采访。 不久将接受Kotlin的父亲Andrei Breslav的采访。 在Loom项目的任何地方都以一种或另一种方式提及，因为它是协程的类似物。 而且，如果您不知道Loom是什么，那么在阅读这些访谈时您可能会感到愚蠢。 有一些很酷的家伙，他们讨论很酷的事情。 你在那儿，而你不在他们那里，你是傻子。 这很愚蠢。 </p><br><p> 不要这样做，请阅读Loom在本文中的内容，或者进一步观看此视频，我将解释所有内容。 </p><br><p> 那么，并发症是什么。 有这样的家伙，罗恩·普雷斯勒。 </p><br><br><p><img src="https://habrastorage.org/webt/w-/tq/ut/w-tqutfyx33olnhdavtq_asdv9u.png"><br><br></p><br><p> 去年，他<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">去了邮件列表</a> ，说Java中的线程很烂，并建议他运行运行时并对其进行修复。 如果不是因为他早些时候写过《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Quasar》</a> ，每个人都会嘲笑他，扔石头，拉屎，这实际上很酷。 您可以在Quasar宣誓很长时间，但是它似乎确实存在并且可以奏效，并且从所有方面看，这很可能是一项成就。 </p><br><p> 只是说，有很多政府无所事事而无所作为。 好吧，弄对了，我是一样的。 或者有些人似乎是很酷的工程师，但是总的来说，在无意识的情况下，他们会说：“在Java中，您需要改进线程。” 有什么改进？ 什么是线程？ </p><br><p> 人们通常懒得思考。 </p><br><p> 像个玩笑： <br> 佩特卡（Petka）和瓦西里·伊万诺维奇（Vasily Ivanovich）坐飞机。 <br> 瓦西里·伊万诺维奇（Vasily Ivanovich）问：-Petka，设备吗？ <br>  Petka回复：-200！ <br> 瓦西里·伊万诺维奇：-那200呢？ <br> 佩特卡：-电器呢？ </p><br><p> 我讲一个故事。 我今年春天在乌克兰，我们是从白俄罗斯飞来的（您知道为什么直接从圣彼得堡来不可能做到这一点）。 在海关，我们坐了大约两个小时。 海关官员非常友善，严肃地说，问Java是否是过时的技术。 附近有坐飞机的人，他们飞到同一个konf。 而且我是一名演讲者，我必须下蹲，站起来，并且如预期的那样，无耻地谈论我根本不使用的东西。 在他谈论称为Liberica的JDK发行版的过程中，这就是Raspberry Pi的JDK。 </p><br><p> 你怎么看？ 甚至不到六个月，人们就敲了我的购物车，然后说，看，我们已经在Liber上放下了解决方案，我已经在白俄罗斯语jfuture.by konf上获得了有关此问题的报告。 这就是方法。 这不是一个糟糕的传教士，而是一个普通的工程师。 </p><br><blockquote> 顺便说一句，我们很快将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">举行2018年Joker大会</a> ，其中包括<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Andrei Breslav</a> （显然是在协程中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">翻腾</a> ）和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Pasha Finkelshtein的</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Josh Long</a>可以被问到Spring对Loom的支持。 好吧，还有很多很酷的杰出专家，快来！ </blockquote><p> 现在，返回到线程。 人们试图通过两个退化的神经元来思考，他们wind起拳头，喃喃自语：“ Java中的线程不是这样，Java中的线程不是这样。” 设备！ 什么电器？ 这通常是地狱。 </p><br><p> 普雷斯勒（Presler）来了，这是一个普通的，没被贬低的家伙，起初他做得很理智。 一年后，看到了一个工作演示。 我说了所有这些，是为了让您理解问题的常规描述，常规文档是这种特殊的英雄主义。 演示通常是空间。 这是第一个实际上在这个方向上做任何事情的人。 他最需要。 </p><br><p>  Presler与演示一起在会议上发表了讲话，并发布了以下视频： </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/J31o0ZMQEnI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> 实际上，整篇文章都是对那里所说内容的回顾。 我完全不假装这种材料的独特性，本文中的所有内容都是Ron发明的。 </p><br><p> 讨论涉及三个痛苦的主题： </p><br><ul><li> 续集 </li><li> 纤维类 </li><li> 尾声 </li></ul><br><p> 可能是，看到Quasar并与他的小故障作斗争使他感到非常恶心，以至于没有力量-您需要将其推入运行时。 </p><br><p> 一年前，从那时起，他们就开始制作原型。 有些人已经不再希望我们有一天能看到一个演示了，但是一个月前他们诞生了该演示，并展示了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此推文中</a>可见的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内容</a> 。 </p><br><br><p><img src="https://habrastorage.org/webt/ck/hp/mc/ckhpmcchdv2k6_4vfbw733evg6c.png"><br><br></p><br><p> 该演示中的所有三个痛苦的话题都直接存在于代码中，或者至少在道德上存在。 好吧，是的，他们还没有掌握尾声，但是他们想要。 </p><br><h1 id="problematika"> 发行 </h1><br><p> 不满意的用户，应用程序开发人员在制作API时被迫在两把椅子之间进行选择。 山峰建在一把椅子上，而花在另一把椅子上生长。 而且没有一个适合我们。 </p><br><br><p><img src="https://habrastorage.org/webt/tn/nx/k-/tnnxk-iwzuj7sybfwllour9qozq.png"><br><br></p><br><p> 例如，如果您编写一个可同步运行的服务，则该服务可与旧版代码很好地配合使用，那么调试和监视性能就变得很容易。 带宽和可伸缩性会出现问题。 仅仅因为您现在可以在一个简单的硬件上运行的线程数就可以在商品硬件上运行-假设有两千个。 这远少于可以为此服务器打开的连接数。 从网络代码的角度来看，这几乎是无止境的。 </p><br><p>  （嗯，是的，这与Java中的套接字排列得很早有关，但这是另一个对话的主题） </p><br><p> 假设您正在编写某种MMO。 </p><br><br><p><img src="https://habrastorage.org/webt/ye/mg/pm/yemgpm6on0pidozkhmco3epwapa.png"><br><br></p><br><p> 例如，在《 EVE Online》的北战争期间，有2,400名飞行员聚集在太空中的一个点，每个人-有条件的，是否用Java编写-都不是一个线程，而是多个线程。 而且，试点当然是复杂的业务逻辑，而不是可以通过放大镜手动排除的任何HTML发行。 </p><br><p> 那场战斗的响应时间太长，以至于玩家不得不等待几分钟来等待投篮。 据我所知，CCP专门为那场战斗投入了其集群的巨大硬件资源。 </p><br><p> 虽然，我可能以徒劳的EVE为例，因为据我所知，一切都是用Python编写的，而在具有多线程的Python中，它仍然比我们的更糟糕-我们可以认为语言功能竞争不佳。 但是，这个例子很清楚，而且带有图片。 </p><br><p> 如果您总体上对IMO主题感兴趣，特别是对“北战争”的历史感兴趣，那么最近在Bulzhat频道上已经出现了关于该主题的非常不错的视频（无论名称是什么意思），请从我的时间戳记下观看。 </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AkAtiTNvjz8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> 我们回到主题。 </p><br><p> 另一方面，您可以使用某种异步框架。 它是可扩展的。 但是我们将立即陷入非常困难的调试阶段，对性能进行复杂的分析，我们将无法将其与旧版软件无缝集成，您将不得不重写很多东西，将它们包裹在可恶的包装器中，并且通常感觉就像我们被强奸了一样。 连续几次。 事实上，实际上，在整整几天里，我们写这篇文章的时候，您都会有那样的感觉。 </p><br><p> 我问专家，著名的院士埃斯科巴（Escobar），他对此有何看法： </p><br><br><p><img width="300" src="https://habrastorage.org/webt/7g/hf/mg/7ghfmg3x8aqhdl0jcyrbpairqsc.png"><br><br></p><br><p> 怎么办 所谓的费伯斯急忙营救。 </p><br><p> 在一般情况下，光纤是这样的轻量级线程，它们也会在地址空间中泛滥（您知道，因为不会发生奇迹）。 但是与普通线程不同，它们不使用抢占式多任务，而是协作式多任务。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Wikipedia上</a>阅读更多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内容</a> 。 </p><br><p> 光纤可以同时实现同步和异步编程的优点。 结果，铁的利用率提高了，并且同一任务在群集中使用的服务器更少。 好吧，在我们的口袋里，我们会薰衣草。 巴斯 奴隶 钱 好吧，你明白了。 对于已保存的服务器。 </p><br><h1 id="na-raspute"> 在十字路口 </h1><br><p> 我想讨论的第一件事。 人们不了解延续和纤维之间的区别。 <br> 现在将有一个邪教启示！ </p><br><p> 我们将宣布一个事实：Continuation和Fiber是两个不同的事物。 </p><br><h1 id="continuations"> 延续 </h1><br><p> 纤维建立在称为Continuations的机制的顶部。 </p><br><p> 连续性（更确切地说是定界的连续性）是一种计算，执行，是程序的一部分，可以入睡，然后从入睡的地方唤醒并继续执行。 甚至在他睡觉时，有时甚至可以将其克隆或序列化。 </p><br><p> 我将使用“ continuation”一词，而不是“ continuation”（如Wikipedia所写），因为我们所有人都使用<em>英语进行</em>交流。 使用普通的俄语术语，很容易会遇到俄语和英语术语之间的差异太大而其他人都无法理解所说内容的情况。 </p><br><p> 我有时还会使用“挤出”一词，而不是英文版本的“ yield”。 只是“收益”一词-确实很讨厌。 因此，将会出现“挤出”。 </p><br><p> 所以在这里。 非常重要的一点是，连续体中不应存在任何竞争。 它本身是此过程的最小原语。 </p><br><p>您可以将延续视为<code>Runnable</code> ，在其中可以调用<code>pause()</code>方法。 它在内部并且直接存在，因为我们的多任务协作。 然后您可以再次运行它，而不是重新计算所有内容，他将继续从他离开的地方开始。 那种魔术。 我们将回到魔术。 </p><br><p> 哪里可以继续进行演示-我们将在最后讨论。 现在让我们谈谈那里有什么。 </p><br><p> 延续类本身位于java.base中，所有链接都将在描述中。  （ <code>src/java.base/share/classes/java/lang/Continuation.java</code> ）。 但是此类非常庞大，数量庞大，因此仅查看从中进行的某种挤压是有意义的。 </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Continuation</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Continuation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContinuationScope scope, Runnable body)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yield</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContinuationScope scope)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPinned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Reason reason)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Pinned: "</span></span> + reason); } }</code> </pre> <br><p> 请注意，实际上此文件在不断变化。 例如，从前一天开始，延续未实现<code>Runnable</code>接口。 将此视为一种草图。 </p><br><p> 看一下构造函数。  <code>body</code> -这是您要运行的代码， <code>scope</code> -是一种skop，可让您在延续中嵌套延续。 </p><br><p> 因此，您可以使用<code>run</code>方法将这段代码预先安排到最后，也可以使用<code>yield</code>方法将其替换为某些特定的数组（此处需要使用该数组来将动作转发到嵌套处理程序，但我们并不关心用户）。 您可以使用<code>isDone</code>方法询问是否一切都完成了。 </p><br><p> 并且由于仅由当前实现的需求所决定的原因（但很有可能，它也将包含在发行版中），所以并非总是能够产生<code>yield</code> 。 例如，如果在延续过程中我们过渡到本机代码并且本机框架出现在堆栈上，那么就不可能卡住。 如果您在连续主体内部使用本机监视器（例如同步方法）时尝试将其挤出，也会发生这种情况。 默认情况下，当您尝试伪造此方法时，会引发一个异常...，但是基于连续性构建的光纤会重载此方法并执行其他操作。 这将稍后。 </p><br><p> 您可以大约以下方式使用它： </p><br><pre> <code class="java hljs">Continuation cont = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Continuation(SCOPE, () -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { System.out.println(<span class="hljs-string"><span class="hljs-string">"before"</span></span>); Continuation.yield(SCOPE); System.out.println(<span class="hljs-string"><span class="hljs-string">"after"</span></span>); } }); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cont.isDone()) { cont.run(); }</code> </pre> <br><p> 这是Presler演示文稿中的一个示例。 同样，这不是一个“琐碎的”代码，这是某种草图。 </p><br><p> 这是我们正在进行的延续的草图，在此延续的中间，我们被排挤了，然后在一个无休止的循环中，我们询问延续是否有效，是否应该继续。 </p><br><p> 但是总的来说，这并不意味着普通的应用程序程序员会与此API相关。 它适用于系统框架的创建者。 诸如Spring框架之类的系统形成框架将在推出后立即采用此功能。 您会看到的。 考虑这是一个预测。 如此轻松的预测，因为这里的一切都很明显。 所有用于预测的数据都是。 此功能太重要了，无法适应。 因此，无需事先担心有人会以这种形式的编码来折磨您。 好吧，如果您是Spring开发人员，那么您就知道自己在做什么。 </p><br><p> 现在，在接续的基础上，构建了光纤。 </p><br><h1 id="fibers"> 纤维类 </h1><br><p> 因此，在我们的情况下意味着光纤。 <br><br> 这是一种抽象，即： </p><br><ul><li> 轻量级线程是在JVM本身而不是在操作系统中处理的； </li><li> 创建，维护生命，切换任务的开销极低； </li><li> 可以运行数百万次。 </li></ul><br><p> 许多技术正在尝试以一种或另一种方式制造光纤。 例如，在Kotlin中，协程是在非常智能的字节码生成上实现的。  <em>非常聪明</em> 。 但是运行时是实现此类事情的更好场所。 </p><br><p>  JVM至少已经知道如何很好地处理线程，而我们所需要做的就是简化多线程的编码过程。 您可以使用异步API，但这很难被称为“简化”：即使使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Reactor</a>和Spring Project Reactor之类的工具，它允许编写看似线性的代码，如果您需要调试复杂的问题，也无济于事。 </p><br><p> 纤维。 </p><br><p> 纤维由两部分组成。 这是： </p><br><ul><li> 延续性 </li><li> 排程器 </li></ul><br><p> 那就是： </p><br><ul><li> 延续性 </li><li> 策划人 </li></ul><br><br><p><img src="https://habrastorage.org/webt/ga/wc/yk/gawcykupqgqwqjwfxcpccyltenu.jpeg"><br><br></p><br><p> 您可以决定谁在这里。 我认为这里的策划者是杰伊。 </p><br><ul><li>  Fiber连续包装要执行的代码 </li><li> 调度程序在承载线程池上启动它们 </li></ul><br><p>  <em>我将它们称为载体线。</em> </p><br><br><br><p><img src="https://habrastorage.org/webt/j4/hc/gw/j4hcgwglzzsi6qe-cxczwcewohy.jpeg"><br><br></p><br><p> 当前的原型使用<code>java.util.concurrent.Executor</code> ，而内置的调度程序<code>ForkJoinPool</code> 。 我们拥有一切。 将来，可能会出现一些更智能的东西，但现在这样。 </p><br><p> 延续如何表现： </p><br><ul><li> 当发生锁定时（例如，在IO上），它被挤出（屈服）。 </li><li> 准备好继续时继续执行（例如，IO操作已完成，您可以继续）。 </li></ul><br><p> 工作现状： </p><br><ul><li> 主要关注哲学，观念； </li><li>  API不固定，而是“用于显示”。 这是一个研究原型； </li><li>  <code>java.lang.Fiber</code>类有一个现成的编码工作原型。 </li></ul><br><p> 将进行讨论。 </p><br><p> 已经在光纤中看到了什么： </p><br><ul><li> 它运行任务启动； </li><li> 在承运人上停车的停车场； </li><li> 等待光纤完成。 </li></ul><br><h1 id="principialnaya-shema"> 电路图 </h1><br><pre> <code class="java hljs">mount(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { cont.run(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> () { unmount(); }</code> </pre> <br><ul><li> 我们可以将光纤安装在线架上。 </li><li> 然后继续运行； </li><li> 等到她被挤走或说实话停下来； </li><li> 最后，我们总是离开线程。 </li></ul><br><p> 该伪代码将在<code>ForkJoinPool</code>或其他一些<code>ForkJoinPool</code>上执行（最终将在最终版本中执行）。 </p><br><h1 id="ispolzovanie-v-realnosti"> 实际使用 </h1><br><pre> <code class="java hljs">Fiber f = Fiber.execute( () -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Good Morning!"</span></span>); readLock.lock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Good Afternoon"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { readLock.unlock(); } System.out.println(<span class="hljs-string"><span class="hljs-string">"Good Night"</span></span>); });</code> </pre> <br><p> 看，我们正在创建一种纤维，其中： </p><br><ul><li> 欢迎大家； </li><li> 我们正在阻止可重入的oke； </li><li> 回来后，恭喜你吃了午饭； </li><li> 最终释放锁； </li><li> 说再见 </li></ul><br><p> 一切都非常简单。 </p><br><p> 我们不会直接造成拥挤。  Project Loom本身知道在触发<code>readLock.lock();</code>时<code>readLock.lock();</code> 他应该干预并暗中进行镇压。 用户看不到它，但是它在那里发生。 </p><br><h1 id="steki-povsyudu-steki"> 堆，到处都是堆！ </h1><br><p> 让我们以披萨堆栈为例来说明发生了什么。 </p><br><p> 最初，载体线程处于等待状态，什么也没有发生。 </p><br><p><img src="https://habrastorage.org/webt/8y/gw/mr/8ygwmr7dc_owazfdj-wa4trrs4g.png"><br><br></p><br><p> 回想一下堆栈顶部的顶部。 </p><br><p> 然后安排执行光纤，然后光纤任务开始运行。 </p><br><p><img src="https://habrastorage.org/webt/pd/ya/mn/pdyamn0chhcnelgtphtxeg6eniq.png"><br><br></p><br><p> 在他自己内部，他显然发起了一个延续，其中已经找到了真实的代码。 </p><br><p><img src="https://habrastorage.org/webt/33/nw/fb/33nwfb3dz0klj1oiog21iegsbuy.png"><br><br></p><br><p> 从用户的角度来看，我们在这里还没有启动任何功能。 </p><br><p> 那只是用户代码的第一帧出现在堆栈上，并用紫色标记。 </p><br><p> 此外，代码被执行，执行，在某个时刻任务试图捕获锁并在其上阻塞，这导致自动挤出。 </p><br><p><img src="https://habrastorage.org/webt/vv/lk/ah/vvlkahftvyuefpupb4fyidb5gdq.png"><br><br></p><br><p> 延续堆栈上的所有内容都存储在某个神奇的地方。 并消失。 </p><br><p><img src="https://habrastorage.org/webt/hz/oq/6n/hzoq6nmzmezadhp8-ntn6_qerxk.png"><br><br></p><br><p> 如您所见，流返回到光纤，回到<code>Continuation.run</code>的指令。 这是光纤代码的结尾。 </p><br><p> 光纤任务结束，媒体载体正在等待新的作业。 </p><br><p><img src="https://habrastorage.org/webt/l4/nt/k9/l4ntk9qfl8dpcamol4ufahy8sa0.png"><br><br></p><br><p> 光纤停在某处，连续体完全被挤出。 </p><br><p> 迟早，拥有锁的人将其释放的时刻到了。 <br> 这导致这样一个事实，即正在等待释放锁的光纤已打开包装。 该光纤的任务再次开始。 </p><br><ul><li> 重新进入解锁 </li><li>  Locksupport.unpark </li><li> 光纤断开 </li><li>  ForkJoinPool.execute </li></ul><br><p> 然后我们快速返回到最近的堆栈。 </p><br><p><img src="https://habrastorage.org/webt/hz/oq/6n/hzoq6nmzmezadhp8-ntn6_qerxk.png"><br><br></p><br><p> 而且，载体线可以完全不同。 这是有道理的！ </p><br><p> 再次运行继续。 </p><br><p><img src="https://habrastorage.org/webt/ll/c-/mx/llc-mxgfttlpleiqtprwm6igcju.png"><br><br></p><br><p> 魔术来了！ 恢复堆栈，并从<code>Continuation.yield</code>之后的指令<code>Continuation.yield</code> 。 </p><br><p><img src="https://habrastorage.org/webt/la/4t/pp/la4tppjy2spiy4_auvwdikgm8nu.png"><br><br></p><br><p> 我们从刚刚停放的锁中爬出，并开始执行延续中剩余的所有代码： </p><br><p><img src="https://habrastorage.org/webt/yt/ce/ht/ytcehtff1fomwn5cehnzkegzpts.png"><br><br></p><br><p> 用户任务结束，控制在continuation.run指令之后立即返回到光纤任务 </p><br><p><img src="https://habrastorage.org/webt/sz/m8/cc/szm8ccxgwntcgjzwqcl_gcernqg.png"><br><br></p><br><p> 同时，光纤的执行结束，我们再次处于待机模式。 </p><br><p><img src="https://habrastorage.org/webt/l4/nt/k9/l4ntk9qfl8dpcamol4ufahy8sa0.png"><br><br></p><br><p> 纤维的下一次发射再次启动了上述整个重生周期。 </p><br><p><img src="https://habrastorage.org/webt/c7/z9/wm/c7z9wmktfbsithnlvyuea4mtqki.jpeg"><br><br></p><br><h1 id="zhivye-primery"> 现场例子 </h1><br><p> 谁曾说这一切可行？ 这是关于晚上写的几个微基准测试吗？ </p><br><p> 作为鞭炮操作的一个例子，奥拉克洛夫派人编写了一个小型Web服务器，并向其提供了请求，以使其窒息。 然后他们转移到纤维上。 服务器停止阻塞，由此得出结论，光纤工作正常。 </p><br><p> 我没有该服务器的确切代码，但是如果这篇文章获得足够的喜欢和评论，我将尝试自己写一个示例并构建真实的图形。 </p><br><h1 id="problemy"> 问题所在 </h1><br><p> 这里有什么问题吗？ 当然可以！ 费伯斯的整个故事是关于持续存在的问题和权衡取舍的故事。 </p><br><h2 id="filosofskie-problemy"> 哲学问题 </h2><br><ul><li> 我们需要重新发明线程吗？ </li><li>  <em>所有</em>现有代码是否<em>都应</em>在光纤内部正常工作？ </li></ul><br><p> 当前的原型运行有局限性。 可能会发布，尽管我不想这么做。 尽管如此，OpenJDK仍然尊重无限的兼容性。 </p><br><p> 有哪些技术限制？ 最明显的限制是2件。 </p><br><h2 id="problema-raz--nelzya-vytesnit-nativnye-freymy"> 问题是一次-您无法取代本机框架 </h2><br><pre> <code class="java hljs">PrivilegedAction&lt;Void&gt; pa = () -&gt; { readLock.lock(); <span class="hljs-comment"><span class="hljs-comment">// may park/yield try { // } finally { readLock.unlock(); } return null; } AccessController.doPrivileged(pa); //native method</span></span></code> </pre> <br><p> 在这里， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">doPrivileged</a>调用了本机方法。 </p><br><p> 您<code>doPrivileged</code>调用<code>doPrivileged</code> ，跳出VM，堆栈中将显示一个本机框架，然后尝试将其停放在<code>readLock.lock()</code> 。 并且在那一刻，载体线将被弄脏直到未被选中。 也就是说，线程消失了。 在这种情况下，承载线可能会终止，并且通常这会破坏整个光纤的概念。 </p><br><p> 解决该问题的方法是已知的，并且正在对此进行讨论。 </p><br><h2 id="problema-dva---synchronized-bloki"> 问题二-同步块 </h2><br><p> 这是更严重的垃圾 </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (object) { <span class="hljs-comment"><span class="hljs-comment">//may park object.wait(); //may park }</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (object) { <span class="hljs-comment"><span class="hljs-comment">//may park socket.getInputStream().read(); //may park }</span></span></code> </pre> <br><p> 如果监视器捕获在光纤中，则载体线也会踢动。 </p><br><p> 显然，在全新的代码中，您可以将监视器更改为直接锁定，而不是等待+通知，您可以使用条件对象，但是该如何处理旧式？ 这是一个问题。 </p><br><h1 id="thread-api-threadcurrentthread-thread-locals"> 线程API？  Thread.currentThread（）？ 线程本地人？ </h1><br><p> 在当前的原型中， <code>Thread</code>和<code>Fiber</code>了一个通用的超类<code>Strand</code> 。 </p><br><p> 这使您能够以最小的方式传输API。 <br> 下一步要做什么-与该项目一样，这是一个问题。 </p><br><p> 现在线程API发生了什么？ </p><br><ul><li> 光纤中首次使用<code>Thread.currentThread()</code>会创建一种影子线程，即Shadow Thread； </li><li> 从系统的角度来看，这是一个“未发布”的线程，并且其中没有VM元信息。 </li><li>  ST试图效仿所有可能的方法。 </li><li> 但是您必须了解旧的API有很多垃圾； </li><li> 更具体地说，Shadow Thread对<code>stop</code> ， <code>suspend</code> ， <code>resume</code>和未捕获的异常以外的所有事物都实现了Thread API。 </li></ul><br><p> 线程本地变量怎么办？ </p><br><ul><li> 现在线程本地变量变成了光纤本地变量； </li><li> 这有很多问题，所有这些都在讨论中； </li><li> 特别讨论了一组用途； </li><li> 线程在历史上既正确又错误地使用（错误使用线程的人仍然希望得到某些东西，而您不能完全让他们失望）； </li><li> 通常，这会创建整个应用程序： <br><ul><li> 高级：容器中的连接或密码缓存； </li><li> 低级：系统库中的处理器。 </li></ul></li></ul><br><h1 id="skolko-vse-eto-zhret"> 吃多少 </h1><br><p><img src="https://habrastorage.org/webt/pl/7-/pi/pl7-pidz-d2o3l98qx2srbmezxi.png"><br><br></p><br><p> 线程： </p><br><ul><li> 堆栈：内核数据结构上的1MB和16KB； </li><li> 每个线程实例：2300字节，包括VM元信息。 </li></ul><br><p> 纤维： </p><br><ul><li> 连续堆栈：从数百字节到千字节； </li><li> 每个光纤实例：200-240字节。 </li></ul><br><p> 差别很大！ <br> 这正是让数百万人解雇的原因。 </p><br><h1 id="chto-mozhet-parkovatsya"> 什么可以停车 </h1><br><p> 显然，最神奇的事情是发生某些事件时自动停车。 目前支持什么？ </p><br><ul><li>  Thread.sleep，加入； </li><li>  java.util.concurrent和LockSupport.lock; </li><li>  IO：套接字上的网络（套接字读取，写入，连接，接受），文件，管道； </li><li> 所有这些都还没有完成，但是隧道中的光是可见的。 </li></ul><br><h1 id="kommunikaciya-mezhdu-fayberami"> 光纤之间的通讯 </h1><br><p> 每个人都问的另一个问题是：如何在光纤之间竞争性地交换信息。 </p><br><ul><li> 当前的原型在<code>Runnable</code>启动任务，如果出于某些原因，可以将其转换为<code>CompletableFuture</code> ； </li><li>  java.util.concurrent“有效”。 您可以以标准方式混淆所有内容； </li><li> 可能有用于多线程的新API，但这并不准确； </li><li> 一堆小问题，例如“纤维应该返回值吗？”； 一切都在讨论中，它们不在原型中。 </li></ul><br><h1 id="kak-realizovany-kontinuacii-v-prototipe"> 原型中的延续如何实现？ </h1><br><p> 延续上有明显的要求：您需要使用尽可能少的RAM，并且需要尽快在它们之间切换。 否则，将其保留在数百万中将是行不通的。 这里的主要任务是以某种方式不为每个停车位做完整的堆栈副本。 而且有这样的计划！ 让我们尝试在图片中对此进行解释。 </p><br><p> 当然，最酷的方法是将所有堆栈放在Java臀部上并直接使用它们。 但是目前尚不清楚如何编码，因此原型使用复制。 但是，复制时会有一个很小但很重要的hack。 </p><br><p> 我们有两把椅子……我是说，有两叠。 臀部有两个java数组。 一个是对象数组，我们将在其中存储对对象的引用。 第二个是原始的（例如，亲密的），它将处理其他所有内容。 </p><br><p><img src="https://habrastorage.org/webt/33/tf/cj/33tfcj897awloqfisxfwwl-4ypy.png"><br><br></p><br><p> 现在，我们处于第一次将要执行连续的状态。 </p><br><p>  <code>run</code>调用一个称为<code>enter</code>的内部方法： </p><br><p><img src="https://habrastorage.org/webt/j6/d5/ki/j6d5kioz8ygupanxditl3iaslbi.png"><br><br></p><br><p> 然后执行用户代码，直到第一个挤出为止。 </p><br><p><img src="https://habrastorage.org/webt/ab/on/6c/abon6cdsoepe-ts69pkmm9sk35i.png"><br><br></p><br><p> 此时，将进行VM调用，该调用将<code>freeze</code> 。 在此原型中，这是直接在物理上完成的-使用复制。 </p><br><p><img src="https://habrastorage.org/webt/iu/or/jv/iuorjvmb6xrjnycvx3nxbdcqxxc.png"><br><br></p><br><p> 我们开始将帧从本地堆栈顺序复制到java hip的过程。 </p><br><p><img src="https://habrastorage.org/webt/ln/nu/sm/lnnusmrix2hsqpwxmzkeemd_or0.png"><br><br></p><br><p> 有必要检查监视器是否存放在此处或是否使用了本机代码，或者是否确实不允许我们继续工作。 </p><br><p><img src="https://habrastorage.org/webt/vl/5c/k0/vl5ck0i3jtouapded9snnl9brvy.png"><br><br></p><br><p> 如果一切顺利，我们首先将其复制到原始数组中： </p><br><p><img src="https://habrastorage.org/webt/ka/z_/gl/kaz_glkmthfyd1x8rzdprn3v8ym.png"><br><br></p><br><p> 然后我们隔离对对象的引用，并将其保存在对象数组中： </p><br><p><img src="https://habrastorage.org/webt/xc/2q/nb/xc2qnbafy_2eybwzif-3s3vmaym.png"><br><br></p><br><p> 其实，给读过这个地方的每个人都喝两杯茶！ </p><br><p> 此外，我们对本机堆栈的所有其他元素继续此过程。 </p><br><p><img src="https://habrastorage.org/webt/6e/sp/-0/6esp-07i4dyasxj5esb9qu6fh5i.png"><br><br></p><br><p> 万岁！ 我们将所有内容复制到臀部的巢穴中。 您可以安全地跳到通话地点，而不必担心我们丢失了一些东西。 一切都是时髦的。 </p><br><p><img src="https://habrastorage.org/webt/bq/sz/ju/bqszjuffw-s4f14audafvzbmqzc.png"><br><br></p><br><p> 现在，迟早，调用代码将再次调用我们的延续。 她必须从上次离开的地方继续。 这是我们的任务。 </p><br><p><img src="https://habrastorage.org/webt/8i/bg/x9/8ibgx9r_26wedxrahar1vfqdifi.png"><br><br></p><br><p> 检查延续是否正在运行，是的，它正在运行。 因此，您需要调用VM，清理堆栈上的一些空间，然后调用内部的VM函数。  “解冻”被翻译成俄文“解冻”，“解冻”，听起来很合逻辑。 有必要将帧从连续堆栈中解冻到我们的主要本机堆栈中。 </p><br><p> 我不确定解冻的茶是否很清楚。 错误的抽象就像带门的小猫。 但这将为我们做。 </p><br><p><img src="https://habrastorage.org/webt/ra/sv/5v/rasv5v_5w8_dpegomn_omgtdiza.png"><br><br></p><br><p> 我们制作了很明显的副本。 </p><br><p> 首先使用原始数组： </p><br><p><img src="https://habrastorage.org/webt/wc/he/vg/wchevg-fsflrnicy0itprkp0q2e.png"><br><br></p><br><p> 然后从链接： </p><br><p><img src="https://habrastorage.org/webt/o_/o2/6s/o_o26sakm0n5hyq9wisbo7vouge.png"><br><br></p><br><p> 您需要修补复制的内容以获得正确的堆栈： </p><br><p><img src="https://habrastorage.org/webt/sm/h7/0n/smh70naepp3kshxaa78zxv1g2du.png"><br><br></p><br><p> 对所有帧重复淫秽： </p><br><p><img src="https://habrastorage.org/webt/cg/dv/61/cgdv617uqeriqmuqcyc2jkjpnbe.png"><br><br></p><br><p> 现在，您可以返回<code>yield</code>并继续进行，就好像什么都没发生一样。 </p><br><p><img src="https://habrastorage.org/webt/gn/dd/xw/gnddxwqqsrwuidc9ev2nxwmiwqc.png"><br><br></p><br><p> 问题在于堆栈的完整副本根本不是我们想要的。 这是非常抑制性的。 所有这一切都是隔离链接，检查是否固定，这不是很快。 最重要的是-所有这些线性地取决于堆栈的大小！ 总之，地狱。 不需要这样做。 </p><br><p> 相反，我们有另一个想法-懒惰复制。 </p><br><p> 让我们回滚到已经冻结的地方。 </p><br><p><img src="https://habrastorage.org/webt/5b/hw/tg/5bhwtgg8cfg-agcwu_kdtrqlify.png"><br><br></p><br><p> 我们像以前一样继续该过程： </p><br><p><img src="https://habrastorage.org/webt/rj/ac/f9/rjacf9tmfekskko8jwojuocxixm.png"><br><br></p><br><p> 与以前一样，我们清理本地堆栈上的位置： </p><br><p><img src="https://habrastorage.org/webt/nm/ol/ow/nmolowac-dkmdefuobd-kaijyeq.png"><br><br></p><br><p> 但是，我们并不是连续复制所有内容，而是仅复制一个或几个框架： </p><br><p><img src="https://habrastorage.org/webt/3a/ca/1x/3aca1xglgfbq8yzwxkjypelxpqy.png"><br><br></p><br><p> 现在的黑客。 您需要修补方法<code>C</code>的返回地址，以便它指向某个返回屏障： </p><br><p><img src="https://habrastorage.org/webt/zs/si/3z/zssi3zgaadvvsrg883agxsmq3pc.png"><br><br></p><br><p> 现在您可以放心地返回<code>yield</code> ： </p><br><p><img src="https://habrastorage.org/webt/e1/f_/2s/e1f_2snf4bh-ggjcv5lrgabqkwk.png"><br><br></p><br><p> 反过来，这将导致调用<code>C</code>方法中的用户代码： </p><br><p><img src="https://habrastorage.org/webt/y2/nl/rm/y2nlrmn9lczwhcaa3f41ii69nq0.png"><br><br></p><br><p> 现在想象一下， <code>C</code>想要返回调用它的代码。 但是他的召唤者是<code>B</code> ，他不在筹码中！ 因此，当他尝试返回时，将转到返回地址，该地址现在是返回屏障。 而且，您知道，这将再次引起<code>thaw</code> ： </p><br><p><img src="https://habrastorage.org/webt/hb/6g/8d/hb6g8dfw35ujqntvi-y7lzyskis.png"><br><br></p><br><p>  <code>thaw</code>后将解冻连续堆栈上的下一帧，这是<code>B</code> ： </p><br><p><img src="https://habrastorage.org/webt/cp/mp/ao/cpmpao3_arvnvgykenc9r4fgwsk.png"><br><br></p><br><p> 实际上，我们根据要求懒惰地复制了它。 </p><br><p> 接下来，我们从连续堆栈中删除<code>B</code>并再次设置障碍（需要设置障碍，因为在连续堆栈上还剩下一些东西）。 依此类推。 </p><br><p><img src="https://habrastorage.org/webt/gv/yo/0u/gvyo0u4iwzunuqovy1yv_-jbutq.png"><br><br></p><br><p> 但是，假设<code>B</code>不会返回到调用代码，而是首先调用其他方法<code>D</code> 而且这种新方法也希望被挤出。 </p><br><p><img src="https://habrastorage.org/webt/f9/1i/t9/f91it9xn705zsxuzvvbqh5gdoqi.png"><br><br></p><br><p> 在这种情况下，当需要进行<code>freeze</code> ，我们将仅需要将本机堆栈的顶部复制到延续堆栈中： </p><br><p><img src="https://habrastorage.org/webt/pt/8b/ul/pt8buljt77lsp-wj-rswobc4v_y.png"><br><br></p><br><p> 因此，完成的工作量并不线性地取决于堆叠的大小。 它线性地取决于我们在工作中实际使用的帧数。 </p><br><h1 id="chto-ostalos"> 还剩下什么？ </h1><br><p> 开发人员牢记某些功能，但并未进入原型。 </p><br><ul><li> 序列化和克隆。 在另一台计算机上，在其他时间等继续运行的能力 </li><li>  JVM TI和调试，就好像它们是常规线程一样。 如果您在读取套接字时受阻，那么您将不会从yield处看到漂亮的跳跃，在原型中，该线程将像其他任何普通线程一样被阻塞。 </li><li> 甚至没有碰到尾递归。 </li></ul><br><p> 后续步骤： </p><br><ul><li> 编写人工API； </li><li> 添加所有缺少的功能； </li><li> 提高性能。 </li></ul><br><h1 id="gde-vzyat"> 去哪儿 </h1><br><p> 原型在OpenJDK存储库中作为早午餐制作。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您可以</a>通过切换到早午餐<code>fibers</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处下载原型</a> 。 </p><br><p> 这样做是这样的： </p><br><pre> <code class="bash hljs">$ hg <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> http://hg.openjdk.java.net/loom/loom $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> loom $ hg update -r fibers $ sh configure $ make images</code> </pre> <br><p>   ,       OpenJDK. , -,       - ,    . </p><br><p><img src="https://habrastorage.org/webt/gk/qz/3-/gkqz3-f8gmkcwkynnnrp4opp1rg.png"><br><br></p><br><p> -,       C++   GNU .  ,        Windows. ,    VirtualBox    Ubuntu       ,          Cygwin  msys64.   ,  msys   ,  Cygwin. </p><br><p>  , ,  ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a> . </p><br><p>   -   ,   mercurial extension   fsmonitor. ,   ,   <code>hg help -e fsmonitor</code> . <br>      ~/.hgrc  : </p><br><pre> <code class="plaintext hljs">[fsmonitor] mode = on</code> </pre> <br><p>  -           .             -, <code>cp -R ./loom ./loom-backup</code> . </p><br><p>  ,          . ,   Java-    ,       . </p><br><p> <code>sh configure</code>    - . ,     Ubuntu,     Autoconf ( <code>sudo apt-get install autoconf</code> ).  —     OpenJDK   Ubuntu,     ,  .  Windows      ,   . </p><br><p> ,     ,   <code>hg diff --stat -r default:fibers</code> . </p><br><p>  ,          ,   ,     . </p><br><h1 id="zaklyuchenie"> 结论 </h1><br><p>      «, ».   «», . «Loom» —  « ».  Project Loom         . </p><br><p>          ,        . ,      «»  ,  ,      —  , ,  , —  . </p><br><p> ,   ,          XIX    ,        . </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/305/64e/143/30564e14316852dd18d4235b3850e134.jpg"><br><p>      . -,  . </p><br><p> ,                 .        IDE   . </p><br><p>          ,       ,   ,    « », «», « »   . </p><br><p>       ?   .   . </p><br><p> 谢谢啦 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN422519/">https://habr.com/ru/post/zh-CN422519/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN422509/index.html">《从不单独吃饭》一书的摘要</a></li>
<li><a href="../zh-CN422511/index.html">将数据加载到Splunk：通用转发器与重型转发器。 有什么区别？</a></li>
<li><a href="../zh-CN422513/index.html">关于如何在假期不激怒测试人员同事的7个技巧</a></li>
<li><a href="../zh-CN422515/index.html">9月的两个Apache Ignite mitap和内存计算网络研讨会</a></li>
<li><a href="../zh-CN422517/index.html">Wolfram云中的TelegramBot</a></li>
<li><a href="../zh-CN422521/index.html">不可避免的预感</a></li>
<li><a href="../zh-CN422525/index.html">“友谊的矩阵。” 年龄最小的社交图谱最早</a></li>
<li><a href="../zh-CN422527/index.html">PostgreSQL新闻摘要。 第10期</a></li>
<li><a href="../zh-CN422529/index.html">IB组特别课程：“移动应用程序安全性”</a></li>
<li><a href="../zh-CN422531/index.html">网站优化：最重要</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>