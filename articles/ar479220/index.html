<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🚒 👩🏽‍🤝‍👨🏿 🍠 Nano-neuron - 7 وظائف جافا سكريبت بسيطة توضح كيف يمكن للآلة "التعلم" 💘 🏂🏽 🚣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="النانو العصبية هي نسخة مبسطة من الخلايا العصبية من مفهوم الشبكة العصبية. يقوم Nano-neuron بأبسط مهمة ويتم تدريبه على تحويل درجة الحرارة من درجة مئوية ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nano-neuron - 7 وظائف جافا سكريبت بسيطة توضح كيف يمكن للآلة "التعلم"</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479220/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  <a href="https://github.com/trekhleb/nano-neuron" rel="nofollow"><strong>النانو العصبية</strong></a> هي نسخة <em>مبسطة</em> من الخلايا العصبية من مفهوم الشبكة العصبية.  يقوم Nano-neuron بأبسط مهمة ويتم تدريبه على تحويل درجة الحرارة من درجة مئوية إلى درجة فهرنهايت. </p><br><p style=";text-align:right;direction:rtl">  يتكون كود <a href="" rel="nofollow"><strong>NanoNeuron.js</strong></a> من 7 وظائف جافا سكريبت بسيطة تتضمن التعلم والتدريب والتنبؤ والإشارة المباشرة والخلفية لإشارة النموذج.  كان الغرض من كتابة هذه الوظائف هو إعطاء القارئ شرحًا بسيطًا (حدسيًا) بسيطًا عن كيفية "تعلم" الآلة بعد كل شيء.  لا يستخدم الكود مكتبات الطرف الثالث.  كما يقول المثل ، وظائف جافا سكريبت "الفانيليا" بسيطة فقط. </p><br><p style=";text-align:right;direction:rtl">  هذه الوظائف ليست <strong>بأي حال</strong> دليلاً شاملاً للتعلم الآلي.  العديد من مفاهيم التعلم الآلي مفقودة أو مبسطة!  يُسمح بهذا التبسيط للغرض الوحيد - لإعطاء القارئ الفهم والحدس الأكثر <strong>أساسية</strong> حول كيفية "تعلُّم" الآلة من حيث المبدأ ، ونتيجة لذلك ، يبدو "MAGIC of machine machine" أكثر فأكثر للقارئ كـ "MATHEMATICS من تعلم الآلة". </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/98d/6c4/69e/98d6c469e1facbf97154fe29f698cd12.png" alt="NanoNeuron"></p><a name="habracut"></a><br><h2 id="chto-vyuchit-nash-nano-neyron" style=";text-align:right;direction:rtl">  ما سوف نتعلمه من الخلايا العصبية النانوية لدينا </h2><br><p style=";text-align:right;direction:rtl">  قد تكون سمعت عن الخلايا العصبية في سياق <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D1%2581%25D0%25BA%25D1%2583%25D1%2581%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BD%25D0%25B5%25D0%25B9%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B5%25D1%2582%25D1%258C" rel="nofollow">الشبكات العصبية</a> .  النانو العصبية هي نسخة مبسطة من تلك الخلايا العصبية ذاتها.  في هذا المثال ، سنكتب تنفيذه من البداية.  للبساطة ، لن نقوم ببناء شبكة من الخلايا العصبية النانوية.  سوف نركز على إنشاء واحد من الخلايا العصبية النانوية ونحاول تعليمه كيفية تحويل درجة الحرارة من درجات مئوية إلى فهرنهايت.  بمعنى آخر ، سوف نعلمه أن <strong>يتنبأ</strong> بدرجة الحرارة في درجة فهرنهايت بناءً على درجة الحرارة بالدرجات المئوية. </p><br><p style=";text-align:right;direction:rtl">  بالمناسبة ، صيغة تحويل الدرجات المئوية إلى درجة فهرنهايت هي كما يلي: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/9fa/2e8/8b5/9fa2e88b5a7324c8b9fc359b274ba091.png" alt="مئوية إلى فهرنهايت"></p><br><p style=";text-align:right;direction:rtl">  ولكن في الوقت الحالي ، لا تعرف الخلايا العصبية النانوية لدينا أي شيء عن هذه الصيغة ... </p><br><h3 id="model-nano-neyrona" style=";text-align:right;direction:rtl">  نموذج النانو العصبية </h3><br><p style=";text-align:right;direction:rtl"> لنبدأ بإنشاء وظيفة تصف نموذج العصبونات النانوية.  هذا النموذج هو علاقة خطية بسيطة بين <code>x</code> و <code>y</code> ، والتي تبدو كما يلي: <code>y = w * x + b</code> .  ببساطة ، لدينا nano-neuron هو طفل يمكنه رسم خط مستقيم في نظام الإحداثيات <code>XY</code> . </p><br><p style=";text-align:right;direction:rtl">  المتغيرات <code>w</code> و <code>b</code> هي <strong>معلمات</strong> طراز.  يعرف النانو العصبي هاتين المعلمتين لوظيفة خطية فقط.  هذه المعلمات هي بالضبط ما سوف نتعلمه من الخلايا العصبية النانوية لدينا خلال عملية التدريب. </p><br><p style=";text-align:right;direction:rtl">  الشيء الوحيد الذي تستطيع الخلايا العصبية النانوية فعله في هذه المرحلة هو محاكاة العلاقات الخطية.  يقوم بذلك في طريقة <code>predict()</code> ، والذي يأخذ متغير <code>x</code> عند الإدخال ويتوقع المتغير <code>y</code> في الإخراج.  لا السحر. </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NanoNeuron</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.w = w; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = b; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.predict = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.w + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b; } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  _ (... انتظر ... <a href="https://en.wikipedia.org/wiki/Linear_regression" rel="nofollow">الانحدار الخطي</a> هو أنت ، أم ماذا؟) _ </p><br><h3 id="konvertaciya-gradusov-celsiya-v-gradusy-farengeyta" style=";text-align:right;direction:rtl">  تحويل درجة مئوية إلى درجة فهرنهايت </h3><br><p style=";text-align:right;direction:rtl">  يمكن تحويل درجة الحرارة بالدرجات المئوية إلى فهرنهايت وفقًا للصيغة: <code>f = 1.8 * c + 32</code> ، حيث <code>c</code> هي درجة الحرارة بالدرجات Celsius و <code>f</code> هي درجة الحرارة بالدرجات فهرنهايت. </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">celsiusToFahrenheit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> w = <span class="hljs-number"><span class="hljs-number">1.8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = c * w + b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f; };</code> </pre> <br><p style=";text-align:right;direction:rtl">  نتيجة لذلك ، نريد أن يكون لدينا خلية عصبية نانو قادرة على محاكاة هذه الوظيفة بالذات.  سيتعين عليه تخمين (معرفة) أن المعلمة <code>w = 1.8</code> و <code>b = 32</code> دون معرفة ذلك مقدمًا. </p><br><p style=";text-align:right;direction:rtl">  هذه هي الطريقة التي تبدو بها وظيفة التحويل على الرسم البياني.  هذا ما يجب أن يتعلمه "الطفل" النانوي العصبي لدينا "لرسم": </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/68b/0d6/8bc/68b0d68bcc7be00ec9526867b2fcecf3.png" alt="مئوية إلى فهرنهايت التحويل"></p><br><h3 id="generirovanie-dannyh" style=";text-align:right;direction:rtl">  توليد البيانات </h3><br><p style=";text-align:right;direction:rtl">  في البرمجة الكلاسيكية ، نعرف بيانات الإدخال ( <code>x</code> ) والخوارزمية لتحويل هذه البيانات (المعلمتان <code>w</code> و <code>b</code> ) ، لكن بيانات الإخراج ( <code>y</code> ) غير معروفة.  يتم حساب الناتج بناءً على المدخلات باستخدام خوارزمية معروفة.  على العكس من ذلك ، في التعلم الآلي ، فقط بيانات المدخلات والمخرجات ( <code>x</code> و <code>y</code> ) معروفة ، لكن خوارزمية التبديل من <code>x</code> إلى <code>y</code> معروفة (المعلمتان <code>w</code> و <code>b</code> ). </p><br><p style=";text-align:right;direction:rtl">  إنه توليد المدخلات والمخرجات التي سنفعلها الآن.  نحن بحاجة إلى توليد بيانات <strong>لتدريب</strong> نموذجنا وبياناتنا <strong>لاختبار</strong> النموذج.  سوف تساعدنا وظيفة المساعد <code>celsiusToFahrenheit()</code> هذا.  كل مجموعة من مجموعات بيانات التدريب والاختبار هي مجموعة من الأزواج <code>x</code> و <code>y</code> .  على سبيل المثال ، إذا كانت <code>x = 2</code> ، ثم <code>y = 35,6</code> وهكذا. </p><br><blockquote style=";text-align:right;direction:rtl">  في العالم الواقعي ، من المرجح أن يتم <em>جمع</em> معظم البيانات ، وليس <em>توليدها</em> .  على سبيل المثال ، قد تكون هذه البيانات التي تم جمعها عبارة عن مجموعة من أزواج من "صور الوجه" -&gt; "اسم الشخص". </blockquote><p style=";text-align:right;direction:rtl">  سنستخدم مجموعة بيانات التدريب لتدريب الخلايا العصبية النانوية لدينا.  قبل أن يكبر وهو قادر على اتخاذ القرارات من تلقاء نفسه ، يجب علينا أن نعلمه ما هو "صحيح" وما هو "خطأ" باستخدام البيانات "الصحيحة" من مجموعة التدريب. </p><br><blockquote style=";text-align:right;direction:rtl">  بالمناسبة ، هنا يتم تتبع مبدأ الحياة "القمامة عند المدخل - القمامة عند الخروج" بشكل واضح.  إذا قام أحد الخلايا العصبية النانوية بإلقاء "كذبة" في مجموعة التدريب التي يتم تحويلها إلى 5 درجات مئوية إلى 1000 درجة فهرنهايت ، فبعد العديد من التكرار في التدريب ، سوف يصدق ذلك وسيحول جميع قيم درجة الحرارة بشكل صحيح <strong>باستثناء</strong> 5 درجات مئوية.  نحن بحاجة إلى توخي الحذر الشديد مع بيانات التدريب التي نقوم بتحميلها كل يوم في شبكة الدماغ العصبية لدينا. </blockquote><p style=";text-align:right;direction:rtl">  استطرادا.  دعنا نستمر. </p><br><p style=";text-align:right;direction:rtl">  سوف نستخدم مجموعة بيانات TEST لتقييم مدى جودة تدريب الخلايا العصبية النانوية لدينا ، ويمكننا التنبؤ بالبيانات الصحيحة التي لم يراها أثناء تدريبه. </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateDataSets</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// xTrain -&gt; [0, 1, 2, ...], // yTrain -&gt; [32, 33.8, 35.6, ...] const xTrain = []; const yTrain = []; for (let x = 0; x &lt; 100; x += 1) { const y = celsiusToFahrenheit(x); xTrain.push(x); yTrain.push(y); } // xTest -&gt; [0.5, 1.5, 2.5, ...] // yTest -&gt; [32.9, 34.7, 36.5, ...] const xTest = []; const yTest = []; //   0.5    1,       //   ,       . for (let x = 0.5; x &lt; 100; x += 1) { const y = celsiusToFahrenheit(x); xTest.push(x); yTest.push(y); } return [xTrain, yTrain, xTest, yTest]; }</span></span></code> </pre> <br><h3 id="ocenka-pogreshnosti-predskazaniy" style=";text-align:right;direction:rtl">  تقدير خطأ التنبؤ </h3><br><p style=";text-align:right;direction:rtl">  نحتاج إلى قياس معين (القياس ، العدد ، التقييم) الذي سيوضح مدى قرب التنبؤ بالخلية العصبية النانوية.  بمعنى آخر ، يجب أن يوضح هذا الرقم / المتري / الوظيفة مدى صواب أو خطأ الخلايا العصبية النانوية.  يشبه في المدرسة ، يمكن للطالب الحصول على درجة <code>5</code> أو <code>2</code> للسيطرة عليه. </p><br><p style=";text-align:right;direction:rtl">  في حالة الخلايا العصبية النانوية ، سيتم إنتاج الخطأ (الخطأ) بين القيمة الحقيقية للقيمة <code>y</code> والقيمة المتوقعة <code>prediction</code> من خلال الصيغة: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/8d8/e50/ac1/8d8e50ac12d03614e65975f7b5d36931.png" alt="تكلفة التنبؤ"></p><br><p style=";text-align:right;direction:rtl">  كما يتبين من الصيغة ، سننظر في الخطأ على أنه اختلاف بسيط بين القيمتين.  كلما كانت القيم أقرب إلى بعضها البعض ، كلما كان الاختلاف أصغر.  نستخدم التربيع هنا للتخلص من العلامة ، بحيث في النهاية <code>(1 - 2) ^ 2</code> تعادل <code>(2 - 1) ^ 2</code> .  يحدث القسمة على <code>2</code> فقط من أجل تبسيط معنى مشتق هذه الوظيفة في صيغة الانتشار الخلفي للإشارة (المزيد حول هذا أدناه). </p><br><p style=";text-align:right;direction:rtl">  ستبدو وظيفة الخطأ في هذه الحالة كما يلي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predictionCost</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y, prediction</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (y - prediction) ** <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ie -&gt; 235.6 }</span></span></code> </pre> <br><h3 id="pryamoe-rasprostranenie-signala" style=";text-align:right;direction:rtl">  انتشار إشارة مباشرة </h3><br><p style=";text-align:right;direction:rtl">  يعني انتشار الإشارة المباشرة من خلال نموذجنا عمل تنبؤات لجميع الأزواج من مجموعة بيانات التدريب <code>yTrain</code> و <code>yTrain</code> وحساب متوسط ​​الخطأ (خطأ) من هذه التنبؤات. </p><br><p style=";text-align:right;direction:rtl">  نحن فقط نسمح للخلايا العصبية النانوية "بالتحدث" ، مما يسمح لها بعمل تنبؤات (تحويل درجة الحرارة).  في الوقت نفسه ، قد يكون وجود خلية عصبية نانوية في هذه المرحلة خاطئًا جدًا.  سيُظهر لنا متوسط ​​قيمة خطأ التنبؤ مدى قرب نموذجنا من الحقيقة في الوقت الحالي.  تعد قيمة الخطأ مهمة للغاية هنا ، حيث أنه من خلال تغيير المعلمتين <code>w</code> و <code>b</code> وانتشار الإشارة المباشرة مرة أخرى ، يمكننا تقييم ما إذا كانت الخلايا العصبية النانوية لدينا أصبحت "أكثر ذكاء" بمعلمات جديدة أم لا. </p><br><p style=";text-align:right;direction:rtl">  سيتم تنفيذ متوسط ​​خطأ التنبؤ بخلية nano-neuron باستخدام الصيغة التالية: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/575/db3/e0a/575db3e0a0c872b29582147e41231344.png" alt="متوسط ​​التكلفة"></p><br><p style=";text-align:right;direction:rtl">  حيث <code>m</code> هو عدد نسخ التدريب (في حالتنا ، لدينا <code>100</code> زوج من البيانات). </p><br><p style=";text-align:right;direction:rtl">  إليك كيفية تنفيذ ذلك في الكود: </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forwardPropagation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">model, xTrain, yTrain</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m = xTrain.length; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> predictions = []; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cost = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prediction = nanoNeuron.predict(xTrain[i]); cost += predictionCost(yTrain[i], prediction); predictions.push(prediction); } <span class="hljs-comment"><span class="hljs-comment">//     . cost /= m; return [predictions, cost]; }</span></span></code> </pre> <br><h3 id="obratnoe-rasprostranenie-signala" style=";text-align:right;direction:rtl">  انتشار إشارة عكس </h3><br><p style=";text-align:right;direction:rtl">  الآن وقد عرفنا مدى صحة أو عدم صحة الخلايا العصبية النانوية في تنبؤاتها (استنادًا إلى متوسط ​​قيمة الخطأ) ، كيف يمكننا أن نجعل التنبؤات أكثر دقة؟ </p><br><p style=";text-align:right;direction:rtl">  انتشار إشارة عكس سوف تساعدنا في هذا.  انتشار عودة الإشارة هو عملية تقييم خطأ الخلايا العصبية النانوية ومن ثم ضبط المعلمات <code>w</code> و <code>b</code> بحيث تصبح التنبؤات التالية للخلية العصبية النانوية لمجموعة البيانات التدريبية بأكملها أكثر دقة قليلاً. </p><br><p style=";text-align:right;direction:rtl">  هذا هو المكان الذي يصبح فيه التعلم الآلي مثل السحر.  المفهوم الرئيسي هنا هو <strong>مشتق من الوظيفة</strong> ، والذي يوضح حجم الخطوة وأي طريقة نحتاج إلى اتخاذها من أجل الاقتراب من الحد الأدنى من الوظيفة (في حالتنا ، الحد الأدنى من وظيفة الخطأ). </p><br><p style=";text-align:right;direction:rtl">  الهدف النهائي من تدريب الخلايا العصبية النانوية هو إيجاد الحد الأدنى من وظيفة الخطأ (انظر الوظيفة أعلاه).  إذا نجحنا في العثور على قيم <code>w</code> و <code>b</code> التي يكون متوسط ​​قيمة وظيفة الخطأ فيها صغيرًا ، فإن هذا يعني أن الخلايا العصبية النانوية لدينا تتكيف بشكل جيد مع تنبؤات درجة الحرارة بالدرجات فهرنهايت. </p><br><p style=";text-align:right;direction:rtl">  المشتقات هي موضوع كبير ومنفصل لن نغطيه في هذه المقالة.  <a href="https://www.mathsisfun.com/calculus/derivatives-introduction.html" rel="nofollow">MathIsFun</a> هو مورد رائع يمكنه توفير فهم أساسي للمشتقات. </p><br><p style=";text-align:right;direction:rtl">  الشيء الوحيد الذي يجب أن نتعلمه من جوهر المشتق والذي سيساعدنا على فهم كيفية عمل الإبطال الخلفي للإشارة هو أن مشتق دالة في نقطة معينة <code>x</code> و <code>y</code> ، بحكم التعريف ، هو خط المماس إلى منحنى هذه الوظيفة في <code>x</code> و <code>y</code> <em>ويشير لنا الاتجاه إلى الحد الأدنى من وظيفة</em> . </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/66d/bfd/49a/66dbfd49aaf1ced48d7f6b5917fddb12.svg" alt="منحدر مشتق"></p><br><p style=";text-align:right;direction:rtl">  <em>الصورة مأخوذة من <a href="https://www.mathsisfun.com/calculus/derivatives-introduction.html" rel="nofollow">MathIsFun</a></em> </p><br><p style=";text-align:right;direction:rtl">  على سبيل المثال ، في الرسم البياني أعلاه ، ترى أنه عند النقطة <code>(x=2, y=4)</code> ميل المنحدر أننا نحتاج إلى التحرك <code></code> <code></code> للوصول إلى الحد الأدنى من الوظيفة.  لاحظ أيضًا أنه كلما زاد ميل الظل ، يجب أن نتحرك بشكل أسرع إلى الحد الأدنى. </p><br><p style=";text-align:right;direction:rtl">  المشتقات من متوسط ​​الخطأ لدينا دالة <code>averageCost</code> المعلمات <code>w</code> و <code>b</code> ستبدو كما يلي: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/4cc/bda/ba1/4ccbdaba120c399c1528e2bc38cf0efd.png" alt="DW"></p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/e02/0cb/125/e020cb125449849009a9f565a32ff46f.png" alt="ديسيبل"></p><br><p style=";text-align:right;direction:rtl">  حيث <code>m</code> هو عدد نسخ التدريب (في حالتنا ، لدينا <code>100</code> زوج من البيانات). </p><br><p style=";text-align:right;direction:rtl">  <em>يمكنك قراءة المزيد من التفاصيل حول كيفية أخذ مشتق من الوظائف المعقدة <a href="https://www.mathsisfun.com/calculus/derivatives-rules.html" rel="nofollow">هنا</a> .</em> </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">backwardPropagation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">predictions, xTrain, yTrain</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m = xTrain.length; <span class="hljs-comment"><span class="hljs-comment">//           'w'  'b'. //      0. let dW = 0; let dB = 0; for (let i = 0; i &lt; m; i += 1) { dW += (yTrain[i] - predictions[i]) * xTrain[i]; dB += yTrain[i] - predictions[i]; } //    . dW /= m; dB /= m; return [dW, dB]; }</span></span></code> </pre> <br><h3 id="trenirovka-modeli" style=";text-align:right;direction:rtl">  التدريب النموذجي </h3><br><p style=";text-align:right;direction:rtl">  نحن الآن نعرف كيفية تقدير الخطأ / الخطأ في تنبؤات نموذجنا العصبي النانوي لجميع بيانات التدريب (انتشار الإشارات المباشرة).  نحن نعرف أيضًا كيفية ضبط المعلمات <code>w</code> و <code>b</code> لنموذج العصب النانوي (الانتشار الخلفي للإشارة) لتحسين دقة التنبؤات.  تكمن المشكلة في أننا إذا قمنا بالانتشار الأمامي والخلفي للإشارة مرة واحدة فقط ، فلن يكون هذا كافياً لنموذجنا لتحديد ومعرفة التبعيات والقوانين في بيانات التدريب.  يمكنك مقارنة ذلك بالزيارة المدرسية للطالب ليوم واحد.  يجب عليه الذهاب إلى المدرسة بانتظام ، يومًا بعد يوم ، سنة بعد سنة ، حتى يتعلم كل المواد. </p><br><p style=";text-align:right;direction:rtl">  لذلك ، يجب أن <em>نكرر</em> انتشار الأمام والخلف للإشارة عدة مرات.  هذا هو <code>trainModel()</code> وظيفة <code>trainModel()</code> .  إنها مثل "المعلم" لنموذج الخلايا العصبية النانوية لدينا: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  ستقضي بعض الوقت مع عصبتنا النانوية السخيفة ، تحاول تدريبه ، </li><li style=";text-align:right;direction:rtl">  سوف تستخدم الكتب الخاصة (مجموعات البيانات <code>yTrain</code> و <code>yTrain</code> ) للتدريب ، </li><li style=";text-align:right;direction:rtl">  إنه يشجع "الطالب" على الدراسة بجدية أكبر (أسرع) باستخدام معلمة <code>alpha</code> ، والتي تتحكم بشكل أساسي في سرعة التعلم. </li></ul><br><p style=";text-align:right;direction:rtl">  بضع كلمات حول المعلمة <code>alpha</code> .  هذا مجرد معامل (مضاعف) لقيم المتغيرات <code>dW</code> و <code>dB</code> ، التي نحسبها أثناء الانتشار الخلفي للإشارة.  لذلك ، أظهر لنا المشتق الاتجاه إلى الحد الأدنى من وظيفة الخطأ (تخبرنا علامات قيم <code>dW</code> و <code>dB</code> بهذا).  كما أوضح لنا المشتق مدى السرعة التي نحتاجها للتقدم نحو الحد الأدنى للوظيفة (القيم المطلقة لـ <code>dW</code> و <code>dB</code> تخبرنا بذلك).  نحتاج الآن إلى مضاعفة حجم الخطوة بخطوة <code>alpha</code> لضبط سرعة نهجنا إلى الحد الأدنى (إجمالي حجم الخطوة).  في بعض الأحيان ، إذا استخدمنا قيمًا كبيرة لـ <code>alpha</code> ، فيمكننا اتباع خطوات كبيرة بحيث يمكننا ببساطة <em>تجاوز</em> الحد الأدنى من الوظيفة ، وبالتالي تخطيها. </p><br><p style=";text-align:right;direction:rtl">  من خلال التشبيه مع "المعلم" ، كلما أجبرت "طالبنا النانوي" على التعلم ، كلما كان أسرع في التعلم ، ولكن إذا فرضت عليه ضغطًا شديدًا وضغطت عليه بشدة ، فإن "طالبنا النانوي" قد يتعرض لانهيار عصبي لامبالاة كاملة ولن يتعلم أي شيء على الإطلاق. </p><br><p style=";text-align:right;direction:rtl">  سنقوم بتحديث معايير نموذجنا <code>w</code> و <code>b</code> النحو التالي: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/c7b/db8/84f/c7bdb884f2a940d62332246cdbcb44bc.png" alt="ث"></p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/b57/622/0ab/b576220ab6515d44255ef56699077bab.png" alt="ب"></p><br><p style=";text-align:right;direction:rtl">  وهكذا يبدو التدريب نفسه: </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trainModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{model, epochs, alpha, xTrain, yTrain}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     -.  . const costHistory = []; //    ()  for (let epoch = 0; epoch &lt; epochs; epoch += 1) { //   . const [predictions, cost] = forwardPropagation(model, xTrain, yTrain); costHistory.push(cost); //   . const [dW, dB] = backwardPropagation(predictions, xTrain, yTrain); //    -,    . nanoNeuron.w += alpha * dW; nanoNeuron.b += alpha * dB; } return costHistory; }</span></span></code> </pre> <br><h3 id="soberem-vse-funkcii-vmeste" style=";text-align:right;direction:rtl">  وضع كل الميزات معًا </h3><br><p style=";text-align:right;direction:rtl">  الوقت لاستخدام جميع الوظائف التي تم إنشاؤها مسبقا معا. </p><br><p style=";text-align:right;direction:rtl">  إنشاء مثيل لنموذج النانو العصبية.  في الوقت الحالي ، لا يعرف العصب النانوي شيئًا حول ماهية المعلمات <code>w</code> و <code>b</code> .  لذلك دعونا نضع <code>w</code> و <code>b</code> بشكل عشوائي. </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> w = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); <span class="hljs-comment"><span class="hljs-comment">// ie -&gt; 0.9492 const b = Math.random(); // ie -&gt; 0.4570 const nanoNeuron = new NanoNeuron(w, b);</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  نقوم بإنشاء مجموعات بيانات التدريب والاختبار. </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [xTrain, yTrain, xTest, yTest] = generateDataSets();</code> </pre> <br><p style=";text-align:right;direction:rtl">  الآن دعونا نحاول تدريب نموذجنا باستخدام خطوات صغيرة ( <code>0.0005</code> ) لـ <code>70000</code> عصر.  يمكنك تجربة هذه المعلمات ، فهي مصممة تجريبيا. </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> epochs = <span class="hljs-number"><span class="hljs-number">70000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0.0005</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> trainingCostHistory = trainModel({<span class="hljs-attr"><span class="hljs-attr">model</span></span>: nanoNeuron, epochs, alpha, xTrain, yTrain});</code> </pre> <br><p style=";text-align:right;direction:rtl">  دعونا نتحقق من كيفية تغير قيمة الخطأ في نموذجنا أثناء التدريب.  نتوقع أن تكون قيمة الخطأ بعد التدريب أقل بكثير من قبل التدريب.  وهذا يعني أن لدينا أكثر حكمة النانو العصبية.  يكون الخيار المعاكس ممكنًا أيضًا ، عندما يزداد خطأ التنبؤات بعد التدريب فقط (على سبيل المثال ، القيم الكبيرة لخطوة التعلم <code>alpha</code> ). </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'  :'</span></span>, trainingCostHistory[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// ie -&gt; 4694.3335043 console.log('  :', trainingCostHistory[epochs - 1]); // ie -&gt; 0.0000024</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  وهنا كيف تغيرت قيمة خطأ النموذج أثناء التدريب.  على المحور <code>x</code> توجد عهود (بالآلاف).  نتوقع أن يكون الرسم البياني في انخفاض. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/191/860/d6f/191860d6f0cd8cf7d24127f04f779462.png" alt="عملية التدريب"></p><br><p style=";text-align:right;direction:rtl">  دعونا نلقي نظرة على ما المعلمات لدينا "الخلايا العصبية النانوية" المستفادة.  نتوقع أن تشبه <code>celsiusToFahrenheit()</code> <code>w</code> و <code>b</code> المعلمات التي تحمل الاسم نفسه من <code>celsiusToFahrenheit()</code> ( <code>w = 1.8</code> و <code>b = 32</code> ) ، لأنها كانت <code>celsiusToFahrenheit()</code> النانوية التي حاولت محاكاةها. </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">' -:'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">w</span></span>: nanoNeuron.w, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: nanoNeuron.b}); <span class="hljs-comment"><span class="hljs-comment">// ie -&gt; {w: 1.8, b: 31.99}</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  كما ترى ، فإن الخلايا العصبية النانوية قريبة جدًا من وظيفة <code>celsiusToFahrenheit()</code> . </p><br><p style=";text-align:right;direction:rtl">  الآن ، دعونا نرى مدى دقة تنبؤات الخلايا العصبية النانوية لدينا فيما يتعلق ببيانات الاختبار التي لم يراها أثناء التدريب.  يجب أن يكون خطأ التنبؤ لبيانات الاختبار بالقرب من خطأ التنبؤ لبيانات التدريب.  هذا يعني أن الخلايا العصبية النانوية قد تعلمت التبعيات الصحيحة ويمكن أن تستخلص تجربتها بشكل صحيح من البيانات غير المعروفة سابقًا (هذه هي القيمة الكاملة للنموذج). </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs">[testPredictions, testCost] = forwardPropagation(nanoNeuron, xTest, yTest); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'   :'</span></span>, testCost); <span class="hljs-comment"><span class="hljs-comment">// ie -&gt; 0.0000023</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  الآن ، بما أن "طفلنا الصغير" تلقى تدريباً جيداً في "المدرسة" ويعرف الآن كيفية تحويل الدرجات المئوية بدقة إلى درجات فهرنهايت حتى بالنسبة للبيانات التي لم يرها ، يمكننا أن نطلق عليه "ذكاء".  الآن يمكننا حتى أن نطلب منه المشورة بشأن تحويل درجة الحرارة ، وكان هذا هو الغرض من التدريب بأكمله. </p><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tempInCelsius = <span class="hljs-number"><span class="hljs-number">70</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customPrediction = nanoNeuron.predict(tempInCelsius); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`- "",  </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${tempInCelsius}</span></span></span><span class="hljs-string">°C   :`</span></span>, customPrediction); <span class="hljs-comment"><span class="hljs-comment">// -&gt; 158.0002 console.log('  :', celsiusToFahrenheit(tempInCelsius)); // -&gt; 158</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  قريب جدا!  مثل الناس ، لدينا الخلايا العصبية النانوية جيدة ، ولكن ليست مثالية :) </p><br><p style=";text-align:right;direction:rtl">  الترميز الناجح! </p><br><h2 id="kak-zapustit-i-protestirovat-nano-neyron" style=";text-align:right;direction:rtl">  كيفية تشغيل واختبار الخلايا العصبية النانوية </h2><br><p style=";text-align:right;direction:rtl">  يمكنك استنساخ المستودع وتشغيل الخلايا العصبية النانو محليًا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/trekhleb/nano-neuron.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> nano-neuron</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">node ./NanoNeuron.js</code> </pre> <br><h2 id="upuschennye-koncepcii" style=";text-align:right;direction:rtl">  المفاهيم الضائعة </h2><br><p style=";text-align:right;direction:rtl">  تم حذف أو تبسيط مفاهيم التعلم الآلي التالية لسهولة التفسير. </p><br><p style=";text-align:right;direction:rtl">  <strong>فصل التدريب ومجموعات بيانات الاختبار</strong> </p><br><p style=";text-align:right;direction:rtl">  عادة ما يكون لديك مجموعة واحدة كبيرة من البيانات.  اعتمادًا على عدد النسخ في هذه المجموعة ، يمكن إجراء تقسيمها إلى مجموعات تدريب واختبار بنسبة 70/30.  يجب خلط البيانات في المجموعة بشكل عشوائي قبل الانقسام.  إذا كانت كمية البيانات كبيرة (على سبيل المثال ، ملايين) ، فيمكن إجراء التقسيم إلى مجموعات اختبار وتدريب بنسب قريبة من 90/10 أو 95/5. </p><br><p style=";text-align:right;direction:rtl">  <strong>السلطة على الانترنت</strong> </p><br><p style=";text-align:right;direction:rtl">  عادةً لن تجد حالات عند استخدام خلية عصبية واحدة فقط.  القوة في <a href="https://en.wikipedia.org/wiki/Neural_network" rel="nofollow">شبكة من</a> هذه الخلايا العصبية.  يمكن للشبكة العصبية أن تتعلم تبعيات أكثر تعقيدًا. </p><br><p style=";text-align:right;direction:rtl">  أيضًا في المثال أعلاه ، قد تبدو الخلايا العصبية النانوية لدينا بمثابة <a href="https://en.wikipedia.org/wiki/Linear_regression" rel="nofollow">انحدار خطي</a> بسيط أكثر من الشبكة العصبية. </p><br><p style=";text-align:right;direction:rtl">  <strong>تطبيع المدخلات</strong> </p><br><p style=";text-align:right;direction:rtl">  قبل التدريب ، من المعتاد <a href="https://www.jeremyjordan.me/batch-normalization/" rel="nofollow">تطبيع بيانات الإدخال</a> . </p><br><p style=";text-align:right;direction:rtl">  <strong>تنفيذ المتجهات</strong> </p><br><p style=";text-align:right;direction:rtl">  بالنسبة للشبكات العصبية ، تكون حسابات المتجهات (المصفوفة) أسرع بكثير من العمليات الحسابية للحلقات.  عادةً ما يتم تنفيذ نشر الإشارة المباشرة والعكسية باستخدام عمليات المصفوفة باستخدام مكتبة Python <a href="https://numpy.org/" rel="nofollow">Numpy</a> ، على سبيل المثال. </p><br><p style=";text-align:right;direction:rtl">  <strong>خطأ الحد الأدنى وظيفة</strong> </p><br><p style=";text-align:right;direction:rtl">  تم تبسيط وظيفة الخطأ التي استخدمناها للخلايا العصبية النانو.  يجب أن يحتوي على <a href="https://stackoverflow.com/questions/32986123/why-the-cost-function-of-logistic-regression-has-a-logarithmic-expression/32998675" rel="nofollow">مكونات لوغاريتمية</a> .  أي تغيير في صيغة دالة الخطأ يستلزم أيضًا تغيير في الصيغ الخاصة بالانتشار الأمامي والخلفي للإشارة. </p><br><p style=";text-align:right;direction:rtl">  <strong>وظيفة التنشيط</strong> </p><br><p style=";text-align:right;direction:rtl">  عادة ما تمر قيمة الخرج للخلايا العصبية من خلال وظيفة التنشيط.  للتنشيط ، يمكن استخدام وظائف مثل <a href="https://en.wikipedia.org/wiki/Sigmoid_function" rel="nofollow">Sigmoid</a> و <a href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks)" rel="nofollow">ReLU</a> وغيرها. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar479220/">https://habr.com/ru/post/ar479220/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar479202/index.html">C ++ والأساليب العددية: تكامل تقريبي لـ Newton-Cotes</a></li>
<li><a href="../ar479210/index.html">ماذا سيحدث لعمليات الشراء في المتاجر الأجنبية عبر الإنترنت من 1 يناير 2020</a></li>
<li><a href="../ar479214/index.html">مجموعة مختارة من الأحداث المجانية القادمة للمطورين في موسكو # 2</a></li>
<li><a href="../ar479216/index.html">الرياح الثانية باندورا DXL 3000 أو كيف كنت ثمل القياس عن بعد الخاصة بي</a></li>
<li><a href="../ar479218/index.html">كيفية جعل روبوت يحول الصور إلى كاريكاتير: إرشادات خطوة بخطوة للدمى</a></li>
<li><a href="../ar479222/index.html">ملخص المواد المثيرة للاهتمام لمطوّر البرامج المحمول رقم 325 (من 2 إلى 8 ديسمبر)</a></li>
<li><a href="../ar479226/index.html">Habr-analysis: ما يطلبه المستخدمون كهدية من Habr</a></li>
<li><a href="../ar479230/index.html">قم بتوثيق واجهة برمجة التطبيقات السريعة الخاصة بك مع تعليقات توضيحية</a></li>
<li><a href="../ar479232/index.html">تطوير تطبيق MQ JMS على Spring Boot</a></li>
<li><a href="../ar479234/index.html">أخبار من خريطة الشارع المفتوح رقم 488 (11/19/2019 - 11/25/2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>