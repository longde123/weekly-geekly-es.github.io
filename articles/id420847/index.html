<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌚 👨‍🔬 👩🏿‍🌾 Pengantar Pemrograman Shader untuk Tata Letak 💅🏻 👟 🤽🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WebGL telah ada sejak lama, banyak artikel telah ditulis tentang shader, ada serangkaian pelajaran. Tetapi sebagian besar, mereka terlalu rumit untuk ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar Pemrograman Shader untuk Tata Letak</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420847/"><p><img src="https://habrastorage.org/webt/mx/-v/ry/mx-vryd99xgt73gzsgzhfvcqpe0.jpeg"></p><br><p> WebGL telah ada sejak lama, banyak artikel telah ditulis tentang shader, ada serangkaian pelajaran.  Tetapi sebagian besar, mereka terlalu rumit untuk perancang tata letak.  Bahkan lebih baik untuk mengatakan bahwa mereka mencakup sejumlah besar informasi yang dibutuhkan pengembang mesin game daripada perancang tata letak.  Mereka segera mulai dengan membangun pemandangan yang kompleks, kamera, cahaya ... Di situs biasa, untuk membuat sepasang efek dengan foto, semua pengetahuan ini berlebihan.  Akibatnya, orang membuat struktur arsitektur yang sangat kompleks dan menulis shader panjang, panjang untuk tindakan esensi yang sangat sederhana. </p><br><p>  Semua ini mendorong pengantar aspek-aspek bekerja dengan shader yang paling mungkin berguna bagi perancang tata letak untuk membuat berbagai efek 2d dengan gambar di situs.  Tentu saja, disesuaikan dengan fakta bahwa mereka sendiri relatif jarang digunakan dalam desain antarmuka.  Kami akan membuat templat awal dalam JS murni tanpa pustaka pihak ketiga dan mempertimbangkan ide-ide untuk membuat beberapa efek populer berdasarkan pergeseran piksel, yang sulit dilakukan pada SVG, tetapi pada saat yang sama mereka dengan mudah diimplementasikan menggunakan shader. </p><a name="habracut"></a><br><blockquote> Diasumsikan bahwa pembaca sudah terbiasa dengan <code>canvas</code> , menguraikan apa itu WebGL, dan memiliki pengetahuan matematika yang minimal.  Beberapa poin akan dijelaskan secara sederhana, bukan akademis, untuk memberikan pemahaman praktis tentang teknologi untuk bekerja dengan mereka, dan bukan teori lengkap tentang dapur batin mereka atau istilah untuk belajar.  Ada buku-buku pintar untuk ini. </blockquote><p>  <em>Harus segera dicatat bahwa editor yang diintegrasikan ke dalam artikel dari CodePen memiliki kemampuan untuk mempengaruhi kinerja dari apa yang dilakukan di dalamnya.</em>  <em>Jadi sebelum menulis komentar bahwa ada sesuatu yang melambat di macbook Anda, pastikan masalahnya tidak berasal dari mereka.</em> </p><br><h2 id="osnovnye-idei">  Ide utama </h2><br><p>  <strong>Apa itu shader?</strong> </p><br><p>  Apa itu shader fragmen?  Ini pada dasarnya adalah program kecil.  Ini dieksekusi untuk setiap pixel di <code>anvas</code> .  Jika kita memiliki <code>canvas</code> ukuran 1000x500px, maka program ini akan mengeksekusi 500.000 kali, setiap kali menerima sebagai input parameter koordinat piksel yang saat ini sedang dijalankan.  Ini semua terjadi pada GPU dalam berbagai utas paralel.  Pada prosesor pusat, perhitungan seperti itu akan memakan waktu lebih lama. </p><br><p>  Vertex shader juga merupakan program, tetapi tidak dieksekusi untuk setiap piksel pada <code>canvas</code> , tetapi untuk setiap simpul dalam bentuk dari mana semuanya dibangun dalam ruang tiga dimensi.  Juga sejajar dengan semua simpul.  Oleh karena itu, input menerima koordinat titik, bukan piksel. </p><br><p>  Lebih jauh dalam konteks tugas kita, berikut ini terjadi: </p><br><ul><li>  Kami mengambil satu set koordinat simpul persegi panjang, di mana foto itu kemudian akan "digambar". </li><li>  Vertex shader untuk setiap titik mempertimbangkan lokasinya di ruang angkasa.  Bagi kami, ini akan datang ke kasing khusus - pesawat sejajar dengan layar.  Foto dalam 3d tidak kita butuhkan.  Proyeksi selanjutnya ke bidang layar dapat mengatakan apa-apa. </li><li>  Lebih jauh untuk setiap fragmen yang terlihat, dan dalam konteks kami untuk semua fragmen piksel, shader fragmen dijalankan, ia mengambil foto dan koordinat saat ini, menghitung sesuatu dan memberikan warna untuk piksel tertentu ini. </li><li>  Jika tidak ada logika dalam fragmen shader, maka perilaku semua ini akan menyerupai metode <code>drawImage()</code> <code>canvas</code> .  Tapi kemudian kita tambahkan logika ini dan dapatkan banyak hal menarik. </li></ul><br><p>  Ini adalah deskripsi yang sangat sederhana, tetapi harus jelas siapa yang melakukan apa. </p><br><p>  <strong>Sedikit tentang sintaksis</strong> </p><br><p>  Shader ditulis dalam GLSL - OpenGL Shading Language.  Bahasa ini sangat mirip dengan C.  Tidak masuk akal untuk menggambarkan seluruh sintaksis dan metode standar di sini, tetapi Anda selalu dapat menggunakan lembar contekan: </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler dengan gambar</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/id/vb/6e/idvb6ew9k7ackf94bjviuxavhxc.jpeg"><br><img src="https://habrastorage.org/webt/ye/ax/b4/yeaxb44uvcjkhir92ezxcsnc2oo.jpeg"><br><img src="https://habrastorage.org/webt/f7/2q/5q/f72q5qifi99xwv5nsqfnkb2x1au.jpeg"><br><img src="https://habrastorage.org/webt/8c/ty/in/8ctyinenggjs8gutaj484oreep4.jpeg"></p></div></div><br><p>  Setiap shader memiliki fungsi utama, yang dengannya eksekusi dimulai.  Parameter input standar untuk shader dan output dari hasil pekerjaan mereka diimplementasikan melalui variabel khusus dengan awalan <code>gl_</code> .  Mereka dilindungi terlebih dahulu dan tersedia di dalam shader yang sama.  Jadi koordinat vertex untuk letak vertex shader dalam variabel <code>gl_Position</code> , koordinat fragmen (pixel) untuk fragmen shader terletak di <code>gl_FragCoord</code> , dll.  Anda selalu dapat menemukan daftar lengkap variabel khusus yang tersedia di lembar contekan yang sama. </p><br><p>  Jenis variabel utama dalam GLSL agak bersahaja - <code>void</code> , <code>bool</code> , <code>int</code> , <code>float</code> ... Jika Anda bekerja dengan bahasa C-like, Anda sudah melihatnya.  Ada jenis lain, khususnya vektor dimensi yang berbeda - <code>vec2</code> , <code>vec3</code> , <code>vec4</code> .  Kami akan terus menggunakannya untuk koordinat dan warna.  Variabel yang dapat kita buat adalah dari tiga modifikasi penting: </p><br><ul><li>  <strong>Seragam</strong> - Data global dalam segala hal.  Melewati dari luar, sama untuk semua panggilan shader vertex dan fragmen. </li><li>  <strong>Atribut</strong> - Data ini ditransfer lebih tepat dan untuk setiap panggilan shader mungkin berbeda. </li><li>  <strong>Memvariasikan</strong> - Diperlukan untuk mentransfer data dari vertex shaders ke fragmen shaders. </li></ul><br><blockquote>  Sangat berguna untuk awalan u / a / v ke semua variabel di shader untuk membuatnya lebih mudah untuk memahami dari mana data berasal. </blockquote><p>  Saya percaya bahwa ada baiknya beralih ke contoh praktis untuk segera menonton semua ini dalam tindakan dan tidak memuat memori Anda. </p><br><h2 id="gotovim-startovyy-shablon">  Template mulai memasak </h2><br><p>  Mari kita mulai dengan JS.  Seperti yang biasanya terjadi ketika bekerja dengan <code>canvas</code> , kita membutuhkannya dan konteksnya.  Agar tidak memuat kode sampel, kami akan membuat variabel global: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CANVAS = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(IDs.canvas); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GL = canvas.getContext(<span class="hljs-string"><span class="hljs-string">'webgl'</span></span>);</code> </pre> <br><p>  Lewati momen yang terkait dengan ukuran <code>canvas</code> dan perhitungan ulangnya saat mengubah ukuran jendela browser.  Kode ini termasuk dalam contoh dan biasanya tergantung pada sisa tata letak.  Tidak masuk akal untuk fokus padanya.  Mari beralih ke tindakan dengan WebGL. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shaders</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShaders</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PROGRAM</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attachShader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM, shaders.vertex)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attachShader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM, shaders.fragment)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linkProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM)</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><p>  Pertama, kita kompilasi shader (itu akan sedikit lebih rendah), buat program, tambahkan kedua shader kita ke dalamnya dan buat tautan.  Pada titik ini, kompatibilitas shader diperiksa.  Ingat tentang berbagai variabel yang diteruskan dari verteks ke fragmen?  - Secara khusus, set mereka diperiksa di sini sehingga kemudian dalam proses itu tidak ternyata sesuatu belum ditransmisikan atau ditransmisikan, tetapi tidak sama sekali.  Tentu saja, pemeriksaan ini tidak akan mengungkapkan kesalahan logis, saya pikir ini bisa dimengerti. </p><br><p>  Koordinat simpul akan disimpan dalam array buffer khusus dan akan dikirim dalam bentuk potongan, satu simpul, ke setiap panggilan shader.  Selanjutnya, kami menjelaskan beberapa detail untuk bekerja dengan potongan-potongan ini.  Pertama, kita akan menggunakan koordinat vertex di shader melalui <code>a_position</code> atribut <code>a_position</code> .  Itu bisa disebut berbeda, itu tidak masalah.  Kami mendapatkan lokasinya (ini adalah sesuatu seperti pointer di C, tetapi bukan pointer, melainkan nomor entitas yang hanya ada di dalam program). </p><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vertexPositionAttribute = GL.getAttribLocation(<span class="hljs-keyword"><span class="hljs-keyword">PROGRAM</span></span>, <span class="hljs-string"><span class="hljs-string">'a_position'</span></span>);</code> </pre> <br><p>  Selanjutnya, kami menunjukkan bahwa array dengan koordinat akan melewati variabel ini (dalam shader itu sendiri, kami akan menganggapnya sebagai vektor).  WebGL akan secara mandiri mencari tahu koordinat mana dari titik-titik dalam bentuk kami yang harus diteruskan ke panggilan shader mana.  Kami hanya mengatur parameter untuk array vektor yang akan ditransmisikan: dimensi - 2 (kami akan mengirimkan koordinat <code>(x,y)</code> ), terdiri dari angka dan tidak dinormalisasi.  Parameter terakhir tidak menarik bagi kami, kami membiarkan nol secara default. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.enableVertexAttribArray</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">vertexPositionAttribute</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.vertexAttribPointer</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">vertexPositionAttribute</span></span>, 2, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.FLOAT</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">false</span></span>, 0, 0);</code> </pre> <br><p>  Sekarang buat buffer itu sendiri dengan koordinat simpul pesawat kami, di mana foto itu akan ditampilkan.  Koordinat "2d" lebih jelas, tetapi untuk tugas kita ini adalah hal yang paling penting. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPlane</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.ARRAY_BUFFER, GL.createBuffer()</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bufferData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( GL.ARRAY_BUFFER, new Float32Array([ -1, -1, -1, 1, 1, -1, 1, 1 ])</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">STATIC_DRAW</span></span></span><span class="hljs-function"> ); }</span></span></code> </pre> <br><p>  Kotak ini akan cukup untuk semua contoh kami.  <code>STATIC_DRAW</code> berarti bahwa buffer dimuat satu kali dan kemudian akan digunakan kembali.  Kami tidak akan mengunggah apa pun lagi. </p><br><p>  Sebelum beralih ke shader sendiri, mari kita lihat kompilasi mereka: </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShaders</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">vertex</span></span>: compileShader( GL.VERTEX_SHADER, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(IDs.shaders.vertex).textContent ), <span class="hljs-attr"><span class="hljs-attr">fragment</span></span>: compileShader( GL.FRAGMENT_SHADER, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(IDs.shaders.fragment).textContent ) }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compileShader</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type, source</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shader = GL.createShader(type); GL.shaderSource(shader, source); GL.compileShader(shader); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shader; }</code> </pre> <br><p>  Kami mendapatkan kode shader dari elemen-elemen pada halaman, membuat shader dan mengompilasinya.  Secara teori, Anda dapat menyimpan kode shader dalam file terpisah dan memuatnya selama perakitan sebagai string di tempat yang tepat, tetapi CodePen tidak memberikan kesempatan seperti itu untuk contoh.  Banyak pelajaran menyarankan penulisan kode langsung di JS, tetapi bahasa tidak mengubahnya menjadi bahasa yang nyaman.  Meskipun tentu saja rasanya dan warnanya ... </p><br><p>  Jika kesalahan terjadi selama kompilasi, skrip akan terus berjalan menampilkan beberapa peringatan di konsol yang tidak masuk akal.  Sangat berguna untuk melihat log setelah kompilasi agar tidak memutar otak Anda atas apa yang tidak dikompilasi di sana: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">console</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.log</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getShaderInfoLog</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span>));</code> </pre> <br><blockquote>  WebGL menyediakan beberapa opsi berbeda untuk melacak masalah saat menyusun shader dan membuat program, tetapi dalam praktiknya ternyata secara real time kami tidak dapat memperbaiki apa pun.  Begitu sering kita akan dibimbing oleh pemikiran "jatuh - lalu jatuh" dan kita tidak akan memuat kode dengan banyak cek tambahan. </blockquote><p>  <strong>Mari kita beralih ke shader sendiri</strong> </p><br><p>  Karena kita hanya akan memiliki satu bidang yang kita tidak akan melakukan apa pun, satu vertex shader sederhana sudah cukup bagi kita, yang akan kita lakukan di awal.  Upaya utama akan difokuskan pada fragmen shader dan semua contoh berikutnya akan relevan bagi mereka. </p><br><blockquote>  Cobalah untuk menulis kode shader dengan nama variabel yang kurang lebih bermakna.  Pada jaringan Anda akan menemukan contoh-contoh di mana fungsi dengan matematika yang kuat untuk 200 baris teks berkelanjutan akan dirangkai dari variabel satu huruf, tetapi hanya karena seseorang tidak berarti itu perlu diulang.  Pendekatan semacam itu bukan "kekhususan bekerja dengan GL", itu adalah copy-paste kode sumber dangkal dari abad terakhir yang ditulis oleh orang-orang yang di masa muda mereka memiliki batasan pada panjang nama variabel. </blockquote><p>  Pertama, vertex shader.  Vektor 2d dengan koordinat <code>(x,y)</code> akan ditransfer ke variabel atribut <code>a_position</code> , seperti yang kami katakan.  Shader harus mengembalikan vektor empat nilai <code>(x,y,z,w)</code> .  Itu tidak akan memindahkan apa pun di ruang angkasa, jadi pada sumbu z, kita cukup nol semuanya dan mengatur nilai w ke unit standar.  Jika Anda bertanya-tanya mengapa ada empat daripada tiga koordinat, maka Anda dapat menggunakan pencarian jaringan untuk "koordinat seragam". </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'vertex-shader'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'x-shader/x-vertex'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> precision mediump float; attribute vec2 a_position; </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">void</span></span></span><span class="actionscript"> main() { gl_Position = vec4(position, </span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">0</span></span></span><span class="actionscript">, </span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">1</span></span></span><span class="actionscript">); } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Hasil pekerjaan direkam dalam variabel khusus <code>gl_Position</code> .  Shader tidak memiliki <code>return</code> dalam arti penuh kata, mereka menuliskan semua hasil pekerjaan mereka dalam variabel yang khusus disediakan untuk tujuan ini. </p><br><blockquote>  Perhatikan pekerjaan presisi untuk tipe data float.  Untuk menghindari beberapa masalah pada perangkat seluler, akurasi harus lebih buruk daripada highp dan harus sama di kedua shader.  Ini diperlihatkan sebagai contoh di sini, tetapi merupakan praktik yang baik pada ponsel untuk mematikan kecantikan semacam itu dengan shader sama sekali. </blockquote><p>  Shader fragmen akan selalu mengembalikan warna yang sama untuk memulai.  Kotak kami akan menempati seluruh <code>canvas</code> , jadi sebenarnya di sini kami mengatur warna untuk setiap piksel: </p><br><pre> <code class="hljs pgsql">&lt;script id=<span class="hljs-string"><span class="hljs-string">'fragment-shader'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>=<span class="hljs-string"><span class="hljs-string">'x-shader/x-fragment'</span></span>&gt; <span class="hljs-type"><span class="hljs-type">precision</span></span> mediump <span class="hljs-type"><span class="hljs-type">float</span></span>; #define GOLD vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.86</span></span>, <span class="hljs-number"><span class="hljs-number">0.6</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) <span class="hljs-type"><span class="hljs-type">void</span></span> main() { gl_FragColor = GOLD; } &lt;/script&gt;</code> </pre> <br><p>  Anda bisa memperhatikan angka yang menggambarkan warna.  Ini biasa bagi semua jenis huruf RGBA, hanya dinormalisasi.  Nilai bukan bilangan bulat dari 0 hingga 255, tetapi fraksional dari 0 hingga 1. Urutannya sama. </p><br><blockquote>  Jangan lupa untuk menggunakan preprocessor untuk semua konstanta ajaib dalam proyek nyata - ini membuat kode lebih dimengerti tanpa mempengaruhi kinerja (substitusi, seperti dalam C, terjadi selama kompilasi). </blockquote><p>  Perlu diperhatikan poin lain tentang preprosesor: </p><br><blockquote>  Penggunaan pemeriksaan konstan #jikaef GL_ES dalam berbagai pelajaran tidak memiliki arti praktis.  di browser kami hari ini, tidak ada opsi GL lain yang ada. </blockquote><p>  Tapi sudah waktunya untuk melihat hasilnya: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/JaoYMj" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Kotak emas menunjukkan bahwa shader berfungsi seperti yang diharapkan.  Masuk akal untuk bermain-main dengan mereka sedikit sebelum beralih ke bekerja dengan foto. </p><br><p>  <strong>Gradien dan mengubah vektor</strong> </p><br><p>  Biasanya, tutorial WebGL mulai dengan menggambar gradien.  Ini praktis tidak masuk akal, tetapi akan berguna untuk mencatat beberapa poin. </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gl_FragColor = vec4(gl_FragCoord.zxy / <span class="hljs-number"><span class="hljs-number">500.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Dalam contoh ini, kami menggunakan koordinat piksel saat ini sebagai warna.  Anda akan sering melihat ini dalam contoh di internet.  Keduanya adalah vektor.  Jadi tidak ada yang mengganggu untuk mencampur semuanya dalam tumpukan.  Penginjil TypeScript harus memiliki serangan di sini.  Poin penting adalah bagaimana kita hanya mendapatkan sebagian dari koordinat dari vektor.  Properti <code>.xy</code> , <code>.zy</code> , <code>.zyx</code> , <code>.xyzw</code> , <code>.xyzw</code> , <code>.xyzw</code> , <code>.xyzw</code> , <code>.xyzw</code> , dll.  dalam urutan yang berbeda memungkinkan Anda untuk mengeluarkan elemen-elemen vektor dalam urutan tertentu dalam bentuk vektor lain.  Sangat mudah diimplementasikan.  Juga, vektor dimensi tinggi dapat dibuat dari vektor dimensi rendah dengan menambahkan nilai yang hilang, seperti yang kami lakukan. </p><br><blockquote>  Selalu nyatakan bagian pecahan angka secara eksplisit.  Tidak ada konversi int otomatis -&gt; mengambang di sini. </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/vzENvx" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <strong>Seragam dan berlalunya waktu</strong> </p><br><p>  Contoh berguna berikutnya adalah penggunaan seragam.  Ini adalah data yang paling umum untuk semua panggilan shader.  Kami mendapatkan lokasi mereka dengan cara yang sama seperti untuk variabel atribut, misalnya: </p><br><pre> <code class="hljs delphi">GL.getUniformLocation(<span class="hljs-keyword"><span class="hljs-keyword">PROGRAM</span></span>, <span class="hljs-string"><span class="hljs-string">'u_time'</span></span>)</code> </pre> <br><p>  Lalu kita bisa mengatur nilai-nilai mereka sebelum setiap frame.  Seperti halnya vektor, ada banyak metode serupa di sini, dimulai dengan kata <code>uniform</code> , kemudian muncul dimensi variabel (1 untuk angka, 2, 3 atau 4 untuk vektor) dan ketik (f - float, i - int, v - vector) . </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeStamp)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uniform1f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.getUniformLocation(PROGRAM, 'u_time')</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeStamp</span></span></span><span class="hljs-function"> / 1000.0); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawArrays</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TRIANGLE_STRIP, 0, 4)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">window</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestAnimationFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(draw)</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><blockquote>  Faktanya, kita tidak selalu membutuhkan antarmuka 60fps.  Sangat mungkin untuk menambahkan pelambatan ke requestAnimationFrame dan mengurangi frekuensi menggambar ulang frame. </blockquote><p>  Sebagai contoh, kami akan mengubah warna isian.  Dalam shader, semua fungsi matematika dasar tersedia - <code>sin</code> , <code>cos</code> , <code>tan</code> , <code>asin</code> , <code>acos</code> , <code>atan</code> , <code>pow</code> , <code>exp</code> , <code>log</code> , <code>sqrt</code> , <code>abs</code> , dan lainnya.  Kami akan menggunakan dua dari mereka. </p><br><pre> <code class="hljs cpp">uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> u_time; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ gl_FragColor = vec4( <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time)), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time * <span class="hljs-number"><span class="hljs-number">3.0</span></span>)), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)), <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Waktu dalam animasi semacam itu adalah konsep yang relatif.  Di sini kita menggunakan nilai-nilai yang diberikan oleh <code>requestAnimationFrame</code> , tetapi kita dapat membuat "waktu" kita sendiri.  Idenya adalah bahwa jika beberapa parameter dijelaskan oleh fungsi waktu, maka kita dapat mengubah waktu dalam arah yang berlawanan, memperlambat, mempercepatnya atau kembali ke keadaan semula.  Ini bisa sangat membantu. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/VGYvNP" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Tapi contoh abstrak yang cukup, mari kita beralih ke menggunakan gambar. </p><br><p>  <strong>Memuat gambar ke dalam tekstur</strong> </p><br><p>  Untuk menggunakan gambar, kita perlu membuat tekstur, yang kemudian akan ditampilkan di pesawat kita.  Untuk memulai, muat gambar itu sendiri: </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Image(); image.crossOrigin = <span class="hljs-string"><span class="hljs-string">'anonymous'</span></span>; image.onload = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// .... }; image.src = 'example.jpg'; }</span></span></code> </pre> <br><p>  Setelah dimuat, buat tekstur dan tunjukkan bahwa ia akan pergi di nomor 0. Di WebGL, bisa ada banyak tekstur pada saat yang sama dan kita harus secara eksplisit menunjukkan di mana perintah selanjutnya akan berhubungan.  Dalam contoh kami, hanya akan ada satu tekstur, tetapi kami masih secara eksplisit menunjukkan bahwa itu akan menjadi nol. </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> texture = GL.createTexture(); GL.activeTexture(GL.TEXTURE0); GL.bindTexture(GL.TEXTURE_2D, texture);</code> </pre> <br><p>  Tetap menambahkan gambar.  Kami juga segera mengatakan bahwa itu perlu diputar sepanjang sumbu Y, karena  di WebGL, porosnya terbalik: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.pixelStorei</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.UNPACK_FLIP_Y_WEBGL</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texImage2D</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, 0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.RGB</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.RGB</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.UNSIGNED_BYTE</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">image</span></span>);</code> </pre> <br><p>  Secara teori, teksturnya harus persegi.  Lebih tepatnya, mereka bahkan harus memiliki ukuran yang sama dengan kekuatan dua - 32px, 64px, 128px, dll.  Tapi kita semua mengerti bahwa tidak ada yang akan memproses foto dan mereka akan berada dalam proporsi yang berbeda setiap kali.  Ini akan menyebabkan kesalahan bahkan jika <code>canvas</code> dalam ukuran cocok dengan tekstur.  Oleh karena itu, kami mengisi seluruh ruang ke tepi pesawat dengan piksel gambar yang ekstrem.  Ini adalah praktik standar, meskipun tampaknya sedikit penopang. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texParameteri</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_WRAP_S</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CLAMP_TO_EDGE</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texParameteri</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_WRAP_T</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CLAMP_TO_EDGE</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texParameteri</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_MIN_FILTER</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LINEAR</span></span>);</code> </pre> <br><p>  Tetap mentransfer tekstur ke shader.  Data ini umum untuk semua, jadi kami menggunakan pengubah <code>uniform</code> . </p><br><pre> <code class="hljs delphi">GL.uniform1i(GL.getUniformLocation(<span class="hljs-keyword"><span class="hljs-keyword">PROGRAM</span></span>, <span class="hljs-string"><span class="hljs-string">'u_texture'</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Sekarang kita bisa menggunakan warna dari tekstur dalam shader fragmen.  Tapi kami juga ingin gambarnya menempati seluruh <code>canvas</code> .  Jika gambar dan <code>canvas</code> memiliki proporsi yang sama, maka tugas ini menjadi sepele.  Pertama, kami mentransfer ukuran <code>canvas</code> ke shader (ini harus dilakukan setiap kali Anda mengubah ukurannya): </p><br><pre> <code class="hljs pgsql">GL.uniform1f(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_canvas_size'</span></span>), Math.max(CANVAS.height, CANVAS.width));</code> </pre> <br><p>  Dan bagikan koordinat ke dalamnya: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> sampler2D u_texture; <span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> float u_canvas_size; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, gl_FragCoord.xy / u_canvas_size); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/QVwjeJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>Pada titik ini, Anda dapat menghentikan sebentar dan menyeduh teh.</em>  <em>Kami telah melakukan semua pekerjaan persiapan dan beralih ke menciptakan berbagai efek.</em> </p><br><h2 id="effekty">  Efek </h2><br><p>  Dalam menciptakan berbagai efek, intuisi dan eksperimen memainkan peran penting.  Seringkali, Anda dapat mengganti algoritma yang kompleks dengan sesuatu yang sangat sederhana dan memberikan hasil yang serupa.  Pengguna akhir tidak akan melihat perbedaannya, tetapi kami mempercepat pekerjaan dan menyederhanakan dukungan.  WebGL tidak menyediakan alat yang masuk akal untuk debugging shader, sehingga bermanfaat bagi kita untuk memiliki potongan kode kecil yang dapat masuk di kepala secara keseluruhan. </p><br><blockquote>  Lebih sedikit kode berarti lebih sedikit masalah.  Dan lebih mudah dibaca.  Selalu periksa shader yang ditemukan di jaringan untuk tindakan yang tidak perlu.  Itu terjadi bahwa Anda dapat menghapus setengah kode dan tidak ada yang akan berubah. </blockquote><p>  Mari kita bermain sedikit dengan shader.  Sebagian besar efek kami akan didasarkan pada kenyataan bahwa kami mengembalikan warna bukan dari piksel pada tekstur yang seharusnya ada di tempat ini, tetapi beberapa yang bersebelahan.  Berguna untuk menambahkan koordinat hasil fungsi standar koordinat.  Waktu juga akan berguna untuk digunakan - sehingga hasil eksekusi akan lebih mudah dilacak, dan pada akhirnya, kami masih akan membuat efek animasi.  Mari kita coba gunakan sinus: </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + sin(<span class="hljs-name"><span class="hljs-name">u_time</span></span> + gl_FragCoord.y))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Hasilnya aneh.  Jelas, semuanya bergerak dengan terlalu banyak amplitudo.  Bagilah semuanya dengan beberapa nomor: </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + sin(<span class="hljs-name"><span class="hljs-name">u_time</span></span> + gl_FragCoord.y) / <span class="hljs-number"><span class="hljs-number">250.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Sudah lebih baik.  Sekarang jelas bahwa kami mendapat sedikit kegembiraan.  Secara teori, untuk meningkatkan setiap gelombang, kita perlu membagi argumen sinus - koordinat.  Mari kita lakukan: </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + sin(<span class="hljs-name"><span class="hljs-name">u_time</span></span> + gl_FragCoord.y / <span class="hljs-number"><span class="hljs-number">30.0</span></span>) / <span class="hljs-number"><span class="hljs-number">250.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/jvEWbJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Efek serupa sering disertai dengan pemilihan koefisien.  Ini dilakukan dengan mata.  Seperti halnya memasak, pada awalnya akan sulit ditebak, tetapi kemudian akan terjadi dengan sendirinya.  Hal utama adalah untuk setidaknya memahami kira-kira apa koefisien ini atau itu dalam formula yang dihasilkan mempengaruhi.  Setelah koefisien dipilih, masuk akal untuk memasukkannya ke dalam makro (seperti contoh pertama) dan memberikan nama yang bermakna. </p><br><p>  <strong>Cermin bengkok, sepeda dan eksperimen</strong> </p><br><p>  Berpikir itu baik.  Ya, ada algoritma yang sudah jadi untuk memecahkan beberapa masalah yang bisa kita ambil dan gunakan.       ,      . </p><br><p>         ,   " ",       .  Apa yang harus dilakukan </p><br><p> ,       ,   ?      .   ,       rand()  - .    ,    ,   ,  ,   .    .                  .   ,      .         .      .    -,    .      .    ,     ,       ,   .     ,           "": </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(vec2 <span class="hljs-keyword"><span class="hljs-keyword">seed</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract(<span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">dot</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">seed</span></span>, vec2(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>))) * <span class="hljs-number"><span class="hljs-number">43758.5453123</span></span>); }</code> </pre><br><p>    ,          , ,      NVIDIA  ATI     .     ,        . </p><br><p>       ,    ,          : </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + rand(<span class="hljs-name"><span class="hljs-name">gl_FragCoord</span></span>.xy) / <span class="hljs-number"><span class="hljs-number">100.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>          : </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + rand(<span class="hljs-name"><span class="hljs-name">gl_FragCoord</span></span>.xy + vec2(<span class="hljs-name"><span class="hljs-name">sin</span></span>(<span class="hljs-name"><span class="hljs-name">u_time</span></span>))) / <span class="hljs-number"><span class="hljs-number">250.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>    ,   ,   : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/pOvgbX" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> ,        .     ,   ,     .   —           .  Bagaimana cara melakukannya? .      . </p><br><p>       0  1,     - .    5 —          .       ,      . </p><br><pre> <code class="hljs matlab">vec2 texture_coord = gl_FragCoord.xy / u_canvas_size; gl_FragColor = texture2D(u_texture, texture_coord + <span class="hljs-built_in"><span class="hljs-built_in">rand</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">5.0</span></span>) + vec2(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time))) / <span class="hljs-number"><span class="hljs-number">100.0</span></span>);</code> </pre> <br><p>   ,   -    .   -   . ,    ,   .     ? </p><br><p>        ,  ,   ,  - .     , .    , ..      -.      ,      .      . ,         ,   .        . </p><br><p>    <code>sin</code>  <code>cos</code>   ,    .   .         . </p><br><pre> <code class="hljs mel">gl_FragColor = texture2D(u_texture, texture_coord + vec2( <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(u_time + texture_coord.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(u_time + texture_coord.y * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>));</code> </pre> <br><p>      .   <code>fract</code>  .    1  1 —     : </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(vec2 position) { vec2 block_position = <span class="hljs-keyword"><span class="hljs-keyword">floor</span></span>(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> top_left_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> top_right_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottom_left_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottom_right_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); vec2 computed_value = fract(position); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>        . WebGL      <code>smoothstep</code> ,     : </p><br><pre> <code class="hljs lisp">vec2 computed_value = smoothstep(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, fract(<span class="hljs-name"><span class="hljs-name">position</span></span>))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>    ,      .   ,          X   : </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> computed_value.x;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/mGyVBK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> …    ,  ,    ... </p><br><blockquote>    - ,     ,     ...        . </blockquote><p>     y —    ,   .      ? </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(computed_value);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/OoPMza" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>     . </p><br><p>     .     0.5 —      . </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">return</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mix</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">top_left_value</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">top_right_value</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span>) + (<span class="hljs-selector-tag"><span class="hljs-selector-tag">bottom_left_value</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">top_left_value</span></span>) * <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.y</span></span> * (1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span>) + (<span class="hljs-selector-tag"><span class="hljs-selector-tag">bottom_right_value</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">top_right_value</span></span>) * <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span> * <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.y</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span>;</code> </pre> <br><p>      : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/eLmJMZ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> <em>     ,   , ,  .</em> </p><br><p> <strong> </strong> </p><br><p>        ,     ,          .         - . </p><br><p>    uniform-,       .   0  1,  0 —   ,  1 —  . </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> u_intensity;</code> </pre> <br><p>       : </p><br><pre> <code class="hljs mel">gl_FragColor = texture2D(u_texture, texture_coord + vec2(<span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(u_time + texture_coord.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(u_time + texture_coord.y * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>) * u_intensity);</code> </pre> <br><p>         ,      . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/PdwZdX" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>         (  0  1),             . </p><br><blockquote>  ,    ,         ,       .          —         requestAnimationFrame.       ,     FPS. </blockquote><p> <strong>   </strong> </p><br><p>      ,        .   uniform-. </p><br><pre> <code class="hljs powershell">document.addEventListener(<span class="hljs-string"><span class="hljs-string">'mousemove'</span></span>, (e) =&gt; { let rect = CANVAS.getBoundingClientRect(); MOUSE_POSITION = [ <span class="hljs-type"><span class="hljs-type">e.clientX</span></span> - <span class="hljs-type"><span class="hljs-type">rect.left</span></span>, <span class="hljs-type"><span class="hljs-type">rect.height</span></span> - (<span class="hljs-type"><span class="hljs-type">e.clientY</span></span> - <span class="hljs-type"><span class="hljs-type">rect.top</span></span>) ]; GL.uniform2fv(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_mouse_position'</span></span>), MOUSE_POSITION); });</code> </pre> <br><p>    ,            .      —  ,       . </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> texture_coord = gl_FragCoord.xy / u_canvas_size; <span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> direction = u_mouse_position / u_canvas_size - texture_coord; <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> dist = distance(gl_FragCoord.xy, u_mouse_position) / u_canvas_size; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (dist &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, texture_coord + u_intensity * direction * dist * <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span> ); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, texture_coord); } }</code> </pre> <br><p>         -    .         . </p><br><blockquote>             .    ,        . </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/bxNEOP" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> <strong></strong> </p><br><p>      . Glitch-     ,      SVG.      .    — .      ?       —  ,   ,   ,      . </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float</span></span> random_value = rand(vec2(texture_coord.y, u_time)); <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (random_value &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">05</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, vec2(texture_coord.x + random_value / <span class="hljs-number"><span class="hljs-number">5</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, texture_coord.y)); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, texture_coord); }</code> </pre> <br><blockquote> "     ?" —   ,      .          . </blockquote><p>     .      —  ,           . </p><br><pre> <code class="hljs lisp">float random_value = rand(<span class="hljs-name"><span class="hljs-name">vec2</span></span>(<span class="hljs-name"><span class="hljs-name">floor</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span>.y * 20.0), u_time));</code> </pre> <br><p>     .   ,       : </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, vec2(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span>.x + random_value / <span class="hljs-number"><span class="hljs-number">4.0</span></span>, texture_coord.y)) + vec4(<span class="hljs-name"><span class="hljs-name">vec3</span></span>(<span class="hljs-name"><span class="hljs-name">random_value</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>          .          —    . ,           —   <code>.r</code> , <code>.g</code> , <code>.b</code> , <code>.rg</code> , <code>.rb</code> , <code>.rgb</code> , <code>.bgr</code> , ...               . </p><br><p>       : </p><br><pre> <code class="hljs lisp">float random_value = u_intensity * rand(<span class="hljs-name"><span class="hljs-name">vec2</span></span>(<span class="hljs-name"><span class="hljs-name">floor</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span>.y * 20.0), u_time));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/OoPMeY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="chto-v-itoge">  Apa hasilnya? </h2><br><p>         ,                   ,     .          ,  ,      —         . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420847/">https://habr.com/ru/post/id420847/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420833/index.html">Kesalahan monetisasi aplikasi utama [dan cara memperbaikinya]</a></li>
<li><a href="../id420837/index.html">Menguji array RAID perangkat lunak untuk perangkat NVMe menggunakan metodologi SNIA</a></li>
<li><a href="../id420841/index.html">Perbaikan terbaru pra-rumah sakit atau "Hei Sombong! Di mana kesalahan saya? "</a></li>
<li><a href="../id420843/index.html">7 September, Yekaterinburg - pertemuan untuk pengembang .NET</a></li>
<li><a href="../id420845/index.html">Penjinakan keras kepala dengan menggunakan kruk: lubang adaptor Wi-Fi WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../id420853/index.html">Memenuhi Windows Pseudo Console (ConPTY)</a></li>
<li><a href="../id420857/index.html">Roaming Wi-Fi mulus: teori dalam praktik</a></li>
<li><a href="../id420859/index.html">Untuk pertanyaan Wirth dan rantai</a></li>
<li><a href="../id420861/index.html">Bersiap untuk C ++ 20. Studi Kasus Nyata Coroutines TS</a></li>
<li><a href="../id420863/index.html">Saat kami melakukan smartphone Rusia pertama, melanjutkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>