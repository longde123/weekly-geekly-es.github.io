<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§π ‚ú°Ô∏è üßî Las minas bajo rendimiento est√°n esperando en las alas üëÜüèº üò§ üòπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo hablar√© sobre las minas colocadas bajo el rendimiento, as√≠ como su detecci√≥n (preferiblemente antes de la explosi√≥n) y su eliminaci√≥n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Las minas bajo rendimiento est√°n esperando en las alas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443206/"><p>  En este art√≠culo hablar√© sobre las minas colocadas bajo el rendimiento, as√≠ como su detecci√≥n (preferiblemente antes de la explosi√≥n) y su eliminaci√≥n. </p><br><div class="spoiler">  <b class="spoiler_title">Una imagen para llamar la atenci√≥n.</b> <div class="spoiler_text"><p><img src="https://ic.pics.livejournal.com/ivagkin/26880913/58954/58954_original.jpg" alt="imagen"></p></div></div><a name="habracut"></a><br><h4 id="chto-takoe-mina">  ¬øQu√© es una mina? </h4><br><p>  Comencemos con lo que est√° en los or√≠genes de cualquier conocimiento, con definici√≥n.  Los antiguos dec√≠an que nombrar correctamente significa entender correctamente.  Creo que la definici√≥n de una mina bajo rendimiento se expresa mejor al contrastarla con un error obvio, por ejemplo, esto: </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... strings)</span></span></span><span class="hljs-function"> </span></span>{ String result = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : strings) { result += str; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Incluso los desarrolladores novatos saben que las l√≠neas son inmutables, y pegarlas juntas en un bucle no significa agregar datos al final de una l√≠nea existente, sino crear una <strong>nueva</strong> l√≠nea con cada pasada.  Si se equivoca, no se desanime: la "Idea" le advertir√° inmediatamente sobre el peligro, y el "Sonar" seguramente inundar√° su asamblea. </p><br><p>  Pero este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo</a> atraer√° mucha menos atenci√≥n, y la Idea ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">antes de la versi√≥n 2018.2</a> ) permanecer√° en silencio: </p><br><pre> <code class="java hljs">Long total = <span class="hljs-number"><span class="hljs-number">0L</span></span>; List&lt;Long&gt; totals = query.getResultList(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long element : totals) { total += element == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : element; }</code> </pre> <br><p>  El problema aqu√≠ es el mismo: los envoltorios para tipos simples son inmutables, lo que significa agregar 5 unidades al n√∫mero de objeto significa crear un nuevo envoltorio y escribir el n√∫mero 6 en √©l. </p><br><p>  La broma aqu√≠ es la presencia en Java de dos representaciones de ciertos tipos de datos: simple y objeto, as√≠ como su transformaci√≥n autom√°tica por medio del lenguaje mismo.  Debido a esto, muchos desarrolladores novatos piensan algo como esto: "Bueno, la ejecuci√≥n de alguna manera los transforma all√≠ por s√≠ mismo, es solo un n√∫mero". </p><br><p>  De hecho, no todo es tan simple.  Tome el <a href="">punto de referencia</a> e intente agregar los n√∫meros de la manera especificada: </p><br><div class="spoiler">  <b class="spoiler_title">De repente, sali√≥ muy, muy barato (en adelante JDK 11, a menos que se indique expl√≠citamente lo contrario)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> (size) Mode Cnt Score Error Units wrapper 10 avgt 100 23,5 ¬± 0,1 ns/op wrapper 100 avgt 100 352,3 ¬± 2,1 ns/op wrapper 1000 avgt 100 4424,5 ¬± 25,2 ns/op wrapper 10 avgt 100 0 ¬± 0 B/op wrapper 100 avgt 100 1872 ¬± 0 B/op wrapper 1000 avgt 100 23472 ¬± 0 B/op</code> </pre> <br><p>  Compare con un tipo simple: </p><br><pre> <code class="plaintext hljs">primitive 10 avgt 100 6,4 ¬± 0,0 ns/op primitive 100 avgt 100 39,8 ¬± 0,1 ns/op primitive 1000 avgt 100 252,5 ¬± 1,3 ns/op primitive 10 avgt 100 0 ¬± 0 B/op primitive 100 avgt 100 0 ¬± 0 B/op primitive 1000 avgt 100 0 ¬± 0 B/op</code> </pre> </div></div><br><p>  De aqu√≠ derivamos una de las definiciones de minas bajo rendimiento: este es un c√≥digo que no llama la atenci√≥n, no es detectado (al menos en el momento en que lo encontraste) por analizadores est√°ticos, pero puede ralentizarse en algunos usos.  En nuestro caso, mientras que la suma no excede 127, los objetos se toman del cach√© y <code>Long</code> solo 4 veces m√°s lento que <code>long</code> .  Sin embargo, para una matriz de tama√±o 100, la velocidad es casi 10 veces menor. </p><br><h4 id="bolshie-melochi">  Peque√±as cosas grandes </h4><br><p>  A veces, un peque√±o cambio, que <em>casi</em> no cambia el significado de la ejecuci√≥n, en <em>algunas</em> circunstancias se convierte en un freno fuerte. </p><br><p>  Supongamos que tenemos un c√≥digo: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.data.convert.CustomConversions$ConversionTargetsCache Map&lt;Object, TypeInformation&lt;?&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { TypeInformation&lt;?&gt; info = cache.get(alias); if (info == null) { info = getAlias.apply(alias); cache.put(alias, info); } return info; }</span></span></code> </pre> <br><p>  ¬øC√≥mo se ve la l√≥gica del m√©todo? </p><br><div class="spoiler">  <b class="spoiler_title">No te apresures a espiar, piensa</b> <div class="spoiler_text"><p>  Este es <code>ConcurrentHashMap::computeIfAbsent</code> ! </p></div></div><br><p>  Tenemos el "ocho" y podemos mejorar fr√≠amente el c√≥digo: reemplace 6 l√≠neas con una, haciendo que el c√≥digo sea m√°s corto y f√°cil de entender.  Por cierto, los conocedores de subprocesos <code>ConcurrentHashMap::computeIfAbsent</code> probablemente se√±alar√°n una mejora m√°s que <code>ConcurrentHashMap::computeIfAbsent</code> trae consigo, pero un poco m√°s tarde;) </p><br><p>  Hagamos un gran pensamiento realidad: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.data.convert.CustomConversions$ConversionTargetsCache Map&lt;Object, TypeInformation&lt;?&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { return cache.computeIfAbsent(alias, getAlias); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Se reunieron, comenzaron, lloraron</b> <div class="spoiler_text"><p>  Para ver el tama√±o completo, haga clic derecho en la imagen y seleccione "Abrir imagen en una pesta√±a nueva" <br><img src="https://habrastorage.org/getpro/habr/post_images/9f0/2aa/0e0/9f02aa0e028903e85a63d08207d93509.png" alt="imagen"></p></div></div><br><p>  Si bien la aplicaci√≥n funcionaba con un hilo, todo era m√°s o menos bueno.  Las corrientes se hicieron m√°s y empeoraron significativamente.  <code>ConcurrentHashMap::computeIfAbsent</code> que <code>ConcurrentHashMap::computeIfAbsent</code> bloqueado, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">incluso si la clave <strong>ya se ha</strong> agregado al diccionario</a> .  Y esto se convirti√≥ en la raz√≥n de un gran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">error</a> en Spring Date Mongo. </p><br><p>  Puede verificar esto con una <a href="">medida</a> simple ("ocho").  Aqu√≠ est√° su conclusi√≥n: </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units 1 thread computeIfAbsent avgt 20 19,405 ¬± 0,411 ns/op getAndPut avgt 20 4,578 ¬± 0,045 ns/op 2 threads computeIfAbsent avgt 20 66,492 ¬± 2,036 ns/op getAndPut avgt 20 4,454 ¬± 0,110 ns/op 4 threads computeIfAbsent avgt 20 155,975 ¬± 8,850 ns/op getAndPut avgt 20 5,616 ¬± 2,073 ns/op 6 threads computeIfAbsent avgt 20 203,188 ¬± 10,547 ns/op getAndPut avgt 20 7,024 ¬± 0,456 ns/op 8 threads computeIfAbsent avgt 20 302,036 ¬± 31,702 ns/op getAndPut avgt 20 7,990 ¬± 0,144 ns/op</code> </pre> <br><p>  ¬øPueden los desarrolladores considerarlo claramente un error?  En mi humilde opini√≥n, no, no.  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> dice: </p><br><blockquote>  Algunos intentos de actualizaci√≥n en este mapa por otros subprocesos pueden bloquearse mientras el c√°lculo est√° en progreso, por lo que el c√°lculo debe ser breve y simple, y no debe intentar actualizar ninguna otra asignaci√≥n de este mapa </blockquote><p>  En otras palabras, <code>ConcurrentHashMap::computeIfAbsent</code> cierra la celda que contiene la clave del mundo exterior (a diferencia de <code>ConcurrentHashMap::get</code> ), lo que generalmente es cierto, ya que le permite esquivar la carrera mientras llama a un m√©todo desde diferentes hilos cuando la clave a√∫n no se ha agregado. </p><br><p>  Por otro lado, en el modo de operaci√≥n m√°s com√∫n, el c√°lculo del valor y su vinculaci√≥n con la tecla se produce solo en la primera llamada, y todas las llamadas posteriores solo devuelven el valor calculado previamente.  Por lo tanto, tiene sentido cambiar la l√≥gica para que el bloqueo se establezca solo al cambiar.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fue hecho aqu√≠</a> . </p><br><p>  En ediciones m√°s recientes (&gt; 8), <code>ConcurrentHashMap::computeIfAbsent</code> vuelto <code>ConcurrentHashMap::computeIfAbsent</code> : </p><br><pre> <code class="plaintext hljs">JDK 11 Benchmark Mode Cnt Score Error Units 1 thread computeIfAbsent avgt 20 6,983 ¬± 0,066 ns/op getAndPut avgt 20 5,291 ¬± 1,220 ns/op 2 threads computeIfAbsent avgt 20 7,173 ¬± 0,249 ns/op getAndPut avgt 20 5,118 ¬± 0,395 ns/op 4 threads computeIfAbsent avgt 20 7,991 ¬± 0,447 ns/op getAndPut avgt 20 5,270 ¬± 0,366 ns/op 6 threads computeIfAbsent avgt 20 11,919 ¬± 0,865 ns/op getAndPut avgt 20 7,249 ¬± 0,199 ns/op 8 threads computeIfAbsent avgt 20 14,360 ¬± 0,892 ns/op getAndPut avgt 20 8,511 ¬± 0,229 ns/op</code> </pre> <br><p>  Preste atenci√≥n a lo insidioso de este ejemplo: el contenido sem√°ntico no <em>ha</em> cambiado mucho, porque a primera vista simplemente usamos una sintaxis m√°s avanzada.  Al mismo tiempo, mientras la aplicaci√≥n se ejecuta en un hilo, ¬°el usuario casi no siente la diferencia!  As√≠ es como los cambios aparentemente inofensivos <del>  el cerdo </del>  m√≠a bajo nuestro desempe√±o. </p><br><div class="spoiler">  <b class="spoiler_title">Por qu√© escrib√≠ 'casi sin cambios'</b> <div class="spoiler_text"><p>  <code>ConcurrentHashMap::computeIfAbsent</code> no siempre es intercambiable con la expresi√≥n <code>getAndPut</code> , porque <code>ConcurrentHashMap::computeIfAbsent</code> es una operaci√≥n at√≥mica.  En el mismo c√≥digo </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { TypeInformation&lt;?&gt; info = cache.get(alias); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { info = getAlias.apply(alias); cache.put(alias, info); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> info; }</code> </pre> <br><p>  Debido a la falta de sincronizaci√≥n externa <strong>, aparece una carrera</strong> .  Si la funci√≥n pasada a <code>ConcurrentHashMap::computeIfAbsent</code> para la clave dada siempre devuelve el mismo valor, entonces esta es una carrera "segura", lo m√°ximo que enfrentamos es calcular el mismo valor 2 o m√°s veces.  Si no existen tales garant√≠as, entonces un reemplazo mec√°nico est√° plagado de un desglose de la aplicaci√≥n.  Ten cuidado </p></div></div><br><h4 id="eti-ruki-nichego-ne-menyali">  Estas manos no cambiaron nada </h4><br><p>  Tambi√©n sucede que el c√≥digo no cambia en absoluto, pero de repente comienza a disminuir. </p><br><p>  Imagine que nos enfrentamos a la tarea de mover los elementos de una matriz a una colecci√≥n.  Lo m√°s l√≥gico ser√≠a usar el <code>Collection::addAll</code> listo para usar, pero aqu√≠ est√° la mala suerte: acepta la colecci√≥n: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span></span>; }</code> </pre> <br><p>  La forma m√°s f√°cil es envolver la matriz en <code>Arrays::asList</code> .  Resultara algo como </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection.addAll(Arrays.asList(items)); }</code> </pre> <br><p>  Durante la revisi√≥n, los colegas conscientes del rendimiento probablemente nos dir√°n que hay dos problemas en este c√≥digo a la vez: </p><br><ul><li>  envolver una matriz en una lista (objeto adicional) </li><li>  crear un iterador (otro objeto extra) y pasarlo </li></ul><br><p>  De hecho, en la implementaci√≥n de referencia de <code>Collection::addAll</code> veremos esto: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractCollection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> modified = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (E e : c) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (add(e)) modified = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modified; } }</code> </pre> <br><p>  Entonces se crea un iterador aqu√≠ y los elementos se ordenan con √©l.  Por lo tanto, los camaradas experimentados ofrecen su soluci√≥n: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.addAll(collection, items); }</code> </pre> <br><p>  Dentro del c√≥digo, con raz√≥n <em>parece</em> m√°s productivo: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; c, T... elements)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (T element : elements) result |= c.add(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Primero, no se crea un iterador.  En segundo lugar, el pase se realiza en el ciclo de conteo habitual, adem√°s, las matrices se ajustan bien a los cach√©s, sus elementos se ubican en la memoria secuencialmente (lo que significa que habr√° pocos errores de cach√©) y el acceso a ellos por √≠ndice es muy r√°pido.  Bueno, tampoco se crea una lista de contenedor.  Suena bien y suena. </p><br><p>  Finalmente, los colegas citan ultima ratio regum: documentaci√≥n.  Y all√≠, gris sobre blanco (o verde sobre negro) dice: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * ... * The behavior of this convenience method is identical to that of * c.addAll(Arrays.asList(elements)), but this method is likely * to run significantly faster under most implementations. &lt;---- * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@since</span></span></span><span class="hljs-comment"> 1.5 */</span></span> <span class="hljs-meta"><span class="hljs-meta">@SafeVarargs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; c, T... elements)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  Es decir, los propios desarrolladores (¬øy a qui√©n deber√≠an creer, si no a ellos?) Escriba que para la mayor√≠a de las implementaciones el m√©todo de utilidad funciona <em>mucho</em> m√°s r√°pido.  Y √©l es realmente m√°s r√°pido.  A veces </p><br><p>  El <a href="">punto de referencia</a> , que <code>HashSet</code> para el <code>HashSet</code> en el G8, ayudar√° a <code>HashSet</code> : </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units addAll HashSet 10 avgt 100 155,2 ¬± 2,8 ns/op addAll HashSet 100 avgt 100 1884,4 ¬± 37,4 ns/op addAll HashSet 1000 avgt 100 17917,3 ¬± 298,8 ns/op collectionsAddAll HashSet 10 avgt 100 136,1 ¬± 0,8 ns/op collectionsAddAll HashSet 100 avgt 100 1538,3 ¬± 31,4 ns/op collectionsAddAll HashSet 1000 avgt 100 15168,6 ¬± 289,4 ns/op</code> </pre> <br><p>  Parece que los camaradas m√°s experimentados ten√≠an raz√≥n.  Casi. </p><br><p>  En ediciones posteriores (por ejemplo, en 11) la brillantez del m√©todo de utilidad se desvanecer√° un poco: </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units addAll HashSet 10 avgt 100 143,1 ¬± 0,6 ns/op addAll HashSet 100 avgt 100 1738,4 ¬± 7,3 ns/op addAll HashSet 1000 avgt 100 16853,9 ¬± 101,0 ns/op collectionsAddAll HashSet 10 avgt 100 132,1 ¬± 1,1 ns/op collectionsAddAll HashSet 100 avgt 100 1661,1 ¬± 7,1 ns/op collectionsAddAll HashSet 1000 avgt 100 15450,9 ¬± 93,9 ns/op</code> </pre> <br><p>  Se puede ver que no estamos hablando de ninguno "mucho m√°s r√°pido".  Y si repetimos el experimento para <code>ArrayList</code> -a, entonces resulta que el m√©todo de utilidad comienza a perder mucho (cuanto m√°s fuerte es): </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units JDK 8 addAll ArrayList 10 avgt 100 38,5 ¬± 0,5 ns/op addAll ArrayList 100 avgt 100 188,4 ¬± 7,0 ns/op addAll ArrayList 1000 avgt 100 1278,8 ¬± 42,9 ns/op collectionsAddAll ArrayList 10 avgt 100 62,7 ¬± 0,7 ns/op collectionsAddAll ArrayList 100 avgt 100 495,1 ¬± 2,0 ns/op collectionsAddAll ArrayList 1000 avgt 100 4892,5 ¬± 48,0 ns/op JDK 11 addAll ArrayList 10 avgt 100 26,1 ¬± 0,0 ns/op addAll ArrayList 100 avgt 100 161,1 ¬± 0,4 ns/op addAll ArrayList 1000 avgt 100 1276,7 ¬± 3,7 ns/op collectionsAddAll ArrayList 10 avgt 100 41,6 ¬± 0,0 ns/op collectionsAddAll ArrayList 100 avgt 100 492,6 ¬± 1,5 ns/op collectionsAddAll ArrayList 1000 avgt 100 6792,7 ¬± 165,5 ns/op</code> </pre> <br><p>  Aqu√≠ no hay nada inesperado, <code>ArrayList</code> construido alrededor de una matriz, por lo que los desarrolladores han redefinido con visi√≥n de <code>Collection::addAll</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ Object[] a = c.toArray(); modCount++; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numNew = a.length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numNew == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; Object[] elementData; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numNew &gt; (elementData = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementData).length - (s = size)) elementData = grow(s + numNew); System.arraycopy(a, <span class="hljs-number"><span class="hljs-number">0</span></span>, elementData, s, numNew); &lt;---    size = s + numNew; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre> <br><p>  Ahora de vuelta a nuestras minas.  Supongamos que, sin embargo, aceptamos la soluci√≥n propuesta para la correcci√≥n de pruebas y dejamos este c√≥digo: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.addAll(collection, items); }</code> </pre> <br><p>  Por el momento, todo est√° bien, pero despu√©s de agregar una nueva funcionalidad, el m√©todo a veces se calienta y comienza a disminuir.  Abrimos c√≥digos fuente, el c√≥digo no cambi√≥.  La cantidad de datos es la misma.  Y el rendimiento se hundi√≥ mucho.  Este es otro tipo de mina. </p><br><p>  Descubre el depurador y encuentra lo hermoso: </p><br><p><img src="https://habrastorage.org/webt/nw/og/mu/nwogmu0_mvl-ix_hdyoxdaoydik.png"></p><br><p>  Tenga en cuenta: no cambiamos el algoritmo, la cantidad de datos procesados ‚Äã‚Äãno cambi√≥, pero su naturaleza cambi√≥ y se inici√≥ un problema de rendimiento en nuestro c√≥digo: </p><br><pre> <code class="plaintext hljs"> Java 8 Java 11  addAll 10 56,9 25,2 ns/op collectionsAddAll 10 352,2 142,9 ns/op addAll 100 159,9 84,3 ns/op collectionsAddAll 100 4607,1 3964,3 ns/op addAll 1000 1244,2 760,2 ns/op collectionsAddAll 1000 355796,9 364677,0 ns/op</code> </pre> <br><p>  En matrices grandes, la diferencia entre <code>Collections::addAll</code> y <code>Collection::addAll</code> es modesta 500 veces.  El hecho es que <code>COWList</code> no solo expande la matriz existente, sino que crea una nueva cada vez que se agregan elementos: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (lock) { Object[] es = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = es.length; es = Arrays.copyOf(es, len + <span class="hljs-number"><span class="hljs-number">1</span></span>); &lt;----    es[len] = e; setArray(es); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } }</code> </pre> <br><p><del>  ¬øQui√©n tiene la culpa? </del></p><br><div class="spoiler">  <b class="spoiler_title">Que hacer</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://bugs.openjdk.java.net/browse/JDK-8193031</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://cr.openjdk.java.net/~martin/webrevs/jdk/Collections-addAll/</a> </p></div></div><br><p>  El principal problema aqu√≠ es que el <code>Collections::addAll</code> acepta una interfaz, mientras que el m√©todo <code>addAll</code> no <code>addAll</code> cuerpo.  Sin cuerpo: sin negocio, por lo tanto, la documentaci√≥n est√° escrita en base a la implementaci√≥n existente en <code>AbstractCollection::addAll</code> , que es un algoritmo generalizado aplicable a todas las colecciones.  Esto significa que implementaciones m√°s espec√≠ficas de estructuras de datos que est√°n en un nivel inferior de abstracci√≥n pueden alterar este comportamiento. </p><br><div class="spoiler">  <b class="spoiler_title">Ahora humanamente</b> <div class="spoiler_text"><pre> <code class="java hljs"> Collection::addAll ‚Äì   AbstractCollection::addAll ‚Äì   &lt;---    ArrayList::addAll HashSet::addAll ‚Äì   &lt;---      COWList::addAll</code> </pre> </div></div><br><h4 id="eschyo-ob-abstrakciyah">  M√°s sobre abstracciones </h4><br><p>  Como estamos hablando de los niveles de abstracci√≥n, te contar√© un ejemplo de la vida. </p><br><p>  Comparemos estas dos formas de guardar el en√©simo n√∫mero de entidades en la base de datos: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.save(e); } } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.saveAndFlush(e); } }</code> </pre> <br><p>  A primera vista, el rendimiento de ambos m√©todos no deber√≠a ser muy diferente, porque </p><br><ul><li>  en ambos casos se almacenar√° el mismo n√∫mero de entidades en la base de datos </li><li>  Si la clave se toma de la secuencia, el n√∫mero de llamadas ser√° el mismo. </li><li>  la cantidad de datos transferidos es la misma </li></ul><br><p>  <code>SimpleJpaRepository::saveAndFlush</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInformation.isNew(entity)) { em.persist(entity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entity; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.merge(entity); } } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveAndFlush</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ S result = save(entity); flush(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flush</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ em.flush(); }</code> </pre> <br><p>  El punto oscuro aqu√≠ es el m√©todo <code>flush()</code> .  ¬øPor qu√© tonto?  Me parece que su divulgaci√≥n en la interfaz <code>JpaRepository</code> fue un error de los desarrolladores.  Tratar√© de justificar mi pensamiento.  Por lo general, el desarrollador no utiliza este m√©todo en absoluto, porque la llamada a <code>EntityManager::flush</code> vinculada a la finalizaci√≥n de una transacci√≥n controlada por Spring: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     @Transactional public void method() { &lt;--  Session::open /*.*/ } &lt;--  Session::flush</span></span></code> </pre> <br><p>  Tenga en cuenta: <code>EntityManager</code> es parte de la especificaci√≥n <code>JPA</code> implementada en Hibernate como una sesi√≥n (interfaz de sesi√≥n y clase SessionImpl, respectivamente).  Spring Date es un marco que se ejecuta sobre un ORM, en este caso, sobre Hibernate.  Resulta que el <code>JpaRepository::saveAndFlush</code> nos da acceso a los niveles inferiores de la API, aunque la tarea del marco es ocultar los detalles de bajo nivel (la situaci√≥n es algo similar a la historia insegura en el JDK). <br>  En nuestro caso, cuando usamos <code>JpaRepository::saveAndFlush</code> nos <code>JpaRepository::saveAndFlush</code> en las capas inferiores de la aplicaci√≥n, rompiendo as√≠ algo. </p><br><div class="spoiler">  <b class="spoiler_title">T√≥mate tu tiempo para mirar, piensa por ti mismo</b> <div class="spoiler_text"><p>  La capacidad de Hibernate para enviar datos en lotes est√° rota, un m√∫ltiplo de la configuraci√≥n <code>jdbc.batch_size</code> , que se especifica en <code>application.yml</code> : </p><br><pre> <code class="plaintext hljs">spring: jpa: properties: hibernate: jdbc.batch_size: 500</code> </pre> <br><p>  El trabajo de Hibernate se basa en eventos, por lo que cuando guarda 1000 entidades como esta </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.save(e); } }</code> </pre> <br><p>  llamar a <code>repository.save(e)</code> no guarda instant√°neamente.  En su lugar, se crea un evento que est√° en cola.  Una vez completada la transacci√≥n, los datos se fusionan utilizando <code>EntityManager::flush</code> , que divide las inserciones / actualizaciones en paquetes m√∫ltiples de <code>jdbc.batch_size</code> y crea solicitudes a partir de ellas.  En nuestro caso, <code>jdbc.batch_size: 500</code> , por lo que guardar 1000 entidades en realidad significa solo 2 solicitudes. </p><br><p>  Pero con una descarga manual de la sesi√≥n en cada paso del ciclo </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.saveAndFlush(e); } }</code> </pre> <br><p>  la cola se borra y guardar 1000 entidades significa 1000 consultas. </p></div></div><br><p>  Por lo tanto, interferir con las capas inferiores de la aplicaci√≥n puede convertirse f√°cilmente en una mina, y no solo en una mina de productividad (vea Inseguro y su uso incontrolado). </p><br><p>  ¬øCu√°nto se ralentiza?  Tomemos el mejor caso (para nosotros): la base de datos est√° en el mismo host que la aplicaci√≥n.  Mi <a href="">medida</a> muestra la siguiente imagen: </p><br><pre> <code class="plaintext hljs"> (entityCount) Mode Cnt Score Error Units bulkSave 10 ss 500 16,613 ¬± 1,714 ms/op bulkSave 100 ss 500 31,371 ¬± 1,453 ms/op bulkSave 1000 ss 500 35,687 ¬± 1,973 ms/op bulkSaveUsingFlush 10 ss 500 32,653 ¬± 2,166 ms/op bulkSaveUsingFlush 100 ss 500 61,983 ¬± 6,304 ms/op bulkSaveUsingFlush 1000 ss 500 184,814 ¬± 6,976 ms/op</code> </pre> <br><p>  Obviamente, si la base de datos se encuentra en un host remoto, el costo de la transferencia de datos degradar√° cada vez m√°s el rendimiento a medida que aumenta el volumen de datos. </p><br><p>  Por lo tanto, trabajar en el nivel incorrecto de abstracci√≥n puede crear f√°cilmente una bomba de tiempo.  Por cierto, en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uno de mis art√≠culos anteriores</a> habl√© sobre un curioso intento de mejorar <code>StringBuilder</code> -a: all√≠ no tuve √©xito al intentar ingresar a un nivel de c√≥digo m√°s abstracto. </p><br><h4 id="granicy-minnyh-poley">  Fronteras de campo minado </h4><br><p>  ¬øJuguemos a un zapador?  Encuentra el m√≠o: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); Assert.notNull(key, "Null key ..." + context.metadata.operation); // ... return key; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øLo encontraste?</b>  <b class="spoiler_title">Verifica la respuesta correcta.</b> <div class="spoiler_text"><pre> <code class="java hljs"> | \ / <span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport | \ / Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); | \ / Assert.notNull(key, "Null key ..." + context.metadata.operation); return key; }</span></span></code> </pre> </div></div><br><p>  "¬øEst√°s bromeando?", Exclama el cr√≠tico. "¬øPero solo hay un pegado de dos l√≠neas? ¬øQu√© significa esto en la sangrienta E.?"  Perm√≠tanme llamar su atenci√≥n sobre el hecho de que destaqu√© no solo el pegado de las cadenas, sino tambi√©n el nombre de la clase y el nombre del m√©todo.  De hecho, el peligro de pegar cadenas no est√° en pegarse, sino en lo que sucede en el m√©todo que crea las claves para el cach√©, es decir, en ciertos escenarios tendremos muchos accesos a este m√©todo, lo que significa muchas l√≠neas de basura. <br>  Por lo tanto, se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">debe crear</a> un mensaje de error <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solo</a> cuando este error se produce realmente: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); if (key == null) { throw new IAE("Null key ..." + context.metadata.operation); } // ... return key; }</span></span></code> </pre> <br><p>  Por lo tanto, los campos minados tienen l√≠mites: esta es la cantidad de datos, la frecuencia de acceso al m√©todo, etc. indicadores cuantitativos, al alcanzar y exceder un ligero inconveniente que se vuelve estad√≠sticamente significativo. </p><br><p>  Por otro lado, esta es la caracter√≠stica hasta que la intersecci√≥n de la que complica el c√≥digo no proporcione una mejora significativa (medible). </p><br><p>  Esta es otra conclusi√≥n para el desarrollador: en la mayor√≠a de los casos, el enga√±o es malo, lo que lleva a una complicaci√≥n sin sentido del c√≥digo.  En 99 casos de cada 100, no ganamos nada. </p><br><p>  Debe recordarse que siempre hay </p><br><h4 id="tot-samyy-sotyy-sluchay">  El cent√©simo caso </h4><br><p>  Aqu√≠ est√° el c√≥digo que Nitzan Wakart da en su art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La vol√°til sorpresa de lectura</a> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoopyBenchmarks</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({ <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-string"><span class="hljs-string">"1024"</span></span>, <span class="hljs-string"><span class="hljs-string">"32768"</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bunn; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ bunn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]; } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { <span class="hljs-comment"><span class="hljs-comment">// good old C style for (the win?) fox.consume(bunn[y]); } } @Benchmark public void sweetLoop(Blackhole fox) { for (byte bunny : bunn) { // syntactic sugar loop goodness fox.consume(bunny); } } }</span></span></code> </pre> <br><p>  Cuando configuremos la experiencia, descubriremos una sorprendente diferencia entre las dos formas de iterar sobre una matriz: </p><br><pre> <code class="plaintext hljs">Benchmark (size) Score Score error Units goodOldLoop 32 46.630 0.097 ns/op goodOldLoop 1024 1199.338 0.705 ns/op goodOldLoop 32768 37813.600 56.081 ns/op sweetLoop 32 19.304 0.010 ns/op sweetLoop 1024 475.141 1.227 ns/op sweetLoop 32768 14295.800 36.071 ns/op</code> </pre> <br><p>  Aqu√≠, un desarrollador inexperto puede llegar a una conclusi√≥n tan obvia y comparada: pasar a trav√©s de una matriz usando la nueva sintaxis funciona m√°s r√°pido que un ciclo de conteo.  Esta es la conclusi√≥n incorrecta, porque vale la pena cambiar un <code>goodOldLoop</code> m√©todo <code>goodOldLoop</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoopReturns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] sunn = bunn; <span class="hljs-comment"><span class="hljs-comment">// make a local copy of the field for (int y = 0; y &lt; sunn.length; y++) { fox.consume(sunn[y]); } }</span></span></code> </pre> <br><p>  y su rendimiento es comparable al del m√©todo <code>sweetLoop</code> "m√°s r√°pido": </p><br><pre> <code class="plaintext hljs">Benchmark (size) Score Score error Units goodOldLoopReturns 32 19.306 0.045 ns/op goodOldLoopReturns 1024 476.493 1.190 ns/op goodOldLoopReturns 32768 14292.286 16.046 ns/op sweetLoop 32 19.304 0.010 ns/op sweetLoop 1024 475.141 1.227 ns/op sweetLoop 32768 14295.800 36.071 ns/op</code> </pre> <br><p>     <code>Blackhole::consume</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//... public volatile byte b1, b2; public volatile BlackholeL2 nullBait = null; /** * Consume object. This call provides a side effect preventing JIT to eliminate dependent computations. * * @param b object to consume. */ public final void consume(byte b) { if (b == b1 &amp; b == b2) { // SHOULD NEVER HAPPEN nullBait.b1 = b; // implicit null pointer exception } }</span></span></code> </pre> <br><p>         ,    ,      .     <code>goodOldLoop</code>       <code>this.bunn</code>    ,  <code>for-each</code>     ,        (,  Java Concurrency In Practice   "  ").      . </p><br><p>    : "      ?   , <code>Blackhole::consume</code> ‚Äî   JMH       .  ,  ,       ?" </p><br><p>          : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bunn; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { fox.consume(bunn[y]); } }</code> </pre> <br><p>   ? ?  ,    : </p><br><pre> <code class="java hljs">E[] bunn; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;E&gt; fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { fox.consume(bunn[y]); } }</code> </pre> <br><p>  <code>Iterable::forEach</code> !        ,   ,        ,       (   JDK 13): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//ArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); final int expectedModCount = modCount; final Object[] es = elementData; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) action.accept(elementAt(es, i)); if (modCount != expectedModCount) throw new ConcurrentModificationException(); } //Arrays$ArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); for (E e : a) { action.accept(e); } } //CopyOnWriteArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); for (Object x : getArray()) { @SuppressWarnings("unchecked") E e = (E) x; action.accept(e); } } //ArrayDeque public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); final Object[] es = elements; for (int i = head, end = tail, to = (i &lt;= end) ? end : es.length; ; i = 0, to = end) { for (; i &lt; to; i++) action.accept(elementAt(es, i)); if (to == end) { if (end != tail) throw new ConcurrentModificationException(); break; } } }</span></span></code> </pre> <br><p>     ,          . ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> <code>Collections.nCopies()::forEach</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Consumer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> E&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(action); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n; i++) { action.accept(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element); } }</code> </pre> <br><p>            , . .   <code>this.n</code>  <code>this.element</code>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CopiesList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RandomAccess</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> E element; CopiesList(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, E e) { <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> n &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n = n; element = e; }</code> </pre> <br><p>  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   </a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   </a> <code>@Stable</code> . </p><br><p>  :  99   100  ,     ,    1   100,             .     ,     . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   </a>          "  volatile". </p><br><h4 id="eho-voyny">   </h4><br><p>      ,   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//java.lang.Integer @HotSpotIntrinsicCandidate public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); }</span></span></code> </pre> <br><p> -   ,         ( <code>java.lang.Integer</code> , <code>java.lang.Long</code> , <code>java.lang.Short</code> , <code>java.lang.Byte</code> , <code>java.lang.Character</code> ).  ,     ,     </p><br><pre> <code class="java hljs">Integer intgr = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br><p>    . </p><br><p>      : </p><br><pre> <code class="java hljs">Integer intgr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br><p>        ,         ,       <code>Integer::valueOf</code>   . </p><br><p>         :      .                ,   ,      ""  (         ).   ,        ,         <code>Integer::valueOf</code> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"  "</a> . </p><br><p>   . ,              . ,       .      ,    ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443206/">https://habr.com/ru/post/443206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443196/index.html">Sin un minuto sin conexi√≥n: elegir un enrutador LTE industrial</a></li>
<li><a href="../443198/index.html">Mark Zuckerberg dice que Facebook est√° trabajando en una interfaz neuronal para leer pensamientos</a></li>
<li><a href="../443200/index.html">Los piratas inform√°ticos iran√≠es roban terabytes de datos de Citrix</a></li>
<li><a href="../443202/index.html">Rally contra el aislamiento de Runet</a></li>
<li><a href="../443204/index.html">Resumen semanal de frontend (4-10 de marzo de 2019)</a></li>
<li><a href="../443208/index.html">Rat√≥n corporativo</a></li>
<li><a href="../443210/index.html">Tutorial React Parte 21: Segunda lecci√≥n y taller de renderizado condicional</a></li>
<li><a href="../443212/index.html">Tutorial de React, Parte 22: S√©ptima etapa de trabajo en una aplicaci√≥n TODO, descargando datos de fuentes externas</a></li>
<li><a href="../443214/index.html">Tutorial de Reacci√≥n Parte 23: Lecci√≥n de los primeros formularios</a></li>
<li><a href="../443216/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 355 (del 4 al 10 de marzo de 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>