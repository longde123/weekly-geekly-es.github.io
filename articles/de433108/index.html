<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∑üèª ü•å üë®üèΩ‚ÄçüöÄ ld -z separater Code üëâüèª üòæ üéí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel konzentriert sich auf eine kleine Sicherheitsfunktion, die in GNU ld zur Version 2.30 im Dezember 2018 hinzugef√ºgt wurde. Auf Russisch ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ld -z separater Code</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/433108/"><p><img src="https://habrastorage.org/webt/mz/nr/5c/mznr5cswg58pumrqbt60sjacvg4.png"></p><br><p>  Dieser Artikel konzentriert sich auf eine kleine Sicherheitsfunktion, die in GNU ld zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 2.30</a> im Dezember 2018 hinzugef√ºgt wurde.  Auf Russisch wurde diese Verbesserung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Opennet</a> mit folgender Anmerkung erw√§hnt: </p><br><blockquote>  "-z separater Code" -Modus, der die Sicherheit ausf√ºhrbarer Dateien auf Kosten einer geringf√ºgigen Erh√∂hung der Gr√∂√üe und des Speicherverbrauchs erh√∂ht </blockquote><p>  Lass es uns herausfinden.  Um zu erkl√§ren, um welche Art von Sicherheitsproblem es sich handelt und um welche L√∂sung es sich handelt, beginnen wir mit den allgemeinen Funktionen von Exploits f√ºr bin√§re Sicherheitsl√ºcken. </p><a name="habracut"></a><br><h1 id="problemy-perehvata-potoka-upravleniya-v-eksploytah">  Probleme mit dem Kontrollfluss ausnutzen </h1><br><p>  Ein Angreifer kann Daten an das Programm √ºbertragen und auf diese Weise mithilfe verschiedener Sicherheitsanf√§lligkeiten bearbeiten: Schreiben nach Index √ºber die Grenzen eines Arrays hinaus, unsicheres Kopieren von Zeichenfolgen und Verwenden von Objekten nach der Freigabe.  Solche Fehler sind typisch f√ºr C- und C ++ - Programmcode und k√∂nnen bei bestimmten Eingabedaten f√ºr das Programm zu einer Speicherbesch√§digung f√ºhren. </p><br><div class="spoiler">  <b class="spoiler_title">Sicherheitsl√ºcken in Bezug auf Speicherbesch√§digung</b> <div class="spoiler_text"><p> CWE-20: Unsachgem√§√üe Eingabevalidierung <br>  CWE-118: Falscher Zugriff auf indizierbare Ressourcen ('Bereichsfehler') <br>  CWE-119: Unsachgem√§√üe Einschr√§nkung von Operationen innerhalb der Grenzen eines Speicherpuffers <br>  CWE-120: Pufferkopie ohne √úberpr√ºfung der Eingabegr√∂√üe ('Klassischer Puffer√ºberlauf') <br>  CWE-121: Stapelbasierter Puffer√ºberlauf <br>  CWE-122: Heap-basierter Puffer√ºberlauf <br>  CWE-123: Write-what-where-Bedingung <br>  CWE-124: Buffer Underwrite ('Buffer Underflow') <br>  CWE-125: Lesen au√üerhalb der Grenzen <br>  CWE-126: Puffer√ºberlesen <br>  CWE-127: Puffer unterlesen <br>  CWE-128: Umlauffehler <br>  CWE-129: Unsachgem√§√üe Validierung des Array-Index <br>  CWE-130: Unsachgem√§√üe Behandlung von Inkonsistenzen bei L√§ngenparametern <br>  CWE-131: Falsche Berechnung der Puffergr√∂√üe <br>  CWE-134: Verwendung einer extern gesteuerten Formatzeichenfolge <br>  CWE-135: Falsche Berechnung der Multi-Byte-Stringl√§nge <br>  CWE-170: Unsachgem√§√üe Nullbeendigung <br>  CWE-190: Integer Overflow oder Wraparound <br>  CWE-415: Double Free <br>  CWE-416: Nach kostenlos verwenden <br>  CWE-476: NULL-Zeiger-Dereferenzierung <br>  CWE-787: Schreiben au√üerhalb der Grenzen <br>  CWE-824: Zugriff auf nicht initialisierten Zeiger <br>  ... </p></div></div><br><p>  Das klassische Exploit-Element speicherbesch√§digungs√§hnlicher Sicherheitsl√ºcken ist das √úberschreiben eines Zeigers im Speicher.  Der Zeiger wird dann vom Programm verwendet, um die Steuerung auf einen anderen Code zu √ºbertragen: eine Klassenmethode oder -funktion von einem anderen Modul aufzurufen, von einer Funktion zur√ºckzukehren.  Und da der Zeiger √ºberschrieben wurde, wird die Kontrolle vom Angreifer abgefangen - das hei√üt, der von ihm vorbereitete Code wird ausgef√ºhrt.  Wenn Sie an Variationen und Details dieser Techniken interessiert sind, empfehlen wir Ihnen, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokument zu</a> lesen. </p><br><p>  Dieser gemeinsame Moment des Betriebs solcher Exploits ist bekannt, und hier f√ºr den Angreifer sind die Barrieren seit langem gesetzt: </p><br><ol><li>  √úberpr√ºfen der Integrit√§t von Zeigern vor dem √úbergeben der Kontrolle: Stapel-Cookies, Kontrollflussschutz, Zeigerauthentifizierung </li><li>  Randomisierung von Segmentadressen mit Code und Daten: Randomisierung des Adressraumlayouts </li><li>  Verhindern, dass Code au√üerhalb von Codesegmenten ausgef√ºhrt wird: Schutz des ausf√ºhrbaren Speicherplatzes </li></ol><br><p>  Als n√§chstes konzentrieren wir uns auf den Schutz des letzteren Typs. </p><br><h1 id="executable-space-protection">  ausf√ºhrbarer Speicherplatzschutz </h1><br><p>  Der Programmspeicher ist heterogen und in Segmente mit unterschiedlichen Rechten unterteilt: Lesen, Schreiben und Ausf√ºhren.  Dies wird durch die F√§higkeit des Prozessors sichergestellt, Speicherseiten mit Zugriffsflags in Seitentabellen zu markieren.  Die Idee des Schutzes basiert auf einer strikten Trennung von Code und Daten: Die vom Angreifer w√§hrend des Verarbeitungsprozesses empfangenen Daten sollten in <strong>nicht ausf√ºhrbaren</strong> Segmenten (Stapel, Heap) und der Code des Programms selbst in separaten <strong>unver√§nderlichen</strong> Segmenten <strong>abgelegt werden</strong> .  Dies sollte dem Angreifer daher die M√∂glichkeit nehmen, Fremdcode im Speicher abzulegen und auszuf√ºhren. </p><br><p>  Um das Verbot der Codeausf√ºhrung in Datensegmenten zu umgehen, werden Techniken zur Wiederverwendung von Code verwendet.  Das hei√üt, der Angreifer √ºbertr√§gt die Kontrolle auf die Codefragmente (im Folgenden als Gadgets bezeichnet), die sich auf den ausf√ºhrbaren Seiten befinden.  Techniken dieser Art sind in aufsteigender Reihenfolge von unterschiedlicher Schwierigkeit: </p><br><ul><li>  √úbertragen der Kontrolle an eine Funktion, die das tut, was f√ºr den Angreifer ausreicht: an die Funktion system () mit einem kontrollierten Argument zum Ausf√ºhren beliebiger Shell-Befehle (ret2libc) </li><li> √úbertragen der Steuerung an eine Funktion oder Kette von Gadgets, die den Schutz deaktivieren oder einen Teil des Speichers ausf√ºhrbar machen (z. B. Aufrufen von <code>mprotect()</code> ), gefolgt von der Ausf√ºhrung von beliebigem Code </li><li>  Ausf√ºhrung aller gew√ºnschten Aktionen mit einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://web.archive.org/web/20170325014927/">langen Kette von Gadgets</a> </li></ul><br><p>  Somit steht der Angreifer vor der Aufgabe, den vorhandenen Code in dem einen oder anderen Volume wiederzuverwenden.  Wenn dies etwas komplizierter ist als die R√ºckkehr zu einer einzelnen Funktion, ist eine <em>Reihe von Gadgets</em> erforderlich.  Um nach Gadgets nach ausf√ºhrbaren Segmenten zu suchen, gibt es folgende Tools: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ropper</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ropgadget</a> . </p><br><h2 id="dyra-read_implies_exec">  Loch READ_IMPLIES_EXEC </h2><br><p>  Manchmal k√∂nnen jedoch Speicherbereiche mit Daten ausf√ºhrbar sein, und die oben beschriebenen Prinzipien der Trennung von Code und Daten werden eindeutig verletzt.  In solchen F√§llen bleibt dem Angreifer die M√ºhe erspart, Gadgets oder Funktionen zur Wiederverwendung des Codes zu finden.  Ein interessanter Fund dieser Art war der ausf√ºhrbare Stack und alle Datensegmente auf derselben ‚ÄûIndustrial Firewall‚Äú. </p><br><p>  Listing <code>/proc/$pid/maps</code> : </p><br><pre> <code class="plaintext hljs">00008000-00009000 r-xp 00000000 08:01 10 /var/flash/dmt/nx_test/a.out 00010000-00011000 rwxp 00000000 08:01 10 /var/flash/dmt/nx_test/a.out 00011000-00032000 rwxp 00000000 00:00 0 [heap] 40000000-4001f000 r-xp 00000000 1f:02 429 /lib/ld-linux.so.2 4001f000-40022000 rwxp 00000000 00:00 0 40027000-40028000 r-xp 0001f000 1f:02 429 /lib/ld-linux.so.2 40028000-40029000 rwxp 00020000 1f:02 429 /lib/ld-linux.so.2 4002c000-40172000 r-xp 00000000 1f:02 430 /lib/libc.so.6 40172000-40179000 ---p 00146000 1f:02 430 /lib/libc.so.6 40179000-4017b000 r-xp 00145000 1f:02 430 /lib/libc.so.6 4017b000-4017c000 rwxp 00147000 1f:02 430 /lib/libc.so.6 4017c000-40b80000 rwxp 00000000 00:00 0 be8c2000-be8d7000 rwxp 00000000 00:00 0 [stack]</code> </pre> <br><p>  Hier sehen Sie die Speicherkarte des Testdienstprogramms.  Eine Karte besteht aus Speicherbereichen - Tabellenzeilen.  Achten Sie zun√§chst auf die rechte Spalte - sie erkl√§rt den Inhalt des Bereichs (Codesegmente, Daten von Funktionsbibliotheken oder des Programms selbst) oder seinen Typ (Heap, Stack).  Auf der linken Seite befindet sich in der angegebenen Reihenfolge der Adressbereich, den jeder Speicherbereich belegt, und au√üerdem die Zugriffsrechte-Flags: r (Lesen), w (Schreiben), x (Ausf√ºhren).  Diese Flags bestimmen das Verhalten des Systems beim Versuch, Speicher an diesen Adressen zu lesen, zu schreiben und auszuf√ºhren.  Wenn der angegebene Zugriffsmodus verletzt wird, wird eine Ausnahme ausgel√∂st. </p><br><p>  Beachten Sie, dass fast der gesamte Speicher im Prozess ausf√ºhrbar ist: der Stapel, der Heap und alle Datensegmente.  Das ist ein Problem.  Offensichtlich erleichtert das Vorhandensein von rwx-Speicherseiten einem Angreifer das Leben, da er <strong>seinen</strong> Code in einem solchen Prozess an jedem Ort frei ausf√ºhren kann, an dem sein Code beim √úbertragen von Daten (Paketen, Dateien) an ein solches Programm zur Verarbeitung abgerufen wird. </p><br><p>  Warum ist eine solche Situation bei einem modernen Ger√§t aufgetreten, das das Verbot der Codeausf√ºhrung auf Datenseiten mit Hardware unterst√ºtzt, h√§ngt die Sicherheit von Unternehmens- und Industrienetzwerken vom Ger√§t ab, und das Problem und seine L√∂sung sind seit langem bekannt? </p><br><p>  Dieses Bild wird durch das Verhalten des Kernels w√§hrend der Initialisierung des Prozesses (Zuweisen eines Stapels, Heaps, Laden des Haupt-ELF usw.) und w√§hrend der Ausf√ºhrung der Aufrufe des Kernprozesses bestimmt.  Das Schl√ºsselattribut, das dies beeinflusst, ist das Pers√∂nlichkeitsflag <code>READ_IMPLIES_EXEC</code> .  Dieses Flag bewirkt, dass jeder lesbare Speicher auch ausf√ºhrbar wird.  Ein Flag kann aus mehreren Gr√ºnden f√ºr Ihren Prozess gesetzt werden: </p><br><ol><li>  Legacy kann explizit vom Software-Flag im ELF-Header angefordert werden, um einen sehr interessanten Mechanismus zu implementieren: ein Sprungbrett auf dem Stapel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> )! </li><li>  Es kann von untergeordneten Prozessen vom √ºbergeordneten Prozess geerbt werden. </li><li>  Es kann vom Kernel unabh√§ngig f√ºr alle Prozesse installiert werden!  Erstens, wenn die Architektur keinen nicht ausf√ºhrbaren Speicher unterst√ºtzt.  Zweitens, nur f√ºr den Fall, einige andere <a href="">alte Kr√ºcken</a> zu st√ºtzen.  Dieser Code befindet sich im Kernel 2.6.32 (ARM), der eine sehr lange Lebensdauer hatte.  Dies war nur unser Fall. </li></ol><br><h1 id="prostranstvo-dlya-poiska-gadzhetov-v-obraze-elf">  Platz zum Auffinden von Gadgets in einem ELF-Bild </h1><br><p>  Funktionsbibliotheken und ausf√ºhrbare Programmdateien liegen im ELF-Format vor.  Der gcc-Compiler √ºbersetzt Sprachkonstrukte in Maschinencode und f√ºgt sie in einen Abschnitt und die Daten, die dieser Code verarbeitet, in andere Abschnitte ein.  Es gibt viele Abschnitte, die vom ld-Linker in Segmente gruppiert werden.  Somit enth√§lt ELF ein Programmbild, das zwei Darstellungen aufweist: eine Tabelle mit Abschnitten und eine Tabelle mit Segmenten. </p><br><pre> <code class="plaintext hljs">$ readelf -l /bin/ls Elf file type is EXEC (Executable file) Entry point 0x804bee9 There are 9 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x08048034 0x08048034 0x00120 0x00120 RE 0x4 INTERP 0x000154 0x08048154 0x08048154 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x08048000 0x08048000 0x1e40c 0x1e40c RE 0x1000 LOAD 0x01ef00 0x08067f00 0x08067f00 0x00444 0x01078 RW 0x1000 DYNAMIC 0x01ef0c 0x08067f0c 0x08067f0c 0x000f0 0x000f0 RW 0x4 NOTE 0x000168 0x08048168 0x08048168 0x00044 0x00044 R 0x4 GNU_EH_FRAME 0x018b74 0x08060b74 0x08060b74 0x00814 0x00814 R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 GNU_RELRO 0x01ef00 0x08067f00 0x08067f00 0x00100 0x00100 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame 03 .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 04 .dynamic 05 .note.ABI-tag .note.gnu.build-id 06 .eh_frame_hdr 07 08 .init_array .fini_array .jcr .dynamic .got</code> </pre> <br><p>  Hier sehen Sie die Zuordnung von Abschnitten zu Segmenten in einem ELF-Bild. </p><br><p>  Die <strong>Abschnittstabelle</strong> wird von Dienstprogrammen zum Analysieren von Programmen und Bibliotheken verwendet, von Ladern jedoch nicht zum Projizieren von ELFs in den Prozessspeicher.  Die Abschnittstabelle beschreibt die ELF-Struktur detaillierter als die Segmenttabelle.  Innerhalb eines Segments k√∂nnen sich mehrere Abschnitte befinden. </p><br><p>  Ein speicherinternes ELF-Bild wird von ELF-Ladern basierend auf dem Inhalt der <strong>Segmenttabelle erstellt</strong> .  Die <strong>Partitionstabelle</strong> wird nicht mehr zum Laden von ELF in den Speicher verwendet. </p><br><div class="spoiler">  <b class="spoiler_title">Es gibt jedoch Ausnahmen von dieser Regel.</b> <div class="spoiler_text"><p>  In der Natur gibt es beispielsweise einen Debian-Entwickler-Patch f√ºr den ELF ld.so-Loader f√ºr die ARM-Architektur, der nach einem speziellen Abschnitt ".ARM.attributes" wie <a href="">SHT_ARM_ATTRIBUTES sucht,</a> und Bin√§rdateien mit einer abges√§gten Abschnittstabelle in einem solchen System werden nicht geladen ... </p></div></div><br><p>  Ein ELF-Segment verf√ºgt √ºber Flags, die bestimmen, welche Berechtigungen das Segment im Speicher haben wird.  Traditionell wurde der gr√∂√üte Teil der Software f√ºr GNU / Linux so erstellt, dass zwei <code>PT_LOAD</code> Segmente (im Speicher <code>PT_LOAD</code> ) in der Segmenttabelle deklariert wurden - wie in der obigen Auflistung: </p><br><ol><li><p>  Segment mit <code>RE</code> Flags </p><br><p>  1.1.  <strong>Ausf√ºhrbarer</strong> ELF-Code: Abschnitte <code>.init</code> , <code>.text</code> , <code>.fini</code> </p><br><p>  1.2.  <strong>Unver√§nderliche</strong> Daten in ELF: <code>.rodata</code> <code>.symtab</code> , <code>.rodata</code> </p><br></li><li><p>  Segment <code>RW</code> Flaggen </p><br><p>  2.1.  <strong>Variable</strong> Daten in ELF: Abschnitte <code>.plt</code> , <code>.got</code> , <code>.data</code> , <code>.bss</code> </p><br></li></ol><br><p>  Wenn Sie auf die Zusammensetzung des ersten Segments und seiner Zugriffsflags achten, wird deutlich, dass ein solches Layout den Platz f√ºr die Suche nach Gadgets f√ºr Techniken zur Wiederverwendung von Code erweitert.  In gro√üen ELFs wie libcrypto k√∂nnen Servicetabellen und andere unver√§nderliche <strong>Daten</strong> bis zu 40% des <strong>ausf√ºhrbaren</strong> Segments einnehmen.  Das Vorhandensein von etwas √§hnlichem wie Codeteilen in diesen Daten wird durch Versuche best√§tigt, solche Bin√§rdateien mit einer gro√üen Datenmenge im ausf√ºhrbaren Segment ohne Abschnittstabellen und Symbole zu zerlegen.  Jede Folge von Bytes in diesem einzelnen ausf√ºhrbaren Segment kann als n√ºtzlich f√ºr das angreifende Fragment von Maschinencode und Sprungbrett angesehen werden - sei es diese Folge von Bytes mit mindestens einem Teil der Zeile der Debugging-Nachricht aus dem Programm, einem Teil des Funktionsnamens in der Symboltabelle oder der konstanten Anzahl des kryptografischen Algorithmus ... </p><br><div class="spoiler">  <b class="spoiler_title">Ausf√ºhrbare PE-Header</b> <div class="spoiler_text"><p>  Die ausf√ºhrbaren Header und Tabellen am Anfang des ersten Abschnitts des ELF-Images √§hneln der Situation mit Windows vor etwa 15 Jahren.  Es gab eine Reihe von Viren, die Dateien infizierten und ihren Code in ihren PE-Header schrieben, der auch dort ausf√ºhrbar war.  Ich habe es geschafft, ein solches Beispiel im Archiv zu finden: </p><br><p><img src="https://habrastorage.org/webt/gy/kt/7t/gykt7t5znycwstjaek_cdoo_xvm.png" alt="Virus.Win32.Haless.1127"></p><br><p>  Wie Sie sehen k√∂nnen, wird der Virusk√∂rper direkt nach der Abschnittstabelle im Bereich der PE-Header gequetscht.  Bei einer Projektion einer Datei auf den virtuellen Speicher stehen hier normalerweise etwa 3 KB freier Speicherplatz zur Verf√ºgung.  Nach dem K√∂rper des Virus gibt es ein leeres Feld und dann beginnt der erste Abschnitt mit dem Programmcode. </p><br><p>  F√ºr Linux gab es jedoch viel interessantere Werke der VX-Szene: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergeltung</a> . </p></div></div><br><h1 id="reshenie">  L√∂sung </h1><br><ul><li>  Das oben beschriebene Problem ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seit langem</a> bekannt. </li><li>  Behoben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">12. Januar 2018</a> : Der Schl√ºssel `ld -z separater Code:" Separaten Code erstellen "PT_LOAD" Segment-Header im Objekt wird hinzugef√ºgt. Dies gibt ein Speichersegment an, das nur Anweisungen enthalten sollte und sich in vollst√§ndig getrennten Seiten von anderen Daten befinden muss. Erstellen Sie kein separates Code-Segment "PT_LOAD", wenn Noseparate-Code verwendet wird. ").  Die Funktion wurde in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 2.30 ver√∂ffentlicht</a> . </li><li>  Dar√ºber hinaus war diese Funktion in der n√§chsten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 2.31</a> standardm√§√üig enthalten. </li><li>  Pr√§sentiert in frischen <code>binutils</code> Paketen, zum Beispiel in den Ubuntu 18.10-Repositorys.  Viele Pakete wurden bereits mit dieser neuen Funktion zusammengestellt, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ElfMaster-</a> Forscher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kennengelernt</a> und dokumentiert haben </li></ul><br><p>  Durch √Ñnderungen am Layoutalgorithmus wird ein neues ELF-Bild erhalten: </p><br><pre> <code class="plaintext hljs">$ readelf -l ls Elf file type is DYN (Shared object file) Entry point 0x41aa There are 11 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x00000034 0x00000034 0x00160 0x00160 R 0x4 INTERP 0x000194 0x00000194 0x00000194 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x00000000 0x00000000 0x01e6c 0x01e6c R 0x1000 LOAD 0x002000 0x00002000 0x00002000 0x14bd8 0x14bd8 RE 0x1000 LOAD 0x017000 0x00017000 0x00017000 0x0bf80 0x0bf80 R 0x1000 LOAD 0x0237f8 0x000247f8 0x000247f8 0x0096c 0x01afc RW 0x1000 DYNAMIC 0x023cec 0x00024cec 0x00024cec 0x00100 0x00100 RW 0x4 NOTE 0x0001a8 0x000001a8 0x000001a8 0x00044 0x00044 R 0x4 GNU_EH_FRAME 0x01c3f8 0x0001c3f8 0x0001c3f8 0x0092c 0x0092c R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 GNU_RELRO 0x0237f8 0x000247f8 0x000247f8 0x00808 0x00808 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt 03 .init .plt .plt.got .text .fini 04 .rodata .eh_frame_hdr .eh_frame 05 .init_array .fini_array .data.rel.ro .dynamic .got .data .bss 06 .dynamic 07 .note.ABI-tag .note.gnu.build-id 08 .eh_frame_hdr 09 10 .init_array .fini_array .data.rel.ro .dynamic .got</code> </pre> <br><p>  Die Grenze zwischen Code und Daten ist jetzt genauer.  Das einzige ausf√ºhrbare Segment enth√§lt wirklich nur Codeabschnitte: .init, .plt, .plt.got, .text, .fini. </p><br><div class="spoiler">  <b class="spoiler_title">Was genau wurde in ld ge√§ndert?</b> <div class="spoiler_text"><p>  Wie Sie wissen, wird die Struktur der Ausgabe-ELF-Datei durch das <a href="">Linker-Skript beschrieben</a> .  Sie k√∂nnen das Standardskript folgenderma√üen sehen: </p><br><pre> <code class="plaintext hljs">$ ld --verbose GNU ld (GNU Binutils for Ubuntu) 2.26.1 * * * using internal linker script: ================================================== /* Script for -z combreloc: combine and sort reloc sections */ /* Copyright (C) 2014-2015 Free Software Foundation, Inc. * * *</code> </pre> <br><p>  Viele andere Skripte f√ºr verschiedene Plattformen und Optionskombinationen befinden sich im Verzeichnis <code>ldscripts</code> .  F√ºr die Option " <code>separate-code</code> neue Skripte erstellt. </p><br><pre> <code class="plaintext hljs">$ diff elf_x86_64.x elf_x86_64.xe 1c1 &lt; /* Default linker script, for normal executables */ --- &gt; /* Script for -z separate-code: generate normal executables with separate code segment */ 46a47 &gt; . = ALIGN(CONSTANT (MAXPAGESIZE)); 70a72,75 &gt; . = ALIGN(CONSTANT (MAXPAGESIZE)); &gt; /* Adjust the address for the rodata segment. We want to adjust up to &gt; the same address within the page on the next page up. */ &gt; . = SEGMENT_START("rodata-segment", ALIGN(CONSTANT (MAXPAGESIZE)) + (. &amp; (CONSTANT (MAXPAGESIZE) - 1)));</code> </pre> <br><p>  Hier sehen Sie, dass eine Direktive hinzugef√ºgt wurde, um ein neues Segment mit schreibgesch√ºtzten Abschnitten nach dem Codesegment zu deklarieren. </p><br><p>  Zus√§tzlich zu den Skripten wurden jedoch √Ñnderungen an den Linkerquellen vorgenommen.  In der Funktion <code>_bfd_elf_map_sections_to_segments</code> - siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">commit</a> .  Wenn Sie jetzt Segmente f√ºr Abschnitte ausw√§hlen, wird ein neues Segment hinzugef√ºgt, wenn sich der Abschnitt durch das <code>SEC_CODE</code> Flag vom vorherigen Abschnitt unterscheidet. </p></div></div><br><h1 id="vyvod">  Fazit </h1><br><p>  Nach wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vor</a> empfehlen wir Entwicklern, bei der Entwicklung von Software nicht zu vergessen, die im Compiler und Linker integrierten Sicherheitsflags zu verwenden.  Nur eine so kleine √Ñnderung kann das Leben des Angreifers erheblich verkomplizieren und Ihr Leben viel ruhiger machen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433108/">https://habr.com/ru/post/de433108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433098/index.html">Die Geschichte von DDR3, SPD und chinesischen Originalherstellern</a></li>
<li><a href="../de433100/index.html">Arbeiten mit einer Datenbank aus einer Anwendung</a></li>
<li><a href="../de433102/index.html">Warum glauben Wissenschaftler, dass der Neunte Planet nicht existiert?</a></li>
<li><a href="../de433104/index.html">Die Foobar-Herausforderung: Googles geheimer Test f√ºr Entwickler</a></li>
<li><a href="../de433106/index.html">SpaceX und die NASA bekr√§ftigen ihre Absicht, den ersten Start des Crew Dragon-Schiffs im Januar 2019 zu starten</a></li>
<li><a href="../de433110/index.html">Erstellen von Hochleistungsorganisationen: Die strategische Bedeutung von Collaboration-Software</a></li>
<li><a href="../de433112/index.html">Unterhaltsames JavaScript: Schneetag</a></li>
<li><a href="../de433114/index.html">PMP-Zertifizierung: Vorbereitung auf die Pendlerpr√ºfung</a></li>
<li><a href="../de433116/index.html">Flammenwerfer, Weihnachtsmann auf einem Panzer, Bigfoot, Baba Yaga auf Endurica (und m√∂glicherweise ein Jetpack) - alles f√ºr Kinder f√ºr das neue Jahr</a></li>
<li><a href="../de433118/index.html">Benchmark-Tests und schnelle Analyse von Permutationsalgorithmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>