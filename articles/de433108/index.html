<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤷🏻 🥌 👨🏽‍🚀 ld -z separater Code 👉🏻 😾 🎒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel konzentriert sich auf eine kleine Sicherheitsfunktion, die in GNU ld zur Version 2.30 im Dezember 2018 hinzugefügt wurde. Auf Russisch ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ld -z separater Code</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/433108/"><p><img src="https://habrastorage.org/webt/mz/nr/5c/mznr5cswg58pumrqbt60sjacvg4.png"></p><br><p>  Dieser Artikel konzentriert sich auf eine kleine Sicherheitsfunktion, die in GNU ld zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 2.30</a> im Dezember 2018 hinzugefügt wurde.  Auf Russisch wurde diese Verbesserung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Opennet</a> mit folgender Anmerkung erwähnt: </p><br><blockquote>  "-z separater Code" -Modus, der die Sicherheit ausführbarer Dateien auf Kosten einer geringfügigen Erhöhung der Größe und des Speicherverbrauchs erhöht </blockquote><p>  Lass es uns herausfinden.  Um zu erklären, um welche Art von Sicherheitsproblem es sich handelt und um welche Lösung es sich handelt, beginnen wir mit den allgemeinen Funktionen von Exploits für binäre Sicherheitslücken. </p><a name="habracut"></a><br><h1 id="problemy-perehvata-potoka-upravleniya-v-eksploytah">  Probleme mit dem Kontrollfluss ausnutzen </h1><br><p>  Ein Angreifer kann Daten an das Programm übertragen und auf diese Weise mithilfe verschiedener Sicherheitsanfälligkeiten bearbeiten: Schreiben nach Index über die Grenzen eines Arrays hinaus, unsicheres Kopieren von Zeichenfolgen und Verwenden von Objekten nach der Freigabe.  Solche Fehler sind typisch für C- und C ++ - Programmcode und können bei bestimmten Eingabedaten für das Programm zu einer Speicherbeschädigung führen. </p><br><div class="spoiler">  <b class="spoiler_title">Sicherheitslücken in Bezug auf Speicherbeschädigung</b> <div class="spoiler_text"><p> CWE-20: Unsachgemäße Eingabevalidierung <br>  CWE-118: Falscher Zugriff auf indizierbare Ressourcen ('Bereichsfehler') <br>  CWE-119: Unsachgemäße Einschränkung von Operationen innerhalb der Grenzen eines Speicherpuffers <br>  CWE-120: Pufferkopie ohne Überprüfung der Eingabegröße ('Klassischer Pufferüberlauf') <br>  CWE-121: Stapelbasierter Pufferüberlauf <br>  CWE-122: Heap-basierter Pufferüberlauf <br>  CWE-123: Write-what-where-Bedingung <br>  CWE-124: Buffer Underwrite ('Buffer Underflow') <br>  CWE-125: Lesen außerhalb der Grenzen <br>  CWE-126: Pufferüberlesen <br>  CWE-127: Puffer unterlesen <br>  CWE-128: Umlauffehler <br>  CWE-129: Unsachgemäße Validierung des Array-Index <br>  CWE-130: Unsachgemäße Behandlung von Inkonsistenzen bei Längenparametern <br>  CWE-131: Falsche Berechnung der Puffergröße <br>  CWE-134: Verwendung einer extern gesteuerten Formatzeichenfolge <br>  CWE-135: Falsche Berechnung der Multi-Byte-Stringlänge <br>  CWE-170: Unsachgemäße Nullbeendigung <br>  CWE-190: Integer Overflow oder Wraparound <br>  CWE-415: Double Free <br>  CWE-416: Nach kostenlos verwenden <br>  CWE-476: NULL-Zeiger-Dereferenzierung <br>  CWE-787: Schreiben außerhalb der Grenzen <br>  CWE-824: Zugriff auf nicht initialisierten Zeiger <br>  ... </p></div></div><br><p>  Das klassische Exploit-Element speicherbeschädigungsähnlicher Sicherheitslücken ist das Überschreiben eines Zeigers im Speicher.  Der Zeiger wird dann vom Programm verwendet, um die Steuerung auf einen anderen Code zu übertragen: eine Klassenmethode oder -funktion von einem anderen Modul aufzurufen, von einer Funktion zurückzukehren.  Und da der Zeiger überschrieben wurde, wird die Kontrolle vom Angreifer abgefangen - das heißt, der von ihm vorbereitete Code wird ausgeführt.  Wenn Sie an Variationen und Details dieser Techniken interessiert sind, empfehlen wir Ihnen, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokument zu</a> lesen. </p><br><p>  Dieser gemeinsame Moment des Betriebs solcher Exploits ist bekannt, und hier für den Angreifer sind die Barrieren seit langem gesetzt: </p><br><ol><li>  Überprüfen der Integrität von Zeigern vor dem Übergeben der Kontrolle: Stapel-Cookies, Kontrollflussschutz, Zeigerauthentifizierung </li><li>  Randomisierung von Segmentadressen mit Code und Daten: Randomisierung des Adressraumlayouts </li><li>  Verhindern, dass Code außerhalb von Codesegmenten ausgeführt wird: Schutz des ausführbaren Speicherplatzes </li></ol><br><p>  Als nächstes konzentrieren wir uns auf den Schutz des letzteren Typs. </p><br><h1 id="executable-space-protection">  ausführbarer Speicherplatzschutz </h1><br><p>  Der Programmspeicher ist heterogen und in Segmente mit unterschiedlichen Rechten unterteilt: Lesen, Schreiben und Ausführen.  Dies wird durch die Fähigkeit des Prozessors sichergestellt, Speicherseiten mit Zugriffsflags in Seitentabellen zu markieren.  Die Idee des Schutzes basiert auf einer strikten Trennung von Code und Daten: Die vom Angreifer während des Verarbeitungsprozesses empfangenen Daten sollten in <strong>nicht ausführbaren</strong> Segmenten (Stapel, Heap) und der Code des Programms selbst in separaten <strong>unveränderlichen</strong> Segmenten <strong>abgelegt werden</strong> .  Dies sollte dem Angreifer daher die Möglichkeit nehmen, Fremdcode im Speicher abzulegen und auszuführen. </p><br><p>  Um das Verbot der Codeausführung in Datensegmenten zu umgehen, werden Techniken zur Wiederverwendung von Code verwendet.  Das heißt, der Angreifer überträgt die Kontrolle auf die Codefragmente (im Folgenden als Gadgets bezeichnet), die sich auf den ausführbaren Seiten befinden.  Techniken dieser Art sind in aufsteigender Reihenfolge von unterschiedlicher Schwierigkeit: </p><br><ul><li>  Übertragen der Kontrolle an eine Funktion, die das tut, was für den Angreifer ausreicht: an die Funktion system () mit einem kontrollierten Argument zum Ausführen beliebiger Shell-Befehle (ret2libc) </li><li> Übertragen der Steuerung an eine Funktion oder Kette von Gadgets, die den Schutz deaktivieren oder einen Teil des Speichers ausführbar machen (z. B. Aufrufen von <code>mprotect()</code> ), gefolgt von der Ausführung von beliebigem Code </li><li>  Ausführung aller gewünschten Aktionen mit einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://web.archive.org/web/20170325014927/">langen Kette von Gadgets</a> </li></ul><br><p>  Somit steht der Angreifer vor der Aufgabe, den vorhandenen Code in dem einen oder anderen Volume wiederzuverwenden.  Wenn dies etwas komplizierter ist als die Rückkehr zu einer einzelnen Funktion, ist eine <em>Reihe von Gadgets</em> erforderlich.  Um nach Gadgets nach ausführbaren Segmenten zu suchen, gibt es folgende Tools: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ropper</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ropgadget</a> . </p><br><h2 id="dyra-read_implies_exec">  Loch READ_IMPLIES_EXEC </h2><br><p>  Manchmal können jedoch Speicherbereiche mit Daten ausführbar sein, und die oben beschriebenen Prinzipien der Trennung von Code und Daten werden eindeutig verletzt.  In solchen Fällen bleibt dem Angreifer die Mühe erspart, Gadgets oder Funktionen zur Wiederverwendung des Codes zu finden.  Ein interessanter Fund dieser Art war der ausführbare Stack und alle Datensegmente auf derselben „Industrial Firewall“. </p><br><p>  Listing <code>/proc/$pid/maps</code> : </p><br><pre> <code class="plaintext hljs">00008000-00009000 r-xp 00000000 08:01 10 /var/flash/dmt/nx_test/a.out 00010000-00011000 rwxp 00000000 08:01 10 /var/flash/dmt/nx_test/a.out 00011000-00032000 rwxp 00000000 00:00 0 [heap] 40000000-4001f000 r-xp 00000000 1f:02 429 /lib/ld-linux.so.2 4001f000-40022000 rwxp 00000000 00:00 0 40027000-40028000 r-xp 0001f000 1f:02 429 /lib/ld-linux.so.2 40028000-40029000 rwxp 00020000 1f:02 429 /lib/ld-linux.so.2 4002c000-40172000 r-xp 00000000 1f:02 430 /lib/libc.so.6 40172000-40179000 ---p 00146000 1f:02 430 /lib/libc.so.6 40179000-4017b000 r-xp 00145000 1f:02 430 /lib/libc.so.6 4017b000-4017c000 rwxp 00147000 1f:02 430 /lib/libc.so.6 4017c000-40b80000 rwxp 00000000 00:00 0 be8c2000-be8d7000 rwxp 00000000 00:00 0 [stack]</code> </pre> <br><p>  Hier sehen Sie die Speicherkarte des Testdienstprogramms.  Eine Karte besteht aus Speicherbereichen - Tabellenzeilen.  Achten Sie zunächst auf die rechte Spalte - sie erklärt den Inhalt des Bereichs (Codesegmente, Daten von Funktionsbibliotheken oder des Programms selbst) oder seinen Typ (Heap, Stack).  Auf der linken Seite befindet sich in der angegebenen Reihenfolge der Adressbereich, den jeder Speicherbereich belegt, und außerdem die Zugriffsrechte-Flags: r (Lesen), w (Schreiben), x (Ausführen).  Diese Flags bestimmen das Verhalten des Systems beim Versuch, Speicher an diesen Adressen zu lesen, zu schreiben und auszuführen.  Wenn der angegebene Zugriffsmodus verletzt wird, wird eine Ausnahme ausgelöst. </p><br><p>  Beachten Sie, dass fast der gesamte Speicher im Prozess ausführbar ist: der Stapel, der Heap und alle Datensegmente.  Das ist ein Problem.  Offensichtlich erleichtert das Vorhandensein von rwx-Speicherseiten einem Angreifer das Leben, da er <strong>seinen</strong> Code in einem solchen Prozess an jedem Ort frei ausführen kann, an dem sein Code beim Übertragen von Daten (Paketen, Dateien) an ein solches Programm zur Verarbeitung abgerufen wird. </p><br><p>  Warum ist eine solche Situation bei einem modernen Gerät aufgetreten, das das Verbot der Codeausführung auf Datenseiten mit Hardware unterstützt, hängt die Sicherheit von Unternehmens- und Industrienetzwerken vom Gerät ab, und das Problem und seine Lösung sind seit langem bekannt? </p><br><p>  Dieses Bild wird durch das Verhalten des Kernels während der Initialisierung des Prozesses (Zuweisen eines Stapels, Heaps, Laden des Haupt-ELF usw.) und während der Ausführung der Aufrufe des Kernprozesses bestimmt.  Das Schlüsselattribut, das dies beeinflusst, ist das Persönlichkeitsflag <code>READ_IMPLIES_EXEC</code> .  Dieses Flag bewirkt, dass jeder lesbare Speicher auch ausführbar wird.  Ein Flag kann aus mehreren Gründen für Ihren Prozess gesetzt werden: </p><br><ol><li>  Legacy kann explizit vom Software-Flag im ELF-Header angefordert werden, um einen sehr interessanten Mechanismus zu implementieren: ein Sprungbrett auf dem Stapel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> )! </li><li>  Es kann von untergeordneten Prozessen vom übergeordneten Prozess geerbt werden. </li><li>  Es kann vom Kernel unabhängig für alle Prozesse installiert werden!  Erstens, wenn die Architektur keinen nicht ausführbaren Speicher unterstützt.  Zweitens, nur für den Fall, einige andere <a href="">alte Krücken</a> zu stützen.  Dieser Code befindet sich im Kernel 2.6.32 (ARM), der eine sehr lange Lebensdauer hatte.  Dies war nur unser Fall. </li></ol><br><h1 id="prostranstvo-dlya-poiska-gadzhetov-v-obraze-elf">  Platz zum Auffinden von Gadgets in einem ELF-Bild </h1><br><p>  Funktionsbibliotheken und ausführbare Programmdateien liegen im ELF-Format vor.  Der gcc-Compiler übersetzt Sprachkonstrukte in Maschinencode und fügt sie in einen Abschnitt und die Daten, die dieser Code verarbeitet, in andere Abschnitte ein.  Es gibt viele Abschnitte, die vom ld-Linker in Segmente gruppiert werden.  Somit enthält ELF ein Programmbild, das zwei Darstellungen aufweist: eine Tabelle mit Abschnitten und eine Tabelle mit Segmenten. </p><br><pre> <code class="plaintext hljs">$ readelf -l /bin/ls Elf file type is EXEC (Executable file) Entry point 0x804bee9 There are 9 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x08048034 0x08048034 0x00120 0x00120 RE 0x4 INTERP 0x000154 0x08048154 0x08048154 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x08048000 0x08048000 0x1e40c 0x1e40c RE 0x1000 LOAD 0x01ef00 0x08067f00 0x08067f00 0x00444 0x01078 RW 0x1000 DYNAMIC 0x01ef0c 0x08067f0c 0x08067f0c 0x000f0 0x000f0 RW 0x4 NOTE 0x000168 0x08048168 0x08048168 0x00044 0x00044 R 0x4 GNU_EH_FRAME 0x018b74 0x08060b74 0x08060b74 0x00814 0x00814 R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 GNU_RELRO 0x01ef00 0x08067f00 0x08067f00 0x00100 0x00100 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame 03 .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 04 .dynamic 05 .note.ABI-tag .note.gnu.build-id 06 .eh_frame_hdr 07 08 .init_array .fini_array .jcr .dynamic .got</code> </pre> <br><p>  Hier sehen Sie die Zuordnung von Abschnitten zu Segmenten in einem ELF-Bild. </p><br><p>  Die <strong>Abschnittstabelle</strong> wird von Dienstprogrammen zum Analysieren von Programmen und Bibliotheken verwendet, von Ladern jedoch nicht zum Projizieren von ELFs in den Prozessspeicher.  Die Abschnittstabelle beschreibt die ELF-Struktur detaillierter als die Segmenttabelle.  Innerhalb eines Segments können sich mehrere Abschnitte befinden. </p><br><p>  Ein speicherinternes ELF-Bild wird von ELF-Ladern basierend auf dem Inhalt der <strong>Segmenttabelle erstellt</strong> .  Die <strong>Partitionstabelle</strong> wird nicht mehr zum Laden von ELF in den Speicher verwendet. </p><br><div class="spoiler">  <b class="spoiler_title">Es gibt jedoch Ausnahmen von dieser Regel.</b> <div class="spoiler_text"><p>  In der Natur gibt es beispielsweise einen Debian-Entwickler-Patch für den ELF ld.so-Loader für die ARM-Architektur, der nach einem speziellen Abschnitt ".ARM.attributes" wie <a href="">SHT_ARM_ATTRIBUTES sucht,</a> und Binärdateien mit einer abgesägten Abschnittstabelle in einem solchen System werden nicht geladen ... </p></div></div><br><p>  Ein ELF-Segment verfügt über Flags, die bestimmen, welche Berechtigungen das Segment im Speicher haben wird.  Traditionell wurde der größte Teil der Software für GNU / Linux so erstellt, dass zwei <code>PT_LOAD</code> Segmente (im Speicher <code>PT_LOAD</code> ) in der Segmenttabelle deklariert wurden - wie in der obigen Auflistung: </p><br><ol><li><p>  Segment mit <code>RE</code> Flags </p><br><p>  1.1.  <strong>Ausführbarer</strong> ELF-Code: Abschnitte <code>.init</code> , <code>.text</code> , <code>.fini</code> </p><br><p>  1.2.  <strong>Unveränderliche</strong> Daten in ELF: <code>.rodata</code> <code>.symtab</code> , <code>.rodata</code> </p><br></li><li><p>  Segment <code>RW</code> Flaggen </p><br><p>  2.1.  <strong>Variable</strong> Daten in ELF: Abschnitte <code>.plt</code> , <code>.got</code> , <code>.data</code> , <code>.bss</code> </p><br></li></ol><br><p>  Wenn Sie auf die Zusammensetzung des ersten Segments und seiner Zugriffsflags achten, wird deutlich, dass ein solches Layout den Platz für die Suche nach Gadgets für Techniken zur Wiederverwendung von Code erweitert.  In großen ELFs wie libcrypto können Servicetabellen und andere unveränderliche <strong>Daten</strong> bis zu 40% des <strong>ausführbaren</strong> Segments einnehmen.  Das Vorhandensein von etwas ähnlichem wie Codeteilen in diesen Daten wird durch Versuche bestätigt, solche Binärdateien mit einer großen Datenmenge im ausführbaren Segment ohne Abschnittstabellen und Symbole zu zerlegen.  Jede Folge von Bytes in diesem einzelnen ausführbaren Segment kann als nützlich für das angreifende Fragment von Maschinencode und Sprungbrett angesehen werden - sei es diese Folge von Bytes mit mindestens einem Teil der Zeile der Debugging-Nachricht aus dem Programm, einem Teil des Funktionsnamens in der Symboltabelle oder der konstanten Anzahl des kryptografischen Algorithmus ... </p><br><div class="spoiler">  <b class="spoiler_title">Ausführbare PE-Header</b> <div class="spoiler_text"><p>  Die ausführbaren Header und Tabellen am Anfang des ersten Abschnitts des ELF-Images ähneln der Situation mit Windows vor etwa 15 Jahren.  Es gab eine Reihe von Viren, die Dateien infizierten und ihren Code in ihren PE-Header schrieben, der auch dort ausführbar war.  Ich habe es geschafft, ein solches Beispiel im Archiv zu finden: </p><br><p><img src="https://habrastorage.org/webt/gy/kt/7t/gykt7t5znycwstjaek_cdoo_xvm.png" alt="Virus.Win32.Haless.1127"></p><br><p>  Wie Sie sehen können, wird der Viruskörper direkt nach der Abschnittstabelle im Bereich der PE-Header gequetscht.  Bei einer Projektion einer Datei auf den virtuellen Speicher stehen hier normalerweise etwa 3 KB freier Speicherplatz zur Verfügung.  Nach dem Körper des Virus gibt es ein leeres Feld und dann beginnt der erste Abschnitt mit dem Programmcode. </p><br><p>  Für Linux gab es jedoch viel interessantere Werke der VX-Szene: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergeltung</a> . </p></div></div><br><h1 id="reshenie">  Lösung </h1><br><ul><li>  Das oben beschriebene Problem ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seit langem</a> bekannt. </li><li>  Behoben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">12. Januar 2018</a> : Der Schlüssel `ld -z separater Code:" Separaten Code erstellen "PT_LOAD" Segment-Header im Objekt wird hinzugefügt. Dies gibt ein Speichersegment an, das nur Anweisungen enthalten sollte und sich in vollständig getrennten Seiten von anderen Daten befinden muss. Erstellen Sie kein separates Code-Segment "PT_LOAD", wenn Noseparate-Code verwendet wird. ").  Die Funktion wurde in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 2.30 veröffentlicht</a> . </li><li>  Darüber hinaus war diese Funktion in der nächsten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 2.31</a> standardmäßig enthalten. </li><li>  Präsentiert in frischen <code>binutils</code> Paketen, zum Beispiel in den Ubuntu 18.10-Repositorys.  Viele Pakete wurden bereits mit dieser neuen Funktion zusammengestellt, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ElfMaster-</a> Forscher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kennengelernt</a> und dokumentiert haben </li></ul><br><p>  Durch Änderungen am Layoutalgorithmus wird ein neues ELF-Bild erhalten: </p><br><pre> <code class="plaintext hljs">$ readelf -l ls Elf file type is DYN (Shared object file) Entry point 0x41aa There are 11 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x00000034 0x00000034 0x00160 0x00160 R 0x4 INTERP 0x000194 0x00000194 0x00000194 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x00000000 0x00000000 0x01e6c 0x01e6c R 0x1000 LOAD 0x002000 0x00002000 0x00002000 0x14bd8 0x14bd8 RE 0x1000 LOAD 0x017000 0x00017000 0x00017000 0x0bf80 0x0bf80 R 0x1000 LOAD 0x0237f8 0x000247f8 0x000247f8 0x0096c 0x01afc RW 0x1000 DYNAMIC 0x023cec 0x00024cec 0x00024cec 0x00100 0x00100 RW 0x4 NOTE 0x0001a8 0x000001a8 0x000001a8 0x00044 0x00044 R 0x4 GNU_EH_FRAME 0x01c3f8 0x0001c3f8 0x0001c3f8 0x0092c 0x0092c R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 GNU_RELRO 0x0237f8 0x000247f8 0x000247f8 0x00808 0x00808 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt 03 .init .plt .plt.got .text .fini 04 .rodata .eh_frame_hdr .eh_frame 05 .init_array .fini_array .data.rel.ro .dynamic .got .data .bss 06 .dynamic 07 .note.ABI-tag .note.gnu.build-id 08 .eh_frame_hdr 09 10 .init_array .fini_array .data.rel.ro .dynamic .got</code> </pre> <br><p>  Die Grenze zwischen Code und Daten ist jetzt genauer.  Das einzige ausführbare Segment enthält wirklich nur Codeabschnitte: .init, .plt, .plt.got, .text, .fini. </p><br><div class="spoiler">  <b class="spoiler_title">Was genau wurde in ld geändert?</b> <div class="spoiler_text"><p>  Wie Sie wissen, wird die Struktur der Ausgabe-ELF-Datei durch das <a href="">Linker-Skript beschrieben</a> .  Sie können das Standardskript folgendermaßen sehen: </p><br><pre> <code class="plaintext hljs">$ ld --verbose GNU ld (GNU Binutils for Ubuntu) 2.26.1 * * * using internal linker script: ================================================== /* Script for -z combreloc: combine and sort reloc sections */ /* Copyright (C) 2014-2015 Free Software Foundation, Inc. * * *</code> </pre> <br><p>  Viele andere Skripte für verschiedene Plattformen und Optionskombinationen befinden sich im Verzeichnis <code>ldscripts</code> .  Für die Option " <code>separate-code</code> neue Skripte erstellt. </p><br><pre> <code class="plaintext hljs">$ diff elf_x86_64.x elf_x86_64.xe 1c1 &lt; /* Default linker script, for normal executables */ --- &gt; /* Script for -z separate-code: generate normal executables with separate code segment */ 46a47 &gt; . = ALIGN(CONSTANT (MAXPAGESIZE)); 70a72,75 &gt; . = ALIGN(CONSTANT (MAXPAGESIZE)); &gt; /* Adjust the address for the rodata segment. We want to adjust up to &gt; the same address within the page on the next page up. */ &gt; . = SEGMENT_START("rodata-segment", ALIGN(CONSTANT (MAXPAGESIZE)) + (. &amp; (CONSTANT (MAXPAGESIZE) - 1)));</code> </pre> <br><p>  Hier sehen Sie, dass eine Direktive hinzugefügt wurde, um ein neues Segment mit schreibgeschützten Abschnitten nach dem Codesegment zu deklarieren. </p><br><p>  Zusätzlich zu den Skripten wurden jedoch Änderungen an den Linkerquellen vorgenommen.  In der Funktion <code>_bfd_elf_map_sections_to_segments</code> - siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">commit</a> .  Wenn Sie jetzt Segmente für Abschnitte auswählen, wird ein neues Segment hinzugefügt, wenn sich der Abschnitt durch das <code>SEC_CODE</code> Flag vom vorherigen Abschnitt unterscheidet. </p></div></div><br><h1 id="vyvod">  Fazit </h1><br><p>  Nach wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vor</a> empfehlen wir Entwicklern, bei der Entwicklung von Software nicht zu vergessen, die im Compiler und Linker integrierten Sicherheitsflags zu verwenden.  Nur eine so kleine Änderung kann das Leben des Angreifers erheblich verkomplizieren und Ihr Leben viel ruhiger machen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433108/">https://habr.com/ru/post/de433108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433098/index.html">Die Geschichte von DDR3, SPD und chinesischen Originalherstellern</a></li>
<li><a href="../de433100/index.html">Arbeiten mit einer Datenbank aus einer Anwendung</a></li>
<li><a href="../de433102/index.html">Warum glauben Wissenschaftler, dass der Neunte Planet nicht existiert?</a></li>
<li><a href="../de433104/index.html">Die Foobar-Herausforderung: Googles geheimer Test für Entwickler</a></li>
<li><a href="../de433106/index.html">SpaceX und die NASA bekräftigen ihre Absicht, den ersten Start des Crew Dragon-Schiffs im Januar 2019 zu starten</a></li>
<li><a href="../de433110/index.html">Erstellen von Hochleistungsorganisationen: Die strategische Bedeutung von Collaboration-Software</a></li>
<li><a href="../de433112/index.html">Unterhaltsames JavaScript: Schneetag</a></li>
<li><a href="../de433114/index.html">PMP-Zertifizierung: Vorbereitung auf die Pendlerprüfung</a></li>
<li><a href="../de433116/index.html">Flammenwerfer, Weihnachtsmann auf einem Panzer, Bigfoot, Baba Yaga auf Endurica (und möglicherweise ein Jetpack) - alles für Kinder für das neue Jahr</a></li>
<li><a href="../de433118/index.html">Benchmark-Tests und schnelle Analyse von Permutationsalgorithmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>