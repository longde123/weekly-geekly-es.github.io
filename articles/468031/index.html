<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüé® üêÉ üïπÔ∏è Llevamos un juego multijugador de C ++ a la web con Cheerp, WebRTC y Firebase üö¨ üë©‚Äçüë©‚Äçüëß‚Äçüëß üõ∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Nuestra empresa Leaning Technologies ofrece soluciones para portar aplicaciones de escritorio tradicionales a la web. Nuestro compilado...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Llevamos un juego multijugador de C ++ a la web con Cheerp, WebRTC y Firebase</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468031/"><h2>  Introduccion </h2><br>  Nuestra empresa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">Leaning Technologies</a> ofrece soluciones para portar aplicaciones de escritorio tradicionales a la web.  Nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">compilador Cheerp de</a> C ++ genera una combinaci√≥n de WebAssembly y JavaScript, que proporciona <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">una interacci√≥n f√°cil con el navegador</a> y un alto rendimiento. <br><br>  Como ejemplo de su aplicaci√≥n, decidimos portar un juego multijugador para la web y elegimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener"><strong>Teeworlds</strong></a> para esto.  Teeworlds es un juego retro bidimensional para varios jugadores con una peque√±a pero activa comunidad de jugadores (¬°incluido yo!).  Es peque√±o en t√©rminos de recursos descargables y requisitos de CPU y GPU, un candidato ideal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bb/70c/bb8/8bb70cbb863efd3e58cec7da962558a7.png" width="956" height="892"></div><br>  <i>Funciona en el navegador Teeworlds</i> <br><a name="habracut"></a><br>  Decidimos utilizar este proyecto para experimentar con <strong>soluciones generales para portar c√≥digo de red a la web</strong> .  Esto generalmente se hace de las siguientes maneras: <br><br><ul><li>  <strong>XMLHttpRequest / fetch</strong> si la parte de la red consta solo de solicitudes HTTP, o </li><li>  <strong>WebSockets</strong> </li></ul><br>  Ambas soluciones requieren alojar el componente del servidor en el lado del servidor, y ninguna de ellas le permite utilizar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UDP</a> como protocolo de transporte.  Esto es importante para aplicaciones en tiempo real, como videoconferencias y software de juegos, porque las garant√≠as de entrega y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el</a> pedido de paquetes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TCP</a> pueden interferir con bajas latencias. <br><br>  Hay una tercera forma: usar la red desde un navegador: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener"><strong>WebRTC</strong></a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener"><strong>RTCDataChannel</strong></a> admite transmisiones confiables y poco confiables (en el √∫ltimo caso, si es posible, intenta usar UDP como protocolo de transporte), y puede usarse tanto con un servidor remoto como entre navegadores.  <strong>Esto significa que podemos transferir toda la aplicaci√≥n al navegador, ¬°incluido el componente del servidor!</strong> <br><br>  Sin embargo, esta es una dificultad adicional: antes de que dos pares de WebRTC puedan intercambiar datos, deben realizar un procedimiento de protocolo de enlace relativamente complicado para la conexi√≥n, que requiere varias entidades de terceros (un servidor de se√±al y uno o m√°s servidores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">STUN</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">TURN</a> ). <br><br>  Idealmente, nos gustar√≠a crear una API de red internamente utilizando WebRTC, pero lo m√°s cerca posible de la interfaz UDP Sockets, que no necesita establecer una conexi√≥n. <br><br>  Esto nos permitir√° aprovechar WebRTC sin la necesidad de revelar detalles complejos al c√≥digo de la aplicaci√≥n (que quer√≠amos cambiar lo menos posible en nuestro proyecto). <br><br><h1>  WebRTC m√≠nimo </h1><br>  WebRTC es un conjunto de API disponible en los navegadores que proporciona audio, video y transferencia arbitraria de datos entre pares. <br><br>  La conexi√≥n entre los pares se establece (incluso si hay NAT en uno o ambos lados) utilizando los servidores STUN y / o TURN a trav√©s de un mecanismo llamado ICE.  Los pares intercambian informaci√≥n ICE y par√°metros de canal a trav√©s de la oferta SDP y el protocolo de respuesta. <br><br>  Wow!  Cu√°ntas abreviaturas a la vez.  Expliquemos brevemente qu√© significan estos conceptos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener"><strong>Utilidades transversales de sesi√≥n para NAT</strong> ( <strong>STUN</strong> )</a> : un protocolo para omitir NAT y recibir un par (IP, puerto) para intercambiar datos directamente con el host.  Si logra completar su tarea, los compa√±eros pueden intercambiar datos de forma independiente entre s√≠. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener"><strong>El uso transversal de los rel√©s alrededor de NAT</strong> ( <strong>TURN</strong> )</a> tambi√©n se usa para omitir NAT, pero lo hace redirigiendo datos a trav√©s de un proxy que es visible para ambos pares.  Agrega retraso y es m√°s costoso de ejecutar que STUN (porque se usa durante toda la sesi√≥n de comunicaci√≥n), pero a veces esta es la √∫nica opci√≥n posible. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener"><strong>El establecimiento de conectividad interactiva</strong> ( <strong>ICE</strong> ) se</a> utiliza para seleccionar la mejor manera posible de conectar dos pares en funci√≥n de la informaci√≥n obtenida conectando directamente a pares, as√≠ como la informaci√≥n recibida por cualquier n√∫mero de servidores STUN y TURN. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener"><strong>El Protocolo de descripci√≥n de sesi√≥n</strong> ( <strong>SDP</strong> )</a> es un formato para describir los par√°metros del canal de conexi√≥n, por ejemplo, candidatos ICE, c√≥decs multimedia (en el caso de un canal de audio / video), etc. ... Uno de los pares env√≠a una oferta SDP ("oferta"), y el segundo responde con SDP Respuesta ("respuesta").  Despu√©s de eso, se crea un canal. </li></ul><br>  Para crear dicha conexi√≥n, los pares deben recopilar la informaci√≥n que recibieron de los servidores STUN y TURN e intercambiarla entre s√≠. <br><br>  El problema es que todav√≠a no tienen la capacidad de intercambiar datos directamente, por lo que debe haber un mecanismo fuera de banda para intercambiar estos datos: un servidor de se√±ales. <br><br>  Un servidor de se√±ales puede ser muy simple, porque su √∫nica tarea es redirigir los datos entre pares en la etapa de "apret√≥n de manos" (como se muestra en el diagrama a continuaci√≥n). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ac/972/ba0/5ac972ba057357540ffd749081dbdd3b.png" width="783" height="710"></div><br>  <i>Secuencia de protocolo de enlace simplificado WebRTC</i> <br><br><h1>  Descripci√≥n del modelo de red de Teeworlds </h1><br>  La arquitectura de red de Teeworlds es muy simple: <br><br><ul><li>  Los componentes de cliente y servidor son dos programas diferentes. </li><li>  Los clientes ingresan al juego conect√°ndose a uno de varios servidores, cada uno de los cuales aloja un solo juego a la vez. </li><li>  Toda la transferencia de datos en el juego es a trav√©s del servidor. </li><li>  Se usa un servidor maestro especial para recopilar una lista de todos los servidores p√∫blicos que se muestran en el cliente del juego. </li></ul><br>  Debido al uso de WebRTC para el intercambio de datos, podemos transferir el componente del servidor del juego al navegador donde se encuentra el cliente.  Nos da una gran oportunidad ... <br><br><h1>  Deshazte de los servidores </h1><br>  La falta de l√≥gica del servidor tiene una buena ventaja: podemos implementar toda la aplicaci√≥n como contenido est√°tico en las p√°ginas de Github o en nuestro propio equipo detr√°s de Cloudflare, lo que garantiza descargas r√°pidas y un alto tiempo de actividad de forma gratuita.  De hecho, podemos olvidarnos de ellos, y si tenemos suerte y el juego se vuelve popular, entonces la infraestructura no tendr√° que modernizarse. <br><br>  Sin embargo, para que el sistema funcione, todav√≠a tenemos que usar una arquitectura externa: <br><br><ul><li>  Uno o m√°s servidores STUN: tenemos la opci√≥n de varias opciones gratuitas. </li><li>  Al menos un servidor TURN: no hay opciones gratuitas aqu√≠, por lo que podemos configurar el nuestro o pagar el servicio.  Afortunadamente, la mayor√≠a de las veces puede conectarse a trav√©s de los servidores STUN (y proporcionar un verdadero p2p), pero TURN es necesario como alternativa. </li><li>  Servidor de se√±al: a diferencia de los otros dos aspectos, la se√±alizaci√≥n no est√° estandarizada.  El responsable del servidor de se√±ales depende de alguna manera de la aplicaci√≥n.  En nuestro caso, antes de establecer una conexi√≥n, es necesario intercambiar una peque√±a cantidad de datos. </li><li>  Servidor maestro de Teeworlds: otros servidores lo utilizan para notificar su existencia y los clientes buscan servidores p√∫blicos.  Aunque no es obligatorio (los clientes siempre pueden conectarse a un servidor que conocen manualmente), ser√≠a bueno tenerlo para que los jugadores puedan participar en juegos con personas aleatorias. </li></ul><br>  Decidimos usar los servidores STUN gratuitos de Google e implementamos un servidor TURN por nuestra cuenta. <br><br>  Para los √∫ltimos dos puntos usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">Firebase</a> : <br><br><ul><li>  El servidor maestro de Teeworlds se implementa de manera muy simple: como una lista de objetos que contienen informaci√≥n (nombre, IP, mapa, modo, ...) de cada servidor activo.  Los servidores publican y actualizan su propio objeto, y los clientes toman la lista completa y se la muestran al jugador.  Tambi√©n mostramos la lista en la p√°gina de inicio como HTML, para que los jugadores puedan simplemente hacer clic en el servidor e ir directamente al juego. </li><li>  La se√±alizaci√≥n est√° estrechamente relacionada con nuestra implementaci√≥n de socket, descrita en la siguiente secci√≥n. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d6/ae6/72d/3d6ae672db99216dabcf0a792d008f5e.png" width="1697" height="513"></div><br>  <i>Lista de servidores dentro del juego y en la p√°gina de inicio</i> <br><br><h1>  Implementaci√≥n de socket </h1><br>  Queremos crear una API lo m√°s cerca posible de los sockets Posix UDP para minimizar la cantidad de cambios necesarios. <br><br>  Tambi√©n queremos obtener el m√≠nimo necesario para el intercambio de datos m√°s simple en la red. <br><br>  Por ejemplo, no necesitamos enrutamiento real: todos los pares est√°n en la misma "LAN virtual" asociada con una instancia espec√≠fica de la base de datos Firebase. <br><br>  Por lo tanto, no necesitamos direcciones IP √∫nicas: para la identificaci√≥n √∫nica de pares, es suficiente usar valores √∫nicos de claves Firebase (similares a los nombres de dominio), y cada par asigna localmente direcciones IP "falsas" a cada clave que necesita ser convertida.  Esto elimina por completo la necesidad de una asignaci√≥n de direcci√≥n IP global, que es una tarea no trivial. <br><br>  Aqu√≠ est√° la API m√≠nima que necesitamos implementar: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Create and destroy a socket int socket(); int close(int fd); // Bind a socket to a port, and publish it on Firebase int bind(int fd, AddrInfo* addr); // Send a packet. This lazily create a WebRTC connection to the // peer when necessary int sendto(int fd, uint8_t* buf, int len, const AddrInfo* addr); // Receive the packets destined to this socket int recvfrom(int fd, uint8_t* buf, int len, AddrInfo* addr); // Be notified when new packets arrived int recvCallback(Callback cb); // Obtain a local ip address for this peer key uint32_t resolve(client::String* key); // Get the peer key for this ip String* reverseResolve(uint32_t addr); // Get the local peer key String* local_key(); // Initialize the library with the given Firebase database and // WebRTc connection options void init(client::FirebaseConfig* fb, client::RTCConfiguration* ice);</span></span></code> </pre> <br>  La API es simple y similar a la API de Sockets Posix, pero tiene varias diferencias importantes: <strong>registrar devoluciones de llamada, asignar direcciones IP locales y una conexi√≥n diferida</strong> . <br><br><h2>  Registro de devoluci√≥n de llamada </h2><br>  Incluso si el programa fuente usa E / S sin bloqueo, el c√≥digo debe ser refactorizado para ejecutarse en un navegador web. <br><br>  La raz√≥n de esto es que el bucle de eventos en el navegador est√° oculto del programa (ya sea JavaScript o WebAssembly). <br><br>  En un entorno nativo, podemos escribir c√≥digo de esta manera <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { select(...); <span class="hljs-comment"><span class="hljs-comment">// wait for I/O events while(true) { int r = readfrom(...); // try to read if (r &lt; 0 &amp;&amp; errno == EWOULDBLOCK) // no more data available break; ... } ... }</span></span></code> </pre> <br>  Si el bucle de eventos est√° oculto para nosotros, entonces debemos convertirlo en algo como esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cb = []() { <span class="hljs-comment"><span class="hljs-comment">// this will be called when new data is available while(true) { int r = readfrom(...); // try to read if (r &lt; 0 &amp;&amp; errno == EWOULDBLOCK) // no more data available break; ... } ... }; recvCallback(cb); // register the callback</span></span></code> </pre> <br><h2>  Asignaci√≥n de IP local </h2><br>  Los identificadores de nodo en nuestra "red" no son direcciones IP, sino claves de Firebase (estas son l√≠neas que se ven as√≠: <code>-LmEC50PYZLCiCP-vqde</code> ). <br><br>  Esto es conveniente porque no necesitamos un mecanismo para asignar IP y verificar su singularidad (as√≠ como su eliminaci√≥n despu√©s de desconectar al cliente), pero a menudo es necesario identificar a los pares por un valor num√©rico. <br><br>  Para esto, se utilizan las funciones <code>resolve</code> e <code>reverseResolve</code> : la aplicaci√≥n de alguna manera obtiene el valor de cadena de la clave (a trav√©s de la entrada del usuario o del servidor maestro) y puede convertirlo a una direcci√≥n IP para uso interno.  El resto de la API tambi√©n obtiene este valor en lugar de una cadena por simplicidad. <br><br>  Esto es similar a una b√∫squeda de DNS, solo se realiza localmente en el cliente. <br><br>  Es decir, las direcciones IP no se pueden compartir entre diferentes clientes, y si necesita alg√∫n tipo de identificador global, tendr√° que generarlo de una manera diferente. <br><br><h2>  Mezcla perezosa </h2><br>  UDP no necesita una conexi√≥n, pero, como vimos, antes de comenzar la transferencia de datos entre dos pares, WebRTC requiere un largo proceso de conexi√≥n. <br><br>  Si queremos proporcionar el mismo nivel de abstracci√≥n ( <code>sendto</code> / <code>recvfrom</code> con pares arbitrarios sin conectar primero), entonces debemos hacer una conexi√≥n "perezosa" (retardada) dentro de la API. <br><br>  Esto es lo que sucede durante el intercambio de datos normal entre el "servidor" y el "cliente" en caso de utilizar UDP, y lo que debe hacer nuestra biblioteca: <br><br><ul><li>  El servidor llama a <code>bind()</code> para indicarle al sistema operativo que desea recibir paquetes en el puerto especificado. </li></ul><br>  En su lugar, publicaremos el puerto abierto en Firebase bajo la clave del servidor y escucharemos los eventos en su sub√°rbol. <br><br><ul><li>  El servidor llama a <code>recvfrom()</code> , aceptando paquetes de cualquier host a este puerto. </li></ul><br>  En nuestro caso, debemos verificar la cola entrante de los paquetes enviados a este puerto. <br><br>  Cada puerto tiene su propia cola, y agregamos los puertos de origen y de destino al comienzo de los datagramas WebRTC para saber qu√© cola redirigir cuando llega un nuevo paquete. <br><br>  La llamada no es de bloqueo, por lo que si no hay paquetes, simplemente devolvemos -1 y establecemos <code>errno=EWOULDBLOCK</code> . <br><br><ul><li>  El cliente recibe, por alg√∫n medio externo, la IP y el puerto del servidor, y llama a <code>sendto()</code> .  Adem√°s, se realiza una llamada interna a <code>bind()</code> , por lo que <code>recvfrom()</code> posterior recibir√° una respuesta sin ejecutar expl√≠citamente bind. </li></ul><br>  En nuestro caso, el cliente recibe externamente la clave de cadena y utiliza la funci√≥n <code>resolve()</code> para obtener la direcci√≥n IP. <br><br>  En este punto, comenzamos el "apret√≥n de manos" de WebRTC si los dos pares a√∫n no est√°n conectados entre s√≠.  Las conexiones a diferentes puertos del mismo par utilizan el mismo DataRannel WebRTC. <br><br>  Tambi√©n realizamos un <code>bind()</code> indirecto <code>bind()</code> para que el servidor pueda volver a conectarse en el pr√≥ximo <code>sendto()</code> en caso de que se <code>sendto()</code> por alg√∫n motivo. <br><br>  El servidor recibe una notificaci√≥n cuando el cliente se conecta cuando el cliente escribe su oferta SDP bajo la informaci√≥n del puerto del servidor en Firebase, y el servidor responde con su propia respuesta. <br><br><hr><br>  El siguiente diagrama muestra un ejemplo del movimiento de mensajes para un esquema de socket y la transmisi√≥n del primer mensaje del cliente al servidor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4e/03a/024/b4e03a0246a77f74034c3b823bc7a1a6.png" width="787" height="1656"></div><br>  <i>Diagrama completo de pasos de conexi√≥n entre el cliente y el servidor</i> <br><br><h1>  Conclusi√≥n </h1><br>  Si has le√≠do hasta el final, entonces probablemente est√©s interesado en mirar la teor√≠a en acci√≥n.  El juego se puede jugar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">teeworlds.leaningtech.com</a> , ¬°pru√©balo! <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Partido amistoso entre colegas</i> <br><br>  El c√≥digo de la biblioteca de red est√° disponible gratuitamente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">Github</a> .  ¬°√önete al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">chat</a> en nuestro canal en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener">Gitter</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468031/">https://habr.com/ru/post/468031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468019/index.html">Desarrollo de sitios web en WebAssembly usando NetCore 3 y Blazor</a></li>
<li><a href="../468021/index.html">PHP, ¬øcu√°nta abstracci√≥n para la gente?</a></li>
<li><a href="../468023/index.html">Inteligencia artificial en el juego de lucha Shadow Fight 3</a></li>
<li><a href="../468025/index.html">¬øC√≥mo configurar SNI en Zimbra OSE?</a></li>
<li><a href="../468027/index.html">M√©todos de optimizaci√≥n de c√≥digo para Redd. Parte 2: memoria no almacenable en cach√© y operaci√≥n de bus paralelo</a></li>
<li><a href="../468035/index.html">Descargue la prensa con un controlador de juego u 8 patentes inusuales para dispositivos de entrada</a></li>
<li><a href="../468039/index.html">Meetup de Mosc√∫ Kubernetes # 6 en Acronis (Fiztehpark) 10/03/2019</a></li>
<li><a href="../468041/index.html">Anuncio de la interfaz web de Kubernetes Web View (y una breve descripci√≥n de otras IU web para Kubernetes)</a></li>
<li><a href="../468043/index.html">C√≥mo crear un kit de interfaz de usuario que est√© a la venta. Etapas del desarrollo de un sistema de dise√±o comercial.</a></li>
<li><a href="../468047/index.html">Trabajando con jerarqu√≠as en lsFusion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>