<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍💼 #⃣ 🙋🏻 دورة معهد ماساتشوستس للتكنولوجيا "أمن أنظمة الكمبيوتر". المحاضرة 7: جزء الحماية من Native Client الجزء 2 👩🏼‍🤝‍👨🏿 💒 👠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="معهد ماساتشوستس للتكنولوجيا. محاضرة رقم 6.858. "أمن أنظمة الكمبيوتر." نيكولاي زيلدوفيتش ، جيمس ميكنز. 2014 سنة 
 أمان أنظمة الكمبيوتر هي دورة حول تطوي...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>دورة معهد ماساتشوستس للتكنولوجيا "أمن أنظمة الكمبيوتر". المحاضرة 7: جزء الحماية من Native Client الجزء 2</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418225/" style=";text-align:right;direction:rtl"><h3 style=";text-align:right;direction:rtl">  معهد ماساتشوستس للتكنولوجيا.  محاضرة رقم 6.858.  "أمن أنظمة الكمبيوتر."  نيكولاي زيلدوفيتش ، جيمس ميكنز.  2014 سنة </h3><br>  أمان أنظمة الكمبيوتر هي دورة حول تطوير وتنفيذ أنظمة الكمبيوتر الآمنة.  تغطي المحاضرات نماذج التهديد ، والهجمات التي تهدد الأمن ، وتقنيات الأمان بناءً على العمل العلمي الحديث.  تشمل الموضوعات أمان نظام التشغيل (OS) ، والميزات ، وإدارة تدفق المعلومات ، وأمان اللغة ، وبروتوكولات الشبكة ، وأمان الأجهزة ، وأمان تطبيقات الويب. <br><br>  المحاضرة 1: "مقدمة: نماذج التهديد" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 3</a> <br>  المحاضرة 2: "السيطرة على هجمات القراصنة" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 3</a> <br>  المحاضرة 3: "تجاوزات العازلة: المآثر والحماية" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 3</a> <br>  المحاضرة 4: "فصل الامتيازات" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 3</a> <br>  المحاضرة 5: "من أين تأتي أنظمة الأمن؟" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 2</a> <br>  المحاضرة 6: "الفرص" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 3</a> <br>  المحاضرة 7: "وضع حماية العميل الأصلي" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 3</a> <a name="habracut"></a><br><br>  <b>الجمهور:</b> لماذا يجب أن يبدأ نطاق سعة ذاكرة نطاق العنوان من نقطة الصفر؟ <br><br>  <b>الأستاذ:</b> لأنه من حيث الأداء ، يكون استخدام القفزة الهدف أكثر كفاءة إذا كنت تعلم أن العنوان الصحيح هو مجموعة مستمرة من العناوين بدءًا من الصفر.  لأنه بعد ذلك يمكنك القيام بذلك باستخدام قناع <b>AND</b> واحد ، حيث تكون جميع البتات العالية واحدة فقط زوج من البتات المنخفضة هو صفر. <br><br>  <b>الجمهور:</b> اعتقدت أن القناع <b>AND</b> كان من المفترض أن يوفر المحاذاة. <br><br>  <b>البروفيسور:</b> حسنًا ، القناع يوفر محاذاة ، ولكن لماذا يبدأ من الصفر؟  أعتقد أنهم يعتمدون على <b>الأجهزة</b> المجزأة.  لذلك ، يمكنهم استخدامها لتحريك المنطقة لأعلى ، من حيث المساحة الخطية.  أو ربما يتعلق الأمر فقط بكيفية "رؤية" التطبيق لهذا النطاق.  في الواقع ، يمكنك وضعه في تعويضات مختلفة في مساحة العنوان الافتراضية الخاصة بك.  سيسمح لك هذا بتنفيذ حيل معينة مع أجهزة مقسمة لتشغيل وحدات متعددة في نفس مساحة العنوان. <br><br><img src="https://habrastorage.org/webt/_r/ef/sc/_refscc89wngsofm0ajoa0eflym.jpeg"><br><br>  <b>الحضور:</b> ربما لأنهم يريدون "التقاط" نقطة استقبال المؤشر الفارغ؟ <br><br>  <b>الأستاذ:</b> نعم ، لأنهم يريدون التقاط جميع نقاط الاستقبال.  ولكن لديك طريقة للقيام بذلك.  لأن المؤشر الفارغ يشير إلى المقطع الذي يتم الوصول إليه.  وإذا قمت بنقل المقطع ، يمكنك عرض صفحة صفرية غير مستخدمة في بداية كل جزء.  لذلك سيساعد هذا في صنع بعض الوحدات. <br><br>  أعتقد أن أحد أسباب هذا القرار - لبدء النطاق من 0 - يرجع إلى رغبتهم في نقل برنامجهم إلى منصة <b>x64</b> ، التي لديها تصميم مختلف قليلاً.  لكن مقالهم لا يقول هذا.  في تصميم 64 بت ، تخلصت المعدات نفسها من بعض أجهزة التجزئة ، والتي اعتمدوا عليها لأسباب الكفاءة ، لذلك كان عليهم توفير نهج موجه نحو البرامج.  ومع ذلك ، بالنسبة إلى <b>الإصدار x32 ،</b> لا يزال هذا ليس سببًا جيدًا لبدء المساحة من نقطة الصفر. <br><br>  لذا ، نواصل السؤال الرئيسي - ماذا نريد أن نضمن من وجهة نظر أمنية.  دعونا نقترب من هذه المسألة "بسذاجة" إلى حد ما ونرى كيف يمكننا تدمير كل شيء ، ثم محاولة إصلاحه. <br><br>  أعتقد أن الخطة الساذجة هي البحث عن التعليمات المحظورة بمجرد مسح الملف التنفيذي من البداية إلى النهاية.  فكيف يمكنك اكتشاف هذه التعليمات؟  يمكنك ببساطة أخذ كود البرنامج ووضعه في سطر عملاق من صفر إلى 256 ميجابايت ، اعتمادًا على حجم التعليمات البرمجية الخاصة بك ، ثم بدء البحث. <br><br><img src="https://habrastorage.org/webt/nl/vt/rv/nlvtrvk-s3z8c_yhuugx0zqaxyc.jpeg"><br><br>  قد يحتوي هذا السطر أولاً على وحدة تعليمات <b>NOP</b> ، ثم وحدة تعليمات <b>ADD</b> ، <b>NOT</b> ، <b>JUMP ،</b> وما إلى ذلك.  ما عليك سوى البحث ، وإذا وجدت تعليمات سيئة ، فقل أنها وحدة سيئة وتخلص منها.  وإذا كنت لا ترى أي استدعاء للنظام لهذه التعليمات ، فيمكنك تمكين تشغيل هذه الوحدة والقيام بكل شيء في نطاق 0-256.  هل تعتقد أن هذا سيعمل أم لا؟  ما الذي يقلقهم؟  لماذا هو صعب جدا؟ <br><br>  <b>الجمهور:</b> هل هم قلقون من حجم التعليمات؟ <br><br>  <b>الأستاذ:</b> نعم ، الحقيقة هي أن منصة <b>x86</b> لها تعليمات متغيرة الطول.  هذا يعني أن الحجم الدقيق للإرشادات يعتمد على البايتات القليلة الأولى من هذا الإرشاد.  في الواقع ، يمكنك إلقاء نظرة على البايت الأول لتقول أن التعليمات ستكون أكبر بكثير ، وبعد ذلك قد تضطر إلى النظر في بضعة بايتات أخرى ، ثم تقرر الحجم الذي تحتاجه.  تحتوي بعض البنى مثل <b>Spark</b> و <b>ARM</b> و <b>MIPS</b> على تعليمات أكثر طولًا.  يحتوي <b>ARM</b> على أطوال تعليمات - 2 أو 4 بايت.  ولكن على النظام الأساسي <b>x86 ،</b> يمكن أن يكون طول التعليمات 1 و 5 و 10 بايت ، وإذا حاولت ، يمكنك حتى الحصول على تعليمات طويلة إلى حد ما من 15 بايت.  ومع ذلك ، هذه تعليمات معقدة. <br><br>  نتيجة لذلك ، قد تظهر مشكلة.  إذا قمت بمسح هذا السطر من التعليمات البرمجية بشكل خطي ، فسيكون كل شيء على ما يرام.  ولكن ربما في وقت التشغيل ، ستذهب إلى منتصف نوع من التعليمات ، على سبيل المثال ، <b>لا</b> . <br><br><img src="https://habrastorage.org/webt/ob/rv/lj/obrvlj58uew5ji8-9mev7cxwb04.jpeg"><br><br>  من الممكن أن تكون هذه تعليمات متعددة البايت ، وإذا قمت بتفسيرها بدءًا من البايت الثاني ، فستبدو مختلفة تمامًا. <br><br>  مثال آخر سنلعب فيه مع المجمع.  لنفترض أن لدينا تعليمات <b>25 CD 80 00 00</b> .  بعد النظر في البايت الثاني ، سوف تفسره على أنه تعليمات من خمسة بايت ، أي أنه يجب عليك النظر إلى 5 بايت إلى الأمام ورؤية أنه متبوعًا بإرشادات <b>AND٪ EAX ، 0x00 00 80 قرص مضغوط</b> ، بدءًا من عامل التشغيل <b>AND</b> لسجل <b>EAX</b> مع بعض ثوابت محددة ، على سبيل المثال ، <b>00 00 80 CD</b> .  هذه إحدى الإرشادات الآمنة التي يجب على <b>العميل الأصلي</b> السماح بها ببساطة من خلال القاعدة الأولى للتحقق من التعليمات الثنائية.  ولكن إذا قررت <b>وحدة المعالجة المركزية</b> ، أثناء تنفيذ البرنامج ، أنه يجب أن تبدأ في تنفيذ التعليمات البرمجية من <b>القرص المضغوط</b> ، فسأضع علامة على هذا المكان من التعليمات بسهم ، فإن التعليمات <b>٪ EAX ، 0x00 00 80 CD</b> ، والتي هي في الواقع تعليمات من 4 بايت ، تعني تنفيذ <b>INT 0x80 دولارًا</b> ، وهي طريقة لإجراء مكالمة نظام على <b>Linux</b> . <br><br><img src="https://habrastorage.org/webt/ib/3a/zp/ib3azp3oe9zmfedweosbecx9fto.jpeg"><br><br>  لذا إذا فاتتك هذه الحقيقة ، فدع الوحدة غير الموثوق بها "تقفز" إلى النواة وإجراء مكالمات النظام ، أي افعل ما تريد منعه.  كيف يمكننا تجنب ذلك؟ <br><br>  ربما يجب أن نحاول النظر إلى إزاحة كل بايت.  لأن x86 يمكن أن يبدأ فقط تفسير التعليمات في حدود البايت ، وليس بت.  وبالتالي ، عليك أن تنظر في إزاحة كل بايت لمعرفة أين يبدأ التعليمات.  هل تعتقد أن هذه خطة مجدية؟ <br><br>  <b>الجمهور:</b> أعتقد أنه إذا كان شخص ما يستخدم بالفعل <b>و</b> ، فلن يقفز المعالج إلى هذا المكان ، ولكنه ببساطة يسمح بتشغيل البرنامج. <br><br>  <b>الأستاذ:</b> نعم ، لأنه في الأساس ليس عرضة لإيجابيات كاذبة.  الآن ، إذا كنت تريده حقًا ، يمكنك تغيير الرمز قليلاً لتجنبه بطريقة أو بأخرى.  إذا كنت تعرف بالضبط ما يبحث عنه جهاز الاختبار ، فمن المحتمل أن تغير هذه التعليمات.  ربما عن طريق إعداد <b>AND</b> أولاً لإرشادات واحدة ، ثم استخدم القناع على آخر.  ولكن من الأسهل تجنب هذه الترتيبات المشبوهة للبايت ، على الرغم من أن هذا يبدو غير مريح إلى حد ما. <br><br>  من الممكن أن تحتوي الهندسة على تغيير مترجم.  في الأساس ، لديهم نوع من المكونات يحتاج بالفعل إلى ترجمة التعليمات البرمجية بشكل صحيح.  لا يمكنك فقط "خلع" <b>GCC</b> وترجمة التعليمات البرمجية لـ <b>Native Client</b> .  لذلك في الأساس هذا ممكن.  ولكن على الأرجح ، يعتقدون فقط أنه يسبب الكثير من المتاعب ، ولن يكون حلاً موثوقًا أو عالي الأداء ، وما إلى ذلك.  بالإضافة إلى ذلك ، هناك العديد من تعليمات <b>x86</b> المحظورة ، أو التي يجب اعتبارها غير آمنة ، وبالتالي يجب حظرها.  ولكن بالنسبة للجزء الأكبر فهي بحجم بايت واحد ، لذا من الصعب العثور عليها أو تصفيتها. <br><br>  لذلك ، إذا لم يتمكنوا من جمع وتصنيف التعليمات غير الآمنة والأمل في الأفضل ، فإنهم بحاجة إلى استخدام خطة مختلفة من أجل تفكيكها بطريقة موثوقة.  إذن ، ما الذي يفعله <b>Native Client</b> للتأكد من أنه لا "يتعثر" في هذا الترميز المتغير الطول؟ <br><br>  بمعنى ما ، إذا قمنا بالفعل بمسح الملف القابل للتنفيذ من اليسار إلى اليمين وبحثنا عن جميع الرموز غير الصحيحة المحتملة ، وإذا كانت هذه هي الطريقة التي يعمل بها الرمز ، فنحن في حالة جيدة.  حتى إذا كانت هناك بعض التعليمات الغريبة وبعض التحيز ، فإن المعالج لن يستمر في "القفز" هناك ، فسيقوم بتنفيذ البرنامج بنفس الترتيب الذي يتم فيه مسح التعليمات ، أي من اليسار إلى اليمين. <br><br><img src="https://habrastorage.org/webt/kh/v0/ea/khv0ea7apzgmwqnx1pbaj8k1fgy.jpeg"><br><br>  وبالتالي ، تنشأ مشكلة التفكيك الموثوق به نظرًا لوجود "قفزات" في مكان ما من التطبيق.  قد يفشل المعالج إذا قام "بقفزة" إلى بعض التعليمات البرمجية التي لم يلاحظها عند المسح من اليسار إلى اليمين.  لذا فهذه مشكلة تفكيك موثوق به حتى الآن قيد التطوير.  والخطة الرئيسية هي التحقق من أين تؤدي كل "القفزات".  في الواقع ، إنها بسيطة للغاية على مستوى ما.  هناك مجموعة من القواعد التي سنأخذها بعين الاعتبار في ثانية ، ولكن الخطة التقريبية هي أنه إذا رأيت تعليمات "القفز" ، فأنت بحاجة إلى التأكد من أن الغرض من "القفز" قد لوحظ في وقت سابق.  للقيام بذلك ، في الواقع ، يكفي المسح من اليسار إلى اليمين ، أي الإجراء الذي وصفناه في نهجنا الساذج للمشكلة. <br><br>  في هذه الحالة ، إذا رأيت أي تعليمات "انتقال" والعنوان الذي تشير إليه هذه التعليمات ، فيجب عليك التأكد من أن هذا هو نفس العنوان الذي رأيته بالفعل أثناء التفكيك من اليسار إلى اليمين. <br><br>  إذا تم العثور على تعليمة قفزة لبايت القرص المضغوط هذا ، فيجب أن نضع علامة على هذه القفزة على أنها غير صالحة لأننا لم نشاهد التعليمات التي تبدأ في بايت القرص المضغوط ، لكننا رأينا تعليمات أخرى تبدأ بالرقم 25. ولكن إذا كانت جميع تعليمات القفزة أمر بالذهاب إلى بداية التعليمات ، في هذه الحالة إلى 25 ، ثم كل شيء على ما يرام لدينا.  هل هذا واضح؟ <br><br>  المشكلة الوحيدة هي أنه لا يمكنك التحقق من أهداف كل قفزة في البرنامج ، لأنه قد تكون هناك قفزات غير مباشرة.  على سبيل المثال ، في <b>x86 ،</b> قد يكون لديك شيء مثل القفز إلى قيمة سجل <b>EAX</b> هذا.  هذا أمر رائع لتنفيذ مؤشرات الوظيفة. <br><br><img src="https://habrastorage.org/webt/uf/gh/bl/ufghbl_dd-pofxnrp7fy-ne3ee0.jpeg"><br><br>  أي أن مؤشر الوظيفة موجود في مكان ما في الذاكرة ، يمكنك الاحتفاظ به في سجل ما ، ثم الانتقال إلى أي عنوان في سجل الحركة. <br><br>  فكيف يتعامل هؤلاء مع القفزات غير المباشرة؟  لأنه في الواقع ، ليس لدي أي فكرة عما إذا كان هذا سيكون "قفزة" لبايت <b>القرص المضغوط</b> أو البايت 25. ماذا يفعلون في هذه الحالة؟ <br><br>  <b>الجمهور:</b> استخدام الأدوات؟ <br><br>  <b>الأستاذ:</b> نعم ، الأجهزة هي خدعتهم الرئيسية.  لذلك ، كلما رأوا أن المترجم مستعد لأداء الجيل ، فهذا دليل على أن هذه القفزة لن تسبب مشاكل.  للقيام بذلك ، يحتاجون إلى التأكد من تنفيذ جميع القفزات بتعدد 32 بايت.  كيف يفعلون ذلك؟  يغيرون كل تعليمات القفز إلى ما يسمونه "تعليمات زائفة".  هذه هي نفس التعليمات ، ولكنها مسبقة ، والتي تمسح البتات المنخفضة الخمسة في سجل <b>EAX</b> .  حقيقة أن التعليمات تزيل 5 بتات منخفضة تعني أنها تتسبب في أن تكون القيمة المعطاة من مضاعفات 32 ، من اثنين إلى خمسة ، ثم يتم تنفيذ قفزة في هذه القيمة بالفعل. <br><br><img src="https://habrastorage.org/webt/r3/sf/nq/r3sfnqlxz3egqe8q-0ret79kwzu.jpeg"><br><br>  إذا نظرت إلى هذا أثناء التحقق ، فتأكد من أن هذا "الزوج" التعليمي سوف "يقفز" فقط مع تعدد 32 بايت.  وبعد ذلك ، من أجل التأكد من عدم وجود إمكانية "القفز" في بعض التعليمات الغريبة ، يمكنك تطبيق قاعدة إضافية.  وهو يتألف من حقيقة أنه أثناء التفكيك ، عندما تنظر إلى التعليمات الخاصة بك من اليسار إلى اليمين ، فإنك تتأكد من أن بداية كل تعليمة صالحة ستكون أيضًا مضاعفات 32 بايت. <br><br>  وبالتالي ، بالإضافة إلى مجموعة الأدوات هذه ، يمكنك التحقق من أن كل رمز من مضاعفات 32 هو التعليمات الصحيحة.  بواسطة تعليمات صالحة ، أعني تعليمات مفككة من اليسار إلى اليمين. <br><br>  <b>الجمهور:</b> لماذا تم اختيار الرقم 32؟ <br><br>  <b>الأستاذ:</b> نعم ، لماذا اختاروا 32 بدلا من 1000 أو 5؟  لماذا 5 سيئ؟ <br><br>  <b>الجمهور:</b> لأن الرقم يجب أن يكون قوة 2. <br><br>  <b>الأستاذ:</b> نعم ، هذا هو السبب.  لأنه بخلاف ذلك ، سيتطلب ضمان استخدام شيء ما من مضاعفات 5 تعليمات إضافية تؤدي إلى النفقات العامة.  ماذا عن ثمانية؟  هل ثمانية عدد جيد بما فيه الكفاية؟ <br><br>  <b>الجمهور:</b> قد يكون لديك تعليمات أطول من ثمانية بت. <br><br>  <b>الأستاذ:</b> نعم ، قد يكون هذا لأطول تعليمات مسموح بها على منصة x86.  إذا كان لدينا تعليمات من 10 بايت ، ويجب أن يكون كل شيء من مضاعفات 8 ، فلن نتمكن من إدراجه في أي مكان.  لذا يجب أن يكون الطول كافياً لجميع الحالات ، لأن أكبر تعليمة رأيتها كانت بطول 15 بايت.  حتى 32 بايت كافية. <br><br>  إذا كنت ترغب في تكييف التعليمات لإدخال أو الخروج من بيئة خدمة العملية ، فقد تحتاج إلى قدر غير عادي من التعليمات البرمجية في فتحة واحدة 32 بايت.  على سبيل المثال ، 31 بايت ، لأن 1 بايت يحتوي على تعليمات.  هل يجب أن تكون أكبر بكثير؟  هل يجب أن نجعل هذا يساوي 1024 بايت على سبيل المثال؟  إذا كان لديك العديد من المؤشرات الوظيفية أو العديد من القفزات غير المباشرة ، في كل مرة تريد إنشاء مكان حيث ستقفز ، يجب عليك مواصلته إلى الحد التالي ، بغض النظر عن قيمته.  حتى مع 32 بت حجمها طبيعي جدا.  في أسوأ السيناريوهات ، ستفقد 31 بايت فقط إذا كنت بحاجة للوصول بسرعة إلى الحد التالي.  ولكن إذا كان لديك حجم مضاعف 1024 بايت ، فهناك إمكانية لإضاعة كيلوبايت كامل من الذاكرة عبثا لقفز غير مباشر.  إذا كان لديك وظائف قصيرة أو العديد من المؤشرات الوظيفية ، فإن مثل هذا الحجم الكبير لتعدد طول "القفزة" سيؤدي إلى إهدار كبير للذاكرة. <br><br>  لا أعتقد أن الرقم 32 يمثل حجر عثرة أمام <b>Native Client</b> .  يمكن أن تعمل بعض الكتل مع تعدد 16 بت ، حوالي 64 أو 128 بت ، لا يهم.  بدت لهم 32 بت فقط القيمة المثلى والمقبولة. <br><br>  لذا ، دعونا نضع خطة للتفكيك الموثوق به.  نتيجة لذلك ، يجب أن يكون المترجم حذرا قليلا عند تجميع <b>كود</b> <b>C</b> أو <b>C ++</b> في ثنائي <b>Native Client</b> وملاحظة القواعد التالية. <br><br><img src="https://habrastorage.org/webt/c0/nh/kc/c0nhkc4izpqqyrj_rtr2gg-eytu.jpeg"><br><br>  لذلك ، كلما كان لديه قفزة ، كما هو موضح في السطر العلوي ، يجب عليه إضافة هذه التعليمات الإضافية الواردة في السطرين السفليين.  وبغض النظر عن حقيقة أنه ينشئ وظيفة سيقوم "بالقفز إليها" ، فإن تعليماتنا ستقفز كما تشير الإضافة <b>و $ 0xffffffe0 ،٪ eax</b> .  ولا يمكن أن تكمله بالأصفار فقط ، لأن كل هذا يجب أن يحتوي على الرموز الصحيحة.  وبالتالي ، فإن الإضافة ضرورية للتأكد من صحة كل تعليمات ممكنة.  ولحسن الحظ ، على منصة <b>x86</b> ، لا يتم وصف وظيفة <b>noop</b> واحدة بايت واحد ، أو على الأقل لا يوجد بايت واحد <b>noop</b> 1 في الحجم.  وبالتالي ، يمكنك دائمًا إضافة أشياء إلى قيمة الثابت. <br><br>  فماذا يضمن لنا ذلك؟  دعونا نتأكد من أننا نرى دائمًا ما يحدث في مصطلحات التعليمات التي سيتم اتباعها.  إليك ما تقدمه لنا هذه القاعدة - التأكيد على أن مكالمة النظام لن تتم عن طريق الصدفة.  هذا ينطبق على القفزات ، ولكن ماذا عن العوائد؟  كيف يتعاملون مع العائدات؟  هل يمكننا <b>العودة</b> إلى وظيفة في <b>Native Client</b> ؟  ماذا يحدث إذا قمت بتشغيل الرمز الساخن؟ <br><br>  <b>الجمهور:</b> يمكنه تجاوز المكدس. <br><br>  <b>الأستاذ:</b> صحيح أنه ينبثق بشكل غير متوقع على المكدس.  ولكن الحقيقة هي أن المكدس المستخدم بواسطة وحدات <b>Native Client</b> يحتوي بالفعل على بعض البيانات في الداخل.  وبالتالي ، عند التعامل مع <b>Native Client ،</b> لا داعي للقلق بشأن تجاوز سعة المكدس. <br><br>  <b>الجمهور:</b> انتظر ، ولكن يمكنك وضع أي شيء على المكدس.  وعندما تأخذ قفزة غير مباشرة. <br><br>  <b>الأستاذ:</b> هذا صحيح.  يبدو العائد تقريبًا مثل قفزة غير مباشرة من مكان ما في الذاكرة ، والذي يقع في الجزء العلوي من المكدس.  لذلك ، أعتقد أن الشيء الوحيد الذي يمكنهم القيام به لوظيفة <b>العودة</b> هو تعيين البادئة بنفس الطريقة كما في الاختيار السابق.  وتتحقق هذه البادئة من ما ينبثق في أعلى المكدس.  أنت تتحقق مما إذا كان هذا صحيحًا ، وعندما تكتب أو تستخدم عامل التشغيل <b>AND</b> ، فإنك تتحقق مما يوجد في أعلى المكدس.  يبدو هذا غير موثوق به بعض الشيء بسبب التغيير المستمر للبيانات.  لأنه ، على سبيل المثال ، إذا نظرت إلى الجزء العلوي من المكدس وتأكدت من أن كل شيء على ما يرام هناك ، ثم قمت بكتابة شيء ما ، فقد يقوم دفق البيانات في نفس الوحدة النمطية بتعديل شيء في الجزء العلوي من المكدس ، وبعد ذلك ستشير إلى العنصر الخاطئ العنوان <br><br>  <b>الجمهور:</b> هل هذا لا ينطبق على القفز بنفس القدر؟ <br><br>  <b>الأستاذ:</b> نعم ، فماذا يحدث هناك بقفزة؟  هل يمكن لظروف عرقنا إبطال هذا الاختبار بطريقة أو بأخرى؟ <br><br>  <b>الجمهور:</b> ولكن هل الكود غير قابل للكتابة؟ <br><br>  <b>الأستاذ:</b> نعم ، لا يمكن كتابة الرمز ، هذا صحيح.  لذلك ، لا يمكنك تعديل AND.  ولكن ألا يمكن لبعض التيار الآخر تغيير الغرض من القفزة بين هذين التوجيهين؟ <br><br>  <b>الجمهور:</b> هذا في السجل ، لذلك ... <br><br>  <b>الأستاذ:</b> نعم ، هذا شيء رائع.  لأنه إذا قام الدفق بتعديل شيء ما في الذاكرة أو في ما يتم تحميله من <b>EAX</b> (في حد ذاته ، يمكنك القيام بذلك قبل التنزيل) ، في هذه الحالة سيكون <b>EAX</b> في حالة سيئة ، ولكن بعد ذلك سوف يمحو البتات السيئة.  أو يمكنه تغيير الذاكرة بعد ذلك ، عندما يكون المؤشر بالفعل في <b>EAX</b> ، لذلك لا يهم أنه يغير موقع الذاكرة التي تم تحميل سجل <b>EAX منها</b> . <br><br>  في الواقع ، لا تشارك مؤشرات الترابط مجموعات التسجيل.  لذلك ، إذا قام مؤشر ترابط آخر بتغيير سجل <b>EAX</b> ، فلن يؤثر ذلك على سجل <b>EAX</b> لمؤشر الترابط هذا.  لذلك ، لا يمكن لمؤشرات الترابط الأخرى إبطال هذا التسلسل من التعليمات. <br><br>  هناك سؤال آخر مثير للاهتمام.  هل يمكننا الالتفاف على هذا <b>و</b> ؟  يمكنني القفز أينما أريد في أي مكان في مساحة العنوان هذه.      ,       <b>AND</b>  . <br><br><img src="https://habrastorage.org/webt/4p/vf/nk/4pvfnkoa0kmui9vdd5wn2o-jbk0.jpeg"><br><br>       ,      ,   ,    ,  ,        <b>AND</b> .    .     <b>jmp</b> ,      . <br><br><img src="https://habrastorage.org/webt/kg/mf/cu/kgmfcuyc42v0rtkdtzt1ptm1ty4.jpeg"><br><br> ,      ,    -  ,    1237.     ,     32.  <b>Native Client</b>       ,     ,      ,     .          ,   ,      1237      ? <br><br><img src="https://habrastorage.org/webt/dn/_-/_r/dn_-_r-vi7p_qx7nxwwkqmroh-w.jpeg"><br><br>    -  <b>EAX</b> ,   , ,        ,      .  ,    ?     ? <br><br> <b>:</b> <b>NaCl</b>   ,      . <br><br> <b>:</b> ,       .      <b>x86</b>    ,    ,   <b>NaCl</b>   ,  2          .       ,    ,  : «,    ,    !»,              <b>25 CD 80 00 00</b> .     .         ,     <b>x86</b> . <br><br>   ,   <b>Native Client</b>      . ,       ,   ,    ,          <b>NaCl</b> . ,     . <br><br> <b>:</b> ,        ,     .     ,         .  ,      ,     ,       ,     . <br><br><img src="https://habrastorage.org/webt/sq/hd/pl/sqhdplwnbsfj55r8qmp6trwxk5y.jpeg"><br><br> <b>:</b> ,  .     ,   . ,       ,      ,   <b>EAX</b> .           ,   -  .        <b>EAX</b> ,  <b>EBX</b>   .           ,       .          <b>EAX</b>  <b>EBX</b>  <b>AND</b>   .     ,  ,      <b>EAX</b> ,         .         ,   -   <b>64</b>  .    <b>Jmp *% eax</b>   <b>AND</b>   . <br><br><img src="https://habrastorage.org/webt/qz/nf/zt/qznfzt9lqpfreshgcc76zygs8cq.jpeg"><br><br> ,   , ,   ,   .   <b>Intel</b> ,        ,  ,   ,      .       ,   ,             .       <b>AND</b>    ,   <b>EAX</b>  ,    «» . <br><br> ,       ,           .     ,       .     ,    ,   ,   .      ,  ,   ,    . <br> ,     ,  <b>C1</b>  <b>C7</b> . <br><br> <b>C1</b>   ,       ,            .     ,     «»     .   ,       ,      .   ,       ,     - .  ,    . <br> <b>2</b> ,     0   <b>64</b> .     ,     ,        .        ,      ,      . <br><br>  <b>3</b> ,  ,  ,   .        ,  ,         . <br><br> <b>4</b>   ,         <b>hlt</b> .             <b>halt</b> ?     ,  <b>C4</b> .   ,   ,      -  ,      . <br><br>     ,  ,          ? ,          ,      -  . <br>     ,     ,  ,       ,       .    ,       ,     ,  ,           .         . <br><br><img src="https://habrastorage.org/webt/9i/1f/yj/9i1fyjdue4tun6jsa8gnnzkue9c.jpeg"><br><br> 55:20  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">دورة معهد ماساتشوستس للتكنولوجيا "أمن أنظمة الكمبيوتر".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="> 7: « Native Client»,  3</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/I0Psvvky-44" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="></a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br> <b>3  </b>    Dell R630     — <b>2  Intel Deca-Core Xeon E5-2630 v4 / 128GB DDR4 / 41TB HDD  2240GB SSD / 1Gbps 10 TB —  $99,33 </b> ,    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هنا</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ديل R730xd أرخص مرتين؟ </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">فقط لدينا </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV من 249 دولارًا</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> في هولندا والولايات المتحدة! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اقرأ عن </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كيفية بناء مبنى البنية التحتية </font><font style="vertical-align: inherit;">الطبقة باستخدام خوادم Dell R730xd E5-2650 v4 بتكلفة 9000 يورو مقابل سنت واحد؟</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar418225/">https://habr.com/ru/post/ar418225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar418215/index.html">دورة معهد ماساتشوستس للتكنولوجيا "أمن أنظمة الكمبيوتر". المحاضرة 5: "من أين تأتي أخطاء نظام الأمان" ، الجزء 2</a></li>
<li><a href="../ar418217/index.html">دورة معهد ماساتشوستس للتكنولوجيا "أمن أنظمة الكمبيوتر". المحاضرة 6: "الفرص" ، الجزء 1</a></li>
<li><a href="../ar418219/index.html">دورة معهد ماساتشوستس للتكنولوجيا "أمن أنظمة الكمبيوتر". المحاضرة 6: الفرص ، الجزء 2</a></li>
<li><a href="../ar418221/index.html">دورة معهد ماساتشوستس للتكنولوجيا "أمن أنظمة الكمبيوتر". المحاضرة 6: "الفرص" ، الجزء 3</a></li>
<li><a href="../ar418223/index.html">دورة معهد ماساتشوستس للتكنولوجيا "أمن أنظمة الكمبيوتر". المحاضرة 7: صندوق حماية Native Client ، الجزء الأول</a></li>
<li><a href="../ar418227/index.html">دورة معهد ماساتشوستس للتكنولوجيا "أمن أنظمة الكمبيوتر". المحاضرة 7: رمل العميل الأصلي ، الجزء 3</a></li>
<li><a href="../ar418229/index.html">دورة معهد ماساتشوستس للتكنولوجيا "أمن أنظمة الكمبيوتر". المحاضرة 8: نموذج أمن الشبكات ، الجزء 1</a></li>
<li><a href="../ar418233/index.html">فن الإستذكار من BMW لإيجاد قيم الحدود</a></li>
<li><a href="../ar418235/index.html">ملحمة منظمة أو كيفية بناء المعاملات التجارية في الخدمات باستخدام قاعدة البيانات لكل نمط خدمة</a></li>
<li><a href="../ar418237/index.html">تطوير تطبيقات متعددة المستأجرين على SAP Cloud Platform في Neo ، الجزء 2: التفويض والمصادقة</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>