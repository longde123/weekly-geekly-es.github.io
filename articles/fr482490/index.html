<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🔧 🕞 🤜🏾 Qu'est-ce que MISRA et comment le faire cuire 👔 🤹🏾 👩‍👩‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Peut-être que chaque développeur de programmes pour microcontrôleurs a probablement entendu au moins une fois parler de normes de codage spéciales con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qu'est-ce que MISRA et comment le faire cuire</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/482490/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf9/5bc/021/cf95bc0219fd9e34f03d5cfc316f7e71.png" alt="Figure 1"></div><br><br>  Peut-être que chaque développeur de programmes pour microcontrôleurs a probablement entendu au moins une fois parler de normes de codage spéciales conçues pour aider à augmenter la sécurité et la portabilité de votre code.  L'une de ces normes est MISRA.  Dans cet article, nous examinerons plus en détail ce qu'est ce standard, quelle est sa philosophie et comment l'utiliser dans vos projets. <br><a name="habracut"></a><br>  Beaucoup de nos lecteurs ont entendu dire que PVS-Studio prend en charge la classification de leurs alertes selon la norme MISRA.  PVS-Studio <a href="https://www.viva64.com/ru/misra/">couvre actuellement</a> plus de 100 règles MISRA C: 2012 et MISRA C ++: 2008. <br><br>  Cet article vise à tuer trois oiseaux avec une pierre: <br><br><ol><li>  Dites ce qu'est MISRA pour ceux qui ne sont pas familiers avec cette norme; </li><li>  Rappeler au monde intégré ce dont nous sommes capables; </li><li>  Pour aider à approfondir le cours des affaires pour les nouveaux employés qui développeront également notre analyseur MISRA; </li></ol><br>  J'espère que je pourrai le rendre intéressant.  Commençons donc! <br><br><h2>  L'histoire de MISRA </h2><br>  L'histoire de MISRA a commencé il y a longtemps.  Puis, au début des années 90, le programme du gouvernement britannique sous le nom indicatif "Safe IT" a alloué des fonds à divers projets, d'une manière ou d'une autre liés à la sécurité des systèmes électroniques.  Le projet MISRA (Motor Industry Software Reliability Association) lui-même a été fondé pour créer un guide pour le développement de logiciels pour les microcontrôleurs dans les véhicules terrestres - dans les voitures en général. <br><br>  Ayant reçu un financement de l'État, l'équipe MISRA s'est mise au travail et, en novembre 1994, a publié son premier guide: " <a href="https://pdfs.semanticscholar.org/f7ab/6319c0ab1fb546e406a3f65463cd0e5d2f0c.pdf">Lignes directrices pour le développement de logiciels basés sur les véhicules</a> ".  Ce guide n'est pas encore lié à un langage spécifique, mais je dois l'avouer: le travail était impressionnant et concernait probablement tous les aspects imaginables du développement de logiciels embarqués.  Soit dit en passant, les développeurs de ce guide ont récemment <a href="https://www.misra.org.uk/LinkClick.aspx%3Ffileticket%3DpHorDgiWiPs%253D%26amp%3Btabid%3D59">célébré le 25e anniversaire d'</a> une date aussi importante pour eux. <br><br>  Lorsque le financement de l'État a pris fin, les membres de la MISRA ont décidé de continuer à travailler ensemble sur une base informelle - cela continue à ce jour.  En fait, MISRA (en tant qu'organisation) est une communauté d'intervenants de diverses industries de fabrication d'automobiles et d'avions.  Maintenant, ces parties sont: <br><br><ul><li>  Voitures à moteur Bentley </li><li>  Ford Motor Company </li><li> Jaguar land rover </li><li>  Systèmes diesel Delphi </li><li>  HORIBA MIRA </li><li>  Protean électrique </li><li>  Services d'ingénierie Visteon </li><li>  L'université de leeds </li><li>  Ricardo uk </li><li>  ZF TRW </li></ul><br>  Des acteurs du marché très forts, non?  Sans surprise, leur première norme liée au langage, MISRA C, est devenue largement acceptée par les développeurs embarqués critiques.  MISRA C ++ est apparu un peu plus tard.  Progressivement, les versions des normes ont été mises à jour et affinées pour couvrir les nouvelles fonctionnalités des langues.  Au moment d'écrire ces lignes, les versions actuelles sont MISRA C: 2012 et MISRA C ++: 2008. <br><br><h2>  Philosophie et exemples de règles </h2><br>  Les caractéristiques les plus distinctives de MISRA sont son incroyable attention aux détails et son extrême minutie pour assurer la sécurité.  Les auteurs ont non seulement rassemblé en un seul endroit tous les «trous» C et C ++ qui leur venaient à l'esprit (comme, par exemple, les auteurs du CERT) - ils ont soigneusement élaboré les normes internationales de ces langages et noté toutes les façons imaginables et inconcevables de faire des erreurs.  Et puis ils ont pris et ajouté les règles sur la lisibilité du code d'en haut - c'est pour rendre plus difficile l'introduction d'une nouvelle erreur dans du code déjà propre. <br><br>  Pour comprendre l'étendue du sérieux, considérez quelques règles tirées de la norme. <br><br>  D'une part, il existe de nombreuses bonnes règles appropriées qui doivent toujours être suivies à tout moment, quel que soit le but de votre projet.  Pour la plupart, ils sont conçus pour éliminer les comportements indéfinis / non spécifiés / dépendants de l'implémentation.  Par exemple: <br><br><ul><li>  N'utilisez pas la valeur d'une variable non initialisée </li><li>  N'utilisez pas le pointeur FILE après avoir fermé le flux </li><li>  Toutes les fonctions non nulles doivent renvoyer une valeur. </li><li>  Le compteur de boucle ne doit pas avoir de type virgule flottante </li><li>  ... etc. </li></ul><br>  D'un autre côté, il y a des règles dont les bénéfices se trouvent à la surface, mais qui (du point de vue des projets ordinaires) ne sont pas si coupables de briser: <br><br><ul><li>  N'utilisez pas goto et longjmp </li><li>  Chaque commutateur doit se terminer par défaut </li><li>  N'écrivez pas de code inaccessible </li><li>  N'utilisez pas de fonctions variables </li><li>  N'utilisez pas l'arithmétique d'adresse (sauf <i>[]</i> et <i>++</i> ) </li><li>  ... </li></ul><br>  De telles règles ne sont pas non plus mauvaises et, combinées aux précédentes, elles donnent déjà une augmentation tangible de la sécurité, mais est-ce suffisant pour des systèmes embarqués hautement responsables?  Ils sont utilisés non seulement dans l'industrie automobile, mais aussi dans la fabrication d'aéronefs, l'aérospatiale, l'armée et le médical. <br><br>  Nous ne voulons pas, en raison d'une erreur logicielle, de certains <a href="https://www.viva64.com/ru/b/0438/">patients irradiés par une</a> machine à rayons X <a href="https://www.viva64.com/ru/b/0438/">avec une dose de 20 000 rad</a> , donc les règles habituelles «quotidiennes» ne suffisent plus.  L'enjeu est la vie humaine et d'énormes sommes d'argent, et la minutie doit être incluse.  Ici, le reste des règles MISRA entrent en scène: <br><ul><li>  Le suffixe «L» dans le littéral doit toujours être en majuscules (le petit «l» peut être confondu avec l'unité) </li><li>  N'utilisez pas l'opérateur virgule (cela augmente les chances de faire une erreur) </li><li>  Ne pas utiliser de récursivité (une petite pile de microcontrôleurs peut facilement déborder) </li><li>  Les corps des <i>instructions</i> <i>if</i> , <i>else</i> , <i>for</i> , <i>while</i> , <i>do</i> doivent être placés entre accolades (vous pouvez potentiellement faire une erreur si le <a href="https://www.viva64.com/ru/w/v2507/">code n'est pas aligné correctement</a> ) </li><li>  N'utilisez pas de mémoire dynamique (car il est possible de l'allouer sans succès à partir du tas, en particulier dans les microcontrôleurs) </li><li>  ... et beaucoup, beaucoup de ces règles. </li></ul><br>  Souvent, les gens qui rencontrent MISRA pensent que la philosophie de la norme est "d'interdire ceci et d'interdire cela".  En fait, c'est le cas, mais seulement en partie. <br><br>  Oui, la norme a de nombreuses règles similaires, mais son but n'est pas d'interdire tout ce qui est possible, mais d'énumérer des moyens tous ou tous de violer d'une manière ou d'une autre la sécurité du code.  Pour la plupart des règles, vous choisissez de les suivre ou non.  Je vais l'expliquer plus en détail. <br><br>  Dans MISRA C, les règles se répartissent en trois catégories principales: obligatoires, obligatoires et consultatives.  Obligatoire - ce sont des règles qui ne doivent être violées sous aucun prétexte.  Par exemple, cette section inclut la règle «ne pas utiliser la valeur d'une variable non initialisée».  Les règles requises sont moins strictes: elles permettent la possibilité d'un rejet, mais uniquement si ces écarts sont soigneusement documentés et justifiés par écrit.  Les règles restantes sont incluses dans la catégorie Avis - ce sont des règles qui ne doivent pas être suivies. <br><br>  MISRA C ++ est un peu différent: la catégorie Obligatoire y manque et la plupart des règles appartiennent à la catégorie Obligatoire.  Par conséquent, en fait, vous avez le droit de violer n'importe quelle règle - n'oubliez pas de documenter les écarts.  Il existe également une catégorie Document - ce sont des règles obligatoires (les écarts ne sont pas autorisés), qui sont associés à des pratiques courantes comme «Chaque utilisation de l'assembleur doit être documentée» ou «la bibliothèque de plug-ins doit être conforme à MISRA C ++». <br><br><h2>  Qu'y a-t-il d'autre </h2><br>  En fait, MISRA ne consiste pas seulement en un ensemble de règles.  En fait, c'est un manuel pour écrire du code sûr pour les microcontrôleurs, et donc il est plein de toutes sortes d'utilités.  Examinons-les en détail. <br><br>  Tout d'abord, la norme contient une description assez approfondie du contexte: pour ce qui a été créé, pourquoi C ou C ++ a été choisi, les avantages et les inconvénients de ces langages. <br><br>  Nous connaissons bien les vertus de ces langues.  Oui, et sur les lacunes, en général aussi :) Quelle est la complexité élevée, la spécification incomplète de la norme et la syntaxe qui permettent de faire une erreur très facilement, puis de rechercher une erreur pendant longtemps.  Par exemple, vous pourriez accidentellement écrire ceci: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i); { do_something(); }</code> </pre> <br>  Pourtant, il y a une chance qu'une personne ne remarque pas un <a href="https://www.viva64.com/ru/w/v529/">point</a> - <a href="https://www.viva64.com/ru/w/v529/">virgule supplémentaire</a> , non?  Vous pouvez également écrire <a href="https://www.viva64.com/ru/w/v559/">comme ceci</a> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpendTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> doWantToKillPeople)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doWantToKillPeople = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { StartNuclearWar(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { PlayComputerGames(); } }</code> </pre> <br>  Il est bon que le <a href="https://www.viva64.com/ru/w/v2507/">premier</a> et le <a href="https://www.viva64.com/ru/w/v2561/">deuxième</a> cas soient facilement pris en compte par les règles MISRA (le premier est MISRA C: 13.4 / MISRA C ++: 6.2.1, le second est MISRA C: 13.4 / MISRA C ++: 6.2.1). <br><br>  En plus de décrire les problèmes, la norme contient un grand nombre de conseils sur ce que vous devez savoir avant de commencer: sur la façon de configurer le processus de développement MISRA, sur l'utilisation d'analyseurs statiques pour vérifier la conformité du code, sur quels documents vous devez conserver et comment remplir, et ainsi de suite et ainsi de suite. <br><br>  À la fin, il y a des applications qui contiennent: une liste courte et un tableau récapitulatif des règles, une petite liste de vulnérabilités C / C ++, un exemple de documentation des écarts par rapport à la règle, ainsi que plusieurs listes de contrôle conçues pour vous aider à ne pas vous perdre dans toute cette bureaucratie. <br><br>  Comme vous pouvez le voir, MISRA n'est pas seulement un ensemble de règles, mais presque toute une infrastructure pour écrire du code sécurisé pour les systèmes embarqués. <br><br><h2>  Utilisez dans vos projets </h2><br>  Imaginez une situation: vous allez écrire un programme pour un système embarqué très nécessaire et responsable.  Ou vous avez déjà un programme, mais vous devez le «transférer» à MISRA.  Comment vérifier la conformité de votre code avec la norme?  Devez-vous vraiment le faire manuellement? <br><br>  La vérification manuelle du code n'est pas une tâche facile et potentiellement impossible.  Non seulement chaque réviseur devrait examiner attentivement chaque ligne de code, mais il devrait également connaître la norme par cœur.  Horreur! <br><br>  Par conséquent, les développeurs MISRA eux-mêmes sont invités à utiliser l'analyse statique pour tester votre code.  En effet, en fait, l'analyse statique est un processus de révision de code automatisé.  Vous exécutez simplement l'analyseur sur votre programme et en quelques minutes, vous recevrez un rapport sur les violations potentielles de la norme.  Ce dont vous avez besoin, non?  Il vous suffit de consulter le journal et de corriger la réponse. <br><br>  Question suivante: à quel moment commencez-vous à utiliser MISRA?  La réponse est simple: le plus tôt sera le mieux.  Idéalement, avant même de commencer à écrire du code, car MISRA suppose que vous suivez la norme tout au long de la vie de votre code. <br><br>  Bien sûr, il n'est pas toujours possible d'écrire MISRA dès le début.  Par exemple, il arrive souvent qu'un projet ait déjà été partiellement ou entièrement mis en œuvre, mais le client souhaitait que le projet soit conforme à la norme.  Dans ce cas, vous devrez effectuer une refactorisation approfondie du code existant. <br><br>  C'est là que l'écueil apparaît.  Je dirais même qu'un rocher sous-marin apparaît.  Que se passe-t-il si vous prenez un analyseur statique et vérifiez la conformité du projet «ordinaire» avec la norme MISRA?  Spoiler: vous pouvez avoir peur. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44e/2b7/7d9/44e2b77d90cd9804e1ec0a5a38f166a2.png" alt="Figure 5"></div><br><br>  Bien sûr, l'exemple de l'image est exagéré.  Ici, vous pouvez voir le résultat de la vérification d'un projet suffisamment grand, qui en fait n'a jamais été pensé pour travailler sur des microcontrôleurs.  Néanmoins, lors de la vérification d'un code existant, vous pouvez très bien voir une, deux, cinq, voire dix mille opérations d'analyseur.  Et dans tout ce tas, de nouvelles opérations seront perdues qui ont été émises dans le code qui vient d'être écrit ou modifié. <br><br>  Que faire à ce sujet?  Est-il vraiment nécessaire de mettre toutes les choses de côté et de s'asseoir pour réparer tous les anciens positifs? <br><br>  Nous savons que la première fois qu'un projet est vérifié, beaucoup de points positifs apparaissent assez souvent et nous avons développé une solution qui vous aidera à bénéficier immédiatement de l'analyseur, sans arrêter le travail.  Cette solution est appelée une "base de suppression". <br><br>  Suppress-bases est le mécanisme PVS-Studio qui permet de supprimer massivement les messages de l'analyseur.  Si vous vérifiez le projet pour la première fois et y découvrez plusieurs milliers de positifs, il vous suffit de les ajouter à la base de suppression et la prochaine fois que vous exécuterez l'analyseur, il ne vous enverra aucun avertissement. <br><br>  Ainsi, vous pouvez continuer à écrire et à modifier le code de la manière habituelle, et en même temps, vous ne verrez des avertissements que sur les erreurs qui viennent d'être introduites dans le projet.  Dans le même temps, vous profiterez au maximum de l'analyseur ici et maintenant, sans être distrait par le ratissage d'anciennes erreurs.  Quelques clics - et l'analyseur est implémenté!  Vous pouvez lire des instructions détaillées à ce sujet <a href="https://www.viva64.com/ru/m/0032/">ici</a> . <br><br>  Vous pourriez probablement vous demander: «Attendez, que faire des réponses cachées?» La réponse est assez simple: ne les oubliez pas et corrigez-les tranquillement.  Vous pouvez, par exemple, placer la base de suppression dans le système de contrôle de version et autoriser uniquement les validations qui n'augmentent pas le nombre d'opérations.  Ainsi, petit à petit, votre "rocher sous-marin" est tôt ou tard vidé et il n'en restera plus aucune trace. <br><br>  D'accord, l'analyseur est implémenté et maintenant nous sommes prêts à continuer.  Que faire ensuite?  Affaires claires - pour travailler avec le code.  Mais que faut-il pour pouvoir déclarer la conformité à la norme?  Comment prouver que votre projet est conforme à MISRA? <br><br>  Le fait est qu'il n'y a pas de «certificat» spécial que votre code est conforme à MISRA.  Comme le stipule la norme elle-même, le suivi du code de conformité doit être effectué par deux parties: le client du logiciel et le fournisseur du logiciel.  Le fournisseur développe un logiciel conforme à la norme et remplit les documents nécessaires.  Le client, pour sa part, doit s'assurer de la véracité des données de ces documents. <br><br>  Si vous êtes vous-même à la fois client et développeur de votre propre logiciel, la responsabilité de la conformité à la norme incombera uniquement à vos épaules :) <br><br>  En général, pour prouver la conformité de votre projet, vous aurez besoin de documents de preuve.  La liste des documents que les développeurs de projets doivent préparer peut varier, mais MISRA en propose certains comme référence.  Examinons cet ensemble plus en détail. <br><br>  Pour revendiquer la conformité à la norme, vous aurez besoin de quelques éléments: <br><br><ul><li>  En fait, un projet dont le code est conforme aux règles obligatoires et obligatoires </li><li>  Guider le plan d'application </li><li>  Documentation de tous les avertissements du compilateur et de l'analyseur statique </li><li>  Documentation de tous les écarts par rapport aux règles requises </li><li>  Résumé de la conformité aux lignes directrices </li></ul><br>  Le premier est un plan de conformité.  C'est votre tableau le plus important, et ce sera lui qui enverra l'examinateur à tous les autres documents.  Dans sa première colonne est une liste des règles MISRA, dans le reste, il est noté si des écarts par rapport à ces règles ont été identifiés.  Ce tableau ressemble à ceci: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/341/643/231/3416432314b7841327af4659356de62c.png" alt="Figure 8"></div><br>  La norme recommande de construire votre projet avec plusieurs compilateurs, ainsi que d'utiliser deux analyseurs statiques ou plus pour vérifier la conformité de votre code.  Si le compilateur ou l'analyseur génère une sorte d'avertissement associé à la règle, vous devez le noter dans le tableau et le document: pourquoi l'opération ne peut pas être éliminée, si elle est fausse, etc. <br><br>  Si l'une des règles ne peut pas être vérifiée avec un analyseur statique, vous devez effectuer la procédure de révision du code.  Cette procédure doit également être documentée, après quoi un lien vers cette documentation doit être ajouté au plan de conformité. <br><br>  Si le compilateur ou l'analyseur statique s'avère correct, ou si des violations de code réelles ont été détectées lors du processus de révision du code, vous devez soit les corriger, soit les documenter.  Encore une fois, en attachant un lien vers la documentation du tableau. <br><br>  Ainsi, un plan de conformité est un document par lequel vous pouvez trouver de la documentation pour tout écart identifié dans votre code. <br><br>  Maintenant, un peu sur la documentation des écarts par rapport aux règles.  Comme je l'ai déjà mentionné, une telle documentation n'est nécessaire que pour les règles requises, car vous ne pouvez pas violer les règles de niveau obligatoire et les règles consultatives ne peuvent pas être suivies sans aucune documentation. <br><br>  Si vous décidez de déroger à la règle, la documentation doit contenir: <br><br><ul><li>  Numéro de règle brisé </li><li>  Emplacement exact de l'écart </li><li>  La validité de l'écart </li><li>  Preuve que l'écart ne compromet pas la sécurité </li><li>  Implications potentielles pour les utilisateurs </li></ul><br>  Comme vous pouvez le voir, cette approche de la documentation vous fait sérieusement penser si la violation en vaut la peine.  Cela est fait spécifiquement pour violer les règles requises n'était pas bon :) <br><br>  Maintenant sur le résumé de la conformité aux règles.  Ce document est peut-être le plus simple à remplir: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3d/77e/e05/f3d77ee05c3639efdc6df19706d60450.png" alt="Figure 2"></div><br>  La colonne centrale est remplie avant de commencer à travailler avec le code, et la colonne la plus à droite se trouve une fois que votre projet est prêt. <br><br>  Il est tout à fait raisonnable de poser une question: pourquoi avez-vous besoin de spécifier des catégories de règles, si elles sont déjà spécifiées dans la norme elle-même?  Le fait est que la norme permet "d'augmenter" la règle dans une catégorie plus stricte.  Par exemple, un client peut vous demander de déplacer une règle de conseil dans une catégorie.  Une telle «augmentation» doit être effectuée avant de travailler avec le code, et un résumé du respect des règles permet de le constater clairement. <br><br>  Avec la dernière colonne, tout est simple: il suffit de noter si la règle est utilisée, et si oui, y a-t-il des écarts par rapport à elle. <br><br>  Cette table entière est nécessaire pour que vous puissiez voir rapidement les priorités des règles et si le code les correspond.  Si vous êtes soudain intéressé à connaître la raison exacte du rejet, vous pouvez toujours vous référer au plan de conformité et trouver la documentation dont vous avez besoin. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b4/c84/ca8/5b4c84ca873358cbb9b5dd6349330da4.png" alt="Figure 3"></div><br>  Vous avez donc soigneusement écrit le code en suivant les règles MISRA.  Vous avez élaboré un plan de conformité et documenté tout ce que vous pouviez documenter, et rempli un résumé de conformité.  Si cela est vrai, vous avez reçu du code très propre, très lisible et très fiable que vous détestez maintenant :) <br><br>  Où vivra votre programme maintenant?  Dans un appareil d'IRM?  Dans un capteur de vitesse ordinaire ou dans le système de pilote automatique d'un satellite spatial?  Oui, vous êtes passé par un chemin bureaucratique sérieux, mais ce sont des bagatelles.  Comment ne pas être méticuleux lorsque de vraies vies humaines sont en jeu? <br><br>  Si vous avez réussi et réussi à atteindre une fin victorieuse, je vous félicite sincèrement: vous écrivez du code sécurisé de haute qualité.  Je vous remercie! <br><br><h2>  L'avenir des normes </h2><br>  Enfin, je veux parler un peu de l'avenir des normes. <br><br>  MISRA vit et se développe actuellement.  Par exemple, au début de 2019, «The MISRA C: 2012 Third Edition (First Revision)» a été annoncé - une norme mise à jour et complétée par de nouvelles règles 2012.  Dans le même temps, ils ont annoncé la sortie prochaine de MISRA C: 2012 Amendement 2 - C11 Core, la norme 2012, dans laquelle des règles seront ajoutées qui couvriront les versions du langage C pour 2011 et 2018 pour la première fois. <br><br>  Ne reste pas immobile et MISRA C ++.  Comme vous le savez, la dernière norme MISRA C ++ remonte à 2008, donc la version la plus ancienne du langage qu'elle couvre est C ++ 03.  Pour cette raison, il existe une autre norme, similaire à MISRA, et elle s'appelle AUTOSAR C ++.  Il a été initialement conçu comme une continuation de MISRA C ++ et était destiné à couvrir les versions ultérieures du langage.  Contrairement à son cerveau, AUTOSAR C ++ est mis à jour deux fois par an et prend actuellement en charge C ++ 14.  Une nouvelle mise à niveau est prévue vers C ++ 17, puis C ++ 20, etc. <br><br>  Qu'est-ce que j'ai commencé avec une autre norme?  Le fait est qu'il y a un peu moins d'un an, les deux organisations ont annoncé l'unification de leurs normes en une seule.  Désormais, MISRA C ++ et AUTOSAR C ++ deviendront un standard unique, et maintenant ils seront développés ensemble.  Je pense que c'est une excellente nouvelle pour les développeurs écrivant sous des microcontrôleurs C ++, et pas moins une excellente nouvelle pour les développeurs d'analyseurs statiques.  Il y a encore beaucoup de travail préféré à venir!  :) <br><br><h2>  Conclusion </h2><br>  Aujourd'hui, nous avons beaucoup appris sur MISRA: nous avons lu l'histoire de son apparition, étudié des exemples de règles et la philosophie de la norme, examiné tout ce dont vous avez besoin pour utiliser MISRA dans vos projets, et même regardé un peu vers l'avenir.  J'espère que vous comprenez mieux maintenant ce qu'est MISRA et comment le cuisiner! <br><br>  Selon la vieille tradition, je laisserai ici un lien vers notre analyseur statique PVS-Studio.  Il est capable de trouver non seulement des écarts par rapport à la norme MISRA, mais également une <a href="https://www.viva64.com/ru/examples/">vaste gamme d'</a> erreurs et de vulnérabilités.  Si vous souhaitez essayer PVS-Studio vous-même, <a href="https://www.viva64.com/ru/pvs-studio-download/">téléchargez la</a> version de démonstration et vérifiez votre projet. <br><br>  Ceci conclut mon article.  Je souhaite à tous les lecteurs une bonne année et un bon week-end de nouvel an! <br><br><h2>  Liens annexes </h2><br><ol><li>  Georgy Gribkov - " <a href="http://0x1.tv/%25D0%2591%25D0%25B5%25D0%25B7%25D0%25BE%25D0%25BF%25D0%25B0%25D1%2581%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C_%25D0%25BD%25D0%25B0_%25D0%25BC%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D0%25BC%25D0%25B0%25D0%25BB%25D0%25BA%25D0%25B0%25D1%2585_%25E2%2580%2594_%25D0%25BA%25D0%25B0%25D0%25BA_%25D0%25BF%25D0%25B8%25D1%2581%25D0%25B0%25D1%2582%25D1%258C_%25D0%25BD%25D0%25B0%25D0%25B4%25D0%25B5%25D0%25B6%25D0%25BD%25D1%258B%25D0%25B9_C/C%252B%252B_%25D0%25BA%25D0%25BE%25D0%25B4_%25D0%25B4%25D0%25BB%25D1%258F_%25D0%25B2%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25B5%25D0%25BC%25D1%258B%25D1%2585_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC_(%25D0%2593%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B3%25D0%25B8%25D0%25B9_%25D0%2593%25D1%2580%25D0%25B8%25D0%25B1%25D0%25BA%25D0%25BE%25D0%25B2,_SECR-2019)">Sécurité à vitesse maximale - comment écrire du code C / C ++ fiable pour les systèmes embarqués</a> ." </li><li>  <a href="https://youtu.be/c5sJd4Abr8c">PVS-Studio est un analyseur de code statique</a> . </li><li>  <a href="https://youtu.be/9h7yObKAADU">Collaboration PVS-Studio &amp; KEIL 5</a> . </li></ol><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/482486/"><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: George Gribkov.  <a href="https://habr.com/en/company/pvs-studio/blog/482486/">Qu'est-ce que MISRA et comment le faire cuire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr482490/">https://habr.com/ru/post/fr482490/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482478/index.html">Iteraptor: bibliothèque pour redus de carte transparent profond</a></li>
<li><a href="../fr482480/index.html">Touches cosmiques de l'année sortante</a></li>
<li><a href="../fr482482/index.html">Jeux de rôle</a></li>
<li><a href="../fr482484/index.html">Comment augmenter l'efficacité du développement en utilisant la théorie des contraintes</a></li>
<li><a href="../fr482486/index.html">Qu'est-ce que Misra et comment le faire cuire</a></li>
<li><a href="../fr482492/index.html">Dégel du pergélisol et émissions de gaz à effet de serre</a></li>
<li><a href="../fr482494/index.html">Mettre à jour les résultats de l'enquête</a></li>
<li><a href="../fr482496/index.html">Résultats: 9 avancées technologiques majeures de 2019</a></li>
<li><a href="../fr482498/index.html">Histoire de l'évolution des interfaces en Java</a></li>
<li><a href="../fr482500/index.html">Python ou R: quel est le meilleur choix pour la science des données?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>