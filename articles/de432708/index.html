<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛰️ 🍗 👨🏻 Kaskadierende SFUs: Verbesserung der Skalierbarkeit und Qualität von Medien in WebRTC-Anwendungen 🧗🏻 🤟🏽 👩🏿‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt zwei Schwierigkeiten bei der Bereitstellung von Medienservern für WebRTC: Skalierung, d. H. über die Verwendung eines Servers hinaus und Optim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kaskadierende SFUs: Verbesserung der Skalierbarkeit und Qualität von Medien in WebRTC-Anwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/432708/">  Es gibt zwei Schwierigkeiten bei der Bereitstellung von Medienservern für WebRTC: Skalierung, d. H.  über die Verwendung eines Servers hinaus und Optimierung der Verzögerungen für alle Konferenzbenutzer.  Während einfaches Sharding im Sinne von "Alle Benutzer der X-Konferenz an Server Y senden" leicht horizontal skaliert werden kann, ist es in Bezug auf Verzögerungen alles andere als optimal.  Die Verteilung der Konferenz auf Server, die nicht nur in der Nähe der Benutzer, sondern auch miteinander verbunden sind, klingt nach einer Lösung für beide Probleme.  Heute haben wir eine Übersetzung von detailliertem Material von Boris Grozev aus Jitsi vorbereitet: Probleme der Kaskadierung von SFUs mit einer Beschreibung des Ansatzes und einiger Schwierigkeiten sowie Implementierungsdetails.  Es ist erwähnenswert, dass Voximplant-Konferenzen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auch SFU verwenden</a> .  Wir arbeiten derzeit an der Kaskadierung der SFU, die nächstes Jahr auf unserer Plattform erscheinen soll. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yg/nu/on/ygnuonxaklzagcy26fi8ga3hj1u.jpeg"></div><br>  <font color="gray">Mausneuronen.</font>  <font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NIHD-</a> Bild ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CC-BY-2.0</a> )</font> <br><a name="habracut"></a><br>  Echtzeitkommunikation reagiert sehr empfindlich auf das Netzwerk: Bandbreite, Latenz und Paketverlust.  Eine Verringerung der Bitrate führt zu einer Verringerung der Videoqualität, eine lange Netzwerkverzögerung führt zu einer langen Verzögerung für Endbenutzer.  Der Verlust von Paketen kann dazu führen, dass der Ton unterbrochen wird und das Video einfriert (aufgrund von Bildsprüngen). <br><br>  Daher ist es für die Konferenz sehr wichtig, die optimale Route zwischen den Endgeräten / Benutzern zu wählen.  Wenn nur zwei Benutzer vorhanden sind, ist dies ganz einfach: WebRTC verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das ICE-Protokoll</a> , um eine Verbindung zwischen den Teilnehmern herzustellen.  Wenn möglich, stellen die Teilnehmer eine direkte Verbindung her, andernfalls wird ein TURN-Server verwendet.  WebRTC kann einen Domänennamen auflösen, um die Adresse eines TURN-Servers abzurufen, sodass Sie einfach eine lokale TURN basierend auf DNS auswählen können, z. B. mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AWS Route53-</a> Eigenschaften. <br><br>  Wenn jedoch das Routing mehrerer Teilnehmer über einen zentralen Medienserver erfolgt, wird die Situation kompliziert.  Viele WebRTC-Dienste verwenden Selective Forwarding Units (SFUs), um Audio und Video zwischen drei oder mehr Teilnehmern effizienter zu übertragen. <br><br><h2>  Problem mit einem Stern </h2><br>  In der Sterntopologie stellen alle Teilnehmer eine Verbindung zu einem einzelnen Server her, über den sie Medienströme austauschen.  Offensichtlich ist die Wahl des Serverstandorts von großer Bedeutung: Wenn sich alle Teilnehmer in den USA befinden, ist die Verwendung eines Servers in Sydney keine gute Idee. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ql/kc/om/qlkcomjzkd6g2ouz09pkdzhlvpw.png"></div><br>  Viele Dienste verwenden einen einfachen Ansatz, der in den meisten Fällen gut funktioniert: Sie wählen einen Server, der näher am ersten Konferenzteilnehmer liegt.  Es gibt jedoch Zeiten, in denen diese Lösung nicht optimal ist.  Stellen Sie sich vor, wir haben drei Teilnehmer aus dem obigen Bild.  Wenn ein Australier (Anrufer C) als erster an der Konferenz teilnimmt, wählt der Algorithmus einen Server in Australien aus, jedoch ist Server 1 in den USA die beste Wahl, da  Er ist den meisten Teilnehmern näher. <br><br>  Das beschriebene Szenario ist nicht sehr häufig, tritt jedoch auf.  Wenn wir davon ausgehen, dass der Benutzer in zufälliger Reihenfolge verbunden ist, tritt die beschriebene Situation bei ⅓ aller Konferenzen mit 3 Teilnehmern auf, von denen eine sehr gelöscht ist. <br><br>  Ein weiteres und häufigeres Szenario: Wir haben zwei Teilnehmergruppen an verschiedenen Standorten.  In diesem Fall ist die Verbindungsreihenfolge unwichtig. Wir haben immer eine Gruppe eng anliegender Teilnehmer, die gezwungen sind, Medien mit einem Remote-Server auszutauschen.  Zum Beispiel 2 Teilnehmer aus Australien (C &amp; D) und 2 aus den USA (A &amp; B). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/t9/me/uht9mexxe1vpojj608kyvf1ccb8.png"></div><br>  Der Wechsel zu Server 1 ist für C &amp; D-Mitglieder nicht optimal.  Server 2 ist für A &amp; B nicht optimal.  Das heißt, unabhängig davon, welcher Server verwendet wird, sind immer Teilnehmer mit dem Remote-Server (= nicht optimal) verbunden. <br><br>  Aber wenn wir kein einziges Serverlimit hätten?  Wir könnten jeden Teilnehmer mit dem nächsten Server verbinden, es würde nur bleiben, um diese Server zu verbinden. <br><br><h2>  Lösung: Kaskadierung </h2><br>  Wir verschieben die Frage, wie die Server verbunden werden sollen.  Lassen Sie uns zuerst sehen, wie sich das auswirken wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qc/lk/nj/qclknjbtsc5nkj5sp1evoqavla8.png"></div><br>  Die SFU-Verbindung zwischen C und D hat sich nicht geändert - Server 2 wird weiterhin verwendet. Server 1 wird für die Teilnehmer A und B verwendet, und dies ist offensichtlich besser.  Das Interessanteste ist die Verbindung zwischen beispielsweise A und C: Anstelle von A &lt;=&gt; Server 2 &lt;=&gt; C wird die Route A &lt;=&gt; Server 1 &lt;=&gt; Server 2 &lt;=&gt; C verwendet. <br><br><h2>  Implizite Auswirkung auf den Wechselkurs </h2><br>  Der SFU-Mix hat Vor- und Nachteile.  Einerseits wird in der beschriebenen Situation die Austauschzeit zwischen Teilnehmern länger, wenn neue Sprünge im Netzwerk hinzugefügt werden.  Andererseits nimmt diese Zeit ab, wenn wir über die Verbindung „Client“ - „erster Server“ sprechen, da wir den Medienstrom mit einer geringeren Verzögerung nach dem Hop-by-Hop-Prinzip wiederherstellen können. <br><br>  Wie funktioniert es  WebRTC verwendet RTP (normalerweise über UDP) zum Übertragen von Medien.  Dies bedeutet, dass der Transport unzuverlässig ist.  Wenn ein UDP-Paket verloren geht, können Sie den Verlust ignorieren oder eine erneute Übertragung (Neuübertragung) mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTCP-NACK-</a> Pakets <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anfordern.</a> Die Auswahl liegt bereits im Gewissen der Anwendung.  Beispielsweise kann eine Anwendung den Verlust von Audiopaketen ignorieren und die erneute Übertragung einiger (aber nicht aller) Videopakete anfordern, je nachdem, ob sie zum Decodieren nachfolgender Frames benötigt werden oder nicht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ia/ly/oi/ialyoi-naszu3kclgng8r6i6kx4.png"></div><br>  <font color="gray">Neuübertragung von RTP-Paketen, einzelner Server</font> <br><br>  Bei einer Kaskadierung kann die erneute Übertragung auf den lokalen Server beschränkt sein, dh an jedem einzelnen Standort durchgeführt werden.  Wenn beispielsweise auf der Route A-S1-S2-C ein Paket zwischen A und S1 verloren geht, bemerkt S1 dies und fordert eine erneute Übertragung an.  Ähnlich wie beim Verlust zwischen S2 und C. Und selbst wenn das Paket zwischen Servern verloren geht, kann die empfangende Seite auch eine erneute Übertragung anfordern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/si/zs/ak/sizsaktt0nq72ymcfvkkojwfjq0.png"></div><br>  <font color="gray">RTP-Paket-Neuübertragung, zwei Server.</font>  <font color="gray">Beachten Sie, dass Server 2 Paket 2 nicht anfordert, da NACK kurz nach dem Senden des Pakets eingetroffen ist.</font> <br><br>  Der Client verwendet einen Jitterpuffer, um die Videowiedergabe zu verzögern und verzögerte / erneut übertragene Pakete zu empfangen.  Die Puffergröße ändert sich dynamisch in Abhängigkeit von der Austauschzeit zwischen den Parteien.  Wenn Hop-by-Hop-Neuübertragungen auftreten, nimmt die Verzögerung ab, und infolgedessen kann der Puffer kleiner sein - infolgedessen nimmt auch die Gesamtverzögerung ab. <br><br>  Kurz gesagt: Selbst wenn die Austauschzeit zwischen den Teilnehmern höher ist, kann dies zu einer Verringerung der Verzögerung bei der Übertragung von Medien zwischen den Teilnehmern führen.  Diesen Effekt müssen wir in der Praxis noch untersuchen. <br><br><h2>  Einführung in kaskadierende SFUs: Jitsi Meet Case </h2><br><h3>  Alarm vs.  Medien </h3><br>  Werfen wir einen Blick auf den Alarm.  Jitsi Meet teilte von Anfang an das Konzept eines Signalisierungsservers ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jicofo</a> ) und eines Medienservers / einer SFU.  Dies ermöglichte die Einführung einer Kaskadenunterstützung ist relativ einfach.  Erstens könnten wir die gesamte Signalisierungslogik an einem Ort handhaben;  Zweitens hatten wir bereits ein Signalisierungsprotokoll zwischen Jicofo und dem Medienserver.  Wir mussten die Funktionalität nur ein wenig erweitern: Wir haben bereits mehrere SFUs unterstützt, die mit einem Signalisierungsserver verbunden sind. Wir mussten die Fähigkeit einer SFU hinzufügen, eine Verbindung zu vielen Signalisierungsservern herzustellen. <br><br>  Als Ergebnis wurden zwei unabhängige Serverpools angezeigt: einer für Jicofo-Instanzen, der andere für Medienserverinstanzen (siehe Abbildung): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zu/vm/j-/zuvmj-aptvmxeaz_-_2dpy0gnxs.png"></div><br>  <font color="gray">Ein Beispiel für die Organisation von Servern in AWS mit der Möglichkeit einer Kaskade zwischen verschiedenen Rechenzentren.</font> <br><br>  Der zweite Teil des Systems ist die Bridge-to-Bridge-Kommunikation.  Wir wollten diesen Teil so einfach wie möglich gestalten, damit es keine komplizierten Signale zwischen den Brücken gibt.  Alle Alarme gehen zwischen jicofo und jitsi-videobridge;  Die Bridge-Verbindung wird nur für Audio- / Video- und Datenverbindungsnachrichten verwendet. <br><br><h3>  Octo-Protokoll </h3><br>  Um diese Interaktion zu verwalten, haben wir das Octo-Protokoll verwendet, das RTP-Pakete in einfache Header fester Länge einschließt und Ihnen auch das Senden von Textnachrichten ermöglicht.  In der aktuellen Implementierung sind die Brücken durch eine Vollmaschentopologie (Vollnetz) verbunden, es sind jedoch auch andere Topologien möglich.  Verwenden Sie beispielsweise einen zentralen Server (Stern für Brücken) oder eine Baumstruktur für jede Brücke. <br><br>  <i>Erläuterung: Anstatt es in einen Octo-Header einzuschließen, können Sie die RTP-Header-Erweiterung verwenden, mit der Bridges auf reinem (S) RTP zwischen Bridges ausgeführt werden.</i>  <i>Zukünftige Versionen von Octo können diesen Ansatz verwenden.</i> <i><br><br></i>  <i>Zweite Erklärung: Octo bedeutet nichts.</i>  <i>Zuerst wollten wir einen zentralen Server verwenden, der uns an einen Tintenfisch erinnerte.</i>  <i>So erschien der Name für das Projekt.</i> <i><br></i> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xt/vv/ln/xtvvlnyyumqkz65qlvsxweuss94.png"></div>  <font color="gray">Octo-Header-Format</font> <br><br>  In der Jitsi-Terminologie verfügt eine Bridge, wenn sie Teil einer Konferenz mit mehreren Bridges ist, über einen zusätzlichen Octo-Kanal (tatsächlich einen Kanal für Audio und einen für Video).  Dieser Kanal ist für das Senden / Empfangen von Medien zu / von anderen Bridges verantwortlich.  Jeder Bridge wird ein freier Port für Octo zugewiesen (standardmäßig 4096). Daher benötigen wir das Feld Konferenz-ID, um mehrere Konferenzen abwickeln zu können. <br><br>  Derzeit sind im Protokoll keine Sicherheitsmechanismen integriert, und wir delegieren diese Verantwortung an die unteren Ebenen.  Dies ist das Nächste, was wir in naher Zukunft tun werden. Derzeit sollten sich die Bridges jedoch in einem sicheren Netzwerk befinden (z. B. einer separaten AWS VPC-Instanz). <br><br><h3>  Simulcast </h3><br>  Mit Simulcast kann jeder Teilnehmer mehrere Medienströme mit unterschiedlichen Bitraten senden, während die Bridge dabei hilft, festzustellen, welche benötigt werden.  Damit dies korrekt funktioniert, übertragen wir alle Simulcast-Streams zwischen den Brücken.  Dank dessen können Sie schnell zwischen Streams wechseln, da die lokale Bridge keinen neuen Stream anfordern muss.  Dies ist jedoch unter dem Gesichtspunkt des Verkehrs von Brücke zu Brücke nicht optimal, da  Einige Threads werden selten verwendet und laden nur die Bandbreite ohne Zweck. <br><br><h3>  Aktive Mitgliederauswahl </h3><br>  Wir wollten auch die Möglichkeit haben, einen aktiven Teilnehmer / Sprecher der Konferenz zu abonnieren.  Es stellte sich als einfach heraus - wir haben jeder Brücke beigebracht, den Hauptteilnehmer unabhängig zu bestimmen und dann unsere lokalen Kunden zu benachrichtigen.  Dies bedeutet, dass die Ermittlung mehrmals erfolgt, jedoch nicht kostspielig ist und Sie einige Punkte vereinfachen können (z. B. müssen Sie nicht entscheiden, welche Bridge für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DSI</a> verantwortlich sein soll, und sich um das Weiterleiten von Nachrichten kümmern). <br><br><h3>  Brückenauswahl </h3><br>  In der aktuellen Implementierung ist dieser Algorithmus einfach.  Wenn ein neuer Teilnehmer an der Konferenz teilnimmt, muss Jicofo bestimmen, welche Brücke ihm zugewiesen werden soll.  Dies erfolgt basierend auf der Region des Teilnehmers und der Überlastung der Brücken.  Wenn es in derselben Region eine freie Brücke gibt, wird sie ernannt.  Andernfalls wird eine andere Brücke verwendet. <br><br>  Weitere Informationen zu Octo finden Sie in der <a href="">Dokumentation</a> . <br><br><h2>  Erweitern Sie die kaskadierende SFU </h2><br>  Für die Bereitstellung haben wir Computer in Amazon AWS verwendet.  Wir hatten Server (Alarme und Medien) in 6 Regionen: <br><br><ul><li>  us-east-1 (North Virginia); </li><li>  us-west-2 (Oregon); </li><li>  eu-west-1 (Irland); </li><li>  eu-central-1 (Frankfurt); </li><li>  ap-se-1 (Singapur); </li><li>  ap-se-2 (Sydney). </li></ul><br>  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">georeferenzierte HAProxy-</a> Instanzen verwendet, um die Mitgliedsregion zu bestimmen.  Die Domäne meet.jit.si wird von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Route53 verwaltet</a> und in die HAProxy-Instanz aufgelöst, die die Region zu den HTTP-Headern der gesendeten Anforderung hinzufügt.  Der Header wird später als Wert der Variablen <code>config.deploymentInfo.userRegion</code> , die dank der Datei <code>/config.js</code> auf dem Client <code>/config.js</code> ist. <br><br>  Die Jitsi-Oberfläche zeigt an, wie viele Bridges verwendet werden und an welche spezifischen Benutzer angeschlossen sind - zu Diagnose- und Demonstrationszwecken.  Wenn Sie den Mauszeiger über die obere linke Ecke des lokalen Videos bewegen, werden die Gesamtzahl der Server und der Server angezeigt, mit dem Sie verbunden sind.  Ebenso können Sie die Parameter des zweiten Teilnehmers sehen.  Sie sehen auch die Austauschzeit zwischen Ihrem Browser und dem Browser des Gesprächspartners (Parameter E2E RTT). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/up/hs/r3/uphsr3-ddqg6cjkhcu6sgis1g9s.png"></div><br>  <font color="gray">Indem Sie sehen, wer mit welchem ​​Server verbunden ist, können Sie sehen, ob Kaskadierung verwendet wird.</font> <br><br><h2>  Fazit </h2><br>  Octo erschien ursprünglich als A / B-Test.  Die ersten Ergebnisse waren gut, so dass Octo jetzt für alle verfügbar ist.  Es ist immer noch viel Verkehr zu passieren und die Leistung genauer zu betrachten.  Es ist auch geplant, diese Entwicklungen zu nutzen, um noch größere Konferenzen zu unterstützen (wenn eine SFU nicht mehr ausreicht). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432708/">https://habr.com/ru/post/de432708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432698/index.html">Fantastische Timlids und wo sie leben</a></li>
<li><a href="../de432700/index.html">Komm schon! @ # Mit deiner "Toxizität"</a></li>
<li><a href="../de432702/index.html">Inhalt 2018: breiter aussehen, tiefer graben</a></li>
<li><a href="../de432704/index.html">Verwendung eines externen drahtlosen Buro H999-Thermometers mit hausgemachten Geräten</a></li>
<li><a href="../de432706/index.html">Eins-zu-viele-Team beim Kundenerfolg: Warum brauchen Sie es?</a></li>
<li><a href="../de432710/index.html">Spam-Anrufe. Ist es möglich, sie zu bekämpfen?</a></li>
<li><a href="../de432714/index.html">Vorhersagen der Sicherheitswoche 50: 2019</a></li>
<li><a href="../de432716/index.html">Traili. Gpuhub. Cybercortex</a></li>
<li><a href="../de432718/index.html">Controller, sei ruhig! Wir nehmen den Code in UIView heraus</a></li>
<li><a href="../de432720/index.html">China hat Apple verboten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>