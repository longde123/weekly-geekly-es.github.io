<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüöí üíÜüèº üë∂üèº No es suficiente contar pol√≠gonos para optimizar modelos 3D üë¶üèΩ üñêüèæ ‚ö±Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despu√©s de comprender los conceptos b√°sicos del proceso de representaci√≥n de malla, puede aplicar varias t√©cnicas para optimizar la velocidad de repre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>No es suficiente contar pol√≠gonos para optimizar modelos 3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433186/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/210/1dd/a47/2101dda47cad028f91a5104cf9a1525c.png" alt="imagen"></div><br>  Despu√©s de comprender los conceptos b√°sicos del proceso de representaci√≥n de malla, puede aplicar varias t√©cnicas para optimizar la velocidad de representaci√≥n. <br><br><h2>  Introduccion </h2><br>  ¬øCu√°ntos pol√≠gonos puedo usar?  Esta es una pregunta muy com√∫n que los artistas hacen al crear modelos para renderizar en tiempo real.  Esta pregunta es dif√≠cil de responder, porque no es solo una cuesti√≥n de n√∫meros. <br><br>  Comenc√© mi carrera como artista 3D en la era de la primera PlayStation, y luego me convert√≠ en programador de gr√°ficos.  Me gustar√≠a leer este art√≠culo antes de comenzar a crear modelos 3D para juegos.  Los fundamentos fundamentales considerados en √©l son √∫tiles para muchos artistas.  Aunque la mayor parte de la informaci√≥n en este art√≠culo no afectar√° significativamente la productividad de su trabajo diario, le dar√° una comprensi√≥n b√°sica de c√≥mo la unidad de procesamiento de gr√°ficos (GPU) procesa las mallas que crea. <br><br>  La velocidad de su representaci√≥n generalmente depende del n√∫mero de pol√≠gonos en la malla.  Sin embargo, aunque el n√∫mero de pol√≠gonos a menudo se correlaciona con la velocidad de fotogramas por segundo (FPS), puede encontrar que incluso despu√©s de reducir el n√∫mero de pol√≠gonos, la malla a√∫n se renderiza lentamente.  Pero al comprender c√≥mo se representan las mallas en general, puede aplicar un conjunto de t√©cnicas para aumentar la velocidad de representaci√≥n. <br><a name="habracut"></a><br><h2>  C√≥mo se presentan los datos poligonales </h2><br>  Para comprender c√≥mo la GPU dibuja pol√≠gonos, primero debe considerar la estructura de datos utilizada para describir los pol√≠gonos.  Un pol√≠gono consiste en un conjunto de puntos llamados v√©rtices y enlaces.  Los v√©rtices a menudo se almacenan como matrices de valores, por ejemplo, como en la Figura 1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ff/cb1/c94/4ffcb1c945c51025a430d752e475b1c3.png"></div><br>  <i>Figura 1. Una matriz de valores de pol√≠gonos simples.</i> <br><br>  En este caso, cuatro v√©rtices en tres dimensiones (x, y y z) nos dan 12 valores.  Para crear pol√≠gonos, la segunda matriz de valores describe los v√©rtices mismos, como se muestra en la Figura 2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01d/1c9/3eb/01d1c93eb3645689d0d30de75b0ea524.png"></div><br>  <i>Figura 2. Una matriz de enlaces a los v√©rtices.</i> <br><br>  Estos v√©rtices conectados entre s√≠ forman dos pol√≠gonos.  Tenga en cuenta que dos tri√°ngulos, cada uno con tres √°ngulos, se pueden describir con cuatro v√©rtices, porque los v√©rtices 1 y 2 se usan en ambos tri√°ngulos.  Para que la GPU procese estos datos, se supone que cada pol√≠gono es triangular.  Las GPU esperan que trabajes con tri√°ngulos porque est√°n dise√±ados espec√≠ficamente para dibujarlos.  Si necesita dibujar pol√≠gonos con un n√∫mero diferente de v√©rtices, entonces necesita una aplicaci√≥n que los divida en tri√°ngulos antes de renderizar en la GPU.  Por ejemplo, si crea un cubo de seis pol√≠gonos, cada uno de los cuales tiene cuatro lados, entonces esto no es m√°s efectivo que crear un cubo de 12 pol√≠gonos que consta de tres lados;  Son estos tri√°ngulos los que dibujar√° la GPU.  Recuerde la regla: necesita contar no pol√≠gonos, sino tri√°ngulos. <br><br>  Los datos de v√©rtice utilizados en el ejemplo anterior son tridimensionales, pero esto no es necesario.  Dos dimensiones pueden ser suficientes para usted, pero a menudo necesita almacenar otros datos, por ejemplo, coordenadas UV para texturas y normales para iluminaci√≥n. <br><br><h2>  Dibujo poligonal </h2><br>  Al representar un pol√≠gono, la GPU primero determina d√≥nde dibujar el pol√≠gono.  Para hacer esto, calcula la posici√≥n en la pantalla donde deber√≠an estar los tres v√©rtices.  Esta operaci√≥n se llama transformar.  Estos c√°lculos en la GPU se realizan mediante un peque√±o programa llamado sombreador de v√©rtices. <br><br>  El sombreador de v√©rtices a menudo realiza otros tipos de operaciones, como procesar animaciones.  Despu√©s de calcular las posiciones de los tres v√©rtices del pol√≠gono, la GPU calcula qu√© p√≠xeles est√°n en este tri√°ngulo y luego comienza a llenar estos p√≠xeles con otro peque√±o programa llamado "fragment shader" (fragment shader).  Un sombreador de fragmentos generalmente se ejecuta una vez por p√≠xel.  Sin embargo, en algunos casos raros, se puede realizar varias veces por p√≠xel, por ejemplo, para mejorar el suavizado.  Los sombreadores de fragmentos a menudo se denominan sombreadores de p√≠xeles, porque en la mayor√≠a de los casos los fragmentos corresponden a p√≠xeles (ver Figura 3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/5e6/4cc/16c5e64cc4daec8ceef7264fce4b8a08.png"></div><br>  <i>Figura 3. Un pol√≠gono dibujado en la pantalla.</i> <br><br>  La Figura 4 muestra la secuencia de acciones realizadas por la GPU al representar el pol√≠gono. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87c/c60/8d2/87cc608d2ac63afc4c818b824bc11fb5.png"></div><br>  <i>Figura 4. El orden de la GPU que representa el pol√≠gono.</i> <br><br>  Si divide el tri√°ngulo en dos y dibuja ambos tri√°ngulos (consulte la Figura 5), ‚Äã‚Äãel procedimiento corresponder√° a la Figura 6. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19a/34a/521/19a34a521bdd7ace482a8a1defb8c926.png"></div><br>  <i>Figura 5. Divisi√≥n del pol√≠gono en dos.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0c/16c/07c/d0c16c07ce793e36aaa40e237ad60d78.png"></div><br>  <i>Figura 6. El procedimiento de la GPU dibujando dos pol√≠gonos.</i> <br><br>  En este caso, se requieren el doble de transformaciones y preparaciones, pero dado que el n√∫mero de p√≠xeles sigue siendo el mismo, la operaci√≥n no necesita rasterizar p√≠xeles adicionales.  Esto muestra que duplicar el n√∫mero de pol√≠gonos no necesariamente duplica el tiempo de renderizado. <br><br><h2>  Usar cach√© de v√©rtices </h2><br>  Si observa los dos pol√≠gonos del ejemplo anterior, puede ver que tienen dos v√©rtices comunes.  Se puede suponer que estos v√©rtices tendr√°n que calcularse dos veces, pero un mecanismo llamado cach√© de v√©rtices le permite reutilizar los resultados del c√°lculo.  Los resultados de los c√°lculos del sombreador de v√©rtices para su reutilizaci√≥n se almacenan en la memoria cach√©, un √°rea peque√±a de memoria que contiene los √∫ltimos v√©rtices.  El procedimiento para dibujar dos pol√≠gonos usando el cach√© de v√©rtices se muestra en la Figura 7. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f0/272/d4a/4f0272d4aed10e3805af75688282cdc2.png"></div><br>  <i>Figura 7. Dibujando dos pol√≠gonos usando el cach√© de v√©rtices.</i> <br><br>  Gracias a la memoria cach√© de v√©rtices, puede dibujar dos pol√≠gonos casi tan r√°pido como uno si tienen v√©rtices comunes. <br><br><h2>  Nos ocupamos de los par√°metros de los v√©rtices. </h2><br>  Para que el v√©rtice sea reutilizable, no debe modificarse con cada uso.  Por supuesto, la posici√≥n deber√≠a permanecer igual, pero otros par√°metros tampoco deber√≠an cambiar.  Los par√°metros pasados ‚Äã‚Äãa la parte superior dependen del motor utilizado.  Aqu√≠ hay dos par√°metros comunes: <br><br><ul><li>  Coordenadas de textura </li><li>  Normal </li></ul><br>  Cuando se aplica UV a un objeto 3D, cualquier costura creada significar√° que los v√©rtices a lo largo de la costura no se pueden compartir.  Por lo tanto, en el caso general, se deben evitar las costuras (ver Figura 8). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8b/75d/854/c8b75d85471cc476ba6e6f8a9425c7a7.png"></div><br>  <i>Figura 8. Textura de sutura UV.</i> <br><br>  Para una iluminaci√≥n adecuada de la superficie, cada v√©rtice generalmente almacena un normal, un vector dirigido desde la superficie.  Debido al hecho de que todos los pol√≠gonos con un v√©rtice com√∫n est√°n definidos por una normal, su forma parece suave.  Esto se llama sombreado suave.  Si cada tri√°ngulo tiene sus propias normales, entonces los bordes entre los pol√≠gonos se vuelven pronunciados y la superficie parece plana.  Por lo tanto, esto se llama sombreado plano.  La Figura 9 muestra dos mallas id√©nticas, una con sombreado suave y la otra con sombreado plano. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/379/ee3/41f/379ee341f3720b32dba0d4b753c88b98.png"></div><br>  <i>Figura 9. Comparaci√≥n de sombreado liso con sombreado plano.</i> <br><br>  Esta geometr√≠a sombreada suave consta de 18 tri√°ngulos y tiene 16 v√©rtices comunes.  El sombreado plano de 18 tri√°ngulos requiere 54 v√©rtices (18 x 3), porque ninguno de los v√©rtices se comparte.  Incluso si dos mallas tienen el mismo n√∫mero de pol√≠gonos, su velocidad de representaci√≥n seguir√° siendo diferente. <br><br><h2>  Importancia de la forma </h2><br>  Las GPU funcionan r√°pido principalmente porque pueden realizar muchas operaciones en paralelo.  Los materiales de marketing de GPU a menudo se centran en la cantidad de canalizaciones que determinan cu√°ntas GPU pueden funcionar al mismo tiempo.  Cuando la GPU dibuja el pol√≠gono, le da la tarea de muchas tuber√≠as para llenar los cuadrados de p√≠xeles.  Esto suele ser un cuadrado de ocho por ocho p√≠xeles.  La GPU contin√∫a haciendo esto hasta que todos los p√≠xeles est√©n llenos.  Obviamente, los tri√°ngulos no son cuadrados, por lo que algunos p√≠xeles del cuadrado estar√°n dentro del tri√°ngulo y otros afuera.  El equipo funciona con todos los p√≠xeles en un cuadrado, incluso aquellos que est√°n fuera del tri√°ngulo.  Despu√©s de calcular todos los v√©rtices en el cuadrado, el equipo descarta los p√≠xeles fuera del tri√°ngulo. <br><br>  La Figura 10 muestra un tri√°ngulo, que requiere tres cuadrados (fichas) para dibujar.  Se utilizan la mayor√≠a de los p√≠xeles calculados (cian), y los que se muestran en rojo van m√°s all√° de los l√≠mites del tri√°ngulo y se descartar√°n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/c2e/262/74bc2e262019ac7b5f488babc01d7298.png"></div><br>  <i>Figura 10. Tres fichas para dibujar un tri√°ngulo.</i> <br><br>  El pol√≠gono en la Figura 11 con exactamente el mismo n√∫mero de p√≠xeles, pero estirado, requiere m√°s mosaicos para rellenar;  La mayor√≠a de los resultados en cada mosaico (√°rea roja) se descartar√°n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d0/a9e/286/9d0a9e28607c023f81928ea60c8c386a.png"></div><br>  <i>Figura 11. Relleno de mosaicos en una imagen estirada.</i> <br><br>  El n√∫mero de p√≠xeles representados es solo uno de los factores.  La forma del pol√≠gono tambi√©n es importante.  Para aumentar la eficiencia, trate de evitar pol√≠gonos largos y estrechos y d√© preferencia a los tri√°ngulos con lados aproximadamente iguales, cuyos √°ngulos est√°n cerca de los 60 grados.  Las dos superficies planas en la Figura 12 se triangulan de dos maneras diferentes, pero se ven iguales cuando se representan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/607/5d0/965/6075d0965cddfabc1a639bc58b476bb1.png"></div><br>  <i>Figura 12. Superficies trianguladas de dos maneras diferentes.</i> <br><br>  Tienen exactamente el mismo n√∫mero de pol√≠gonos y p√≠xeles, pero dado que la superficie de la izquierda tiene pol√≠gonos m√°s largos y estrechos que los de la derecha, su representaci√≥n ser√° m√°s lenta. <br><br><h2>  Redibujando </h2><br>  Para dibujar una estrella de seis puntas, puede crear una malla de 10 pol√≠gonos o dibujar la misma forma con solo dos pol√≠gonos, como se muestra en la Figura 13. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/553/86b/dff/55386bdffeaeabbedb9bda0a913f2dda.png"></div><br>  <i>Figura 13. Dos formas diferentes de representar una estrella de seis puntas.</i> <br><br>  Puede decidir que es m√°s r√°pido dibujar dos pol√≠gonos que 10. Sin embargo, en este caso, esto probablemente sea incorrecto, porque los p√≠xeles en el centro de la estrella se dibujar√°n dos veces.  Este fen√≥meno se llama sobregiro.  En esencia, significa que los p√≠xeles se vuelven a dibujar m√°s de una vez.  El redibujado ocurre naturalmente durante todo el proceso de renderizado.  Por ejemplo, si un personaje est√° parcialmente oculto por una columna, se dibujar√° en su totalidad, a pesar de que la columna se superpone a parte del personaje.  Algunos motores usan algoritmos complejos para evitar renderizar objetos que son invisibles en la imagen final, pero esta es una tarea dif√≠cil.  La CPU a menudo es m√°s dif√≠cil de entender qu√© no necesita ser renderizado que la GPU para dibujarla. <br><br>  Como artista, debe aceptar el hecho de que no puede deshacerse del repintado, pero es una buena pr√°ctica eliminar las superficies que no se pueden ver.  Si est√° colaborando con un equipo de desarrollo, solicite agregar un modo de depuraci√≥n al motor del juego, en el que todo se vuelve transparente.  Esto facilitar√° la b√∫squeda de pol√≠gonos ocultos que se pueden eliminar. <br><br><h2>  Implementando un caj√≥n en el piso </h2><br>  La Figura 14 muestra una escena simple: una caja parada en el piso.  El piso consta de solo dos tri√°ngulos, y la caja consta de 10 tri√°ngulos.  El redibujado en esta escena se muestra en rojo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/227/ece/c87227ecea93c82e5870a6c68493bd00.png"></div><br>  <i>Figura 14. Un caj√≥n parado en el piso.</i> <br><br>  En este caso, la GPU dibujar√° parte del piso al piso con un caj√≥n, a pesar de que no ser√° visible.  Si, en cambio, cre√°ramos un agujero en el piso debajo de la caja, habr√≠amos recibido m√°s pol√≠gonos, pero mucho menos redise√±ado, como se puede ver en la Figura 15. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/202/1e4/045/2021e4045609645f18c056179196bac0.png"></div><br>  <i>Figura 15. Un agujero debajo del caj√≥n para evitar volver a dibujar.</i> <br><br>  En tales casos, todo depende de su elecci√≥n.  A veces vale la pena reducir la cantidad de pol√≠gonos, obteniendo un nuevo dibujo a cambio.  En otras situaciones, vale la pena agregar pol√≠gonos para evitar volver a dibujar.  Otro ejemplo: las dos figuras que se muestran a continuaci√≥n son las mismas mallas de superficie con puntos que sobresalen.  En la primera malla (Figura 16), las puntas se encuentran en la superficie. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/569/436/a65/569436a65cd84150968803a745098129.png"></div><br>  <i>Figura 16. Las puntas se encuentran en la superficie.</i> <br><br>  En la segunda malla de la Figura 17, se cortan agujeros en la superficie debajo de las puntas para reducir la cantidad de redibujado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c2/815/692/9c2815692a63c60b9b13fb027405484c.png"></div><br>  <i>Figura 17. Los agujeros se cortan debajo de las puntas.</i> <br><br>  En este caso, se agregaron muchos pol√≠gonos para cortar agujeros, algunos de los cuales tienen una forma estrecha.  Adem√°s, la superficie de la redibujada, de la que nos deshacemos, no es muy grande, por lo que en este caso esta t√©cnica no es efectiva. <br><br>  Imagina que est√°s modelando una casa parada en el suelo.  Para crearlo, puedes dejar la tierra sin cambios o cortar un agujero en el suelo debajo de la casa.  Redibujar es m√°s cuando el agujero no se corta debajo de la casa.  Sin embargo, la elecci√≥n depende de la geometr√≠a y del punto de vista desde el cual el jugador ver√° la casa.  Si dibujas tierra debajo de la base de la casa, esto crear√° una gran cantidad de redibujos si entras a la casa y miras hacia abajo.  Sin embargo, la diferencia no ser√° particularmente grande si miras la casa desde un avi√≥n.  En este caso, es mejor tener un modo de depuraci√≥n en el motor del juego que haga que las superficies sean transparentes para que pueda ver lo que se dibuja debajo de las superficies visibles para el jugador. <br><br><h2>  Cuando los buffers Z tienen un conflicto Z </h2><br>  Cuando la GPU dibuja dos pol√≠gonos superpuestos, ¬øc√≥mo determina cu√°l est√° encima del otro?  Los primeros investigadores de gr√°ficos por computadora pasaron mucho tiempo investigando este problema.  Ed Catmell (quien m√°s tarde se convirti√≥ en presidente de Pixar y Walt Disney Animation Studios) escribi√≥ un art√≠culo que describ√≠a diez enfoques diferentes para esta tarea.  En una parte del art√≠culo, se√±ala que la soluci√≥n a este problema ser√° trivial si las computadoras tienen suficiente memoria para almacenar un valor de profundidad por p√≠xel.  En las d√©cadas de 1970 y 1980, era una gran cantidad de memoria.  Sin embargo, hoy en d√≠a la mayor√≠a de las GPU funcionan as√≠: este sistema se llama Z-buffer. <br><br>  El Z-buffer (tambi√©n conocido como el buffer de profundidad) funciona de la siguiente manera: con cada p√≠xel se asocia su valor de profundidad.  Cuando el equipo dibuja un objeto, calcula qu√© tan lejos se dibuja un p√≠xel de la c√°mara.  Luego verifica el valor de profundidad de un p√≠xel existente.  Si est√° m√°s lejos de la c√°mara que el nuevo p√≠xel, se dibujar√° el nuevo p√≠xel.  Si un p√≠xel existente est√° m√°s cerca de la c√°mara que uno nuevo, entonces el nuevo p√≠xel no se dibuja.  Este enfoque resuelve muchos problemas y funciona incluso si los pol√≠gonos se cruzan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/210/1dd/a47/2101dda47cad028f91a5104cf9a1525c.png"></div><br>  <i>Figura 18. Pol√≠gonos de intersecci√≥n procesados ‚Äã‚Äãpor el tamp√≥n de profundidad.</i> <br><br>  Sin embargo, el Z-buffer no tiene una precisi√≥n infinita.  Si dos superficies est√°n casi a la misma distancia de la c√°mara, esto confunde la GPU y puede seleccionar aleatoriamente una de las superficies, como se muestra en la Figura 19. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/ec2/2e9/e7fec22e99a74b0147b42bc91bf7be33.png"></div><br>  <i>Figura 19. Las superficies con la misma profundidad tienen problemas de visualizaci√≥n.</i> <br><br>  Esto se llama Z-fighting y se ve muy defectuoso.  A menudo, los conflictos Z empeoran cuanto m√°s se aleja la superficie de la c√°mara.  Los desarrolladores de motores pueden incorporar correcciones en ellos para suavizar este problema, pero si un artista crea pol√≠gonos lo suficientemente cercanos y superpuestos, entonces todav√≠a puede surgir un problema.  Otro ejemplo es una pared con un p√≥ster colgado.  El p√≥ster se encuentra casi a la misma profundidad de la c√°mara que la pared detr√°s de √©l, por lo que el riesgo de conflictos Z es muy alto.  La soluci√≥n es cortar un agujero en la pared debajo del p√≥ster.  Esto tambi√©n reducir√° la cantidad de redise√±o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da1/4e2/536/da14e2536deb1d23b0e2a7b4de57bc33.png"></div><br>  <i>Figura 20. Un ejemplo de un conflicto Z de pol√≠gonos superpuestos.</i> <br><br>  En casos extremos, un conflicto Z puede ocurrir incluso cuando los objetos se tocan entre s√≠.  La Figura 20 muestra el caj√≥n en el piso, y dado que no cortamos un agujero en el piso debajo del caj√≥n, el z-buffer puede confundirse al lado del borde donde el piso se encuentra con el caj√≥n. <br><br><h2>  Usar llamadas de sorteo </h2><br>  Las GPU se han vuelto extremadamente r√°pidas, tan r√°pidas que las CPU pueden no seguirlas.  Dado que las GPU est√°n dise√±adas esencialmente para realizar una tarea, es mucho m√°s f√°cil comenzar a trabajar r√°pidamente.  Los gr√°ficos est√°n inherentemente relacionados con el c√°lculo de m√∫ltiples p√≠xeles, por lo que puede crear equipos que computen m√∫ltiples p√≠xeles en paralelo.  Sin embargo, la GPU solo representa lo que ordena para dibujar la CPU.  Si la CPU no puede "alimentar" r√°pidamente la GPU con datos, entonces la tarjeta de video estar√° inactiva.  Cada vez que la CPU ordena a la GPU que dibuje algo, se llama una llamada de extracci√≥n.  La llamada de sorteo m√°s simple consiste en renderizar una malla, que incluye un sombreador y un conjunto de texturas. <br><br>  Imagine un procesador lento que puede transferir 100 llamadas de extracci√≥n por cuadro, y una GPU r√°pida que puede extraer un mill√≥n de pol√≠gonos por cuadro.  En este caso, una llamada de sorteo ideal puede dibujar 10,000 pol√≠gonos.  Si sus mallas consisten en solo 100 pol√≠gonos, entonces la GPU podr√° dibujar solo 10,000 pol√≠gonos por cuadro.  Es decir, el 99% de las veces la GPU estar√° inactiva.  En este caso, podemos aumentar f√°cilmente el n√∫mero de pol√≠gonos en las mallas sin perder nada. <br><br>  En qu√© consiste la llamada de sorteo y el costo de la misma, depende en gran medida de motores y arquitecturas espec√≠ficos.  Algunos motores pueden combinar muchas mallas en una sola llamada de sorteo (realizar sus lotes, lotes), pero todas las mallas tendr√°n que tener el mismo sombreador o pueden tener otras restricciones.  Las nuevas API como Vulkan y DirectX 12 est√°n dise√±adas espec√≠ficamente para resolver este problema al optimizar la forma en que el programa se comunica con el controlador de gr√°ficos, lo que aumenta el n√∫mero de llamadas de extracci√≥n que se pueden transferir en un solo cuadro. <br><br>  Si su equipo est√° escribiendo su propio motor, pregunte a los desarrolladores del motor qu√© limitaciones tienen las llamadas de extracci√≥n.  Si utiliza un motor listo como Unreal o Unity, ejecute puntos de referencia de rendimiento para determinar los l√≠mites de las capacidades del motor.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puede descubrir que puede aumentar la cantidad de pol√≠gonos sin causar una disminuci√≥n en la velocidad. </font></font><br><br><h2>  Conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que este art√≠culo sirva como una buena introducci√≥n para ayudarlo a comprender los diversos aspectos del rendimiento de representaci√≥n. </font><font style="vertical-align: inherit;">En las GPU de diferentes fabricantes, todo se implementa un poco a su manera. </font><font style="vertical-align: inherit;">Existen muchas reservas y condiciones especiales relacionadas con motores espec√≠ficos y plataformas de hardware. </font><font style="vertical-align: inherit;">Mantenga siempre un di√°logo abierto con los programadores de renderizado para usar sus recomendaciones en su proyecto.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sobre el autor </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eskil Steenberg es un desarrollador independiente de juegos y herramientas, y trabaja como consultor y en proyectos independientes. </font><font style="vertical-align: inherit;">Todas las capturas de pantalla se tomaron en proyectos activos utilizando herramientas desarrolladas por Esquil. </font><font style="vertical-align: inherit;">Puede obtener m√°s informaci√≥n sobre su trabajo en el sitio web de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quel Solaar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y en su cuenta de Twitter @quelsolaar.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433186/">https://habr.com/ru/post/es433186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433176/index.html">Certificado de Docker Remote API de autenticaci√≥n con verificaci√≥n de revocaci√≥n</a></li>
<li><a href="../es433178/index.html">C√≥mo restauramos un archivo .wav da√±ado</a></li>
<li><a href="../es433180/index.html">Resolver problemas de tipo de datos en Ruby o hacer que los datos sean confiables nuevamente</a></li>
<li><a href="../es433182/index.html">¬øEs posible capacitar a un agente para negociar en el mercado de valores con refuerzos? Implementaci√≥n de lenguaje R</a></li>
<li><a href="../es433184/index.html">ASP.NET Core 2.2 lanzado. Que hay de nuevo (2 de 3)</a></li>
<li><a href="../es433188/index.html">La Duma del Estado present√≥ un proyecto de ley sobre el trabajo aut√≥nomo de Runet</a></li>
<li><a href="../es433192/index.html">Kubernetes: una soluci√≥n de proyecto personal incre√≠blemente asequible</a></li>
<li><a href="../es433194/index.html">Luz nocturna programada</a></li>
<li><a href="../es433196/index.html">Gu√≠a de regalos de a√±o nuevo</a></li>
<li><a href="../es433198/index.html">10 d√≥lares por hospedaje: hace 20 a√±os y hoy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>