<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌪️ 🐶 🛀🏽 Buku “Belajar Java EE. Pemrograman modern untuk perusahaan besar " 🗺️ 🤟🏼 🥘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Habr! 

 Buku ini menjelaskan tentang generasi baru Java EE. Anda akan memulai perjalanan melalui Java EE dalam konteks dunia modern layanan dan w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku “Belajar Java EE. Pemrograman modern untuk perusahaan besar "</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/418025/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ct/ac/t4/ctact4noq-x7eg0x5gqj_8kbm7g.jpeg" align="left" alt="gambar"></a>  Hai Habr! <br><br>  Buku ini menjelaskan tentang generasi baru Java EE.  Anda akan memulai perjalanan melalui Java EE dalam konteks dunia modern layanan dan wadah mikro.  Ini bukan panduan referensi untuk sintaksis API - konsep dan teknik yang disajikan di sini mencerminkan pengalaman nyata seseorang yang baru-baru ini berjalan di jalur ini, memperhatikan dengan seksama kendala yang muncul, dan siap untuk berbagi pengetahuannya.  Dalam berbagai situasi, mulai dari membuat paket untuk pengujian dan penggunaan cloud, buku ini akan menjadi pendamping yang ideal untuk pemula dan pengembang berpengalaman yang berusaha memahami lebih dari sekadar API, dan membantu mereka membangun kembali pemikiran mereka untuk membuat arsitektur aplikasi modern di Java EE . <br><a name="habracut"></a><br><h3>  Urutan eksekusi </h3><br>  Proses bisnis yang diterapkan dalam aplikasi perusahaan menggambarkan aliran proses tertentu.  Untuk skenario bisnis yang terlibat, ini adalah proses permintaan dan tanggapan yang sinkron, atau pemrosesan tidak sinkron dari proses yang dimulai. <br><br>  Skenario bisnis disebut dalam utas terpisah, satu utas per permintaan atau panggilan.  Streaming dibuat oleh wadah dan dimasukkan ke dalam drive untuk digunakan kembali setelah panggilan berhasil diproses.  Secara default, proses bisnis yang didefinisikan dalam kelas aplikasi, serta tugas lintas sektor seperti transaksi, dijalankan secara berurutan. <br><br><h3>  Eksekusi sinkron </h3><br>  Skenario khas ketika permintaan HTTP membutuhkan respons dari database diimplementasikan sebagai berikut.  Satu utas memproses permintaan yang tiba di loop, misalnya, Sumber Daya Pengguna JAX-RS, dengan membalikkan prinsip kontrol;  Metode sumber daya JAX-RS disebut oleh wadah.  Sumber daya mengimplementasikan dan menggunakan EJB UserManagement, yang juga secara implisit disebut oleh wadah.  Semua operasi dilakukan oleh perantara secara serempak.  Pengguna EJB akan menggunakan manajer entitas untuk menyimpan entitas baru, dan segera setelah metode bisnis yang memulai transaksi yang aktif selesai, wadah akan mencoba untuk melakukan transaksi ke database.  Bergantung pada hasil transaksi, metode sumber daya sirkuit melanjutkan operasi dan menghasilkan respons kepada klien.  Semuanya terjadi secara serempak, pada saat ini klien diblokir dan menunggu tanggapan. <br><br>  Eksekusi sinkron mencakup pemrosesan peristiwa CDI sinkron.  Mereka memisahkan pemicu peristiwa domain dari prosesnya, namun, peristiwa diproses secara serempak.  Ada beberapa metode untuk memantau transaksi.  Jika tahap transaksi ditunjukkan, maka peristiwa tersebut dapat diproses pada tahap ini - selama memperbaiki transaksi, sebelum penyelesaiannya, setelah selesai, dalam kasus transaksi yang gagal atau berhasil.  Secara default, atau jika transaksi tidak aktif, acara CDI segera diproses saat terjadi.  Ini memungkinkan para insinyur untuk mengimplementasikan solusi yang kompleks - misalnya, menggunakan peristiwa yang terjadi hanya setelah berhasil menambahkan entitas ke database.  Bagaimanapun, dalam semua kasus, pemrosesan dilakukan secara serempak. <br><br><h3>  Eksekusi tidak sinkron </h3><br>  Pelaksanaan tugas yang disinkronkan memenuhi persyaratan banyak skenario bisnis, tetapi ada kalanya Anda memerlukan perilaku tidak sinkron.  Ada sejumlah batasan pada penggunaan utas oleh lingkungan Java EE.  Kontainer mengelola sumber daya dan mengalir serta menempatkannya dalam drive.  Utilitas kontrol konkurensi eksternal terletak di luar wadah, dan mereka tidak mengetahui aliran ini.  Oleh karena itu, kode aplikasi tidak boleh berjalan dan mengendalikan utasnya.  Untuk melakukan ini, ia menggunakan fitur Java EE.  Ada beberapa API dengan dukungan asinkron bawaan. <br><br>  <b>Metode Asinkron EJB</b> <br><br>  Cara termudah untuk menerapkan perilaku asinkron adalah dengan menggunakan anotasi @ Asinkron untuk metode bisnis kelas EJB atau EJB.  Panggilan ke metode ini segera kembali, kadang-kadang dengan respons tipe Future.  Mereka berjalan di utas terpisah yang dikendalikan oleh wadah.  Metode ini berfungsi dengan baik untuk skenario sederhana, tetapi terbatas pada EJB: <br><br><pre><code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Asynchronous</span></span> <span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculatePi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> decimalPlaces)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      } }</span></span></code> </pre> <br>  <b>Layanan manajemen kinerja</b> <br><br>  Untuk pelaksanaan tugas yang tidak sinkron dalam objek CDI yang dikelola atau menggunakan utilitas kontrol konkurensi Java SE, Java EE mencakup versi yang dikelola kontainer dari fungsi ExecutorService dan ScheduledExecutorService.  Mereka digunakan untuk mengimplementasikan tugas-tugas tidak sinkron dalam utas yang digerakkan oleh wadah.  Contoh ManagedExecutorService dan ManagedScheduledExecutorService tertanam dalam kode aplikasi.  Mereka dapat digunakan untuk mengeksekusi logika mereka sendiri, tetapi paling efektif ketika dikombinasikan dengan utilitas kontrol konkurensi Java SE, seperti nilai-nilai masa depan yang dilengkapi.  Contoh berikut menunjukkan cara membuat nilai masa depan empuk menggunakan utas yang digerakkan oleh wadah: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.annotation.Resource; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.enterprise.concurrent.ManagedExecutorService; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Random; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.CompletableFuture; <span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService mes; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CompletableFuture&lt;Double&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateRandomPi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxDecimalPlaces)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture.supplyAsync(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random().nextInt(maxDecimalPlaces) + <span class="hljs-number"><span class="hljs-number">1</span></span>, mes) .thenApply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::calculatePi); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculatePi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> decimalPlaces)</span></span></span><span class="hljs-function"> </span></span>{ … } }</code> </pre> <br>  Objek Kalkulator mengembalikan nilai masa depan yang dilengkapi dari tipe ganda, yang masih dapat dihitung saat konteks panggilan dilanjutkan.  Itu dapat diminta ketika perhitungan selesai, serta dikombinasikan dengan perhitungan selanjutnya.  Tidak masalah di mana utas baru diperlukan dalam aplikasi perusahaan, Anda harus menggunakan fungsionalitas Java EE untuk mengelolanya. <br><br>  <b>Acara CDI Asinkron</b> <br><br>  Acara CDI juga dapat diproses secara tidak sinkron.  Dalam hal ini, wadah juga menyediakan aliran untuk menangani acara.  Untuk menjelaskan peristiwa pengendali asinkron, metode ini dijelaskan dengan @ObservesAsync, dan acara tersebut diaktifkan menggunakan metode fireAsync ().  Cuplikan kode berikut menunjukkan peristiwa CDI asinkron: <br><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarManufacturer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> CarFactory carFactory; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> Event&lt;CarCreated&gt; carCreated; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Car </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">manufactureCar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Specification spec)</span></span></span><span class="hljs-function"> </span></span>{ Car car = carFactory.createCar(spec); carCreated.fireAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CarCreated(spec)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> car; } }</code> </pre> <br>  Pengatur kejadian dipanggil dengan utas yang dikelola wadah sendiri: <br><br><pre> <code class="hljs cs">import javax.enterprise.<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.ObservesAsync; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CreatedCarListener</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCarCreated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">@ObservesAsync CarCreated </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    } }</span></span></code> </pre> <br>  Untuk alasan kompatibilitas ke belakang, peristiwa CDI sinkron juga dapat diproses dalam metode EJB asinkron.  Dengan demikian, peristiwa dan penangan didefinisikan sebagai sinkron, dan metode penangan adalah metode bisnis EJB dengan penjelasan @Asynchronous.  Sebelum peristiwa asinkron diperkenalkan ke standar CDI untuk Java EE 8, ini adalah satu-satunya cara untuk mengimplementasikan fitur ini.  Untuk menghindari kebingungan di Java EE 8 dan yang lebih baru, implementasi ini sebaiknya dihindari. <br><br>  <b>Lingkup Pemrosesan Asinkron</b> <br><br>  Karena wadah tidak memiliki informasi tentang berapa lama tugas asinkron dapat dilakukan, penggunaan cakupan dalam kasus ini terbatas.  Objek dengan cakupan dalam permintaan atau sesi yang tersedia saat tugas asinkron diluncurkan tidak serta merta akan aktif selama implementasinya - permintaan dan sesi dapat berakhir jauh sebelum selesai.  Dengan demikian, utas yang melakukan tugas asinkron, seperti yang disediakan oleh layanan pelaksana yang dijadwalkan atau peristiwa asinkron, mungkin tidak memiliki akses ke instance objek yang dikelola dengan ruang lingkup dalam permintaan atau sesi yang aktif selama panggilan.  Hal yang sama berlaku untuk mengakses tautan ke instance tertanam, misalnya dalam metode lambda yang merupakan bagian dari eksekusi sinkron. <br><br>  Ini harus diperhitungkan saat memodelkan tugas asinkron.  Semua informasi tentang panggilan tertentu harus diberikan pada saat tugas dimulai.  Namun, tugas asinkron dapat memiliki instance objek yang dikelola sendiri dengan cakupan terbatas. <br><br>  <b>Tetapkan waktu eksekusi</b> <br><br>  Skenario bisnis dapat dipanggil tidak hanya dari luar, misalnya, melalui permintaan HTTP, tetapi juga dari dalam aplikasi - tugas yang berjalan pada waktu tertentu. <br><br>  Di dunia Unix, fungsionalitas untuk menjalankan pekerjaan berkala sangat populer - ini adalah tugas-tugas penjadwal.  EJB menyediakan kemampuan yang sama menggunakan pengukur waktu EJB.  Pengatur waktu memanggil metode bisnis pada interval yang ditentukan atau setelah waktu yang ditentukan.  Contoh berikut menjelaskan pengatur waktu siklus yang dimulai setiap sepuluh menit: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.ejb.Schedule; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.ejb.Startup; <span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-meta"><span class="hljs-meta">@Startup</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PeriodicJob</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Schedule</span></span>(minute = <span class="hljs-string"><span class="hljs-string">"*/10"</span></span>, hour = <span class="hljs-string"><span class="hljs-string">"*"</span></span>, persistent = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executeJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   10  } }</span></span></code> </pre> <br>  Setiap EJB - singleton, objek terkelola dengan atau tanpa persistensi negara - dapat membuat pengatur waktu.  Namun, dalam sebagian besar skenario masuk akal untuk membuat penghitung waktu hanya untuk tunggal.  Penundaan diatur untuk semua objek yang aktif.  Biasanya diperlukan untuk meluncurkan tugas yang dijadwalkan dalam waktu, itulah sebabnya itu digunakan dalam singleton.  Untuk alasan yang sama, dalam contoh ini, objek EJB harus aktif ketika aplikasi dimulai.  Ini memastikan bahwa penghitung waktu mulai bekerja segera. <br><br>  Jika Anda menggambarkan timer sebagai konstanta, maka masa pakainya meluas ke seluruh siklus hidup JVM.  Kontainer bertanggung jawab untuk menyimpan timer yang persisten, biasanya dalam database.  Penghitung waktu permanen, yang seharusnya berfungsi saat aplikasi tidak tersedia, hidup saat startup.  Ini juga memungkinkan Anda untuk menggunakan penghitung waktu yang sama dengan banyak instance objek.  Penghitung waktu konstan dengan konfigurasi server yang sesuai adalah solusi yang tepat jika Anda perlu menjalankan proses bisnis tepat sekali di beberapa server. <br><br>  Pengatur waktu yang dibuat secara otomatis menggunakan anotasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Jadwal</a> diuraikan menggunakan ekspresi cron seperti Unix.  Untuk menambah fleksibilitas, pengukur waktu EJB dijelaskan secara terprogram menggunakan layanan pengatur waktu yang disediakan wadah, yang menciptakan metode Pengingat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Waktu</a> Balik dan waktu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">habis</a> . <br><br>  Tugas periodik dan tangguhan juga dapat dijelaskan di luar EJB menggunakan layanan penjadwal yang dikelola kontainer.  Sebuah instance dari ManagedScheduledExecutorService yang melakukan tugas setelah penundaan yang ditentukan atau pada interval yang ditentukan diimplementasikan dalam komponen yang dikelola.  Tugas-tugas ini akan diimplementasikan dalam utas yang digerakkan oleh wadah: <br><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@ApplicationScoped</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Periodic</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedScheduledExecutorService mses; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startAsyncJobs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mses.schedule(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::execute, <span class="hljs-number"><span class="hljs-number">10</span></span>, TimeUnit.SECONDS); mses.scheduleAtFixedRate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::execute, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, TimeUnit.SECONDS); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ … } }</code> </pre> <br>  Memanggil metode startAsyncJobs () akan menjalankan fungsi execute () pada utas yang dikelola sepuluh detik setelah panggilan dan kemudian setiap sepuluh detik setelah menit pertama. <br><br>  <b>Sinkronisasi dan reaktivitas dalam JAX-RS</b> <br><br>  JAX-RS mendukung perilaku asinkron sehingga tidak perlu memblokir aliran permintaan sisi server.  Bahkan jika koneksi HTTP sedang menunggu tanggapan, aliran permintaan dapat terus memproses permintaan lain sementara proses yang panjang berjalan di server.  Alur permintaan dikumpulkan dalam wadah, dan repositori permintaan ini berukuran tertentu.  Agar tidak membuang aliran permintaan, metode sumber daya asinkron JAX-RS membuat tugas yang dieksekusi ketika aliran permintaan kembali dan dapat digunakan kembali.  Koneksi HTTP dilanjutkan dan memberikan respons setelah selesainya tugas asinkron atau setelah batas waktu.  Contoh berikut menunjukkan metode sumber daya sinkron JAX-RS: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Path(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"users"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-meta"><span class="hljs-meta">@Consumes(MediaType.APPLICATION_JSON)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UsersResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService mes; … <span class="hljs-meta"><span class="hljs-meta">@POST</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletionStage&lt;Response&gt; createUserAsync(User user) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture.supplyAsync(() -&gt; createUser(user), mes); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Response createUser(User user) { userStore.create(user); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response.accepted().build(); } }</code> </pre> <br>  Agar alur permintaan sibuk terlalu lama, metode JAX-RS harus diselesaikan dengan cepat.  Ini disebabkan oleh fakta bahwa metode sumber daya dipanggil dari wadah dengan cara inversi kontrol.  Hasil yang diperoleh pada tahap penyelesaian akan digunakan untuk melanjutkan koneksi klien pada akhir pemrosesan. <br><br>  Tahap pengembalian penyelesaian adalah teknologi yang relatif baru di JAX-RS API.  Jika Anda perlu menjelaskan keterlambatan dan pada saat yang sama memberikan fleksibilitas yang lebih besar dengan respons asinkron, Anda dapat memasukkan tipe AsyncResponse dalam metode ini.  Pendekatan ini ditunjukkan dalam contoh berikut: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">javax</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ws</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rs</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.container</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.AsyncResponse</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">javax</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ws</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rs</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.container</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Suspended</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">Path</span></span>("<span class="hljs-keyword"><span class="hljs-keyword">users</span></span>") @Consumes(MediaType.APPLICATION_JSON) public class UsersResource { @<span class="hljs-keyword"><span class="hljs-keyword">Resource</span></span> ManagedExecutorService mes; … @<span class="hljs-keyword"><span class="hljs-keyword">POST</span></span> public void createUserAsync(User user, @Suspended AsyncResponse response) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setTimeout</span></span>(5, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TimeUnit</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SECONDS</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setTimeoutHandler</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.resume</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.status</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Status</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SERVICE_UNAVAILABLE</span></span>)<span class="hljs-selector-class"><span class="hljs-selector-class">.build</span></span>())); <span class="hljs-selector-tag"><span class="hljs-selector-tag">mes</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.execute</span></span>(() <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.resume</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">createUser</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">user</span></span>))); } }</code> </pre> <br>  Berkat batas waktu yang dibuat, permintaan klien tidak akan menunggu tanpa batas, tetapi hanya sampai hasilnya diterima atau batas waktu panggilan berakhir.  Namun, penghitungan akan berlanjut karena dilakukan secara tidak sinkron.  Untuk sumber daya JAX-RS diimplementasikan sebagai EJBs, Anda dapat menerapkan anotasi @Asynchronous sehingga Anda tidak secara eksplisit memanggil metode bisnis asinkron melalui pelaksana layanan. <br><br>  Klien JAX-RS juga mendukung perilaku asinkron.  Bergantung pada persyaratan, masuk akal untuk tidak memblokirnya selama panggilan HTTP.  Contoh sebelumnya menunjukkan cara mengatur penundaan untuk permintaan klien.  Untuk panggilan sistem eksternal yang berjalan lama dan terutama paralel, lebih baik menggunakan perilaku asinkron dan reaktif. <br><br>  Pertimbangkan beberapa aplikasi server yang menyediakan informasi cuaca.  Komponen klien mengakses semua aplikasi ini dan menghitung perkiraan cuaca rata-rata.  Idealnya, Anda dapat membuat akses ke sistem paralel: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.stream.Collectors; <span class="hljs-meta"><span class="hljs-meta">@ApplicationScoped</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeatherForecast</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Client client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;WebTarget&gt; targets; <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService mes; <span class="hljs-meta"><span class="hljs-meta">@PostConstruct</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ client = ClientBuilder.newClient(); targets = … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Forecast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAverageForecast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invokeTargetsAsync() .stream() .map(CompletableFuture::join) .reduce(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::calculateAverage) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"   "</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;CompletableFuture&lt;Forecast&gt;&gt; invokeTargetsAsync() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> targets.stream() .map(t -&gt; CompletableFuture.supplyAsync(() -&gt; t .request(MediaType.APPLICATION_JSON_TYPE) .get(Forecast.class), mes)) .collect(Collectors.toList()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Forecast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateAverage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Forecast first, Forecast second)</span></span></span><span class="hljs-function"> </span></span>{ … } <span class="hljs-meta"><span class="hljs-meta">@PreDestroy</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closeClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ client.close(); } }</code> </pre> <br>  Metode invokeTargetAsync () memanggil objek yang tersedia secara serempak, menggunakan layanan pelaksana terjadwal.  Deskriptor CompletableFuture dikembalikan dan digunakan untuk menghitung hasil rata-rata.  Awal metode join () akan diblokir sampai panggilan selesai dan hasilnya diterima. <br><br>  Objek yang disebut mulai secara tidak sinkron dan menunggu respons dari beberapa sumber sekaligus, mungkin lebih lambat.  Dalam hal ini, menunggu respons dari sumber daya layanan cuaca membutuhkan waktu sebanyak yang diharapkan dari respons yang paling lambat, dan tidak semua respons bersama. <br><br>  Versi terbaru JAX-RS memiliki dukungan bawaan untuk tahap penyelesaian, yang mengurangi kode stereotip dalam aplikasi.  Seperti halnya nilai padded, panggilan segera mengembalikan kode fase penyelesaian untuk referensi di masa mendatang.  Contoh berikut menunjukkan fungsi klien reaktif JAX-RS menggunakan panggilan rx (): <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-type"><span class="hljs-type">Forecast</span></span> getAverageForecast() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invokeTargetsAsync() .stream() .<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>((l, r) -&gt; l.thenCombine(r, this::calculateAverage)) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(s -&gt; s.toCompletableFuture().<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>()) .orElseThrow(() -&gt; new <span class="hljs-type"><span class="hljs-type">IllegalStateException</span></span>(<span class="hljs-string"><span class="hljs-string">"   "</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CompletionStage</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Forecast</span></span>&gt;&gt; invokeTargetsAsync() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> targets.stream() .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(t -&gt; t .request(<span class="hljs-type"><span class="hljs-type">MediaType</span></span>.<span class="hljs-type"><span class="hljs-type">APPLICATION_JSON_TYPE</span></span>) .rx() .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-type"><span class="hljs-type">Forecast</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>)) .collect(<span class="hljs-type"><span class="hljs-type">Collectors</span></span>.toList()); }</code> </pre> <br>  Dalam contoh di atas, Anda tidak perlu mencari layanan dari pelaksana yang dijadwalkan - klien JAX-RS akan mengaturnya sendiri.  Sebelum metode rx () muncul, klien menggunakan panggilan async () eksplisit.  Metode ini berperilaku sama, tetapi hanya mengembalikan objek Masa Depan.  Menggunakan pendekatan reaktif pada klien adalah optimal untuk sebagian besar proyek. <br>  Seperti yang Anda lihat, Java EE menggunakan layanan artis yang dikelola kontainer. <br><br><h3>  Konsep dan prinsip desain dalam Java EE modern </h3><br>  API Java EE didasarkan pada konvensi dan prinsip desain yang dijabarkan sebagai standar.  Insinyur perangkat lunak akan menemukan templat API yang familier dan pendekatan pengembangan aplikasi di dalamnya.  Tujuan Java EE adalah untuk mempromosikan penggunaan API yang konsisten. <br><br>  Prinsip utama aplikasi yang difokuskan terutama pada implementasi skenario bisnis adalah: teknologi tidak boleh mengganggu.  Seperti yang telah disebutkan, insinyur harus dapat fokus pada penerapan logika bisnis tanpa menghabiskan sebagian besar waktu pada masalah teknologi dan infrastruktur.  Idealnya, logika domain diterapkan di Jawa sederhana dan dilengkapi dengan anotasi dan properti lain yang didukung oleh lingkungan perusahaan, tanpa memengaruhi kode domain atau mempersulitnya.  Ini berarti bahwa teknologi tidak memerlukan banyak perhatian dari para insinyur dan tidak memaksakan pembatasan terlalu besar.  Lingkungan J2EE dulu membutuhkan banyak solusi yang sangat kompleks.  Untuk mengimplementasikan antarmuka dan memperluas kelas dasar, kami harus menggunakan objek yang dikelola dan objek penyimpanan yang persisten.  Ini mempersulit logika area subjek dan membuat pengujian menjadi sulit. <br><br>  Dalam Java EE, logika domain diimplementasikan dalam bentuk kelas-kelas Java sederhana yang dilengkapi dengan anotasi, yang menurutnya wadah tersebut menyelesaikan tugas-tugas korporat tertentu selama eksekusi aplikasi.  Praktek membuat kode bersih seringkali melibatkan penulisan kode yang lebih indah daripada nyaman untuk digunakan kembali.  Java EE mendukung pendekatan ini.  Jika karena alasan tertentu Anda perlu menghapus teknologi dan meninggalkan logika murni area subjek, ini dilakukan hanya dengan menghapus anotasi yang sesuai. <br><br>  Seperti yang akan kita lihat di Bab 7, pendekatan pemrograman ini menyiratkan perlunya pengujian, karena untuk programmer, sebagian besar spesifikasi Java EE tidak lebih dari penjelasan. <br><br>  Di seluruh API, prinsip desain yang disebut inversion of control (IoC) telah diadopsi - dengan kata lain, "jangan panggil kami, kami akan menyebut diri kami sendiri."  Ini terutama terlihat di sirkuit aplikasi, seperti sumber daya JAX-RS.  Metode sumber daya dijelaskan menggunakan anotasi metode Java, yang kemudian dipanggil oleh wadah dalam konteks yang sesuai.  Hal yang sama berlaku untuk injeksi ketergantungan, di mana Anda harus memilih generator atau mempertimbangkan tugas lintas sektoral seperti pencegat.  Pengembang aplikasi dapat fokus pada penerapan logika dan menggambarkan hubungan, meninggalkan penerapan detail teknis dalam sebuah wadah.  Contoh lain, tidak begitu jelas, adalah deskripsi mengkonversi objek Java ke JSON dan sebaliknya melalui penjelasan JSON-B.  Objek ditransformasikan tidak hanya dalam bentuk eksplisit, terprogram, tetapi juga secara implisit, dalam gaya deklaratif. <br><br>  Prinsip lain yang memungkinkan para insinyur untuk menerapkan teknologi ini secara efektif adalah pemrograman berdasarkan kesepakatan.  Secara default, Java EE mendefinisikan perilaku tertentu yang cocok dengan sebagian besar skenario penggunaan.  Jika tidak cukup atau tidak memenuhi persyaratan, perilaku dapat didefinisikan ulang, seringkali pada beberapa tingkatan. <br>  Ada banyak contoh pemrograman konvensi.  Salah satunya adalah penggunaan metode sumber daya JAX-RS yang mengubah fungsi Java menjadi respons HTTP.  Jika perilaku standar JAX-RS sehubungan dengan tanggapan tidak memenuhi persyaratan, Anda dapat menerapkan jenis respons tersebut.  Contoh lain adalah spesifikasi objek yang dikelola, yang biasanya diimplementasikan menggunakan anotasi.  Untuk mengubah perilaku ini, Anda dapat menggunakan deskriptor XML beans.xml.  Sangat mudah bagi para programmer bahwa di dunia Java EE modern, aplikasi perusahaan dikembangkan dengan cara pragmatis dan berkinerja tinggi yang biasanya tidak memerlukan penggunaan intensif XML seperti sebelumnya. <br><br>  Adapun produktivitas programmer, prinsip penting lain dari pengembangan pada Java EE adalah bahwa platform ini memerlukan integrasi dalam wadah berbagai standar.  Karena kontainer mendukung serangkaian API tertentu - dan jika seluruh Java EE API didukung, itulah yang sebenarnya terjadi - kontainer juga memerlukan implementasi API untuk menyediakan integrasi API lainnya yang mulus.  Keuntungan dari pendekatan ini adalah kemampuan untuk menggunakan sumber daya JAX-RS dari konversi JSON-B dan teknologi Validasi Bean tanpa konfigurasi eksplisit tambahan, dengan pengecualian anotasi.  Dalam contoh sebelumnya, kami melihat bagaimana fungsi yang didefinisikan dalam standar individu dapat digunakan bersama tanpa upaya tambahan.  Ini adalah salah satu keuntungan terbesar dari platform Java EE.  Spesifikasi umum menjamin kombinasi standar individu.  Pemrogram dapat mengandalkan fitur dan implementasi tertentu yang disediakan oleh server aplikasi. <br><br><h3>  Mudah digunakan kode berkualitas tinggi </h3><br>  Pemrogram umumnya setuju bahwa Anda harus berusaha untuk menulis kode berkualitas tinggi.  Namun, tidak semua teknologi sama-sama cocok untuk ini. <br><br>  Seperti yang disebutkan di awal buku, fokus pada pengembangan aplikasi harus logika bisnis.  Dalam hal terjadi perubahan dalam logika bisnis atau munculnya pengetahuan baru, perlu memperbarui model domain, serta kode sumber.  Diperlukan refactoring berulang untuk membuat dan memelihara model domain dan kode sumber berkualitas tinggi secara keseluruhan.  Upaya untuk memperdalam pemahaman tentang area subjek dijelaskan dalam konsep desain berorientasi masalah. <br><br>  Ada banyak literatur tentang refactoring tingkat kode.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah logika bisnis disajikan dalam bentuk kode dan diverifikasi oleh tes, programmer harus meluangkan waktu dan melakukan upaya untuk memikirkan kembali dan meningkatkan opsi pertama. Ini berlaku untuk pengidentifikasi nama, metode, dan kelas. Yang sangat penting adalah pemilihan nama, tingkat abstraksi, dan titik tanggung jawab bersama.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menurut definisi desain berorientasi masalah, area subjek harus sesuai sebanyak mungkin dengan perwakilannya dalam bentuk kode. Ini termasuk, khususnya, bahasa bidang subjek - dengan kata lain, cara programmer dan pakar bisnis berbicara tentang fungsi-fungsi tertentu. Tujuan dari seluruh tim adalah untuk menemukan bahasa umum universal yang akan digunakan secara efektif tidak hanya dalam diskusi dan slide presentasi, tetapi juga dalam kode. Penyempurnaan pengetahuan di bidang bisnis akan terjadi secara siklis. Seperti refactoring pada level kode, pendekatan ini menyiratkan bahwa model asli tidak akan sepenuhnya memenuhi semua persyaratan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan demikian, teknologi yang diterapkan harus mendukung perubahan model dan kode. Jika ada terlalu banyak batasan, maka membuat perubahan nanti akan sulit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk pengembangan aplikasi secara umum, dan terutama untuk refactoring, sangat penting bahwa perangkat lunak cukup tercakup oleh tes otomatis. Karena kode terus berubah, uji regresi memastikan bahwa tidak ada fungsi bisnis yang secara tidak sengaja rusak. Dengan demikian, sejumlah uji kontrol mendukung refactoring, memungkinkan para insinyur untuk memahami dengan jelas bahwa setelah melakukan perubahan, semua fungsi masih berfungsi seperti yang diharapkan. Idealnya, teknologi harus mendukung kemampuan untuk menguji tanpa memaksakan pembatasan pada struktur kode. Kita akan membahas ini secara lebih rinci di Bab 7.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengaktifkan refactoring, ikatan yang lemah lebih disukai daripada ikatan yang ketat. Mengubah satu komponen memengaruhi semua fungsi yang secara eksplisit menyebutnya, dan semua komponen yang dibutuhkan. Java EE mendukung beberapa opsi pengikatan yang lemah: injeksi ketergantungan, peristiwa, dan tugas ujung ke ujung seperti kait. Semua ini menyederhanakan perubahan kode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada sejumlah alat dan metode untuk mengukur kualitas. Secara khusus, analisis kode statis memungkinkan Anda untuk mengumpulkan informasi tentang kompleksitas, konektivitas, dependensi antara kelas dan paket, dan implementasinya secara keseluruhan. Alat-alat ini membantu insinyur mengidentifikasi potensi masalah dan membuat gambaran luas tentang proyek perangkat lunak. Bab 6 akan menunjukkan kepada Anda cara memeriksa kualitas kode secara otomatis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, disarankan untuk terus menata ulang kode dan meningkatkan kualitasnya. Proyek perangkat lunak sering dibuat untuk memperkenalkan fungsi penghasil pendapatan baru, dan bukan untuk meningkatkan fungsionalitas yang ada. Masalahnya adalah bahwa refactoring dan peningkatan kualitas kode pada pandangan pertama tidak membawa manfaat bagi bisnis. Tentu saja tidak demikian. Untuk mencapai kecepatan yang stabil dan mengintegrasikan fungsi-fungsi baru dengan kualitas yang memuaskan, perlu untuk meninjau fungsi yang ada. Idealnya, loop refactoring harus tertanam dalam diagram proyek. Pengalaman menunjukkan bahwa manajer proyek sering tidak menyadari masalah ini. Namun, tim insinyur perangkat lunak bertanggung jawab untuk menjaga kualitas.</font></font><br><br><h3>  Tentang penulis </h3><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebastian Daschner</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah pekerja lepas Java yang bekerja sebagai konsultan dan guru, pemrogram dan penyuka Java (EE). Dia mengambil bagian dalam JCP, membantu menciptakan standar Java EE baru, melayani 37SR dan 374 kelompok ahli di JSR dan bekerja di berbagai proyek sumber terbuka. Untuk kontribusinya pada komunitas dan ekosistem Jawa, ia telah dianugerahi gelar Java and Oracle Development Champion.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebastian secara teratur berbicara di konferensi IT internasional seperti JavaLand, JavaOne, dan Jfokus. </font><font style="vertical-align: inherit;">Dia menerima JavaOne Rockstar Award di JavaOne Conference 2016. Bersama dengan manajer komunitas Java Steve Chin, dia menghadiri puluhan konferensi dan kelompok pengguna Java saat bepergian dengan sepeda motor. </font><font style="vertical-align: inherit;">Steve dan Sebastian menciptakan JOnsen, sebuah konferensi non-Jawa yang diadakan di sumber air panas di pedesaan Jepang.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tentang Peninjau </font></font></h3><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melissa McKay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah pengembang perangkat lunak dengan 15 tahun pengalaman menciptakan berbagai jenis aplikasi untuk klien dan perusahaan swasta. Sekarang ia terutama bergerak dalam aplikasi Java sisi server yang digunakan di bidang komunikasi dan televisi. Minatnya meliputi sistem cluster, ia memiliki hasrat khusus untuk memecahkan masalah yang terkait dengan aplikasi paralel dan multi-berulir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melissa secara teratur menghadiri non-konferensi JCrete di Kreta, Yunani, dan senang menghadiri pembukaan non-konferensi JOnsen di Jepang. Dia menikmati berpartisipasi dalam konferensi IT sukarelawan untuk anak-anak, seperti JavaOne4Kids dan JCrete4Kids. Dia adalah anggota komite konten di JavaOne 2017 dan merupakan anggota aktif dari Kelompok Pengguna Java Denver.</font></font><br><br>  »Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kupon diskon 20% untuk penjaja - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java EE</font></font></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418025/">https://habr.com/ru/post/id418025/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418011/index.html">Halaman Tunggal dan SEO. Rahasia Optimasi</a></li>
<li><a href="../id418013/index.html">Intel Core i7-8086K (bagian 3)</a></li>
<li><a href="../id418015/index.html">Vasyuki baru. Perkembangan inovatif Moskow hingga 2100</a></li>
<li><a href="../id418017/index.html">Analisis perilaku Trojan Pegasus di jaringan</a></li>
<li><a href="../id418023/index.html">Pointer dalam C lebih abstrak dari yang Anda kira</a></li>
<li><a href="../id418027/index.html">Layanan Mikro Blitz</a></li>
<li><a href="../id418029/index.html">ReactOS 0.4.9: pembenci harus mencari argumen baru</a></li>
<li><a href="../id418031/index.html">Penumpukan massal model ML dalam produksi: nyata atau tidak?</a></li>
<li><a href="../id418035/index.html">Memperkenalkan Timeline di Unity</a></li>
<li><a href="../id418037/index.html">Penguji seluler bersiap-siap. Selamat datang di Rapat Pengujian Avito Mobile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>