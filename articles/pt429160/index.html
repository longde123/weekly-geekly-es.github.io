<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüöí üíß üëáüèº GPUs para Nintendo DS Console e recursos interessantes üç¢ üñêüèæ üòæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gostaria de falar sobre o funcionamento do console da Nintendo DS GPU, suas diferen√ßas em rela√ß√£o √†s GPUs modernas, e tamb√©m expressar minha opini√£o s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GPUs para Nintendo DS Console e recursos interessantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429160/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/uc/yy/rg/ucyyrgszova3-3kx-wpaxjbonwk.jpeg"></div><br>  Gostaria de falar sobre o funcionamento do console da Nintendo DS GPU, suas diferen√ßas em rela√ß√£o √†s GPUs modernas, e tamb√©m expressar minha opini√£o sobre por que usar o Vulkan em vez do OpenGL em emuladores n√£o trar√° vantagens. <br><br>  Eu realmente n√£o conhe√ßo o Vulkan, mas pelo que li, est√° claro para mim que o Vulkan difere do OpenGL por funcionar em um n√≠vel mais baixo, permitindo que os programadores gerenciem a mem√≥ria da GPU e coisas semelhantes.  Isso pode ser √∫til para emular consoles mais modernos que usam APIs gr√°ficas propriet√°rias que fornecem n√≠veis de controle n√£o dispon√≠veis no OpenGL. <br><a name="habracut"></a><br>  Por exemplo, o renderizador de hardware blargSNES - um de seus truques √© que, durante algumas opera√ß√µes com buffers de cores diferentes, um buffer de profundidade / est√™ncil √© usado.  No OpenGL, isso n√£o √© poss√≠vel. <br><br>  Al√©m disso, resta menos lixo entre o aplicativo e a GPU, o que significa que, se implementado corretamente, o desempenho ser√° maior.  Enquanto os drivers OpenGL est√£o cheios de otimiza√ß√µes para casos de uso padr√£o e at√© para jogos espec√≠ficos, no Vulkan, o aplicativo em si deve ser bem escrito antes de tudo. <br><br>  Isto √©, em ess√™ncia, "grande responsabilidade vem com grande for√ßa". <br><br>  N√£o sou especialista em API 3D, ent√£o vamos voltar a isso.  O que eu sei bem: console GPU DS. <br><br>  V√°rios artigos j√° foram escritos sobre suas partes individuais ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sobre seus quads sofisticados</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sobre absurdos com viewport</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sobre os recursos divertidos do rasterizador</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sobre a incr√≠vel implementa√ß√£o do anti-aliasing</a> ), mas neste artigo consideraremos o dispositivo como um todo, mas com todos os detalhes interessantes.  Pelo menos √© tudo o que sabemos. <br><br>  A GPU em si √© um hardware bastante antigo e obsoleto.  √â limitado a 2048 pol√≠gonos e / ou 6144 v√©rtices por quadro.  A resolu√ß√£o √© 256x192.  Mesmo se voc√™ quadruplicar isso, o desempenho n√£o ser√° um problema.  Sob condi√ß√µes ideais, o DS pode gerar at√© 122880 pol√≠gonos por segundo, o que √© rid√≠culo pelos padr√µes das GPUs modernas. <br><br>  Agora vamos aos detalhes da GPU.  Aparentemente, parece bastante padr√£o, mas no fundo seu trabalho √© muito diferente do trabalho das GPUs modernas, o que torna a emula√ß√£o de algumas fun√ß√µes mais complicada. <br><br>  A GPU √© dividida em duas partes: um mecanismo de geometria e um mecanismo de renderiza√ß√£o.  O mecanismo de geometria processa os v√©rtices resultantes, constr√≥i pol√≠gonos e os transforma para que voc√™ possa transmiti-los ao mecanismo de renderiza√ß√£o, que (voc√™ adivinhou) desenha tudo na tela. <br><br><h2>  Mecanismo de geometria </h2><br>  Transportador geom√©trico bastante padr√£o. <br><br>  Vale ressaltar que toda aritm√©tica √© realizada em n√∫meros inteiros de ponto fixo, porque o DS n√£o suporta n√∫meros de ponto flutuante. <br><br>  O mecanismo de geometria √© emulado completamente por meio de programa√ß√£o (GPU3D.cpp), ou seja, n√£o se aplica muito ao que usamos para renderizar gr√°ficos, mas, de qualquer forma, vou lhe contar mais sobre isso. <br><br>  1. Transforma√ß√£o e ilumina√ß√£o.  Os v√©rtices e coordenadas de textura resultantes s√£o convertidos usando conjuntos de matrizes 4x4.  Al√©m das cores dos v√©rtices, a ilumina√ß√£o √© aplicada.  Tudo √© bastante padr√£o aqui, o √∫nico n√£o-padr√£o √© como as coordenadas de textura funcionam (1,0 = um DS texel).  Tamb√©m vale a pena mencionar todo o sistema de pilhas de matrizes, que em um grau ou outro s√£o a implementa√ß√£o de hardware do glPushMatrix (). <br><br>  2. Configurando pol√≠gonos.  Os v√©rtices convertidos s√£o montados em pol√≠gonos, que podem ser tri√¢ngulos, quadr√¢ngulos (quadris), faixas de tri√¢ngulos ou faixas de quadr√¢ngulos.  Os quads s√£o processados ‚Äã‚Äãnativamente e n√£o se convertem em tri√¢ngulos, o que √© bastante problem√°tico porque as GPUs modernas suportam apenas tri√¢ngulos.  No entanto, parece que algu√©m <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">veio com uma solu√ß√£o</a> que eu preciso testar. <br><br>  3. Solte.  Os pol√≠gonos podem ser descartados dependendo da orienta√ß√£o na tela e do modo de sele√ß√£o selecionado.  Tamb√©m esquema bastante padr√£o.  No entanto, eu preciso descobrir como isso funciona para quads. <br><br>  4. Truncamento.  Os pol√≠gonos al√©m do escopo de visibilidade s√£o eliminados.  Pol√≠gonos que se estendem parcialmente al√©m dessa regi√£o s√£o truncados.  Esta etapa n√£o cria novos pol√≠gonos, mas adiciona v√©rtices aos j√° existentes.  De fato, cada um dos 6 planos de truncamento pode adicionar um v√©rtice ao pol√≠gono, ou seja, como resultado, podemos obter at√© 10 v√©rtices.  Na se√ß√£o sobre o mecanismo de renderiza√ß√£o, mostrarei como lidamos com isso. <br><br>  5. Converta na viewport.  As coordenadas X / Y s√£o convertidas em coordenadas da tela.  As coordenadas Z s√£o convertidas para caber em um intervalo de buffer de profundidade de 24 bits. <br><br>  O interessante √© como as coordenadas W s√£o processadas: elas s√£o "normalizadas" para caber em um intervalo de 16 bits.  Para isso, cada coordenada W do pol√≠gono √© obtida e, se for maior que 0xFFFF, √© deslocada para a direita em 4 posi√ß√µes para caber em 16 bits.  Por outro lado, se a coordenada for menor que 0x1000, ela se mover√° para a esquerda at√© cair no intervalo.  Suponho que isso seja necess√°rio para obter bons intervalos, o que significa maior precis√£o durante a interpola√ß√£o. <br><br>  6. Classifica√ß√£o.  Os pol√≠gonos s√£o classificados de modo que os pol√≠gonos transl√∫cidos sejam desenhados primeiro.  Em seguida, eles s√£o classificados por suas coordenadas Y (sim), o que √© necess√°rio para pol√≠gonos opacos e opcionalmente transl√∫cidos. <br><br>  Al√©m disso, esta √© a raz√£o da restri√ß√£o de 2048 pol√≠gonos: para a classifica√ß√£o, eles precisam ser armazenados em algum lugar.  Existem dois bancos de mem√≥ria interna alocados para armazenar pol√≠gonos e v√©rtices.  Existe at√© um registro informando quantos pol√≠gonos e v√©rtices s√£o armazenados. <br><br><h2>  Mecanismo de renderiza√ß√£o </h2><br>  E aqui come√ßa a divers√£o! <br><br>  Depois que todos os pol√≠gonos foram configurados e classificados, o mecanismo de renderiza√ß√£o come√ßa a funcionar. <br><br>  A primeira coisa engra√ßada √© como ela preenche os pol√≠gonos.  Isso √© completamente diferente do trabalho das GPUs modernas que executam o preenchimento de blocos e usam algoritmos otimizados por tri√¢ngulo.  N√£o sei como eles funcionam, mas vi como isso √© feito na GPU do console do 3DS e tudo √© baseado em blocos l√°. <br><br>  Seja como for, no DS, a renderiza√ß√£o √© feita em strings raster.  Os desenvolvedores tiveram que fazer isso para que a renderiza√ß√£o pudesse ser executada em paralelo com os motores bidimensionais da telha da velha escola, que executam desenhos em linhas raster.  H√° um pequeno buffer com 48 linhas raster que podem ser usadas para ajustar algumas linhas raster. <br><br>  Um rasterizador √© um renderizador de pol√≠gonos convexos com base em seq√º√™ncias de caracteres raster.  Ele pode lidar com um n√∫mero arbitr√°rio de v√©rtices.  Ele pode renderizar incorretamente se voc√™ passar pol√≠gonos que n√£o s√£o convexos ou t√™m arestas que se cruzam, por exemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ul/ts/vd/ultsvdezpi2riupyjponrg--exq.png"></div><br>  <i>O pol√≠gono √© uma borboleta.</i>  <i>Tudo est√° correto e magn√≠fico.</i> <br><br>  Mas e se mudarmos isso? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t0/z-/48/t0z-48rfmcp8ndjpebeydxaof08.png"></div><br>  <i>Ai.</i> <br><br>  Qual √© o erro aqui?  Vamos desenhar o contorno do pol√≠gono original para descobrir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nl/mj/tx/nlmjtxlv9qeennvaulabodzsnu0.png"></div><br>  Um renderizador pode preencher apenas uma lacuna por linha raster.  Ele define as arestas esquerda e direita come√ßando nos picos mais altos e segue essas arestas at√© encontrar novos picos. <br><br>  Na imagem mostrada acima, ele come√ßa no v√©rtice superior, ou seja, no canto superior esquerdo, e continua a ser preenchido at√© atingir o final da borda esquerda (v√©rtice inferior esquerdo).  Ele n√£o sabe que as arestas se cruzam. <br><br>  Nesse ponto, ele procura o pr√≥ximo v√©rtice na borda esquerda.  √â interessante notar que ele sabe que n√£o precisa usar v√©rtices mais altos que o atual e tamb√©m sabe que as arestas esquerda e direita foram trocadas.  Portanto, ele continua sendo preenchido at√© o final do aterro. <br><br>  Eu acrescentaria mais alguns exemplos de pol√≠gonos n√£o convexos, mas nos afastaremos muito do t√≥pico. <br><br>  Vamos entender melhor como o sombreamento e a textura do Gouraud funcionam com um n√∫mero arbitr√°rio de v√©rtices.  Existem algoritmos baric√™ntricos usados ‚Äã‚Äãpara interpolar dados ao longo de um tri√¢ngulo, mas ... no nosso caso, eles n√£o s√£o adequados. <br><br>  O renderizador do DS aqui tamb√©m tem sua pr√≥pria implementa√ß√£o.  Mais algumas imagens interessantes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p0/-l/qm/p0-lqmqqcinmjrvlzjiw_fsvh5w.png"></div><br>  Os v√©rtices do pol√≠gono s√£o os pontos 1, 2, 3 e 4. Os n√∫meros n√£o correspondem √† ordem real de travessia, mas voc√™ entende o significado. <br><br>  Na linha de varredura atual, o renderizador define os v√©rtices diretamente ao redor das arestas (como mencionado acima, come√ßa nos v√©rtices mais altos e depois percorre as arestas at√© que estejam completas).  No nosso caso, esses s√£o os v√©rtices 1 e 2 para a borda esquerda, 3 e 4 para a borda direita. <br><br>  As inclina√ß√µes das arestas s√£o usadas para determinar os limites da folga, ou seja, pontos 5 e 6. Nesses pontos, os atributos dos v√©rtices s√£o interpolados com base nas posi√ß√µes verticais nas arestas (ou nas posi√ß√µes horizontais das arestas, cujas inclina√ß√µes est√£o principalmente ao longo do eixo X). <br><br>  Em seguida, para cada pixel do espa√ßo (por exemplo, para o ponto 7), os atributos baseados na posi√ß√£o X dentro do espa√ßo s√£o interpolados dos atributos calculados anteriormente nos pontos 5 e 6. <br><br>  Aqui, todos os coeficientes utilizados s√£o iguais a 50% para simplificar o trabalho, mas o significado √© claro. <br><br>  N√£o entrarei nos detalhes da interpola√ß√£o de atributos, embora tamb√©m seja interessante escrever sobre isso.  De fato, essa interpola√ß√£o est√° correta do ponto de vista da perspectiva, mas possui simplifica√ß√µes e recursos interessantes. <br><br>  Agora vamos falar sobre como o DS preenche os pol√≠gonos. <br><br>  Quais regras de preenchimento ele usa?  Tamb√©m h√° muitas coisas interessantes aqui! <br><br>  Em primeiro lugar, existem regras de preenchimento diferentes para pol√≠gonos opacos e transl√∫cidos.  Mas o mais importante √© que essas regras se aplicam <i>pixel por pixel</i> .  Os pol√≠gonos transl√∫cidos podem ter pixels opacos e seguir√£o as mesmas regras que os pol√≠gonos opacos.  Voc√™ pode adivinhar que para imitar esses truques nas GPUs modernas, s√£o necess√°rias v√°rias passagens de renderiza√ß√£o. <br><br>  Al√©m disso, diferentes atributos de pol√≠gono podem influenciar a renderiza√ß√£o de v√°rias maneiras interessantes.  Al√©m dos buffers de cor e profundidade razoavelmente padr√£o, o renderizador tamb√©m possui <i>um buffer de atributo</i> que rastreia todo tipo de coisas interessantes.  Ou seja: o ID do pol√≠gono (separadamente para pol√≠gonos opacos e transl√∫cidos), translucidez de pixel, a necessidade de aplicar neblina, se esse pol√≠gono √© direcionado para ou a partir da c√¢mera (sim, isso tamb√©m) e se o pixel est√° na borda do pol√≠gono.  E talvez outra coisa. <br><br>  A tarefa de emular tal sistema n√£o ser√° trivial.  Uma GPU moderna comum possui um buffer de est√™ncil limitado a 8 bits, o que est√° longe de ser suficiente para tudo o que pode armazenar um buffer de atributo.  Precisamos apresentar uma solu√ß√£o complicada. <br><br>  Vamos descobrir isso: <br><br>  * Atualiza√ß√£o do buffer de profundidade: necess√°ria para pixels opacos, opcional para pixels transl√∫cidos. <br><br>  * IDs de pol√≠gono: IDs de 6 bits s√£o atribu√≠dos a pol√≠gonos, que podem ser usados ‚Äã‚Äãpara diversas finalidades.  IDs de pol√≠gono opacos s√£o usados ‚Äã‚Äãpara marcar bordas.  O ID dos pol√≠gonos transl√∫cidos pode ser usado para controlar onde eles ser√£o desenhados: um pixel transl√∫cido n√£o ser√° desenhado se o ID do pol√≠gono corresponder ao ID do pol√≠gono transl√∫cido j√° no buffer do atributo.  Al√©m disso, os dois IDs de pol√≠gono tamb√©m s√£o usados ‚Äã‚Äãpara controlar a renderiza√ß√£o de sombra.  Por exemplo, voc√™ pode criar uma sombra que cubra o ch√£o, mas n√£o o personagem. <br><br>  (Nota: as sombras s√£o apenas uma implementa√ß√£o do buffer de est√™ncil, n√£o h√° nada de terr√≠vel aqui.) <br><br>  √â importante notar que, ao renderizar pixels transl√∫cidos, o ID existente do pol√≠gono opaco √© salvo, bem como as sinaliza√ß√µes de borda do √∫ltimo pol√≠gono opaco. <br><br>  * sinalizador de nevoeiro: determina se √© necess√°rio aplicar um passe de nevoeiro para esse pixel.  O processo de atualiza√ß√£o depende se o pixel recebido √© opaco ou transl√∫cido. <br><br>  * bandeira da linha de frente: aqui h√° problemas com ela.  D√™ uma olhada na captura de tela: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hb/8m/pb/hb8mpbdxkcher7n0xmaocay2j_4.png"></div><br>  Sands of Destruction, as telas deste jogo s√£o um conjunto de truques.  Eles n√£o apenas alteram suas coordenadas Y para afetar a classifica√ß√£o em Y.  A tela mostrada nesta captura de tela √© provavelmente a pior. <br><br>  Ele usa o caso limite do teste de profundidade: a fun√ß√£o de compara√ß√£o "menor que" <b>assume valores iguais</b> se o jogo <i>desenha um pol√≠gono olhando para a c√¢mera no topo dos pixels opacos do pol√≠gono direcionados para longe da c√¢mera</i> .  Sim exatamente.  E os valores Z de todos os pol√≠gonos s√£o zero.  Se voc√™ n√£o emular esse recurso, alguns elementos estar√£o ausentes na tela. <br><br>  Eu acho que isso foi feito para que a parte da frente do objeto estivesse sempre vis√≠vel na parte de tr√°s, mesmo quando elas s√£o t√£o planas que os valores de Z s√£o os mesmos.  Com todos esses truques e truques, o renderizador do DS √© semelhante √† vers√£o de hardware dos renderizadores da era do DOS. <br><br>  Seja como for, emular esse comportamento por meio da GPU foi dif√≠cil.  Mas existem outros casos semelhantes de teste de profundidade, que tamb√©m precisam ser testados e documentados. <br><br>  * sinalizadores de nervuras: o renderizador rastreia a localiza√ß√£o das bordas dos pol√≠gonos.  Eles s√£o usados ‚Äã‚Äãnas √∫ltimas passagens, nomeadamente na marca√ß√£o de arestas e suaviza√ß√£o de serrilhado.  Tamb√©m existem regras especiais para o preenchimento de pol√≠gonos opacos com o anti-aliasing desativado.  O diagrama abaixo ilustra estas regras: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/pu/hf/eypuhfe9rghuhobfo1r9njkt4wy.png"></div><br>  Nota: os wireframes s√£o renderizados preenchendo apenas as arestas!  Movimento muito inteligente. <br><br>  Outra observa√ß√£o divertida sobre o buffer de profundidade: <br><br>  Existem dois modos de buffer de profundidade poss√≠veis no DS: buffer Z e buffer W.  Isso parece ser bastante padr√£o, mas apenas se voc√™ n√£o entrar em detalhes. <br><br>  * O buffer Z usa coordenadas Z convertidas para caber em um intervalo de buffer de profundidade de 24 bits.  As coordenadas Z s√£o interpoladas linearmente sobre pol√≠gonos (com algumas esquisitices, mas n√£o s√£o particularmente importantes).  Tamb√©m n√£o h√° nada fora do padr√£o. <br><br>  * No buffer W, as coordenadas W s√£o usadas "como est√£o".  As GPUs modernas geralmente usam 1 / W, mas o DS usa apenas aritm√©tica de ponto fixo; portanto, o uso de valores rec√≠procos n√£o √© muito conveniente.  Seja como for, neste modo, as coordenadas W s√£o interpoladas com corre√ß√£o de perspectiva. <br><br>  Aqui est√° a apar√™ncia da aprova√ß√£o final: <br><br>  * marca√ß√£o de borda: os pixels com marcadores de borda definidos recebem uma cor retirada da tabela e determinada com base no ID de um pol√≠gono opaco. <br><br>  Eles ser√£o bordas coloridas de pol√≠gonos.  √â importante notar que, se um pol√≠gono transl√∫cido for desenhado sobre um pol√≠gono opaco, as bordas do pol√≠gono ainda ser√£o coloridas. <br><br>  Um efeito colateral do princ√≠pio de truncamento: as bordas nas quais os pol√≠gonos se cruzam com as bordas da tela tamb√©m ser√£o coloridas.  Voc√™ pode, por exemplo, perceber isso nas capturas de tela do Picross 3D. <br><br>  * nevoeiro: √© aplicado a cada pixel com base nos valores de profundidade usados ‚Äã‚Äãpara indexar a tabela de densidade de nevoeiro.  Como voc√™ pode imaginar, isso se aplica aos pixels que possuem sinalizadores de n√©voa configurados no buffer de atributo. <br><br>  * antialiasing (suaviza√ß√£o): √© aplicado nas bordas dos pol√≠gonos (opacos).  Com base nas inclina√ß√µes das arestas ao renderizar pol√≠gonos, os valores de cobertura de pixel s√£o calculados.  Na √∫ltima passagem, esses pixels s√£o misturados com os pixels abaixo deles, usando o mecanismo complicado que eu descrevi em uma postagem anterior. <br><br>  O antialiasing n√£o deve (e n√£o pode) ser emulado dessa maneira na GPU; portanto, isso n√£o √© importante aqui. <br><br>  Exceto que, se a marca√ß√£o de borda e o anti-aliasing devem ser aplicados aos mesmos pixels, eles obt√™m apenas o tamanho da borda, mas com 50% de opacidade. <br><br>  Parece que descrevi o processo de renderiza√ß√£o mais ou menos bem.  N√£o nos aprofundamos na mistura de texturas (combinando cores de v√©rtice e textura), mas ela pode ser emulada em um shader de fragmento.  O mesmo se aplica √† marca√ß√£o de borda e neblina, desde que encontremos uma maneira de contornar todo esse sistema com um buffer de atributo. <br><br>  Mas, em geral, eu queria transmitir o seguinte: OpenGL ou Vulkan (assim como Direct3D, Glide ou qualquer outra coisa) n√£o ajudar√£o aqui.  Nossas GPUs modernas t√™m energia mais que suficiente para trabalhar com pol√≠gonos brutos.  O problema s√£o os detalhes e os recursos da rasteriza√ß√£o.  E nem se trata da idealidade dos pixels, por exemplo, basta olhar para o rastreador de problemas do emulador DeSmuME para entender quais problemas os desenvolvedores encontram ao renderizar atrav√©s do OpenGL.  Tamb√©m temos que lidar com esses mesmos problemas de alguma forma. <br><br>  Tamb√©m observo que o uso do OpenGL nos permitir√° portar o emulador, por exemplo, para o Switch (porque um usu√°rio do Github chamado Hydr8gon come√ßou a criar uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">porta para o emulador no Switch</a> ). <br><br>  Ent√£o ... me deseje sorte. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt429160/">https://habr.com/ru/post/pt429160/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt429150/index.html">Gerenciando seus m√≥dulos para CMS usando o compositor</a></li>
<li><a href="../pt429152/index.html">Componente de navega√ß√£o Android. Coisas simples que voc√™ precisa fazer</a></li>
<li><a href="../pt429154/index.html">Segundo faturamento, mercado e sandboxes para Big Data: o que os ambientes de teste na nuvem podem fazer?</a></li>
<li><a href="../pt429156/index.html">Toda a verdade sobre o RTOS. Artigo 19. Sem√°foros: introdu√ß√£o e servi√ßos b√°sicos</a></li>
<li><a href="../pt429158/index.html">S√≠ndrome do impostor afeta homens n√£o menos que mulheres ... e outras descobertas de 10.000 entrevistas t√©cnicas</a></li>
<li><a href="../pt429162/index.html">‚ÄúPara fazer mudan√ßas, entender por que as pessoas resistem a isso‚Äù: Jim Holmes sobre o teste de cultura</a></li>
<li><a href="../pt429166/index.html">Multicristal: da hist√≥ria √† especula√ß√£o sobre o futuro</a></li>
<li><a href="../pt429168/index.html">Atrav√©s do fogo e da √°gua: a hist√≥ria da literatura cient√≠fica russa</a></li>
<li><a href="../pt429172/index.html">1C em Proxmox. Notas gerais</a></li>
<li><a href="../pt429174/index.html">BlueStacks 4: teste em hardware fraco + coment√°rios do desenvolvedor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>