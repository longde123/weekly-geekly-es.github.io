<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛃 🚁 🚴 Cara mengalahkan naga: tulis ulang program Anda di Golang 🛣️ 🛌🏻 🖌️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kebetulan program Anda ditulis dalam bahasa scripting - misalnya, di Ruby - dan ada kebutuhan untuk menulis ulang di Golang. 


 Pertanyaan yang masuk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara mengalahkan naga: tulis ulang program Anda di Golang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/437044/"><p>  Kebetulan program Anda ditulis dalam bahasa scripting - misalnya, di Ruby - dan ada kebutuhan untuk menulis ulang di Golang. </p><br><p>  Pertanyaan yang masuk akal: <strong>mengapa</strong> Anda perlu menulis ulang program yang sudah ditulis dan berfungsi dengan baik? </p><br><p><img src="https://habrastorage.org/webt/b7/a0/ho/b7a0hogmqu_sytkfqkhaqbmwbz0.jpeg"><a name="habracut"></a></p><br><p>  Pertama, katakanlah program <strong>dikaitkan dengan ekosistem tertentu</strong> - dalam kasus kami, ini adalah Docker dan Kubernetes.  Seluruh infrastruktur proyek ini ditulis dalam Golang.  Ini membuka akses ke perpustakaan yang menggunakan Docker, Kubernetes dan lainnya.  Dari sudut pandang dukungan, pengembangan, dan penyempurnaan program Anda, lebih menguntungkan untuk menggunakan infrastruktur yang sama dengan yang digunakan produk utama.  Dalam hal ini, semua fitur baru akan segera tersedia dan Anda tidak perlu mengimplementasikannya kembali dalam bahasa lain.  Hanya kondisi ini <strong>dalam situasi khusus kami</strong> yang cukup untuk membuat keputusan tentang perlunya mengubah bahasa secara prinsip, dan tentang bahasa apa yang seharusnya.  Namun, ada keuntungan lain ... </p><br><p>  Kedua, <strong>kemudahan menginstal</strong> aplikasi di Golang.  Anda tidak perlu menginstal Rvm, Ruby, satu set permata, dll ke dalam sistem. Anda perlu mengunduh satu file biner statis dan menggunakannya. </p><br><p> Ketiga, <strong>kecepatan</strong> program di Golang lebih tinggi.  Ini bukan peningkatan sistemik yang signifikan dalam kecepatan, yang diperoleh dengan menggunakan arsitektur dan algoritma yang benar dalam bahasa apa pun.  Tapi ini adalah peningkatan yang dirasakan saat Anda meluncurkan program Anda dari konsol.  Misalnya, <code>--help</code> di Ruby dapat bekerja dalam 0,8 detik, dan di Golang - 0,02 detik.  Itu hanya terasa meningkatkan pengalaman pengguna menggunakan program. </p><br><p>  <em><strong>NB</strong> : Seperti yang dapat ditebak oleh pembaca biasa di blog kami, artikel ini didasarkan pada pengalaman menulis ulang produk <strong>dapp</strong> kami, yang sekarang - belum secara resmi (!) - dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">werf</a> .</em>  <em>Lihat akhir artikel untuk detail lebih lanjut tentang itu.</em> </p><br><p>  Bagus: Anda bisa mengambil dan menulis kode baru yang sepenuhnya terisolasi dari kode skrip lama.  Tetapi segera muncul beberapa <strong>kesulitan dan keterbatasan</strong> sumber daya dan waktu yang dialokasikan untuk pembangunan: </p><br><ul><li>  Versi program saat ini di Ruby secara konstan membutuhkan perbaikan dan koreksi: <br><ul><li>  Bug muncul saat digunakan dan harus segera diperbaiki; </li><li>  Anda tidak dapat membekukan penambahan fitur baru selama enam bulan, karena  Fitur-fitur ini sering dibutuhkan oleh klien / pengguna. </li></ul></li><li>  Mempertahankan 2 basis kode sekaligus sulit dan mahal: <br><ul><li>  Ada beberapa tim yang terdiri dari 2-3 orang, mengingat keberadaan proyek lain selain program Ruby ini. </li></ul></li><li>  Pengenalan versi baru: <br><ul><li>  Seharusnya tidak ada penurunan fungsi yang signifikan; </li><li>  Idealnya, ini harus mulus dan mulus. </li></ul></li></ul><br><p>  Diperlukan proses porting berkelanjutan.  Tapi bagaimana saya bisa melakukan ini jika versi Golang sedang dikembangkan sebagai program mandiri? </p><br><h2 id="pishem-srazu-na-dvuh-yazykah">  Kami menulis dalam dua bahasa sekaligus </h2><br><p>  Tetapi bagaimana jika Anda mentransfer komponen ke Golang dari bawah ke atas?  Kami mulai dengan hal-hal tingkat rendah, kemudian naik abstraksi. </p><br><p>  Bayangkan program Anda terdiri dari komponen-komponen berikut: </p><br><pre> <code class="plaintext hljs">lib/ config.rb build/ image.rb git_repo/ base.rb local.rb remote.rb docker_registry.rb builder/ base.rb shell.rb ansible.rb stage/ base.rb from.rb before_install.rb git.rb install.rb before_setup.rb setup.rb deploy/ kubernetes/ client.rb manager/ base.rb job.rb deployment.rb pod.rb</code> </pre> <br><h3 id="portirovat-komponent-s-funkciyami">  Komponen port dengan fitur </h3><br><p>  Kasus sederhana.  Kami mengambil komponen yang sudah ada yang cukup terisolasi dari yang lain - misalnya, <code>config</code> ( <code>lib/config.rb</code> ).  Dalam komponen ini, hanya fungsi <code>Config::parse</code> yang didefinisikan, yang mengambil path ke config, membacanya, dan menghasilkan struktur yang dihuni.  Biner terpisah pada <code>config</code> Golang dan <code>config</code> paket terkait akan bertanggung jawab untuk implementasinya: </p><br><pre> <code class="plaintext hljs">cmd/ config/ main.go pkg/ config/ config.go</code> </pre> <br><p>  Biner Golang menerima argumen dari file JSON dan menampilkan hasilnya ke file JSON. </p><br><pre> <code class="plaintext hljs">config -args-from-file args.json -res-to-file res.json</code> </pre> <br><p>  <code>config</code> bahwa <code>config</code> dapat menampilkan pesan ke stdout / stderr (dalam program Ruby kami, output <em>selalu</em> menuju ke stdout / stderr, sehingga fitur ini tidak diparameterisasi). </p><br><p>  Memanggil <code>config</code> binary sama dengan memanggil beberapa fungsi dari komponen <code>config</code> .  Argumen melalui file <code>args.json</code> menunjukkan nama fungsi dan parameternya.  Pada output melalui file <code>res.json</code> , <code>res.json</code> mendapatkan hasil dari fungsinya.  Jika fungsi harus mengembalikan objek dari beberapa kelas, maka data <em>objek dari</em> kelas ini dikembalikan dalam bentuk serial JSON. </p><br><p>  Misalnya, untuk memanggil fungsi <code>Config::parse</code> , tentukan <code>args.json</code> berikut: </p><br><pre> <code class="plaintext hljs">{ "command": "Parse", "configPath": "path-to-config.yaml" }</code> </pre> <br><p>  Kami <code>res.json</code> hasilnya di <code>res.json</code> : </p><br><pre> <code class="plaintext hljs">{ "config": { "Images": [{"Name": "nginx"}, {"Name": "rails"}], "From": "ubuntu:16.04" }, }</code> </pre> <br><p>  Di bidang <code>config</code> , kita mendapatkan status objek <code>Config::Config</code> bersambung dalam JSON.  Dari kondisi ini, pada pemanggil di Ruby, Anda perlu membuat objek <code>Config::Config</code> . </p><br><p>  Dalam kasus kesalahan yang <em>disediakan</em> , biner dapat mengembalikan JSON berikut: </p><br><pre> <code class="plaintext hljs">{ "error": "no such file path-to-config.yaml" }</code> </pre> <br><p>  Bidang <code>error</code> harus ditangani oleh penelepon. </p><br><h4 id="vyzyvaem-golang-iz-ruby">  Memanggil Golang dari Ruby </h4><br><p>  Di sisi Ruby, kami mengubah fungsi <code>Config::parse(config_path)</code> menjadi wrapper yang memanggil <code>config</code> kami, mendapatkan hasilnya, memproses semua kemungkinan kesalahan.  Berikut ini contoh pseudocode Ruby dengan penyederhanaan: </p><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config_path</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">call_id</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_random_number</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args_file</span></span></span><span class="hljs-class"> = "</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#{get_tmp_dir}/args.#{call_id}.json" res_file = "#{get_tmp_dir}/res.#{call_id}.json" args_file.write(JSON.dump( "command" =&gt; "Parse", "configPath" =&gt; config_path, )) system("config -args-from-file #{args_file} -res-to-file #{res_file}") raise "config failed with unknown error" if $?.exitstatus != 0 res = JSON.load_file(res_file) raise ParseError, res["error"] if res["error"] return Config.new_from_state(res["config"]) end end</span></span></span></span></code> </pre> <br><p>  Biner bisa rusak dengan bukan nol, kode tak terduga - ini adalah situasi yang luar biasa.  Atau dengan kode yang disediakan - dalam hal ini kita melihat file <code>res.json</code> untuk keberadaan bidang <code>error</code> dan <code>config</code> dan sebagai hasilnya kita mengembalikan objek <code>Config::Config</code> dari bidang <code>config</code> serial. </p><br><p>  Dari sudut pandang pengguna, fungsi <code>Config::Parse</code> tidak berubah. </p><br><h3 id="portirovat-komponent-klass">  Kelas komponen port </h3><br><p>  Sebagai contoh, ambil hierarki kelas <code>lib/git_repo</code> .  Ada 2 kelas: <code>GitRepo::Local</code> dan <code>GitRepo::Remote</code> .  Masuk akal untuk menggabungkan implementasinya dalam biner <code>git_repo</code> tunggal dan, dengan demikian, mengemas <code>git_repo</code> di Golang. </p><br><pre> <code class="plaintext hljs">cmd/ git_repo/ main.go pkg/ git_repo/ base.go local.go remote.go</code> </pre> <br><p>  Panggilan ke biner <code>git_repo</code> sesuai dengan panggilan ke beberapa metode dari <code>GitRepo::Local</code> atau <code>GitRepo::Remote</code> objek <code>GitRepo::Remote</code> .  Objek memiliki status dan dapat berubah setelah pemanggilan metode.  Oleh karena itu, dalam argumen, kami melewati keadaan saat ini berseri dalam JSON.  Dan pada output, kita selalu mendapatkan status objek yang baru - juga di JSON. </p><br><p>  Misalnya, untuk memanggil metode <code>local_repo.commit_exists?(commit)</code> , kami menentukan <code>args.json</code> berikut: </p><br><pre> <code class="plaintext hljs">{ "localGitRepo": { "name": "my_local_git_repo", "path": "path/to/git" }, "method": "IsCommitExists", "commit": "e43b1336d37478282693419e2c3f2d03a482c578" }</code> </pre> <br><p>  Outputnya adalah <code>res.json</code> : </p><br><pre> <code class="plaintext hljs">{ "localGitRepo": { "name": "my_local_git_repo", "path": "path/to/git" }, "result": true, }</code> </pre> <br><p>  Di bidang <code>localGitRepo</code> , keadaan objek baru diterima (yang mungkin tidak berubah).  Kita harus meletakkan keadaan ini di objek- <code>local_git_repo</code> Ruby saat ini <code>local_git_repo</code> . </p><br><h4 id="vyzyvaem-golang-iz-ruby-1">  Memanggil Golang dari Ruby </h4><br><p>  Di sisi Ruby, kita mengubah setiap metode <code>GitRepo::Base</code> , <code>GitRepo::Local</code> , <code>GitRepo::Remote</code> menjadi pembungkus yang memanggil <code>git_repo</code> kami, dapatkan hasilnya, atur status objek objek baru <code>GitRepo::Local</code> atau <code>GitRepo::Remote</code> . </p><br><p>  Kalau tidak, semuanya mirip dengan memanggil fungsi sederhana. </p><br><h4 id="kak-byt-s-polimorfizmom-i-bazovymi-klassami">  Bagaimana menghadapi polimorfisme dan kelas dasar </h4><br><p>  Cara termudah adalah tidak mendukung polimorfisme dari Golang.  Yaitu  pastikan bahwa panggilan ke biner <code>git_repo</code> selalu secara eksplisit ditujukan ke implementasi tertentu (jika <code>localGitRepo</code> ditentukan dalam argumen, maka panggilan tersebut berasal dari <code>GitRepo::Local</code> objek kelas <code>GitRepo::Local</code> ; jika <code>remoteGitRepo</code> ditentukan - lalu dari <code>GitRepo::Remote</code> ) dan dapatkan dengan menyalin sejumlah kecil boilerplate- kode dalam cmd.  Lagipula, <strong>kode ini akan dibuang begitu</strong> pemindahan ke Golang selesai. </p><br><h4 id="kak-menyat-sostoyanie-drugogo-obekta">  Cara mengubah keadaan objek lain </h4><br><p>  Ada situasi ketika suatu objek menerima objek lain sebagai parameter dan memanggil metode yang secara implisit mengubah keadaan objek kedua ini. </p><br><p>  Dalam hal ini, Anda harus: </p><br><ol><li>  Ketika sebuah biner dipanggil, sebagai tambahan dari keadaan serial dari objek yang dipanggil metode tersebut, mentransmisikan status serial dari semua objek parameter. </li><li>  Setelah panggilan, atur ulang keadaan objek tempat metode dipanggil, dan juga setel ulang keadaan semua objek yang diteruskan sebagai parameter. </li></ol><br><p>  Kalau tidak, semuanya serupa. </p><br><h3 id="chto-poluchaetsya">  Apa itu </h3><br><p>  Kami mengambil komponen, port ke Golang, merilis versi baru. </p><br><p>  Dalam kasus ketika komponen yang mendasarinya sudah porting dan komponen tingkat yang lebih tinggi yang menggunakannya ditransfer, <strong>komponen</strong> ini <strong>dapat “menerima” komponen yang mendasarinya</strong> .  Dalam hal ini, binari tambahan terkait mungkin sudah dihapus sebagai tidak perlu. </p><br><p>  Dan ini berlanjut sampai kita sampai pada lapisan paling atas, yang merekatkan <strong>semua abstraksi yang mendasarinya</strong> .  Ini akan menyelesaikan tahap pertama porting.  Lapisan atas adalah CLI.  Dia masih bisa hidup di Ruby untuk sementara waktu sebelum beralih ke Golang sepenuhnya. </p><br><h2 id="kak-rasprostranyat-etogo-monstra">  Bagaimana cara mendistribusikan monster ini? </h2><br><p>  Bagus: sekarang kami memiliki pendekatan untuk secara bertahap port semua komponen.  Pertanyaan: bagaimana cara mendistribusikan program semacam itu dalam 2 bahasa? </p><br><p>  Dalam kasus Ruby, program masih diinstal sebagai Gem.  Segera setelah memanggil biner, ia dapat mengunduh dependensi ini ke URL tertentu (hardcoded) dan menyimpannya secara lokal di sistem (di suatu tempat di file layanan). </p><br><p>  Ketika kami membuat rilis baru dari program kami dalam 2 bahasa, kami harus: </p><br><ol><li>  Kumpulkan dan unggah semua dependensi biner ke hosting tertentu. </li><li>  Buat versi Ruby Gem baru. </li></ol><br><p>  Binari untuk setiap versi berikutnya dikumpulkan secara terpisah, bahkan jika beberapa komponen tidak berubah.  Seseorang dapat membuat versi terpisah dari semua binari dependen.  Maka tidak perlu mengumpulkan binari baru untuk setiap versi program yang baru.  Tetapi dalam kasus kami, kami beralih dari kenyataan bahwa kami tidak punya waktu untuk melakukan sesuatu yang sangat rumit dan mengoptimalkan kode waktu, jadi untuk kesederhanaan kami mengumpulkan biner terpisah untuk setiap versi program hingga merugikan menghemat ruang dan waktu untuk mengunduh. </p><br><h2 id="nedostatki-podhoda">  Kerugian dari pendekatan </h2><br><p>  Jelas, overhead yang terus-menerus memanggil program eksternal melalui <code>system</code> / <code>exec</code> . </p><br><p>  Sulit untuk melakukan <strong>cache data global apa pun di tingkat Golang</strong> - setelah semua, semua data di Golang (misalnya, variabel paket) dibuat ketika suatu metode dipanggil dan mati setelah selesai.  Ini harus selalu diingat.  Namun, caching masih dimungkinkan <strong>pada level instance kelas</strong> atau <strong>dengan secara eksplisit meneruskan parameter</strong> ke komponen eksternal. </p><br><p>  Kita tidak boleh lupa untuk mentransfer <strong>keadaan objek ke Golang</strong> dan mengembalikannya dengan benar setelah panggilan. </p><br><p>  Ketergantungan biner pada Golang <strong>memakan banyak ruang</strong> .  Adalah satu hal ketika ada biner 30 MB tunggal - sebuah program di Golang.  Hal lain, ketika Anda melakukan porting ~ 10 komponen, yang masing-masing memiliki berat 30 MB, kami mendapatkan 300 MB file <strong>untuk setiap versi</strong> .  Karena itu, ruang di hosting biner dan di mesin host, tempat program Anda bekerja dan terus diperbarui, dengan cepat pergi.  Namun, masalahnya tidak signifikan jika Anda menghapus versi lama secara berkala. </p><br><p>  Perhatikan juga bahwa dengan setiap pembaruan program, akan diperlukan waktu untuk mengunduh dependensi biner. </p><br><h2 id="preimuschestva-podhoda">  Manfaat pendekatan </h2><br><p>  Terlepas dari semua kelemahan yang disebutkan, pendekatan ini memungkinkan Anda untuk mengatur <strong>proses porting berkelanjutan ke bahasa lain</strong> dan bertahan dengan satu tim pengembangan. </p><br><p>  Keuntungan paling penting adalah kemampuan untuk mendapatkan <strong>umpan balik cepat</strong> pada kode baru, menguji dan menstabilkannya. </p><br><p>  Dalam hal ini, Anda dapat, antara lain, menambahkan fitur baru ke program Anda, memperbaiki bug di versi saat ini. </p><br><h2 id="kak-sdelat-okonchatelnyy-perevorot-na-golang">  Cara membuat kudeta terakhir di Golang </h2><br><p>  Saat ini semua komponen utama beralih ke Golang dan sudah diuji coba dalam produksi, tetap saja hanya menulis ulang antarmuka teratas program Anda (CLI) ke Golang dan membuang semua kode Ruby lama. </p><br><p>  Pada tahap ini, tetap hanya untuk memecahkan masalah kompatibilitas CLI baru Anda dengan yang lama. </p><br><p>  Hore, kawan!  Revolusi telah menjadi kenyataan. </p><br><h2 id="kak-my-perepisali-dapp-na-golang">  Bagaimana kami menulis ulang dapp di Golang </h2><br><p>  Dapp adalah utilitas yang dikembangkan oleh Flant untuk mengatur proses CI / CD.  Itu ditulis dalam Ruby karena alasan historis: </p><br><ul><li>  Pengalaman luas dalam mengembangkan program di Ruby. </li><li>  Chef Bekas (resep untuk itu ditulis dalam Ruby). </li><li>  Inersia, penolakan untuk menggunakan bahasa baru bagi kita untuk sesuatu yang serius. </li></ul><br><p>  Pendekatan yang dijelaskan dalam artikel itu diterapkan untuk menulis ulang dapp di Golang.  Grafik di bawah ini menunjukkan kronologi perjuangan antara yang baik (Golang, biru) dan kejahatan (Ruby, merah): </p><br><img src="https://habrastorage.org/webt/xc/qg/gy/xcqggyavhbvkewruasv-pgcxbfa.png"><br><p>  <em>Jumlah kode dalam proyek dapp / werf di Ruby vs. bahasa</em>  <em>Golang selama rilis</em> </p><br><p>  Saat ini, Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengunduh alpha versi 1.0</a> , yang tidak memiliki Ruby.  Kami juga mengganti nama dapp menjadi werf, tapi itu cerita lain ... <strong>Tunggu rilis lengkap werf 1.0 segera!</strong> </p><br><p>  Sebagai keuntungan tambahan dari migrasi ini dan ilustrasi integrasi dengan ekosistem Kubernet yang terkenal, kami mencatat bahwa menulis ulang dapp di Golang memberi kami kesempatan untuk membuat proyek lain - <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kubedog</a></strong> .  Jadi kami dapat memisahkan kode untuk melacak sumber daya K8 menjadi proyek terpisah, yang dapat berguna <strong>tidak hanya</strong> di werf, tetapi juga di proyek lain.  Ada solusi lain untuk tugas yang sama <em>(lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengumuman terbaru</a> kami untuk detail)</em> , tetapi untuk "bersaing" dengan mereka (dalam hal popularitas) tanpa Go sebagai dasarnya tidak akan mungkin terjadi. </p><br><h2 id="ps">  PS </h2><br><p>  Baca juga di blog kami: </p><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memperkenalkan perpustakaan kubedog untuk melacak sumber daya Kubernetes.</a> " </li><li>  "Kami secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">resmi memperkenalkan utilitas dapp - DevOps untuk mempertahankan CI / CD</a> ." </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tunggu: dukungan untuk YAML dan Ansible (tanpa sapi) di dapp</a> ." </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bangun dan instal aplikasi di Kubernet menggunakan dapp dan GitLab CI</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437044/">https://habr.com/ru/post/id437044/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437032/index.html">Petunjuk Instalasi Modsecurity NGINX</a></li>
<li><a href="../id437034/index.html">Universal Whistles: Tinjauan Dongle USB Snom A230 dan A210</a></li>
<li><a href="../id437036/index.html">SAPUI5 untuk boneka bagian 2: Latihan selangkah demi selangkah yang lengkap</a></li>
<li><a href="../id437038/index.html">Panduan Terjemahan Aliran Benjamin Winterberg Stream</a></li>
<li><a href="../id437040/index.html">Di Rusia, mulai menguji antarmuka saraf domestik "Neurochat"</a></li>
<li><a href="../id437050/index.html">Buku "Python. Tentu saja ekspres. Edisi ke-3.</a></li>
<li><a href="../id437052/index.html">Jangan ketinggalan untuk belajar: Apakah seorang spesialis IT universitas perlu</a></li>
<li><a href="../id437054/index.html">Intel 9th ​​Generation Processors Baru: Core minus GPU</a></li>
<li><a href="../id437056/index.html">Zimbra Collaboration Suite dan Zextras Suite sepenuhnya kompatibel dengan OS RED domestik</a></li>
<li><a href="../id437062/index.html">Efek dari keterlambatan dan panjang terminal dari sirkuit mikro dan perangkat lunak pada perhitungan total panjang / keterlambatan konduktor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>