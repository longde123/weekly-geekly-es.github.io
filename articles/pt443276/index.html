<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåø üë©üèæ‚Äçü§ù‚Äçüë©üèº ‚ò∏Ô∏è Programador de consultas surpresa no banco de dados PostgreSQL üåÆ üëéüèº üë©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gr√°ficos, relat√≥rios e an√°lises - tudo isso est√° de alguma forma presente no back-office de qualquer empresa, mesmo que muito pequena. Quando as tabel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programador de consultas surpresa no banco de dados PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/okko/blog/443276/">  Gr√°ficos, relat√≥rios e an√°lises - tudo isso est√° de alguma forma presente no back-office de qualquer empresa, mesmo que muito pequena.  Quando as tabelas usuais no Excel / Numbers / Libre ficam lotadas, mas os dados ainda n√£o s√£o muito grandes, as solu√ß√µes tradicionais para as necessidades internas da empresa geralmente s√£o criadas usando bancos de dados relacionais como PostgreSQL, MySQL ou MariaDB. <br><br>  Esses bancos de dados s√£o gratuitos, gra√ßas ao SQL, eles se integram convenientemente a outros componentes do sistema, s√£o populares e a maioria dos desenvolvedores e analistas pode trabalhar com eles.  A carga (tr√°fego e volumes) que eles conseguem digerir √© volumosa o suficiente para aguentar com calma at√© que a empresa possa oferecer solu√ß√µes mais complexas (e caras) para an√°lises e relat√≥rios. <br><a name="habracut"></a><br><h4>  Posi√ß√£o inicial </h4><br>  No entanto, mesmo em uma tecnologia que tem sido repetidamente estudada, sempre existem nuances diferentes que podem subitamente aumentar as preocupa√ß√µes dos engenheiros.  Al√©m da confiabilidade, o problema mais freq√ºentemente mencionado nos bancos de dados √© o desempenho deles.  Obviamente, com um aumento na quantidade de dados, a taxa de resposta do banco de dados diminui, mas se isso acontecer de forma previs√≠vel e for consistente com o aumento da carga, isso n√£o ser√° t√£o ruim.  Voc√™ sempre pode ver com anteced√™ncia quando o banco de dados come√ßa a exigir aten√ß√£o e planejar uma atualiza√ß√£o ou transi√ß√£o para um banco de dados fundamentalmente diferente.  Muito pior se o desempenho do banco de dados diminuir de forma imprevis√≠vel. <br><br>  O t√≥pico de melhorar o desempenho do banco de dados √© t√£o antigo quanto o mundo e muito extenso, e neste artigo eu gostaria de focar em apenas uma dire√ß√£o.  Ou seja, na avalia√ß√£o da efic√°cia dos planos de consulta em um banco de dados PostgreSQL, bem como na altera√ß√£o dessa efici√™ncia ao longo do tempo para tornar o comportamento do planejador de banco de dados mais previs√≠vel. <br><br>  Apesar do fato de que muitas das coisas que ser√£o discutidas s√£o aplic√°veis ‚Äã‚Äãa todas as vers√µes recentes desse banco de dados, os exemplos abaixo significam a vers√£o 11.2, a √∫ltima no momento. <br>  Antes de nos aprofundarmos nos detalhes, faz sentido discordar e dizer algumas palavras sobre a origem dos problemas de desempenho nos bancos de dados relacionais.  Com o que exatamente o banco de dados est√° ocupado quando "desacelera"?  Falta de mem√≥ria (um grande n√∫mero de acessos ao disco ou √† rede), um processador fraco, todos esses s√£o problemas √≥bvios com solu√ß√µes claras, mas o que mais pode afetar a velocidade de execu√ß√£o da consulta? <br><br><h4>  Refresque mem√≥rias </h4><br>  Para que o banco de dados responda √† consulta SQL, ele precisa criar um plano de consulta (em quais tabelas e colunas para ver quais √≠ndices s√£o necess√°rios, o que escolher a partir da√≠, o que comparar, com que quantidade de mem√≥ria √© necess√°ria etc.).  Esse plano √© formado na forma de uma √°rvore, cujos n√≥s s√£o apenas algumas opera√ß√µes t√≠picas, com diferentes complexidades computacionais.  Aqui est√£o alguns deles, por exemplo (N √© o n√∫mero de linhas com as quais executar a opera√ß√£o): <br><br><table><thead><tr><th>  <nobr>Opera√ß√£o</nobr> </th><th>  O que √© feito </th><th>  Custo </th></tr></thead><tbody><tr><td colspan="3">  <i><font color="#999">SELECIONE ... ONDE ... opera√ß√µes de busca de dados</font></i> </td></tr><tr><td>  <nobr>An√°lise Seq</nobr> </td><td>  Carregamos cada linha da tabela e verificamos a condi√ß√£o. </td><td>  O (N) </td></tr><tr><td>  <nobr>Varredura de √≠ndice</nobr> <br>  (√≠ndice da √°rvore b) </td><td>  Os dados est√£o diretamente no √≠ndice, portanto, pesquisamos por condi√ß√£o os elementos necess√°rios do √≠ndice e coletamos os dados a partir da√≠. </td><td>  O (log (N)), procure por um elemento em uma √°rvore classificada. </td></tr><tr><td>  <nobr>Varredura de √≠ndice</nobr> <br>  (√≠ndice de hash) </td><td>  Os dados est√£o diretamente no √≠ndice, portanto, pesquisamos por condi√ß√£o os elementos necess√°rios do √≠ndice e coletamos os dados a partir da√≠. </td><td>  O (1), procurando um item em uma tabela de hash, excluindo o custo de cria√ß√£o de hashes </td></tr><tr><td>  Verifica√ß√£o de heap de bitmap </td><td>  Selecionamos os n√∫meros das linhas necess√°rias por √≠ndice, depois carregamos apenas as linhas necess√°rias e executamos verifica√ß√µes adicionais com elas. </td><td>  Varredura de √çndice + Varredura Seq (M), <br>  Onde M √© o n√∫mero de linhas encontradas ap√≥s a verifica√ß√£o do √≠ndice.  Sup√µe-se que M &lt;&lt; N, isto √©,  O √≠ndice √© mais √∫til que o Seq Scan. </td></tr><tr><td colspan="3">  <i><font color="#999">Opera√ß√µes de jun√ß√£o (JOIN, SELECT de v√°rias tabelas)</font></i> </td></tr><tr><td>  Loop aninhado </td><td>  Para cada linha da tabela esquerda, procure uma linha adequada na tabela direita. </td><td>  O (N2). <br>  Mas se uma das tabelas for muito menor que a outra (dicion√°rio) e praticamente n√£o aumentar com o tempo, o custo real poder√° diminuir para O (N). </td></tr><tr><td>  Hash join </td><td>  Para cada linha das tabelas esquerda e direita, consideramos o hash, o que reduz o n√∫mero de pesquisas de poss√≠veis op√ß√µes de conex√£o. </td><td>  O (N), mas no caso de uma fun√ß√£o hash muito ineficiente ou um grande n√∫mero de campos id√™nticos para a conex√£o, pode haver O (N <sup>2</sup> ) </td></tr><tr><td>  Mesclar jun√ß√£o </td><td>  Por condi√ß√£o, classificamos as tabelas esquerda e direita, ap√≥s as quais combinamos as duas listas classificadas </td><td>  O (N * log (N)) <br>  Classifica√ß√£o de custos + passando pela lista. </td></tr><tr><td colspan="3">  <i><font color="#999">Opera√ß√µes de agrega√ß√£o (GROUP BY, DISTINCT)</font></i> </td></tr><tr><td>  Agregado de grupo </td><td>  Classificamos a tabela de acordo com a condi√ß√£o de agrega√ß√£o e, na lista classificada, agrupamos as linhas adjacentes. </td><td>  O (N * log (N)) </td></tr><tr><td>  Agregado de hash </td><td>  Consideramos o hash para a condi√ß√£o de agrega√ß√£o para cada linha.  Para linhas com o mesmo hash, realizamos agrega√ß√£o. </td><td>  O (N) </td></tr></tbody></table><br>  Como voc√™ pode ver, o custo de uma consulta depende muito de como os dados est√£o localizados nas tabelas e de como essa ordem corresponde √†s opera√ß√µes de hash usadas.  O loop aninhado, apesar do custo em O (N <sup>2</sup> ), pode ser mais rent√°vel que a jun√ß√£o de hash ou a jun√ß√£o de mesclagem quando uma das tabelas unidas degenera em uma ou v√°rias linhas. <br><br>  Al√©m dos recursos da CPU, o custo tamb√©m inclui o uso de mem√≥ria.  Como s√£o recursos limitados, o planejador de consultas precisa encontrar um compromisso.  Se duas tabelas s√£o matematicamente mais lucrativas para se conectar via Hash Join, mas simplesmente n√£o h√° espa√ßo para uma tabela de hash t√£o grande na mem√≥ria, o banco de dados pode ser for√ßado a usar o Merge Join, por exemplo.  Um loop aninhado "lento" geralmente n√£o requer mem√≥ria adicional e est√° pronto para produzir resultados logo ap√≥s o lan√ßamento. <br><br>  O custo relativo dessas opera√ß√µes √© mostrado mais claramente no gr√°fico.  Estes n√£o s√£o n√∫meros absolutos, apenas uma propor√ß√£o aproximada de diferentes opera√ß√µes. <br><br><img src="https://habrastorage.org/webt/9f/p_/mx/9fp_mx7mhhd5kgokxbqeu-kxpfa.png"><br><br>  O gr√°fico de loop aninhado "come√ßa" abaixo, porque  n√£o requer c√°lculos adicionais ou aloca√ß√£o de mem√≥ria ou c√≥pia de dados intermedi√°rios, mas possui um custo de O (N <sup>2</sup> ).  A jun√ß√£o de mesclagem e a jun√ß√£o de hash t√™m custos iniciais mais altos; no entanto, ap√≥s alguns valores de N, eles come√ßam a superar o loop aninhado a tempo.  O planejador tenta escolher o plano com o menor custo e, no gr√°fico acima, adere a diferentes opera√ß√µes com N diferente (seta tracejada verde).  Com o n√∫mero de linhas at√© N1, √© mais lucrativo usar o Nested Loop; de N1 para N2 √© mais lucrativo mesclar Join, depois que N2 se torna mais rent√°vel para Hash Join, no entanto, o Hash Join exige mem√≥ria para criar tabelas de hash.  E ao atingir N3, essa mem√≥ria se torna insuficiente, o que leva ao uso for√ßado do Merge Join. <br><br>  Ao escolher um plano, o planejador estima o custo de cada opera√ß√£o no plano usando um conjunto de custos relativos de algumas opera√ß√µes "at√¥micas" no banco de dados.  Como, por exemplo, c√°lculos, compara√ß√µes, carregamento de uma p√°gina na mem√≥ria, etc.  Aqui est√° uma lista de alguns desses par√¢metros da configura√ß√£o padr√£o, n√£o h√° muitos: <br><br><table><thead><tr><th>  Constante de custo relativo </th><th>  Valor padr√£o </th></tr></thead><tbody><tr><td>  seq_page_cost </td><td>  1.0 </td></tr><tr><td>  random_page_cost </td><td>  4.0 </td></tr><tr><td>  cpu_tuple_cost </td><td>  0,01 </td></tr><tr><td>  cpu_index_tuple_cost </td><td>  0,005 </td></tr><tr><td>  cpu_operator_cost </td><td>  0,0025 </td></tr><tr><td>  parallel_tuple_cost </td><td>  0,1 </td></tr><tr><td>  parallel_setup_cost </td><td>  1000,0 </td></tr></tbody></table><br>  √â verdade que apenas essas constantes s√£o poucas, voc√™ ainda precisa saber o "N", ou seja, exatamente quantas linhas dos resultados anteriores ter√£o que ser processadas em cada uma dessas opera√ß√µes.  O limite superior √© √≥bvio aqui - o banco de dados "sabe" quantos dados h√° em qualquer tabela e sempre pode calcular "ao m√°ximo".  Por exemplo, se voc√™ tiver duas tabelas de 100 linhas cada, a uni√£o delas poder√° produzir de 0 a 10.000 linhas na sa√≠da.  Assim, a pr√≥xima opera√ß√£o de entrada pode ter at√© 10.000 linhas. <br><br>  Mas se voc√™ souber pelo menos um pouco sobre a natureza dos dados nas tabelas, esse n√∫mero de linhas poder√° ser previsto com mais precis√£o.  Por exemplo, para duas tabelas de 100 linhas do exemplo acima, se voc√™ souber com anteced√™ncia que a jun√ß√£o n√£o produzir√° 10 mil linhas, mas as mesmas 100, o custo estimado da pr√≥xima opera√ß√£o ser√° bastante reduzido.  Nesse caso, esse plano poderia ser mais eficaz que outros. <br><br><h4>  Otimiza√ß√£o imediata </h4><br>  Para que o planejador possa prever com mais precis√£o o tamanho dos resultados intermedi√°rios, o PostgreSQL usa a cole√ß√£o de estat√≠sticas em tabelas, que s√£o acumuladas em pg_statistic ou em sua vers√£o mais leg√≠vel - em pg_stats.  Ele √© atualizado automaticamente quando o v√°cuo √© iniciado ou explicitamente com o comando ANALYZE.  Esta tabela armazena uma variedade de informa√ß√µes sobre quais dados e que tipo de natureza est√£o nas tabelas.  Em particular, histogramas de valores, porcentagem de campos vazios e outras informa√ß√µes.  O planejador usa tudo isso para prever com mais precis√£o a quantidade de dados para cada opera√ß√£o na √°rvore do plano e, assim, calcular com mais precis√£o o custo das opera√ß√µes e o plano como um todo. <br><br>  Tome por exemplo a consulta: <br><pre><code class="plaintext hljs">SELECT t1.important_value FROM t1 WHERE t1.a &gt; 100</code> </pre> <br><br>  Suponha que o histograma dos valores na coluna ‚Äút1.a‚Äù tenha revelado que valores maiores que 100 s√£o encontrados em aproximadamente 1% das linhas da tabela.  Ent√£o podemos prever que essa amostra retornar√° cerca de um cent√©simo de todas as linhas da tabela "t1". <br>  O banco de dados oferece a oportunidade de analisar o custo previsto do plano por meio do comando EXPLAIN e o tempo real de sua opera√ß√£o - usando EXPLAIN ANALYZE. <br><br>  Parece que, com as estat√≠sticas autom√°ticas, tudo deve ficar bem agora, mas pode haver dificuldades.  H√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bom artigo</a> sobre isso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no Citus Data</a> , com um exemplo da inefici√™ncia de estat√≠sticas autom√°ticas e a coleta de estat√≠sticas adicionais usando CREATE STATISTICS (dispon√≠vel no PG 10.0). <br><br>  Portanto, para o planejador, existem duas fontes de erros no c√°lculo de custos: <br><br><ol><li>  O custo relativo das opera√ß√µes primitivas (seq_page_cost, cpu_operator_cost e assim por diante) por padr√£o pode ser muito diferente da realidade (custo da cpu 0,01, custo de carregamento da p√°gina srq - 1 ou 4 para carregamento aleat√≥rio da p√°gina).  Longe do fato de que 100 compara√ß√µes ser√£o iguais a 1 carregamento de p√°gina. </li><li>  Erro ao prever o n√∫mero de linhas em opera√ß√µes intermedi√°rias.  O custo real da opera√ß√£o, neste caso, pode ser muito diferente da previs√£o. </li></ol><br>  Em consultas complexas, a elabora√ß√£o e a previs√£o de todos os planos poss√≠veis podem demorar bastante tempo.  Para que serve retornar dados em 1 segundo se o banco de dados estava planejando apenas uma solicita√ß√£o minuciosa?  O PostgreSQL possui um otimizador Geqo para essa situa√ß√£o, √© um agendador que n√£o cria todas as op√ß√µes poss√≠veis para os planos, mas come√ßa com algumas aleat√≥rias e completa as melhores, prevendo maneiras de reduzir custos.  Tudo isso tamb√©m n√£o melhora a precis√£o da previs√£o, embora acelere a busca de pelo menos algum plano mais ou menos ideal. <br><br><h4>  Planos repentinos - concorrentes </h4><br>  Se tudo correr bem, sua solicita√ß√£o ser√° atendida o mais r√°pido poss√≠vel.  √Ä medida que a quantidade de dados aumenta, a velocidade de execu√ß√£o da consulta no banco de dados aumenta gradualmente e, ap√≥s algum tempo, observando-o, voc√™ pode prever aproximadamente quando ser√° necess√°rio aumentar a mem√≥ria ou o n√∫mero de n√∫cleos da CPU ou expandir o cluster, etc. <br><br>  Mas devemos levar em conta o fato de que o plano ideal possui concorrentes com custos de execu√ß√£o pr√≥ximos, o que n√£o vemos.  E se o banco de dados mudar repentinamente o plano de consulta para outro, isso √© uma surpresa.  √â bom se o banco de dados pular para um plano mais eficiente.  E se n√£o?  Vejamos a foto, por exemplo.  Esse √© o custo previsto e o tempo real da implementa√ß√£o de dois planos (vermelho e verde): <br><br><img src="https://habrastorage.org/webt/an/0e/t1/an0et1smgdhh60caqa4yltzgiu4.png"><br><br>  Aqui, um plano √© mostrado em verde e o seu "concorrente" mais pr√≥ximo em vermelho.  A linha pontilhada mostra um gr√°fico dos custos projetados, a linha s√≥lida √© o tempo real.  A seta tracejada cinza mostra a sele√ß√£o do planejador. <br><br>  Suponha que em uma boa sexta √† noite o n√∫mero previsto de linhas em alguma opera√ß√£o intermedi√°ria chegue a N1 e a previs√£o "vermelha" comece a superar a "verde".  O planejador come√ßa a us√°-lo.  O tempo real de execu√ß√£o da consulta aumenta imediatamente (alternando de uma linha s√≥lida verde para uma vermelha), ou seja, o cronograma de degrada√ß√£o do banco de dados assume a forma de uma etapa (ou talvez uma "parede").  Na pr√°tica, esse ‚Äúmuro‚Äù pode aumentar o tempo de execu√ß√£o da consulta em uma ordem de magnitude ou mais. <br><br>  Vale ressaltar que essa situa√ß√£o √© provavelmente mais t√≠pica para o back office e as an√°lises do que para o front-end, uma vez que o √∫ltimo geralmente √© adaptado para consultas mais simult√¢neas e, portanto, utiliza consultas mais simples no banco de dados, onde o erro nas previs√µes do plano √© menor.  Se este for um banco de dados para relat√≥rios ou an√°lises, as consultas podem ser arbitrariamente complexas. <br><br><h4>  Como viver com isso? </h4><br>  Surge a quest√£o: era poss√≠vel prever, de alguma maneira, planos invis√≠veis "subaqu√°ticos"?  Afinal, o problema n√£o √© que eles n√£o s√£o √≥timos, mas que mudar para outro plano pode ocorrer imprevisivelmente e, de acordo com a lei da maldade, no momento mais infeliz para isso. <br><br>  Infelizmente, voc√™ n√£o pode v√™-los diretamente, mas pode procurar planos alternativos alterando os pesos reais pelos quais eles s√£o selecionados.  O significado dessa abordagem √© remover de vista o plano atual, que o planejador considera ideal, para que um de seus concorrentes mais pr√≥ximos se torne ideal e, portanto, ele possa ser visto atrav√©s da equipe EXPLAIN.  Periodicamente, verificando mudan√ßas nos custos desses "concorrentes" e no plano principal, √© poss√≠vel avaliar a probabilidade de que o banco de dados em breve "salte" para outro plano. <br><br>  Al√©m de coletar dados sobre previs√µes de planos alternativos, voc√™ pode execut√°-los e medir seu desempenho, o que tamb√©m fornece uma id√©ia do "bem-estar" interno do banco de dados. <br>  Vamos ver quais ferramentas temos para esses experimentos. <br><br>  Primeiro, voc√™ pode "proibir" explicitamente opera√ß√µes espec√≠ficas usando vari√°veis ‚Äã‚Äãde sess√£o.  Convenientemente, eles n√£o precisam ser alterados na configura√ß√£o e o banco de dados √© recarregado, seus valores mudam apenas na sess√£o aberta atual e n√£o afetam outras sess√µes, para que voc√™ possa experimentar diretamente com dados reais.  Aqui est√° uma lista deles com valores padr√£o.  Quase todas as opera√ß√µes est√£o inclu√≠das: <br><table><thead><tr><th>  Opera√ß√µes Utilizadas </th><th>  Valor padr√£o </th></tr></thead><tbody><tr><td>  enable_bitmapscan <br>  enable_hashagg <br>  enable_hashjoin <br>  enable_indexscan <br>  enable_indexonlyscan <br>  enable_material <br>  enable_mergejoin <br>  enable_nestloop <br>  enable_parallel_append <br>  enable_seqscan <br>  enable_sort <br>  enable_tidscan <br>  enable_parallel_hash <br>  enable_partition_pruning </td><td>  em </td></tr><tr><td>  enable_partitionwise_join <br>  enable_partitionwise_aggregate </td><td>  fora </td></tr></tbody></table><br>  Proibindo ou permitindo determinadas opera√ß√µes, for√ßamos o planejador a selecionar outros planos que podemos ver com o mesmo comando EXPLAIN.  De fato, a ‚Äúproibi√ß√£o‚Äù de opera√ß√µes n√£o pro√≠be seu uso, mas simplesmente aumenta muito seu custo.  No PostgreSQL, cada opera√ß√£o "proibida" acumula automaticamente um custo igual a 10 bilh√µes de unidades convencionais.  Al√©m disso, no EXPLAIN, o peso total do plano pode ser proibitivamente alto, mas no contexto dessas dezenas de bilh√µes, o peso das opera√ß√µes restantes √© claramente vis√≠vel, pois geralmente se encaixa em pedidos menores. <br><br>  De particular interesse s√£o duas das seguintes opera√ß√µes: <br><br><ul><li>  <strong>Hash Join.</strong>  Sua complexidade √© O (N), mas com um erro com uma previs√£o na quantidade do resultado, voc√™ n√£o pode caber na mem√≥ria e precisar√° fazer a jun√ß√£o de mesclagem, com um custo de O (N * log (N)). </li><li>  <strong>Loop aninhado.</strong>  Sua complexidade √© O (N <sup>2</sup> ), portanto, o erro na previs√£o de tamanho afeta quadraticamente a velocidade dessa conex√£o. </li></ul><br>  Por exemplo, vamos pegar alguns n√∫meros reais de consultas, cuja otimiza√ß√£o est√°vamos envolvidos em nossa empresa. <br><br>  <strong><u>Plano 1.</u></strong> Com todas as opera√ß√µes permitidas, o custo total do plano mais ideal foi de 274962,09 unidades. <br><br>  <strong><u>Plano 2.</u></strong> Com o loop aninhado "proibido", o custo aumentou para 40000534153.85.  Esses 40 bilh√µes que comp√µem a maior parte do custo s√£o 4 vezes o Nested Loop usado, apesar da proibi√ß√£o.  E o restante 534153,85 - essa √© precisamente a previs√£o do custo de todas as outras opera√ß√µes no plano.  Como vemos, √© cerca de duas vezes maior que o custo do plano ideal, ou seja, est√° pr√≥ximo o suficiente. <br><br>  <strong><u>Plano 3.</u></strong> Com a Hash Join "proibida", o custo foi de 383253,77.  O plano foi realmente elaborado sem o uso da opera√ß√£o Hash Join, pois n√£o vemos bilh√µes.  Seu custo, no entanto, √© 30% superior ao do √≥timo, o que tamb√©m √© muito pr√≥ximo. <br><br>  Na realidade, os tempos de execu√ß√£o da consulta foram os seguintes: <br><br>  <strong><u>Plano 1</u></strong> (todas as opera√ß√µes permitidas) conclu√≠do em ~ 9 minutos. <br>  <strong><u>O plano 2</u></strong> (com o loop aninhado "proibido") foi conclu√≠do em 1,5 segundos. <br>  <strong><u>O plano 3</u></strong> (com uma jun√ß√£o de hash "proibido") foi conclu√≠do em ~ 5 minutos. <br><br>  O motivo, como voc√™ pode ver, √© a previs√£o incorreta do custo do Nested Loop.  De fato, ao comparar EXPLAIN com EXPLAIN ANALYZE, um erro √© detectado com a defini√ß√£o desse N malfadado na opera√ß√£o intermedi√°ria.  Em vez de uma √∫nica linha prevista, o Nested Loop encontrou milhares de linhas, o que causou um aumento no tempo de execu√ß√£o da consulta em algumas ordens de magnitude. <br><br>  A economia com o Hash Join "proibido" est√° associada √† substitui√ß√£o do hash pela classifica√ß√£o e Merge Join, que funcionaram mais r√°pido nesse caso que o Hash Join.  Observe que esse plano 2, na realidade, √© quase duas vezes mais r√°pido que o plano "ideal" 1. Embora tenha sido previsto que ser√° mais lento. <br><br>  Na pr√°tica, se sua solicita√ß√£o repentinamente (ap√≥s uma atualiza√ß√£o do banco de dados ou apenas por si s√≥) come√ßar a ser executada por muito mais tempo do que antes, tente primeiro negar a Hash Join ou o Nested Loop e veja como isso afeta a velocidade da consulta.  Em um caso de sucesso, voc√™ poder√° pelo menos banir um novo plano n√£o ideal e retornar ao r√°pido anterior. <br><br>  Para fazer isso, voc√™ n√£o precisa alterar os arquivos de configura√ß√£o do PostgreSQL com uma reinicializa√ß√£o do banco de dados; √© simples em qualquer console alterar o valor da vari√°vel desejada para uma sess√£o aberta do banco de dados.  As sess√µes restantes n√£o ser√£o afetadas, a configura√ß√£o ser√° alterada apenas para a sua sess√£o atual.  Por exemplo, assim: <br><br><pre> <code class="plaintext hljs">SET enable_hashjoin='on'; SET enable_nestloop='off'; SELECT ‚Ä¶ FROM ‚Ä¶ (    )</code> </pre><br>  A segunda maneira de influenciar a escolha do plano √© alterar os pesos das opera√ß√µes de baixo n√≠vel.  N√£o existe uma receita universal aqui, mas, por exemplo, se voc√™ tiver um banco de dados com um cache "aquecido" e todos os dados forem armazenados na mem√≥ria, √© prov√°vel que o custo do carregamento seq√ºencial de p√°ginas n√£o seja diferente do custo do carregamento de uma p√°gina aleat√≥ria.  Enquanto na configura√ß√£o padr√£o, aleat√≥rio √© 4 vezes mais caro que seq√ºencial. <br><br>  Ou, outro exemplo, o custo condicional da execu√ß√£o do processamento paralelo √© 1000 por padr√£o, enquanto o custo do carregamento de uma p√°gina √© 1,0.  Faz sentido come√ßar alterando apenas um dos par√¢metros por vez para determinar se isso afeta a escolha do plano.  As maneiras mais f√°ceis s√£o come√ßar definindo o par√¢metro como 0 ou com algum valor alto (1 milh√£o). <br><br>  No entanto, lembre-se de que, ao melhorar o desempenho em uma solicita√ß√£o, √© poss√≠vel degrad√°-lo em outra.  Em geral, existe um amplo campo para experimentos.  √â melhor tentar alter√°-los um de cada vez, um de cada vez. <br><br><h4>  Op√ß√µes alternativas de tratamento </h4><br>  Uma hist√≥ria sobre um agendador seria incompleta sem mencionar pelo menos duas extens√µes do PostgreSQL. <br><br>  O primeiro √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SR_PLAN</a> , para salvar o plano calculado e for√ßar seu uso posterior.  Isso ajuda a tornar o comportamento do banco de dados mais previs√≠vel em termos de op√ß√µes de plano. <br><br>  O segundo √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Adaptive Query Optimizer</a> , que implementa feedback para o planejador a partir da execu√ß√£o em tempo real da consulta, ou seja, o planejador mede os resultados reais da consulta executada e ajusta seus planos no futuro com isso em mente.  O banco de dados √©, portanto, "auto-ajust√°vel" para dados e consultas espec√≠ficas. <br><br><h4>  O que mais o banco de dados faz quando fica lento? </h4><br>  Agora que classificamos mais ou menos o planejamento da consulta, vamos ver o que mais pode ser aprimorado no pr√≥prio banco de dados e nos aplicativos que o utilizam para obter o m√°ximo desempenho dele. <br><br>  Suponha que o plano de consulta j√° seja ideal.  Se excluirmos os problemas mais √≥bvios (pouca mem√≥ria ou um disco / rede lento), ainda haver√° custos para calcular os hashes.  Provavelmente existem grandes oportunidades para futuras melhorias no PostgreSQL (usando a GPU ou mesmo as instru√ß√µes SSE2 / SSE3 / AVX da CPU), mas at√© agora isso n√£o foi feito e os c√°lculos de hash quase nunca usam os recursos de hardware do hardware.  Voc√™ pode ajudar um pouco nesse banco de dados. <br><br>  Se voc√™ notar, por padr√£o, os √≠ndices no PostgreSQL s√£o criados como b-tree.  Sua utilidade √© que eles s√£o bastante vers√°teis.  Esse √≠ndice pode ser usado tanto com condi√ß√µes de igualdade quanto com condi√ß√µes de compara√ß√£o (mais ou menos).  Encontrar um item nesse √≠ndice √© um custo logar√≠tmico.  Mas se sua consulta contiver apenas uma condi√ß√£o de igualdade, os √≠ndices tamb√©m poder√£o ser criados como um √≠ndice de hash, cujo custo √© constante. <br><br>  Al√©m disso, voc√™ ainda pode tentar modificar a solicita√ß√£o para usar sua execu√ß√£o paralela.  Para entender exatamente como reescrev√™-lo, √© melhor se familiarizar com a lista de casos em que o paralelismo √© automaticamente proibido pelo agendador e evitar tais situa√ß√µes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O manual</a> deste t√≥pico descreve brevemente todas as situa√ß√µes, portanto n√£o faz sentido repeti-las aqui. <br><br>  O que fazer se a solicita√ß√£o ainda n√£o for boa em paralelo?  √â muito triste ver como, em seu poderoso banco de dados com v√°rios n√∫cleos, onde voc√™ √© o √∫nico cliente, um n√∫cleo √© 100% ocupado e todos os outros kernels apenas olham para ele.  Nesse caso, voc√™ precisa ajudar o banco de dados na lateral do aplicativo.  Como cada sess√£o possui um n√∫cleo pr√≥prio, √© poss√≠vel abrir v√°rias delas e dividir a consulta geral em partes, fazendo sele√ß√µes mais curtas e r√°pidas, combinando-as em um resultado comum j√° no aplicativo.  Isso ocupar√° o m√°ximo de recursos dispon√≠veis da CPU no banco de dados PostgreSQL. <br><br>  Concluindo, gostaria de observar que as op√ß√µes de diagn√≥stico e otimiza√ß√£o acima s√£o apenas a ponta do iceberg, no entanto, s√£o bastante f√°ceis de usar e podem ajudar a identificar rapidamente o problema diretamente nos dados operacionais, sem arriscar prejudicar a configura√ß√£o ou interromper a opera√ß√£o de outros aplicativos. <br><br>  Consultas bem-sucedidas, com planos precisos e breves. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443276/">https://habr.com/ru/post/pt443276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443266/index.html">Como ajudamos a transformar o trabalho de contabilidade em uma grande empresa de energia</a></li>
<li><a href="../pt443268/index.html">Post mortem: siga o middleware ou como quebramos os coment√°rios</a></li>
<li><a href="../pt443270/index.html">O an√∫ncio do Sony Xperia 1: um novo conceito principal</a></li>
<li><a href="../pt443272/index.html">O mito das pragas nichrome</a></li>
<li><a href="../pt443274/index.html">Compila√ß√£o de not√≠cias da ind√∫stria de jogos de 8 de mar√ßo a domingo</a></li>
<li><a href="../pt443280/index.html">A hist√≥ria de como montei um home theater de 120 polegadas com canos, cordas, uma tela dobr√°vel e veludo preto</a></li>
<li><a href="../pt443282/index.html">O que devemos construir uma blockchain?</a></li>
<li><a href="../pt443284/index.html">√çndices no PostgreSQL - 4 (Btree)</a></li>
<li><a href="../pt443286/index.html">TDMS Fairway. Mecanismo de preenchimento autom√°tico para as principais inscri√ß√µes nos desenhos e detalhes dos documentos</a></li>
<li><a href="../pt443288/index.html">Navega√ß√£o em projetos com v√°rios m√≥dulos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>