<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÜ üï∫üèª üë©üèΩ‚Äçüíº Monolith pour des centaines de versions client: comment nous √©crivons et prenons en charge les tests üçí üö™ üë©üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! 

 Je suis d√©veloppeur backend dans l'√©quipe du serveur Badoo. Lors de la conf√©rence HighLoad de l‚Äôann√©e derni√®re, j‚Äôai fait une pr√©se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monolith pour des centaines de versions client: comment nous √©crivons et prenons en charge les tests</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/443768/"><img src="https://habrastorage.org/webt/tz/sv/jv/tzsvjvswjax_rsrd3fjcriulb-8.jpeg"><br><br>  Bonjour √† tous! <br><br>  Je suis d√©veloppeur backend dans l'√©quipe du serveur Badoo.  Lors de la conf√©rence HighLoad de l‚Äôann√©e derni√®re, j‚Äôai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fait une pr√©sentation</a> , dont je veux partager avec vous une version texte.  Ce message sera tr√®s utile √† ceux qui √©crivent des tests pour le backend eux-m√™mes et rencontrent des probl√®mes avec les tests de code h√©rit√©, ainsi qu'√† ceux qui veulent tester une logique m√©tier complexe. <br><br>  De quoi parlerons-nous?  Tout d'abord, je parlerai bri√®vement de notre processus de d√©veloppement et de la fa√ßon dont il affecte notre besoin de tests et le d√©sir d'√©crire ces tests.  Ensuite, nous allons monter et descendre la pyramide de l'automatisation des tests, discuter des types de tests que nous utilisons, parler des outils √† l'int√©rieur de chacun d'eux et des probl√®mes que nous r√©solvons avec leur aide.  En fin de compte, r√©fl√©chissez √† la fa√ßon de g√©rer et d'ex√©cuter tout cela. <br><a name="habracut"></a><br><h2>  Notre processus de d√©veloppement </h2><br>  Nous avons illustr√© notre processus de d√©veloppement: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/er/hv/jr/erhvjrnkf7zncdxhlgjusogzmyk.png" width="600"></div><br>  Un golfeur est un d√©veloppeur backend.  √Ä un moment donn√©, une t√¢che de d√©veloppement lui arrive, g√©n√©ralement sous la forme de deux documents: les exigences du c√¥t√© commercial et un document technique qui d√©crit les changements dans notre protocole d'interaction entre le backend et les clients (applications mobiles et site). <br><br>  Le d√©veloppeur √©crit le code et le met en service, et plus t√¥t que toutes les applications clientes.  Toutes les fonctionnalit√©s sont prot√©g√©es par des indicateurs de fonctionnalit√© ou des tests A / B, cela est prescrit dans un document technique.  Apr√®s cela, conform√©ment aux priorit√©s actuelles et √† la feuille de route du produit, les applications client sont publi√©es.  Pour nous, d√©veloppeurs backend, il est totalement impr√©visible lorsqu'une fonctionnalit√© particuli√®re sera impl√©ment√©e sur les clients.  Le cycle de publication des applications client est un peu plus compliqu√© et plus long que le n√¥tre, donc nos chefs de produit jonglent litt√©ralement avec les priorit√©s. <br><br>  La culture de d√©veloppement adopt√©e par l'entreprise est d'une grande importance: le d√©veloppeur backend est responsable de la fonctionnalit√© depuis le moment de sa mise en ≈ìuvre sur le backend jusqu'√† la derni√®re int√©gration sur la derni√®re plateforme sur laquelle il √©tait initialement pr√©vu de mettre en ≈ìuvre cette fonctionnalit√©. <br><br>  Cette situation est tout √† fait possible: il y a six mois, vous avez d√©ploy√© une fonctionnalit√©, les √©quipes clientes ne l'ont pas mise en ≈ìuvre depuis longtemps, car les priorit√©s de l'entreprise ont chang√©, vous √™tes d√©j√† occup√© √† travailler sur d'autres t√¢ches, vous avez de nouveaux d√©lais, priorit√©s - et ici, vos coll√®gues se mettent en marche et ils disent: ¬´Vous souvenez-vous de cette chose que vous avez lav√©e il y a six mois?  Elle ne travaille pas. "  Et au lieu de vous engager dans de nouvelles t√¢ches, vous √©teignez les incendies. <br><br><img src="https://habrastorage.org/files/e22/ebe/15c/e22ebe15c2174a4d99ebf0da46fbe950.gif" width="600"><br><br>  Par cons√©quent, nos d√©veloppeurs ont une motivation inhabituelle pour les programmeurs PHP - s'assurer qu'il y a le moins de probl√®mes possible pendant la phase d'int√©gration. <br><br>  Que voulez-vous faire en premier pour vous assurer que la fonctionnalit√© fonctionne? <br><br>  Bien s√ªr, la premi√®re chose qui me vient √† l'esprit est de proc√©der √† des tests manuels.  Vous r√©cup√©rez l'application, mais elle ne sait pas comment - parce que la fonctionnalit√© est nouvelle, les clients s'en occuperont dans six mois.  Eh bien, les tests manuels ne donnent aucune garantie que pendant le temps qui s'√©coule entre la sortie du backend et le d√©but de l'int√©gration, personne ne cassera quoi que ce soit sur les clients. <br><br>  Et ici, les tests automatis√©s viennent √† notre aide. <br><br><h2>  Tests unitaires </h2><br>  Les tests les plus simples que nous √©crivons sont des tests unitaires.  Nous utilisons PHP comme langage principal pour le backend, et PHPUnit comme framework pour les tests unitaires.  Pour l'avenir, je dirai que tous nos tests backend sont √©crits sur la base de ce cadre. <br><br>  Les tests unitaires couvrent le plus souvent de petits morceaux de code isol√©s, v√©rifient les performances des m√©thodes ou des fonctions, c'est-√†-dire qu'il s'agit de minuscules unit√©s de logique m√©tier.  Nos tests unitaires ne doivent pas interagir avec quoi que ce soit, acc√©der √† des bases de donn√©es ou √† des services. <br><br><h3>  Softmocks </h3><br>  La principale difficult√© rencontr√©e par les d√©veloppeurs lors de l'√©criture de tests unitaires est le code non testable, et il s'agit g√©n√©ralement du code h√©rit√©. <br><br>  Un exemple simple.  Badoo a 12 ans, autrefois une tr√®s petite startup, qui a √©t√© d√©velopp√©e par plusieurs personnes.  Le d√©marrage a r√©ussi avec succ√®s sans aucun test.  Ensuite, nous sommes devenus assez grands et nous avons r√©alis√© que vous ne pouvez pas vivre sans tests.  Mais √† cette √©poque, beaucoup de code avait √©t√© √©crit qui fonctionnait.  Ne le r√©√©crivez pas juste pour le plaisir de tester!  Ce ne serait pas tr√®s raisonnable d'un point de vue commercial. <br><br>  Par cons√©quent, nous avons d√©velopp√© une petite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">biblioth√®que open source SoftMocks</a> , ce qui rend notre processus d'√©criture de tests moins cher et plus rapide.  Il intercepte tous les fichiers PHP inclus / requis et remplace √† la vol√©e le fichier source par du contenu modifi√©, c'est-√†-dire du code r√©√©crit.  Cela nous permet de cr√©er des talons pour n'importe quel code.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Il</a> d√©taille le fonctionnement de la biblioth√®que. <br><br>  Voici √† quoi cela ressemble pour un d√©veloppeur: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//mock  \Badoo\SoftMocks::redefineConstant($constantName, $newValue); //mock  : , ,  \Badoo\SoftMocks::redefineMethod( $class, $method, $method_args, $fake_code ); //mock  \Badoo\SoftMocks::redefineFunction( $function, $function_args, $fake_code );</span></span></code> </pre> <br>  Avec l'aide de ces constructions simples, nous pouvons red√©finir globalement tout ce que nous voulons.  En particulier, ils nous permettent de contourner les limitations du cr√©ateur PHPUnit standard.  Autrement dit, nous pouvons nous moquer des m√©thodes statiques et priv√©es, red√©finir les constantes et faire bien plus, ce qui est impossible dans PHPUnit ordinaire. <br><br>  Cependant, nous avons rencontr√© un probl√®me: il semble aux d√©veloppeurs que s'il y a des SoftMocks, il n'est pas n√©cessaire d'√©crire le code test√© - vous pouvez toujours "peigner" le code avec nos mocks globaux, et tout fonctionnera bien.  Mais cette approche conduit √† un code plus complexe et √† l'accumulation de "b√©quilles".  Par cons√©quent, nous avons adopt√© plusieurs r√®gles qui nous permettent de garder la situation sous contr√¥le: <br><br><ol><li>  Tout nouveau code devrait √™tre facilement test√© avec des simulations PHPUnit standard.  Si cette condition est remplie, le code peut √™tre test√© et vous pouvez facilement s√©lectionner un petit morceau et le tester uniquement. <br></li><li>  SoftMocks peut √™tre utilis√© avec un ancien code √©crit d'une mani√®re qui ne convient pas aux tests unitaires, ainsi que dans les cas o√π il est trop cher / long / difficile √† faire autrement (mettez l'accent sur ce qui est n√©cessaire). <br></li></ol><br>  Le respect de ces r√®gles est soigneusement contr√¥l√© au stade de la r√©vision du code. <br><br><h3>  Test de mutation </h3><br>  S√©par√©ment, je veux parler de la qualit√© des tests unitaires.  Je pense que beaucoup d'entre vous utilisent des mesures comme la couverture du code.  Mais elle, malheureusement, ne r√©pond pas √† une question: "Ai-je pass√© un bon test unitaire?"  Il est possible que vous ayez √©crit un tel test, qui en fait ne v√©rifie rien, ne contient pas une seule assertion, mais il g√©n√®re une excellente couverture de code.  Bien s√ªr, l'exemple est exag√©r√©, mais la situation n'est pas si √©loign√©e de la r√©alit√©. <br><br>  R√©cemment, nous avons commenc√© √† introduire le test mutationnel.  Il s'agit d'un concept assez ancien, mais peu connu.  L'algorithme pour de tels tests est assez simple: <br><br><ul><li>  prendre le code et la couverture du code; <br></li><li>  analyser et commencer √† changer le code: vrai √† faux,&gt; √†&gt; =, + √† - (en g√©n√©ral, nuire √† tous les niveaux); <br></li><li>  pour chaque changement de mutation, ex√©cutez des suites de tests qui couvrent la cha√Æne modifi√©e; <br></li><li>  si les tests √©chouent, alors ils sont bons et ne nous permettent vraiment pas de casser le code; <br></li><li>  si les tests ont r√©ussi, tr√®s probablement, ils ne sont pas assez efficaces, malgr√© la couverture, et il peut √™tre utile de les examiner de plus pr√®s, pour donner une certaine affirmation (ou il existe un domaine non couvert par le test). <br></li></ul><br>  Il existe plusieurs frameworks pr√™ts √† l'emploi pour PHP, tels que Humbug et Infection.  Malheureusement, ils ne nous convenaient pas, car ils sont incompatibles avec SoftMocks.  Par cons√©quent, nous avons √©crit notre propre petit utilitaire de console, qui fait de m√™me, mais utilise notre format de couverture de code interne et est ami avec SoftMocks.  Maintenant, le d√©veloppeur le d√©marre manuellement et analyse les tests √©crits par lui, mais nous travaillons √† l'introduction de l'outil dans notre processus de d√©veloppement. <br><br><h2>  Test d'int√©gration </h2><br>  A l'aide de tests d'int√©gration, nous v√©rifions l'interaction avec diff√©rents services et bases de donn√©es. <br><br>  Pour mieux comprendre l'histoire, d√©veloppons une promo fictive et couvrons-la avec des tests.  Imaginez que nos chefs de produits aient d√©cid√© de distribuer des billets de conf√©rence √† nos utilisateurs les plus d√©vou√©s: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/72/us/3f/72us3fyuuclhm8c1erh3qk42yra.png" width="300"></div><br>  La promotion doit √™tre affich√©e si: <br><br><ul><li>  l'utilisateur dans le champ "Travail" indique "programmeur", <br></li><li>  l'utilisateur participe au test A / B HL18_promo, <br></li><li>  L'utilisateur est inscrit depuis plus de deux ans. <br></li></ul><br>  En cliquant sur le bouton ¬´Obtenir un ticket¬ª, nous devons enregistrer les donn√©es de cet utilisateur dans une liste afin de les transf√©rer √† nos responsables qui distribuent les tickets. <br><br>  M√™me dans cet exemple assez simple, il y a une chose qui ne peut pas √™tre v√©rifi√©e √† l'aide de tests unitaires - l'interaction avec la base de donn√©es.  Pour ce faire, nous devons utiliser des tests d'int√©gration. <br><br>  Consid√©rez la mani√®re standard de tester l'interaction avec la base de donn√©es propos√©e par PHPUnit: <br><br><ol><li>  Augmentez la base de donn√©es de test. <br></li><li>  Nous pr√©parons les DataTables et DataSets. <br></li><li>  Ex√©cutez le test. <br></li><li>  Nous effa√ßons la base de donn√©es de test. <br></li></ol><br>  Quelles difficult√©s attendent une telle approche? <br><br><ul><li>  Vous devez prendre en charge les structures de DataTables et DataSets.  Si nous avons chang√© la disposition du tableau, il est n√©cessaire de refl√©ter ces changements dans le test, ce qui n'est pas toujours pratique et n√©cessite du temps suppl√©mentaire. <br></li><li>  Il faut du temps pour pr√©parer la base de donn√©es.  Chaque fois lors de la configuration du test, nous devons y t√©l√©charger quelque chose, cr√©er des tableaux, ce qui est long et g√™nant s'il y a beaucoup de tests. <br></li><li>  Et l'inconv√©nient le plus important: l'ex√©cution de ces tests en parall√®le les rend instables.  Nous avons commenc√© le test A, il a commenc√© √† √©crire sur la table de test, qu'il a cr√©√©e.  Dans le m√™me temps, nous avons lanc√© le test B, qui souhaite fonctionner avec la m√™me table de test.  En cons√©quence, des blocages mutuels et d'autres situations impr√©vues surviennent. <br></li></ul><br>  Pour √©viter ces probl√®mes, nous avons d√©velopp√© notre propre petite biblioth√®que DBMocks. <br><br><h3>  DBMocks </h3><br>  Le principe de fonctionnement est le suivant: <br><br><ol><li>  Avec l'aide de SoftMocks, nous interceptons tous les wrappers √† travers lesquels nous travaillons avec des bases de donn√©es. <br></li><li>  Quand <br>  la requ√™te passe par une simulation, analyse la requ√™te SQL et en extrait DB + TableName, et obtient l'h√¥te de la connexion. <br></li><li>  Sur le m√™me h√¥te dans tmpfs, nous cr√©ons une table temporaire avec la m√™me structure que celle d'origine (nous copions la structure en utilisant SHOW CREATE TABLE). <br></li><li>  Apr√®s cela, nous redirigerons toutes les demandes qui proviendront de la simulation vers cette table vers une demande temporaire fra√Æchement cr√©√©e. <br></li></ol><br>  Qu'est-ce que cela nous donne: <br><br><ul><li>  pas besoin de s'occuper constamment des structures; <br></li><li>  les tests ne peuvent plus corrompre les donn√©es des tables source, car nous les redirigeons vers des tables temporaires √† la vol√©e; <br></li><li>  nous testons toujours la compatibilit√© avec la version de MySQL avec laquelle nous travaillons, et si la demande cesse soudainement d'√™tre compatible avec la nouvelle version, alors notre test la verra et la plantera. <br></li><li>  et surtout, les tests sont maintenant isol√©s, et m√™me si vous les ex√©cutez en parall√®le, les threads se disperseront dans diff√©rentes tables temporaires, car nous ajoutons une cl√© unique √† chaque test dans les noms des tables de test. <br></li></ul><br><h2>  Test d'API </h2><br>  La diff√©rence entre les tests unitaires et API est bien illustr√©e par ce GIF: <br><br><img src="https://habrastorage.org/webt/ho/zb/me/hozbmexeumir1wdsjsgnlobh5xs.gif"><br>  <i>La serrure fonctionne bien, mais elle est attach√©e √† la mauvaise porte.</i> <br><br>  Nos tests simulent une session client, sont capables d'envoyer des requ√™tes au backend, en suivant notre protocole, et le backend y r√©pond comme un vrai client. <br><br><h3>  Pool d'utilisateurs de test </h3><br>  De quoi avons-nous besoin pour r√©ussir ces tests?  Revenons aux conditions du salon de notre promo: <br><br><ul><li>  l'utilisateur dans le champ "Travail" indique "programmeur", <br></li><li>  l'utilisateur participe au test A / B HL18_promo, <br></li><li>  L'utilisateur est inscrit depuis plus de deux ans. <br></li></ul><br>  Apparemment, ici, tout est sur l'utilisateur.  Et en r√©alit√©, 99% des tests API n√©cessitent un utilisateur enregistr√© autoris√©, pr√©sent dans tous les services et bases de donn√©es. <br><br>  O√π l'obtenir?  Vous pouvez essayer de l'enregistrer au moment du test, mais: <br><br><ul><li>  elle est longue et consommatrice de ressources; <br></li><li>  apr√®s avoir termin√© le test, cet utilisateur doit √™tre supprim√© d'une mani√®re ou d'une autre, ce qui est une t√¢che plut√¥t banale si nous parlons de grands projets; <br></li><li>  enfin, comme dans de nombreux autres projets tr√®s charg√©s, nous effectuons de nombreuses op√©rations en arri√®re-plan (ajout d'un utilisateur √† divers services, r√©plication vers d'autres centres de donn√©es, etc.);  les tests ne savent rien de ces processus, mais s'ils s'appuient implicitement sur les r√©sultats de leur ex√©cution, il y a un risque d'instabilit√©. <br></li></ul><br><br>  Nous avons d√©velopp√© un outil appel√© Pool d'utilisateurs de test.  Il repose sur deux id√©es: <br><br><ol><li>  Nous n'enregistrons pas les utilisateurs √† chaque fois, mais nous les utilisons plusieurs fois. <br></li><li>  Apr√®s le test, nous r√©initialisons les donn√©es utilisateur √† leur √©tat d'origine (au moment de l'inscription).  Si cela n'est pas fait, les tests deviendront instables au fil du temps, car les utilisateurs seront ¬´pollu√©s¬ª avec des informations provenant d'autres tests. <br></li></ol><br><br>  Cela fonctionne comme ceci: <br><br><img src="https://habrastorage.org/webt/yg/db/p5/ygdbp5rwmfrbd2ssyiejb3bp8fs.png"><br><br>  √Ä un moment donn√©, nous voulions ex√©cuter nos tests d'API dans un environnement de production.  Pourquoi voulons-nous m√™me cela?  Parce que l'infrastructure de d√©veloppement n'est pas la m√™me que la production. <br><br>  Bien que nous essayions de r√©p√©ter constamment l'infrastructure de production √† une taille r√©duite, devel n'en sera jamais une copie compl√®te.  Pour √™tre absolument s√ªr que la nouvelle version r√©pond aux attentes et qu'il n'y a aucun probl√®me, nous t√©l√©chargeons le nouveau code dans le cluster de pr√©production, qui fonctionne avec les donn√©es et services de production, et y ex√©cutons nos tests d'API. <br><br>  Dans ce cas, il est tr√®s important de r√©fl√©chir √† la fa√ßon d'isoler les utilisateurs de test des vrais. <br><br><div class="spoiler">  <b class="spoiler_title">Que se passera-t-il si les utilisateurs de test commencent √† appara√Ætre r√©els dans notre application.</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/io/wg/gkiowghhl3b4hzazgj9u5e_wf4s.gif" width="300"></div><br></div></div><br>  Comment isoler?  Chacun de nos utilisateurs a un drapeau <code>is_test_user</code> .  Au stade de l'inscription, cela devient <code>yes</code> ou <code>no</code> et ne change plus.  Par ce drapeau, nous isolons les utilisateurs dans tous les services.  Il est √©galement important d'exclure les utilisateurs de test des analyses commerciales et des r√©sultats des tests A / B afin de ne pas fausser les statistiques. <br><br>  Vous pouvez y aller de mani√®re plus simple: nous avons commenc√© avec le fait que tous les utilisateurs de test ont √©t√© ¬´relocalis√©s¬ª en Antarctique.  Si vous avez un g√©oservice, c'est une fa√ßon compl√®tement fonctionnelle. <br><br><h3>  API QA </h3><br>  Nous n'avons pas seulement besoin d'un utilisateur - nous en avons besoin avec certains param√®tres: travailler en tant que programmeur, participer √† un certain test A / B et a √©t√© enregistr√© il y a plus de deux ans.  Pour les utilisateurs de tests, nous pouvons facilement attribuer une profession √† l'aide de notre API backend, mais entrer dans les tests A / B est probabiliste.  Et la condition d'inscription il y a plus de deux ans est g√©n√©ralement difficile √† remplir, car on ne sait pas quand l'utilisateur est apparu dans le pool. <br><br>  Pour r√©soudre ces probl√®mes, nous avons une API QA.  Il s'agit en fait d'une porte d√©rob√©e pour les tests, qui est une m√©thode API bien document√©e qui vous permet de g√©rer rapidement et facilement les donn√©es des utilisateurs et de changer leur √©tat en contournant le protocole principal de notre communication avec les clients.  Les m√©thodes sont √©crites par des d√©veloppeurs backend pour les ing√©nieurs QA et pour une utilisation dans les tests d'interface utilisateur et d'API. <br><br>  L'API QA ne peut √™tre appliqu√©e que dans le cas d'utilisateurs de test: s'il n'y a pas d'indicateur correspondant, le test tombera imm√©diatement.  Voici l'une de nos m√©thodes d'API QA qui vous permet de changer la date d'enregistrement de l'utilisateur en une date arbitraire: <br><br><img src="https://habrastorage.org/webt/gw/mf/ws/gwmfwsbej3rtmytvaxdoxbzrvaa.png"><br><br>  Et cela ressemblera donc √† trois appels qui vous permettront de modifier rapidement les donn√©es de l'utilisateur de test afin qu'il satisfasse aux conditions d'affichage de la promo: <br><br><ul><li>  Dans le champ "Travail" le "programmeur" est indiqu√©: <br> <code>addUserWorkEducation?user_id=ID&amp;works[]=Badoo, <br> </code> <br> </li><li>  L'utilisateur participe au test A / B HL18_promo: <br> <code>forceSplitTest?user_id=ID&amp;test=HL18_promo</code> <br> </li><li>  Enregistr√© il y a plus de deux ans: <br> <code>userCreatedChange?user_id=ID&amp;created=2016-09-01</code> <br> </li></ul><br><br>  Puisqu'il s'agit d'une porte d√©rob√©e, il est imp√©ratif de penser √† la s√©curit√©.  Nous avons prot√©g√© notre service de plusieurs mani√®res: <br><br><ul><li>  isol√© au niveau du r√©seau: les services ne sont accessibles que depuis le r√©seau du bureau; <br></li><li>  √† chaque demande, nous transmettons un secret, sans lequel il est impossible d'acc√©der √† l'API QA m√™me √† partir du r√©seau du bureau; <br></li><li>  les m√©thodes ne fonctionnent qu'avec les utilisateurs de test. <br></li></ul><br><br><h3>  Remotemocks </h3><br>  Pour travailler avec le backend distant des tests API, nous pouvons avoir besoin de simulations.  Pour quoi?  Par exemple, si le test d'API dans l'environnement de production commence √† acc√©der √† la base de donn√©es, nous devons nous assurer que les donn√©es qu'il contient sont effac√©es des donn√©es de test.  De plus, les simulations contribuent √† rendre la r√©ponse au test plus adapt√©e aux tests. <br><br>  Nous avons trois textes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jo/66/dc/jo66dczs4sbrfuzaohyqy7izy6e.png" width="300"></div><br><br>  Badoo est une application multilingue, nous avons un composant de localisation complexe qui vous permet de traduire et de recevoir rapidement des traductions pour l'emplacement actuel de l'utilisateur.  Nos localisateurs travaillent constamment pour am√©liorer les traductions, effectuer des tests A / B avec des jetons et rechercher des formulations plus efficaces.  Et, pendant le test, nous ne pouvons pas savoir quel texte sera retourn√© par le serveur - il peut changer √† tout moment.  Mais nous pouvons utiliser RemoteMocks pour v√©rifier si le composant de localisation est correctement acc√©d√©. <br><br>  Comment fonctionnent RemoteMocks?  Le test demande au backend de les initialiser pour sa session et, √† r√©ception de toutes les demandes suivantes, le backend v√©rifie les faux pour la session en cours.  S'ils le sont, il les initialise simplement √† l'aide de SoftMocks. <br><br>  Si nous voulons cr√©er une maquette distante, nous indiquons quelle classe ou m√©thode doit √™tre remplac√©e et avec quoi.  Toutes les demandes backend ult√©rieures seront ex√©cut√©es en tenant compte de cette simulation: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;remoteInterceptMethod( \Promo\HighLoadConference::class, <span class="hljs-string"><span class="hljs-string">'saveUserEmailToDb'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> );</code> </pre><br>  Eh bien, maintenant, collectons notre test d'API: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//       $app_startup = [ 'supported_promo_blocks' =&gt; [\Mobile\Proto\Enum\PromoBlockType::GENERIC_PROMO] ]; $Client = $this-&gt;getLoginedConnection(BmaFunctionalConfig::USER_TYPE_NEW, $app_startup); //  $Client-&gt;getQaApiClient()-&gt;addUserWorkEducation(['Badoo, ']); $Client-&gt;getQaApiClient()-&gt;forceSplitTest('HL18_promo'); $Client-&gt;getQaApiClient()-&gt;userCreatedChange('2016-09-01'); //     $this-&gt;remoteInterceptMethod(\Promo\HighLoadConference::class, 'saveUserEmail', true); //,   ,   $Resp = $Client-&gt;ServerGetPromoBlocks([]); $this-&gt;assertTrue($Resp-&gt;hasMessageType('CLIENT_NEXT_PROMO_BLOCKS')); $PromoBlock = $Resp-&gt;CLIENT_NEXT_PROMO_BLOCKS; ‚Ä¶ //   CTA, ,   ,   $Resp = $Client-&gt;ServerPromoAccepted($PromoBlock-&gt;getPromoId()); $this-&gt;assertTrue($Resp-&gt;hasMessageType('CLIENT_ACKNOWLEDGE_COMMAND'));</span></span></code> </pre><br><br>  D'une mani√®re si simple, nous pouvons tester toute fonctionnalit√© qui vient au d√©veloppement dans le backend et n√©cessite des modifications dans le protocole mobile. <br><br><h3>  R√®gles d'utilisation des tests d'API </h3><br>  Tout semble aller bien, mais nous avons de nouveau rencontr√© un probl√®me: les tests d'API se sont av√©r√©s trop pratiques pour le d√©veloppement et il y avait une tentation de les utiliser partout.  En cons√©quence, une fois que nous avons r√©alis√© que nous commencions √† r√©soudre des probl√®mes √† l'aide de tests API auxquels ils n'√©taient pas destin√©s. <br><br>  Pourquoi est-ce mauvais?  Parce que les tests API sont tr√®s lents.  Ils vont sur le r√©seau, se tournent vers le backend, qui r√©cup√®re la session, va √† la base de donn√©es et √† un tas de services.  Par cons√©quent, nous avons d√©velopp√© un ensemble de r√®gles d'utilisation des tests API: <br><ul><li>  Les tests API ont pour but de v√©rifier le protocole d'interaction entre le client et le serveur, ainsi que l'int√©gration correcte du nouveau code; <br><br></li><li>  il est permis de couvrir des processus complexes avec eux, par exemple, des cha√Ænes d'actions; <br></li><li>  ils ne peuvent pas √™tre utilis√©s pour tester la petite variabilit√© de la r√©ponse du serveur - c'est la t√¢che des tests unitaires; <br></li><li>  lors de la r√©vision du code, nous v√©rifions notamment les tests. <br></li></ul><br><h2>  Tests d'interface utilisateur </h2><br>  Puisque nous envisageons une pyramide d'automatisation, je vais vous parler un peu des tests d'interface utilisateur. <br><br>  Les d√©veloppeurs backend de Badoo n'√©crivent pas de tests d'interface utilisateur - pour cela, nous avons une √©quipe d√©di√©e dans le d√©partement QA.  Nous couvrons la fonctionnalit√© avec des tests d'interface utilisateur lorsqu'elle est d√©j√† √©voqu√©e et stabilis√©e, car nous pensons qu'il est d√©raisonnable de d√©penser des ressources pour une automatisation assez co√ªteuse de la fonctionnalit√©, qui, peut-√™tre, n'ira pas au-del√† du test A / B. <br><br>  Nous utilisons Calabash pour les tests automatiques mobiles et Selenium pour le Web.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Il</a> parle de notre plate-forme d'automatisation et de test. <br><br><h2>  Essai de fonctionnement </h2><br>  Nous avons maintenant 100 000 tests unitaires, 6 000 tests d'int√©gration et 14 000 tests API.  Si vous essayez de les ex√©cuter dans un seul thread, alors m√™me sur notre machine la plus puissante, une ex√©cution compl√®te de tous prendra: modulaire - 40 minutes, int√©gration - 90 minutes, tests API - dix heures.  C'est trop long. <br><br><h3>  Parall√©lisation </h3><br>  <i>Nous avons parl√© de notre exp√©rience de parall√©lisation des tests unitaires <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans cet article</a> .</i> <br><br>  La premi√®re solution, qui semble √©vidente, consiste √† ex√©cuter des tests dans plusieurs threads.  Mais nous sommes all√©s plus loin et avons fait un cloud pour un lancement parall√®le afin de pouvoir faire √©voluer les ressources mat√©rielles.  Simplifi√©, son travail ressemble √† ceci: <br><br><img src="https://habrastorage.org/webt/2q/s8/v7/2qs8v7eoyhw_-e3iv-igmt_xui0.png"><br><br>  La t√¢che la plus int√©ressante ici est la r√©partition des tests entre les threads, c'est-√†-dire leur r√©partition en morceaux. <br><br>  Vous pouvez les diviser √©galement, mais tous les tests sont diff√©rents, il peut donc y avoir un fort biais dans le temps d'ex√©cution d'un thread: tous les threads ont d√©j√† atteint et l'un se bloque pendant une demi-heure, car il √©tait ¬´chanceux¬ª avec des tests tr√®s lents. <br><br>  Vous pouvez d√©marrer plusieurs threads et les alimenter en testant un √† la fois.  Dans ce cas, l'inconv√©nient est moins √©vident: il y a des frais g√©n√©raux d'initialisation de l'environnement qui, avec un grand nombre de tests et cette approche, commencent √† jouer un r√¥le important. <br><br>  Qu'avons-nous fait?  Nous avons commenc√© √† collecter des statistiques sur le temps n√©cessaire pour ex√©cuter chaque test, puis √† commencer √† composer des morceaux de telle mani√®re que, selon les statistiques, un thread ne fonctionnerait pas pendant plus de 30 secondes.  Dans le m√™me temps, nous emballons les tests assez √©troitement en morceaux pour les rendre plus petits. <br><br>  Cependant, notre approche pr√©sente √©galement un inconv√©nient.  Il est associ√© aux tests API: ils sont tr√®s lents et consomment beaucoup de ressources, emp√™chant l'ex√©cution de tests rapides. <br><br>  Par cons√©quent, nous avons divis√© le cloud en deux parties: dans la premi√®re, seuls les tests rapides sont lanc√©s, et dans la seconde, √† la fois rapide et lent peuvent √™tre lanc√©s.  Avec cette approche, nous avons toujours un morceau du cloud qui peut g√©rer des tests rapides. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6z/py/0n/6zpy0n5tqvqmqjsf7huyqiu5ogo.png" width="600"></div><br><br>  En cons√©quence, les tests unitaires ont commenc√© √† s'ex√©cuter en une minute, les tests d'int√©gration en cinq minutes et les tests API en 15 minutes.  Autrement dit, une course compl√®te au lieu de 12 heures ne prend pas plus de 22 minutes. <br><br><h3>  Test de couverture de code ex√©cut√© </h3><br>  Nous avons un grand monolithe complexe et, dans le bon sens, nous devons constamment effectuer tous les tests, car un changement √† un endroit peut casser quelque chose √† un autre.  C'est l'un des principaux inconv√©nients de l'architecture monolithique. <br><br>  √Ä un moment donn√©, nous sommes arriv√©s √† la conclusion que vous n'avez pas besoin d'ex√©cuter tous les tests √† chaque fois - vous pouvez effectuer des analyses en fonction de la couverture du code: <br><br><ol><li>  Prenez notre branche diff. <br></li><li>  Nous cr√©ons une liste de fichiers modifi√©s. <br></li><li>  Pour chaque fichier, nous obtenons une liste de tests, <br>  qui le couvrent. <br></li><li>  √Ä partir de ces tests, nous cr√©ons un ensemble et l'ex√©cutons dans un nuage de test. <br></li></ol><br>  O√π obtenir une couverture?  Nous collectons des donn√©es une fois par jour lorsque l'infrastructure de l'environnement de d√©veloppement est inactive.  Le nombre de tests effectu√©s a consid√©rablement diminu√©, la vitesse de r√©ception des commentaires de leur part, au contraire, a consid√©rablement augment√©.  Profit! <br><br>  Un bonus suppl√©mentaire √©tait la possibilit√© d'ex√©cuter des tests pour les correctifs.  Malgr√© le fait que Badoo n'a pas √©t√© une startup depuis longtemps, nous pouvons toujours mettre en ≈ìuvre rapidement des changements dans la production, verser rapidement des correctifs, d√©ployer des fonctionnalit√©s et changer la configuration.  En r√®gle g√©n√©rale, la vitesse de d√©ploiement des correctifs est tr√®s importante pour nous.           ,          . <br><br>    .       ,       ,   ,       .        .     ,  code coverage        . ,   , ‚Äî  ,  -        ,     .     . <br><br>         API-,      code coverage.         ,   ,    .       - ,  API-         . <br><br><h2>  Conclusion </h2><br><ul><li>       ,       .    - , , -    . <br></li><li>   ‚â† .    code review    ,   . <br></li><li>       , ,     .         . <br></li><li>   .              . <br></li><li> ,    !     ,         . <br></li></ul><br><br><blockquote> <b> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Badoo PHP Meetup 16 </a> .         PHP-.    ,   .   ! <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  12:00,  ‚Äî   YouTube-</a></b> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443768/">https://habr.com/ru/post/fr443768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443754/index.html">√Ä propos de la pertinence de Selenium WebDriverWait</a></li>
<li><a href="../fr443756/index.html">Conception de la classe: qu'est-ce qui est bon?</a></li>
<li><a href="../fr443758/index.html">Reconnaissance rapide de Doodle Draw: comment se faire des amis R, C ++ et Neural Grids</a></li>
<li><a href="../fr443764/index.html">Ce que le cr√©ateur a fum√©: une arme √† feu inhabituelle</a></li>
<li><a href="../fr443766/index.html">Essayer la programmation de contrat C ++ 20 maintenant</a></li>
<li><a href="../fr443770/index.html">Conception pilot√©e par domaine: objets de valeur et noyau d'entit√© dans la pratique</a></li>
<li><a href="../fr443774/index.html">Comment la neurobiologie interf√®re dans les √©lections pr√©sidentielles am√©ricaines</a></li>
<li><a href="../fr443780/index.html">Projet MCDM. Partie 1. Concept</a></li>
<li><a href="../fr443782/index.html">Les d√©veloppeurs peuvent d√©sormais utiliser l'API r√©seau de Valve pour leurs jeux Steam</a></li>
<li><a href="../fr443786/index.html">Analyse du deuxi√®me concours de quiz Android sur le stand HeadHunter au Mobius 2018 Moscou</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>