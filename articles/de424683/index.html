<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìñ üèà ‚öîÔ∏è 90 neue Funktionen (und APIs) in JDK 11 üíÖüèª üöß üë©üèø‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich pr√§sentiere Ihnen die √úbersetzung des Artikels ‚Äû 90 neue Funktionen (und APIs) in JDK 11 ‚Äú von Simon Ritter. 





 F√ºr viele bedeutet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>90 neue Funktionen (und APIs) in JDK 11</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424683/"><p>  Hallo Habr!  Ich pr√§sentiere Ihnen die √úbersetzung des Artikels ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">90 neue Funktionen (und APIs) in JDK 11</a> ‚Äú von Simon Ritter. </p><br><p><img src="https://habrastorage.org/webt/nz/8c/f_/nz8cf_erkk_q0xqhz_kptdl772s.jpeg"></p><br><p>  F√ºr viele bedeutet der neue sechsmonatige JDK-Ver√∂ffentlichungszyklus, dass einige noch nicht herausgefunden haben, welche neuen Funktionen in JDK 10 enthalten sind, und JDK 11 kurz davor steht. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In einem der fr√ºhen Blogs</a> wurden alle 109 neuen Funktionen und APIs aufgelistet konnte in JDK 10 gefunden werden. Daher wurde f√ºr JDK 11 beschlossen, dasselbe zu tun.  Es wurde jedoch ein anderes Format gew√§hlt.  Dieser Beitrag wird in zwei Abschnitte unterteilt: neue Funktionen, die Entwicklern zur Verf√ºgung stehen (√∂ffentliche API) und alles andere.  Wenn Sie also nur daran interessiert sind, was sich direkt auf Ihre Entwicklung auswirkt, k√∂nnen Sie den zweiten Teil √ºberspringen. </p><br><p>  Die Gesamtzahl der √Ñnderungen, die berechnet werden konnten, betrug 90 (dies ist JEP plus neue Klassen und Methoden, ausgenommen separate Methoden f√ºr den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://openjdk.java.net/groups/net/">HTTP-Client</a> und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flight Recorder</a> ) ( <em>Anmerkung des √úbersetzers: Java Flight Recorder (JFR) war eines der in Oracle integrierten Add-Ons im JDK, aber ab Java 11 wurde es dank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 328</a> auf Open Source √ºbertragen)</em> .  Obwohl JDK 11 elf √Ñnderungen weniger als in JDK 10 gefunden hat, kann man mit Recht sagen, dass JDK 11 definitiv auf JVM-Ebene um mehr Funktionen erweitert wurde. </p><a name="habracut"></a><br><h3 id="novye-zametnye-dlya-razrabotchika-fichi">  Neue Funktionen, die f√ºr den Entwickler erkennbar sind </h3><br><p>  JDK 11 enth√§lt einige √Ñnderungen, die sich auf den Entwicklungsstil auswirken k√∂nnen.  Es gibt eine geringf√ºgige √Ñnderung der Syntax, viele neue APIs und die M√∂glichkeit, Anwendungen in einer Datei ohne Verwendung eines Compilers auszuf√ºhren ( <em>Hinweis√ºbersetzer: sogenannte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shebang-Dateien</a></em> ).  Dar√ºber hinaus ist die gro√üe (und <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wichtige</a></strong> ) √Ñnderung das Entfernen des Aggregationsmoduls <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">java.se.ee</a></strong> , das sich auf die Migration einer vorhandenen Anwendung auf JDK 11 auswirken kann. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 323: Syntax lokaler Variablen f√ºr Lambda-Parameter</a></strong> </p><br><p>  In JDK 10 wurde die lokale Variableninferenz (oder Typinferenz) eingef√ºhrt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 286</a> ).  Dies vereinfacht den Code, da Sie den Typ der lokalen Variablen nicht mehr explizit angeben m√ºssen, sondern stattdessen <strong>var</strong> verwenden k√∂nnen.  JEP 323 erweitert die Verwendung dieser Syntax, die jetzt auch auf die Parameter von Lambda-Ausdr√ºcken anwendbar ist.  Ein einfaches Beispiel: </p><br><pre><code class="java hljs">list.stream() .map((<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s) -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p>  Ein aufmerksamer Java-Programmierer w√ºrde angeben, dass Lambda-Ausdr√ºcke bereits Typinferenz haben, sodass die Verwendung von var (in diesem Fall) redundant w√§re.  Wir k√∂nnten genauso gut den gleichen Code schreiben wie: </p><br><pre> <code class="java hljs"> list.stream() .map(s -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p>  Warum Var-Unterst√ºtzung hinzuf√ºgen?  Die Antwort ist ein Sonderfall - wenn Sie einem Lambda-Parameter eine Anmerkung hinzuf√ºgen m√∂chten.  Dies kann nicht ohne irgendeine Beteiligung geschehen.  Um die Verwendung eines expliziten Typs zu vermeiden, k√∂nnen wir var verwenden, um die Dinge auf folgende Weise zu vereinfachen: </p><br><pre> <code class="java hljs"> list.stream() .map((<span class="hljs-meta"><span class="hljs-meta">@Notnull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s) -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p>  Diese √Ñnderung erforderte √Ñnderungen an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Java Language Specification (JLS)</a> , insbesondere: </p><br><p>  Seite 24: Die Beschreibung der var-Spezialkennung. <br>  Seite 627-630: Lambda-Parameter <br>  Seite 636: Laufzeitauswertung von Lambda-Ausdr√ºcken <br>  Seite 746: Lambda-Syntax </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 330: Starten von Single-File-Quellcode-Programmen</a></strong> </p><br><p>  Eine der Kritikpunkte an Java ist die Redundanz der Syntax, und die ‚ÄûZeremonie‚Äú, die mit dem Starten selbst einer trivialen Anwendung verbunden ist, kann die Einstiegsschwelle f√ºr Anf√§nger erheblich erh√∂hen.  Um eine Anwendung zu schreiben, die einfach "Hello World!" Druckt, m√ºssen Sie eine Klasse mit der √∂ffentlichen statischen void main-Methode schreiben und die System.out.println () -Methode verwenden.  Anschlie√üend m√ºssen Sie den Code mit javac kompilieren.  Schlie√ülich k√∂nnen Sie eine Anwendung starten, die die Welt willkommen hei√üt.  Das Ausf√ºhren des gleichen Skripts in den meisten modernen Sprachen ist viel einfacher und schneller. </p><br><p>  JEP 330 macht das Kompilieren einer Einzeldateianwendung √ºberfl√ºssig.  Geben Sie jetzt einfach ein: </p><br><pre> <code class="java hljs"> java HelloWorld.java</code> </pre> <br><p>  Der Java-Launcher erkennt, dass die Datei den Java-Quellcode enth√§lt, und kompiliert den Code vor der Ausf√ºhrung in eine * .class-Datei. </p><br><p>  Nach dem Namen der Quelldatei platzierte Argumente werden beim Start der Anwendung als Argumente √ºbergeben.  Argumente, die vor dem Namen der Quelldatei stehen, werden nach dem Kompilieren des Codes als Argumente an den Java-Launcher √ºbergeben (auf diese Weise k√∂nnen Sie beispielsweise den Klassenpfad in der Befehlszeile festlegen).  Argumente, die sich auf den Compiler beziehen (z. B. Klassenpfad), werden ebenfalls zur Kompilierung an javac √ºbergeben. </p><br><p>  Ein Beispiel: </p><br><pre> <code class="java hljs"> java -classpath /home/foo/java Hello.java Bonjour</code> </pre> <br><p>  Es entspricht: </p><br><pre> <code class="java hljs"> javac -classpath /home/foo/java Hello.java java -classpath /home/foo/java Hello Bonjour</code> </pre> <br><p>  Dieses JEP bietet auch Unterst√ºtzung f√ºr Shebang-Dateien.  Um zu vermeiden, dass der Java-Launcher in der Befehlszeile erw√§hnt werden muss, k√∂nnen Sie ihn in die erste Zeile der Quelldatei aufnehmen.  Zum Beispiel: </p><br><pre> <code class="java hljs"> #!/usr/bin/java --source <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloWorld</span></span></span><span class="hljs-class"> </span></span>{ ...</code> </pre> <br><p>  Das Flag -source mit der verwendeten Java-Version ist erforderlich. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 321: HTTP-Client (Standard)</a></strong> </p><br><p>  JDK 9 f√ºhrte eine neue API zur Unterst√ºtzung des HTTP-Client-Protokolls ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 110</a> ) ein.  Da JDK 9 das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Platform Module System (JPMS) bereitstellte</a> , wurde diese API als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inkubatormodul aufgenommen</a> .  Inkubatormodule bieten neue APIs, machen sie jedoch nicht zum Java SE-Standard.  Entwickler k√∂nnen die API testen, indem sie Feedback geben.  Nach den erforderlichen √Ñnderungen (diese API wurde in JDK 10 aktualisiert) kann die API auf das Hauptmodul √ºbertragen werden, um Teil des Standards zu werden. </p><br><p>  Die HTTP-Client-API ist jetzt Teil des Java SE 11-Standards. Damit wird ein neues Modul und Paket f√ºr das JDK, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://download.java.net/java/early_access/jdk11/docs/api/java.net.">java.net.http, eingef√ºhrt</a> .  Hauptklassen: </p><br><ul><li>  Httpclient </li><li>  Httprequest </li><li>  HttpResponse </li><li>  Web-Socket </li></ul><br><p>  Die API kann synchron oder asynchron verwendet werden.  Im asynchronen Modus werden CompletionFutures und CompletionStages verwendet. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 320: Entfernen Sie die Java EE- und CORBA-Module</a></strong> </p><br><p>  Mit der Einf√ºhrung von JPMS in JDK 9 war es m√∂glich, die monolithische Datei rt.jar in mehrere Module aufzuteilen.  Ein zus√§tzlicher Vorteil von JPMS besteht darin, dass Sie jetzt eine Java-Laufzeitumgebung erstellen k√∂nnen, die nur die f√ºr Ihre Anwendung erforderlichen Module enth√§lt, wodurch die Gesamtgr√∂√üe erheblich reduziert wird.  Mit klar definierten Grenzen lassen sich veraltete Module jetzt einfacher aus der Java-API entfernen.  Dies ist, was dieser JEP tut;  Das Metamodul java.se.ee enth√§lt sechs Module, die nicht mehr Teil des Java SE 11-Standards sind und nicht im JDK enthalten sind. </p><br><p>  Remote-Module: </p><br><ul><li>  corba ( <em>Anmerkung des √úbersetzers:</em> <del>  <em>Ruhe in Frieden</em> </del>  <em>in der H√∂lle brennen</em> ) </li><li>  Transaktion </li><li>  Aktivierung </li><li>  xml.bind </li><li>  xml.ws </li><li>  xml.ws.annotation </li></ul><br><p>  Diese Module sind seit JDK 9 als veraltet (@Deprecated) markiert und wurden standardm√§√üig nicht in die Kompilierung oder Laufzeit einbezogen.  Wenn Sie versucht h√§tten, eine Anwendung mithilfe der API aus diesen Modulen in JDK 9 oder JDK 10 zu kompilieren oder auszuf√ºhren, w√§ren Sie gescheitert.  Wenn Sie die API dieser Module in Ihrem Code verwenden, m√ºssen Sie sie als separates Modul oder Bibliothek bereitstellen.  Den Bewertungen nach zu urteilen, scheinen die java.xml-Module, die Teil der Unterst√ºtzung von JAX-WS, SOAP-Webdiensten sind, die meisten Probleme zu verursachen. </p><br><h3 id="novyy-publichnyy-api">  Neue √∂ffentliche API </h3><br><p>  Viele der neuen APIs in JDK 11 sind das Ergebnis der Tatsache, dass das HTTP-Client-Modul jetzt Teil des Standards ist, sowie der Integration von Flight Recorder. </p><br><p>  Eine vollst√§ndige schematische Liste der API-√Ñnderungen, einschlie√ülich eines Vergleichs verschiedener Versionen des JDK, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">finden Sie hier.</a> </p><br><p>  Hier sind alle neuen Methoden aufgef√ºhrt, die nicht in den Modulen java.net.http und jdk.jfr enthalten sind.  Ebenfalls nicht aufgef√ºhrt sind die neuen Methoden und Klassen in den Modulen java.security, die f√ºr √Ñnderungen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 324</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 329</a> sehr spezifisch sind (es gibt sechs neue Klassen und acht neue Methoden). </p><br><h4 id="javaiobytearrayoutputstream">  java.io.ByteArrayOutputStream </h4><br><ul><li>  <strong>void writeBytes (byte [])</strong> : Schreibt alle Bytes aus dem Argument in OutputStream </li></ul><br><h4 id="javaiofilereader">  java.io.FileReader </h4><br><p>  Zwei neue Konstruktoren, mit denen Sie einen Zeichensatz angeben k√∂nnen. </p><br><h4 id="javaiofilewriter">  java.io.FileWriter </h4><br><p>  Vier neue Konstruktoren, mit denen Sie einen Zeichensatz angeben k√∂nnen. </p><br><h4 id="javaioinputstream">  java.io.InputStream </h4><br><ul><li>  <strong>io.InputStream nullInputStream ()</strong> : <strong>Gibt</strong> einen InputStream zur√ºck, der keine Bytes liest.  Bei Betrachtung dieser Methode (und der in OutputStream, Reader und Writer) stellt sich die Frage, warum sie n√ºtzlich sein k√∂nnte.  Sie k√∂nnen sie sich als <strong>/ dev / null</strong> vorstellen, um nicht ben√∂tigte Ausgaben zu verwerfen oder Eingaben bereitzustellen, die immer Null-Bytes zur√ºckgeben. </li></ul><br><h4 id="javaiooutputstream">  java.io.OutputStream </h4><br><ul><li>  <strong>io.OutputStream nullOutputStream ()</strong> </li></ul><br><h4 id="javaioreader">  java.io.Reader </h4><br><ul><li>  <strong>io.Reader nullReader ()</strong> </li></ul><br><h4 id="javaiowriter">  java.io.Writer </h4><br><ul><li>  <strong>io.Writer nullWriter ()</strong> </li></ul><br><h4 id="javalangcharacter">  java.lang.Character </h4><br><ul><li>  <strong>String toString (int)</strong> : Dies ist eine √ºberladene Form einer vorhandenen Methode, aber int wird anstelle von char verwendet.  Int ist der Unicode-Codepunkt. </li></ul><br><h4 id="javalangcharsequence">  java.lang.CharSequence </h4><br><ul><li>  <strong>int compare (CharSequence, CharSequence)</strong> : Vergleicht zwei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lexikografische</a> Instanzen von CharSequence.  Gibt einen negativen Wert, Null oder einen positiven Wert zur√ºck, wenn die erste Sequenz lexikographisch kleiner, gleich oder gr√∂√üer als die zweite ist. </li></ul><br><h4 id="javalangrefreference">  java.lang.ref.Reference </h4><br><ul><li>  <strong>lang.Object clone ()</strong> : Ich muss zugeben, diese √Ñnderung <strong>sorgt</strong> f√ºr Verwirrung.  Die Reference-Klasse implementiert die klonbare Schnittstelle nicht, und diese Methode l√∂st eine CloneNotSupportedException aus.  Es muss einen Grund f√ºr seine Aufnahme geben, vielleicht f√ºr etwas in der Zukunft.  ( <em>Anmerkung des √úbersetzers: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es gibt eine Diskussion √ºber StackOverflow</a> , ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ticket in OpenJDK.</a></em> ) </li></ul><br><h4 id="javalangruntime">  java.lang.Runtime </h4><br><h4 id="javalangsystem">  java.lang.System </h4><br><p>  Es gibt hier keine neuen Methoden, aber es ist erw√§hnenswert, dass die <strong>runFinalizersOnExit ()</strong> -Methode jetzt aus beiden Klassen entfernt wurde (bei der Migration auf JDK 11 kann ein Problem auftreten). </p><br><h4 id="javalangstring">  java.lang.String </h4><br><p>  Ich denke, dies ist eines der Highlights der neuen APIs in JDK 11. Hier gibt es einige n√ºtzliche neue Methoden. </p><br><ul><li>  <strong>boolean isBlank ()</strong> : <strong>Gibt</strong> true zur√ºck, wenn die Zeichenfolge leer ist oder nur Leerzeichen enth√§lt, andernfalls false. </li><li>  <strong>Stream lines ()</strong> : Gibt Stream from String zur√ºck, der aus diesem String extrahiert und durch Zeilentrennzeichen getrennt wurde. </li><li>  <strong>String repeat (int)</strong> : Gibt einen String zur√ºck, dessen Wert die Verkettung dieses Strings ist, der mehrmals wiederholt wird. </li><li>  <strong>String strip ()</strong> : Gibt einen String zur√ºck, dessen Wert dieser String ist. Dadurch werden alle Leerzeichen am Anfang und Ende des Strings entfernt. </li><li>  <strong>String stripLeading ()</strong> : <strong>Gibt</strong> einen String zur√ºck, dessen Wert dieser String ist, w√§hrend alle Leerzeichen am Zeilenanfang entfernt werden. </li><li>  <strong>String stripTrailing ()</strong> : <strong>Gibt</strong> einen String zur√ºck, dessen Wert dieser <strong>String ist. Dadurch werden</strong> alle Leerzeichen am Ende des Strings entfernt. </li></ul><br><p>  H√∂chstwahrscheinlich schauen Sie sich <strong>strip () an</strong> und fragen: "Wie unterscheidet sich das von der vorhandenen <strong>trim ()</strong> -Methode?"  Die Antwort liegt in der unterschiedlichen Definition von R√§umen.  ( <em>Anmerkung des √úbersetzers: Kurz gesagt, <strong>strip ()</strong> versteht Unicode besser, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">detaillierte Analyse auf StackOverflow</a></em> ) </p><br><h4 id="javalangstringbuffer">  java.lang.StringBuffer </h4><br><h4 id="javalangstringbuilder">  java.lang.StringBuilder </h4><br><p>  Beide Klassen haben eine neue <strong>compareTo ()</strong> -Methode, die einen StringBuffer / StringBuilder verwendet und einen int zur√ºckgibt.  Die lexikalische Vergleichsmethode √§hnelt der neuen <strong>compareTo ()</strong> -Methode in CharSequence. </p><br><h4 id="javalangthread">  java.lang.Thread </h4><br><p>  Keine neuen Methoden.  Die <strong>Methoden</strong> <strong>destroy ()</strong> und <strong>stop (Throwable)</strong> wurden entfernt.  Die <strong>stop ()</strong> -Methode, die keine Argumente akzeptiert, ist noch vorhanden.  Kann zu einem Kompatibilit√§tsproblem f√ºhren. </p><br><h4 id="javaniobytebuffer">  java.nio.ByteBuffer </h4><br><h4 id="javaniocharbuffer">  java.nio.CharBuffer </h4><br><h4 id="javaniodoublebuffer">  java.nio.DoubleBuffer </h4><br><h4 id="javaniofloatbuffer">  java.nio.FloatBuffer </h4><br><h4 id="javaniolongbuffer">  java.nio.LongBuffer </h4><br><h4 id="javanioshortbuffer">  java.nio.ShortBuffer </h4><br><p>  Alle diese Klassen haben jetzt die Methode <strong>mismatch ()</strong> , die den relativen Index der ersten Nicht√ºbereinstimmung zwischen diesem Puffer und dem √ºbergebenen Puffer findet und zur√ºckgibt. </p><br><h4 id="javaniochannelsselectionkey">  java.nio.channels.SelectionKey </h4><br><ul><li>  <strong>int InterestOpsAnd (int)</strong> : Legt das Interesse dieses Schl√ºssels (das Interesse des Schl√ºssels <strong>)</strong> atomar an der bitweisen Schnittmenge ("und") der vorhandenen Interessengruppe und des √ºbergebenen Werts fest. </li><li>  <strong>int InterestOpsOr (int)</strong> : Legt das Interesse dieses Schl√ºssels (das Interesse des Schl√ºssels <strong>)</strong> atomar an der bitweisen Vereinigung ("oder") der vorhandenen Interessengruppe und des √ºbergebenen Werts fest. </li></ul><br><h4 id="javaniochannelsselector">  java.nio.channels.Selector </h4><br><ul><li>  <strong>int select (java.util.function.Consumer, long)</strong> : W√§hlen Sie Aktionen f√ºr Tasten aus und f√ºhren Sie sie aus, deren entsprechende Kan√§le f√ºr E / A-Vorg√§nge bereit sind.  langes Argument ist eine Auszeit. </li><li>  <strong>int select (java.util.function.Consumer)</strong> : wie oben, jedoch ohne Zeit√ºberschreitung. </li><li>  <strong>int selectNow (java.util.function.Consumer)</strong> : wie oben, nur nicht blockierend. </li></ul><br><h4 id="javaniofilefiles">  java.nio.file.Files </h4><br><ul><li>  <strong>String readString (Pfad)</strong> : Liest den gesamten Inhalt einer Datei in einen String und decodiert mithilfe der UTF-8-Codierung von Bytes in Zeichen. </li><li>  <strong>String readString (Pfad, Zeichensatz)</strong> : Wie oben angegeben, mit dem Unterschied, dass die Dekodierung von Bytes zu Zeichen mit dem angegebenen Zeichensatz erfolgt. </li><li>  <strong>Pfad writeString (Pfad, CharSequence, java.nio.file.OpenOption [])</strong> : Schreiben Sie CharSequence in eine Datei.  Zeichen werden mithilfe der UTF-8-Codierung in Bytes codiert. </li><li>  <strong>Pfad writeString (Pfad, CharSequence, java.nio.file.Charset, OpenOption [])</strong> : Wie oben werden Zeichen in Bytes mit der in Zeichensatz angegebenen Codierung codiert. </li></ul><br><h4 id="javaniofilepath">  java.nio.file.Path </h4><br><ul><li>  <strong>Pfad von (String, String [])</strong> : Gibt den Pfad aus dem String-Argument des Pfads oder der Folge von Strings zur√ºck, die zusammen die Pfadzeichenfolge bilden. </li><li>  <strong>Pfad von (net.URI)</strong> : <strong>Gibt den</strong> Pfad von der URI zur√ºck. </li></ul><br><h4 id="javautilcollection">  java.util.Collection </h4><br><ul><li>  <strong>Object [] toArray (java.util.function.IntFunction)</strong> : <strong>Gibt</strong> ein Array zur√ºck, das alle Elemente in dieser Auflistung enth√§lt. Verwenden Sie dazu die bereitgestellte Generierungsfunktion, um das zur√ºckgegebene Array zuzuweisen. </li></ul><br><h4 id="javautilconcurrentpriorityblockingqueue">  java.util.concurrent.PriorityBlockingQueue </h4><br><h4 id="javautilpriorityqueue">  java.util.PriorityQueue </h4><br><ul><li>  <strong>void forEach (java.util.function.Consumer)</strong> : F√ºhrt die √ºbergebene Aktion f√ºr jedes Iterable-Element aus, bis alle Elemente verarbeitet wurden oder die Aktion eine Ausnahme ausl√∂st. </li><li>  <strong>boolean removeAll (java.util.Collection)</strong> : <strong>Entfernt</strong> alle Elemente dieser Sammlung, die auch in der angegebenen Sammlung enthalten sind (optionale Operation). </li><li>  <strong>boolean removeIf (java.util.function.Predicate)</strong> : Entfernt alle Elemente aus dieser Sammlung, die das angegebene Pr√§dikat erf√ºllen. </li><li>  <strong>boolean keepAll (java.util.Collection)</strong> : Speichert nur die Elemente in dieser Sammlung, die in der √ºbertragenen Sammlung enthalten sind (optionale Operation). </li></ul><br><h4 id="javautilconcurrenttimeunit">  java.util.concurrent.TimeUnit </h4><br><ul><li>  <strong>long convert (java.time.Duration)</strong> : konvertiert die √ºbergebene Duration in diesen Typ. </li></ul><br><h4 id="javautilfunctionpredicate">  java.util.function.Predicate </h4><br><ul><li>  <strong>Pr√§dikat nicht (Pr√§dikat)</strong> : Gibt das Pr√§dikat zur√ºck, bei dem es sich um die Negation des √ºbertragenen Pr√§dikats handelt. </li></ul><br><p>  Dies ist eine meiner neuen Lieblings-APIs in JDK 11. Als Beispiel k√∂nnen Sie diesen Code konvertieren: </p><br><pre> <code class="java hljs"> lines.stream() .filter(s -&gt; !s.isBlank())</code> </pre> <br><p>  in </p><br><pre> <code class="java hljs"> lines.stream() .filter(Predicate.not(String::isBlank))</code> </pre> <br><p>  oder wenn wir statische Importe verwenden: </p><br><pre> <code class="java hljs"> lines.stream() .filter(not(String::isBlank))</code> </pre> <br><p>  Pers√∂nlich glaube ich, dass diese Version verst√§ndlicher und pr√§gnanter ist. </p><br><h4 id="javautiloptional">  java.util.Optional </h4><br><h4 id="javautiloptionalint">  java.util.OptionalInt </h4><br><h4 id="javautiloptionaldouble">  java.util.OptionalDouble </h4><br><h4 id="javautiloptionallong">  java.util.OptionalLong </h4><br><ul><li>  <strong>boolean isEmpty ()</strong> : Wenn kein Wert vorhanden ist, wird true zur√ºckgegeben, andernfalls false. </li></ul><br><h4 id="javautilregexpattern">  java.util.regex.Pattern </h4><br><ul><li>  <strong>Pr√§dikat asMatchPredicate ()</strong> : Ich denke, es k√∂nnte das Juwel der neuen JDK 11-API sein. Erstellt ein Pr√§dikat, das pr√ºft, ob diese Vorlage mit der angegebenen Eingabezeichenfolge √ºbereinstimmt. </li></ul><br><h4 id="javautilzipdeflater">  java.util.zip.Deflater </h4><br><ul><li><p>  <strong>int deflate (ByteBuffer)</strong> : Komprimiert die Eingabe und f√ºllt den angegebenen Puffer damit. </p><br></li><li><p>  <strong>int deflate (ByteBuffer, int)</strong> : Komprimiert die Eingabe und f√ºllt den angegebenen Puffer damit.  Gibt die tats√§chliche Menge der komprimierten Daten zur√ºck. </p><br></li><li><p>  <strong>void setDictionary (ByteBuffer)</strong> : Legt das angegebene W√∂rterbuch f√ºr die Komprimierung auf Bytes in diesem Puffer fest.  Dies ist eine √ºberladene Form einer vorhandenen Methode, die ein ByteBuffer jetzt akzeptieren kann, anstatt eines Byte-Arrays. </p><br></li><li><p>  <strong>void setInput (ByteBuffer)</strong> : Legt die zu komprimierende Eingabe fest.  Auch eine √ºberladene Form einer vorhandenen Methode. </p><br></li></ul><br><h4 id="javautilzipinflater">  java.util.zip.Inflater </h4><br><ul><li>  <strong>int inflate (ByteBuffer)</strong> : Dekomprimiert Bytes in den angegebenen Puffer.  Gibt die tats√§chliche Anzahl entpackter Bytes zur√ºck. </li><li>  <strong>void setDictionary (ByteBuffer)</strong> : Setzt das angegebene W√∂rterbuch auf Bytes in diesem Puffer.  Die √ºberladene Form einer vorhandenen Methode. </li><li>  <strong>void setInput (ByteBuffer)</strong> : Legt die Eingabe f√ºr die Dekomprimierung fest.  Die √ºberladene Form einer vorhandenen Methode. </li></ul><br><h4 id="javaxprintattributestandarddialogowner">  javax.print.attribute.standard.DialogOwner </h4><br><p>  Dies ist eine neue Klasse in JDK 11. Wird verwendet, um eine Anforderung f√ºr einen Druckdialog oder eine Seiteneinrichtung zu unterst√ºtzen.  Muss √ºber allen Fenstern oder einem bestimmten Fenster angezeigt werden. </p><br><h4 id="javaxswingdefaultcomboboxmodel">  javax.swing.DefaultComboBoxModel </h4><br><h4 id="javaxswingdefaultlistmodel">  javax.swing.DefaultListModel </h4><br><ul><li>  <strong>void addAll (Sammlung)</strong> : <strong>F√ºgt</strong> alle in der Sammlung vorhandenen Elemente hinzu. </li><li>  <strong>void addAll (int, Collection)</strong> : <strong>F√ºgt</strong> alle in der Sammlung vorhandenen Elemente ab dem angegebenen Index hinzu. </li></ul><br><h4 id="javaxswinglistselectionmodel">  javax.swing.ListSelectionModel </h4><br><ul><li>  <strong>int [] getSelectedIndices ()</strong> : Gibt ein Array aller ausgew√§hlten Indizes im ausgew√§hlten Modell in aufsteigender Reihenfolge zur√ºck. </li><li>  <strong>int getSelectedItemsCount ()</strong> : Gibt die Anzahl der ausgew√§hlten Elemente zur√ºck. </li></ul><br><h4 id="jdkjshellevalexception">  jdk.jshell.EvalException </h4><br><ul><li>  <strong>jshell.JShellException getCause ()</strong> : <strong>Gibt einen ausl√∂sbaren</strong> Ursachen-Wrapper im Ausf√ºhrungsclient zur√ºck, der durch eine EvalException dargestellt wird, oder null, wenn die Ursache nicht vorhanden oder unbekannt ist. </li></ul><br><h3 id="novye-fichi-ne-publichnyy-api">  Neue Funktionen (keine √∂ffentliche API) </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 181: Nestbasierte Zugriffskontrolle</a> </p><br><p>  Java (und andere Sprachen) unterst√ºtzt verschachtelte Klassen durch innere Klassen.  F√ºr die korrekte Operation muss der Compiler einige Tricks ausf√ºhren.  Zum Beispiel: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerInt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printOuterInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Outer int = "</span></span> + outerInt); } } }</code> </pre> <br><p>  Der Compiler √§ndert dies, um vor dem Kompilieren Folgendes zu erstellen: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerInt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> access$<span class="hljs-number"><span class="hljs-number">000</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outerInt; } }</code> </pre> <br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class">$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ Outer outer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printOuterInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Outer int = "</span></span> + outer.access$<span class="hljs-number"><span class="hljs-number">000</span></span>()); } }</code> </pre> <br><p>  Obwohl die innere Klasse logischerweise Teil desselben Codes wie die √§u√üere Klasse ist, wird sie als separate Klasse kompiliert.  Dies erfordert daher eine synthetische Methode ("Br√ºcke"), die vom Compiler erstellt werden muss, um Zugriff auf das private Feld der externen Klasse zu erhalten. </p><br><p>  Dieser JEP stellt das Konzept eines ‚ÄûSockets‚Äú dar, bei dem zwei Mitglieder desselben Sockets (au√üen und innen aus unserem Beispiel) Nachbarn sind.  Im Dateiformat * .class wurden zwei neue Attribute hinzugef√ºgt: NestHost und NestMembers.  Diese √Ñnderungen sind auch f√ºr andere mit Bytecode kompilierte Sprachen n√ºtzlich, die verschachtelte Klassen unterst√ºtzen. </p><br><p>  Diese Funktion bietet drei neue Methoden f√ºr java.lang.Class: </p><br><ul><li>  <strong>Klasse getNestHost ()</strong> </li><li>  <strong>Klasse [] getNestMembers ()</strong> </li><li>  <strong>boolean isNestmateOf (clazz)</strong> </li></ul><br><p>  Diese Funktion erforderte auch √Ñnderungen an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Java Virtual Machine Specification (JVMS)</a> , insbesondere in Abschnitt 5.4.4 Zugriffssteuerung. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 309: Dynamische Klassendateikonstanten</a></strong> </p><br><p>  Dieser JEP beschreibt die Erweiterung des Dateiformats * .class, um das neue Formular mit dem konstanten Pool CONSTANT_Dynamic (in Pr√§sentationen h√§ufig als condy bezeichnet) zu unterst√ºtzen.  Die Idee einer dynamischen Konstante scheint ein Oxymoron zu sein, aber tats√§chlich kann man sie sich als endg√ºltigen Wert in Java vorstellen.  Der Wert des Konstantenpools wird nicht in der Kompilierungsphase festgelegt (im Gegensatz zu anderen Konstanten), aber die Bootstrap-Methode wird verwendet, um den Wert zur Laufzeit zu bestimmen.  Daher ist der Wert dynamisch, aber da sein Wert nur einmal festgelegt wird, ist er auch konstant. </p><br><p>  Diese Funktion ist vor allem f√ºr diejenigen n√ºtzlich, die neue Sprachen und Compiler entwickeln.  Wer generiert den Bytecode und die * .class-Dateien, um sie auf der JVM auszuf√ºhren?  Dies vereinfacht einige Aufgaben. </p><br><p>  Diese Funktion bietet eine neue Klasse java.lang.invoke.ConstantBootstraps mit neun neuen Methoden.  Ich werde sie hier nicht alle auflisten;  Dies sind Bootstrap-Methoden f√ºr dynamisch berechnete Konstanten. </p><br><p>  Diese Funktion erforderte √Ñnderungen am JVMS, insbesondere hinsichtlich der Verwendung des speziellen Aufrufbytecodes und von Abschnitt 4.4 des Konstantenpools. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 315: Verbessern Sie Aarch64 Intrinsics</a></strong> </p><br><p>  Dies war der JEP von Red Hat.  Die JVM kann jetzt speziellere Anweisungen verwenden, die im Befehlssatz von Arm 64 verf√ºgbar sind. Dies verbessert insbesondere die Funktionsweise der Methoden sin (), cos () und log () der Klasse java.lang.Math. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 318: Der Epsilon Garbage Collector</a></strong> </p><br><p>  Red Hat hat ebenfalls zu diesem JEP beigetragen.  Der Epsilon-M√ºllsammler ist etwas ungew√∂hnlich, da er keinen M√ºll sammelt!  Bei der Erstellung neuer Objekte wird bei Bedarf neuer Speicher zugewiesen, der von Objekten ohne Verkn√ºpfungen belegte Speicherplatz wird jedoch nicht freigegeben. </p><br><p>  Es scheint also, worum geht es?  Es gibt mindestens zwei Verwendungszwecke: </p><br><ul><li>  Zun√§chst soll dieser Kollektor sicherstellen, dass neue GC-Algorithmen hinsichtlich ihrer Auswirkungen auf die Leistung bewertet werden.  Die Idee ist, eine Beispielanwendung mit Epsilon GC auszuf√ºhren und eine Metrik zu generieren.  Ein neuer GC-Algorithmus ist enthalten, die gleichen Tests werden ausgef√ºhrt und die Ergebnisse werden verglichen. </li><li>  F√ºr sehr kurze oder kurzlebige Aufgaben (denken Sie an eine serverlose Funktion in der Cloud), bei der Sie sicherstellen k√∂nnen, dass Sie den dem Heap-Speicher zugewiesenen Speicher nicht √ºberschreiten.  Dies kann die Leistung verbessern, indem der Overhead (einschlie√ülich der Erfassung von Statistiken, die zur Entscheidung √ºber die Ausf√ºhrung des Kollektors erforderlich sind) im Anwendungscode entf√§llt. </li></ul><br><p>  Wenn der Heap-Speicherplatz ersch√∂pft ist, kann der nachfolgende JVM-Betrieb auf drei Arten konfiguriert werden: </p><br><ul><li>  Ein regul√§rer OutOfMemoryError wird aufgerufen. </li><li>  Heap zur√ºcksetzen </li><li>  Es ist schwierig, die JVM anzuhalten und m√∂glicherweise eine externe Aufgabe auszuf√ºhren (z. B. den Debugger zu starten). </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 324: Schl√ºsselvereinbarung mit Curve25519 und Curve448</strong></a> </p><br><p>  Kryptografische Standards √§ndern sich st√§ndig und verbessern sich.  In diesem Fall wird das vorhandene Diffie-Hellman-Schema mit einer elliptischen Kurve durch Curve25519 und Curve448 ersetzt.  Dies ist ein in RFC-7748 definiertes Schl√ºsselvereinbarungsschema. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 327: Unicode 10</strong></a> </p><br><p>  Die Java-Plattform unterst√ºtzt Unicode, um die Verarbeitung aller Zeichens√§tze zu erm√∂glichen.  Da Unicode auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 10</a> aktualisiert wurde, wurde auch das JDK aktualisiert, um diese Version des Standards zu unterst√ºtzen. </p><br><p>  Ich bin immer wieder gespannt, was Unicode-Entwickler in neuen Versionen enthalten.  Unicode 10 hat 8.518 neue Zeichen.  Dazu geh√∂ren das Bitcoin-Symbol, der N√ºshu-Zeichensatz (von chinesischen Frauen zum Schreiben von Gedichten verwendet) sowie der Soyombo- und der Zanabazar-Platz (die Zeichen, die in historischen buddhistischen Texten zum Schreiben von Sanskrit-, tibetischen und mongolischen Sprachen verwendet werden).  Viele andere Emoji wurden ebenfalls hinzugef√ºgt, einschlie√ülich des lang erwarteten (anscheinend) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colbert Emoji</a> . </p><br><p>  Denken Sie daran, dass Sie ab JDK 9 UTF-8 in Eigenschaftendateien (.properties) verwenden k√∂nnen.  Dies bedeutet, dass in solchen Dateien jedes Unicode-Zeichen verwendet werden kann.  Einschlie√ülich Emojis.  N√ºshu. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 328: Flight Recorder</strong></a> </p><br><p> Flight Recorder ‚Äî       JVM.  JDK 11        Oracle JDK. ,  Oracle     Oracle JDK  OpenJDK,      OpenJDK. </p><br><p> JEP    : </p><br><ul><li>  API        </li><li>        </li><li>      </li><li>    , JVM HotSpot   JDK </li></ul><br><p>      : jdk.jfr  jdk.management.jfr. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 329: ChaCha20 and Poly1305 Cryptographic Algorithms</strong></a> </p><br><p>  JEP 324,   ,  JDK.   ChaCha20  ChaCha20-Poly1305,    RFC 7539. ChaCha20 ‚Äî     ,    ,    RC4. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 331: Low-overhead Heap Profiling</strong></a> </p><br><p>  ,   JEP,   Google.          Java  JVM. </p><br><p>  : </p><br><ul><li>    ,       </li><li>       </li><li>     </li><li>        ( ,     GC   VM) </li><li>         Java. </li></ul><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 332: Transport Layer Security (TLS) 1.3</strong></a> </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TLS 1.3 (RFC 8446)</a>  " "  TLS            . JDK   ,      Datagram Transport Layer Security (DTLS). </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 333: ZGC A Scalable, Low Latency Garbage Collector</strong></a> </p><br><p>     ,     ,     ()    .      (  ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weak Generational Hypothesis</a> )    (  )  GC   .     ""  ,            .           . </p><br><p> ZGC ‚Äî region-based (  G1), NUMA aware  compacting  .      . </p><br><p>     pauseless     ,      C4   Zing JVM. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 335: Deprecate the Nashorn Scripting Engine</strong></a> </p><br><p> Nashorn    JDK 8     Rhino Javascript .    ,   Nashorn   API  jjs     Java.   ,   .     Graal VM   ,     ,  . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 336: Deprecate the Pack200 Tools and APIs</strong></a> </p><br><p> Pack200 ‚Äî     JAR-,     Java SE 5.0.   JPMS  JDK 9 Pack200       JDK.  pack200  unpack200  API Pack200  java.util.jar          JDK.   ,  . </p><br><h3 id="vyvody">  Schlussfolgerungen </h3><br><p> JDK 11 ‚Äî   LTS JDK (       ).   ,  ,   ,   ,  JVM   ,        . </p><br><p> Zulu  JDK 11  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>   ! </p><br><p>         JDK 11? </p><br><p> ( <em>. : ,         </em> ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424683/">https://habr.com/ru/post/de424683/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424673/index.html">CLRium # 4: .NET-Community-Meeting</a></li>
<li><a href="../de424675/index.html">Was passiert im Einzelhandel?</a></li>
<li><a href="../de424677/index.html">Eine kurze Geschichte der Zehnertastatur</a></li>
<li><a href="../de424679/index.html">Reparieren Sie wichtige Computer-Peripherieger√§te</a></li>
<li><a href="../de424681/index.html">Oktober IT Events Digest (Teil 1)</a></li>
<li><a href="../de424685/index.html">Die US-amerikanische B√∂rsenaufsichtsbeh√∂rde (Securities and Exchange Commission) reichte eine Klage gegen den Chef von Tesla Elon Musk ein, auch wegen Betrugs</a></li>
<li><a href="../de424687/index.html">Das sind die richtigen Bienen: mechanische Anpassung an dynamische Effekte</a></li>
<li><a href="../de424689/index.html">Die Kontrolle √ºber die Situation macht gl√ºcklich.</a></li>
<li><a href="../de424691/index.html">Wir laden Sie zur Konferenz Azov Developers Meetup 2018 - 13. Oktober in Taganrog ein</a></li>
<li><a href="../de424693/index.html">Hinzuf√ºgen eines Wasserzeichens zu allen Bildern der Site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>