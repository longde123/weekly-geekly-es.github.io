<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📖 🏈 ⚔️ 90 neue Funktionen (und APIs) in JDK 11 💅🏻 🚧 👩🏿‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich präsentiere Ihnen die Übersetzung des Artikels „ 90 neue Funktionen (und APIs) in JDK 11 “ von Simon Ritter. 





 Für viele bedeutet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>90 neue Funktionen (und APIs) in JDK 11</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424683/"><p>  Hallo Habr!  Ich präsentiere Ihnen die Übersetzung des Artikels „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">90 neue Funktionen (und APIs) in JDK 11</a> “ von Simon Ritter. </p><br><p><img src="https://habrastorage.org/webt/nz/8c/f_/nz8cf_erkk_q0xqhz_kptdl772s.jpeg"></p><br><p>  Für viele bedeutet der neue sechsmonatige JDK-Veröffentlichungszyklus, dass einige noch nicht herausgefunden haben, welche neuen Funktionen in JDK 10 enthalten sind, und JDK 11 kurz davor steht. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In einem der frühen Blogs</a> wurden alle 109 neuen Funktionen und APIs aufgelistet konnte in JDK 10 gefunden werden. Daher wurde für JDK 11 beschlossen, dasselbe zu tun.  Es wurde jedoch ein anderes Format gewählt.  Dieser Beitrag wird in zwei Abschnitte unterteilt: neue Funktionen, die Entwicklern zur Verfügung stehen (öffentliche API) und alles andere.  Wenn Sie also nur daran interessiert sind, was sich direkt auf Ihre Entwicklung auswirkt, können Sie den zweiten Teil überspringen. </p><br><p>  Die Gesamtzahl der Änderungen, die berechnet werden konnten, betrug 90 (dies ist JEP plus neue Klassen und Methoden, ausgenommen separate Methoden für den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://openjdk.java.net/groups/net/">HTTP-Client</a> und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flight Recorder</a> ) ( <em>Anmerkung des Übersetzers: Java Flight Recorder (JFR) war eines der in Oracle integrierten Add-Ons im JDK, aber ab Java 11 wurde es dank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 328</a> auf Open Source übertragen)</em> .  Obwohl JDK 11 elf Änderungen weniger als in JDK 10 gefunden hat, kann man mit Recht sagen, dass JDK 11 definitiv auf JVM-Ebene um mehr Funktionen erweitert wurde. </p><a name="habracut"></a><br><h3 id="novye-zametnye-dlya-razrabotchika-fichi">  Neue Funktionen, die für den Entwickler erkennbar sind </h3><br><p>  JDK 11 enthält einige Änderungen, die sich auf den Entwicklungsstil auswirken können.  Es gibt eine geringfügige Änderung der Syntax, viele neue APIs und die Möglichkeit, Anwendungen in einer Datei ohne Verwendung eines Compilers auszuführen ( <em>Hinweisübersetzer: sogenannte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shebang-Dateien</a></em> ).  Darüber hinaus ist die große (und <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wichtige</a></strong> ) Änderung das Entfernen des Aggregationsmoduls <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">java.se.ee</a></strong> , das sich auf die Migration einer vorhandenen Anwendung auf JDK 11 auswirken kann. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 323: Syntax lokaler Variablen für Lambda-Parameter</a></strong> </p><br><p>  In JDK 10 wurde die lokale Variableninferenz (oder Typinferenz) eingeführt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 286</a> ).  Dies vereinfacht den Code, da Sie den Typ der lokalen Variablen nicht mehr explizit angeben müssen, sondern stattdessen <strong>var</strong> verwenden können.  JEP 323 erweitert die Verwendung dieser Syntax, die jetzt auch auf die Parameter von Lambda-Ausdrücken anwendbar ist.  Ein einfaches Beispiel: </p><br><pre><code class="java hljs">list.stream() .map((<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s) -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p>  Ein aufmerksamer Java-Programmierer würde angeben, dass Lambda-Ausdrücke bereits Typinferenz haben, sodass die Verwendung von var (in diesem Fall) redundant wäre.  Wir könnten genauso gut den gleichen Code schreiben wie: </p><br><pre> <code class="java hljs"> list.stream() .map(s -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p>  Warum Var-Unterstützung hinzufügen?  Die Antwort ist ein Sonderfall - wenn Sie einem Lambda-Parameter eine Anmerkung hinzufügen möchten.  Dies kann nicht ohne irgendeine Beteiligung geschehen.  Um die Verwendung eines expliziten Typs zu vermeiden, können wir var verwenden, um die Dinge auf folgende Weise zu vereinfachen: </p><br><pre> <code class="java hljs"> list.stream() .map((<span class="hljs-meta"><span class="hljs-meta">@Notnull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s) -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p>  Diese Änderung erforderte Änderungen an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Java Language Specification (JLS)</a> , insbesondere: </p><br><p>  Seite 24: Die Beschreibung der var-Spezialkennung. <br>  Seite 627-630: Lambda-Parameter <br>  Seite 636: Laufzeitauswertung von Lambda-Ausdrücken <br>  Seite 746: Lambda-Syntax </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 330: Starten von Single-File-Quellcode-Programmen</a></strong> </p><br><p>  Eine der Kritikpunkte an Java ist die Redundanz der Syntax, und die „Zeremonie“, die mit dem Starten selbst einer trivialen Anwendung verbunden ist, kann die Einstiegsschwelle für Anfänger erheblich erhöhen.  Um eine Anwendung zu schreiben, die einfach "Hello World!" Druckt, müssen Sie eine Klasse mit der öffentlichen statischen void main-Methode schreiben und die System.out.println () -Methode verwenden.  Anschließend müssen Sie den Code mit javac kompilieren.  Schließlich können Sie eine Anwendung starten, die die Welt willkommen heißt.  Das Ausführen des gleichen Skripts in den meisten modernen Sprachen ist viel einfacher und schneller. </p><br><p>  JEP 330 macht das Kompilieren einer Einzeldateianwendung überflüssig.  Geben Sie jetzt einfach ein: </p><br><pre> <code class="java hljs"> java HelloWorld.java</code> </pre> <br><p>  Der Java-Launcher erkennt, dass die Datei den Java-Quellcode enthält, und kompiliert den Code vor der Ausführung in eine * .class-Datei. </p><br><p>  Nach dem Namen der Quelldatei platzierte Argumente werden beim Start der Anwendung als Argumente übergeben.  Argumente, die vor dem Namen der Quelldatei stehen, werden nach dem Kompilieren des Codes als Argumente an den Java-Launcher übergeben (auf diese Weise können Sie beispielsweise den Klassenpfad in der Befehlszeile festlegen).  Argumente, die sich auf den Compiler beziehen (z. B. Klassenpfad), werden ebenfalls zur Kompilierung an javac übergeben. </p><br><p>  Ein Beispiel: </p><br><pre> <code class="java hljs"> java -classpath /home/foo/java Hello.java Bonjour</code> </pre> <br><p>  Es entspricht: </p><br><pre> <code class="java hljs"> javac -classpath /home/foo/java Hello.java java -classpath /home/foo/java Hello Bonjour</code> </pre> <br><p>  Dieses JEP bietet auch Unterstützung für Shebang-Dateien.  Um zu vermeiden, dass der Java-Launcher in der Befehlszeile erwähnt werden muss, können Sie ihn in die erste Zeile der Quelldatei aufnehmen.  Zum Beispiel: </p><br><pre> <code class="java hljs"> #!/usr/bin/java --source <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloWorld</span></span></span><span class="hljs-class"> </span></span>{ ...</code> </pre> <br><p>  Das Flag -source mit der verwendeten Java-Version ist erforderlich. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 321: HTTP-Client (Standard)</a></strong> </p><br><p>  JDK 9 führte eine neue API zur Unterstützung des HTTP-Client-Protokolls ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 110</a> ) ein.  Da JDK 9 das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Platform Module System (JPMS) bereitstellte</a> , wurde diese API als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inkubatormodul aufgenommen</a> .  Inkubatormodule bieten neue APIs, machen sie jedoch nicht zum Java SE-Standard.  Entwickler können die API testen, indem sie Feedback geben.  Nach den erforderlichen Änderungen (diese API wurde in JDK 10 aktualisiert) kann die API auf das Hauptmodul übertragen werden, um Teil des Standards zu werden. </p><br><p>  Die HTTP-Client-API ist jetzt Teil des Java SE 11-Standards. Damit wird ein neues Modul und Paket für das JDK, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://download.java.net/java/early_access/jdk11/docs/api/java.net.">java.net.http, eingeführt</a> .  Hauptklassen: </p><br><ul><li>  Httpclient </li><li>  Httprequest </li><li>  HttpResponse </li><li>  Web-Socket </li></ul><br><p>  Die API kann synchron oder asynchron verwendet werden.  Im asynchronen Modus werden CompletionFutures und CompletionStages verwendet. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 320: Entfernen Sie die Java EE- und CORBA-Module</a></strong> </p><br><p>  Mit der Einführung von JPMS in JDK 9 war es möglich, die monolithische Datei rt.jar in mehrere Module aufzuteilen.  Ein zusätzlicher Vorteil von JPMS besteht darin, dass Sie jetzt eine Java-Laufzeitumgebung erstellen können, die nur die für Ihre Anwendung erforderlichen Module enthält, wodurch die Gesamtgröße erheblich reduziert wird.  Mit klar definierten Grenzen lassen sich veraltete Module jetzt einfacher aus der Java-API entfernen.  Dies ist, was dieser JEP tut;  Das Metamodul java.se.ee enthält sechs Module, die nicht mehr Teil des Java SE 11-Standards sind und nicht im JDK enthalten sind. </p><br><p>  Remote-Module: </p><br><ul><li>  corba ( <em>Anmerkung des Übersetzers:</em> <del>  <em>Ruhe in Frieden</em> </del>  <em>in der Hölle brennen</em> ) </li><li>  Transaktion </li><li>  Aktivierung </li><li>  xml.bind </li><li>  xml.ws </li><li>  xml.ws.annotation </li></ul><br><p>  Diese Module sind seit JDK 9 als veraltet (@Deprecated) markiert und wurden standardmäßig nicht in die Kompilierung oder Laufzeit einbezogen.  Wenn Sie versucht hätten, eine Anwendung mithilfe der API aus diesen Modulen in JDK 9 oder JDK 10 zu kompilieren oder auszuführen, wären Sie gescheitert.  Wenn Sie die API dieser Module in Ihrem Code verwenden, müssen Sie sie als separates Modul oder Bibliothek bereitstellen.  Den Bewertungen nach zu urteilen, scheinen die java.xml-Module, die Teil der Unterstützung von JAX-WS, SOAP-Webdiensten sind, die meisten Probleme zu verursachen. </p><br><h3 id="novyy-publichnyy-api">  Neue öffentliche API </h3><br><p>  Viele der neuen APIs in JDK 11 sind das Ergebnis der Tatsache, dass das HTTP-Client-Modul jetzt Teil des Standards ist, sowie der Integration von Flight Recorder. </p><br><p>  Eine vollständige schematische Liste der API-Änderungen, einschließlich eines Vergleichs verschiedener Versionen des JDK, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">finden Sie hier.</a> </p><br><p>  Hier sind alle neuen Methoden aufgeführt, die nicht in den Modulen java.net.http und jdk.jfr enthalten sind.  Ebenfalls nicht aufgeführt sind die neuen Methoden und Klassen in den Modulen java.security, die für Änderungen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 324</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 329</a> sehr spezifisch sind (es gibt sechs neue Klassen und acht neue Methoden). </p><br><h4 id="javaiobytearrayoutputstream">  java.io.ByteArrayOutputStream </h4><br><ul><li>  <strong>void writeBytes (byte [])</strong> : Schreibt alle Bytes aus dem Argument in OutputStream </li></ul><br><h4 id="javaiofilereader">  java.io.FileReader </h4><br><p>  Zwei neue Konstruktoren, mit denen Sie einen Zeichensatz angeben können. </p><br><h4 id="javaiofilewriter">  java.io.FileWriter </h4><br><p>  Vier neue Konstruktoren, mit denen Sie einen Zeichensatz angeben können. </p><br><h4 id="javaioinputstream">  java.io.InputStream </h4><br><ul><li>  <strong>io.InputStream nullInputStream ()</strong> : <strong>Gibt</strong> einen InputStream zurück, der keine Bytes liest.  Bei Betrachtung dieser Methode (und der in OutputStream, Reader und Writer) stellt sich die Frage, warum sie nützlich sein könnte.  Sie können sie sich als <strong>/ dev / null</strong> vorstellen, um nicht benötigte Ausgaben zu verwerfen oder Eingaben bereitzustellen, die immer Null-Bytes zurückgeben. </li></ul><br><h4 id="javaiooutputstream">  java.io.OutputStream </h4><br><ul><li>  <strong>io.OutputStream nullOutputStream ()</strong> </li></ul><br><h4 id="javaioreader">  java.io.Reader </h4><br><ul><li>  <strong>io.Reader nullReader ()</strong> </li></ul><br><h4 id="javaiowriter">  java.io.Writer </h4><br><ul><li>  <strong>io.Writer nullWriter ()</strong> </li></ul><br><h4 id="javalangcharacter">  java.lang.Character </h4><br><ul><li>  <strong>String toString (int)</strong> : Dies ist eine überladene Form einer vorhandenen Methode, aber int wird anstelle von char verwendet.  Int ist der Unicode-Codepunkt. </li></ul><br><h4 id="javalangcharsequence">  java.lang.CharSequence </h4><br><ul><li>  <strong>int compare (CharSequence, CharSequence)</strong> : Vergleicht zwei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lexikografische</a> Instanzen von CharSequence.  Gibt einen negativen Wert, Null oder einen positiven Wert zurück, wenn die erste Sequenz lexikographisch kleiner, gleich oder größer als die zweite ist. </li></ul><br><h4 id="javalangrefreference">  java.lang.ref.Reference </h4><br><ul><li>  <strong>lang.Object clone ()</strong> : Ich muss zugeben, diese Änderung <strong>sorgt</strong> für Verwirrung.  Die Reference-Klasse implementiert die klonbare Schnittstelle nicht, und diese Methode löst eine CloneNotSupportedException aus.  Es muss einen Grund für seine Aufnahme geben, vielleicht für etwas in der Zukunft.  ( <em>Anmerkung des Übersetzers: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es gibt eine Diskussion über StackOverflow</a> , ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ticket in OpenJDK.</a></em> ) </li></ul><br><h4 id="javalangruntime">  java.lang.Runtime </h4><br><h4 id="javalangsystem">  java.lang.System </h4><br><p>  Es gibt hier keine neuen Methoden, aber es ist erwähnenswert, dass die <strong>runFinalizersOnExit ()</strong> -Methode jetzt aus beiden Klassen entfernt wurde (bei der Migration auf JDK 11 kann ein Problem auftreten). </p><br><h4 id="javalangstring">  java.lang.String </h4><br><p>  Ich denke, dies ist eines der Highlights der neuen APIs in JDK 11. Hier gibt es einige nützliche neue Methoden. </p><br><ul><li>  <strong>boolean isBlank ()</strong> : <strong>Gibt</strong> true zurück, wenn die Zeichenfolge leer ist oder nur Leerzeichen enthält, andernfalls false. </li><li>  <strong>Stream lines ()</strong> : Gibt Stream from String zurück, der aus diesem String extrahiert und durch Zeilentrennzeichen getrennt wurde. </li><li>  <strong>String repeat (int)</strong> : Gibt einen String zurück, dessen Wert die Verkettung dieses Strings ist, der mehrmals wiederholt wird. </li><li>  <strong>String strip ()</strong> : Gibt einen String zurück, dessen Wert dieser String ist. Dadurch werden alle Leerzeichen am Anfang und Ende des Strings entfernt. </li><li>  <strong>String stripLeading ()</strong> : <strong>Gibt</strong> einen String zurück, dessen Wert dieser String ist, während alle Leerzeichen am Zeilenanfang entfernt werden. </li><li>  <strong>String stripTrailing ()</strong> : <strong>Gibt</strong> einen String zurück, dessen Wert dieser <strong>String ist. Dadurch werden</strong> alle Leerzeichen am Ende des Strings entfernt. </li></ul><br><p>  Höchstwahrscheinlich schauen Sie sich <strong>strip () an</strong> und fragen: "Wie unterscheidet sich das von der vorhandenen <strong>trim ()</strong> -Methode?"  Die Antwort liegt in der unterschiedlichen Definition von Räumen.  ( <em>Anmerkung des Übersetzers: Kurz gesagt, <strong>strip ()</strong> versteht Unicode besser, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">detaillierte Analyse auf StackOverflow</a></em> ) </p><br><h4 id="javalangstringbuffer">  java.lang.StringBuffer </h4><br><h4 id="javalangstringbuilder">  java.lang.StringBuilder </h4><br><p>  Beide Klassen haben eine neue <strong>compareTo ()</strong> -Methode, die einen StringBuffer / StringBuilder verwendet und einen int zurückgibt.  Die lexikalische Vergleichsmethode ähnelt der neuen <strong>compareTo ()</strong> -Methode in CharSequence. </p><br><h4 id="javalangthread">  java.lang.Thread </h4><br><p>  Keine neuen Methoden.  Die <strong>Methoden</strong> <strong>destroy ()</strong> und <strong>stop (Throwable)</strong> wurden entfernt.  Die <strong>stop ()</strong> -Methode, die keine Argumente akzeptiert, ist noch vorhanden.  Kann zu einem Kompatibilitätsproblem führen. </p><br><h4 id="javaniobytebuffer">  java.nio.ByteBuffer </h4><br><h4 id="javaniocharbuffer">  java.nio.CharBuffer </h4><br><h4 id="javaniodoublebuffer">  java.nio.DoubleBuffer </h4><br><h4 id="javaniofloatbuffer">  java.nio.FloatBuffer </h4><br><h4 id="javaniolongbuffer">  java.nio.LongBuffer </h4><br><h4 id="javanioshortbuffer">  java.nio.ShortBuffer </h4><br><p>  Alle diese Klassen haben jetzt die Methode <strong>mismatch ()</strong> , die den relativen Index der ersten Nichtübereinstimmung zwischen diesem Puffer und dem übergebenen Puffer findet und zurückgibt. </p><br><h4 id="javaniochannelsselectionkey">  java.nio.channels.SelectionKey </h4><br><ul><li>  <strong>int InterestOpsAnd (int)</strong> : Legt das Interesse dieses Schlüssels (das Interesse des Schlüssels <strong>)</strong> atomar an der bitweisen Schnittmenge ("und") der vorhandenen Interessengruppe und des übergebenen Werts fest. </li><li>  <strong>int InterestOpsOr (int)</strong> : Legt das Interesse dieses Schlüssels (das Interesse des Schlüssels <strong>)</strong> atomar an der bitweisen Vereinigung ("oder") der vorhandenen Interessengruppe und des übergebenen Werts fest. </li></ul><br><h4 id="javaniochannelsselector">  java.nio.channels.Selector </h4><br><ul><li>  <strong>int select (java.util.function.Consumer, long)</strong> : Wählen Sie Aktionen für Tasten aus und führen Sie sie aus, deren entsprechende Kanäle für E / A-Vorgänge bereit sind.  langes Argument ist eine Auszeit. </li><li>  <strong>int select (java.util.function.Consumer)</strong> : wie oben, jedoch ohne Zeitüberschreitung. </li><li>  <strong>int selectNow (java.util.function.Consumer)</strong> : wie oben, nur nicht blockierend. </li></ul><br><h4 id="javaniofilefiles">  java.nio.file.Files </h4><br><ul><li>  <strong>String readString (Pfad)</strong> : Liest den gesamten Inhalt einer Datei in einen String und decodiert mithilfe der UTF-8-Codierung von Bytes in Zeichen. </li><li>  <strong>String readString (Pfad, Zeichensatz)</strong> : Wie oben angegeben, mit dem Unterschied, dass die Dekodierung von Bytes zu Zeichen mit dem angegebenen Zeichensatz erfolgt. </li><li>  <strong>Pfad writeString (Pfad, CharSequence, java.nio.file.OpenOption [])</strong> : Schreiben Sie CharSequence in eine Datei.  Zeichen werden mithilfe der UTF-8-Codierung in Bytes codiert. </li><li>  <strong>Pfad writeString (Pfad, CharSequence, java.nio.file.Charset, OpenOption [])</strong> : Wie oben werden Zeichen in Bytes mit der in Zeichensatz angegebenen Codierung codiert. </li></ul><br><h4 id="javaniofilepath">  java.nio.file.Path </h4><br><ul><li>  <strong>Pfad von (String, String [])</strong> : Gibt den Pfad aus dem String-Argument des Pfads oder der Folge von Strings zurück, die zusammen die Pfadzeichenfolge bilden. </li><li>  <strong>Pfad von (net.URI)</strong> : <strong>Gibt den</strong> Pfad von der URI zurück. </li></ul><br><h4 id="javautilcollection">  java.util.Collection </h4><br><ul><li>  <strong>Object [] toArray (java.util.function.IntFunction)</strong> : <strong>Gibt</strong> ein Array zurück, das alle Elemente in dieser Auflistung enthält. Verwenden Sie dazu die bereitgestellte Generierungsfunktion, um das zurückgegebene Array zuzuweisen. </li></ul><br><h4 id="javautilconcurrentpriorityblockingqueue">  java.util.concurrent.PriorityBlockingQueue </h4><br><h4 id="javautilpriorityqueue">  java.util.PriorityQueue </h4><br><ul><li>  <strong>void forEach (java.util.function.Consumer)</strong> : Führt die übergebene Aktion für jedes Iterable-Element aus, bis alle Elemente verarbeitet wurden oder die Aktion eine Ausnahme auslöst. </li><li>  <strong>boolean removeAll (java.util.Collection)</strong> : <strong>Entfernt</strong> alle Elemente dieser Sammlung, die auch in der angegebenen Sammlung enthalten sind (optionale Operation). </li><li>  <strong>boolean removeIf (java.util.function.Predicate)</strong> : Entfernt alle Elemente aus dieser Sammlung, die das angegebene Prädikat erfüllen. </li><li>  <strong>boolean keepAll (java.util.Collection)</strong> : Speichert nur die Elemente in dieser Sammlung, die in der übertragenen Sammlung enthalten sind (optionale Operation). </li></ul><br><h4 id="javautilconcurrenttimeunit">  java.util.concurrent.TimeUnit </h4><br><ul><li>  <strong>long convert (java.time.Duration)</strong> : konvertiert die übergebene Duration in diesen Typ. </li></ul><br><h4 id="javautilfunctionpredicate">  java.util.function.Predicate </h4><br><ul><li>  <strong>Prädikat nicht (Prädikat)</strong> : Gibt das Prädikat zurück, bei dem es sich um die Negation des übertragenen Prädikats handelt. </li></ul><br><p>  Dies ist eine meiner neuen Lieblings-APIs in JDK 11. Als Beispiel können Sie diesen Code konvertieren: </p><br><pre> <code class="java hljs"> lines.stream() .filter(s -&gt; !s.isBlank())</code> </pre> <br><p>  in </p><br><pre> <code class="java hljs"> lines.stream() .filter(Predicate.not(String::isBlank))</code> </pre> <br><p>  oder wenn wir statische Importe verwenden: </p><br><pre> <code class="java hljs"> lines.stream() .filter(not(String::isBlank))</code> </pre> <br><p>  Persönlich glaube ich, dass diese Version verständlicher und prägnanter ist. </p><br><h4 id="javautiloptional">  java.util.Optional </h4><br><h4 id="javautiloptionalint">  java.util.OptionalInt </h4><br><h4 id="javautiloptionaldouble">  java.util.OptionalDouble </h4><br><h4 id="javautiloptionallong">  java.util.OptionalLong </h4><br><ul><li>  <strong>boolean isEmpty ()</strong> : Wenn kein Wert vorhanden ist, wird true zurückgegeben, andernfalls false. </li></ul><br><h4 id="javautilregexpattern">  java.util.regex.Pattern </h4><br><ul><li>  <strong>Prädikat asMatchPredicate ()</strong> : Ich denke, es könnte das Juwel der neuen JDK 11-API sein. Erstellt ein Prädikat, das prüft, ob diese Vorlage mit der angegebenen Eingabezeichenfolge übereinstimmt. </li></ul><br><h4 id="javautilzipdeflater">  java.util.zip.Deflater </h4><br><ul><li><p>  <strong>int deflate (ByteBuffer)</strong> : Komprimiert die Eingabe und füllt den angegebenen Puffer damit. </p><br></li><li><p>  <strong>int deflate (ByteBuffer, int)</strong> : Komprimiert die Eingabe und füllt den angegebenen Puffer damit.  Gibt die tatsächliche Menge der komprimierten Daten zurück. </p><br></li><li><p>  <strong>void setDictionary (ByteBuffer)</strong> : Legt das angegebene Wörterbuch für die Komprimierung auf Bytes in diesem Puffer fest.  Dies ist eine überladene Form einer vorhandenen Methode, die ein ByteBuffer jetzt akzeptieren kann, anstatt eines Byte-Arrays. </p><br></li><li><p>  <strong>void setInput (ByteBuffer)</strong> : Legt die zu komprimierende Eingabe fest.  Auch eine überladene Form einer vorhandenen Methode. </p><br></li></ul><br><h4 id="javautilzipinflater">  java.util.zip.Inflater </h4><br><ul><li>  <strong>int inflate (ByteBuffer)</strong> : Dekomprimiert Bytes in den angegebenen Puffer.  Gibt die tatsächliche Anzahl entpackter Bytes zurück. </li><li>  <strong>void setDictionary (ByteBuffer)</strong> : Setzt das angegebene Wörterbuch auf Bytes in diesem Puffer.  Die überladene Form einer vorhandenen Methode. </li><li>  <strong>void setInput (ByteBuffer)</strong> : Legt die Eingabe für die Dekomprimierung fest.  Die überladene Form einer vorhandenen Methode. </li></ul><br><h4 id="javaxprintattributestandarddialogowner">  javax.print.attribute.standard.DialogOwner </h4><br><p>  Dies ist eine neue Klasse in JDK 11. Wird verwendet, um eine Anforderung für einen Druckdialog oder eine Seiteneinrichtung zu unterstützen.  Muss über allen Fenstern oder einem bestimmten Fenster angezeigt werden. </p><br><h4 id="javaxswingdefaultcomboboxmodel">  javax.swing.DefaultComboBoxModel </h4><br><h4 id="javaxswingdefaultlistmodel">  javax.swing.DefaultListModel </h4><br><ul><li>  <strong>void addAll (Sammlung)</strong> : <strong>Fügt</strong> alle in der Sammlung vorhandenen Elemente hinzu. </li><li>  <strong>void addAll (int, Collection)</strong> : <strong>Fügt</strong> alle in der Sammlung vorhandenen Elemente ab dem angegebenen Index hinzu. </li></ul><br><h4 id="javaxswinglistselectionmodel">  javax.swing.ListSelectionModel </h4><br><ul><li>  <strong>int [] getSelectedIndices ()</strong> : Gibt ein Array aller ausgewählten Indizes im ausgewählten Modell in aufsteigender Reihenfolge zurück. </li><li>  <strong>int getSelectedItemsCount ()</strong> : Gibt die Anzahl der ausgewählten Elemente zurück. </li></ul><br><h4 id="jdkjshellevalexception">  jdk.jshell.EvalException </h4><br><ul><li>  <strong>jshell.JShellException getCause ()</strong> : <strong>Gibt einen auslösbaren</strong> Ursachen-Wrapper im Ausführungsclient zurück, der durch eine EvalException dargestellt wird, oder null, wenn die Ursache nicht vorhanden oder unbekannt ist. </li></ul><br><h3 id="novye-fichi-ne-publichnyy-api">  Neue Funktionen (keine öffentliche API) </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 181: Nestbasierte Zugriffskontrolle</a> </p><br><p>  Java (und andere Sprachen) unterstützt verschachtelte Klassen durch innere Klassen.  Für die korrekte Operation muss der Compiler einige Tricks ausführen.  Zum Beispiel: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerInt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printOuterInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Outer int = "</span></span> + outerInt); } } }</code> </pre> <br><p>  Der Compiler ändert dies, um vor dem Kompilieren Folgendes zu erstellen: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerInt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> access$<span class="hljs-number"><span class="hljs-number">000</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outerInt; } }</code> </pre> <br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class">$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ Outer outer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printOuterInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Outer int = "</span></span> + outer.access$<span class="hljs-number"><span class="hljs-number">000</span></span>()); } }</code> </pre> <br><p>  Obwohl die innere Klasse logischerweise Teil desselben Codes wie die äußere Klasse ist, wird sie als separate Klasse kompiliert.  Dies erfordert daher eine synthetische Methode ("Brücke"), die vom Compiler erstellt werden muss, um Zugriff auf das private Feld der externen Klasse zu erhalten. </p><br><p>  Dieser JEP stellt das Konzept eines „Sockets“ dar, bei dem zwei Mitglieder desselben Sockets (außen und innen aus unserem Beispiel) Nachbarn sind.  Im Dateiformat * .class wurden zwei neue Attribute hinzugefügt: NestHost und NestMembers.  Diese Änderungen sind auch für andere mit Bytecode kompilierte Sprachen nützlich, die verschachtelte Klassen unterstützen. </p><br><p>  Diese Funktion bietet drei neue Methoden für java.lang.Class: </p><br><ul><li>  <strong>Klasse getNestHost ()</strong> </li><li>  <strong>Klasse [] getNestMembers ()</strong> </li><li>  <strong>boolean isNestmateOf (clazz)</strong> </li></ul><br><p>  Diese Funktion erforderte auch Änderungen an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Java Virtual Machine Specification (JVMS)</a> , insbesondere in Abschnitt 5.4.4 Zugriffssteuerung. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 309: Dynamische Klassendateikonstanten</a></strong> </p><br><p>  Dieser JEP beschreibt die Erweiterung des Dateiformats * .class, um das neue Formular mit dem konstanten Pool CONSTANT_Dynamic (in Präsentationen häufig als condy bezeichnet) zu unterstützen.  Die Idee einer dynamischen Konstante scheint ein Oxymoron zu sein, aber tatsächlich kann man sie sich als endgültigen Wert in Java vorstellen.  Der Wert des Konstantenpools wird nicht in der Kompilierungsphase festgelegt (im Gegensatz zu anderen Konstanten), aber die Bootstrap-Methode wird verwendet, um den Wert zur Laufzeit zu bestimmen.  Daher ist der Wert dynamisch, aber da sein Wert nur einmal festgelegt wird, ist er auch konstant. </p><br><p>  Diese Funktion ist vor allem für diejenigen nützlich, die neue Sprachen und Compiler entwickeln.  Wer generiert den Bytecode und die * .class-Dateien, um sie auf der JVM auszuführen?  Dies vereinfacht einige Aufgaben. </p><br><p>  Diese Funktion bietet eine neue Klasse java.lang.invoke.ConstantBootstraps mit neun neuen Methoden.  Ich werde sie hier nicht alle auflisten;  Dies sind Bootstrap-Methoden für dynamisch berechnete Konstanten. </p><br><p>  Diese Funktion erforderte Änderungen am JVMS, insbesondere hinsichtlich der Verwendung des speziellen Aufrufbytecodes und von Abschnitt 4.4 des Konstantenpools. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 315: Verbessern Sie Aarch64 Intrinsics</a></strong> </p><br><p>  Dies war der JEP von Red Hat.  Die JVM kann jetzt speziellere Anweisungen verwenden, die im Befehlssatz von Arm 64 verfügbar sind. Dies verbessert insbesondere die Funktionsweise der Methoden sin (), cos () und log () der Klasse java.lang.Math. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 318: Der Epsilon Garbage Collector</a></strong> </p><br><p>  Red Hat hat ebenfalls zu diesem JEP beigetragen.  Der Epsilon-Müllsammler ist etwas ungewöhnlich, da er keinen Müll sammelt!  Bei der Erstellung neuer Objekte wird bei Bedarf neuer Speicher zugewiesen, der von Objekten ohne Verknüpfungen belegte Speicherplatz wird jedoch nicht freigegeben. </p><br><p>  Es scheint also, worum geht es?  Es gibt mindestens zwei Verwendungszwecke: </p><br><ul><li>  Zunächst soll dieser Kollektor sicherstellen, dass neue GC-Algorithmen hinsichtlich ihrer Auswirkungen auf die Leistung bewertet werden.  Die Idee ist, eine Beispielanwendung mit Epsilon GC auszuführen und eine Metrik zu generieren.  Ein neuer GC-Algorithmus ist enthalten, die gleichen Tests werden ausgeführt und die Ergebnisse werden verglichen. </li><li>  Für sehr kurze oder kurzlebige Aufgaben (denken Sie an eine serverlose Funktion in der Cloud), bei der Sie sicherstellen können, dass Sie den dem Heap-Speicher zugewiesenen Speicher nicht überschreiten.  Dies kann die Leistung verbessern, indem der Overhead (einschließlich der Erfassung von Statistiken, die zur Entscheidung über die Ausführung des Kollektors erforderlich sind) im Anwendungscode entfällt. </li></ul><br><p>  Wenn der Heap-Speicherplatz erschöpft ist, kann der nachfolgende JVM-Betrieb auf drei Arten konfiguriert werden: </p><br><ul><li>  Ein regulärer OutOfMemoryError wird aufgerufen. </li><li>  Heap zurücksetzen </li><li>  Es ist schwierig, die JVM anzuhalten und möglicherweise eine externe Aufgabe auszuführen (z. B. den Debugger zu starten). </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 324: Schlüsselvereinbarung mit Curve25519 und Curve448</strong></a> </p><br><p>  Kryptografische Standards ändern sich ständig und verbessern sich.  In diesem Fall wird das vorhandene Diffie-Hellman-Schema mit einer elliptischen Kurve durch Curve25519 und Curve448 ersetzt.  Dies ist ein in RFC-7748 definiertes Schlüsselvereinbarungsschema. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 327: Unicode 10</strong></a> </p><br><p>  Die Java-Plattform unterstützt Unicode, um die Verarbeitung aller Zeichensätze zu ermöglichen.  Da Unicode auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 10</a> aktualisiert wurde, wurde auch das JDK aktualisiert, um diese Version des Standards zu unterstützen. </p><br><p>  Ich bin immer wieder gespannt, was Unicode-Entwickler in neuen Versionen enthalten.  Unicode 10 hat 8.518 neue Zeichen.  Dazu gehören das Bitcoin-Symbol, der Nüshu-Zeichensatz (von chinesischen Frauen zum Schreiben von Gedichten verwendet) sowie der Soyombo- und der Zanabazar-Platz (die Zeichen, die in historischen buddhistischen Texten zum Schreiben von Sanskrit-, tibetischen und mongolischen Sprachen verwendet werden).  Viele andere Emoji wurden ebenfalls hinzugefügt, einschließlich des lang erwarteten (anscheinend) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colbert Emoji</a> . </p><br><p>  Denken Sie daran, dass Sie ab JDK 9 UTF-8 in Eigenschaftendateien (.properties) verwenden können.  Dies bedeutet, dass in solchen Dateien jedes Unicode-Zeichen verwendet werden kann.  Einschließlich Emojis.  Nüshu. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 328: Flight Recorder</strong></a> </p><br><p> Flight Recorder —       JVM.  JDK 11        Oracle JDK. ,  Oracle     Oracle JDK  OpenJDK,      OpenJDK. </p><br><p> JEP    : </p><br><ul><li>  API        </li><li>        </li><li>      </li><li>    , JVM HotSpot   JDK </li></ul><br><p>      : jdk.jfr  jdk.management.jfr. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 329: ChaCha20 and Poly1305 Cryptographic Algorithms</strong></a> </p><br><p>  JEP 324,   ,  JDK.   ChaCha20  ChaCha20-Poly1305,    RFC 7539. ChaCha20 —     ,    ,    RC4. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 331: Low-overhead Heap Profiling</strong></a> </p><br><p>  ,   JEP,   Google.          Java  JVM. </p><br><p>  : </p><br><ul><li>    ,       </li><li>       </li><li>     </li><li>        ( ,     GC   VM) </li><li>         Java. </li></ul><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 332: Transport Layer Security (TLS) 1.3</strong></a> </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TLS 1.3 (RFC 8446)</a>  " "  TLS            . JDK   ,      Datagram Transport Layer Security (DTLS). </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 333: ZGC A Scalable, Low Latency Garbage Collector</strong></a> </p><br><p>     ,     ,     ()    .      (  ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weak Generational Hypothesis</a> )    (  )  GC   .     ""  ,            .           . </p><br><p> ZGC — region-based (  G1), NUMA aware  compacting  .      . </p><br><p>     pauseless     ,      C4   Zing JVM. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 335: Deprecate the Nashorn Scripting Engine</strong></a> </p><br><p> Nashorn    JDK 8     Rhino Javascript .    ,   Nashorn   API  jjs     Java.   ,   .     Graal VM   ,     ,  . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JEP 336: Deprecate the Pack200 Tools and APIs</strong></a> </p><br><p> Pack200 —     JAR-,     Java SE 5.0.   JPMS  JDK 9 Pack200       JDK.  pack200  unpack200  API Pack200  java.util.jar          JDK.   ,  . </p><br><h3 id="vyvody">  Schlussfolgerungen </h3><br><p> JDK 11 —   LTS JDK (       ).   ,  ,   ,   ,  JVM   ,        . </p><br><p> Zulu  JDK 11  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>   ! </p><br><p>         JDK 11? </p><br><p> ( <em>. : ,         </em> ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424683/">https://habr.com/ru/post/de424683/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424673/index.html">CLRium # 4: .NET-Community-Meeting</a></li>
<li><a href="../de424675/index.html">Was passiert im Einzelhandel?</a></li>
<li><a href="../de424677/index.html">Eine kurze Geschichte der Zehnertastatur</a></li>
<li><a href="../de424679/index.html">Reparieren Sie wichtige Computer-Peripheriegeräte</a></li>
<li><a href="../de424681/index.html">Oktober IT Events Digest (Teil 1)</a></li>
<li><a href="../de424685/index.html">Die US-amerikanische Börsenaufsichtsbehörde (Securities and Exchange Commission) reichte eine Klage gegen den Chef von Tesla Elon Musk ein, auch wegen Betrugs</a></li>
<li><a href="../de424687/index.html">Das sind die richtigen Bienen: mechanische Anpassung an dynamische Effekte</a></li>
<li><a href="../de424689/index.html">Die Kontrolle über die Situation macht glücklich.</a></li>
<li><a href="../de424691/index.html">Wir laden Sie zur Konferenz Azov Developers Meetup 2018 - 13. Oktober in Taganrog ein</a></li>
<li><a href="../de424693/index.html">Hinzufügen eines Wasserzeichens zu allen Bildern der Site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>