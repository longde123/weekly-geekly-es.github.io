<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👿 👨🏿‍🚒 💇 AresDB Demo: Alat Analisis Real-Time Real-Time Berbasis Open dari Uber 👍🏻 🈂️ 👲🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Berkat analisis waktu nyata, kami, karyawan Uber, mendapatkan gagasan tentang kondisi hubungan kerja dan efisiensi kerja, dan berdasarkan data kami me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AresDB Demo: Alat Analisis Real-Time Real-Time Berbasis Open dari Uber</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/440072/"><p>  Berkat analisis waktu nyata, kami, karyawan Uber, mendapatkan gagasan tentang kondisi hubungan kerja dan efisiensi kerja, dan berdasarkan data kami memutuskan bagaimana meningkatkan kualitas kerja pada platform Uber.  Misalnya, tim proyek memantau keadaan pasar dan mengidentifikasi potensi masalah pada platform kami;  perangkat lunak yang didasarkan pada model pembelajaran mesin memprediksi penawaran dan permintaan penumpang untuk pengemudi;  spesialis pemrosesan data meningkatkan model pembelajaran mesin - pada gilirannya, untuk meningkatkan kualitas perkiraan. </p><br><p><img src="https://habrastorage.org/webt/ii/ml/9e/iiml9el5ttzjjxvz6jrx1ff_zng.png"></p><br><p>  Di masa lalu, untuk analisis waktu nyata, kami menggunakan solusi basis data dari perusahaan lain, tetapi tidak ada yang memenuhi semua kriteria kami untuk fungsionalitas, skalabilitas, efisiensi, biaya, dan persyaratan operasional. </p><br><p>  Dirilis pada November 2018, AresDB adalah alat analisis real-time open source.  Ini menggunakan catu daya tidak konvensional, prosesor grafis (GPU), yang memungkinkan Anda untuk meningkatkan skala analisis.  Teknologi GPU, alat analisis waktu nyata yang menjanjikan, telah meningkat secara signifikan dalam beberapa tahun terakhir, menjadikannya ideal untuk komputasi paralel dan pemrosesan data secara real-time. </p><br><p>  Pada bagian berikut, kami menggambarkan struktur AresDB dan bagaimana solusi menarik ini untuk analisis waktu nyata memungkinkan kami untuk lebih efisien dan lebih rasional menyatukan, menyederhanakan, dan meningkatkan solusi basis data Uber untuk analisis waktu nyata.  Kami berharap bahwa setelah membaca artikel ini Anda akan mencoba AresDB sebagai bagian dari proyek Anda sendiri dan juga memastikan kegunaannya! </p><a name="habracut"></a><br><h3 id="prilozheniya-uber-dlya-analiza-v-realnom-vremeni">  Uber aplikasi analisis real-time </h3><br><p>  Analisis data sangat penting untuk keberhasilan Uber.  Di antara fungsi-fungsi lain, alat analitik digunakan untuk menyelesaikan tugas-tugas berikut: </p><br><ul><li>  Membangun <strong>dasbor</strong> untuk memantau metrik bisnis. </li><li>  Membuat <strong>keputusan otomatis</strong> (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menentukan biaya perjalanan</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengidentifikasi kasus penipuan</a> ) berdasarkan metrik ringkasan yang dikumpulkan. </li><li>  Buat <strong>kueri acak</strong> untuk mendiagnosis, memecahkan masalah, dan memecahkan masalah operasi bisnis. </li></ul><br><p>  Kami mengategorikan fungsi-fungsi ini dengan persyaratan yang berbeda sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/oa/sp/lm/oasplm7jy6mqhkoevqutusej-sa.png"></p><br><p>  Dasbor dan sistem pengambilan keputusan menggunakan sistem analisis waktu-nyata untuk membuat pertanyaan serupa pada subset data yang relatif kecil tetapi sangat penting (dengan tingkat relevansi data tertinggi) dengan QPS tinggi dan latensi rendah. </p><br><h3 id="potrebnost-v-drugom-analiticheskom-module">  Perlu modul analitik lain </h3><br><p>  Masalah paling umum yang Uber gunakan alat analisis real-time untuk menyelesaikan adalah menghitung populasi deret waktu.  Perhitungan ini memberikan gambaran interaksi pengguna sehingga kami dapat meningkatkan kualitas layanan yang sesuai.  Berdasarkan mereka, kami meminta indikator untuk parameter tertentu (misalnya, hari, jam, pengenal kota dan status perjalanan) untuk jangka waktu tertentu untuk data yang difilter secara acak (atau kadang-kadang digabungkan).  Selama bertahun-tahun, Uber telah menggunakan beberapa sistem yang dirancang untuk menyelesaikan masalah ini dengan berbagai cara. </p><br><p>  Berikut adalah beberapa solusi pihak ketiga yang kami gunakan untuk menyelesaikan jenis masalah ini: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Pinot</a> , database analitik open source terdistribusi yang ditulis dalam Java, cocok untuk analisis data skala besar.  Pinot menggunakan arsitektur lambda internal untuk meminta data paket dan data waktu-nyata dalam penyimpanan kolom, indeks bit terbalik untuk pemfilteran, dan pohon bintang untuk menyimpan hasil agregat.  Namun, itu tidak mendukung deduplikasi berbasis kunci, memperbarui atau menyisipkan, menggabungkan, atau fitur permintaan lanjutan seperti penyaringan geospasial.  Selain itu, karena Pinot adalah basis data berbasis JVM, permintaan sangat mahal dalam hal penggunaan memori. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Elasticsearch</a> digunakan oleh Uber untuk menyelesaikan berbagai tugas analisis streaming.  Itu dibangun berdasarkan perpustakaan Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lucene</a> , yang menyimpan dokumen, untuk pencarian kata kunci teks lengkap dan indeks terbalik.  Sistem tersebar luas dan diperluas untuk mendukung data agregat.  Indeks terbalik menyediakan pemfilteran tetapi tidak dioptimalkan untuk menyimpan dan memfilter data berdasarkan rentang waktu.  Catatan disimpan dalam bentuk dokumen JSON, yang membebankan biaya tambahan untuk menyediakan akses ke repositori dan permintaan.  Seperti Pinot, Elasticsearch adalah basis data berbasis JVM dan, karenanya, tidak mendukung fungsi gabungan, dan eksekusi permintaan menghabiskan banyak memori. </li></ul><br><p>  Meskipun teknologi ini memiliki kekuatan mereka, mereka tidak memiliki beberapa fitur yang dibutuhkan untuk kasus penggunaan kami.  Kami membutuhkan solusi terpadu, disederhanakan dan dioptimalkan, dan dalam pencariannya kami bekerja ke arah yang tidak standar (lebih tepatnya, di dalam GPU). </p><br><h3 id="ispolzovanie-gpu-dlya-analiza-v-realnom-vremeni">  Menggunakan GPU untuk analisis waktu-nyata </h3><br><p>  Untuk rendering gambar yang realistis dengan frame rate tinggi, GPU secara bersamaan memproses sejumlah besar bentuk dan piksel dengan kecepatan tinggi.  Meskipun kecenderungan untuk meningkatkan frekuensi clock unit pemrosesan data selama beberapa tahun terakhir telah mulai menurun, jumlah transistor dalam chip telah meningkat hanya menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hukum Moore</a> .  Akibatnya, kecepatan komputasi GPU, diukur dalam gigaflops per detik (Gflops / s), meningkat pesat.  Gambar 1 di bawah ini menunjukkan perbandingan tren kecepatan teoritis (Gflops / s) dari NVIDIA GPU dan Intel CPU selama bertahun-tahun: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mq/gh/wg/mqghwgau9j51rlgs_hratcvmw7i.png"></a> </p><br><p>  <em>Gambar 1. Perbandingan kinerja floating-point CPU dan GPU presisi tunggal selama beberapa tahun.</em>  <em>Gambar diambil dari Panduan Pemrograman CUDA C Nvidia.</em> </p><br><p>  Dalam mengembangkan mekanisme permintaan analisis waktu nyata, keputusan untuk mengintegrasikan GPU adalah wajar.  Di Uber, permintaan analisis waktu-nyata yang khas membutuhkan pemrosesan data dalam beberapa hari dengan jutaan atau bahkan milyaran catatan, kemudian difilter dan diringkas dalam waktu singkat.  Tugas komputasi ini sangat cocok dengan model pemrosesan paralel paralel GPU untuk keperluan umum, karena mereka: </p><br><ul><li>  Mereka memproses data secara paralel dengan kecepatan yang sangat tinggi. </li><li>  Mereka memberikan kecepatan komputasi yang lebih tinggi (Gflops / s), yang membuatnya sangat baik untuk melakukan tugas komputasi yang kompleks (lebih dari blok data) yang dapat diparalelkan. </li><li>  Mereka memberikan kinerja yang lebih tinggi (tanpa penundaan) dalam pertukaran data antara unit komputasi dan penyimpanan (ALU dan memori global GPU) dibandingkan dengan unit pemrosesan pusat (CPU), menjadikannya ideal untuk memproses tugas I / O memori paralel, yang membutuhkan sejumlah besar data. </li></ul><br><p>  Berfokus pada penggunaan basis data analitik berbasis GPU, kami - dari sudut pandang kebutuhan kami - mengevaluasi beberapa solusi analitis yang ada yang menggunakan GPU: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kinetica</a> , alat analitik berbasis GPU, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memasuki</a> pasar pada tahun 2009, awalnya untuk digunakan di Angkatan Darat AS dan agen intelijen.  Meskipun menunjukkan potensi tinggi dari teknologi GPU dalam analitik, kami menemukan bahwa untuk kondisi penggunaan kami, banyak fungsi utama yang hilang, termasuk mengubah skema, memasukkan atau memperbarui sebagian, kompresi data, konfigurasi disk dan memori pada tingkat kolom, dan koneksi dengan hubungan geospasial. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OmniSci</a> , modul kueri SQL sumber terbuka, tampak seperti opsi yang menjanjikan, tetapi ketika mengevaluasi produk, kami menyadari bahwa ia tidak memiliki beberapa fitur penting untuk digunakan di Uber, seperti deduplikasi.  Meskipun OminiSci memperkenalkan kode sumber terbuka proyeknya pada tahun 2017, setelah menganalisis solusi mereka berdasarkan C ++, kami sampai pada kesimpulan bahwa tidak mengubah atau bercabang basis kode mereka secara praktis layak. </li><li>  Alat analisis real-time berbasis GPU, termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GPUQP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CoGaDB</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GPUDB</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ocelot</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OmniDB</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Virgin</a> , sering digunakan dalam lembaga penelitian dan pendidikan.  Namun, mengingat tujuan akademis mereka, keputusan ini fokus pada pengembangan algoritma dan konsep pengujian, daripada menyelesaikan masalah dunia nyata.  Karena alasan ini, kami tidak memperhitungkannya - dalam kondisi volume dan skala kami. </li></ul><br><p>  Secara keseluruhan, sistem ini menunjukkan keuntungan besar dan potensi pemrosesan data menggunakan teknologi GPU, dan mereka mengilhami kami untuk membuat solusi analisis real-time GPU kami sendiri yang disesuaikan dengan kebutuhan Uber.  Berdasarkan konsep-konsep ini, kami mengembangkan dan membuka kode sumber untuk AresDB. </p><br><h3 id="obzor-arhitektury-aresdb">  Tinjauan Arsitektur AresDB </h3><br><p>  Pada tingkat tinggi, AresDB menyimpan sebagian besar data dalam memori host (RAM, yang terhubung ke CPU), menggunakan CPU untuk memproses data yang diterima dan disk untuk memulihkan data.  Selama periode permintaan, AresDB mentransfer data dari memori host ke memori GPU untuk pemrosesan paralel dalam GPU.  Seperti yang ditunjukkan pada Gambar 2 di bawah, AresDB termasuk penyimpanan memori, penyimpanan metadata, dan disk: </p><br><p><img src="https://habrastorage.org/webt/my/o0/1h/myo01hflityxzcgrlcfrecplyxc.png"><br>  <em>Gambar 2. Arsitektur unik AresDB termasuk penyimpanan memori, disk, dan penyimpanan metadata.</em> </p><br><h3 id="tablicy">  Tabel </h3><br><p>  Tidak seperti kebanyakan sistem manajemen basis data relasional (RDBMS), AresDB tidak memiliki basis data atau skema.  Semua tabel milik lingkup yang sama dalam satu cluster / instance dari AresDB, yang memungkinkan pengguna untuk mengaksesnya secara langsung.  Pengguna menyimpan data mereka dalam bentuk tabel fakta dan tabel dimensi. </p><br><p>  <strong>Tabel fakta</strong> </p><br><p>  Tabel fakta menyimpan aliran deret waktu yang tak ada habisnya.  Pengguna menggunakan tabel fakta untuk menyimpan acara / fakta yang terjadi dalam waktu nyata, dan setiap acara dikaitkan dengan waktu acara, dan tabel tersebut sering ditanyakan pada waktu acara.  Sebagai contoh dari jenis informasi yang disimpan dalam tabel fakta, kita dapat memberi nama perjalanan, di mana setiap perjalanan adalah acara, dan waktu permintaan perjalanan sering disebut sebagai waktu acara.  Jika beberapa stempel waktu dikaitkan dengan suatu peristiwa, hanya satu stempel waktu diindikasikan sebagai waktu acara dan ditampilkan dalam tabel fakta. </p><br><p>  <strong>Tabel pengukuran</strong> </p><br><p>  Tabel pengukuran menyimpan karakteristik fasilitas saat ini (termasuk kota, pelanggan, dan pengemudi).  Misalnya, pengguna dapat menyimpan informasi tentang kota, khususnya nama kota, zona waktu dan negara, dalam tabel pengukuran.  Tidak seperti tabel fakta, yang terus tumbuh, tabel dimensi selalu terbatas dalam ukuran (misalnya, untuk Uber, tabel kota dibatasi oleh jumlah kota aktual di dunia).  Tabel pengukuran tidak memerlukan kolom waktu khusus. </p><br><h3 id="tipy-dannyh">  Tipe data </h3><br><p>  Tabel di bawah ini menunjukkan tipe data saat ini yang didukung oleh AresDB: </p><br><p><img src="https://habrastorage.org/webt/zj/vl/9v/zjvl9v3bezbrorzdbv71ricwzoq.png"></p><br><p>  Di AresDB, string dikonversi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">enum</a> secara otomatis sebelum mereka memasuki database untuk meningkatkan kenyamanan penyimpanan dan efisiensi permintaan.  Ini memungkinkan pemeriksaan kesetaraan peka huruf besar-kecil, tetapi tidak mendukung operasi lanjutan seperti penggabungan, substring, topeng, dan pencocokan ekspresi reguler.  Di masa mendatang, kami bermaksud menambahkan opsi dukungan garis penuh. </p><br><h3 id="osnovnye-funkcii">  Fungsi utama </h3><br><p>  Arsitektur AresDB mendukung fitur-fitur berikut: </p><br><ul><li>  <strong>Penyimpanan berbasis kolom dengan kompresi</strong> untuk meningkatkan efisiensi penyimpanan (lebih sedikit memori dalam byte untuk penyimpanan data) dan efisiensi kueri (pertukaran data lebih sedikit antara memori CPU dan memori GPU saat memproses permintaan) </li><li>  <strong>Pembaruan waktu-nyata atau masukkan dengan deduplikasi kunci utama</strong> untuk meningkatkan akurasi data dan memperbarui data waktu-nyata dalam beberapa detik </li><li>  <strong>Pemrosesan permintaan GPU</strong> untuk <strong>pemrosesan</strong> data <strong>GPU yang</strong> sangat paralel dengan latensi permintaan rendah (dari sepersekian detik hingga beberapa detik) </li></ul><br><h3 id="stolbchatoe-hranilische">  Penyimpanan kolom </h3><br><p>  <strong>Vektor</strong> </p><br><p>  AresDB menyimpan semua data dalam format kolom.  Nilai setiap kolom disimpan sebagai vektor nilai kolom.  Marker nilai keyakinan / ketidakpastian pada setiap kolom disimpan dalam vektor nol yang terpisah, sedangkan nilai marka nilai keyakinan masing-masing disajikan sebagai satu bit. </p><br><p>  <strong>Penyimpanan aktif</strong> </p><br><p>  AresDB menyimpan data kolom yang tidak dikompresi dan tidak disortir (vektor aktif) dalam penyimpanan aktif.  Catatan data dalam penyimpanan aktif dibagi menjadi paket (aktif) dari volume yang diberikan.  Paket baru dibuat ketika data diterima, sementara paket lama dihapus setelah pengarsipan catatan.  Indeks kunci utama digunakan untuk menemukan deduplikasi dan memperbarui catatan.  Gambar 3 di bawah ini menunjukkan bagaimana kami mengatur catatan aktif dan menggunakan nilai kunci utama untuk menentukan lokasi mereka: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/sa/ak/mk/saakmkzjumbdukxzaizxhmjbcik.png"></a> <br>  <em>Gambar 3. Kami menggunakan nilai kunci utama untuk menentukan lokasi paket dan posisi setiap catatan dalam paket.</em> </p><br><p> Nilai dari setiap kolom dalam paket disimpan sebagai vektor kolom.  Marker reliabilitas / ketidakpastian nilai dalam setiap vektor nilai disimpan sebagai vektor nol yang terpisah, dan marker reliabilitas setiap nilai disajikan sebagai satu bit.  Pada Gambar 4 di bawah ini, kami menawarkan contoh dengan lima nilai untuk kolom <code>city_id</code> : </p><br><p> <a href=""><img src="https://habrastorage.org/webt/zp/bs/ld/zpbsldqk0yij-dvewowbgawy8eq.png"></a> <br>  <em>Gambar 4. Kami menyimpan nilai (nilai aktual) dan vektor nol (penanda kepercayaan) kolom terkompresi dalam tabel data.</em> </p><br><h3 id="arhivnoe-hranilische">  Penyimpanan arsip </h3><br><p>  AresDB juga menyimpan data kolom yang telah diisi, disortir, dan dikompresi (arsip vektor) dalam penyimpanan arsip melalui tabel fakta.  Catatan dalam penyimpanan arsip juga didistribusikan secara batch.  Tidak seperti paket aktif, paket arsip menyimpan catatan per hari sesuai dengan Waktu Universal Terkoordinasi (UTC).  Paket arsip telah menggunakan jumlah hari sebagai pengidentifikasi paket sejak Unix Epoch. </p><br><p>  Catatan disimpan dalam bentuk diurutkan sesuai dengan urutan pengurutan kolom yang ditentukan pengguna.  Seperti yang ditunjukkan pada Gambar 5 di bawah, kami mengurutkannya terlebih dahulu dengan kolom <code>city_id</code> , dan kemudian oleh kolom status: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ah/qm/dm/ahqmdmonjmy4trbjpzf7lqqdm10.png"></a> <br>  <em>Gambar 5. Kami mengurutkan semua baris dengan city_id, lalu dengan negara, dan kemudian kompres setiap kolom dengan pengkodean grup.</em>  <em>Setelah penyortiran dan kompresi, setiap kolom akan menerima vektor akuntansi.</em> </p><br><p>  Tujuan pengaturan urutan pengurutan pengguna untuk kolom adalah sebagai berikut: </p><br><ul><li>  Memaksimalkan efek kompresi dengan menyortir kolom dengan sejumlah kecil elemen di tempat pertama.  Kompresi maksimum meningkatkan efisiensi penyimpanan (lebih sedikit byte diperlukan untuk menyimpan data) dan efisiensi kueri (lebih sedikit byte yang ditransfer antara memori CPU dan memori GPU). </li><li>  Menyediakan pra-penyaringan berdasarkan rentang yang nyaman untuk filter setara umum, mis. City_id = 12.  Pra-filtering meminimalkan jumlah byte yang diperlukan untuk mentransfer data antara memori CPU dan memori GPU, yang memaksimalkan efisiensi permintaan. </li></ul><br><p>  Kolom dikompresi hanya jika ada dalam urutan pengurutan yang ditentukan oleh pengguna.  Kami tidak mencoba mengompres kolom dengan sejumlah besar elemen, karena ini menghemat sedikit memori. </p><br><p>  Setelah mengurutkan, data untuk setiap kolom yang memenuhi syarat dikompres menggunakan opsi pengkodean grup tertentu.  Selain vektor nilai dan vektor nol, kami memperkenalkan vektor akuntansi untuk mewakili kembali nilai yang sama. </p><br><h3 id="priem-dannyh-v-realnom-vremeni-s-podderzhkoy-funkciy-obnovleniya-i-vstavki">  Penerimaan data real-time dengan dukungan untuk fungsi pembaruan dan penyisipan </h3><br><p>  Klien menerima data melalui API HTTP dengan menerbitkan paket layanan.  Paket layanan adalah format biner dipesan khusus yang meminimalkan penggunaan ruang sambil mempertahankan akses acak ke data. </p><br><p>  Ketika AresDB menerima paket layanan, itu pertama menulis paket layanan ke log operasi pemulihan.  Ketika paket layanan ditambahkan ke akhir log peristiwa, AresDB mengidentifikasi dan melompati entri yang terlambat di tabel fakta untuk digunakan dalam penyimpanan aktif.  Catatan dianggap "terlambat" jika waktu acara lebih awal dari waktu yang diarsipkan dari acara putuskan.  Untuk catatan yang tidak dianggap "terlambat," AresDB menggunakan indeks kunci utama untuk menemukan paket di dalam toko aktif di mana Anda ingin memasukkan mereka.  Seperti yang ditunjukkan pada Gambar 6 di bawah ini, catatan baru (yang sebelumnya tidak ditemui berdasarkan nilai kunci utama) dimasukkan ke ruang kosong, dan catatan yang ada diperbarui secara langsung: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/px/y9/ee/pxy9eenpxhgejwvtih8gg37rppu.png"></a> <br>  <em>Gambar 6. Ketika data diterima, setelah menambahkan paket layanan ke log peristiwa, entri "terlambat" ditambahkan ke antrian terbalik, dan entri lainnya ke penyimpanan aktif.</em> </p><br><h3 id="arhivirovanie">  Pengarsipan </h3><br><p>  Ketika data diterima, catatan ditambahkan / diperbarui di penyimpanan aktif, atau ditambahkan ke antrian terbalik, menunggu penempatan di penyimpanan arsip. </p><br><p>  Kami secara berkala memulai proses terjadwal, disebut sebagai pengarsipan, sehubungan dengan catatan penyimpanan aktif untuk melampirkan catatan baru (catatan yang belum pernah diarsipkan sebelumnya) ke penyimpanan arsip.  Proses pengarsipan hanya memproses catatan dalam penyimpanan aktif dengan waktu acara dalam kisaran antara waktu shutdown lama (waktu shutdown dari proses pengarsipan terakhir) dan waktu shutdown baru (waktu shutdown baru berdasarkan parameter keterlambatan pengarsipan dalam tata letak tabel). </p><br><p>  Catatan waktu acara digunakan untuk menentukan di mana paket arsip catatan harus dikombinasikan saat mengemas data arsip ke dalam paket harian.  Pengarsipan tidak memerlukan deduplikasi indeks dari nilai kunci utama selama penggabungan, karena hanya catatan dalam rentang antara waktu shutdown yang lama dan yang baru yang diarsipkan. </p><br><p>  Gambar 7 di bawah ini menunjukkan grafik sesuai dengan waktu acara catatan tertentu. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/6t/l6/uc/6tl6ucxgbni_inkqwjo8u0pxcrs.png"></a> <br>  <em>Gambar 7. Kami menggunakan waktu acara dan waktu perjalanan untuk mendefinisikan catatan sebagai baru (aktif) dan lama (waktu acara lebih awal dari waktu yang diarsipkan dari acara perjalanan).</em> </p><br><p>  Dalam hal ini, interval pengarsipan adalah interval waktu antara dua proses pengarsipan, dan penundaan pengarsipan adalah periode setelah waktu acara, tetapi sampai acara diarsipkan.  Kedua parameter didefinisikan dalam pengaturan skema tabel AresDB. </p><br><h3 id="obratnoe-zapolnenie">  Isi ulang </h3><br><p>  Seperti yang ditunjukkan pada Gambar 7 di atas, catatan lama (waktu acara lebih awal dari waktu yang diarsipkan dari acara pematian) untuk tabel fakta ditambahkan ke antrian terbalik dan akhirnya diproses sebagai bagian dari proses pengurukan.  Pemicu proses ini juga waktu atau ukuran antrian terbalik, jika mencapai tingkat ambang batas.  Dibandingkan dengan proses penambahan data ke penyimpanan aktif, pengisian ulang tidak sinkron dan relatif lebih mahal dalam hal CPU dan sumber daya memori.  Pengisian digunakan dalam skenario berikut: </p><br><ul><li>  Memproses data acak yang sangat terlambat </li><li>  Pengambilan manual data historis dari aliran data hulu </li><li>  Memasukkan data historis di kolom yang baru ditambahkan </li></ul><br><p>  Tidak seperti pengarsipan, proses pengisian ulang idempoten dan membutuhkan deduplikasi berdasarkan nilai kunci utama.  Data yang dapat diisi pada akhirnya akan terlihat oleh kueri. </p><br><p>  Antrian terbalik dipertahankan dalam memori dengan ukuran yang telah ditentukan, dan dengan banyak pengisian isi ulang, proses akan diblokir untuk klien sampai antrian dihapus dengan memulai proses pengisian ulang. </p><br><h3 id="obrabotka-zaprosa">  Meminta pemrosesan </h3><br><p>  Dalam implementasi saat ini, pengguna perlu menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ares Query Language</a> (AQL) yang dibuat oleh Uber untuk menjalankan kueri di AresDB.  AQL adalah bahasa yang efektif untuk kueri analitik runtun waktu dan tidak mengikuti sintaks SQL standar seperti "SELECT FROM WHERE GROUP BY" seperti bahasa lain yang mirip dengan SQL.  Sebagai gantinya, AQL digunakan dalam bidang terstruktur dan dapat dimasukkan dalam objek JSON, YAML, dan Go.  Misalnya, alih-alih <code>/SELECT (*) /FROM   /GROUP BY city_id, /WHERE  = «» /AND request_at &gt;= 1512000000</code> , varian AQL yang setara di JSON ditulis sebagai berikut: </p><br><pre> <code class="plaintext hljs">{ “table”: “trips”, “dimensions”: [ {“sqlExpression”: “city_id”} ], “measures”: [ {“sqlExpression”: “count(*)”} ], ;”&gt; “rowFilters”: [ “status = 'completed'” ], “timeFilter”: { “column”: “request_at”, “from”: “2 days ago” } }</code> </pre> <br><p>  Dalam format JSON, AQL menawarkan pengembang dashboard dan sistem pengambilan keputusan algoritma kueri program yang lebih nyaman daripada SQL, memungkinkan mereka untuk dengan mudah menyusun kueri dan memanipulasi mereka menggunakan kode tanpa khawatir tentang hal-hal seperti injeksi SQL.  Ini bertindak sebagai format permintaan universal untuk arsitektur khas browser web, server eksternal dan internal hingga database (AresDB).  Selain itu, AQL menyediakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sintaks yang</a> nyaman untuk memfilter berdasarkan waktu dan batching dengan dukungan untuk zona waktunya sendiri.  Selain itu, bahasa mendukung sejumlah fungsi, seperti subqueries implisit, untuk mencegah kesalahan umum dalam kueri dan memfasilitasi proses menganalisis dan menulis ulang kueri untuk pengembang antarmuka internal. </p><br><p>  Terlepas dari banyak manfaat yang ditawarkan AQL, kami sangat menyadari bahwa sebagian besar insinyur lebih terbiasa dengan SQL.  Menyediakan antarmuka SQL untuk mengeksekusi kueri adalah salah satu langkah selanjutnya yang akan kita lihat sebagai bagian dari upaya kami untuk meningkatkan interaksi dengan pengguna AresDB. </p><br><p>  Diagram alur eksekusi permintaan AQL ditunjukkan pada Gambar 8 di bawah ini: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/c7/bo/qq/c7boqqkfrjkqgn8i2zeb1ji6wje.png"></a> <br>  <em>Gambar 8. Diagram alir kueri AresDB menggunakan bahasa kueri AQL kami sendiri untuk memproses dan mengambil data dengan cepat dan efisien.</em> </p><br><h3 id="kompilyaciya-zaprosov">  Kompilasi permintaan </h3><br><p>  Kueri AQL dikompilasi ke dalam konteks kueri internal.  Ekspresi dalam filter, pengukuran, dan parameter dianalisis dalam pohon sintaksis abstrak (AST) untuk diproses lebih lanjut melalui prosesor grafis (GPU). </p><br><h3 id="zagruzka-dannyh">  Pemuatan data </h3><br><p>  AresDB menggunakan pra-filter untuk memfilter data arsip dengan murah sebelum mengirimnya ke GPU untuk pemrosesan paralel.  Karena data yang diarsipkan diurutkan berdasarkan urutan kolom yang dikonfigurasi, beberapa filter dapat menggunakan urutan ini dan metode pencarian biner untuk menentukan rentang pencocokan yang sesuai.  Secara khusus, filter yang setara untuk semua kolom X yang awalnya diurutkan dan filter rentang opsional untuk kolom yang diurutkan X + 1 dapat digunakan sebagai filter awal, seperti yang ditunjukkan pada Gambar 9 di bawah ini. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mq/gj/cw/mqgjcwi-es1twxn2navrzd6bhki.png"></a> <br>  <em>Gambar 9. AresDB melakukan pra-filter data kolom sebelum mengirimnya ke GPU untuk diproses.</em> </p><br><p>  Setelah pra-pemfilteran, hanya nilai hijau (memenuhi kondisi filter) yang harus dikirim ke GPU untuk pemrosesan paralel.  Input data dimasukkan ke dalam GPU dan diproses satu paket sekaligus.  Ini termasuk paket aktif dan paket arsip. </p><br><p>  AresDB menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stream CUDA</a> untuk pipelining dan pemrosesan data.  Untuk setiap permintaan, dua aliran diterapkan secara bergantian untuk diproses dalam dua tahap yang tumpang tindih.  Pada Gambar 10 di bawah ini, kami menawarkan grafik yang menggambarkan proses ini. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/gg/b-/hv/ggb-hvvb1tbno_uq2rbokxu1ehi.png"></a> <br>  <em>Gambar 10. Dalam AresDB, dua utas CUDA mengirimkan dan memproses data secara bergantian.</em> </p><br><h3 id="vypolnenie-zaprosa">  Eksekusi query </h3><br><p>  Untuk kesederhanaan, AresDB menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan Thrust</a> untuk mengimplementasikan prosedur eksekusi kueri, yang menawarkan blok algoritma paralel yang disetel dengan halus untuk implementasi cepat kueri dalam alat saat ini. </p><br><p>  Dalam Thrust, input dan output data vektor dievaluasi menggunakan iterator akses acak.  Setiap thread GPU mencari iterator input di posisi kerjanya, membaca nilai-nilai dan melakukan perhitungan, dan kemudian menulis hasilnya ke posisi yang sesuai di iterator output. </p><br><p>  Untuk mengevaluasi ekspresi AresDB, model “satu operator per inti” (OOPK) mengikuti. </p><br><p>  Pada Gambar 11 di bawah ini, prosedur ini ditunjukkan dengan menggunakan contoh AST yang dihasilkan dari ekspresi dimensi <code>request_at – request_at % 86400</code> pada tahap kompilasi permintaan: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/rq/zd/cq/rqzdcq1dpy3vnwhi8tjqppsxroq.png"></a> <br>  <em>Gambar 11. AresDB menggunakan model OOPK untuk mengevaluasi ekspresi.</em> </p><br><p>  Dalam model OOPK, mesin kueri AresDB memotong setiap simpul daun pohon AST dan mengembalikan iterator untuk simpul sumber.  Jika simpul root juga terbatas, tindakan root dilakukan langsung pada input iterator. </p><br><p>  Untuk setiap simpul non-ujung non-root ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">operasi modulo</a> dalam contoh ini), vektor ruang kerja sementara dialokasikan untuk menyimpan hasil antara yang diperoleh dari <code>request_at% 86400</code> ekspresi.  Menggunakan Thrust, fungsi kernel diluncurkan untuk menghitung hasil pernyataan ini di GPU.  Hasil disimpan di iterator ruang kerja. </p><br><p>  Untuk simpul root, fungsi kernel berjalan dengan cara yang sama seperti untuk simpul non-root, tidak terbatas.  Berbagai tindakan keluaran dilakukan berdasarkan jenis ekspresi, yang dijelaskan secara rinci di bawah ini: </p><br><ul><li>  Penyaringan untuk mengurangi jumlah elemen vektor input </li><li>  Merekam data hasil pengukuran dalam vektor pengukuran untuk penggabungan data selanjutnya </li><li>  Rekam output parameter dalam vektor parameter untuk penggabungan data selanjutnya </li></ul><br><p>  Setelah mengevaluasi ekspresi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyortiran</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transformasi</a> dilakukan untuk akhirnya menggabungkan data.  Dalam operasi penyortiran dan transformasi, kami menggunakan nilai-nilai vektor dimensi sebagai nilai kunci untuk penyortiran dan transformasi, dan nilai-nilai vektor parameter sebagai nilai untuk menggabungkan data.  Dengan demikian, baris dengan nilai dimensi yang sama dikelompokkan dan dikombinasikan.  Gambar 12 di bawah ini menunjukkan proses penyortiran dan konversi ini. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ki/wn/hg/kiwnhgruuhvlm2wenraxbrwhwwk.png"></a> <br>  <em>Gambar 12. Setelah mengevaluasi ekspresi, AresDB mengurutkan dan mengonversi data sesuai dengan nilai-nilai kunci dari vektor pengukuran (nilai kunci) dan parameter (nilai).</em> </p><br><p>  AresDB juga mendukung fungsi kueri lanjutan berikut: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bergabung</a> : AresDB saat ini mendukung opsi gabung hash antara tabel fakta dan tabel dimensi </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memperkirakan jumlah item</a> Hyperloglog: AresDB menggunakan algoritma Hyperloglog </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Geo Intersect</a> : AresDB saat ini hanya mendukung operasi yang saling berhubungan antara GeoPoint dan GeoShape </li></ul><br><h3 id="upravlenie-resursami">  Manajemen sumber daya </h3><br><p>  Sebagai basis data berdasarkan memori internal, AresDB harus mengelola jenis penggunaan memori berikut: </p><br><p><img src="https://habrastorage.org/webt/20/_4/bb/20_4bbooneymuteoxhig9tqcdjk.png"></p><br><p>  Ketika AresDB mulai, ia menggunakan anggaran memori bersama yang dikonfigurasi.  Anggaran dibagi menjadi enam jenis memori dan juga harus menyisakan ruang yang cukup untuk sistem operasi dan proses lainnya.  Anggaran ini juga mencakup perkiraan kemacetan yang dikonfigurasi secara statis, penyimpanan data aktif yang dipantau oleh server, dan data yang diarsipkan yang dapat diputuskan oleh server untuk diunduh dan dihapus tergantung pada sisa anggaran memori. <br>  Gambar 13 di bawah ini menunjukkan model memori host AresDB. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/no/dq/2t/nodq2t_tlr0fn-cy6ubrdwpqofi.png"></a> <br>  <em>Gambar 13. AresDB mengelola penggunaan memorinya sendiri sehingga tidak melebihi anggaran total proses yang dikonfigurasi.</em> </p><br><p>  AresDB memungkinkan pengguna untuk mengatur hari preload dan prioritas tingkat kolom untuk tabel fakta dan preload data yang diarsipkan hanya pada hari preload.  Data yang belum diunduh sebelumnya dimuat ke dalam memori dari disk sesuai permintaan.  Ketika diisi, AresDB juga menghapus data yang diarsipkan dari memori host.  Prinsip-prinsip penghapusan AresDB didasarkan pada parameter berikut: jumlah hari preloading, prioritas kolom, hari penyusunan paket, dan ukuran kolom. </p><br><p>  AresDB juga mengelola beberapa perangkat GPU dan mensimulasikan sumber daya perangkat sebagai utas GPU dan memori perangkat, melacak penggunaan memori GPU untuk memproses permintaan.  AresDB mengelola perangkat GPU melalui manajer perangkat yang memodelkan sumber daya perangkat GPU dalam dua dimensi (utas GPU dan memori perangkat) dan melacak penggunaan memori saat memproses permintaan.  Setelah mengkompilasi permintaan, AresDB memungkinkan pengguna untuk memperkirakan jumlah sumber daya yang dibutuhkan untuk menyelesaikan permintaan.  Persyaratan memori perangkat harus dipenuhi sebelum permintaan diselesaikan;  jika saat ini tidak ada cukup memori pada perangkat apa pun, permintaan tersebut harus menunggu.  Saat ini, AresDB dapat menjalankan satu atau lebih permintaan pada perangkat GPU yang sama secara bersamaan jika perangkat tersebut memenuhi semua persyaratan sumber daya. </p><br><p>  Dalam implementasi saat ini, AresDB tidak men-cache input di memori perangkat untuk digunakan kembali dalam beberapa permintaan.  AresDB bertujuan untuk mendukung permintaan terhadap dataset yang terus diperbarui secara real time dan di-cache dengan benar.  Dalam versi AresDB yang akan datang, kami bermaksud mengimplementasikan fungsi untuk menyimpan data dalam memori GPU, yang akan membantu mengoptimalkan kinerja kueri. </p><br><h3 id="primer-ispolzovaniya-obzornaya-informacionnaya-panel-uber">  Contoh penggunaan: Dasbor ikhtisar Uber </h3><br><p>  Di Uber, kami menggunakan AresDB untuk membuat dasbor untuk mendapatkan informasi bisnis waktu-nyata.  AresDB bertanggung jawab untuk menyimpan acara utama dengan pembaruan konstan dan menghitung metrik kritis untuk mereka dalam sepersekian detik berkat sumber daya GPU dengan biaya rendah, sehingga pengguna dapat menggunakan dasbor secara interaktif.  Misalnya, data perjalanan anonim yang memiliki masa berlaku lama di gudang data diperbarui oleh beberapa layanan, termasuk sistem pengiriman, pembayaran, dan sistem penetapan harga kami.  Untuk memanfaatkan data perjalanan secara efisien, pengguna membagi dan memecah data menjadi dimensi yang berbeda untuk mendapatkan wawasan tentang solusi waktu nyata. </p><br><p>  Saat menggunakan AresDB, dasbor Uber adalah dasbor analisis luas yang digunakan oleh tim dalam perusahaan untuk menghasilkan metrik yang relevan dan respons waktu nyata untuk meningkatkan pengalaman pengguna. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/p-/8e/k6/p-8ek6nx3gioyhngzczop7oh1jw.png"></a> <br> <em> 14.       Uber  AresDB           .</em> </p><br><p>     ,  ,    : </p><br><p> <strong> ( )</strong> </p><br><p><img src="https://habrastorage.org/webt/he/7a/q4/he7aq4btwhfbdgmj3qy-npinpyy.png"></p><br><p> <strong> ( )</strong> </p><br><p><img src="https://habrastorage.org/webt/wi/ox/pb/wioxpbxuygxvf3lg3gs0velx-rc.png"></p><br><h3 id="shemy-tablic-v-aresdb">    AresDB </h3><br><p>     ,  ,       AresDB   : </p><br><p><img src="https://habrastorage.org/webt/uz/ur/hq/uzurhq1u-nkwue6eq7zqepbyqiu.jpeg"></p><br><p>    ,       ,    ,    ,        ,       . </p><br><p>       <a href="">  AresDB</a>      ,  Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kafka</a> ,       ,  Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flink</a>  Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spark</a> . </p><br><h3 id="primery-zaprosov-dlya-aresdb">    AresDB </h3><br><p>           , «   »  « ».         ,  -.           24         AQL: </p><br><p><img src="https://habrastorage.org/webt/po/1m/1u/po1m1uit03geewuvntsviruc5pw.jpeg"></p><br><p> <strong>   : <br></strong>         ,        ,   . </p><br><p><img src="https://habrastorage.org/webt/63/wr/9h/63wr9hhyak0furssgtfxa_bcj98.png"></p><br><p>      ,    AresDB    ,     ,                 . AresDB       ,       ,          . </p><br><h3 id="sleduyuschie-shagi">   </h3><br><p> AresDB    Uber         ,            .     ,  ,       AresDB    . </p><br><p>         : </p><br><ul><li> <strong> </strong> :         AresDB,  ,     ,        . </li><li> <strong>   </strong> :      AresDB   2018        ,           ,      AresDB    . </li><li> <strong>  </strong> :       ,     ,          ,       . </li><li> <strong>  </strong> :           ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   (LLVM)</a>    GPU. </li></ul><br><p> AresDB  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>   Apache.     AresDB     . </p><br><p> <em>          ,         .</em> </p><br><h3 id="blagodarnosti">  Ucapan Terima Kasih </h3><br><p> <em>    (Kate Zhang),   (Jennifer Anderson),   (Nikhil Joshi),   (Abhi Khune),   (Shengyue Ji),   (Chinmay Soman),   (Xiang Fu),   (David Chen)    (Li Ning)  ,      !</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440072/">https://habr.com/ru/post/id440072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440060/index.html">TensorFlow di Apache Ignite</a></li>
<li><a href="../id440062/index.html">Merencanakan dengan senang hati. Bagaimana kami mengatur proses tanpa manajer</a></li>
<li><a href="../id440064/index.html">Pusat data yang dapat dipilih: London, Moskow, Zurich, St. Petersburg</a></li>
<li><a href="../id440066/index.html">Ekstensi VSCode untuk mempermudah pengembangan JavaScript dan Vue</a></li>
<li><a href="../id440070/index.html">Julia, Keturunan Gradien dan Metode Simpleks</a></li>
<li><a href="../id440074/index.html">Roskomos menganggap itu salah untuk membandingkan mesin Raptor Ilona Mask dan RD-180</a></li>
<li><a href="../id440076/index.html">Terjemahan dan interpretasi iklan dari bahasa Inggris ke bahasa Rusia</a></li>
<li><a href="../id440078/index.html">Perangkat kompiler Swift. Bagian 4</a></li>
<li><a href="../id440084/index.html">10 miliar ekspor perangkat lunak dapat diabaikan</a></li>
<li><a href="../id440086/index.html">Dunia Virus MS-DOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>