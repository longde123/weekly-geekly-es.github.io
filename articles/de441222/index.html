<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜🏿 🔇 👨🏻‍🎨 Warum ist Kubernetes so kompliziert mit Repositories? 💸 👸🏿 ☎️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als Container-Orchestratoren wie Kubernetes eintrafen, änderte sich der Ansatz zur Entwicklung und Bereitstellung von Anwendungen dramatisch. Microser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum ist Kubernetes so kompliziert mit Repositories?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/441222/"><p><img src="https://habrastorage.org/webt/3w/v4/sh/3wv4sha9sfamx7elh4imtocvesm.jpeg"></p><br><p>  Als Container-Orchestratoren wie Kubernetes eintrafen, änderte sich der Ansatz zur Entwicklung und Bereitstellung von Anwendungen dramatisch.  Microservices sind erschienen, und für den Entwickler ist die Anwendungslogik nicht mehr mit der Infrastruktur verbunden: Erstellen Sie Anwendungen für sich selbst und bieten Sie neue Funktionen an. </p><br><p>  Kubernetes abstrahiert von den physischen Computern, die es steuert.  Sagen Sie ihm einfach, wie viel Speicher und Rechenleistung Sie benötigen - und Sie erhalten alles.  Infrastruktur?  Nein, nicht gehört. </p><br><p>  Durch die Verwaltung von Docker-Images, Kubernetes und Anwendungen wird es portabel.  Nachdem Sie Containeranwendungen mit Kubernetes entwickelt haben, können Sie sie überall bereitstellen: in einer offenen Cloud, lokal oder in einer Hybridumgebung - ohne den Code zu ändern. </p><br><p>  Wir lieben Kubernetes wegen Skalierbarkeit, Portabilität und Verwaltbarkeit, aber es speichert keinen Status.  Wir haben jedoch fast alle Stateful-Anwendungen, dh sie benötigen externen Speicher. </p><a name="habracut"></a><br><p>  Kubernetes hat eine sehr dynamische Architektur.  Container werden abhängig von der Last und den Anweisungen der Entwickler erstellt und zerstört.  Hülsen und Behälter sind selbstheilend und replizieren sich.  Sie sind im Wesentlichen kurzlebig. </p><br><p>  <strong>Die externe Speicherung ist für eine solche Variabilität zu schwierig.</strong>  <strong>Es gehorcht nicht den Regeln der dynamischen Schöpfung und Zerstörung.</strong> </p><br><p> Sie müssen lediglich eine Stateful-Anwendung in einer anderen Infrastruktur bereitstellen: in einer anderen Cloud dort, lokal oder in einem Hybridmodell - wie es Portabilitätsprobleme gibt.  Externer Speicher kann an eine bestimmte Cloud gebunden werden. </p><br><p>  Aber nur in diesen Speichern für Cloud-Anwendungen wird sich der Teufel selbst das Bein brechen.  Und verstehen Sie die fiktiven Bedeutungen und Bedeutungen der <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherterminologie in Kubernetes</a></strong> .  Und es gibt Kubernetes eigene Repositories, Open Source-Plattformen, verwaltete oder kostenpflichtige Dienste ... </p><br><p>  Hier einige Beispiele <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">für CNCF-Cloud-Speicher</a></strong> : </p><br><p><img src="https://habrastorage.org/webt/cm/wl/ov/cmwlovlr6qt3qcicg0sm5acufvw.png"></p><br><p>  Es scheint, dass Sie die Datenbank in Kubernetes bereitstellen - Sie müssen nur die entsprechende Lösung auswählen, sie in einen Container packen, um auf der lokalen Festplatte zu arbeiten, und sie als nächste Arbeitslast im Cluster bereitstellen.  Aber die Datenbank hat ihre eigenen Besonderheiten, so dass Denken kein Eis ist. </p><br><p>  Container - sie sind so zusammengeschustert, dass sie ihren Zustand nicht bewahren.  Deshalb sind sie so einfach zu starten und zu stoppen.  Und da nichts gespeichert und übertragen werden muss, kümmert sich der Cluster nicht um Lese- und Kopiervorgänge. </p><br><p>  Sie müssen den Status in der Datenbank speichern.  Wenn eine Datenbank, die in einem Cluster in einem Container bereitgestellt wird, nirgendwo migriert und nicht zu oft gestartet wird, kommt die Datenspeicherphysik ins Spiel.  Im Idealfall sollten sich Container, die Daten verwenden, im selben Herd wie die Datenbank befinden. </p><br><p>  In einigen Fällen kann die Datenbank natürlich in einem Container bereitgestellt werden.  In einer Testumgebung oder bei Aufgaben mit wenig Daten leben Datenbanken bequem in Clustern. </p><br><p>  <strong>Die Produktion erfordert normalerweise eine externe Lagerung.</strong> </p><br><p>  Kubernetes kommuniziert mit dem Repository über Schnittstellen der Steuerebene.  Sie verbinden Kubernetes mit externem Speicher.  An Kubernetes angeschlossener externer Speicher wird als Volume-Plugins bezeichnet.  Mit ihnen können Sie Speicher abstrahieren und Speicher übertragen. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Volume-Plugins wurden früher</a></strong> mithilfe der Kubernetes-Codebasis <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellt</a></strong> , verknüpft, kompiliert und bereitgestellt.  Dies hat die Entwickler stark eingeschränkt und erfordert zusätzliche Wartung: Wenn Sie neue Repositorys hinzufügen möchten, ändern Sie bitte die Kubernetes-Codebasis. </p><br><p>  Stellen Sie jetzt Volume-Plugins für den Cluster bereit - das möchte ich nicht.  Und Sie müssen sich nicht in die Codebasis vertiefen.  Dank CSI und Flexvolume. </p><br><p><img src="https://habrastorage.org/webt/ug/r7/m4/ugr7m4uco1skczyasqf7xf3op3y.png"></p><br><h3 id="sobstvennoe-hranilische-kubernetes">  Kubernetes Native Storage </h3><br><p>  Wie löst Kubernetes Speicherprobleme?  Es gibt verschiedene Lösungen: kurzlebige Optionen, persistenter Speicher in persistenten Volumes, Abfragen von persistenten Volume-Ansprüchen, Speicherklassen oder StatefulSets.  Finde es im Allgemeinen heraus. </p><br><p>  Persistent Volumes (PV) sind vom Administrator vorbereitete Speichereinheiten.  Sie sind nicht abhängig von Herden und ihrem flüchtigen Leben. </p><br><p>  Persistent Volume Claim (PVC) sind Speicheranforderungen, d. H. PV.  Mit PVC können Sie Speicher an einen Knoten binden, und dieser Knoten verwendet ihn. </p><br><p>  Sie können statisch oder dynamisch mit Speicher arbeiten. </p><br><p>  Bei einem statischen Ansatz bereitet der Administrator PVs vor, die vor Anforderungen bereitgestellt werden sollen, und diese PVs werden mithilfe expliziter PVCs manuell an bestimmte Pods gebunden. </p><br><p>  In der Praxis sind speziell definierte PVs nicht mit der tragbaren Struktur von Kubernetes kompatibel. Die Speicherung hängt von der Umgebung ab, z. B. AWS EBS oder ein permanentes GCE-Laufwerk.  Um manuell zu binden, müssen Sie auf ein bestimmtes Repository in der YAML-Datei verweisen. </p><br><p>  Der statische Ansatz widerspricht im Allgemeinen der Kubernetes-Philosophie: CPUs und Speicher werden nicht im Voraus zugewiesen und sind nicht an Pods oder Container gebunden.  Sie werden dynamisch ausgegeben. </p><br><p>  Für die dynamische Bereitstellung verwenden wir Speicherklassen.  Der Clusteradministrator muss die PV nicht im Voraus erstellen.  Es werden mehrere Speicherprofile wie Vorlagen erstellt.  Wenn ein Entwickler eine PVC-Anfrage stellt, wird zum Zeitpunkt der Anfrage eines dieser Muster erstellt und an den Herd angehängt. </p><br><p><img src="https://habrastorage.org/webt/id/9q/mj/id9qmjxqf7tqnki0xc_1a710seg.png"></p><br><p>  Im Allgemeinen arbeitet Kubernetes also mit externem Speicher.  Es gibt viele andere Möglichkeiten. </p><br><h3 id="csi--container-storage-interface">  CSI - Container Storage Interface </h3><br><p>  Es gibt so etwas - <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Container Storage Interface</a></strong> .  CSI wurde von der CNCF-Tresor-Arbeitsgruppe erstellt, die beschlossen hat, eine Standard-Container-Speicherschnittstelle zu definieren, damit die Tresortreiber mit jedem Orchester arbeiten können. </p><br><p>  Die CSI-Spezifikationen sind bereits für Kubernetes angepasst, und es gibt <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unzählige Treiber-Plugins</a></strong> für Bereitstellungen im Kubernetes-Cluster.  Sie müssen über einen CSI-kompatiblen Volume-Treiber auf das Repository zugreifen. Verwenden Sie den <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Csi-</a></strong> Volume- <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typ</a></strong> in Kubernetes. </p><br><p>  Mit CSI kann Speicher als eine weitere Arbeitslast für die Containerisierung und Bereitstellung im Kubernetes-Cluster betrachtet werden. </p><br><p>  Für weitere Informationen hören Sie, wie <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jie Yu in unserem Podcast über CSI spricht</a></strong> . </p><br><h3 id="opensors-proekty">  Open Source Projekte </h3><br><p>  Tools und Projekte für Cloud-Technologien vermehren sich schnell, und ein angemessener Anteil von Open Source-Projekten - was logisch ist - löst eines der Hauptproduktionsprobleme: die Arbeit mit Speicher in der Cloud-Architektur. </p><br><p>  Die beliebtesten von ihnen sind Ceph und Rook. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ceph</a></strong> ist ein dynamisch verwalteter, verteilter Speichercluster mit horizontaler Skalierung.  Ceph bietet eine logische Abstraktion für Speicherressourcen.  Es hat keinen einzigen Fehlerpunkt, es verwaltet sich selbst und arbeitet auf der Basis von Software.  Ceph bietet Schnittstellen zum gleichzeitigen Speichern von Blöcken, Objekten und Dateien für einen einzelnen Speichercluster. </p><br><p>  Ceph hat eine sehr komplexe Architektur mit RADOS-, Librados-, RADOSGW-, RDB-, CRUSH-Algorithmus und verschiedenen Komponenten (Monitore, OSD, MDS).  Lassen Sie uns nicht näher auf die Architektur eingehen. Es reicht zu verstehen, dass Ceph ein verteilter Speichercluster ist, der die Skalierbarkeit vereinfacht, einen einzelnen Fehlerpunkt ohne Leistungseinbußen beseitigt und einen einzelnen Speicher mit Zugriff auf Objekte, Blöcke und Dateien bereitstellt. </p><br><p>  Natürlich ist Ceph für die Cloud angepasst.  Sie können einen Ceph-Cluster auf verschiedene Arten bereitstellen, z. B. mithilfe von Ansible oder über CSI und PVC in einem Kubernetes-Cluster. </p><br><p><img src="https://habrastorage.org/webt/g9/kn/ft/g9knft3jj1y3hw8u2v-4jzoa26k.png"><br>  <em>Ceph Architektur</em> </p><br><p>  Rook ist ein weiteres interessantes und beliebtes Projekt.  Es kombiniert Kubernetes mit seinem Computing und Ceph mit seinen Repositorys in einem Cluster. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rook</a></strong> ist ein Cloud-Speicher-Orchestrator, der Kubernetes ergänzt.  Sie packen Ceph damit in Container und verwenden die Cluster-Management-Logik für den zuverlässigen Betrieb von Ceph in Kubernetes.  Rook automatisiert Bereitstellung, Bootstrap, Optimierung, Skalierung und Neuausrichtung - im Allgemeinen alles, was der Cluster-Administrator tut. </p><br><p>  Mit Rook kann ein Ceph-Cluster wie Kubernetes von yaml aus bereitgestellt werden.  In dieser Datei beschreibt der Administrator, was er im Cluster benötigt.  Rook startet einen Cluster und beginnt aktiv zu überwachen.  Dies ist so etwas wie ein Bediener oder eine Steuerung - es stellt sicher, dass alle Anforderungen von yaml erfüllt werden.  Rook arbeitet mit Synchronisationszyklen - es sieht den Zustand und ergreift Maßnahmen, wenn es Abweichungen gibt. </p><br><p>  Er hat keinen dauerhaften Zustand und muss nicht kontrolliert werden.  Es ist im Geiste von Kubernetes. </p><br><p><img src="https://habrastorage.org/webt/ep/qx/qk/epqxqk5iecbwcekk88ac8tjxih4.png"></p><br><p>  Rook kombiniert Ceph und Kubernetes und ist eine der beliebtesten Cloud-Speicherlösungen: 4.000 Sterne auf Github, 16,3 Millionen Downloads und mehr als hundert Mitwirkende. <br>  Das Rook-Projekt wurde bereits bei CNCF angenommen <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und landete kürzlich in einem Inkubator</a></strong> . </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bassam Tabara</a></strong> wird Ihnen <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in unserer Kubernetes-Repository-Episode</a></strong> mehr über Rook erzählen. <br>  Wenn die Anwendung ein Problem hat, müssen Sie die Anforderungen herausfinden und ein System erstellen oder die erforderlichen Tools verwenden.  Dies gilt auch für Cloud-Speicher.  Und obwohl das Problem nicht von einfachen ist, sind die Werkzeuge und Ansätze zu kurz gekommen.  Die Cloud-Technologie entwickelt sich weiter und neue Lösungen werden uns sicherlich erwarten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441222/">https://habr.com/ru/post/de441222/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441212/index.html">Arbeiten Sie mit kryptografischem Informationsschutz und Hardwareschlüsselträgern unter Linux</a></li>
<li><a href="../de441214/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 1</a></li>
<li><a href="../de441216/index.html">Schwarzer Spiegel oder Picooc-Anzeige?</a></li>
<li><a href="../de441218/index.html">OpenAI Gym + ROS + Gazebo: Training eines eigenständigen Roboters zu Hause. Teil 1</a></li>
<li><a href="../de441220/index.html">Analyse der jüngsten Massenangriffe mit DNS-Erfassung</a></li>
<li><a href="../de441224/index.html">Erstellen Sie ein ARCore-Beispiel für erweiterte Gesichter in Unity</a></li>
<li><a href="../de441226/index.html">Forbes veröffentlichte 2019 eine Liste der teuersten russischen Internetunternehmen</a></li>
<li><a href="../de441234/index.html">SVG-Filtereffekte. Teil 6. Erstellen von Texturen mit feTurbulence</a></li>
<li><a href="../de441236/index.html">Habraiting 2018: die besten Materialien für 2018</a></li>
<li><a href="../de441238/index.html">Englisch programmieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>