<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👦‍👦 🍝 👩🏽‍⚕️ lang格式会降低程序速度 🛤️ 🛸 🕵🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，我们将测量toupper函数的不同实现的性能，因为这是他们在星期二所做的。 

 实际上，我并不在乎toupper函数，我最近才写过另一篇文章，我需要某种通用的绘图核心，并且toupper似乎是基准测试的一个有趣且无害的候选者。 我试图选择一种尽可能简单的方法，但不会碰到我，但恰好发生在这次测...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>lang格式会降低程序速度</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/480012/"> 今天，我们将测量toupper函数的不同实现的性能，因为这是他们在星期二所做的。 <br><br> 实际上，我并不在乎<a href="http://man7.org/linux/man-pages/man3/toupper.3.html"><i>toupper</i></a>函数，我最近才写过另一篇文章，我需要某种通用的绘图核心，并且<i>toupper</i>似乎是基准测试的一个有趣且无害的候选者。 我试图选择一种尽可能简单的方法，但不会碰到我，但恰好发生在这次测试中，我遇到了一个奇怪的问题。 <br><a name="habracut"></a><br> 这篇文章将很小-很快就会有关于原始的，也许更有趣的话题的更全面的文章。 如果要与我重现结果， <a href="https://github.com/travisdowns/toupper-bench">可以在github上获取</a>源代码。 <br><br> 因此，我们将考虑<i>toupper</i>函数的三种实现，该实现将由<i>char</i>类型的元素组成的数组的字符转换为大写字母-即，它以数组为参数并直接更改其元素，以便所有小写字母都大写。 <br><br> 在第一个实现中，我们只需调用C标准库<a href="https://linux.die.net/man/3/toupper">的toupper</a> [1] <a href="https://linux.die.net/man/3/toupper">函数</a>并执行C风格的循环： <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_rawloop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { buf[i] = <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>(buf[i]); } }</code> </pre> <br> 在第二个实现中，我们使用一种<a href="https://www.youtube.com/watch%3Fv%3D2olsGf6JIkU">更现代的</a>方法，将原始循环替换为<i>std :: transform</i> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(buf, buf + size, buf, ::<span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>); }</code> </pre> <br> 最后，在第三个实现中，我们使用一种适用于ASCII字符的特殊算法。 它检查字符是否在<i>a-z</i>范围内，如果成功，则将大写字母替换为相同字母，并从字符代码[2]中减去数字32： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_branch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = buf[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt;= <span class="hljs-string"><span class="hljs-string">'a'</span></span> &amp;&amp; c &lt;= <span class="hljs-string"><span class="hljs-string">'z'</span></span>) { buf[i] = c - <span class="hljs-number"><span class="hljs-number">32</span></span>; } } }</code> </pre> <br> 看起来很简单，对吧？ <br><br> 现在，我们将使用默认设置在gcc 5.5编译器上使用Skylake i7-6700HQ处理器在笔记本电脑上测量这些实现的速度。 结果以散点图的形式给出[3]： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/ps/uf/ecpsuf8lfb6dcp2empyh6vqbkco.png"></div><br> 立即我们将处理与我们的任务无关的三个问题。 <br><br> 首先，查看分支算法的图形（以绿色显示）。 根据输入数据的大小，它有很大的不同-其他两个图形几乎保持平坦。 这实际上只是一个测试工件。 输入的ASCII字符是随机选择的[4]，因此，在第三种实现方式中，决定因素是分支预测算法的操作。 使用少量数据，它可以在执行迭代时完全存储元素的顺序，因此未命中的数量少且速度高， <a href="https://lemire.me/blog/2019/10/16/benchmarking-is-hard-processors-learn-to-predict-branches/">如本注释所示</a> 。 随着数据序列大小的增加，预测算法会记住的次数越来越少，直到最终开始丢失每个大写字母（每个字符0.27个未命中），然后将图形调平。 <br><br> 其次，请注意左上方的绿色斑点组，这与具有<i>toupper_branch</i>分支的变体的较低速度相对应： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/b6/kj/by/b6kjbygj9inzadobigp0txj3vxu.png"></div><br> 这不是孤立的工件：此类斑点在几次发射中出现。 同时，如果仅针对这些数据大小测试算法，则无法复制它们-仅在对所有大小进行测试时它们才会弹出。 但是在这种情况下，它们并不总是出现。 我没有特别研究它，但是我可以假设这是由于分支预测算法中名称或别名的某些冲突或将4 KB内存的物理页面映射到虚拟时造成的（尽管虚拟地址空间的随机性已关闭）。 <br><br> 第三，图上<i>toupper_rawloop</i>的实现（以蓝色显示）看起来像两条不同的线：一条稍微高于每个字符2 <i>个小节</i>的标记，另一条位于每个字符1.5 <i>个小节</i>的水平上。 这两行出现在所有测试人员中。 速度更快的选项（每个周期1.57个字符的速度）实际上会降低下载端口的速度：在端口2和3上读取数据的速度为每个周期1.54微操作，因此它们将占98％的繁忙。 我无法确定“政权”放慢的原因。 <br><br> 当我处理这个问题时，快速的“政权”突然消失了，只有缓慢的“政权”依然存在。 也许处理器意识到我正在尝试做的事情，并秘密下载了微代码的更新程序以消除矛盾，但是我（仍然）有证据-一个带有图形的矢量图像。 <br><br> 在此示例中，我们感兴趣的是什么？ <br><br> 但是让我们感兴趣的是，具有原始循环的版本比具有<i>std :: transform</i>的版本快3-4倍：每个字符1.5-2个周期，而每个字符几个周期则为7。 <br><br> 这是怎么回事 标准算法使我失败了吗？  <i>std :: transform</i>是否有任何缺陷？ <br><br> 不完全是 更确切地说，一点也不。 <br><br> 事实证明，在<a href="">不同文件</a>中编译函数时会出现这种结果。 如果将它们放在同一文件中，则它们的性能将同样降低。 <br><br> 不，对齐与之无关。 <br><br> 但这还不是全部：带有原始循环的快速版本在单独的文件中编译时，如果仅将<i>&lt;algorithm&gt;</i>头文件附加到该文件中，则会降低速度。 是的，没错：只需连接此文件，该文件将永远不会使用，并且不会在最终目标文件中生成任何代码，并且“原始”循环的速度将降低3-4倍。 相反，如果从<i>&lt;algorithm&gt;</i>文件复制并粘贴<i>std :: transform</i>的<i>实现</i> ，但不包括此文件，则带有<i>std :: transform</i>的版本<i>将</i>加速到极限。 <br><br> 怪异并不止于此（我保证不会有更多）：包括<i>&lt;algorithm&gt;</i>文件并不总是导致所描述的效果。 如果<i>&lt;algorithm&gt;</i>早于<i>&lt;ctype.h&gt;</i>连接，则会发生速度下降，但是如果交换它们，则不会： <br><br>  <b>慢速代码：</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;algorithm&gt; #include &lt;ctype.h&gt;</span></span></span></span></code> </pre> <br>  <b>快速代码：</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ctype.h&gt; #include &lt;algorithm&gt;</span></span></span></span></code> </pre> <br> 实际上，当clang-format自动对包含的头文件进行排序并将<i>&lt;algorithm&gt;</i>放在列表所属的列表的开头时，这种异常出现在我（在另一个项目中）中（因此该文章的clickbait标题）。 <br><br> 自然，我们迟早不得不涉足汇编程序的上市。 我们不会延迟这一令人不快的时刻。 <br><br> 函数[5]的<a href="https://godbolt.org/z/DwZBJM">快速和慢速</a>版本如下所示，小循环带有注释： <br><br>  <b>&lt;algorithm&gt;首先连接：</b> <br><br><pre> <code class="cpp hljs">toupper_rawloop(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): push rbp push rbx lea rbp, [rdi+rsi] sub rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> test rsi, rsi je .L1 mov rbx, rdi .L5: movsx edi, BYTE PTR [rbx] ;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>-  *buf add rbx, <span class="hljs-number"><span class="hljs-number">1</span></span> ; buf++ call <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> ;  <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>(c) mov BYTE PTR [rbx<span class="hljs-number"><span class="hljs-number">-1</span></span>], al ;    buf[<span class="hljs-number"><span class="hljs-number">-1</span></span>] cmp rbp, rbx ;  buf == buf_end jne .L5 ; .L1: add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> pop rbx pop rbp ret</code> </pre> <br>  <b>&lt;algorithm&gt;连接第二：</b> <br><br><pre> <code class="cpp hljs">toupper_rawloop(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): test rsi, rsi je .L7 push rbp push rbx mov rbp, rsi mov rbx, rdi sub rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> call __ctype_toupper_loc lea rsi, [rbx+rbp] mov rdi, rbx .L4: ;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>-  buf movsx rcx, BYTE PTR [rdi] ;      <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> ; (   __ctype_toupper_loc) mov rdx, QWORD PTR [rax] ; buf++ add rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>  , ;       mov edx, DWORD PTR [rdx+rcx*<span class="hljs-number"><span class="hljs-number">4</span></span>] mov BYTE PTR [rdi<span class="hljs-number"><span class="hljs-number">-1</span></span>], dl ;   cmp rsi, rdi ;  buf == end_buf jne .L4 ; add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> pop rbx pop rbp .L7: rep ret</code> </pre> <br> 主要区别在于，在慢速版本中，toupper函数仅在循环中被简单地调用，而在快速版本中，函数调用完全不存在，并且在对应表中仅存在搜索[6]，即 函数<i>std :: toupper</i>的主体在调用位置<i>被</i>替换。 <br><br> 如果看一下glibc库的<a href="https://sourceware.org/git/%3Fp%3Dglibc.git%3Ba%3Dblob%3Bf%3Dctype/ctype.h%3Bh%3Dd17f727cf0dc2a0f6c62fa50aff799b175dcb426%3Bhb%3D2a764c6ee848dfe92cb2921ed3b14085f15d9e79">源代码</a> ，我们会在这里找到<i>toupper</i>函数的实现： <br><br><pre> <code class="cpp hljs">__extern_inline <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// __NTH –  , ,      __NTH (toupper (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_toupper_loc ())[__c] : __c; }</span></span></code> </pre> <br> 如我们所见， <i>toupper被</i>定义为<i>extern内联</i>函数，该函数首先检查char字符的大小是否适合一个字节[7]，然后在<i>__ctype_toupper_loc（）</i>函数返回的对应表中搜索该字符。 该函数返回一个本地流指针（类型为<i>const int **</i> ），该指针进而指向一个对应表，响应于对我们符号的请求，该表将返回其大写形式[8]。 <br><br> 现在清楚清单中正在发生什么。 在该算法的快速版本中，编译器替换了<i>toupper</i>函数的主体，但无法替换对<i>__ctype_toupper_loc（）</i>函数的调用[9]。 但是，此调用被声明为<i>__attribute __（（const））</i> ，这意味着返回值仅取决于参数（此处不存在）。 编译器知道此函数每次都返回相同的值，因此将其调用带到循环之外，并且在循环本身中，只有很少的读取操作与访问对应表，将新值写入缓冲区以及循环控制相关。 <br><br> 在慢速版本中，对<i>toupper（）</i>的调用保留在循环的主体中。 循环本身仅需一条命令即可缩短，但是，当然，现在您仍然必须执行<i>toupper</i>函数中的所有代码。 在我的系统上，它看起来像这样： <br><br><pre> <code class="cpp hljs"> lea edx,[rdi+<span class="hljs-number"><span class="hljs-number">0x80</span></span>] ; edx = rdi + <span class="hljs-number"><span class="hljs-number">0x80</span></span> movsxd rax,edi ;    c cmp edx,<span class="hljs-number"><span class="hljs-number">0x17f</span></span> ; ,  c     <span class="hljs-number"><span class="hljs-number">-128</span></span>  <span class="hljs-number"><span class="hljs-number">255</span></span> ja <span class="hljs-number"><span class="hljs-number">2</span></span>a ;  ,   mov rdx,QWORD PTR [rip+<span class="hljs-number"><span class="hljs-number">0x395f30</span></span>] ;    ;   mov rdx,QWORD PTR fs:[rdx] ;     ;     mov rdx,QWORD PTR [rdx] ;    ;    mov rdx,QWORD PTR [rdx+<span class="hljs-number"><span class="hljs-number">0x48</span></span>] ;     <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> mov eax,DWORD PTR [rdx+rax*<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">0x200</span></span>] ;  c   <span class="hljs-number"><span class="hljs-number">2</span></span>a: ret</code> </pre> <br> 由于这是非嵌入式调用，因此该程序会执行更多工作。 至少有五个连续的访问内存的操作（所谓的<i>指针追逐</i> ， <i>指针追逐</i> ）。 在快速版本中，仅剩下其中两个，因为所有其他都从循环中删除。 从调用函数到退出函数之间的延迟应该约为25个周期，并且大约有7个周期出现-这意味着处理器能够并行化调用，在这种情况下，这是相当不错的。 <br><br> 为什么会这样呢？ <br><br> 在包含文件的长长链中，C ++头文件（例如<i>&lt;algorithm&gt;）</i>依次包含<i>&lt;bits / os_defines.h&gt;</i>文件，该文件包含以下行： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      isanum  .  //   . #define __NO_CTYPE 1</span></span></code> </pre> <br> 最终连接文件<i>&lt;ctype.h&gt;时</i> ，由于此指令，不能包含将<i>toupper</i>定义为<i>extern inline</i>的代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined __NO_CTYPE # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __isctype_f __isctype_f (alnum) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  ..  .. __isctype_f (xdigit) # elif defined __isctype # define isalnum(c) __isctype((c), _ISalnum) # define isalpha(c) __isctype((c), _ISalpha) //  ..  .. # endif //      # ifdef __USE_EXTERN_INLINES __extern_inline int __NTH (tolower (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_tolower_loc ())[__c] : __c; } __extern_inline int __NTH (toupper (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_toupper_loc ())[__c] : __c; } # endif //   tolower     # if __GNUC__ &gt;= 2 &amp;&amp; defined __OPTIMIZE__ &amp;&amp; !defined __cplusplus # define tolower(c) __tobody (c, tolower, *__ctype_tolower_loc (), (c)) # define toupper(c) __tobody (c, toupper, *__ctype_toupper_loc (), (c)) # endif /* Optimizing gcc */ #endif /* Not __NO_CTYPE. */</span></span></span></span></code> </pre> <br> 请注意，连接<i>&lt;ctype.h&gt;</i>时， <i>toupper</i> <i>的</i> C ++版本永远不会定义为宏-最大值作为<i>extern</i> <i>内联</i> -因为宏的定义受<i>！Defined __cplusplus检查的</i>保护，因此永远不会生效。 <br><br> 总的来说，我不确定在这种情况下<i>__NO_CTYPE</i>是否应排除声明为<i>extern inline</i>的<i>tolower</i>和<i>toupper</i>函数的主体，但这确实是发生了-因此循环速度显着下降。 总之，我可以说，如果您包含<i>&lt;cctype&gt;</i>而不是<i>&lt;ctype.h&gt;</i> （即C ++是将函数放在<i>std :: namespace</i>中的C头文件的版本），那么在这种情况下，代码将运行缓慢因为<i>&lt;cctype&gt;</i>最终包括<i>&lt;bits / os_defines.h&gt;</i> 。 <br><br> 那重要吗？ 不不 <br><br>  <i>toupper</i>函数不适用于使用不同语言的字符的严肃工作，因此，如果您只需要处理ASCII字符，则可以编写自己的更快的实现。 如果您需要认真处理文本，则很可能会使用UTF-8，并且必须使用某种ICU来支持区域设置，或者等到C ++中出现Unicode支持（可能需要很长时间才能等待） 。 因此，“ clang-format可能导致4倍的性能下降”这样的语句仅适合用作clickbait标头。 <br><br> 在所有版本的libc中都观察到这种效果吗？ 是的，几乎所有的东西，但即使在这里，也不是那么简单。 <br><br> 上面显示的结果对于gcc 5.5和glibc 2.23是正确的，因为我使用了这些版本，但是新版本中发生了一些新变化（从glibc 2.27开始）。 在那里，在<i>&lt;ctype.h</i> <i>&gt;</i>之前打开<i>&lt;algorithm&gt;</i>仍然会产生相同的效果，但是现在<i>&lt;stdlib.h&gt;</i> [10]也会产生问题：如果在<i>&lt;ctype.h&gt;</i>之前打开它，性能也会下降，这不是在早期版本中观察到。 显然，在较新的版本中， <i>&lt;stdlib.h&gt;</i>文件还包含<i>__NO_CTYPE</i>定义。 至少，现在不可能指责clang格式进行排序-在这里它可以帮助解决问题（如果连接文件列表中没有其他问题文件）。 <br><br> 我<a href="https://sourceware.org/bugzilla/show_bug.cgi%3Fid%3D25214">在libc中</a>发布<a href="https://sourceware.org/bugzilla/show_bug.cgi%3Fid%3D25214">了一个错误报告</a> ，因此该错误很可能会得到修复，但是毫无疑问，与头文件连接顺序有关的错误将进一步困扰我们。 <br><br><h2> 留言 </h2><br> 我的网站上没有评论系统，但我正在使用它（也就是说，经常抱怨，很难在静态网站上发表评论）。 <br><br> 同时，您可以在<a href="https://news.ycombinator.com/item%3Fid%3D21579333">Hacker News</a>网站或<a href="https://lobste.rs/s/tjxzck/clang_format_tanks_performance">lobste.rs</a>上讨论此文章。 <br><br><h2> 致谢 </h2><br> 感谢Hacker News的ufo用户，他<a href="https://news.ycombinator.com/item%3Fid%3D21579483">指出</a>没有必要使用lambda函数来将<i>std :: toupper改</i>用于<i>std :: transform中</i> ，也感谢乔纳森·穆勒（Jonathan Muller），他<a href="https://twitter.com/foonathan/status/1197051249822195712">解释</a>说仍然需要lambda函数。 <br><br><ol><li> 是的， <i>&lt;ctype.h&gt;</i>头文件中的<i>toupper（3）</i>函数不适用于大多数非ASCII字符，因为 不能处理大于一个字节的字符，但是它适合我们的任务，因为我们只会将ASCII字符的字符串传递给它。 </li><li> 在ASCII表中，小写和大写字符的位置非常方便-彼此之间的距离为32个位置，这意味着您可以简单地通过将32个字符相减或相加来将字符从一种情况转移到另一种情况。通常，如果我们确定知道所有输入如果数据是ASCII字母，我们可以不进行任何检查就重置第5位（例如<i>c＆0b11011111</i> ），以便将任何大写字母都转换为小写字母，而这不会反映为小写字母。 但是我们可能不知道，所以我们必须检查字符是否为字母，以免意外破坏<i>char</i>等非字母字符。 </li><li> 应该将其称为散点图，并在点的位置上加上“噪声”。 实际上，这是一个普通的散点图，其中我们感兴趣的参数（输入数据的大小）绘制在x轴上，工作速度在y轴上（每个符号的度量- <i>值越低，速度越高</i> ）。 该图的主要特征是，对于x轴上的每个参数值，都会执行几次采样：在这种情况下，对于每种数组大小，测试都会重复10次。 </li><li> 即，字符是从[32，127]范围内随机且均匀地选择的，因此该函数中的条件在大约27％的情况下为真。 </li><li> 这两个清单均引用原始循环实现，并且仅在包含<i>&lt;algorithm&gt;</i>和<i>&lt;ctype.h&gt;文件</i>的顺序上有所不同。 所生成的源代码对于所有实现都是相同的-无论是快速版本还是慢版本。 例如，如果包含<i>&lt;algorithm&gt;</i>文件，则使用<i>std :: transform</i>的实现将生成相同的慢汇编程序代码，如果仅复制函数定义而不包含文件，则将生成相同的快速代码。 </li><li> 但是，此快速循环比它慢，因为在循环内部读取对应表的指针的次数过多（ <i>mov rdx，QWORD PTR [rax]</i> ）。 该指针可能因区域设置而异，但是在执行循环期间不会更新，因此可以将其移出循环。 一定是编译器认为没有足够的理由这样做，因为我们正在写入<i>char</i>类型的元素数组，并且它们原则上可以用作<i>[rax]的</i>别名，即 指向表的指针。 无论如何，即使<i>__restrict__</i>在这里也无济于事。 但是在另一个版本的循环中，仅添加了<i>toupper</i>值，而没有任何内容写入数组， <a href="https://godbolt.org/z/Kb6pc8">因此应用</a>了<a href="https://godbolt.org/z/Kb6pc8">这种优化</a> -在循环外部读取指针。 </li><li> 该检查未反映在可替换的汇编程序代码中，因为编译器已经知道<i>char</i>值始终在<i>[-128，255]</i>范围内。 该检查仅是必需的，因为<i>toupper©</i>函数的API接受一个<i>int</i>类型的值而不是<i>char</i> ，以便用户可以将任何熟悉的<i>int</i>类型的数传递<i>给它</i> ，而对应表仅用于<i>char</i>类型的值，因此该检查有助于避免在缓冲区外读取。 </li><li> 顺便说一句，这解释了为什么<i>std :: toupper</i>过程独立于输入数据的大小：它们不使用分支（除了范围检查，这是非常可预测的），而是使用独立于分支的对应表。  <a href="https://habr.com/ru/company/pvs-studio/blog/480012/">↵</a> </li><li> 即使有非常强烈的愿望，也无法替换此调用：该函数的主体在头文件中不可用。 </li><li> 我绝不会发现<i>stdlib.h</i> （或<i>&lt;algorithm&gt;</i> ）有问题-很有可能许多其他C头文件和所有C ++头文件也导致此现象，我只是没有对其进行测试。 我连接<i>stdlib.h</i>只是为了确定<i>size_t</i> 。 </li></ol><br>  <b>注意事项</b> 本文最初在<a href="https://travisdowns.github.io/blog/2019/11/19/toupper.html">Performance Matters</a>网站上发布。 经作者许可，翻译的文章将发布在此处。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN480012/">https://habr.com/ru/post/zh-CN480012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN480000/index.html">TCP上的服务器WebRTC通道质量指标</a></li>
<li><a href="../zh-CN480002/index.html">回顾DevOpsDays Moscow：来自6份报告的见解</a></li>
<li><a href="../zh-CN480006/index.html">服务器WebRTC over TCP的通道质量指标</a></li>
<li><a href="../zh-CN480008/index.html">尤里·罗加切夫（Yuri Rogachev）：“我来做M-1，却不了解计算机技术”</a></li>
<li><a href="../zh-CN480010/index.html">我们忘记的前3个HTML元素</a></li>
<li><a href="../zh-CN480016/index.html">39％的俄罗斯SMB公司面临针对性的网络攻击</a></li>
<li><a href="../zh-CN480018/index.html">使用Python进行移动应用开发。 KivyMD库</a></li>
<li><a href="../zh-CN480022/index.html">Python实例化</a></li>
<li><a href="../zh-CN480024/index.html">长春：单指令处理器</a></li>
<li><a href="../zh-CN480026/index.html">宣布Azure Spot虚拟机的预览</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>