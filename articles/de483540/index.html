<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ó ‚èÆÔ∏è üë©üèø‚Äçüöí ChaiScript - Skriptsprache f√ºr C ++ üëØ ‚è∞ ‚ö°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn eine Skriptsprache in ein C ++ - Projekt eingebettet werden muss, erinnern sich die meisten Menschen zun√§chst an Lua. In diesem Artikel wird es n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ChaiScript - Skriptsprache f√ºr C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483540/">  Wenn eine Skriptsprache in ein C ++ - Projekt eingebettet werden muss, erinnern sich die meisten Menschen zun√§chst an Lua.  In diesem Artikel wird es nicht darum gehen, √ºber eine andere, nicht weniger bequeme und leicht zu erlernende Sprache namens ChaiScript zu sprechen. <br><br><img src="https://habrastorage.org/webt/zh/vl/py/zhvlpyg_87wuf7gg0alk-s7qeyo.png" alt="Bild"><br><a name="habracut"></a><br><h4>  Kurze Einf√ºhrung </h4><br>  Ich selbst bin aus Versehen auf ChaiScript gesto√üen, als ich <a href="https://youtu.be/uzF4u9KgUWI">eine der Vorlesungen von</a> Jason Turner, einem der Sch√∂pfer der Sprache, sah.  Es hat mich interessiert, und in dem Moment, in dem es notwendig war, eine Skriptsprache im Projekt auszuw√§hlen, habe ich mich entschieden - warum nicht ChaiScript ausprobieren?  Das Ergebnis hat mich positiv √ºberrascht (meine pers√∂nliche Erfahrung wird n√§her am Ende des Artikels geschrieben), aber egal wie seltsam es klingt, es gab keinen einzigen Artikel im Hub, in dem diese Sprache √ºberhaupt erw√§hnt wurde, und ich habe das entschieden Es w√§re sch√∂n, √ºber ihn zu schreiben.  Nat√ºrlich verf√ºgt die Sprache √ºber eine <a href="">Dokumentation</a> und eine <a href="http://chaiscript.com/">offizielle Website</a> , aber nicht jeder wird sie anhand von Beobachtungen lesen, und das Format des Artikels kommt vielen (einschlie√ülich mir) n√§her. <br><br>  Zuerst werden wir √ºber die Syntax der Sprache und all ihre Funktionen sprechen, dann dar√ºber, wie sie in Ihrem C ++ - Projekt implementiert wird, und zum Schluss werde ich ein wenig √ºber meine Erfahrungen sprechen.  Wenn ein Teil von Ihnen nicht interessiert ist oder Sie den Artikel in einer anderen Reihenfolge lesen m√∂chten, k√∂nnen Sie das Inhaltsverzeichnis verwenden: <br><br><ul><li>  <a href="https://habr.com/ru/post/483540/">ChaiScript-Syntax</a> </li><li>  <a href="https://habr.com/ru/post/483540/">Implementierung in C ++</a> </li><li>  <a href="https://habr.com/ru/post/483540/">Pers√∂nliche Erfahrung</a> </li></ul><br><a name="syntax"></a><br><h2>  Sprachsyntax </h2><br>  ChaiScript ist in seiner Syntax C ++ und JS sehr √§hnlich.  Zun√§chst wird es, wie die meisten Skriptsprachen, dynamisch getippt, hat jedoch im Gegensatz zu JavaScript eine strikte Typisierung (Nr. <code>1 + "2"</code> ).  Es gibt auch einen integrierten Garbage Collector. Die Sprache ist vollst√§ndig interpretierbar, sodass Sie Code Zeile f√ºr Zeile ausf√ºhren k√∂nnen, ohne ihn in Bytecode zu kompilieren.  Es unterst√ºtzt Ausnahmen (au√üerdem joint, so dass Sie sie sowohl innerhalb des Skripts als auch in C ++ abfangen k√∂nnen), Lambda-Funktionen und das √úberladen von Operatoren.  Es reagiert nicht auf Leerzeichen, sodass Sie als einzelne Zeile durch ein Semikolon oder im Python-Stil schreiben und Ausdr√ºcke durch eine neue Zeile trennen k√∂nnen. <br><br><h4>  Primitive Typen </h4><br>  ChaiScript speichert Integer-Variablen standardm√§√üig als int, real als double und Strings mit std :: string.  Dies geschieht haupts√§chlich, um die Kompatibilit√§t mit dem aufrufenden Code sicherzustellen.  Die Sprache hat sogar Suffixe f√ºr Zahlen, sodass wir explizit angeben k√∂nnen, um welchen Typ es sich bei unserer Variablen handelt: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*   chaiscript    js    ,  var / auto `;`      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myInt = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">// int var myLongLong = 1ll // long long int var myFloating = 3.3 // double var myBoolean = false // bool var myString = "hello world!\n" // std::string</span></span></code> </pre><br>  Das √Ñndern des Variablentyps funktioniert einfach nicht. Wahrscheinlich m√ºssen Sie f√ºr diese Typen einen eigenen "=" - Operator definieren. Andernfalls besteht die Gefahr, dass Sie entweder eine Ausnahme ausl√∂sen (wir werden sp√§ter darauf eingehen) oder gerundet werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> integer = <span class="hljs-number"><span class="hljs-number">3</span></span> integer = <span class="hljs-number"><span class="hljs-number">5.433</span></span> print(integer) <span class="hljs-comment"><span class="hljs-comment">//  5    double    int! integer = true //   -   `=`  (int, bool)</span></span></code> </pre><br>  Sie k√∂nnen eine Variable jedoch deklarieren, ohne ihr einen Wert zuzuweisen. In diesem Fall enth√§lt sie eine Art undefiniertes Element, bis ihr ein Wert zugewiesen wird. <br><br><h4>  Inline-Container </h4><br>  Die Sprache hat zwei Container - Vector und Map.  Sie arbeiten sehr √§hnlich wie ihre Gegenst√ºcke in C ++ (std :: vector bzw. std :: map), ben√∂tigen jedoch keinen Typ, da sie jeden speichern k√∂nnen.  Die Indizierung kann wie gewohnt mit ints erfolgen, f√ºr Map ist jedoch ein Schl√ºssel mit einer Zeichenfolge erforderlich.  Anscheinend von Python inspiriert, haben die Autoren auch die M√∂glichkeit hinzugef√ºgt, Container in Code mit der folgenden Syntax schnell zu deklarieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = [ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>u, <span class="hljs-number"><span class="hljs-number">4</span></span>ll, <span class="hljs-string"><span class="hljs-string">"16"</span></span>, <span class="hljs-string"><span class="hljs-string">`+`</span></span> ] <span class="hljs-comment"><span class="hljs-comment">//      var m = [ "key1" : 1, "key2": "Bob" ]; //    - var M = Map() //    var V = Vector() //    //        C++ : v.push_back(123) //    ,     v.push_back_ref(m); // m -   //      m["key"] = 3 //       (reference assignment): m["key"] := m //      </span></span></code> </pre><br>  Beide Klassen wiederholen ihre Entsprechungen in C ++ fast vollst√§ndig, mit Ausnahme von Iteratoren, da es stattdessen spezielle Klassen Range und Const_Range gibt.  √úbrigens werden alle Container als Referenz √ºbergeben, auch wenn Sie die Zuweisung durch = verwenden, was f√ºr mich sehr seltsam ist, da bei allen anderen Typen das Kopieren nach Wert erfolgt. <br><br><h4>  Bedingte Konstruktionen </h4><br>  Fast alle Konstruktionen von Bedingungen und Zyklen lassen sich in einem Beispielcode buchst√§blich beschreiben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-comment"><span class="hljs-comment">//  if-else if (a &gt; b) { print("a &gt; b") } else if (a == b){ print("a == b") } else { print("a &lt; b") } // switch -    if- //      //  break    ,    C++ var str = "hello" switch(str) { case("hi") { print("hi!"); break; } case("hello") { print("hello!" break; } case("bye") { print("bye-bye!") break; } default { print("what have you said?") } } var x = true //     ,       while (x) { print("x was true") x = false; } //    C.        ,    ,    ,    for (var i = 0; i &lt; 10; ++i) //   -,    { print(i); //  0 ... 9  10  } // ranged-for loop for(element : [1, 2, 3, 4, 5]) { puts(element) //   12345 } //  :   C++17 if-init statements: if(var x = get_value(); x &lt; 10) { print(x) // x     if }</span></span></code> </pre><br>  Ich denke, die mit C ++ vertrauten Personen haben nichts Neues gefunden.  Dies ist nicht verwunderlich, da ChaiScript als leicht zu erlernende Sprache positioniert ist und daher alle bekannten klassischen Designs √ºbernimmt.  Die Autoren haben beschlossen, sogar zwei Schl√ºsselw√∂rter f√ºr die Deklaration von Variablen hervorzuheben - <code>var</code> und <code>auto</code> , falls Sie die Vorteile von auto wirklich m√∂gen. <br><br><h4>  Ausf√ºhrungskontext </h4><br>  ChaiScript hat einen lokalen und globalen Kontext.  Der Code wird zeilenweise von oben nach unten ausgef√ºhrt, kann aber in Funktionen herausgenommen und sp√§ter (aber nicht fr√ºher!) Aufgerufen werden.  Innerhalb von Funktionen oder Bedingungen / Schleifen deklarierte Variablen sind von au√üen standardm√§√üig nicht sichtbar. Sie k√∂nnen dieses Verhalten jedoch √§ndern, indem Sie den <code>global</code> Bezeichner anstelle von <code>var</code> .  Globale Variablen unterscheiden sich von gew√∂hnlichen insofern, als sie erstens au√üerhalb des lokalen Kontexts sichtbar sind und zweitens neu deklariert werden k√∂nnen (wenn der Wert w√§hrend der Neudeklaration nicht festgelegt wird, bleibt er gleich). <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     chaiscript def foo(x) { global G = 2 print(x) } foo(0) //  foo(x), G = 2 print(G) //  2 global G = 3 //  G = 3,   global -  !</span></span></code> </pre><br>  Wenn Sie eine Variable haben und pr√ºfen m√ºssen, ob ihr ein Wert zugewiesen wurde, verwenden Sie die <code>is_var_undef</code> Funktion <code>is_var_undef</code> , die true zur√ºckgibt, wenn die Variable nicht definiert ist. <br><br><h4>  String-Interpolation </h4><br>  <code>to_string()</code> oder Benutzerobjekte, f√ºr die eine <code>to_string()</code> -Methode <code>to_string()</code> k√∂nnen mit der Syntax <code>${object}</code> in eine Zeichenfolge <code>to_string()</code> .  Dies vermeidet unn√∂tige Verkettungen von Zeichenfolgen und sieht im Allgemeinen viel aufger√§umter aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">//  sum of 3 + 4 = 7 print("sum of ${x} + ${y} = ${x + y}")</span></span></code> </pre><br>  Vector, Map, MapPair und alle Grundelemente unterst√ºtzen diese Funktion ebenfalls.  Der Vektor wird im Format <code>[o1, o2, ...]</code> , Karte als <code>[&lt;key1, val1&gt;, &lt;key2, val2&gt;, ...]</code> und MapPair: <code>&lt;key, val&gt;</code> angezeigt. <br><br><h4>  Funktionen und ihre Nuancen </h4><br>  ChaiScript-Funktionen sind Objekte wie alles andere.  Sie k√∂nnen erfasst, Variablen zugewiesen, in anderen Funktionen verschachtelt und als Argument √ºbergeben werden.  Auch f√ºr sie k√∂nnen Sie den Typ der Eingabewerte angeben (was den dynamisch typisierten Sprachen fehlte!). Hierzu m√ºssen Sie den Typ angeben, bevor Sie den Funktionsparameter deklarieren.  Wenn der Parameter beim Aufrufen in den angegebenen Wert konvertiert werden kann, erfolgt die Konvertierung gem√§√ü den C ++ - Regeln. Andernfalls wird eine Ausnahme ausgel√∂st: <br><br><pre> <code class="javascript hljs">def adder(int x, int y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y } def adder(bool x, bool y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x || y } adder(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ,  3 adder(1.22, -3.7) // ,  1 + (-3) = 2 adder(true, true) // ,  true adder(true, 3) // ,    adder(bool, int)</span></span></code> </pre><br>  Funktionen in der Sprache k√∂nnen auch √ºber Anrufbedingungen (Call Guard) eingestellt werden.  Wird dies nicht beachtet, wird eine Ausnahme ausgel√∂st, andernfalls wird ein Anruf get√§tigt.  Ich beachte auch, dass, wenn die Funktion am Ende keine return-Anweisung hat, der letzte Ausdruck zur√ºckgegeben wird.  Sehr praktisch f√ºr kleine Routinen: <br><br><pre> <code class="javascript hljs">def div(x, y) : y != <span class="hljs-number"><span class="hljs-number">0</span></span> { x / y } <span class="hljs-comment"><span class="hljs-comment">//  `y`    -    `x`  `y` print(div(2, 0.5)) //  4.0 print(div(2, 0)) // , `y`  0!</span></span></code> </pre><br><h4>  Klassen und Dynamic_Object </h4><br>  ChaiScript hat die Grundlagen von OOP, was ein klares Plus ist, wenn Sie komplexe Objekte bearbeiten m√ºssen.  Die Sprache hat einen speziellen Typ - Dynamic_Object.  Tats√§chlich sind alle Instanzen von Klassen und Namespaces genau Dynamic_Object mit vordefinierten Eigenschaften.  Mit einem dynamischen Objekt k√∂nnen Sie ihm w√§hrend der Ausf√ºhrung des Skripts Felder hinzuf√ºgen und dann darauf zugreifen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = Dynamic_Object(); obj.x = <span class="hljs-number"><span class="hljs-number">3</span></span>; obj.f = fun(arg) { print(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x + arg); } <span class="hljs-comment"><span class="hljs-comment">//  obj   f (     `x` obj.f(-3); //  0</span></span></code> </pre><br>  Klassen werden ganz einfach definiert.  Sie k√∂nnen auf Felder, Methoden und Konstruktoren gesetzt werden.  Ab dem interessanten <code>set_explicit(object, value)</code> mit der Sonderfunktion <code>set_explicit(object, value)</code> die Felder des Objekts "reparieren", indem Sie das Hinzuf√ºgen neuer Methoden oder Attribute nach der Klassendeklaration verbieten (dies erfolgt normalerweise im Konstruktor): <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id; <span class="hljs-comment"><span class="hljs-comment">//  id def Widget() { this.id= 0 } //    def Widget(id) { this.id = id } //   1  def get_id() { id } //   } var w = Widget(10) print(w.get_id()) //  10 (w.id) print(w.get_id) //   10,        set_explicit(w, true) //    wx = 3 //      Widget   x</span></span></code> </pre><br>  Ein wichtiger Punkt: Tats√§chlich sind Klassenmethoden nur Funktionen, deren erstes Argument ein Objekt einer Klasse mit einem explizit angegebenen Typ ist.  Daher entspricht der folgende Code dem Hinzuf√ºgen einer Methode zu einer vorhandenen Klasse: <br><br><pre> <code class="javascript hljs">def set_id(Widget w, id) { w.id = id } w.set_id(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-comment"><span class="hljs-comment">// w.id = 9 set_id(w, 9) //  , w.id = 9</span></span></code> </pre><br>  Jeder, der mit C # vertraut ist, kann eine schmerzhafte Erweiterungsmethode ersetzen und ist der Wahrheit sehr nahe.  Auf diese Weise k√∂nnen Sie in der Sprache neue Funktionen auch f√ºr integrierte Klassen hinzuf√ºgen, z. B. f√ºr einen String oder eine Ganzzahl.  Die Autoren bieten auch eine knifflige M√∂glichkeit, Operatoren zu √ºberladen: Dazu m√ºssen Sie das Operator-Symbol wie im folgenden Beispiel mit einer Tilde (`) umgeben: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   +     Widget def `+`(Widget w1, Widget w2) { print("merging two widgets!") } var widget1 = Widget() var widget2 = Widget() widget1 + widget2 //      //        : var plus = `+` print(plus(1, 7)) //  8</span></span></code> </pre><br><h4>  Namespaces </h4><br>  In Bezug auf den Namespace in ChaiScript sollte beachtet werden, dass es sich im Wesentlichen um Klassen handelt, die sich immer in einem globalen Kontext befinden.  Sie k√∂nnen sie mit der <code>namespace(name)</code> Funktion <code>namespace(name)</code> erstellen und anschlie√üend die erforderlichen Funktionen und Klassen hinzuf√ºgen.  Standardm√§√üig gibt es keine Bibliotheken in der Sprache. Sie k√∂nnen sie jedoch mithilfe von Erweiterungen installieren, auf die wir sp√§ter noch eingehen werden.  Im Allgemeinen k√∂nnte die Namespace-Initialisierung folgenderma√üen aussehen: <br><br><pre> <code class="javascript hljs">namespace(<span class="hljs-string"><span class="hljs-string">"math"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    math //   math.square = fun(x) { x * x } math.hypot_squared= fun(x, y) { math.square(x) + math.square(y) } print(math.square(4)) //  16 print(math.hypot_squared(3, 4)) //  25</span></span></code> </pre><br><h4>  Lambda-Ausdr√ºcke und andere Merkmale </h4><br>  Lambda-Ausdr√ºcke in ChaiScript √§hneln dem, was wir aus C ++ kennen.  F√ºr sie wird das Schl√ºsselwort <b>fun</b> verwendet. Au√üerdem m√ºssen die erfassten Variablen explizit angegeben werden. Dies geschieht jedoch immer anhand von Verweisen.  Die Sprache verf√ºgt auch √ºber eine Bindefunktion, mit der Sie Werte an Funktionsparameter binden k√∂nnen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func_object = fun(x) { x * x } func_object(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  81 var name = "John" var greet = fun[name]() { "Hello, " + name } print(greet()) //  Hello, John name = "Bob" print(greet()) //  Hello, Bob var message = bind(fun(msg, name) { msg + " from " + name }, _, "ChaiScript"); print(message("Hello")) //  Hello from ChaiScript</span></span></code> </pre><br><h4>  Ausnahmen </h4><br>  W√§hrend der Skriptausf√ºhrung k√∂nnen Ausnahmen auftreten.  Sie k√∂nnen sowohl in ChaiScript selbst (das wir hier diskutieren) als auch in C ++ abgefangen werden.  Die Syntax ist absolut identisch mit Pluszeichen. Sie k√∂nnen sogar eine Zahl oder eine Zeichenfolge ausgeben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(x + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// x   } catch (e) { print("Error during evaluation")) } //   C++   ChaiScript //   Vector -   std::vector,    std::exception      try { var vec = [1, 2] var val = vec[3] //     } catch (e) { print("index out of range: " + e.what()); // e.what    ChaiScript } //  atch   guard     ,    `:` try { throw(5.2) } catch(e) : is_type(e, "int") { print("Int: ${e}"); //   `e`  int } catch(e) : is_type(e, "double") { print("Double: ${e}"); //  `e`  double }</span></span></code> </pre><br>  Auf eine gute Weise sollten Sie Ihre Klasse von Ausnahmen definieren und sie ausl√∂sen.  Wir werden im zweiten Abschnitt dar√ºber sprechen, wie man es in C ++ abf√§ngt.  F√ºr Interpreter-Ausnahmen gibt ChaiScript Ausnahmen aus, wie eval_error, bad_boxed_cast usw. <br><br><h4>  Interpreter-Konstanten </h4><br>  Zu meiner √úberraschung stellte sich heraus, dass es sich bei der Sprache um eine Art Compiler-Makro handelte - es gibt nur vier davon und alle dienen zur Identifizierung des Kontexts und werden haupts√§chlich zur Fehlerbehandlung verwendet: <br><div class="scrollable-table"><table><tbody><tr><td>  __LINE__ </td><td>  aktuelle Zeile, wenn der Code nicht aus einer Datei ausgef√ºhrt wird, dann '1' </td></tr><tr><td>  __FILE__ </td><td>  Aktuelle Datei, wenn der Code nicht aus einer Datei aufgerufen wird, dann "__EVAL__" </td></tr><tr><td>  __CLASS__ </td><td>  aktuelle Klasse oder "NOT_IN_CLASS" </td></tr><tr><td>  __FUNC__ </td><td>  aktuelle Funktion oder "NOT_IN_FUNCTION" </td></tr></tbody></table></div><br><h4>  Fehler beim √úberf√ºllen </h4><br>  Wenn die aufgerufene Funktion nicht deklariert wurde, wird eine Ausnahme ausgel√∂st.  Wenn dies f√ºr Sie nicht akzeptabel ist, k√∂nnen Sie eine spezielle Funktion definieren - <code>method_missing(object, func_name, params)</code> , die im Fehlerfall mit den entsprechenden Argumenten aufgerufen wird: <br><br><pre> <code class="javascript hljs">def method_missing(Widget w, string name, Vector v) { print(<span class="hljs-string"><span class="hljs-string">"widget method ${name} with params {v} was not found"</span></span>) } w = Widget() w.invoke_error(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  widget method invoke_error with params [1, 2, 3] was not found</span></span></code> </pre><br><h4>  Eingebaute Funktionen </h4><br>  ChaiScript definiert viele integrierte Funktionen, und in dem Artikel m√∂chte ich auf besonders n√ºtzliche Funktionen eingehen.  Darunter: <code>eval(str)</code> , <code>eval_file(filename)</code> , <code>to_json(object)</code> , <code>from_json(str)</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">"x * y"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// res = 15,  eval     //     : //  eval_file eval_file("source.chai") //   use,  ,         use("source.chai") // to_json    Map    var w = Widget(0) var j = to_json(w) // j = "{ "id" : 0 }" // from_json    Map ( ,   ) var m = from_json(" { "x": 0, "y": 3, "z": 2 }") print(m) //  Map  [&lt;x, 0&gt;, &lt;y, 3&gt;, &lt;z, 2&gt;]</span></span></code> </pre><br><a name="cppchai"></a><br><h2>  Implementierung in C ++ </h2><br><h4>  Installation </h4><br>  ChaiScript ist eine auf C ++ - Vorlagen basierende Bibliothek, die nur auf Headern basiert.  Dementsprechend m√ºssen Sie f√ºr die Installation nur ein Klon- <a href="https://github.com/ChaiScript/ChaiScript">Repository</a> erstellen oder alle Dateien aus <a href="https://github.com/ChaiScript/ChaiScript/tree/develop/include/chaiscript">diesem Ordner</a> in Ihr Projekt einf√ºgen.  Da dies alles je nach IDE unterschiedlich <code>#include &lt;chaiscript/chaiscript.hpp&gt;</code> und in den Foren lange Zeit ausf√ºhrlich beschrieben wurde, gehen wir davon aus, dass Sie die Verbindung zur Bibliothek hergestellt haben und der Code mit include: <code>#include &lt;chaiscript/chaiscript.hpp&gt;</code> kompiliert wurde. <br><br><h4>  Aufruf von C ++ - Code und Laden von Skripten </h4><br>  Der kleinste Beispielcode, der ChaiScript verwendet, ist wie folgt.  Wir definieren eine einfache Funktion in C ++, die std :: string verwendet und den ge√§nderten String zur√ºckgibt, und f√ºgen dann im ChaiScript-Objekt einen Link hinzu, um ihn aufzurufen.  Das Kompilieren kann viel Zeit in Anspruch nehmen, ist jedoch in erster Linie darauf zur√ºckzuf√ºhren, dass das Instanziieren einer gro√üen Anzahl von Vorlagen f√ºr den Compiler nicht einfach ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;chaiscript/chaiscript.hpp&gt; std::string greet_name(const std::string&amp; name) { return "hello, " + name; } int main() { chaiscript::ChaiScript chai; //  chaiscript chai.add(chaiscript::fun(&amp;greet_name), "greet"); //    greet //  eval      chai.eval(R"( print(greet("John")); )"); }</span></span></span></span></code> </pre> <br>  Ich hoffe es ist Ihnen gelungen und Sie haben das Ergebnis der Veranstaltung gesehen.  Ich m√∂chte gleich eine Nuance notieren - wenn Sie ein ChaiScript-Objekt als statisch deklarieren, erhalten Sie einen unangenehmen Laufzeitfehler.  Dies liegt an der Tatsache, dass die Sprache standardm√§√üig Multithreading unterst√ºtzt und lokale Ablaufvariablen speichert, auf die in ihrem Destruktor zugegriffen wird.  Sie werden jedoch zerst√∂rt, bevor der Destruktor der statischen Instanz aufgerufen wird. Infolgedessen liegt eine Zugriffsverletzung oder ein Segmentierungsfehler vor.  Basierend auf dem <a href="https://github.com/ChaiScript/ChaiScript/issues/338">Problem bei Github</a> besteht die einfachste L√∂sung darin, " <b><code>#define CHAISCRIPT_NO_THREADS</code></b> in den Compilereinstellungen oder vor dem Einschlie√üen der Bibliotheksdatei zu definieren und dadurch das Multithreading zu deaktivieren.  Soweit ich wei√ü, konnte dieser Fehler nicht behoben werden. <br><br>  Nun werden wir im Detail analysieren, wie die Interaktion zwischen C ++ und ChaiScript abl√§uft.  Die Bibliothek definiert eine spezielle Schablonenfunktion <code>fun</code> , die einen Zeiger auf eine Funktion, einen Funktor oder einen Zeiger auf eine Klassenvariable nehmen und dann ein spezielles Objekt zur√ºckgeben kann, das den Status speichert.  Als Beispiel definieren wir die Widget-Klasse in C ++ und versuchen, sie auf verschiedene Arten mit ChaiScript zu verkn√ºpfen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Widget&amp; w)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"widget #"</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.GetId()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget  C++  chai.add(chaiscript::fun([&amp;w] { return w; }), "get_widget"); //         chai.add(chaiscript::fun(ToString), "to_string"); //   chai.add(chaiscript::fun(&amp;Widget::GetId), "get_id"); //   //    ,   Widget    GetId,    to_string,    chai.eval(R"( var w = get_widget() print(w.get_id) //  2 print(w) //  widget #2 )"); }</span></span></code> </pre><br>  Wie Sie sehen, arbeitet ChaiScript absolut ruhig mit C ++ - Klassen, die ihm unbekannt sind, und kann deren Methoden aufrufen.  Wenn Sie irgendwo im Code einen Fehler machen, wird das Skript h√∂chstwahrscheinlich eine Ausnahme von der Art <code>error in function dispatch</code> , die √ºberhaupt nicht kritisch ist.  Es k√∂nnen jedoch nicht nur Funktionen importiert werden, sondern es wird auch gezeigt, wie Sie einem Skript mithilfe der Bibliothek eine Variable hinzuf√ºgen.  W√§hlen Sie dazu die Aufgabe etwas schwieriger aus - importieren Sie std :: vector &lt;Widget&gt;.  Die Funktion <code>chaiscript::var</code> und die Methode <code>add_global</code> helfen uns dabei.  Wir werden auch das √∂ffentliche <code>Data</code> zu unserem Widget hinzuf√ºgen, um zu sehen, wie das Klassenfeld importiert wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Data = <span class="hljs-number"><span class="hljs-number">0</span></span>; Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Widget&amp; w)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"widget #"</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.GetId()) + <span class="hljs-string"><span class="hljs-string">" with data: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.Data); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Widget&gt; W; <span class="hljs-comment"><span class="hljs-comment">//    Widget W.emplace_back(1); W.emplace_back(2); W.emplace_back(3); chai.add(chaiscript::fund(ToString), "to_string"); chai.add(chaiscript::fun(&amp;Widget::Data), "data"); //     //     ChaiScript chai.add_global(chaiscript::var(std::ref(W)), "widgets"); //     std::ref chai.add(chaiscript::fun(&amp;std::vector&lt;Widget&gt;::size), "size"); //   // .        using IndexFuncType = Widget&amp; (std::vector&lt;Widget&gt;::*)(const size_t); chai.add(chaiscript::fun(IndexFuncType(&amp;std::vector&lt;Widget&gt;::operator[])), "[]"); chai.eval(R"( for(var i = 0; i &lt; vec.size; ++i) { vec[i].data = i * 2; print(vec[i]) } )"); }</span></span></code> </pre><br>  Der obige Code zeigt <b><code>widget #1 with data: 0</code></b> : <b><code>widget #1 with data: 0</code> , <code>widget #2 with data: 2</code> , <code>widget #3 with data: 4</code></b> .  Wir haben dem Klassenfeld in ChaiScript einen Zeiger hinzugef√ºgt, und da sich herausstellte, dass das Feld ein primitiver Typ ist, √§ndern wir seinen Wert.  Es wurden auch mehrere Methoden hinzugef√ºgt, um mit <code>std::vector</code> , einschlie√ülich <code>operator[]</code> .  Diejenigen, die mit STL vertraut sind, wissen, dass <code>std::vector</code> zwei Indizierungsmethoden hat - eine gibt eine konstante Verkn√ºpfung zur√ºck, die andere eine einfache Verkn√ºpfung.  Aus diesem Grund m√ºssen Sie f√ºr √ºberladene Funktionen deren Typ explizit angeben, da sonst Mehrdeutigkeiten auftreten und der Compiler einen Fehler ausl√∂st. <br><br>  Die Bibliothek bietet mehrere weitere Methoden zum Hinzuf√ºgen von Objekten, die jedoch fast alle identisch sind. Daher sehe ich keinen Sinn darin, sie im Detail zu betrachten.  Als kleinen Hinweis ist hier der folgende Code: <br><br><pre> <code class="cpp hljs">chai.add(chaiscript::var(x), <span class="hljs-string"><span class="hljs-string">"x"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// x   ChaiScript chai.add(chaiscript::var(std::ref(x), "x"); //  ,    C++  ChaiScript auto shared_x = std::make_shared&lt;int&gt;(5); chai.add(chaiscript::var(shared_x), "x"); // shared_ptr      C++  ChaiScript chai.add(chaiscript::const_var(x), "x"); //   ChaiScript    chai.add_global_const(chaiscript::const_var(x), "x"); // global const . ,  x   chai.add_global(chaiscript::var(x), "x"); // global , .  x   chai.set_global(chaiscript::var(x), "x"); //   global ,    const</span></span></code> </pre><br><h4>  Verwendung von AWL-Containern </h4><br>  Wenn Sie STL-Container mit <b>primitiven</b> Typen an ChaiScript √ºbergeben m√∂chten, k√∂nnen Sie Ihrem Skript eine Instanziierung f√ºr Vorlagencontainer hinzuf√ºgen, damit Sie nicht f√ºr jeden Typ Methoden importieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyVector = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt;; MyVector V; V.emplace_back(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"John"</span></span>); V.emplace_back(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    - vector  pair chai.add(chaiscript::bootstrap::standard_library::vector_type&lt;MyVector&gt;("MyVec")); chai.add(chaiscript::bootstrap::standard_library::pair_type&lt;MyVector::value_type&gt;("MyVecData")); chai.add(chaiscript::var(std::ref(V)), "vec"); chai.eval(R"( for(var i = 0; i &lt; vec.size; ++i) { print(to_string(vec[i].first) + " " + vec[i].second) } )");</span></span></code> </pre> <br>       ChaiScript,     .  ,        STL-,       .   c <code>std::vector&lt;Widget&gt;</code> ,  , ,   ChaiScript        <code>vector_type</code> ,    Widget  . <br><br><h4> ++   ChaiScript </h4><br>            ChaiScript,      .  ,   .      Widget      WindowWidget,         ,       : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WindowWidget</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Widget { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Size; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WindowWidget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height) : Widget(id), Size(width, height) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWidth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size.first; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size.second; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//   Widget    chai.add(chaiscript::user_type&lt;Widget&gt;(), "Widget"); chai.add(chaiscript::constructor&lt;Widget(int)&gt;(), "Widget"); //   WindowWidget    chai.add(chaiscript::user_type&lt;WindowWidget&gt;(), "WindowWidget"); chai.add(chaiscript::constructor&lt;WindowWidget(int, int, int)&gt;(), "WindowWidget"); // ,  Widget -    WindowWidget chai.add(chaiscript::base_class&lt;Widget, WindowWidget&gt;()); //   Widget  WindowWidget chai.add(chaiscript::fun(&amp;Widget::GetId), "get_id"); chai.add(chaiscript::fun(&amp;WindowWidget::GetWidth), "width"); chai.add(chaiscript::fun(&amp;WindowWidget::GetHeight), "height"); //  WindowWidget     chai.eval(R"( var window = WindowWidget(1, 800, 600) print("${window.width} * ${window.height}") print("widget.id is ${window.get_id}") )"); }</span></span></code> </pre><br>    ChaiScript  ,    C++  ,     .   -          (,      ),      ,          <code>std::vector&lt;Widget&gt;</code> . <br><br><h4>        </h4><br>              .     ChaiScript    ,   ,        : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; w.Data = <span class="hljs-number"><span class="hljs-number">4444</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget w chai.add(chaiscript::fun(&amp;Widget::GetId, &amp;w), "widget_id"); chai.add(chaiscript::fun(&amp;Widget::Data, &amp;w), "widget_data"); chai.eval(R"( print(widget_id) print(widget_data) )");</span></span></code> </pre><br>     ¬´¬ª   C++  ChaiScript ( , vec3, complex, matrix)          .  ChaiScript      <code>type_conversion</code>   .     Complex    int  double    : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Complex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Re, Im; Complex(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> re, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> im = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) : Re(re), Im(im) { } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//  Complex,   re, im,    `=` chai.add(chaiscript::user_type&lt;Complex&gt;(), "Complex"); chai.add(chaiscript::bootstrap::standard_library::assignable_type&lt;Complex&gt;("Complex")); chai.add(chaiscript::constructor&lt;Complex(float, float)&gt;(), "Complex"); chai.add(chaiscript::fun(&amp;Complex::Re), "re"); chai.add(chaiscript::fun(&amp;Complex::Im), "im"); //     double  int  Complex chai.add(chaiscript::type_conversion&lt;int, Complex&gt;()); chai.add(chaiscript::type_conversion&lt;double, Complex&gt;()); //     `+`    chai.eval(R"( def `+`(Complex c, x) { var res = Complex(0, 0) res.re = c.re + x.re res.im = c.im + x.im return res } var c = Complex(1, 2) c = c + 3 print("${c.re} + ${c.im}i") )"); // : `4 + 2i` }</span></span></code> </pre><br>  ,        C++,       ChaiScript.   ,         .       ,        <code>type_conversion</code> .      . <br><br>      Vector  Map ChaiScript'    .      <code>vector_conversion</code>  <code>map_conversion</code> . <br><br><h4>    ChaiScript </h4><br>  <code>eval</code>  <code>eval_file</code>         <code>Boxed_Value</code> .         C++,        ,     <code>boxed_cast&lt;T&gt;</code> .     ,   ,    <code>bad_boxed_cast</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       double d = chai.eval&lt;double&gt;("5.3 + 2.1"); //     Boxed_Value,     auto v = chai.eval("5.3 + 2.1"); double d = chai.boxed_cast&lt;double&gt;(v);</span></span></code> </pre><br>      ChaiScript    shared_ptr,            .      shared_ptr    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = chai.eval&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;&gt;(<span class="hljs-string"><span class="hljs-string">"var x = 3.2"</span></span>);</code> </pre><br> ,        shared_ptr,     access violation  ,           . <br><br>     ,     ChaiScript     ,    ChaiScript.  ,      Complex           : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> printComplex = chai.eval&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(Complex)&gt;&gt;(<span class="hljs-string"><span class="hljs-string">R"( fun(Complex c) { print("${c.re} + ${c.im}i"); } )"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   ,      C++ printComplex(Complex(2, 3)); //  chaiscript,  `2 + 3i`</span></span></code> </pre><br><h4>    ChaiScript </h4><br>        ,    .  <code>eval_error</code>    , <code>bad_boxed_cast</code> ,        <code>std::exception</code>   .        ,        ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Data; MyException(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data) : <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(<span class="hljs-string"><span class="hljs-string">"MyException"</span></span>), Data(data) { } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//      chaiscript chai.add(chaiscript::user_type&lt;MyException&gt;(), "MyException"); chai.add(chaiscript::constructor&lt;MyException(int)&gt;(), "MyException"); try { //          chai.eval("throw(MyException(11111))", chaiscript::exception_specification&lt;MyException, std::exception&gt;()); } catch (MyException&amp; e) { std::cerr &lt;&lt; e.Data; //   `11111` } catch (chaiscript::exception::eval_error&amp; e) { std::cerr &lt;&lt; e.pretty_print(); } catch(std::exception&amp; e) { std::cerr &lt;&lt; e.what(); } }</span></span></code> </pre><br>    ,       C++.   <code>pretty_print</code> ,  <code>eval_error</code>     ,    ,  ,  ,              . <br><br><h4>  ChaiScript </h4><br>  ,   ChaiScript       .  ,     , -,  .         -    <a href="https://github.com/ChaiScript/ChaiScript_Extras">ChaiScript Extras</a> ,      .     <b>math</b>   acos(x): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chaiscript/chaiscript.hpp&gt; #include &lt;chaiscript/extras/math.hpp&gt; int main() { chaiscript::ChaiScript chai; //   auto mathlib = chaiscript::extras::math::bootstrap(); chai.add(mathlib); std::cout &lt;&lt; chai.eval&lt;double&gt;("acos(0.5)"); // ~1.047 }</span></span></span></span></code> </pre><br>           .    ,       math     .  ,     C++    ,   ,      . <br><a name="myexp"></a><br><h2>   </h2><br>      3D-  OpenGL    ,          ,         .      <a href="https://github.com/MomoDeve/MSL"></a> , ,  , ¬´    ¬ª,      . <br><br>      ,  ChaiScript      ,         Lua.      ,        ,       :  ,         C++  C,      -  C-style . ,        ,     . <br><br>        ,         .            ImGui,     chaiscript.               ,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      3D-: // rotation CHAI_IMPORT(&amp;GLInstance::RotateX, rotate_x); CHAI_IMPORT(&amp;GLInstance::RotateY, rotate_y); CHAI_IMPORT(&amp;GLInstance::RotateZ, rotate_z); // scale CHAI_IMPORT((GLInstance&amp;(GLInstance::*)(float))&amp;GLInstance::Scale, scale); CHAI_IMPORT((GLInstance&amp;(GLInstance::*)(float, float, float))&amp;GLInstance::Scale, scale); // translation CHAI_IMPORT(&amp;GLInstance::Translate, translate); CHAI_IMPORT(&amp;GLInstance::TranslateX, translate_x); CHAI_IMPORT(&amp;GLInstance::TranslateY, translate_y); CHAI_IMPORT(&amp;GLInstance::TranslateZ, translate_z); // hide / show CHAI_IMPORT(&amp;GLInstance::Hide, hide); CHAI_IMPORT(&amp;GLInstance::Show, show); // getters CHAI_IMPORT(&amp;GLInstance::GetTranslation, translation); CHAI_IMPORT(&amp;GLInstance::GetRotation, rotation); CHAI_IMPORT(&amp;GLInstance::GetScale, scale);</span></span></code> </pre><br>       ,      -,     .        : <br><br><img src="https://habrastorage.org/webt/rl/bo/td/rlbotdpcfl4pdpbplwxfrvsk73i.png" alt="Bild"><br> <i>  chaiscript  ImGui:      </i> <br><br>     ,            . , Lua      ,       ,          (JIT     ),     ChaiScript    .      ,    ,      . <br><br>         .           C++ (  Lua   ),         ChaiScript    .         .    . <br><br><h4>   </h4><br><ul><li>   ChaiScript: <a href="http://chaiscript.com/">chaiscript.com</a> </li><li>      : <a href="">ChaiScript cheatsheet</a> </li><li>  : <a href="https://codedocs.xyz/ChaiScript/ChaiScript/">codedocs.xyz/ChaiScript/ChaiScript</a> </li><li>     ChaiScript: <a href="https://github.com/MomoDeve/MomoEngine">github.com/MomoDeve/MomoEngine</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483540/">https://habr.com/ru/post/de483540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483528/index.html">Die REST-API muss auf Hypertext basieren</a></li>
<li><a href="../de483530/index.html">Wie wir ein Brettspiel gemacht haben. Warum und warum?</a></li>
<li><a href="../de483532/index.html">DefCon 27-Konferenz: Hinter den Kulissen der Erstellung elektronischer Ausweise Teil 1</a></li>
<li><a href="../de483536/index.html">Die Geschichte des Mikroprozessors und des Personalcomputers: 1974 - 1980</a></li>
<li><a href="../de483538/index.html">Anschlie√üen eines 10 "ER-TFT101-1-Displays an den STM32F429 √ºber FMC</a></li>
<li><a href="../de483542/index.html">Telecom Digest - Materialien √ºber die Arbeit der Anbieter</a></li>
<li><a href="../de483544/index.html">Neue Daten widerlegen die Schl√ºsselannahme von Dunkler Energie</a></li>
<li><a href="../de483550/index.html">Service- und IaaS-Entwicklung: Eine Zusammenstellung von Cloud, Datenspeicher und 1cloud Evolution</a></li>
<li><a href="../de483552/index.html">MVVM und Auswahl von Elementen im Adapter</a></li>
<li><a href="../de483554/index.html">Neue Technologieplattform der 20er Jahre. Warum ich mit Zuckerberg nicht einverstanden bin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>