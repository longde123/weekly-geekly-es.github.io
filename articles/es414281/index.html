<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÑ üïñ üçô Desarrollo de un veloc√≠metro de bicicleta basado en una pantalla de Nokia 3310 ü•Ö üèª üìÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, los llamados veloc√≠metros digitales para bicicletas (ciclocomputadores) se han generalizado entre los accesorios para bicicletas. Estos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de un veloc√≠metro de bicicleta basado en una pantalla de Nokia 3310</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414281/">  Recientemente, los llamados veloc√≠metros digitales para bicicletas (ciclocomputadores) se han generalizado entre los accesorios para bicicletas.  Estos dispositivos son capaces de medir muchos par√°metros, los principales son la velocidad y la distancia.  El principio de medir la velocidad se basa en el c√°lculo del per√≠odo de revoluci√≥n de la rueda, y la distancia se calcula sobre la base de medir el n√∫mero de tales revoluciones.  A menudo, el sensor de revoluci√≥n de la rueda es un interruptor de l√°minas junto con un im√°n en el radio de la rueda.  Dependiendo de la funcionalidad, el precio de tales dispositivos var√≠a ampliamente.  El veloc√≠metro de bicicleta m√°s barato se puede comprar por aproximadamente 500 p. <br><br>  Siempre tuve el deseo de tener un dispositivo similar.  Al mismo tiempo, formul√© una serie de requisitos propios que deber√≠a satisfacer.  En primer lugar, realmente quer√≠a ver un gr√°fico de los cambios de velocidad dependiendo de la distancia o el tiempo acumulado durante un corto per√≠odo a medida que se mueve.  Y tambi√©n, para registrar (registrar) mediciones en un dispositivo de almacenamiento para una mayor transferencia de datos estad√≠sticos a una computadora, su visualizaci√≥n m√°s detallada.  Los modelos baratos no cumplen completamente con mis requisitos, pero no quiero pagar de m√°s por modelos caros. <br><a name="habracut"></a><br>  Basado en lo anterior, decid√≠ crear mi propio veloc√≠metro para bicicleta basado en el microcontrolador ATmega8.  Hubo muchas preguntas, en particular sobre los perif√©ricos utilizados.  Accidentalmente me top√© con art√≠culos sobre el uso de la pantalla del tel√©fono m√≥vil Nokia 3310. Una vez que le√≠ la hoja de datos y me asegur√© de que fuera f√°cil de operar, no tuve dudas de que el veloc√≠metro se fabricar√≠a en el cuerpo del tel√©fono mencionado con su propia pantalla.  El caso es bastante bueno, y el dispositivo en s√≠ no es dif√≠cil de encontrar. <br><br><img src="https://habrastorage.org/webt/co/vu/d2/covud2fzqkaw8fiojo2mes8xfl4.png"><br><br>  Como ROM para registrar estad√≠sticas de medici√≥n, decid√≠ poner una ROM 24XX512 cl√°sica (512 Kbps), que se controla a trav√©s de la interfaz I2C.  No me molest√© con el uso de una tarjeta de memoria SD / MMC.  Otra funci√≥n importante en el dispositivo es el reloj.  Sirven para vincular algunos par√°metros espec√≠ficos medidos (por ejemplo, velocidad m√°xima) a la fecha y la hora, y tambi√©n son necesarios para registrar marcas de tiempo en las estad√≠sticas.  Como reloj, utilic√© un chip de reloj en tiempo real (RTC) separado del microcontrolador, que tiene energ√≠a de bater√≠a independiente y tambi√©n se comunica con el controlador a trav√©s de I2C. <br><br>  Implement√© requisitos secundarios adicionales en la funcionalidad del dispositivo en la etapa de redacci√≥n del programa.  Esto incluye todo tipo de problemas organizativos: la cantidad de botones involucrados, la ubicaci√≥n en la pantalla de varios elementos, la navegaci√≥n en la interfaz, etc.  En t√©rminos de navegaci√≥n, decid√≠ de antemano no complicar el programa, por ejemplo, no implementar el men√∫ de configuraci√≥n, en particular, la configuraci√≥n de fecha y hora.  El reloj se configura una vez.  El reloj funciona independientemente en el chip RTC, gracias a un cuarzo de 32.768 KHz y una bater√≠a que dura mucho tiempo.  La configuraci√≥n de fecha y hora se realiza a trav√©s de la interfaz UART del veloc√≠metro, conectada al puerto COM de la computadora con un solo clic.  A trav√©s de la misma interfaz, se supon√≠a que deb√≠a leer datos estad√≠sticos desde la ROM a una computadora.  Para todo esto, debe escribir el programa apropiado para la computadora.  Sin embargo, como lo demostr√≥ la pr√°ctica adicional, este √∫ltimo tuvo que ser abandonado.  En primer lugar, estaba el problema de implementar la recepci√≥n de datos desde el controlador a la computadora en la etapa de escribir un programa de computadora.  Y, a√∫n m√°s significativamente, el volumen del programa para el controlador aument√≥.  Fue mucho m√°s interesante colocar la ROM (en el SMIC que aloja SOIC-8) en una plataforma extra√≠ble, acorde con la tarjeta SIM, y usar la ranura libre adecuada en el tel√©fono m√≥vil.  Para hacer esto, es necesario fabricar un lector de ROM basado en un lector de SIM de acuerdo con uno de los esquemas bien conocidos del programador de ROM I2C.  Como result√≥ m√°s tarde, esta decisi√≥n no caus√≥ inconvenientes innecesarios. <br><br>  Otra cuesti√≥n importante es la salida de informaci√≥n simb√≥lica (incluida la digital) en una pantalla gr√°fica.  Esto requiere informaci√≥n gr√°fica sobre un s√≠mbolo en particular.  Esta informaci√≥n est√° estrechamente relacionada con un par√°metro como el tama√±o de la fuente mostrada.  Para mostrar el par√°metro principal, la velocidad de movimiento, para una buena claridad, es conveniente utilizar una fuente grande.  Sin embargo, como se mostrar√° m√°s adelante, dicha informaci√≥n gr√°fica sobre diez d√≠gitos no cabe en la memoria de MK, y el uso de la misma ROM externa m√°s amplia disminuir√° la velocidad de dibujo de la fuente.  Decid√≠ usar una fuente con una altura de 8 puntos como la fuente m√°s grande.  Extraje la informaci√≥n gr√°fica de esta fuente del archivo "8X8.FNT" de alg√∫n programa de MS DOS, despu√©s de haber desentra√±ado su estructura y realizado un procesamiento adicional. <br><br><img src="https://habrastorage.org/webt/wu/eo/ft/wueoftqpob-qnbg5kpd3phvlfes.png"><br><br>  Como result√≥ m√°s tarde en la pr√°ctica, este tama√±o es suficiente para la claridad de la velocidad.  Como el tama√±o de la fuente adicional, eleg√≠ el tama√±o 3x5 y dibuj√© independientemente los gr√°ficos para los n√∫meros de este tama√±o.  Estos n√∫meros peque√±os muestran par√°metros adicionales: fecha / hora, velocidad media y m√°xima, ruta. <br><br>  La informaci√≥n gr√°fica de ambas fuentes se almacena en ciertas matrices bidimensionales.  Cada elemento de la matriz, de 1 byte de tama√±o, denota la distribuci√≥n de p√≠xeles de una columna particular de un d√≠gito espec√≠fico.  Para letra grande, se asignan 8 columnas para cada d√≠gito, y 3 para 3. Para la letra peque√±a, tama√±o 3X5, la altura formal no es 5, sino 8 puntos (redondeado a un byte).  Esto le permite preorganizar la ubicaci√≥n de la fuente de 5 posiciones dentro del √°rea de 8 posiciones en la direcci√≥n vertical utilizando uno de los 4 m√©todos posibles.  Estos hechos se muestran bien en la figura a continuaci√≥n, que demuestra el modelado de gr√°ficos para los primeros dos d√≠gitos de esta fuente.  Excel es conocido por modelar.  Los datos iniciales son la disposici√≥n de "unidades" en los campos apropiados para los gr√°ficos deseados.  De estos, las f√≥rmulas calculan los valores de las matrices, hasta el c√≥digo del lenguaje C, que luego se puede copiar en el texto del programa para el microcontrolador. <br><br><img src="https://habrastorage.org/webt/fh/ls/ov/fhlsov48egokegrdbnlteowsxh0.png"><br><br>  Ahora hablaremos sobre las caracter√≠sticas de control de la pantalla utilizada.  Esta pantalla es monocrom√°tica y sus dimensiones son 84 por 48 p√≠xeles.  El control de visualizaci√≥n desde el MK se realiza a trav√©s de la interfaz SPI.  Los bytes transmitidos por SPI se interpretan en la pantalla en dos modos: bytes para visualizaci√≥n y bytes de comandos de configuraci√≥n.  El MK establece estos modos para un pin de pantalla espec√≠fico (D / C).  Se proporciona una lista completa de comandos en la hoja de datos en la pantalla.  Algunos de estos comandos se usan en mi dispositivo y se usan para inicializar la pantalla cuando se aplica energ√≠a al dispositivo: coeficiente de temperatura, contraste, modo de dibujo secuencial (horizontal o vertical), etc.  Noto de inmediato que se aplica el modo de dibujo horizontal.  Esto significa que cuando se transfiere un byte en el modo de visualizaci√≥n, la direcci√≥n aumenta autom√°ticamente una l√≠nea por l√≠nea a la derecha.  Cuando finaliza la l√≠nea, la direcci√≥n de la posici√≥n va al comienzo de la siguiente l√≠nea.  Es suficiente enviar primero un comando de posicionamiento especial a la pantalla a una direcci√≥n espec√≠fica de fila y columna (posici√≥n inicial), y luego enviar bytes de datos secuencialmente uno tras otro para mostrar gr√°ficos.  Vale la pena se√±alar la caracter√≠stica del espacio de direcciones y la interpretaci√≥n de los gr√°ficos, dependiendo de los bytes recibidos por la pantalla.  Observo que para los gr√°ficos monocromos, un byte contiene informaci√≥n sobre ocho p√≠xeles a la vez. <br><br>  La pantalla en cuesti√≥n se divide verticalmente en 6 zonas horizontales con 8 l√≠neas cada una (6 * 8 = 48).  Cada columna de cada zona corresponder√° a un byte espec√≠fico, que se env√≠a con la direcci√≥n de la columna correspondiente (0 ... 83) y el n√∫mero de zona (0 ... 5).  La direcci√≥n no se cuenta desde uno, desde cero.  Por ejemplo, si se posiciona en la direcci√≥n (34; 2) y env√≠a un byte de datos de 255 (en forma binaria "11111111"), los 8 p√≠xeles se iluminar√°n de 16 a 23 verticalmente y en la 35a columna horizontalmente.  En mi opini√≥n, uno de los inconvenientes se deriva de esta caracter√≠stica: la incapacidad de controlar el estado de cada p√≠xel individualmente a nivel de hardware.  Un byte es la pieza m√°s peque√±a de datos para gr√°ficos.  Cuando se transmite un byte a la direcci√≥n actual, se actualizan los 8 p√≠xeles correspondientes en la zona actual.  La pantalla no admite la lectura de la informaci√≥n gr√°fica que se muestra actualmente en el microcontrolador.  Por lo tanto, si es necesario, es necesario almacenar la informaci√≥n de salida en un b√∫fer dedicado de antemano, y para cambiar el estado de los p√≠xeles (bits), aplique m√°scaras de bits para bytes desde este b√∫fer y transfi√©ralos nuevamente a la pantalla. <br><br>  El modelado y la reflexi√≥n sobre la ubicaci√≥n de una informaci√≥n gr√°fica particular en la pantalla se llevaron a cabo teniendo en cuenta las caracter√≠sticas anteriores.  Esto se hizo para simplificar el c√≥digo al escribir el programa.  Y no es casualidad que el tama√±o de fuente se haya considerado de la categor√≠a 8, 16, 24, es decir, un m√∫ltiplo de 8. Tambi√©n divid√≠ la informaci√≥n gr√°fica, por analog√≠a con la pantalla, en 6 zonas horizontales.  En la primera zona, los valores de RPM absolutos y actuales (desde el momento en que se enciende el dispositivo) se muestran en letra peque√±a.  En la segunda zona, los valores absolutos y actuales de la ruta (en kil√≥metros con redondeo a cent√©simas).  En la tercera zona - velocidad media.  En el cuarto - velocidad m√°xima y en letra grande - la velocidad actual.  En la quinta zona, se muestran dos barras de progreso para indicar que la ROM est√° llena y el n√∫mero de sobrescrituras.  En la sexta, √∫ltima zona, la fecha y la hora.  Es la quinta zona la excepci√≥n cuando en la direcci√≥n vertical de cualquier columna tomada hay p√≠xeles relacionados con informaci√≥n diferente.  Por lo tanto, esta informaci√≥n utilizando m√°scaras de bits se recopila en un b√∫fer, cuyo contenido se muestra en esta quinta zona.  Adem√°s, en 3-5 zonas hay informaci√≥n para dibujar un marco alrededor del valor de velocidad visualizado.  En la √∫ltima zona, cada primer bit (menos significativo) en todas las columnas se establece en "1" para dibujar la l√≠nea de separaci√≥n (40a fila).  Para esta simulaci√≥n y visualizaci√≥n de direcciones, represent√© todo lo anterior en celdas de Excel. <br><br><img src="https://habrastorage.org/webt/nd/5z/vk/nd5zvk7smre6acj0voalhm5bimi.png"><br><br>  As√≠ es como se ve la primera ventana de visualizaci√≥n.  Solo dos ventanas.  La segunda ventana es la salida del gr√°fico (histograma) del movimiento.  Para ello, se asignan 5 zonas (40 filas) verticalmente y las 84 columnas horizontalmente.  La sexta zona con el reloj es la misma para ambas ventanas. <br><br>  Al programar, decid√≠ no recurrir al uso de ninguna biblioteca para trabajar con esta pantalla.  Personalmente, es m√°s f√°cil para m√≠ comprender la hoja de datos, implementar parte de las funciones yo mismo, que comprender la biblioteca.  Adem√°s, se encontraron ciertas ventajas en esto.  Recientemente, despu√©s de descargar una de las bibliotecas, descubr√≠ sus caracter√≠sticas funcionales.  Es universal, con su ayuda puede controlar p√≠xeles individualmente y posicionarse en la direcci√≥n de p√≠xeles real.  Pero la biblioteca utiliza un b√∫fer de 84 * 6 bytes de tama√±o, y este b√∫fer de temporizador se env√≠a peri√≥dicamente a la pantalla, actualizando los gr√°ficos.  Por lo tanto, el temporizador y parte de la memoria MK est√°n ocupados.  En mi caso particular, no hay necesidad de usar una biblioteca, ya que al modelar, tuve cuidado de antemano para maximizar la separaci√≥n de informaci√≥n entre las zonas mostradas, que cumplen totalmente con las zonas de visualizaci√≥n.  Y no es necesario actualizar peri√≥dicamente la informaci√≥n en la pantalla: la informaci√≥n se actualiza solo si y solo cuando cambia (con cada rotaci√≥n de la rueda, cada vez que se presiona un bot√≥n, etc.).  Por lo tanto, enfatizo una vez m√°s: dependiendo de la tarea, puede evitar el uso de cualquier biblioteca. <br><br>  Para trabajar con un microcircuito de reloj y ROM, tampoco recurr√≠ al uso de bibliotecas: todas las funciones son bastante simples e implementadas por m√≠ despu√©s de estudiar las hojas de datos para estos componentes. <br><br>  Ahora considere el circuito el√©ctrico del dispositivo. <br><br><img src="https://habrastorage.org/webt/fj/6h/ry/fj6hryk8yrvhu4wr9ckd9njfkj0.png"><br><br>  El dise√±o del veloc√≠metro es relativamente simple.  Adem√°s de todo lo anterior, el circuito contiene un elemento IC5 MAX756 que sirve como un convertidor de potencia de 3 a 5 voltios para una fuente de alimentaci√≥n confiable de la bater√≠a original del tel√©fono m√≥vil Nokia 3310. No implement√© el circuito para la fuente de alimentaci√≥n de 3 voltios debido a la falta de MK y perif√©ricos apropiados.  En este momento, todav√≠a no he adquirido el MAX756, y todo el circuito todav√≠a est√° alimentado por una bater√≠a externa Krona que usa el regulador LM7805 (no es la mejor opci√≥n).  Se conecta a la toma de auriculares en la parte inferior del tel√©fono.  El interruptor de l√°minas SF1, que es un sensor de rotaci√≥n de la rueda, est√° conectado al puerto de interrupci√≥n INT0 MK (pin 32).  Se conecta de forma segura desde la parte inferior del tel√©fono al puerto de carga.  Los botones funcionales S1-S3 conectados a los botones "1", "2", "3" del tel√©fono m√≥vil est√°n conectados a puertos arbitrarios (pines 23, 27, 28).  Un pin S4 est√° conectado al pin 29 del reinicio MK, que coincide con el bot√≥n del extremo superior para encender el tel√©fono m√≥vil.  Lo hice as√≠ como as√≠.  El dispositivo en s√≠ no tiene un modo de espera y se enciende con energ√≠a.  Una pantalla IC2 y un conector para parpadear X1 est√°n conectados al puerto SPI del controlador (pines 15-17).  Con el conector, que quer√≠a hacer sobre la base de los "puntos" existentes en la placa base original para emparejar con una PC (en el mismo lugar), obtuve un peque√±o inconveniente, y en el futuro lo transferir√© a otro lugar.  Una interfaz UART para la conexi√≥n del usuario a una computadora est√° conectada al mismo conector, a trav√©s del cual se configuran la fecha y la hora en el dispositivo (pines 30-31, RX / TX).  La pantalla est√° conectada al controlador a trav√©s de divisores en resistencias, que sirven para reducir el voltaje, porque la pantalla funciona a un voltaje de 3.3 V. Adem√°s, los pines de la pantalla D / C (datos / comando), SCE (luz estrobosc√≥pica) y RES (reinicio de la pantalla) est√°n conectados a puertos arbitrarios MK PB0, PB1 y PB2, respectivamente (pines 12-14).  La pantalla se alimenta a trav√©s de los diodos D1-D3 y la resistencia R6, que sirven para reducir el voltaje de 5 a 3.3 V, evitando el uso de un regulador lineal.  El cuarzo Cr1 cronometrado por MK con un valor nominal de 4.5 MHz fue elegido al azar, pero deliberadamente.  √âl simplemente cay√≥ en mi brazo, y decid√≠ usarlo.  Los transistores Q1 y Q2 est√°n conectados a los puertos del PD4 y PD5 MK (pines 2 y 9), en los que se cargan los LED para la luz de fondo de la pantalla y el teclado.  El controlador proporciona la capacidad de controlar las luces de fondo individualmente, como lo proporciona el dise√±o original del tel√©fono m√≥vil (esto fue a nivel de hardware y no a nivel de usuario), aunque en la pr√°ctica esto no es necesario.  El bus I2C est√° conectado a los puertos PC2-PC3 (pines 25-26) y, por simplicidad, se implementa mediante programaci√≥n utilizando la biblioteca apropiada (aunque est√° conectado a los puertos TWI de hardware).  La ROM IC3 y el reloj de tiempo real (RTC) IC4 est√°n suspendidos en el bus.  Haga una reserva de inmediato para que no haya cr√≠ticas en los comentarios: s√© que el DS1307 no es la mejor soluci√≥n, pero en el momento del desarrollo del circuito no sab√≠a sobre la existencia del DS3231.  La ROM se encuentra en un conector extra√≠ble, similar a una tarjeta SIM.  Se utiliza un puerto adicional del controlador PC1 (pin 24) para recibir pulsos con una frecuencia de 1 Hz con RTC, por lo que se actualiza el tiempo en la pantalla.  Todos los componentes del kit de cuerpo pasivo, de acuerdo con las hojas de datos de cada componente activo. <br><br>  Considere consideraciones matem√°ticas para calcular ciertos par√°metros.  Como ya se mencion√≥ al principio, el principio de medir la velocidad se basa en calcular el per√≠odo de revoluci√≥n de la rueda, y la distancia se calcula sobre la base de medir el n√∫mero de tales revoluciones.  El controlador mide el tiempo entre el pulso anterior y el pulso entrante desde el interruptor de l√°minas.  El resultado de la medici√≥n se convierte en un valor de velocidad dividiendo el valor del per√≠metro de la rueda por el per√≠odo de revoluci√≥n, y este valor se actualiza en la pantalla con cada pulso (revoluci√≥n de la rueda).  Vale la pena se√±alar aqu√≠ que, desde el punto de vista de la f√≠sica, se calcula la velocidad promedio de una bicicleta en una secci√≥n de la ruta correspondiente al per√≠metro de la rueda.  Por separado, se calcula el n√∫mero de pulsos, luego se convierte a un valor de distancia.  Para medir el per√≠odo de rotaci√≥n de la rueda, el controlador utiliza su propio temporizador.  ATmega8 tiene un temporizador de 8 bits y otro de 16 bits.  El rango din√°mico de la medici√≥n depende de la profundidad de bits del temporizador.  En mi caso, se usa un temporizador de 16 bits, ya que 8 bits (256 cuentas de cuentas) son categ√≥ricamente insuficientes.  El per√≠odo de medici√≥n m√°ximo (antes de que el temporizador se desborde) corresponder√° a la velocidad m√≠nima medida.  Puede ingresar el llamado temporizador de software, que medir√° per√≠odos largos.  Sin embargo, para simplificar el programa, no hice esto.  Con el cuarzo usado de 4.5 MHz y un valor m√°ximo de divisor de 1024 en la configuraci√≥n del temporizador, tenemos: (1 / (4500000/1024)) = 0.000227556 ‚Äã‚Äãseg.  Este valor corresponde al per√≠odo m√≠nimo de la cuenta.  Y el per√≠odo m√°ximo de la cuenta ser√° 0.000227556 ‚Äã‚Äã* 65536 = 14.913 segundos.  La velocidad m√°xima medible correspondiente al per√≠odo m√≠nimo medible ser√° de aproximadamente 30,000 km / h.  Ni siquiera val√≠a la pena estipularlo, la "reserva desde arriba" es simplemente enorme.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero la velocidad m√≠nima medida correspondiente al per√≠odo m√°ximo medido ser√° 2.26 / 14.913 / 1000 * 3600 = 0.54 km / h. Aqu√≠ 2.26 es el per√≠metro de la rueda de la bicicleta (en metros) en mi caso. Estoy bastante contento con este valor m√≠nimo medido. Si la bicicleta se mueve a una velocidad inferior a 0,54 km / h, el veloc√≠metro de la bicicleta registrar√° la falta de movimiento (y el desbordamiento del temporizador). Con este cuarzo, la interfaz UART de 4.5 MHz funciona bien a una velocidad de 2400 baudios con un error aceptable aceptable. Esta velocidad tambi√©n es suficiente, especialmente porque uso UART para configuraciones de reloj de una sola vez desde una computadora (para copiar la fecha y hora de una computadora a un dispositivo). Si tomas cuarzo en frecuencia m√°s alta, la velocidad m√≠nima medible aumentar√°, lo que ser√° inaceptable para m√≠,y deber√° usar un temporizador de software. Y si lo toma a continuaci√≥n, el rendimiento del dispositivo en su conjunto disminuye. Por lo tanto, decid√≠ dejar este cuarzo en particular.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observo que los valores de per√≠odo y velocidad son inversamente proporcionales, y el temporizador del microcontrolador mide el per√≠odo discretamente. En nuestro caso, el rango de medici√≥n (0.000227556 ‚Äã‚Äã... 14.913) est√° marcado uniformemente con puntos en la cantidad de 65535, dividi√©ndolo en muchos intervalos iguales. Y estos puntos corresponden a todo tipo de valores medidos. Utilizando la conversi√≥n de intervalos de tiempo a velocidad, este sistema de intervalos se convierte de uniforme a inversamente proporcional. Por lo tanto, el rango de velocidades medidas de forma diversa se divide en intervalos desiguales. La longitud de estos intervalos aumenta al aumentar el valor de la velocidad en s√≠. Dado este hecho, la enorme "reserva desde arriba", sobre la que escrib√≠ un poco m√°s arriba, no estar√° mal. En la pr√°ctica, ser√° suficiente tomar el valor de 100 km / h para la velocidad m√°xima medida de la bicicleta.Esto es solo para no introducir un nuevo d√≠gito (cientos) y no aumentar el ancho del par√°metro mostrado en la pantalla. Calculamos cu√°l es la longitud del intervalo entre valores posibles adyacentes a una velocidad en el vecindario, por ejemplo, a 90 km / h. Usando las f√≥rmulas inversas o la selecci√≥n, es f√°cil calcular que para el valor del temporizador 397 (de 65536 posibles) la velocidad medida corresponde a 90.06 km / h. Y con un valor de temporizador vecino de 398 - 89.83 km / h. Y la diferencia entre las velocidades es de 0.23 km / h, que ya es m√°s que aceptable. Y a velocidades m√°s bajas, esta diferencia ser√° a√∫n menor. La pantalla muestra el valor de la velocidad a la cent√©sima m√°s cercana. Sin embargo, en la pr√°ctica, redondear al entero m√°s cercano o a las d√©cimas suele ser suficiente. De lo anterior, podemos concluir: la falta de uniformidad de la "cuadr√≠cula" de velocidades puede descuidarse,ya que el error de medici√≥n causado por √©l no excede el error permitido.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para calcular la distancia, es suficiente multiplicar el n√∫mero de pulsos (revoluciones) por el per√≠metro de la rueda. En este caso, por supuesto, la distancia se calcula con precisi√≥n al per√≠metro de la rueda, lo cual es bastante aceptable. La velocidad promedio actual se calcula como la relaci√≥n entre la distancia actual recorrida y el valor de tiempo desde el momento en que se activ√≥. Este es el tiempo que el controlador considera contando el n√∫mero de pulsos que llegan una vez por segundo con RTC. La velocidad promedio en la pantalla se actualiza junto con la actualizaci√≥n de tiempo (una vez por segundo). Todos los dem√°s par√°metros se actualizan con cada revoluci√≥n de la rueda.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora sobre las peque√±as caracter√≠sticas de la interfaz. El primer bot√≥n se usa para cambiar de modo (modo gr√°fico o modo de visualizaci√≥n de valores). El segundo bot√≥n: para mostrar la velocidad m√°xima absoluta (de todos los tiempos) en lugar de la relativa cuando se mantiene presionada. Adem√°s, la fecha y hora de alcanzar esta velocidad se muestran en lugar de la fecha y hora actuales. Y tambi√©n, el valor de la direcci√≥n ROM actual se muestra en lugar del valor de la velocidad relativa (para control). Este valor puede estimarse mediante la barra de progreso horizontal en la l√≠nea 38 de la pantalla. En esta ROM, con una capacidad de 65536 bytes (512 kbit), se registran los par√°metros medidos. Como se dir√° m√°s adelante, es suficiente registrar el par√°metro medido inicialmente (el per√≠odo de rotaci√≥n de la rueda) con una marca del tiempo inicial.Todos los dem√°s par√°metros son calculados f√°cilmente por un programa de computadora en la etapa de escaneo de ROM. El tercer bot√≥n se usa para controlar la luz de fondo. A diferencia del dibujo de pantalla anterior, luego elimin√© ceros insignificantes en los par√°metros secundarios para mostrarlos con mayor claridad. En modo gr√°fico, se dibuja un histograma de la velocidad de movimiento de izquierda a derecha, lo que demuestra claramente el proceso de cambio de velocidad en una peque√±a porci√≥n de la distancia de 84 revoluciones de la rueda. El valor del histograma es la velocidad a una escala de 1 p√≠xel por 1 km / h. Si la velocidad supera los 40 km / h, la imagen se reduce verticalmente 2 veces para evitar que se salga de la escala. No se requiere que las caracter√≠sticas completas del comportamiento del dispositivo se describan aqu√≠.M√°s tarde elimin√© ceros insignificantes en los par√°metros secundarios para mostrarlos m√°s claramente. En modo gr√°fico, se dibuja un histograma de la velocidad de movimiento de izquierda a derecha, lo que demuestra claramente el proceso de cambio de velocidad en una peque√±a porci√≥n de la distancia de 84 revoluciones de la rueda. El valor del histograma es la velocidad a una escala de 1 p√≠xel por 1 km / h. Si la velocidad supera los 40 km / h, la imagen se reduce verticalmente 2 veces para evitar que se salga de la escala. No se requiere que las caracter√≠sticas completas del comportamiento del dispositivo se describan aqu√≠.M√°s tarde elimin√© ceros insignificantes en los par√°metros secundarios para mostrarlos m√°s claramente. En modo gr√°fico, se dibuja un histograma de la velocidad de movimiento de izquierda a derecha, lo que demuestra claramente el proceso de cambio de velocidad en una peque√±a porci√≥n de la distancia de 84 revoluciones de la rueda. El valor del histograma es la velocidad a una escala de 1 p√≠xel por 1 km / h. Si la velocidad supera los 40 km / h, la imagen se reduce verticalmente 2 veces para evitar que se salga de la escala. No se requiere que las caracter√≠sticas completas del comportamiento del dispositivo se describan aqu√≠.El valor del histograma es la velocidad a una escala de 1 p√≠xel por 1 km / h. Si la velocidad supera los 40 km / h, la imagen se reduce verticalmente 2 veces para evitar que se salga de la escala. No se requiere que las caracter√≠sticas completas del comportamiento del dispositivo se describan aqu√≠.El valor del histograma es la velocidad a una escala de 1 p√≠xel por 1 km / h. Si la velocidad supera los 40 km / h, la imagen se reduce verticalmente 2 veces para evitar que se salga de la escala. No se requiere que las caracter√≠sticas completas del comportamiento del dispositivo se describan aqu√≠.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vale la pena se√±alar una de las diferencias caracter√≠sticas entre mi veloc√≠metro y la compra barata. Consiste en la velocidad de actualizaci√≥n de la indicaci√≥n de velocidad en la pantalla. En mi dispositivo, se actualiza inmediatamente, seg√∫n lo calculado, con cada rotaci√≥n de la rueda. En los dispositivos comprados, se actualiza con cierto retraso. Quiz√°s este retraso se deba a un intento de filtrar el ruido de medici√≥n (por ejemplo, utilizando el m√©todo de promedio m√≥vil) para estabilizar la visualizaci√≥n de la velocidad en la pantalla para una claridad m√°s detallada. O tal vez la pantalla se actualiza completamente a intervalos regulares (por ejemplo, dos veces por segundo). Puede ser conveniente, pero quer√≠a implementar una actualizaci√≥n de velocidad con cada revoluci√≥n de la rueda.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La placa de circuito impreso se realiza mediante el m√©todo LUT en forma de placa de circuito original del tel√©fono m√≥vil usado. En la fabricaci√≥n de la placa de circuito, utilic√© el programa SLayout. Al mismo tiempo, tom√© una foto de la placa original en ambos lados del esc√°ner de antemano y puse las im√°genes en SLayout como plantilla. Esto es necesario para dibujar almohadillas para conectar la pantalla, botones y conectores en lugares exclusivamente necesarios. En la fabricaci√≥n de la placa, se produjo un error de aproximadamente 0,5 mm. Este error result√≥ ser aceptable en t√©rminos de combinaci√≥n de pads y elementos. Sin embargo, este error afect√≥ la calidad de la luz de fondo: los LED sellados se desplazaron por una fracci√≥n de mil√≠metros y no cayeron en el foco de los mandriles de dispersi√≥n de luz. Debido a esto, el brillo de la luz de fondo disminuy√≥, reduciendo la eficiencia.Las siguientes figuras muestran una vista de la placa de circuito en SLayout junto con tres peque√±as placas de circuito impreso para ROM en forma de tarjeta SIM. Adem√°s, se muestran escaneos de la placa de circuito impreso original desde dos lados.</font></font><br><br><img src="https://habrastorage.org/webt/t4/x_/5a/t4x_5ad0pzcc8eyisyxrlmngkvu.png"><br><br><img src="https://habrastorage.org/webt/hj/gm/wp/hjgmwpma4fq8jbfeasauhjgfaqw.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algunos elementos (botones, conectores) est√°n interconectados por puentes de cable delgados por falta de la capacidad de colocar pistas. Hay un margen para todos los botones disponibles, es decir, es posible usar cualquier bot√≥n disponible. Puede ser conveniente hacer que el bot√≥n grande en el centro sea un bot√≥n para cambiar los modos de visualizaci√≥n. En la esquina superior izquierda de la placa hay una bater√≠a RTC de 3 voltios. En general, todos los elementos en el tablero se colocan correctamente con la coordinaci√≥n de sus dimensiones con las dimensiones de la caja. A diferencia del original dorado, la placa interna est√° recubierta con soldadura ordinaria. Como se muestra en la pr√°ctica inicial, no se pierde el contacto con la pantalla y otros perif√©ricos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El programa para MK result√≥ ser bastante grande y ocupa una parte significativa de su memoria. </font><font style="vertical-align: inherit;">Adem√°s, el programa proporciona el uso de su propia memoria no vol√°til del controlador (EEPROM) para grabar y guardar la informaci√≥n necesaria. </font><font style="vertical-align: inherit;">La siguiente tabla muestra la distribuci√≥n de esta informaci√≥n por direcciones EEPROM.</font></font><br><br><table border="1" cellpadding="7"><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direcci√≥n</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tama√±o</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datos</font></font></b> </td></tr><tr><td>  0 0 </td><td>  4 4 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n (para S) </font></font></td></tr><tr><td>  4 4 </td><td>  2 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> t_min (para v_max) </font></font></td></tr><tr><td>  6 6 </td><td>  6 6 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fecha de t_min </font></font></td></tr><tr><td>  12 </td><td>  2 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Direcci√≥n EEPROM </font></font></td></tr><tr><td>  14 </td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recuento de EEPROM RW </font></font></td></tr><tr><td>  128 </td><td>  80 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√≠gitos 8X8 </font></font></td></tr><tr><td>  208 </td><td>  30 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√≠gitos 3X5 </font></font></td></tr></tbody></table> Los primeros cuatro bytes almacenan la distancia recorrida como el n√∫mero de revoluciones de la rueda.  Eleg√≠ espec√≠ficamente el tipo entero de 32 bits para esta variable, ya que en la pr√°ctica los valores de la ruta recorrida son relativamente grandes.  Por ejemplo, una variable entera de 16 bits podr√≠a ahorrar un m√°ximo de 65.536 revoluciones (aproximadamente 148 km), que es naturalmente peque√±a.  Siguen dos bytes para mantener la velocidad m√°xima absoluta.  De hecho, se ahorra el tiempo m√≠nimo de rotaci√≥n de la rueda.  La variable ocupa dos bytes, porque su valor es el resultado de medir un temporizador de 16 bits.  Los siguientes 6 bytes son la fecha y hora en que se alcanz√≥ la velocidad m√°xima anterior.  Los datos se presentan exactamente en el formato en el que se leen del chip RTC (excluyendo el d√≠a de la semana).  A continuaci√≥n, dos bytes que almacenan el valor de la direcci√≥n actual de la ROM externa.  Este es un tipo de puntero, que es necesario para la posibilidad de continuar el registro de estad√≠sticas en la ROM despu√©s de la pr√≥xima vez que se enciende el dispositivo.  MK debe saber en qu√© posici√≥n del espacio de direcciones de la ROM externa se detuvo por √∫ltima vez.  Desde esta posici√≥n, MK continuar√° grabando.  A este valor se le asignan 2 bytes, ya que el espacio de direcciones de la ROM externa es de 16 bits.  Esto se deduce de un tama√±o de ROM de 64 kB.  El siguiente es una variable de un solo byte que almacena el valor del n√∫mero de sobrescrituras de ROM.  La sobrescritura es el caso cuando el puntero anterior alcanza el valor m√°ximo y se convierte en cero.  En este caso, la informaci√≥n reci√©n recibida en la ROM comenzar√° a grabarse desde el principio, borrando la informaci√≥n antigua disponible en ella.  Una variable entera de un solo byte es capaz de almacenar un m√°ximo de 256 valores.  Le recuerdo que los valores del puntero de la direcci√≥n ROM y el n√∫mero de sobrescrituras se indican visualmente mediante dos barras de progreso en la pantalla.  Adem√°s, despu√©s de un gran espacio de copia de seguridad de la EEPROM MK, comenzando en la direcci√≥n 128, se almacena informaci√≥n gr√°fica sobre 8x8 d√≠gitos.  Para ello, se asignan 80 bytes (8 bytes por cada d√≠gito, como se mencion√≥ anteriormente).  Y finalmente, comenzando en la direcci√≥n 208, se almacenan 30 bytes para obtener informaci√≥n gr√°fica sobre peque√±os d√≠gitos de 3x5 (tres bytes por d√≠gito). <br><br>  Adem√°s del programa principal para el microcontrolador, escrib√≠ tres programas auxiliares m√°s para la computadora, que se analizar√°n a continuaci√≥n.  Todos los programas no tienen una interfaz gr√°fica y funcionan desde la l√≠nea de comandos de Windows XP. <br><br>  El primer programa le permite copiar la fecha y la hora desde una computadora al veloc√≠metro de la bicicleta a trav√©s del puerto COM.  El veloc√≠metro de la bicicleta est√° conectado a la computadora a trav√©s del chip MAX232.  Usando WinAPI, el programa recibe la fecha y hora actuales en una variable estructural especial del tipo SYSTEMTIME.  El d√≠a actual, mes, a√±o, n√∫mero de d√≠a de la semana, horas, minutos, segundos en formato decimal se extraen de esta variable.  Todos estos n√∫meros, con la excepci√≥n del a√±o, no superan los dos decimales (menos de 100) y se encuentran dentro de un byte.  El valor del a√±o se convierte en un n√∫mero de dos d√≠gitos restando de √©l el n√∫mero 2000, el valor del milenio actual.  Cada uno de estos n√∫meros decimales de dos d√≠gitos se convierte a la caracter√≠stica de formato decimal binario del chip RTC.  En este formato, un n√∫mero de dos d√≠gitos tambi√©n ocupa un volumen de un byte.  Los 4 bits m√°s significativos est√°n codificados con el d√≠gito de las decenas, y los menos significativos, el n√∫mero de unidades.  Posteriormente, se forma un paquete de 13 bytes a partir de estos n√∫meros, de acuerdo con un protocolo que determin√© previamente.  Los primeros cinco bytes representan la palabra "TIEMPO =" seg√∫n la codificaci√≥n ASCII est√°ndar.  Luego siga los segundos, minutos, horas, d√≠a de la semana, d√≠a, mes, a√±o.  El √∫ltimo byte es el car√°cter "#", como el car√°cter del final del mensaje.  Este paquete se env√≠a desde la computadora al dispositivo a trav√©s del puerto COM.  El programa del microcontrolador recibe el paquete y verifica que sea correcto, de acuerdo con el formato anterior.  Si los primeros cinco bytes son "TIME =" y el √∫ltimo es "#", el env√≠o se considera correcto, y los bytes en el interior se interpretan en el orden correspondiente.  Sin cambiar esta cadena de bytes, el controlador la env√≠a al chip RTC a trav√©s del bus I2C, configur√°ndola para la fecha y hora actuales.  Observo que este microcircuito admite el c√°lculo de los d√≠as de la semana del 1 al 7, aunque como tal un calendario que determina la correspondencia de la fecha y el d√≠a de la semana, no lo es.  No proporcion√© la visualizaci√≥n de informaci√≥n sobre el d√≠a de la semana en mi dispositivo. <br><br>  El segundo programa est√° dise√±ado para procesar datos del contenido de una ROM externa.  Inicialmente, se supon√≠a que este contenido deber√≠a copiarse desde la ROM al archivo de imagen utilizando alg√∫n programa conocido que funciona con programadores conocidos de MK y ROM (por ejemplo, "icprog").  Sin embargo, despu√©s de estudiar el principio de operaci√≥n I2C con m√°s detalle, logr√© implementar esta funcionalidad y la inclu√≠ en mi programa.  El esquema del programador ROM de esta serie, que utilic√© en el dispositivo, se presenta en la figura a continuaci√≥n. <br><br><img src="https://habrastorage.org/webt/ke/be/p1/kebep1s6zkpkgf0i5eyxu5jcvbi.png"><br><br>  La ROM est√° conectada al puerto COM de la computadora, que se usa no como un medio para intercambiar informaci√≥n a trav√©s de RS-232 (donde es suficiente para usar las salidas de TX, RX, GND), sino como un medio de entrada-salida arbitraria de se√±ales l√≥gicas.  A trav√©s del terminal TX, se alimenta la ROM, que se estabiliza hasta 5V por el regulador 78L05.  Al controlar la salida TX de la computadora, podemos encender o apagar el chip ROM.  La l√≠nea de reloj unidireccional SCL se concentra en el pin RTS del puerto COM, y la l√≠nea de datos bidireccional SDA se concentra en dos pines: CTS (recepci√≥n de datos) y DTR (transmisi√≥n de datos).  Las resistencias y los diodos zener D1 y D2 se utilizan para limitar el nivel de se√±al a TTL, en el que funciona la ROM. <br><br>  Hice este programador est√°ndar para mi caso especial, donde en lugar de un socket para ROM, se usa un lector SIM de un tel√©fono m√≥vil roto. <br><br><img src="https://habrastorage.org/webt/-w/as/0e/-was0enetz2tighj_9_bziqip90.jpeg"><br><br>  Por medio de WinAPI, el programa accede a los pines del puerto COM de la computadora, establece los valores necesarios para ellos (0 o 1) y tambi√©n elimina el valor binario entrante de la ROM del pin CTS.  Basado en este kit de herramientas, la funcionalidad I2C se implement√≥ de acuerdo con la especificaci√≥n relevante, sobre la cual no entrar√© en detalles.  El programa puede leer el contenido de la ROM en una imagen de archivo (como un programador normal), y tambi√©n procesar dicho archivo o procesar informaci√≥n directamente de la ROM.  El procesamiento de la informaci√≥n consiste en obtener los archivos de estad√≠sticas de salida en un formato tabular predeterminado basado en la informaci√≥n de entrada de la ROM.  Cada uno de estos archivos corresponde a un viaje (desde el momento de la corriente hasta la pr√≥xima vez que se enciende el dispositivo).  Primero, describir√© brevemente el formato de entrada que defin√≠ de antemano.  Cada vez que se enciende el dispositivo, se escriben dos bytes de ceros en la direcci√≥n actual, que se lee desde la EEPROM del microcontrolador.  Cuando la rueda comienza a girar (en el primer impulso) despu√©s de un tiempo de espera o despu√©s de encender el dispositivo, la fecha y hora actuales se escriben en formato decimal binario (como se almacena en los registros del chip RTC).  Y luego se registran dos bytes de "unidades" 0xFF.  Durante la rotaci√≥n de la rueda, para cada pulso k-√©simo (k = 2,3, ...), el tiempo de rotaci√≥n de la rueda entre el pulso (k-1) th y k-th se registra en dos bytes (alto y bajo).  Obviamente, esta informaci√≥n es suficiente para vincular la distancia actual (no absoluta) recorrida y la velocidad a la fecha y la hora.  El formato de salida es texto y es una tabla tabular en archivos * .csv que se abren en Excel haciendo doble clic con el mouse.  Las filas en esta tabla corresponden a las revoluciones de las ruedas, y los valores de las columnas se muestran a continuaci√≥n. <br><br><table border="1" cellpadding="7"><tbody><tr><td>  <b>ADR</b> </td><td>  Valor de direcci√≥n ROM </td></tr><tr><td>  <b>FECHA / HORA</b> </td><td>  Fecha y hora de inicio </td></tr><tr><td>  <b>Dic</b> </td><td>  Valor de temporizador decimal </td></tr><tr><td>  <b>tiempo</b> </td><td>  Hora actual </td></tr><tr><td>  <b>t</b> </td><td>  Tiempo de viaje desde el encendido </td></tr><tr><td>  <b>v</b> </td><td>  Velocidad </td></tr><tr><td>  <b>n</b> </td><td>  Velocidad </td></tr><tr><td>  <b>S</b> </td><td>  El camino </td></tr><tr><td>  <b>un</b> </td><td>  El n√∫mero absoluto de revoluciones (solo dentro de la ROM actual) </td></tr><tr><td>  <b>aS</b> </td><td>  Ruta absoluta (solo dentro de la ROM actual) </td></tr><tr><td>  <b>n_day</b> </td><td>  El n√∫mero de revoluciones para el d√≠a actual. </td></tr><tr><td>  <b>S_day</b> </td><td>  El camino para el d√≠a actual </td></tr><tr><td>  <b>v_max</b> </td><td>  Velocidad m√°xima para el viaje actual. </td></tr><tr><td>  <b>av_max</b> </td><td>  Velocidad m√°xima absoluta (solo dentro de la ROM actual) </td></tr><tr><td>  <b>v_mid</b> </td><td>  Velocidad promedio para el viaje actual </td></tr></tbody></table>  En la figura siguiente se muestra una captura de pantalla del contenido de dicho archivo en Excel.  Adem√°s, se muestran gr√°ficos de cambios en la velocidad actual, media y m√°xima en varios colores en un sistema de coordenadas.  Argumento (eje X): valores de velocidad como datos de entrada.  La figura muestra los cambios de par√°metros para las primeras 730 revoluciones.  La distancia recorrida est√° asociada con esta dependencia lineal variable (730 revoluciones corresponden a aproximadamente 1650 m).  Por lo tanto, podemos decir que los gr√°ficos reflejan la dependencia de las velocidades en la distancia (precisa a la escala horizontal), en contraste con la dependencia tradicional de la velocidad en el tiempo, a la que se debe prestar atenci√≥n.  Como ya se mencion√≥, esta caracter√≠stica se debe a la ideolog√≠a y al principio de medir la velocidad por la velocidad de la rueda.  Pero despu√©s de todo, a cada revoluci√≥n de la rueda (el momento de acercamiento del im√°n y el interruptor de l√°minas) se le asigna un momento espec√≠fico en el tiempo.  Naturalmente, esta secuencia de marcas de tiempo no es uniforme.  Sin embargo, por formalidad y conveniencia, Excel tiene la capacidad de especificar una matriz de valores de tiempo en la ruta o la hora actual como argumento para los gr√°ficos.  Pero de todos modos, debe recordarse que la dependencia real de la velocidad en el tiempo (a intervalos de tiempo uniformes para el caso discreto) se habr√≠a visto diferente, con una escala horizontal variable. <br><br><img src="https://habrastorage.org/webt/fn/af/to/fnaftofg4-o5ihmbxhhn9olwlha.png"><br><br><img src="https://habrastorage.org/webt/lw/ul/qa/lwulqayq1gcskndypndok_opb3i.png"><br><br>  La siguiente figura muestra la misma dependencia de la velocidad con las revoluciones, pero ya usa el filtro con el m√©todo de promedio m√≥vil con un ancho de ventana de 11 revoluciones.  Todos los gr√°ficos est√°n construidos en Excel utilizando m√©todos bien conocidos. <br><br><img src="https://habrastorage.org/webt/gx/xu/qk/gxxuqkk_mqlghugdmrgkhevpeem.png"><br><br>  Al comparar los dos gr√°ficos del cambio en la velocidad, es obvio que el componente de alta frecuencia est√° ausente en el gr√°fico filtrado, es decir  ruido eliminado  El ancho de la ventana de media m√≥vil de 11 revoluciones (aproximadamente 25 m), en mi opini√≥n, es demasiado grande.  Si realmente plantea la cuesti√≥n de filtrar las lecturas del ruido, es suficiente tomar un peque√±o ancho de ventana, por ejemplo, igual a tres.  Este algoritmo se puede incorporar al programa del veloc√≠metro de la bicicleta, ya que se puede usar no solo para analizar las lecturas, sino tambi√©n para mostrar estas lecturas en tiempo real.  A pesar de la simplicidad de este algoritmo, no entrar√© en los detalles de su descripci√≥n, ya que este tema est√° cubierto en el curso de las matem√°ticas y est√° m√°s all√° del alcance de este art√≠culo.  Y aqu√≠ hay otra aclaraci√≥n sobre la velocidad promedio.  Como ya escrib√≠, la velocidad promedio es el √∫nico par√°metro que se actualiza no con cada rotaci√≥n de la rueda, sino con cada segundo.  Hice esto para asegurarme de que la pantalla muestra un cambio en la velocidad promedio incluso con movimientos muy lentos.  Por lo tanto, los valores de las lecturas en la pantalla en tiempo real diferir√°n ligeramente de los valores calculados en el futuro por el programa de computadora en la etapa de escaneo de la ROM.  Las lecturas de la velocidad absoluta, la ruta absoluta y la velocidad m√°xima absoluta tambi√©n ser√°n diferentes.  La pantalla muestra valores realmente absolutos (para toda la vida √∫til del dispositivo) y en las tablas de salida, solo dentro de los l√≠mites de la ROM actual que se est√° leyendo. <br><br>  El tercer programa, en esencia, es el mismo programa para el microcontrolador de firmware.  Trabajo con el programador STK 200 m√°s simple conectado al puerto LPT de la computadora, o mejor dicho, con su an√°logo, si puede llamarlo as√≠, porque en el caso m√°s simple el programador no contiene ning√∫n elemento activo.  De hecho, MK a trav√©s de la interfaz SPI se conecta a pines espec√≠ficos del puerto LPT directamente y funciona como esclavo.  El programa implementa un protocolo para intercambiar datos con el controlador ATmega8 de acuerdo con su hoja de datos (p. 237).  La capa f√≠sica SPI se implementa administrando los registros de puertos LPT utilizando la conocida biblioteca din√°mica "inpout32.dll".  Mi biblioteca est√° conectada no como un proyecto (ya que evit√© crear un proyecto como tal en "Dev-cpp" creando un "archivo" simple), sino que utilic√© la funci√≥n LoadLibrary utilizando el tipo estructural HINSTANCE.  La biblioteca "inpout32.dll" se asigna a una variable de este tipo y, posteriormente, los punteros a las funciones de esta biblioteca se extraen en variables separadas.  Inpout32.dll tiene solo dos funciones que son responsables de la entrada y salida de datos.  Se accede a estas funciones utilizando punteros extra√≠dos previamente.  Los pines del puerto LPT se controlan individualmente mediante m√°scaras de bits.  En mi caso particular, el programa que escrib√≠ funciona con el √°rea EEPROM del controlador y est√° dise√±ado para leer, reservar, escribir, corregir y restaurar desde una copia de respaldo de los datos almacenados que pint√© anteriormente.  Como todos los dem√°s programas, el programa se ejecuta desde la l√≠nea de comandos.  En tales casos, para implementar la multifuncionalidad del programa, se utilizan las funciones de "cambio de may√∫sculas y min√∫sculas" y un di√°logo de usuario de texto, por ejemplo, "ingrese '1' para la operaci√≥n No. 1, ..., ingrese '0' para salir del programa".  Los datos se muestran en varios formatos convenientes para m√≠.  Adem√°s de lo anterior, el programa puede mostrar un volcado completo del controlador EEPROM en 512 bytes en la pantalla.  Adem√°s, el programa puede registrar informaci√≥n gr√°fica sobre las fuentes utilizadas en la memoria del controlador.  En el caso de letra peque√±a, tama√±o 3X5, el programa toma informaci√≥n del archivo de texto "Fonts 3X5.txt", que se encuentra en el mismo directorio.  El archivo contiene una tabla tabular de 30 bytes (3 por 10) escrita en formato hexadecimal.  Si lo desea, puede editarse f√°cilmente en un editor de texto, cambiando as√≠ los gr√°ficos de esta fuente.  Como ya se mencion√≥, esta letra peque√±a es tan simple que cambiar sus gr√°ficos no tiene sentido.  Lo √∫nico es que su desplazamiento vertical solo puede ser necesario, ya que hay un stock de espacio en altura de 8 p√≠xeles, y la fuente tiene una altura igual a 5. En el caso de una fuente grande, tama√±o 8X8, que muestra la velocidad actual, proporcion√© la funcionalidad mucho m√°s interesante.  La informaci√≥n gr√°fica sobre esta fuente no se presenta en un archivo de texto como una tabla de bytes, sino en archivos gr√°ficos visuales BMP.  Cada d√≠gito corresponde a uno de esos archivos.  Sus par√°metros son tama√±o 8X8, monocromo con una paleta en blanco y negro.  A continuaci√≥n se muestra una captura de pantalla del conocido editor gr√°fico "MS Paint" con el archivo "8.bmp" abierto. <br><br><img src="https://habrastorage.org/webt/s3/7o/ek/s37oekzshuoye0acdpxotluebas.png"><br><br>  Emp√≠ricamente, estudi√© la estructura de los archivos BMP monocrom√°ticos obtenidos de MS Paint ‚Äù, y sobre esta base pude aprender a leer cada p√≠xel de una imagen BMP monocrom√°tica (excluyendo el uso de estructuras y bibliotecas auxiliares).  En la etapa de lectura horizontal l√≠nea por l√≠nea de abajo hacia arriba (as√≠ es como se organiza la estructura del archivo BMP), el programa convierte la informaci√≥n en el formato vertical espec√≠fico para la pantalla utilizada.  Esta operaci√≥n se lleva a cabo en una pasada, donde se utilizan m√°scaras de bits y la acumulaci√≥n de valores variables.  A continuaci√≥n, mostrar√© esta secci√≥n de c√≥digo para el i-√©simo d√≠gito, prestando atenci√≥n a la simplicidad del proceso. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; k++){ fnt[i][k] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; j++){ fseek(f, <span class="hljs-number"><span class="hljs-number">62</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*j, SEEK_SET); byte = ~fgetc(f); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; k++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(byte &amp; pow2(<span class="hljs-number"><span class="hljs-number">7</span></span>-k)){ fnt[i][k] += pow2(<span class="hljs-number"><span class="hljs-number">7</span></span>-j); } } }</code> </pre> <br>  En el primer bucle, los elementos de la matriz fnt se inicializan en ceros.  Adem√°s, cada k-√©simo elemento de esta matriz (k = 0 ... 7) para el i-√©simo d√≠gito (i = 0 ... 9) llevar√° informaci√≥n gr√°fica sobre cada columna correspondiente de cada d√≠gito correspondiente.  El siguiente ciclo es la ejecuci√≥n a lo largo de las l√≠neas de la imagen del archivo BMP.  Con el operador fseek, nos posicionamos bytes en el desplazamiento 62 + 4 * j del archivo BMP predefinido f.  La estructura del archivo BMP determina la especificidad de la f√≥rmula mediante la cual se calcula el desplazamiento seg√∫n el n√∫mero de l√≠nea j.  En la variable intermedia de byte, obtenemos el valor de byte en el desplazamiento anterior.  Este byte almacena informaci√≥n sobre los ocho p√≠xeles de una imagen monocroma en la l√≠nea actual j.  El operador '~' realiza una inversi√≥n bit a bit del byte, lo que conduce a una inversi√≥n de color de cada p√≠xel.  Esto se debe al hecho de que un p√≠xel negro en la paleta de un archivo BMP monocromo corresponde a un "0" l√≥gico y blanco - "1".  En la pantalla aplicada, por el contrario.  En un bucle anidado, se produce un an√°lisis de bytes del byte y, al mismo tiempo, la informaci√≥n se acumula en la matriz de salida fnt.  Funci√≥n pow2: elevar un n√∫mero entero a una potencia entera no negativa, escrita independientemente.  En lugar de esta funci√≥n, puede usar el operador de desplazamiento bit a bit m√°s eficiente "&lt;&lt;", pero al momento de escribir este programa no lo estaba usando. <br><br>  Adem√°s, el programa proporciona la capacidad de escribir en la memoria de MK una de varias opciones gr√°ficas para esta fuente de mi elecci√≥n.  Estas opciones se implementan utilizando directorios (carpetas) con el nombre de la forma "v1", "v2", "v3", etc., que se encuentran en la carpeta "Fonts 8X8" en el mismo directorio que el programa.  Y ya en estas carpetas est√°n los archivos BMP necesarios.  Gracias a la funcionalidad anterior, es posible corregir o extraer n√∫meros de una "hoja en blanco" en un editor gr√°fico, guardarlos y distribuirlos entre directorios.  Tengo tres opciones de fuente.  La primera opci√≥n es la original.  El segundo, como el original, pero con un cero tachado y una unidad modificada (sin subrayado).  El tercero es una fuente con un borde rectangular. <br><br>  Las fotos a continuaci√≥n muestran: la placa de circuito fabricado del dispositivo desde la parte posterior;  un dispositivo en la mesa con alimentaci√≥n conectada (con una versi√≥n no final del firmware);  Un dispositivo en funcionamiento montado en una bicicleta con un gr√°fico de cambios de velocidad en √©l. <br><br><img src="https://habrastorage.org/webt/zm/5l/ly/zm5llykx8zbjhlpvl9hw72tfd98.jpeg"><br><br><img src="https://habrastorage.org/webt/kx/_b/mz/kx_bmzvxzlw-srwhzbudrpsdcg0.jpeg"><br><br><img src="https://habrastorage.org/webt/ak/lh/gx/aklhgxhxfzvj653rpxh4uqbrbri.jpeg"><br><br>  En el proceso de operaci√≥n del dispositivo, sin embargo, se identificaron peque√±os defectos asociados con las caracter√≠sticas de fabricaci√≥n.  En primer lugar, mal contacto de la pantalla con las almohadillas de la placa de circuito impreso.  En el tel√©fono m√≥vil original, los contactos en el tablero est√°n chapados en oro y no hay oxidaci√≥n.  En mi caso, simplemente est√°n enlatados. <br><br>  En base a lo anterior, se decidi√≥ rehacer el dispositivo en otro caso, as√≠ como rehacer la placa de circuito impreso, en la cual la pantalla se soldar√° insolentemente.  Comenc√© este proceso recientemente.  El resultado es un dise√±o m√°s robusto. <br><br><img src="https://habrastorage.org/webt/el/tw/r1/eltwr1m1zmbt1q5bj11v3a3cxks.png"><br><br><img src="https://habrastorage.org/webt/rh/hs/dw/rhhsdwamztytb2ix0le9mmyj2na.jpeg"><br><br><img src="https://habrastorage.org/webt/mp/rt/-h/mprt-hnrwvztbrvggcj6jhwx0qk.jpeg"><br><br>  Hice el estuche para el dispositivo a partir de una pieza de plexigl√°s, de 17 mm de espesor, en una fresadora CNC.  Para hacer esto, esboc√© preliminarmente los bocetos del caso en el programa SPlan, casi completamente sin conocer el tema de los dibujos, CAD, etc. <br><br><img src="https://habrastorage.org/webt/tn/j6/w-/tnj6w-zgduldrbd4-t9rqw1hihe.jpeg"><br><br>  Estos bocetos son necesarios para la presentaci√≥n general y la obtenci√≥n de las coordenadas de los puntos de control.  En base a ellos, se escribe un programa para la m√°quina CNC, teniendo en cuenta los principios generales y las secuencias de fresado.  Escrib√≠ el programa CNC manualmente en Excel, usando las funciones de autocompletar para operaciones repetidas. <br><br><img src="https://habrastorage.org/webt/eb/g1/ie/ebg1iewnui1ptplfwit3gvrbya0.jpeg"><br><br><img src="https://habrastorage.org/webt/qr/qa/kk/qrqakkmdcsuifjphgg_h8wcqybc.jpeg"><br><br>  Tambi√©n correg√≠ ligeramente el dise√±o del dispositivo, se presenta en la figura a continuaci√≥n. <br><br><img src="https://habrastorage.org/webt/wd/e5/lh/wde5lh6inym01_4elygpybkuuqy.png"><br><br>  En lugar de la retroiluminaci√≥n ya innecesaria del teclado, hay un LED de belleza que parpadea con cada giro del volante.  Los conectores tambi√©n se vuelven a dibujar, y no hay otros elementos que no fueran necesarios en la versi√≥n actualizada del dise√±o.  Adem√°s, encontr√© e instal√© cuarzo 4.433619 MHz, corrigiendo ligeramente algunas constantes en el c√≥digo fuente de mi propio programa.  Tambi√©n se hicieron algunos cambios menores al programa. <br><br>  A continuaci√≥n se presenta una fotograf√≠a del producto terminado.  El dispositivo funciona con una bater√≠a que se encuentra a bordo de la bicicleta.  Desde all√≠, tambi√©n se proporciona iluminaci√≥n para viajes en la oscuridad. <br><br><img src="https://habrastorage.org/webt/qa/1w/ln/qa1wln2ikvghei7heep_puqn9ay.jpeg"><br><br>  Fue en este dise√±o que el dispositivo funcion√≥ completamente sin ning√∫n problema t√©cnico.  El √∫nico inconveniente es el uso de un chip RTC de muy baja calidad: en invierno a bajas temperaturas, el tiempo tiene mucha prisa, hay que ajustarlo una vez al mes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414281/">https://habr.com/ru/post/es414281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414269/index.html">"20,000 IOPS por nodo tienen un buen rendimiento con 5 ms de latencia". Para OLTP: no</a></li>
<li><a href="../es414271/index.html">C√≥mo domar un disco duro en una computadora port√°til y evitar el estacionamiento en 8 segundos de tiempo de inactividad</a></li>
<li><a href="../es414273/index.html">Lo que necesita saber antes de desarrollar un backtester para una estrategia comercial: problemas t√≠picos, tipos de sistemas y sus par√°metros</a></li>
<li><a href="../es414277/index.html">El hombre, su entorno e Internet de las cosas.</a></li>
<li><a href="../es414279/index.html">Votaci√≥n de informes en la octava reuni√≥n de bricolaje en Mail.Ru Group (07.07.2018)</a></li>
<li><a href="../es414283/index.html">C√≥mo distinguir la criptomoneda de la no criptomoneda</a></li>
<li><a href="../es414285/index.html">Usamos un interruptor inal√°mbrico de 433MHz para controlar la PC</a></li>
<li><a href="../es414289/index.html">SpaceX ha abierto un trabajo como ingeniero de cohetes para crear un BFR</a></li>
<li><a href="../es414293/index.html">El tercer ReactOS Hackfest anual se llevar√° a cabo del 14 al 21 de agosto de 2018 en Berl√≠n.</a></li>
<li><a href="../es414295/index.html">"Era posible": formas inusuales pero efectivas de usar tecnolog√≠as de "audio"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>