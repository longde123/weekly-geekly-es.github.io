<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👃🏾 👨🏾‍🎨 🚍 ليس بدون ذعر في Go 🚠 🤹🏽 🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مرحبا عزيزي قراء هابر حبر. أثناء مناقشة تصميم جديد محتمل للتعامل مع الأخطاء والحجج حول مزايا معالجة الأخطاء الصريحة ، أقترح النظر في بعض ميزات الأخطاء...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ليس بدون ذعر في Go</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422419/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  مرحبا عزيزي قراء هابر حبر.  أثناء مناقشة تصميم جديد محتمل للتعامل مع الأخطاء والحجج حول مزايا معالجة الأخطاء الصريحة ، أقترح النظر في بعض ميزات الأخطاء والذعر واستعادتها في Go والتي ستكون مفيدة في الممارسة. <br><img src="https://habrastorage.org/getpro/habr/post_images/dcd/416/6fb/dcd4166fbfbe6deeb07163d4aa4b5665.gif" alt="الصورة"></p><a name="habracut"></a><br><h1 id="error" style=";text-align:right;direction:rtl">  خطأ </h1><br><p style=";text-align:right;direction:rtl">  <em>الخطأ</em> هو واجهة.  ومثل معظم الواجهات في Go ، فإن تعريف <em>الخطأ</em> قصير وبسيط: </p><br><pre style=";text-align:right;direction:rtl"><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> error <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Error() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p style=";text-align:right;direction:rtl">  اتضح أن أي نوع يحتوي على طريقة الخطأ يمكن استخدامه كخطأ.  كما علم روب بايك ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الأخطاء هي قيم</a> ، ويمكن استخدام القيم للتلاعب وبرمجة منطق مختلف. </p><br><p style=";text-align:right;direction:rtl">  هناك وظيفتان في مكتبة Go القياسية يتم استخدامها بشكل ملائم لإنشاء الأخطاء.  الأخطاء. الوظيفة الجديدة مناسبة تمامًا لإنشاء أخطاء بسيطة.  تتيح وظيفة <a href="">fmt.Errorf</a> استخدام التنسيق القياسي. </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs">err := errors.New(<span class="hljs-string"><span class="hljs-string">"emit macho dwarf: elf header corrupted"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name, id = <span class="hljs-string"><span class="hljs-string">"bimmler"</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span> err := fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"user %q (id %d) not found"</span></span>, name, id)</code> </pre> <br><p style=";text-align:right;direction:rtl">  عادةً ما يكون نوع الخطأ كافيًا للتعامل مع الأخطاء.  ولكن في بعض الأحيان قد يكون من الضروري نقل معلومات إضافية مع وجود خطأ ؛ في مثل هذه الحالات ، يمكنك إضافة نوع الخطأ الخاص بك. <br>  مثال جيد هو نوع <em>PathError</em> من حزمة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">نظام التشغيل</a> </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// PathError records an error and the operation and file path that caused it. type PathError struct { Op string Path string Err error } func (e *PathError) Error() string { return e.Op + " " + e.Path + ": " + e.Err.Error() }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  ستحتوي قيمة مثل هذا الخطأ على العملية والمسار والخطأ. </p><br><p style=";text-align:right;direction:rtl">  تتم تهيئتها بهذه الطريقة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs">... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, &amp;PathError{<span class="hljs-string"><span class="hljs-string">"open"</span></span>, name, syscall.ENOENT} ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, &amp;PathError{<span class="hljs-string"><span class="hljs-string">"close"</span></span>, file.name, e}</code> </pre> <br><p style=";text-align:right;direction:rtl">  يمكن أن يكون للمعالجة شكل قياسي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs">_, err := os.Open(<span class="hljs-string"><span class="hljs-string">"---"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>{ fmt.Println(err) } <span class="hljs-comment"><span class="hljs-comment">// open ---: The system cannot find the file specified.</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  ولكن إذا كانت هناك حاجة للحصول على معلومات إضافية ، فيمكنك فك الخطأ في * <em>os.PathError</em> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs">_, err := os.Open(<span class="hljs-string"><span class="hljs-string">"---"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pe, ok := err.(*os.PathError);ok{ fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Err: %s\n"</span></span>, pe.Err) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Op: %s\n"</span></span>, pe.Op) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Path: %s\n"</span></span>, pe.Path) } <span class="hljs-comment"><span class="hljs-comment">// Err: The system cannot find the file specified. // Op: open // Path: ---</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  يمكن تطبيق نفس النهج إذا كان بإمكان الدالة إرجاع عدة أنواع مختلفة من الأخطاء. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لعب</a> </p><br><p style=";text-align:right;direction:rtl">  الإعلان عن عدة أنواع من الأخطاء ، لكل منها بياناته الخاصة: </p><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">كود</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ErrTimeout <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Time time.Duration Err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *ErrTimeout)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Time.String() + <span class="hljs-string"><span class="hljs-string">": "</span></span> + e.Err.Error() } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ErrPermission <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Status <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *ErrPermission)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Status + <span class="hljs-string"><span class="hljs-string">": "</span></span> + e.Err.Error() }</code> </pre> </div></div><br><p style=";text-align:right;direction:rtl">  دالة يمكنها إرجاع هذه الأخطاء: </p><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">كود</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;ErrTimeout{Time: time.Second * <span class="hljs-number"><span class="hljs-number">10</span></span>, Err: errors.New(<span class="hljs-string"><span class="hljs-string">"timeout error"</span></span>)} } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt;= <span class="hljs-number"><span class="hljs-number">10</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;ErrPermission{Status: <span class="hljs-string"><span class="hljs-string">"access_denied"</span></span>, Err: errors.New(<span class="hljs-string"><span class="hljs-string">"permission denied"</span></span>)} } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> </div></div><br><p style=";text-align:right;direction:rtl">  معالجة الخطأ من خلال نوع القوالب: </p><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">كود</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ err := proc(<span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> e := err.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ErrTimeout: fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Timeout: %s\n"</span></span>, e.Time.String()) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Error: %s\n"</span></span>, e.Err) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ErrPermission: fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Status: %s\n"</span></span>, e.Status) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Error: %s\n"</span></span>, e.Err) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(<span class="hljs-string"><span class="hljs-string">"hm?"</span></span>) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } } }</code> </pre> </div></div><br><p style=";text-align:right;direction:rtl">  في حالة عدم حاجة الأخطاء إلى خصائص خاصة ، من الممارسة السليمة في Go إنشاء متغيرات لتخزين الأخطاء على مستوى الحزمة.  مثال على ذلك أخطاء مثل io.EOF و io.ErrNoProgress ، وما إلى ذلك. </p><br><p style=";text-align:right;direction:rtl">  في المثال أدناه ، نقاطع القراءة ونستمر في تشغيل التطبيق عندما يكون الخطأ io.EOF أو نغلق التطبيق لأية أخطاء أخرى. </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ reader := strings.NewReader(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>) p := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { _, err := reader.Read(p) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == io.EOF { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } log.Fatal(err) } } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  يعد هذا فعالًا لأنه يتم إنشاء الأخطاء مرة واحدة فقط وإعادة استخدامها. </p><br><h1 id="stack-trace" style=";text-align:right;direction:rtl">  تتبع المكدس </h1><br><p style=";text-align:right;direction:rtl">  قائمة الوظائف التي تم استدعاؤها في وقت التقاط المكدس.  يساعدك تتبع المكدس في الحصول على فكرة أفضل عما يحدث في النظام.  يمكن أن يساعد حفظ التتبع في السجلات بشكل جاد عند تصحيح الأخطاء. </p><br><p style=";text-align:right;direction:rtl">  غالبًا ما تفتقر Go إلى هذه المعلومات عن طريق الخطأ ، ولكن لحسن الحظ الحصول على تفريغ في Go ليس صعبًا. </p><br><p style=";text-align:right;direction:rtl">  يمكنك استخدام <em>debug.PrintStack ()</em> لإخراج التتبع إلى الإخراج القياسي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ foo() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ bar() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ debug.PrintStack() }</code> </pre> <br><p style=";text-align:right;direction:rtl">  نتيجة لذلك ، سيتم كتابة المعلومات التالية إلى Stderr: </p><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">كومة</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="hljs go">goroutine <span class="hljs-number"><span class="hljs-number">1</span></span> [running]: runtime/debug.Stack(<span class="hljs-number"><span class="hljs-number">0x1</span></span>, <span class="hljs-number"><span class="hljs-number">0x7</span></span>, <span class="hljs-number"><span class="hljs-number">0xc04207ff</span></span>78) .../Go/src/runtime/debug/stack.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> +<span class="hljs-number"><span class="hljs-number">0xae</span></span> runtime/debug.PrintStack() .../Go/src/runtime/debug/stack.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">16</span></span> +<span class="hljs-number"><span class="hljs-number">0x29</span></span> main.bar() .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span> +<span class="hljs-number"><span class="hljs-number">0x27</span></span> main.foo() .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span> +<span class="hljs-number"><span class="hljs-number">0x27</span></span> main.main() .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span> +<span class="hljs-number"><span class="hljs-number">0x27</span></span></code> </pre></div></div><br><p style=";text-align:right;direction:rtl">  <em>يعرض debug.Stack ()</em> شريحة بايت مع تفريغ مكدس ، والتي يمكن تسجيلها لاحقًا أو في أي مكان آخر. </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs">b := debug.Stack() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Trace:\n %s\n"</span></span>, b)</code> </pre> <br><p style=";text-align:right;direction:rtl">  هناك نقطة أخرى إذا فعلنا ذلك: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> bar()</code> </pre> <br><p style=";text-align:right;direction:rtl">  ثم نحصل على المعلومات التالية عند الإخراج: </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs go">main.bar() .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span> +<span class="hljs-number"><span class="hljs-number">0x2d</span></span> created by main.foo .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">14</span></span> +<span class="hljs-number"><span class="hljs-number">0x3c</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  كل غوروتين له كومة منفصلة ، على التوالي ، نحصل فقط على تفريغها.  بالمناسبة ، لدى الغوروتينات مداخنهم الخاصة ، ولا يزال الاسترداد مرتبطًا بهذا ، ولكن المزيد عن ذلك لاحقًا. <br>  وهكذا ، لمعرفة معلومات عن جميع goroutines ، يمكنك استخدام <em>runtime.Stack ()</em> وتمرير الوسيطة الثانية true. </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { n := runtime.Stack(buf, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(buf) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } buf = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(buf)) } fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Trace:\n %s\n"</span></span>, buf) }</code> </pre> <br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">كومة</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="hljs go">Trace: goroutine <span class="hljs-number"><span class="hljs-number">5</span></span> [running]: main.bar() .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">21</span></span> +<span class="hljs-number"><span class="hljs-number">0xbc</span></span> created by main.foo .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">14</span></span> +<span class="hljs-number"><span class="hljs-number">0x3c</span></span> goroutine <span class="hljs-number"><span class="hljs-number">1</span></span> [sleep]: time.Sleep(<span class="hljs-number"><span class="hljs-number">0x77359400</span></span>) .../Go/src/runtime/time.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">102</span></span> +<span class="hljs-number"><span class="hljs-number">0x17b</span></span> main.foo() .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">16</span></span> +<span class="hljs-number"><span class="hljs-number">0x49</span></span> main.main() .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span> +<span class="hljs-number"><span class="hljs-number">0x27</span></span></code> </pre></div></div><br><p style=";text-align:right;direction:rtl">  أضف هذه المعلومات إلى الخطأ وبالتالي زيادة محتوى المعلومات بشكل كبير. <br>  على سبيل المثال ، مثل هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ErrStack <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { StackTrace []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> Err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *ErrStack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buf bytes.Buffer fmt.Fprintf(&amp;buf, <span class="hljs-string"><span class="hljs-string">"Error:\n %s\n"</span></span>, e.Err) fmt.Fprintf(&amp;buf, <span class="hljs-string"><span class="hljs-string">"Trace:\n %s\n"</span></span>, e.StackTrace) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf.String() }</code> </pre> <br><p style=";text-align:right;direction:rtl">  يمكنك إضافة وظيفة لإنشاء هذا الخطأ: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewErrStack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErrStack</span></span></span></span> { buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { n := runtime.Stack(buf, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(buf) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } buf = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(buf)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;ErrStack{StackTrace: buf, Err: errors.New(msg)} }</code> </pre> <br><p style=";text-align:right;direction:rtl">  ثم يمكنك العمل بالفعل مع هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { err := foo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span>{ err := NewErrStack(<span class="hljs-string"><span class="hljs-string">"error"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">كومة</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="hljs go">Error: error Trace: goroutine <span class="hljs-number"><span class="hljs-number">1</span></span> [running]: main.NewErrStack(<span class="hljs-number"><span class="hljs-number">0x4c021f</span></span>, <span class="hljs-number"><span class="hljs-number">0x5</span></span>, <span class="hljs-number"><span class="hljs-number">0x4a92e0</span></span>) .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">41</span></span> +<span class="hljs-number"><span class="hljs-number">0xae</span></span> main.bar(<span class="hljs-number"><span class="hljs-number">0xc04207ff</span></span>38, <span class="hljs-number"><span class="hljs-number">0xc04207ff</span></span>78) .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> +<span class="hljs-number"><span class="hljs-number">0x3d</span></span> main.foo(<span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-number"><span class="hljs-number">0x48ebff</span></span>) .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">21</span></span> +<span class="hljs-number"><span class="hljs-number">0x29</span></span> main.main() .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> +<span class="hljs-number"><span class="hljs-number">0x29</span></span></code> </pre></div></div><br><p style=";text-align:right;direction:rtl">  وفقًا لذلك ، يمكن تقسيم الخطأ والتتبع: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ err := foo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st, ok := err.(*ErrStack);ok{ fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Error:\n %s\n"</span></span>, st.Err) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Trace:\n %s\n"</span></span>, st.StackTrace) } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  وبالطبع يوجد بالفعل حل جاهز.  أحدها حزمة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://github.com/pkg/errors</a> .  يسمح لك بإنشاء خطأ جديد ، والذي سيحتوي بالفعل على مكدس التتبع ، ويمكنك إضافة تتبع و / أو رسالة إضافية إلى خطأ موجود.  بالإضافة إلى تنسيق الإخراج المريح. </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/pkg/errors"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ err := foo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%+v"</span></span>, err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span>{ err := bar() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"error2"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"error"</span></span>) }</code> </pre> <br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">كومة</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="hljs go">error main.bar .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">20</span></span> main.foo .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">16</span></span> main.main .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span> runtime.main .../Go/src/runtime/proc.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">198</span></span> runtime.goexit .../Go/src/runtime/asm_amd64.s:<span class="hljs-number"><span class="hljs-number">2361</span></span> error2 main.foo .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">17</span></span> main.main .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span> runtime.main .../Go/src/runtime/proc.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">198</span></span> runtime.goexit .../Go/src/runtime/asm_amd64.s:<span class="hljs-number"><span class="hljs-number">2361</span></span></code> </pre> </div></div><br><p style=";text-align:right;direction:rtl">  سيعرض٪ v الرسائل فقط </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs vbscript">error2: <span class="hljs-keyword"><span class="hljs-keyword">error</span></span></code> </pre> <br><h1 id="panicrecover" style=";text-align:right;direction:rtl">  الذعر / التعافي </h1><br><p style=";text-align:right;direction:rtl">  الذعر (ويعرف أيضًا بالحادث ، ويعرف أيضًا بالذعر) ، كقاعدة عامة ، يشير إلى وجود أعطال ، والتي لا يمكن للنظام (أو نظام فرعي معين) استمرارها في العمل.  إذا تم استدعاء الذعر ، فإن وقت تشغيل Go ينظر إلى المكدس ، محاولًا العثور على معالج له. </p><br><p style=";text-align:right;direction:rtl">  الذعر غير المعالج إنهاء التطبيق.  هذا يميزهم بشكل أساسي عن الأخطاء التي تسمح لك بعدم معالجة نفسك. </p><br><p style=";text-align:right;direction:rtl">  يمكنك تمرير أي وسيطة إلى استدعاء دالة الذعر. </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(v <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{})</code> </pre> <br><p style=";text-align:right;direction:rtl">  من المثير للذعر تمرير خطأ من النوع الذي يبسط الاسترداد ويساعد على تصحيح الأخطاء. </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(errors.New(<span class="hljs-string"><span class="hljs-string">"error"</span></span>))</code> </pre> <br><p style=";text-align:right;direction:rtl">  يعتمد التعافي من <em>الكوارث</em> في Go على استدعاء دالة مؤجلة ، يُعرف أيضًا <em>بالتأجيل</em> .  ويضمن تنفيذ هذه الوظيفة عند العودة من الوظيفة الأم.  بغض النظر عن السبب - بيان العودة أو نهاية الوظيفة أو الذعر. </p><br><p style=";text-align:right;direction:rtl">  والآن تتيح وظيفة <em>الاسترداد</em> الحصول على معلومات حول الحادث وإيقاف فك مكدس المكالمة. <br>  مكالمة ومعالج ذعر نموذجي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>{ fmt.Printf(<span class="hljs-string"><span class="hljs-string">"panic: %s"</span></span>, err) } }() foo() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(errors.New(<span class="hljs-string"><span class="hljs-string">"error"</span></span>)) }</code> </pre> <br><p style=";text-align:right;direction:rtl">  استرداد الواجهة الواجهة {} (التي نمررها للذعر) أو لا شيء إذا لم يكن هناك دعوة للذعر. </p><br><p style=";text-align:right;direction:rtl">  فكر في مثال آخر للتعامل مع حالات الطوارئ.  لدينا بعض الوظائف التي ننقل إليها على سبيل المثال موردًا ، والتي من الناحية النظرية ، يمكن أن تسبب الذعر. </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f *os.File)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(errors.New(<span class="hljs-string"><span class="hljs-string">"error"</span></span>)) }</code> </pre> <br><p style=";text-align:right;direction:rtl">  أولاً ، قد تحتاج إلى تنفيذ بعض الإجراءات دائمًا في النهاية ، على سبيل المثال ، تنظيف الموارد ، في حالتنا ، إغلاق الملف. </p><br><p style=";text-align:right;direction:rtl">  ثانيًا ، يجب ألا يؤدي التنفيذ غير الصحيح لهذه الوظيفة إلى نهاية البرنامج بالكامل. </p><br><p style=";text-align:right;direction:rtl">  يمكن حل هذه المشكلة بتأجيل واسترداد وإغلاق: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { file, _ := os.Open(<span class="hljs-string"><span class="hljs-string">"file"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); r != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = r.(error) <span class="hljs-comment"><span class="hljs-comment">//   ,   ,     // err := errors.New("trapped panic: %s (%T)", r, r) //     } file.Close() //   }() bar(file) return err }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  يسمح لنا الإغلاق بالانتقال إلى المتغيرات المعلنة أعلاه ، وبفضل هذا نضمن إغلاق الملف وفي حالة وقوع حادث ، واستخراج خطأ منه ونقله إلى آلية معالجة الأخطاء المعتادة. </p><br><p style=";text-align:right;direction:rtl">  هناك حالات عكسية عندما يجب أن تعمل وظيفة بحجج معينة بشكل صحيح دائمًا ، وإذا لم يحدث ذلك ، فستكون سيئة حقًا. </p><br><p style=";text-align:right;direction:rtl">  في مثل هذه الحالات ، أضف دالة مجمعة يتم فيها استدعاء الوظيفة المستهدفة ، وفي حالة حدوث خطأ ، يتم استدعاء الذعر. </p><br><p style=";text-align:right;direction:rtl">  اذهب عادة يحتوي على بادئات <em>Must</em> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// MustCompile is like Compile but panics if the expression cannot be parsed. // It simplifies safe initialization of global variables holding compiled regular // expressions. func MustCompile(str string) *Regexp { regexp, error := Compile(str) if error != nil { panic(`regexp: Compile(` + quote(str) + `): ` + error.Error()) } return regexp }</span></span></code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Must is a helper that wraps a call to a function returning (*Template, error) // and panics if the error is non-nil. It is intended for use in variable initializations // such as // var t = template.Must(template.New("name").Parse("html")) func Must(t *Template, err error) *Template { if err != nil { panic(err) } return t }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  تجدر الإشارة إلى شيء آخر يتعلق بالذعر والكوروتينات. </p><br><p style=";text-align:right;direction:rtl">  جزء من الأطروحات عما نوقش أعلاه: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يتم تخصيص مجموعة منفصلة لكل غوروتين. </li><li style=";text-align:right;direction:rtl">  عند استدعاء الذعر ، يتم البحث عن الاسترداد على المكدس. </li><li style=";text-align:right;direction:rtl">  في حالة عدم العثور على الاسترداد ، يتم إنهاء التطبيق بالكامل. </li></ul><br><p style=";text-align:right;direction:rtl">  المعالج الرئيسي لن يعترض الذعر من foo وسيتعطل البرنامج: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>{ fmt.Printf(<span class="hljs-string"><span class="hljs-string">"panic: %s"</span></span>, err) } }() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> foo() time.Sleep(time.Minute) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(errors.New(<span class="hljs-string"><span class="hljs-string">"error"</span></span>)) }</code> </pre> <br><p style=";text-align:right;direction:rtl">  ستكون هذه مشكلة إذا تم ، على سبيل المثال ، استدعاء معالج للاتصال بالخادم.  في حالة حدوث ذعر في أي من المعالجات ، سيكمل الخادم بأكمله التنفيذ.  ولا يمكنك التحكم في التعامل مع الحوادث في هذه الوظائف لسبب ما. <br>  في حالة بسيطة ، قد يبدو الحل كالتالي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Def</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn f)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"panic"</span></span>) } }() fn() }() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Def(foo) time.Sleep(time.Minute) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(errors.New(<span class="hljs-string"><span class="hljs-string">"error"</span></span>)) }</code> </pre> <br><h1 id="handlecheck" style=";text-align:right;direction:rtl">  التعامل / الاختيار </h1><br><p style=";text-align:right;direction:rtl">  ربما سنرى في المستقبل تغييرات في معالجة الأخطاء.  يمكنك التعرف عليهم من خلال الروابط: <br>  <a href="">go2draft</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">معالجة الخطأ في Go 2</a> </p><br><p style=";text-align:right;direction:rtl">  هذا كل شيء لهذا اليوم.  شكرا لك! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar422419/">https://habr.com/ru/post/ar422419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar422409/index.html">Python: البرمجة التخطيطية في الإنتاج. الجزء الأول</a></li>
<li><a href="../ar422411/index.html">أدوار جديدة في الشركات في عصر الخدمة</a></li>
<li><a href="../ar422413/index.html">تطبيق Arm Mbed OS. ضبط دقيق</a></li>
<li><a href="../ar422415/index.html">Python: البرمجة التخطيطية في الإنتاج. الجزء الثاني</a></li>
<li><a href="../ar422417/index.html">Slavik و GMT + 3 أو فائدة للناس</a></li>
<li><a href="../ar422421/index.html">ستقوم Microsoft بتحسين Skype بشكل جذري</a></li>
<li><a href="../ar422423/index.html">Python و DataScience: استكشاف قوة المكتبة العالمية Numpy</a></li>
<li><a href="../ar422425/index.html">نظرة عامة على طرق ما بعد المعالجة لنماذج FDM المطبوعة ثلاثية الأبعاد</a></li>
<li><a href="../ar422427/index.html">داغاز: خارج الضباب</a></li>
<li><a href="../ar422429/index.html">نحن نسرع ​​من عملية تطوير المشاريع المعقدة. بدون فوضى وأعصاب</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>