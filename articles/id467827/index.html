<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ• ğŸ‘©ğŸ»â€ğŸ”¬ ğŸ¦ƒ Bagaimana kami melakukan Unity kecil kami dari awal ğŸ¦‰ âš›ï¸ ğŸ¤™ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perusahaan kami memiliki mesin gim sendiri, yang digunakan untuk semua gim yang dikembangkan. Ini menyediakan semua fungsi dasar yang penting: 



- r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami melakukan Unity kecil kami dari awal</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/467827/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/068/6b5/6f2/0686b56f20b410c39eb8fb1b33fd3dab.png"></a> <br><br>  Perusahaan kami memiliki mesin gim sendiri, yang digunakan untuk semua gim yang dikembangkan.  Ini menyediakan semua fungsi dasar yang penting: <br><br><ul><li>  rendering </li><li>  bekerja dengan SDK; </li><li>  bekerja dengan sistem operasi; </li><li>  dengan jaringan dan sumber daya. </li></ul><br>  Namun, ia tidak memiliki nilai untuk Unity - sistem yang nyaman untuk mengatur adegan dan objek game, serta editor untuk mereka. <br><br>  Di sini saya ingin memberi tahu bagaimana kami memperkenalkan semua fasilitas ini dan apa yang kami lakukan. <br><a name="habracut"></a><br><h2>  Apa yang sekarang </h2><br>  Sekarang kami memiliki beberapa kemiripan sistem komponen dalam Unity dengan semua subsistem dan editor penting.  Namun, karena kami melanjutkan dari kebutuhan proyek spesifik kami, ada perbedaan yang cukup signifikan. <br><br>  Kami memiliki objek visual yang disimpan dalam adegan.  Objek-objek ini terdiri dari node yang diatur dalam hierarki dan setiap node dapat memiliki sejumlah entitas, seperti: <br><br><ul><li>  Transform - transformasi node; </li><li>  Komponen - terlibat dalam rendering dan hanya ada satu atau tidak sama sekali.  Komponennya adalah sprite, mesh, partikel, dan entitas lain yang dapat ditampilkan.  Persamaan terdekat dengan Unity adalah Renderer; </li><li>  Perilaku - bertanggung jawab atas perilaku, dan mungkin ada beberapa.  Ini adalah analog langsung dari MonoBehaviour in Unity, logika apa pun tertulis di dalamnya; </li><li>  Sortasi adalah suatu entitas yang bertanggung jawab atas urutan di mana node dalam sebuah adegan ditampilkan.  Karena sistem kami seharusnya mudah diintegrasikan ke dalam game yang sudah berjalan, dengan logika yang ada dan beragam untuk menampilkan objek, perlu untuk dapat mengintegrasikan entitas baru ke yang lama.  Jadi penyortiran memungkinkan Anda untuk mentransfer kendali atas urutan tampilan ke kode eksternal. </li></ul><br>  Seperti halnya Unity, programmer membuat komponen, perilaku, atau pengurutan.  Untuk melakukan ini, cukup tulis sebuah kelas, definisikan kembali peristiwa yang diperlukan (Perbarui, OnStart, dll.) Dan tandai bidang yang diperlukan dengan cara khusus.  Di UnrealEngine, ini dilakukan dengan makro, dan kami memutuskan untuk menggunakan tag di komentar. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// @category(VSO.Basic) class SpriteComponent : public MaterialComponent { VISUAL_CLASS(MaterialComponent) public: /// @getter const std::string&amp; GetId() const; /// @setter void SetId(const std::string&amp; id); protected: void OnInit() override; void Draw() override; protected: /// @property Color _color = Color::WHITE; /// @property Sprite _sprite; };</span></span></code> </pre> <br>  Lebih lanjut di kelas, dengan mempertimbangkan tag, semua kode akan dihasilkan, yang diperlukan untuk menyimpan dan memuat data, untuk pekerjaan editor, untuk mendukung kloning dan fungsi kecil lainnya. <br><br>  Serialisasi dan generasi editor otomatis didukung tidak hanya untuk entitas yang disimpan dalam objek visual, tetapi juga untuk kelas apa pun.  Untuk melakukan ini, cukup mewarisi itu dari kelas Serializable khusus dan menandai properti yang diperlukan dengan tag.  Dan jika Anda ingin instance kelas menjadi aset penuh (analog dari ScriptableObject dari Unity), maka kelas harus diwarisi dari kelas Aset. <br><br>  Akibatnya, perpustakaan menyediakan kesempatan untuk dengan cepat mengembangkan fungsionalitas baru.  Dan sekarang bagian dari pekerjaan mengembangkan game, misalnya, membuat efek, tata letak UI, desain adegan permainan, dapat ditransfer ke spesialis yang dapat menanganinya lebih baik daripada programmer. <br><br><h1>  Blok utama </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/d29/5a9/e99/d295a9e992eae41c1b8039ce92d6d168.png"><br><br><h2>  Pembuatan Kode </h2><br>  Agar banyak sistem dapat berfungsi, Anda perlu menulis cukup banyak kode rutin, yang diperlukan karena kurangnya refleksi dalam C ++ ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">refleksi</a> - kemampuan untuk mengakses informasi tentang jenis-jenis dalam kode program).  Karenanya, kami menghasilkan sebagian besar kode teknis ini. <br><br>  Generator adalah satu set skrip python yang mengurai file header dan menghasilkan kode yang diperlukan berdasarkan mereka.  Untuk pengaturan generasi yang fleksibel, tag khusus digunakan dalam komentar. <br><br>  Kami dapat menghasilkan kode untuk subsistem berikut: <br><br><ul><li>  Serialisasi - digunakan untuk menyimpan / memuat data dari disk atau saat transmisi melalui jaringan.  Akan dipertimbangkan lebih detail nanti. </li><li>  Binding untuk perpustakaan refleksi - digunakan untuk secara otomatis menampilkan editor ke data.  Akan dibahas pada bab tentang editor. </li><li>  Kode untuk entitas kloning - digunakan untuk mengkloning entitas dalam editor dan dalam game. </li><li>  Kode untuk refleksi runtime ringan kami. </li></ul><br>  â†’ Contoh kode yang dihasilkan untuk satu kelas dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditemukan di sini.</a> <br><br><h3>  Parsing c ++ </h3><br>  Hampir semua opsi untuk menyelesaikan masalah parsing file header menyebabkan parsing kode dengan dentang.  Tetapi setelah percobaan, menjadi jelas bahwa kecepatan solusi seperti itu tidak cocok untuk kita sama sekali.  Selain itu, kekuatan yang diberikan dentang tidak diperlukan untuk kita. <br><br>  Oleh karena itu, solusi lain ditemukan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CppHeaderParser</a> .  Ini adalah pustaka file tunggal python yang dapat membaca file header.  Ini sangat primitif, tidak mengikuti #include, melompati makro, tidak menguraikan karakter, dan bekerja sangat cepat. <br><br>  Kami masih menggunakannya hingga hari ini, namun, kami harus melakukan cukup banyak pengeditan untuk memperbaiki bug dan memperluas kemampuan kami, khususnya, dukungan untuk inovasi dari C ++ 17 telah ditambahkan. <br><br>  Kami ingin menghindari kesalahpahaman terkait dengan ketidakpastian status pembuatan kode.  Oleh karena itu, diputuskan bahwa generasi harus terjadi sepenuhnya secara otomatis.  Kami menggunakan CMake, di mana generasi dimulai pada setiap kompilasi (kami tidak dapat mengonfigurasi generasi untuk memulai hanya ketika dependensi berubah).  Agar ini tidak memakan banyak waktu dan tidak mengganggu, kami menyimpan cache dengan hasil parsing semua file dan isi direktori.  Akibatnya, awal pembuatan kode hanya membutuhkan beberapa detik. <br><br><h3>  Pembuat kode </h3><br>  Dengan generasi, semuanya lebih sederhana.  Ada banyak perpustakaan untuk menghasilkan apa pun dari templat.  Kami memilih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Templite +</a> , karena sangat kecil, memiliki fungsi yang diperlukan dan berfungsi dengan baik. <br><br>  Ada dua pendekatan untuk generasi.  Versi pertama berisi banyak kondisi, pemeriksaan, dan kode lainnya, sehingga templatnya sendiri minimal, dan sebagian besar logika dan teks yang dihasilkan dalam kode python.  Itu nyaman, karena dalam kode python lebih mudah untuk menulis daripada di template, dan mudah untuk mengacaukan logika rumit sewenang-wenang.  Namun, ini juga mengerikan, karena kode python, dicampur dengan sejumlah besar baris kode C ++, tidak nyaman untuk membaca atau menulis.  Generator python yang digunakan menyederhanakan situasi, tetapi tidak menghilangkan masalah secara keseluruhan. <br><br>  Oleh karena itu, versi generasi saat ini didasarkan pada template, dan kode python hanya menyiapkan data yang diperlukan dan sekarang terlihat jauh lebih baik. <br><br><h2>  Serialisasi </h2><br>  Untuk serialisasi, berbagai perpustakaan dipertimbangkan: protobuf, FlexBuffers, sereal, dll. <br><br>  Perpustakaan dengan pembuatan kode (Protobuf, FlatBuffers dan lainnya) tidak cocok, karena kami memiliki struktur tulisan tangan dan tidak ada cara untuk mengintegrasikan struktur yang dihasilkan ke dalam kode pengguna.  Dan untuk menggandakan jumlah kelas hanya untuk serialisasi terlalu boros. <br><br>  Perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sereal</a> tampaknya menjadi kandidat terbaik - sintaksis yang bagus, implementasi yang jelas, lebih mudah untuk menghasilkan kode serialisasi.  Namun, format binernya tidak sesuai dengan kami, seperti format sebagian besar pustaka lainnya.  Persyaratan format penting adalah kebebasan dari perangkat keras (data harus dibaca terlepas dari urutan byte dan kedalaman bit) dan format biner harus sesuai untuk penulisan dari python. <br><br>  Menulis file biner dari python adalah penting, karena kami ingin memiliki skrip universal platform-independen dan proyek-independen yang akan mengkonversi data dari tampilan teks ke file biner.  Oleh karena itu, kami menulis skrip yang ternyata menjadi alat serialisasi yang sangat nyaman. <br><br>  Gagasan utama diambil dari sereal, didasarkan pada arsip dasar untuk membaca dan menulis data.  Ahli waris yang berbeda dibuat dari mereka yang mengimplementasikan catatan dalam format yang berbeda: xml, json, binary.  Dan kode serialisasi dihasilkan oleh kelas dan menggunakan arsip ini untuk menulis data. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/86c/da6/ad7/86cda6ad7a17970a83905246c8852d0d.png"><br><br><h2>  Editor </h2><br>  Kami menggunakan perpustakaan ImGui untuk editor, di mana kami menulis semua jendela editor utama: konten adegan, penampil file dan aset, pemeriksa aset, editor animasi, dll. <br><br>  Kode editor utama ditulis dengan tangan, tetapi untuk melihat dan mengedit properti kelas tertentu, kami menggunakan pustaka rttr, binning yang dihasilkan untuknya dan kode inspektur umum yang dapat bekerja dengan rttr. <br><br><h3>  Perpustakaan Refleksi - rttr </h3><br>  Untuk mengatur refleksi dalam C ++, perpustakaan rttr dipilih.  Itu tidak memerlukan intervensi di dalam kelas itu sendiri, memiliki API yang nyaman dan dapat dimengerti, memiliki dukungan untuk koleksi dan pembungkus atas jenis (seperti smart pointer) dengan kemampuan untuk mendaftarkan pembungkus Anda dan memungkinkan Anda untuk melakukan apa pun yang diperlukan (membuat jenis, beralih ke anggota kelas, mengubah properti, metode panggilan, dll.). <br><br>  Ini juga memungkinkan Anda untuk bekerja dengan pointer, seperti dengan bidang biasa, dan menggunakan pola objek nol, yang sangat menyederhanakan bekerja dengannya. <br><br>  Kekurangan dari perpustakaan adalah besar dan tidak terlalu cepat, jadi kami menggunakannya hanya untuk editor.  Dalam kode permainan untuk bekerja dengan parameter objek, misalnya, untuk sistem animasi, kami menggunakan perpustakaan refleksi paling sederhana dari produksi kami sendiri. <br><br>  Pustaka rttr membutuhkan penulisan penjilidan dengan pernyataan semua metode dan properti kelas.  Ikatan ini dihasilkan dari kode python untuk semua kelas yang membutuhkan dukungan pengeditan.  Dan karena fakta bahwa rttr dapat menambahkan metadata untuk entitas apa pun, pembuat kode dapat mengatur pengaturan yang berbeda untuk anggota kelas: tooltips, parameter batas nilai yang dapat diterima untuk bidang numerik, inspektur khusus untuk bidang tersebut, dll. Metadata ini digunakan di inspektur untuk menampilkan antarmuka pengeditan. . <br><br>  â†’ Contoh kode untuk mendeklarasikan kelas dalam rttr dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditemukan di sini</a> <br><br><h3>  Inspektur </h3><br>  Kode editor itu sendiri sangat jarang bekerja dengan rttr secara langsung.  Lapisan yang paling umum digunakan adalah bahwa objek dapat menggambar inspektur ImGui untuk itu.  Ini adalah kode tulisan tangan yang berfungsi dengan data dari rttr dan menggambar kontrol ImGui untuknya. <br><br>  Untuk menyesuaikan tampilan antarmuka pengeditan data, metadata yang ditentukan saat pendaftaran di rttr digunakan.  Kami mendukung semua jenis primitif, koleksi, dimungkinkan untuk membuat objek yang disimpan oleh nilai dan oleh pointer.  Jika anggota kelas adalah penunjuk ke kelas dasar, maka Anda dapat memilih pewaris tertentu selama pembuatan. <br><br>  Juga, kode inspektur mengambil dukungan untuk membatalkan operasi - ketika mengubah nilai, perintah dibuat untuk mengubah data, yang kemudian dapat digulirkan kembali. <br><br>  Sejauh ini, kami tidak memiliki sistem untuk menentukan perubahan atom dengan kemampuan untuk melihat dan menyimpannya.  Ini berarti bahwa kami tidak memiliki dukungan untuk menyimpan properti yang diubah dari objek ke tempat kejadian dan menerapkan perubahan ini setelah memuat cetakan.  Dan juga tidak ada pembuatan otomatis trek animasi ketika mengubah properti suatu objek. <br><br><h3>  Windows dan editor </h3><br>  Saat ini, berbagai subsistem dan editor telah dibuat berdasarkan editor, pembuatan kode, dan sistem penciptaan aset kami: <br><br><ul><li>  Sistem antarmuka game menyediakan tata letak yang fleksibel dan nyaman dan mencakup semua elemen antarmuka yang diperlukan.  Sistem scripting visual perilaku jendela dibuat untuknya. </li><li>  Sistem untuk beralih status animasi mirip dengan editor negara dalam animasi di Unity, tetapi agak berbeda dengan prinsip operasi dan memiliki aplikasi yang lebih luas. </li><li>  Perancang pencarian dan acara memungkinkan Anda untuk secara fleksibel menyesuaikan acara permainan, pencarian dan tutorial, hampir tanpa partisipasi programmer. </li></ul><br>  Ketika mengembangkan semua subsistem dan editor ini, kami mengamati <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unity</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unreal Engine,</a> dan berusaha mengambil yang terbaik dari mereka.  Dan beberapa subsistem ini dibuat di sisi proyek game. <br><br><h2>  Untuk meringkas </h2><br>  Sebagai kesimpulan, saya ingin menggambarkan bagaimana pengembangan dilakukan.  Versi kerja pertama dibuat dan diintegrasikan ke dalam beberapa proyek game oleh beberapa orang hanya dalam waktu dua bulan.  Belum memiliki generasi kode, dan banyaknya editor yang sekarang.  Pada saat yang sama, itu adalah versi yang berfungsi, dengan mana gerakan maju dimulai.  Tidak dapat dikatakan bahwa pada saat itu ini sesuai dengan vektor utama pengembangan mesin, semuanya bertumpu pada antusiasme beberapa orang dan pemahaman yang jelas tentang perlunya dan kebenaran dari apa yang kami lakukan. <br><br>  Semua pengembangan selanjutnya dilakukan dengan sangat aktif dan evolusioner, langkah demi langkah, tetapi selalu mempertimbangkan kepentingan proyek game.  Saat ini, lebih dari sepuluh orang sedang mengerjakan pengembangan "Persatuan kecil kami" dan pengembangan versi baru tidak lagi secepat dan secepat sebelumnya. <br><br>  Namun demikian, kami telah mencapai hasil yang luar biasa hanya dalam beberapa tahun dan tidak akan berhenti.  Saya berharap Anda bergerak maju ke apa yang Anda anggap benar dan penting bagi diri Anda dan perusahaan secara keseluruhan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467827/">https://habr.com/ru/post/id467827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467815/index.html">Media menimbulkan kepanikan bahwa "alamat IP kehabisan di Rusia." Bagaimana bisa?</a></li>
<li><a href="../id467817/index.html">Sedikit tentang pola desain generatif</a></li>
<li><a href="../id467821/index.html">Sederhanakan dan Potong yang Dibutuhkan: Wawancara dengan John Romero, pencipta Doom</a></li>
<li><a href="../id467823/index.html">Parsing: OOM di Kubernetes</a></li>
<li><a href="../id467825/index.html">Algoritma pembelajaran mesin harus dimiliki</a></li>
<li><a href="../id467831/index.html">Jalan Berduri menuju Pemrograman</a></li>
<li><a href="../id467837/index.html">MCU tiga sen "Mengerikan" - tinjauan singkat mikrokontroler dengan biaya kurang dari $ 0,1</a></li>
<li><a href="../id467841/index.html">Buat lebih mudah untuk selesai: Wawancara dengan John Romero, pengembang Doom</a></li>
<li><a href="../id467843/index.html">Bagaimana cara menyimpan hingga setengah juta dolar dalam AWS?</a></li>
<li><a href="../id467847/index.html">"Evolusi omnichannel IoT" atau bagaimana Internet dapat memengaruhi omnichannel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>