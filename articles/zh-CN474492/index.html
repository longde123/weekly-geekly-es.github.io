<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥀 😗 👩🏿‍🤝‍👩🏻 与Chatix后端进行多用户聊天 🌈 📏 👍🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="现在，我将向您展示如何在没有后端或不想花时间开发后端的情况下为团队/用户/朋友聊天。 我们将进行简单的文本聊天，大约需要一个小时。 


要编写没有后端的有效网络聊天几乎是不可能的，它必须采用一种或另一种形式。 我们将使用Chatix及其JavaScript SDK。 Chatix和SDK将从事消息...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>与Chatix后端进行多用户聊天</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474492/"><p><img src="https://habrastorage.org/getpro/habr/post_images/d7e/212/ac4/d7e212ac471c99b0cd61dd0e75aab281.png" alt="Chatix聊天室"></p><br><p> 现在，我将向您展示如何在没有后端或不想花时间开发后端的情况下为团队/用户/朋友聊天。 我们将进行简单的文本聊天，大约需要一个小时。 </p><br><p>要编写没有后端的有效网络聊天几乎是不可能的，它必须采用一种或另一种形式。 我们将使用Chatix及其JavaScript SDK。  Chatix和SDK将从事消息存储和网络任务，我们将处理前端。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">完成的项目代码可在GitHub上找到</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示版</a> </p><a name="habracut"></a><br><h2 id="struktura-proekta"> 项目结构 </h2><br><ul><li>  App（应用程序的根组件，充当状态守护者，因为在本课程中，我们不会添加Redux或任何其他状态管理器） <br><ul><li> 标头（显示徽标，聊天名称并允许用户输入其名称的应用程序标头） </li><li>  LogoHeader </li><li> 房间标题 </li><li> 主要的 </li><li>  MemberList（聊天列表） <br><ul><li>  MemberItem [] </li></ul></li><li>  ChatField（包含与聊天消息相关的所有内容的容器） <br><ul><li> 邮件容器 </li><li>  Message []（消息的演示；在本课程中，我们仅处理文本消息） </li><li>  SendMessageForm（用于发送新聊天消息的表单） </li></ul></li><li>  ChatixSDK（无头组件，负责后端） </li></ul></li></ul><br><blockquote>有关状态存储的重要说明。 当然，在此处添加Redux并通过它处理状态更改会更加方便，但是为了节省时间，我们将状态存储在App的根组件中，并将数据转发给子组件并从子方法中调用它们的父代。 <br> 例如，当我们获得聊天的名称时，我们会将其保存为App组件的状态，并将其通过以下<code>App → Header → RoomTitle</code>传递： <code>App → Header → RoomTitle</code> 。 当用户编写消息时，我们会将其从SendMessageForm传输到App： <code>SendMessageForm → ChatField → Main → App</code> 。 </blockquote><p> 我们的聊天在设计中将如下所示： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d1e/096/b73/d1e096b7349824c510542cc215ae437e.png" alt="chatix.io"></p><br><h2 id="vzaimodeystvie-mezhdu-komponentami"> 组件之间的交互 </h2><br><p> 我们的组件必须相互之间传输数据，并且为了使一切正常工作，现在让我们确定它们之间的交互方式。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fde/009/821/fde0098218938f714d32a58ad9776ec9.png" alt="组件互动"></p><br><p> 正如您在图中所看到的，对我们来说主要的组件是<code>App</code> ，它向子组件提供数据（由于反应性，我们只需分配<code>prop</code>并且子组件将响应更改），并且子组件相继将方法调用转发给<code>App</code> 。 这不是可以（并且应该）为生产项目完成的最佳架构，但是它将为我们的课程做准备。 </p><br><h2 id="sozdanie-proekta"> 项目创建 </h2><br><h3 id="sozdaem-vizualnye-komponenty"> 创建视觉组件 </h3><br><h4 id="shapka"> 帽子 </h4><br><ol><li><p> 首先，您需要创建一个新项目，为此，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">create-react-app</a> 。 </p><br><pre> <code class="plaintext hljs">npx create-react-app chatix-chatroom cd chatix-chatroom</code> </pre> <br><p> 使用命令运行项目 </p><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br></li><li><p> 让我们从创建标题开始。 <br> 首先，将徽标添加到标题。 为此，请在src文件夹中创建<strong>components</strong>文件夹，并在其中创建<strong>logo_header</strong>文件夹。 我们将徽标上传到此文件夹，并创建2个<strong>LogoHeader.js</strong>和<strong>LogoHeader.css文件</strong> </p><br></li></ol><br><p>  <strong>LogoHeader.js</strong> </p><br><pre> <code class="plaintext hljs">import React from 'react' import logo from './chatix_logo.svg'; import './LogoHeader.css'; function LogoHeader(){ return ( &lt;div className="LogoHeader"&gt; &lt;img src={logo} className="App-logo" alt="Chatix logo" /&gt; &lt;/div&gt; ); } export default LogoHeader;</code> </pre> <br><p>  <strong>LogoHeader.css</strong> </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.LogoHeader</span></span>{ <span class="hljs-attribute"><span class="hljs-attribute">flex-basis</span></span>: <span class="hljs-number"><span class="hljs-number">200px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-grow</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-shrink</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p> 此处的所有内容都很清楚，只需导入带有徽标和样式的文件即可。 </p><br><p> 我将不再在此处添加样式表的代码，您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">完成的项目</a>页面上看到它们 </p><br><p> 现在显示聊天室的名称。 为此，请创建一个<strong>房间标题</strong>文件夹，并在其中创建<strong>RoomTitle</strong>组件。 我们将通过props将名称放入该组件中，因此我们编写了<code>props.chatroomName</code> ，现在将其转移到此处。 </p><br><p>  <strong>房间标题</strong> </p><br><pre> <code class="plaintext hljs">import React from 'react'; import './RoomTitle.css'; function RoomTitle(props){ return ( &lt;div className="RoomTitle"&gt; &lt;h1&gt;{props.chatroomName}&lt;/h1&gt; &lt;/div&gt; ); } export default RoomTitle;</code> </pre> <br><p> 然后，我们创建标题组件本身，并将徽标和聊天室的名称放入其中。 通过prop <code>chatroomName</code>立即将聊天名称放入子组件中。 </p><br><p> 提醒您，我们同意所有数据（应用程序状态）将由<strong>App</strong>的根组件存储。 通过它，我们将首先将<strong>标头</strong>传输到<strong>Header</strong> ，再从<strong>Header</strong>传输到<strong>RoomTitle</strong> 。 </p><br><p>  <strong>组件\标头\ Header.js</strong> </p><br><p>  <strong>Header.js</strong> </p><br><pre> <code class="plaintext hljs">import React from 'react'; import './Header.css' import LogoHeader from '../logo_header/LogoHeader'; import RoomTitle from '../room-title/RoomTitle'; function Header(props) { return ( &lt;header&gt; &lt;LogoHeader/&gt; &lt;RoomTitle chatroomName={props.chatroomName} /&gt; &lt;/header&gt; ); } export default Header;</code> </pre> <br><p> 接下来，打开<strong>App.js</strong>文件，并将<strong>Header.js</strong>组件添加到<strong>其中</strong> 。 <br> 然后，将名称添加到<strong>状态，</strong>然后通过<strong>props</strong>将其转发到<strong>标头</strong> 。 <br> 同样在标题中，您需要添加当前用户的名称。 为此，将用户对象添加到状态，然后类似地将其转发到标题 </p><br><pre> <code class="plaintext hljs">import React from 'react'; import './App.css'; import Header from './components/header/Header'; class App extends React.Component { constructor(props){ super(props); chatroomName: '-', me: { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" } } render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} /&gt; &lt;/div&gt; ); }; } export default App;</code> </pre> <br><p> 现在，您需要在标题中添加带有当前用户名的输入，并分配要更改的处理程序，以便我们可以将新的用户名转移到<strong>App</strong>组件。 </p><br><p> 为此，我们将名称为名称的<code>handleChangeName</code>函数<code>props.updateVisitor</code>添加到输入中，并调用<code>props.updateVisitor</code>回调函数，在其中我们将使用更新后的名称传递给用户对象。 </p><br><p>  <strong>Header.js</strong> </p><br><pre> <code class="plaintext hljs">function Header(props) { const [name, setName] = useState(props.me.name ? props.me.name : props.me.uuid.substr(-10)) const handleChangeName = (e) =&gt; { setName(e.target.value) let visitor = {...props.me}; visitor.name = e.target.value; props.updateVisitor(visitor) } return ( &lt;header&gt; &lt;LogoHeader/&gt; &lt;RoomTitle chatroomName={props.chatroomName}/&gt; { props.me ? &lt;input className='name-input' value={name} placeholder=' ' onChange={(e) =&gt; handleChangeName(e)} /&gt; : null } &lt;/header&gt; ); }</code> </pre> <br><p> 现在，将此功能<code>props.updateVisitor</code>添加到<strong>App</strong>并将其<code>props.updateVisitor</code>到<code>props.updateVisitor</code> 。 到目前为止，它只是更新状态下的用户对象，但是通过它，我们将更新服务器上的用户。 </p><br><pre> <code class="plaintext hljs">onUpdateVisitor = (visitor) =&gt; { this.setState({me: visitor}) }</code> </pre> <br><p> 因此，现在我们的应用程序看起来像这样，到目前为止，只知道如何更新名称。 继续前进 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/685/7ec/243/6857ec2435f476e8d6dad5201d7909a5.png" alt="聊天室标题"></p><br><h4 id="saydbar"> 侧边栏 </h4><br><p> 现在开始创建侧边栏。 <br> 侧栏将位于<strong>Main.js</strong>页面上的主要组件内。 <br> 我们先创建一个<strong>components \ main \ Main.js</strong> ，然后创建一个包含用户<strong>组件</strong>列表的<strong>组件\ member-list \ MemberList.js，</strong>然后立即创建一个组件，该组件将显示用户自己的<strong>components \ member-item \ MemberItem.js</strong> 。 </p><br><p> 为了更清楚地说明这三个组件之间的关系，请查看本文开头的项目大纲。 </p><br><p> 组件已创建，现在让我们按顺序进行。 <br> 首先，将用户数组添加到<strong>App</strong>组件的状态，然后添加<strong>Main</strong>组件。 然后，我们会将这些用户转发到其中。 </p><br><p>  <strong>该应用程序</strong> </p><br><pre> <code class="plaintext hljs">class App extends React.Component { constructor(props) { super(props); this.state = { chatroomName: '-', members: [ { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" }, { is_online: true, name: "", uuid: "mnzxcv97zx6chvo" }, { is_online: false, name: "", uuid: "kjuhv987ashdfoua" }, { is_online: false, name: "", uuid: "jdhnf978WEHJSNDL" }, ], me: { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" } }; } render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} /&gt; &lt;Main members={this.state.members} me={this.state.me} /&gt; &lt;/div&gt; ); }; }</code> </pre> <br><p> 在<strong>Main</strong>组件中，添加<strong>MemberList</strong>组件并将用户数组转发到其中。 </p><br><p>  <strong>Main.js</strong> </p><br><pre> <code class="plaintext hljs">function Main(props) { return( &lt;section className="Main"&gt; &lt;MemberList members={props.members} /&gt; &lt;/section&gt; ); }</code> </pre> <br><p> 在<strong>MemberList</strong>组件中<strong>，</strong>我们遍历所有用户，并为每个用户返回<strong>MemberItem</strong>组件并将用户对象传递给它。 </p><br><p>  <strong>MemberList.js</strong> </p><br><pre> <code class="plaintext hljs">function MemberList(props) { const members = props.members.map((member) =&gt; &lt;MemberItem key={member.uuid} member={member} /&gt; ); return ( &lt;section className="MemberList"&gt; {members} &lt;/section&gt; ); }</code> </pre> <br><p>  <strong>MemberItem</strong>组件已经在边栏中直接显示用户。 在其中，我们检查用户名（如果未安装），然后显示标识符的前10个字符。 我们还将检查在线/离线状态，并将标识符与当前用户的标识符进行比较，以便在他的对面显示“（您）”标记。 </p><br><pre> <code class="plaintext hljs">function MemberItem(props) { function getName(){ let name = '' if (props.member.uuid === props.me.uuid) { if(props.me.name) { name = props.me.name } else { name = props.me.uuid.substring(props.me.uuid.length-10, props.me.uuid.length); } } else { if(props.member.name){ name = props.member.name } else { name = props.member.uuid.substring(props.member.uuid.length-10, props.member.uuid.length); } } return name; } return( &lt;div className="MemberItem"&gt; &lt;img src={ icon } alt={ props.member.name }/&gt; &lt;span&gt; { getName() } { props.member.uuid === props.me.uuid &amp;&amp; " () " } &lt;/span&gt; { props.member.is_online &amp;&amp; &lt;span className="online"&gt;•&lt;/span&gt; } &lt;/div&gt; ); }</code> </pre> <br><p> 做完了 现在应用程序已经看起来像这样 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eba/512/a8b/eba512a8bca7de4b1487567775f7742b.png" alt="聊天室标题"></p><br><h4 id="spisok-soobscheniy-i-forma-otpravki"> 邮件列表和提交表格 </h4><br><p> 现在，我们将处理邮件列表和发送形式。 <br> 首先，将包含消息的数组添加到<strong>App</strong>组件的状态。 </p><br><p>  <strong>该应用程序</strong> </p><br><pre> <code class="plaintext hljs">this.state = { chatroomName: '-', messages: [ { content: " 1", sender_id: "mnzxcv97zx6chvo", uuid: "dg897sdfg" }, { content: " 2", sender_id: "98s7dfh9a8s7dhf", uuid: "8723hernm" }, { content: "  ", sender_id: "mnzxcv97zx6chvo", uuid: "435nbcv98234" } ], members: [ { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" }, { is_online: true, name: "", uuid: "mnzxcv97zx6chvo" }, { is_online: false, name: "", uuid: "kjuhv987ashdfoua" }, { is_online: false, name: "", uuid: "jdhnf978WEHJSNDL" }, ], me: { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" } };</code> </pre> <br><p> 并将它们转发到<strong>主要</strong>组件 </p><br><p>  <strong>该应用程序</strong> </p><br><pre> <code class="plaintext hljs"> &lt;Main members={this.state.members} messages={this.state.messages} me={this.state.me} /&gt;</code> </pre> <br><p> 现在创建组件组件<strong>/ chat-field / ChatField.js</strong> <br> 将其连接到<strong>Main</strong>并将消息转发给<strong>Main</strong> 。 </p><br><p>  <strong>主要的</strong> </p><br><pre> <code class="plaintext hljs">function Main(props) { return( &lt;section className="Main"&gt; &lt;MemberList me={props.me} members={props.members} /&gt; &lt;ChatField messages={props.messages} /&gt; &lt;/section&gt; ); }</code> </pre> <br><p> 接下来，创建组件组件<strong>/ message-container / MessageContainer.js</strong> <br> 将其连接到<strong>ChatField</strong>并将消息转发给它。 </p><br><p>  <strong>查特菲尔德</strong> </p><br><pre> <code class="plaintext hljs">function Main(props) { return( &lt;section className="Main"&gt; &lt;MemberList me={props.me} members={props.members} /&gt; &lt;ChatField messages={props.messages} /&gt; &lt;/section&gt; ); }</code> </pre> <br><p> 然后，我们将遍历所有消息，并为每个消息返回显示消息的组件。 <br> 让我们创建它<strong>conponents / message / Message.js</strong> 。 在其中，我们将显示访问者的图标，其名称或未指定名称的标识符以及消息文本本身。 </p><br><p>  <strong>留言内容</strong> </p><br><pre> <code class="plaintext hljs">function Message(props) { const getSenderName = () =&gt; { if (props.sender) { return props.sender.name ? props.sender.name : props.sender.uuid.substr(-10); } return "Unknown sender"; }; return( &lt;div className="Message"&gt; &lt;div className="message-sender-icon"&gt; &lt;img src={icon} alt="visitor icon"/&gt; &lt;/div&gt; &lt;div className="message-bubble"&gt; &lt;div className="message-sender-name"&gt;{getSenderName()}&lt;/div&gt; &lt;div className="message-content"&gt;{props.message.content}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); }</code> </pre> <br><p> 现在，在<strong>MessageContainer中，我们</strong>遍历所有消息，并为每个<strong>消息</strong>返回将消息对象传递给的<strong>Message</strong>组件。 </p><br><p>  <strong>邮件容器</strong> </p><br><pre> <code class="plaintext hljs">function MessageContainer(props) { const messageList = props.messages.map(message =&gt; &lt;Message key={message.uuid} sender={props.members.find((member) =&gt; member.uuid === message.sender_id)} message={message} /&gt; ); return ( &lt;section className="MessageContainer" ref={messagesContainer}&gt; {messageList} &lt;/section&gt; ); }</code> </pre> <br><p> 现在项目看起来像这样： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/74d/cad/f22/74dcadf22a3086fa2d7182e1aa791cab.png" alt="聊天室消息"></p><br><p> 现在，创建一个带有用于发送消息的表单的<strong>组件component / send-message-form / SendMessageForm.js</strong> 。 在其中，我们将创建一个输入和一个发送按钮。 更改输入后，会将其文本写入状态，然后单击按钮，我们将调用<code>onSendNewMessage</code>回调函数并将消息从状态传输到状态。  <code>onSendNewMessage</code>稍后将在<strong>App</strong>组件中创建<code>onSendNewMessage</code>函数，并将其通过props转发。 </p><br><p>  <strong>发送消息形式</strong> </p><br><pre> <code class="plaintext hljs">class SendMessageForm extends React.Component { constructor(props) { super(props); this.state = { message: '' }; } currentMessageChanged = (e) =&gt; { this.setState({message: e.target.value }); } sendMessageClicked = async (e) =&gt; { e.preventDefault(); if (this.state.message.length &gt; 0) { await this.props.onSendNewMessage(this.state.message); this.setState({...this.state, ...{message : ''}}); } } render(){ return ( &lt;section className="SendMessageForm"&gt; &lt;form&gt; &lt;input type="text" value={this.state.message} onChange={this.currentMessageChanged} placeholder="Type message to send"/&gt; &lt;button type="submit" onClick={this.sendMessageClicked} &gt; Send &lt;/button&gt; &lt;/form&gt; &lt;/section&gt; ); } }</code> </pre> <br><p> 现在，将<strong>SendMessageForm</strong>组件放置在<strong>ChatField中</strong> 。 </p><br><p>  <strong>查特菲尔德</strong> </p><br><pre> <code class="plaintext hljs">function ChatField(props) { return( &lt;section className="ChatField"&gt; &lt;MessageContainer members={props.members} messages={props.messages} /&gt; &lt;SendMessageForm onSendNewMessage={props.onSendNewMessage}/&gt; &lt;/section&gt; ); }</code> </pre> <br><p> 在<strong>Main</strong>组件中，我们还将<code>onSendNewMessage</code>中<code>onSendNewMessage</code>函数。 </p><br><p>  <strong>主要的</strong> </p><br><pre> <code class="plaintext hljs">&lt;ChatField members={props.members} messages={props.messages} onSendNewMessage={props.onSendNewMessage} /&gt;</code> </pre> <br><p> 现在在<strong>App中</strong>创建此功能，并将其转发给<strong>Main</strong> 。 </p><br><p>  <strong>该应用程序</strong> </p><br><pre> <code class="plaintext hljs">onSendNewMessage = async (message) =&gt; { console.log(message) }</code> </pre> <br><p>  <strong>该应用程序</strong> </p><br><pre> <code class="plaintext hljs">&lt;Main members={this.state.members} messages={this.state.messages} onSendNewMessage={this.onSendNewMessage} me={this.state.me} /&gt;</code> </pre> <br><p> 做完了 现在，当您单击发送消息按钮时，它将被传输到<strong>App</strong>组件。 <br> 现在，应用程序如下所示： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e53/89e/d31/e5389ed317bd0fb4bf87db34b05f57a6.png" alt="最终聊天室"></p><br><p> 因此，现在所有内容都显示在我们的应用程序中，并且一切正常运行，但是到目前为止，这些数据都是静态数据，为了使我们的聊天更加活跃，您需要将其与后端关联。 </p><br><h4 id="podklyuchenie-bekenda"> 后端连接 </h4><br><p> 为此，您需要做的第一件事是安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">chatix-core</a>软件包。 </p><br><pre> <code class="plaintext hljs">npm i chatix-core</code> </pre> <br><p> 然后在<strong>chatix</strong>上创建一个帐户并创建一个聊天室。 为此，请转到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">chatix.io</a>并注册。 <br> 注册后，您可以在聊天设置页面上的管理界面中看到<strong>websiteId</strong>网站<strong>标识符</strong> 。 </p><br><p> 现在，我们将创建一个新的聊天室，我们将使用该聊天室。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/38b/26d/034/38b26d03464c1b236beff17c4118ba00.png" alt="创建聊天室"></p><br><p> 我们返回到项目并创建一个新组件，通过该组件我们可以与服务器一起使用。 <br>  <strong>组件\ chatix \ ChatixSDK.js</strong> </p><br><p> 我们<strong>在其中</strong>导入<strong>ChatixCore。</strong> </p><br><pre> <code class="plaintext hljs">import ChatixCore from 'chatix-core';</code> </pre> <br><p> 在<strong>ChatixSDK</strong>组件中<strong>，</strong>创建<strong>ChatixCore</strong>类的实例，并将<strong>websiteId</strong>作为参数传递。 </p><br><pre> <code class="plaintext hljs">const websiteId = "_WEBSITE_ID"; this.sdk = new ChatixCore(websiteId);</code> </pre> <br><p> 现在，您可以在<strong>this.sdk</strong>中使用用于聊天室的方法。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">chatix-core</a>项目页面上查看方法列表 </p><br><p> 接下来，我们需要连接到服务器并获取有关先前创建的聊天室的数据。  <strong>为此</strong>有异步方法<strong>start（）</strong>和<strong>getChatroom（）</strong> 。 </p><br><p> 收到聊天室对象后，让我们立即获取其名称并将其传输到<strong>App</strong> 。 为此，在<strong>应用程序中</strong>添加回调函数<code>updateChatroomTitle(chatroom.title)</code>并在<strong>ChatixSDK</strong>中对其进行<strong>调用</strong> 。 </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">class ChatixSDK extends React.Component { constructor(props){ super(props); const websiteId = "_WEBSITE_ID"; this.chatroomId = "_CHATROOM_ID"; this.sdk = new ChatixCore(websiteId); this.sdk.start() .then( async () =&gt; { try { // refresh information about chatroom and call passed handler const chatroom = await this.sdk.getChatroom(this.chatroomId); if (props.updateChatroomTitle) { props.updateChatroomTitle(chatroom.title); } } catch (err) { console.error(err); } }) .catch((e) =&gt; { console.error(e); }); } render(){ return null; } }</code> </pre> <br><p> 您可以通过打开所需的聊天室在管理员界面中查看<code>this.chatroomId</code> 。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/57d/309/a77/57d309a77bb226589ba225c52cfe37d6.png" alt="聊天室ID"></p><br><p> 现在，在<strong>应用程序中，</strong>我们将连接<strong>ChatixSDK</strong>组件，并将updateChatroomTitle函数放入该组件中，这将更新聊天名称。 我们还向它添加了一个<code>ref</code>链接，以便我们可以访问此组件。 </p><br><p>  <strong>该应用程序</strong> </p><br><pre> <code class="plaintext hljs">this.chatixSDK = React.createRef();</code> </pre> <br><pre> <code class="plaintext hljs">setChatroomTitle = (newName) =&gt; { const newStateFragment = { chatroomName: newName}; this.setState({...this.state, ...newStateFragment}); };</code> </pre> <br><p>  <strong>该应用程序</strong> </p><br><pre> <code class="plaintext hljs">render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} updateVisitor={this.onUpdateVisitor} /&gt; &lt;Main members={this.state.members} messages={this.state.messages} onSendNewMessage={this.onSendNewMessage} me={this.state.me} /&gt; &lt;ChatixSDK ref={this.chatixSDK} updateChatroomTitle={this.setChatroomTitle} /&gt; &lt;/div&gt; ); };</code> </pre> <br><p> 做完了 现在，在连接到服务器之后，我们立即请求聊天数据，获取其名称并将其写入<strong>App</strong>组件的状态，由于状态的更改会导致该组件再次呈现，因此标头中的名称将自动更新。 现在，该状态下的默认名称可以替换为空字符串。 </p><br><p>  <strong>该应用程序</strong> </p><br><pre> <code class="plaintext hljs">chatroomName: ''</code> </pre> <br><p> 现在，让侧边栏填充真实用户。 <br> 但是，在获得需要连接到聊天的用户列表之前，为此，在<code>this.sdk.start()</code>函数内的<code>this.sdk.start()</code>我们获得了所有用户聊天室的列表，请检查它是否已连接到当前聊天室，如果没有，则将其连接。 </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">const myChatrooms = await this.sdk.getMyChatrooms(); if (myChatrooms.filter(x =&gt; x.id===this.chatroomId).length === 0) { await this.sdk.connectToChatroom(this.chatroomId); }</code> </pre> <br><p> 确定我们的用户已连接到聊天室之后，我们可以获取此聊天的参与者列表。 </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">// lets get all chatroom members using infinite loop with break on empty server response let membersPage = 1; let allChatroomMembers = []; while(true) { let pagedMembers = await this.sdk.getChatroomMembers(this.chatroomId, membersPage++, 10); allChatroomMembers = [...allChatroomMembers, ...pagedMembers]; if (pagedMembers.length === 0) { break; } }</code> </pre> <br><p> 在这里，在一个无限循环中，我们逐页请求用户，直到我们得到所有人为止，一旦我们获得所有人，我们便打破了循环。 之后，就像聊天室的名称一样，我们使用回调函数将其转发给父组件。 </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">if (props.setChatroomMembers) { props.setChatroomMembers(allChatroomMembers); }</code> </pre> <br><p> 现在，在<strong>App</strong>组件中，创建此回调函数<code>setChatroomMembers</code> ，该函数<code>setChatroomMembers</code>用户的联机/脱机状态并按字母顺序对用户进行排序并记录其状态。 </p><br><p>  <strong>App.js</strong> </p><br><pre> <code class="plaintext hljs">setChatroomMembers = (members) =&gt; { members.sort(this.sortMembers); const newStateFragment = { members: members}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> 添加排序功能<strong>sortMembers</strong> 。 它按状态和字母顺序对用户进行排序。 </p><br><p>  <strong>App.js</strong> </p><br><pre> <code class="plaintext hljs">sortMembers(a, b) { if (a.is_online === true &amp;&amp; b.is_online === false) { return -1; } else if (b.is_online === true &amp;&amp; a.is_online === false) { return 1; } else { if (a.name &amp;&amp; b.name) { if (a.name.toLocaleUpperCase() &gt; b.name.toLocaleUpperCase()) { return 1; } else if (a.name.toLocaleUpperCase() &lt; b.name.toLocaleUpperCase()) { return -1; } } else if (a.name &amp;&amp; !b.name) { return -1; } else if (!a.name &amp;&amp; b.name) { return 1; } if (a.uuid &gt; b.uuid) { return -1; } else { return 1; } } }</code> </pre> <br><p> 接下来，我们在ChatixSDK中转发setChatroomMembers函数。 </p><br><p>  <strong>该应用程序</strong> </p><br><pre> <code class="plaintext hljs">render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} updateVisitor={this.onUpdateVisitor} /&gt; &lt;Main members={this.state.members} messages={this.state.messages} onSendNewMessage={this.onSendNewMessage} me={this.state.me} /&gt; &lt;ChatixSDK ref={this.chatixSDK} updateChatroomTitle={this.setChatroomTitle} setChatroomMembers={this.setChatroomMembers} /&gt; &lt;/div&gt; ); };</code> </pre> <br><p> 现在，在连接到服务器之后，我们以及标头会立即请求所有已连接用户的列表，并将其写入<strong>App</strong>组件的状态。 并且还可以更改状态中用户列表的默认值。 </p><br><p>  <strong>该应用程序</strong> </p><br><pre> <code class="plaintext hljs">members: []</code> </pre> <br><p> 现在，按照完全相同的原理，我们获取当前用户的对象和消息数组，并将它们写入<strong>App</strong>状态 </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">// lets load 100 last messages from current chatroom const lastMessages = await this.sdk.getChatroomMessages(this.chatroomId, null, 100); if (props.setChatroomMessages) { props.setChatroomMessages(lastMessages); } if (props.setMe) { const me = this.sdk.getVisitor(); this.props.setMe(me); }</code> </pre> <br><p>  <strong>该应用程序</strong> </p><br><pre> <code class="plaintext hljs">&lt;ChatixSDK ref={this.chatixSDK} setMe={this.setMe} updateChatroomTitle={this.setChatroomTitle} setChatroomMembers={this.setChatroomMembers} setChatroomMessages={this.setChatroomMessages} /&gt;</code> </pre> <br><p> 接下来，我们将发送消息。 </p><br><p> 我们在<strong>App中</strong>已经具有<code>onSendNewMessage</code>函数，该函数显示将消息发送到控制台。 相反，我们只需要调用<code>sendChatroomMessage</code>方法来从<strong>ChatixSDK</strong>发送消息。 <br> 这是一个异步方法，它在响应中返回已发送消息的对象，我们将立即将其添加到状态的消息数组中。 顺便说一句，请注意，我们正在<code>this.chatixSDK</code>前面创建<code>this.chatixSDK</code>链接<code>this.chatixSDK</code> 。 </p><br><p>  <strong>该应用程序</strong> </p><br><pre> <code class="plaintext hljs">onSendNewMessage = async (message) =&gt; { let receivedMsg = await this.chatixSDK.current.sendChatroomMessage(message); const currentMessages = this.state.messages; currentMessages.push(receivedMsg); const newStateFragment = {messages: currentMessages}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> 由于状态更改会导致其重新呈现，因此消息列表将自动更新。 但是我们需要确保在添加消息时，消息块中的滚动会下降。 </p><br><p> 为此，请打开<strong>MessageContainer</strong>组件并使用<strong>useEffect</strong>钩子<strong>，</strong>监视消息数组中的更改，并在更改和添加消息后立即获得包含消息的<strong>scrollHeight</strong>块，并将其滚动相同的数量 </p><br><pre> <code class="plaintext hljs">function MessageContainer(props) { const messagesContainer = React.createRef(); useEffect(() =&gt; { messagesContainer.current.scrollTop = messagesContainer.current.scrollHeight }, [props, messagesContainer]); const messageList = props.messages.map(message =&gt; &lt;Message key={message.uuid} sender={props.members.find((member) =&gt; member.uuid === message.sender_id)} message={message} /&gt; ); return ( &lt;section className="MessageContainer" ref={messagesContainer}&gt; {messageList} &lt;/section&gt; ); }</code> </pre> <br><p> 现在，让我们完成用户名的更新。 我们已经在标题中创建了一个输入，并在更改它时，将更新的用户对象转发到<strong>App</strong>组件，然后在控制台中显示它。 让我们完成此功能。 为此，向其添加名为<code>this.chatixSDK.current.updateVisitor(user)</code>的方法，这将更新服务器上的数据。 只需更新本地状态中的数据，为此，我们将更新<code>this.state.me</code>对象，并在<code>this.state.members</code>数组中找到当前用户并对其进行更新。 在发送给他们的消息中更新当前用户的名称是必要的。 </p><br><p>  <strong>该应用程序</strong> </p><br><pre> <code class="plaintext hljs">onUpdateVisitor = (user) =&gt; { this.chatixSDK.current.updateVisitor(user) this.setMe(user) let currentUser = this.state.members.find((member) =&gt; (member.uuid === user.uuid)) let currentUserIndex = this.state.members.indexOf(currentUser) let newMembers = [...this.state.members] newMembers[currentUserIndex] = user; this.setState({ members: newMembers }) }</code> </pre> <br><p> 现在，我们需要学习如何响应传入消息，连接/断开用户以及更改信息和连接的用户。 </p><br><p> 为此，在构造函数的<strong>ChatixSDK.js</strong>文件中，我们需要覆盖回调函数。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">chatix-core</a>项目页面上查看函数和参数的完整列表。 </p><br><p> 我们<strong>目前</strong>对<strong>onChatroomMessageReceived</strong> ， <strong>onMemberConnectedToChatroom</strong> ， <strong>onMemberDisconnectedFromChatroom</strong>和<strong>onApplyVisitorInfo感兴趣</strong> 。 </p><br><p> 我们重新定义它们，并为每个函数调用我们将在<strong>App中</strong>创建的回调。 </p><br><pre> <code class="plaintext hljs">this.sdk.onChatroomMessageReceived = (chatroomId, message) =&gt; { if (chatroomId === this.chatroomId) { this.props.onNewMessageReceived(message); } }; this.sdk.onMemberConnectedToChatroom = (chatroomId, member) =&gt; { if (chatroomId === this.chatroomId &amp;&amp; props.addChatroomMember) { this.props.addChatroomMember(member); } }; this.sdk.onMemberDisconnectedFromChatroom = (chatroomId, member) =&gt; { if (chatroomId === this.chatroomId &amp;&amp; props.removeChatroomMember) { this.props.removeChatroomMember(member); } }; this.sdk.onApplyVisitorInfo = (visitor) =&gt; { this.props.onMemberUpdated(visitor) }</code> </pre> <br><p> 接下来，转到<strong>应用程序</strong>并创建这些功能。 </p><br><p>  <strong>onNewMessageReceived（消息）</strong> <br> 该函数接受一个消息对象，并简单地将其与其余消息一起添加到状态中。          ,        . </p><br><p> <strong>App</strong> </p><br><pre> <code class="plaintext hljs">onNewMessageReceived = (message) =&gt; { const currentMessages = this.state.messages; currentMessages.push(message); const newStateFragment = {messages: currentMessages}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> <strong>App</strong> <br> <strong>addChatroomMember(member)</strong> <br>            state     members.              . </p><br><p> <strong>App</strong> </p><br><pre> <code class="plaintext hljs">addChatroomMember = (member) =&gt; { const newStateFragment = {}; const currentMembers = this.state.members; currentMembers.push(member); currentMembers.sort(this.sortMembers); newStateFragment.members = currentMembers; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> <strong>App</strong> <br> <strong>removeChatroomMember(memberId)</strong> <br>         state     <strong>members</strong>  <strong>state</strong> . </p><br><pre> <code class="plaintext hljs">removeChatroomMember = (memberId) =&gt; { const currentMembers = this.state.members; const filteredMembers = currentMembers.filter(x=&gt; x.uuid !== memberId); const newStateFragment = {members: filteredMembers}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> <strong>onMemberUpdated(updatedMember)</strong> <br>      .        .       <strong>state</strong>     . </p><br><p> <strong>App</strong> </p><br><pre> <code class="plaintext hljs">onMemberUpdated = (updatedMember) =&gt; { let oldMember = this.state.members.find(member =&gt; member.uuid === updatedMember.uuid); oldMember = this.state.members.indexOf(oldMember); let newStateMembers = this.state.members; newStateMembers[oldMember] = updatedMember; this.setState({ members: newStateMembers }) }</code> </pre> <br><p>      <strong>ChatixSDK</strong> </p><br><p> <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">&lt;ChatixSDK ref={this.chatixSDK} setMe={this.setMe} updateChatroomTitle={this.setChatroomTitle} setChatroomMembers={this.setChatroomMembers} addChatroomMember={this.addChatroomMember} removeChatroomMember={this.removeChatroomMember} setChatroomMessages={this.setChatroomMessages} onNewMessageReceived={this.onNewMessageReceived} onMemberUpdated={this.onMemberUpdated} /&gt;</code> </pre> <br><p> 做完了！       \ ,   ,    /   . </p><br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">alekseyso</a> <br> 其他材料： <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SDK Chatix ()</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SDK Chatix (npm)</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">192   -</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN474492/">https://habr.com/ru/post/zh-CN474492/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN474478/index.html">机器学习简介。 数理统计。 最大似然法</a></li>
<li><a href="../zh-CN474480/index.html">如果不是您的童年时代，该如何教育孩子正确使用技术？</a></li>
<li><a href="../zh-CN474484/index.html">模拟不是拐杖，模拟是规范</a></li>
<li><a href="../zh-CN474488/index.html">免费播放DotNext和HolyJS</a></li>
<li><a href="../zh-CN474490/index.html">时机已到：Coclean鼻腔吸引器概述</a></li>
<li><a href="../zh-CN474494/index.html">2019年Zabbix峰会怎么样</a></li>
<li><a href="../zh-CN474496/index.html">HighLoad ++ 2019上的数据库</a></li>
<li><a href="../zh-CN474498/index.html">JavaFX教程：Hello World</a></li>
<li><a href="../zh-CN474500/index.html">Grafana的插件开发：全锥的故事</a></li>
<li><a href="../zh-CN474502/index.html">Odnoklassniki在Joker 2019上的解析</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>