<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✂️ 👅 🧚 Categorias de expressão em C ++ 😯 👨🏼‍🚀 🕺🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Categorias de expressões, como lvalue e rvalue , relacionam-se mais aos conceitos teóricos fundamentais da linguagem C ++ do que aos aspectos práticos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Categorias de expressão em C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441742/"><p>  Categorias de expressões, como <strong>lvalue</strong> e <strong>rvalue</strong> , relacionam-se mais aos conceitos teóricos fundamentais da linguagem C ++ do que aos aspectos práticos de seu uso.  Por esse motivo, muitos programadores experientes têm uma vaga idéia do que eles significam.  Neste artigo, tentarei explicar o significado desses termos da maneira mais simples possível, diluindo a teoria com exemplos práticos.  Farei uma reserva imediatamente: o artigo não pretende fornecer a descrição mais completa e rigorosa das categorias de expressões. Para obter detalhes, recomendo entrar em contato diretamente com a fonte: padrão da linguagem C ++. </p><a name="habracut"></a><br><blockquote>  O artigo conterá muitos termos no idioma inglês, devido ao fato de que alguns deles são difíceis de traduzir para o russo, enquanto outros são traduzidos em diferentes fontes de maneiras diferentes.  Portanto, frequentemente indico termos em inglês, destacando-os <em>em itálico</em> . </blockquote><br><h2 id="nemnogo-istorii">  Um pouco de história </h2><br><p>  Os termos <strong>lvalue</strong> e <strong>rvalue</strong> apareceram em C. Vale a pena notar que a confusão foi inicialmente estabelecida na terminologia, porque se refere a expressões e não a valores.  Historicamente, um <strong>lvalue</strong> é o que pode ser deixado pelo operador de atribuição, e um <strong>rvalue</strong> é o que pode estar <em>certo</em> apenas. </p><br><pre><code class="plaintext hljs">lvalue = rvalue;</code> </pre> <br><p>  No entanto, essa definição simplifica e distorce a essência.  O padrão C89 definiu <strong>lvalue</strong> como um <em>localizador de objetos</em> , ou seja,  Um objeto com um local de memória identificável.  Dessa forma, tudo o que não se encaixava nessa definição foi incluído na categoria <strong>rvalue</strong> . </p><br><h2 id="byarn-speshit-na-pomosch">  Bjarn corre para o resgate </h2><br><p>  No C ++, a terminologia das categorias de expressão evoluiu bastante fortemente, especialmente após a adoção do C ++ 11 Standard, que introduziu os conceitos de links de valores <strong>racionais</strong> e <em>move a semântica</em> .  A história do surgimento de uma nova terminologia é curiosamente descrita no artigo de Straustrup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“New” Value Terminology</a> . </p><br><p>  A nova terminologia mais rigorosa é baseada em 2 propriedades: </p><br><ul><li>  a presença de identidade ( <em>identidade</em> ) - ou seja, algum parâmetro pelo qual se pode entender se duas expressões se referem à mesma entidade ou não (por exemplo, um endereço na memória); </li><li>  a capacidade de se mover ( <em>pode ser movido de</em> ) - suporta a semântica do movimento. </li></ul><br><p>  Expressões que expressam identidade são generalizadas sob o termo <strong>glvalue</strong> ( <em>valores generalizados</em> ), expressões de roaming são chamadas <strong>rvalue</strong> .  As combinações dessas duas propriedades identificaram três categorias principais de expressões: </p><br><table><thead><tr><th></th><th>  Tenha uma identidade </th><th>  Desprovido de identidade </th></tr></thead><tbody><tr><td>  <strong>Não pode ser movido</strong> </td><td>  lvalue </td><td>  - </td></tr><tr><td>  <strong>Pode ser movido</strong> </td><td>  xvalue </td><td>  prvalue </td></tr></tbody></table><br><p>  De fato, o C ++ 17 Standard introduziu o conceito de <em>remoção</em> de <em>cópia</em> - formalizando situações em que o compilador pode e deve evitar copiar e mover objetos.  Nesse sentido, o valor <strong>inicial</strong> não <strong>pode</strong> necessariamente ser movido.  Detalhes e exemplos podem ser encontrados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  No entanto, isso não afeta o entendimento do esquema geral das categorias de expressões. </p><br><p>  No moderno padrão C ++, a estrutura da categoria é apresentada na forma de um esquema: </p><br><p><img src="https://habrastorage.org/webt/2r/ut/w5/2rutw544jnidqrhi4cgwnc848xg.png" alt="imagem"></p><br><p>  Vamos examinar em termos gerais as propriedades das categorias, bem como as expressões de linguagem incluídas em cada uma das categorias.  Percebo imediatamente que as listas de expressões abaixo para cada categoria não podem ser consideradas completas; para obter informações mais precisas e detalhadas, consulte diretamente o Padrão C ++. </p><br><h2 id="glvalue">  glvalue </h2><br><p>  Expressões na categoria <strong>glvalue</strong> têm as seguintes propriedades: </p><br><ul><li>  pode ser implicitamente convertido em <strong>prvalue</strong> ; </li><li>  podem ser polimórficos, ou seja, para eles os conceitos de tipo estático e dinâmico fazem sentido; </li><li>  não pode ser do tipo <strong>nulo</strong> - isso resulta diretamente da propriedade de ter identidade, porque para expressões do tipo <strong>nulo</strong> não existe um parâmetro que os diferencie um do outro; </li><li>  pode ter um <em>tipo incompleto</em> , por exemplo, na forma de uma <em>declaração direta</em> (se permitido para uma expressão específica). </li></ul><br><h2 id="rvalue">  rvalue </h2><br><p>  Expressões na categoria <strong>rvalue</strong> têm as seguintes propriedades: </p><br><ul><li>  você não pode obter o endereço <strong>rvalue</strong> na memória - isso resulta diretamente da falta de propriedade de identidade; </li><li>  não pode estar no lado esquerdo de uma atribuição ou declaração de atribuição composta; </li><li>  pode ser usado para inicializar um link <strong>lvalue</strong> constante ou um link <strong>rvalue</strong> , enquanto a vida útil do objeto se estende à vida útil do link; </li><li>  se usado como argumento ao chamar uma função que possui 2 versões sobrecarregadas: uma aceita uma referência <strong>lvalue</strong> constante e a outra uma referência <strong>rvalue</strong> , a versão que aceita a referência <strong>rvalue</strong> é selecionada.  É essa propriedade usada para implementar a <em>semântica de movimentação</em> : </li></ul><br><pre> <code class="plaintext hljs">class A { public: A() = default; A(const A&amp;) { std::cout &lt;&lt; "A::A(const A&amp;)\n"; } A(A&amp;&amp;) { std::cout &lt;&lt; "A::A(A&amp;&amp;)\n"; } }; ......... A a; A b(a); //  A(const A&amp;) A c(std::move(a)); //  A(A&amp;&amp;)</code> </pre> <br><blockquote>  Tecnicamente, A&amp;&amp; é um <strong>rvalue</strong> e pode ser usado para inicializar uma referência <strong>lvalue</strong> constante e uma referência <strong>rvalue</strong> .  Mas, graças a essa propriedade, não há ambiguidade; é aceita uma opção de construtor que aceita uma referência <strong>rvalue</strong> . </blockquote><br><h2 id="lvalue">  lvalue </h2><br><p>  Propriedades: </p><br><ul><li>  todas <strong>as</strong> propriedades de <strong>glvalue</strong> (veja acima); </li><li>  você pode pegar o endereço (usando o operador unário interno <code>&amp;</code> ); </li><li>  valores modificáveis ​​podem estar no lado esquerdo do operador de atribuição ou de operadores compostos; </li><li>  pode ser usado para inicializar uma referência a um valor <strong>l</strong> (constante e não constante). </li></ul><br><p>  As seguintes expressões pertencem à categoria <strong>lvalue</strong> : </p><br><ul><li>  o nome de uma variável, função ou campo de classe de qualquer tipo.  Mesmo que a variável seja uma referência <strong>rvalue</strong> , o nome dessa variável na expressão é um <strong>lvalue</strong> ; </li></ul><br><pre> <code class="plaintext hljs">void func() {} ......... auto* func_ptr = &amp;func; // :     auto&amp; func_ref = func; // :     int&amp;&amp; rrn = int(123); auto* pn = &amp;rrn; // :    auto&amp; rn = rrn; // :  lvalue-</code> </pre> <br><ul><li>  chamar uma função ou um operador sobrecarregado que retorne uma referência <strong>lvalue</strong> ou uma expressão de conversão para o tipo de uma referência <strong>lvalue</strong> ; </li><li>  operadores de atribuição internos, operadores de atribuição compostos ( <code>=</code> , <code>+=</code> , <code>/=</code> , etc.), pré-incremento e pré-incremento <code>--b</code> ( <code>++a</code> , <code>--b</code> ), operador de desreferência de ponteiro interno ( <code>*p</code> ); </li><li>  operador interno de acesso por índice ( <code>a[n]</code> ou <code>n[a]</code> ), quando um dos operandos é uma matriz <strong>lvalue</strong> ; </li><li>  chamar uma função ou uma instrução sobrecarregada que retorna uma referência de <strong>rvalue</strong> para uma função; </li><li>  literal de cadeia como <code>"Hello, world!"</code>  . </li></ul><br><blockquote>  Um literal de string difere de todos os outros literais em C ++ precisamente por ser um valor <strong>l</strong> (embora imutável).  Por exemplo, você pode obter seu endereço: </blockquote><br><pre> <code class="plaintext hljs">auto* p = &amp;”Hello, world!”; //   ,   </code> </pre> <br><h2 id="prvalue">  prvalue </h2><br><p>  Propriedades: </p><br><ul><li>  todas as propriedades <strong>rvalue</strong> (veja acima); </li><li>  não pode ser polimórfico: os tipos de expressão estática e dinâmica sempre coincidem; </li><li>  não pode ser de um tipo incompleto (exceto o tipo de <strong>nulo</strong> , isso será discutido abaixo); </li><li>  não pode ter um tipo abstrato ou ser uma matriz de elementos de um tipo abstrato. </li></ul><br><p>  As seguintes expressões pertencem à categoria <strong>prvalue</strong> : </p><br><ul><li>  literal (exceto string), por exemplo <code>42</code> , <code>true</code> ou <code>nullptr</code> ; </li><li>  uma chamada de função ou um operador sobrecarregado que retorna uma não referência ( <code>str.substr(1, 2)</code> , <code>str1 + str2</code> , <code>it++</code> ) ou uma expressão de conversão para um tipo de não referência (por exemplo, <code>static_cast&lt;double&gt;(x)</code> , <code>std::string{}</code> , <code>(int)42</code> ); </li><li>  pós-incremento e pós-decremento <code>b--</code> ( <code>a++</code> , <code>b--</code> ), operações matemáticas <code>b--</code> ( <code>a + b</code> , <code>a % b</code> , <code>a &amp; b</code> , <code>a &lt;&lt; b</code> , etc.), operações lógicas incorporadas ( <code>a &amp;&amp; b</code> , <code>a || b</code> <code>!a</code> , etc.), operações de comparação ( <code>a &lt; b</code> , <code>a == b</code> , <code>a &gt;= b</code> , etc.), a operação interna de obter o endereço ( <code>&amp;a</code> ); </li><li>  <strong>esse</strong> ponteiro; </li><li>  item de listagem; </li><li>  parâmetro atípico de modelo, se não for uma classe; </li><li>  expressão lambda, por exemplo <code>[](int x){ return x * x; }</code>  <code>[](int x){ return x * x; }</code> </li></ul><br><h2 id="xvalue">  xvalue </h2><br><p>  Propriedades: </p><br><ul><li>  todas as propriedades <strong>rvalue</strong> (veja acima); </li><li>  todas <strong>as</strong> propriedades <strong>glvalue</strong> (veja acima). </li></ul><br><p>  Exemplos de expressões <strong>xvalue</strong> : </p><br><ul><li>  chamar uma função ou operador <strong>interno</strong> que retorna uma referência <strong>rvalue</strong> , por exemplo <em>std :: move (x)</em> ; </li></ul><br><blockquote>  e, de fato, para o resultado de chamar <em>std :: move (),</em> você não pode obter um endereço na memória ou inicializar um link para ele, mas, ao mesmo tempo, essa expressão pode ser polimórfica: </blockquote><br><pre> <code class="plaintext hljs">struct XA { virtual void f() { std::cout &lt;&lt; "XA::f()\n"; } }; struct XB : public XA { virtual void f() { std::cout &lt;&lt; "XB::f()\n"; } }; XA&amp;&amp; xa = XB(); auto* p = &amp;std::move(xa); //  auto&amp; r = std::move(xa); //  std::move(xa).f(); //  “XB::f()”</code> </pre> <br><ul><li>  operador interno de acesso por índice ( <code>a[n]</code> ou <code>n[a]</code> ) quando um dos operandos é uma matriz <strong>rvalue</strong> . </li></ul><br><h2 id="nekotorye-osobye-sluchai">  Alguns casos especiais </h2><br><h3 id="operator-zapyataya">  Operador de vírgula </h3><br><p>  Para o operador de vírgula interno, a categoria de expressão sempre corresponde à categoria de expressão do segundo operando. </p><br><pre> <code class="plaintext hljs">int n = 0; auto* pn = &amp;(1, n); // lvalue auto&amp; rn = (1, n); // lvalue 1, n = 2; // lvalue auto* pt = &amp;(1, int(123)); // , rvalue auto&amp; rt = (1, int(123)); // , rvalue</code> </pre> <br><h2 id="vyrazheniya-tipa-void">  Expressões vazias </h2><br><p>  As chamadas para funções que retornam <strong>void</strong> , digitam expressões de conversão para <strong>void</strong> e lançam exceções são consideradas expressões de <strong>pré-valor</strong> , mas não podem ser usadas para inicializar referências ou como argumentos para funções. </p><br><h2 id="ternarnyy-operator-sravneniya">  Operador de comparação ternário </h2><br><p>  Definição da categoria de expressão <code>a ? b : c</code>  <code>a ? b : c</code> - o caso não é trivial, tudo depende das categorias do segundo e terceiro argumentos ( <code>b</code> e <code>c</code> ): </p><br><ul><li>  se <code>b</code> ou <code>c</code> forem do tipo <strong>nulo</strong> , a categoria e o tipo da expressão inteira corresponderão à categoria e ao tipo do outro argumento.  Se os dois argumentos forem do tipo <strong>nulo</strong> , o resultado será um <strong>pré-valor do</strong> tipo <strong>nulo</strong> ; </li><li>  se <code>b</code> são <strong>glvalue do</strong> mesmo tipo, o resultado é um <strong>glvalue do</strong> mesmo tipo; </li><li>  em outros casos, o resultado é prvalue. </li></ul><br><p>  Para o operador ternário, são definidas várias regras segundo as quais conversões implícitas podem ser aplicadas aos argumentos bec, mas isso está um pouco além do <strong><em>escopo do artigo; se</em></strong> você estiver interessado, recomendo <strong><em>consultar a seção Operador condicional [expr.cond]</em></strong> da norma. </p><br><pre> <code class="plaintext hljs">int n = 1; int v = (1 &gt; 2) ? throw 1 : n; // lvalue, .. throw   void,    n ((1 &lt; 2) ? n : v) = 2; //  lvalue,  ,   ((1 &lt; 2) ? n : int(123)) = 2; //   , ..    prvalue</code> </pre> <br><h2 id="obrascheniya-k-polyam-i-metodam-klassov-i-struktur">  Referências a campos e métodos de classes e estruturas </h2><br><p>  Para expressões do formato <code>am</code> <code>p-&gt;m</code> (aqui estamos falando sobre o operador interno <code>-&gt;</code> ), as seguintes regras se aplicam: </p><br><ul><li>  se <code>m</code> for um elemento de enumeração ou um método de classe não estática, a expressão inteira será considerada <strong>prvalue</strong> (embora o link não possa ser inicializado com essa expressão); </li><li>  se <code>a</code> é um <strong>rvalue</strong> e <code>m</code> é um campo não estático de um tipo não de referência, a expressão inteira pertence à categoria <strong>xvalue</strong> ; </li><li>  caso contrário, é um valor <strong>l</strong> . </li></ul><br><p>  Para ponteiros para os alunos ( <code>a.*mp</code> <code>p-&gt;*mp</code> ), as regras são semelhantes: </p><br><ul><li>  se <code>mp</code> é um ponteiro para um método de classe, então toda a expressão é considerada <strong>prvalue</strong> ; </li><li>  se <code>a</code> é um <strong>rvalue</strong> e <code>mp</code> é um ponteiro para um campo de dados, toda a expressão se refere ao <strong>xvalue</strong> ; </li><li>  caso contrário, é um valor <strong>l</strong> . </li></ul><br><h2 id="bitovye-polya">  Campos de bits </h2><br><p>  Os campos de bits são uma ferramenta conveniente para programação de baixo nível; no entanto, sua implementação fica um pouco fora da estrutura geral das categorias de expressão.  Por exemplo, uma chamada para um campo de bits parece ser um valor <strong>l</strong> , <strong>porque</strong> pode estar presente no lado esquerdo do operador de atribuição.  Ao mesmo tempo, não funcionará para pegar o endereço do campo de bits ou inicializar um link não constante por eles.  Você pode inicializar uma referência constante para um campo de bit, mas uma cópia temporária do objeto será criada: </p><br><blockquote>  <strong><em>Campos de bits [class.bit]</em></strong> <br>  <em>Se o inicializador para uma referência do tipo const T &amp; for um valor l que se refere a um campo de bits, a referência será vinculada a um temporário inicializado para conter o valor do campo de bits;</em>  <em>a referência não está vinculada diretamente ao campo de bits.</em> </blockquote><br><pre> <code class="plaintext hljs">struct BF { int f:3; }; BF b; bf = 1; // OK auto* pb = &amp;b.f; //  auto&amp; rb = bf; // </code> </pre> <br><h2 id="vmesto-zaklyucheniya">  Em vez de uma conclusão </h2><br><p>  Como mencionei na introdução, a descrição acima não afirma ser completa, mas apenas fornece uma idéia geral das categorias de expressões.  Essa visão fornecerá uma compreensão um pouco melhor dos parágrafos do Standard e das mensagens de erro do compilador. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441742/">https://habr.com/ru/post/pt441742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441728/index.html">Resumindo o concurso online para o jogo Blotto</a></li>
<li><a href="../pt441732/index.html">Notas do Biorobot</a></li>
<li><a href="../pt441736/index.html">Automatize a conversão de arquivos do Word para outros formatos</a></li>
<li><a href="../pt441738/index.html">Fundamentos termoacústicos</a></li>
<li><a href="../pt441740/index.html">Habra megarating: os melhores artigos e estatísticas de Habr há 12 anos. Parte 1/2</a></li>
<li><a href="../pt441744/index.html">Obtendo links para perfis Vk a partir dos resultados do SearchFace usando Python (mas isso não é exato)</a></li>
<li><a href="../pt441750/index.html">Projetos no CodeFest: Como um gerente pode sobreviver em um mundo em constante mudança?</a></li>
<li><a href="../pt441752/index.html">ZTE mostrou um relógio de smartphone α</a></li>
<li><a href="../pt441754/index.html">Kubernetes histórias de sucesso em produção. Parte 10: Reddit</a></li>
<li><a href="../pt441756/index.html">Para a plataforma russa de PCs industriais, eles usaram os processadores Baikal-T1 e Alt OS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>