<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úÇÔ∏è üëÖ üßö Categorias de express√£o em C ++ üòØ üë®üèº‚ÄçüöÄ üï∫üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Categorias de express√µes, como lvalue e rvalue , relacionam-se mais aos conceitos te√≥ricos fundamentais da linguagem C ++ do que aos aspectos pr√°ticos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Categorias de express√£o em C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441742/"><p>  Categorias de express√µes, como <strong>lvalue</strong> e <strong>rvalue</strong> , relacionam-se mais aos conceitos te√≥ricos fundamentais da linguagem C ++ do que aos aspectos pr√°ticos de seu uso.  Por esse motivo, muitos programadores experientes t√™m uma vaga id√©ia do que eles significam.  Neste artigo, tentarei explicar o significado desses termos da maneira mais simples poss√≠vel, diluindo a teoria com exemplos pr√°ticos.  Farei uma reserva imediatamente: o artigo n√£o pretende fornecer a descri√ß√£o mais completa e rigorosa das categorias de express√µes. Para obter detalhes, recomendo entrar em contato diretamente com a fonte: padr√£o da linguagem C ++. </p><a name="habracut"></a><br><blockquote>  O artigo conter√° muitos termos no idioma ingl√™s, devido ao fato de que alguns deles s√£o dif√≠ceis de traduzir para o russo, enquanto outros s√£o traduzidos em diferentes fontes de maneiras diferentes.  Portanto, frequentemente indico termos em ingl√™s, destacando-os <em>em it√°lico</em> . </blockquote><br><h2 id="nemnogo-istorii">  Um pouco de hist√≥ria </h2><br><p>  Os termos <strong>lvalue</strong> e <strong>rvalue</strong> apareceram em C. Vale a pena notar que a confus√£o foi inicialmente estabelecida na terminologia, porque se refere a express√µes e n√£o a valores.  Historicamente, um <strong>lvalue</strong> √© o que pode ser deixado pelo operador de atribui√ß√£o, e um <strong>rvalue</strong> √© o que pode estar <em>certo</em> apenas. </p><br><pre><code class="plaintext hljs">lvalue = rvalue;</code> </pre> <br><p>  No entanto, essa defini√ß√£o simplifica e distorce a ess√™ncia.  O padr√£o C89 definiu <strong>lvalue</strong> como um <em>localizador de objetos</em> , ou seja,  Um objeto com um local de mem√≥ria identific√°vel.  Dessa forma, tudo o que n√£o se encaixava nessa defini√ß√£o foi inclu√≠do na categoria <strong>rvalue</strong> . </p><br><h2 id="byarn-speshit-na-pomosch">  Bjarn corre para o resgate </h2><br><p>  No C ++, a terminologia das categorias de express√£o evoluiu bastante fortemente, especialmente ap√≥s a ado√ß√£o do C ++ 11 Standard, que introduziu os conceitos de links de valores <strong>racionais</strong> e <em>move a sem√¢ntica</em> .  A hist√≥ria do surgimento de uma nova terminologia √© curiosamente descrita no artigo de Straustrup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúNew‚Äù Value Terminology</a> . </p><br><p>  A nova terminologia mais rigorosa √© baseada em 2 propriedades: </p><br><ul><li>  a presen√ßa de identidade ( <em>identidade</em> ) - ou seja, algum par√¢metro pelo qual se pode entender se duas express√µes se referem √† mesma entidade ou n√£o (por exemplo, um endere√ßo na mem√≥ria); </li><li>  a capacidade de se mover ( <em>pode ser movido de</em> ) - suporta a sem√¢ntica do movimento. </li></ul><br><p>  Express√µes que expressam identidade s√£o generalizadas sob o termo <strong>glvalue</strong> ( <em>valores generalizados</em> ), express√µes de roaming s√£o chamadas <strong>rvalue</strong> .  As combina√ß√µes dessas duas propriedades identificaram tr√™s categorias principais de express√µes: </p><br><table><thead><tr><th></th><th>  Tenha uma identidade </th><th>  Desprovido de identidade </th></tr></thead><tbody><tr><td>  <strong>N√£o pode ser movido</strong> </td><td>  lvalue </td><td>  - </td></tr><tr><td>  <strong>Pode ser movido</strong> </td><td>  xvalue </td><td>  prvalue </td></tr></tbody></table><br><p>  De fato, o C ++ 17 Standard introduziu o conceito de <em>remo√ß√£o</em> de <em>c√≥pia</em> - formalizando situa√ß√µes em que o compilador pode e deve evitar copiar e mover objetos.  Nesse sentido, o valor <strong>inicial</strong> n√£o <strong>pode</strong> necessariamente ser movido.  Detalhes e exemplos podem ser encontrados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  No entanto, isso n√£o afeta o entendimento do esquema geral das categorias de express√µes. </p><br><p>  No moderno padr√£o C ++, a estrutura da categoria √© apresentada na forma de um esquema: </p><br><p><img src="https://habrastorage.org/webt/2r/ut/w5/2rutw544jnidqrhi4cgwnc848xg.png" alt="imagem"></p><br><p>  Vamos examinar em termos gerais as propriedades das categorias, bem como as express√µes de linguagem inclu√≠das em cada uma das categorias.  Percebo imediatamente que as listas de express√µes abaixo para cada categoria n√£o podem ser consideradas completas; para obter informa√ß√µes mais precisas e detalhadas, consulte diretamente o Padr√£o C ++. </p><br><h2 id="glvalue">  glvalue </h2><br><p>  Express√µes na categoria <strong>glvalue</strong> t√™m as seguintes propriedades: </p><br><ul><li>  pode ser implicitamente convertido em <strong>prvalue</strong> ; </li><li>  podem ser polim√≥rficos, ou seja, para eles os conceitos de tipo est√°tico e din√¢mico fazem sentido; </li><li>  n√£o pode ser do tipo <strong>nulo</strong> - isso resulta diretamente da propriedade de ter identidade, porque para express√µes do tipo <strong>nulo</strong> n√£o existe um par√¢metro que os diferencie um do outro; </li><li>  pode ter um <em>tipo incompleto</em> , por exemplo, na forma de uma <em>declara√ß√£o direta</em> (se permitido para uma express√£o espec√≠fica). </li></ul><br><h2 id="rvalue">  rvalue </h2><br><p>  Express√µes na categoria <strong>rvalue</strong> t√™m as seguintes propriedades: </p><br><ul><li>  voc√™ n√£o pode obter o endere√ßo <strong>rvalue</strong> na mem√≥ria - isso resulta diretamente da falta de propriedade de identidade; </li><li>  n√£o pode estar no lado esquerdo de uma atribui√ß√£o ou declara√ß√£o de atribui√ß√£o composta; </li><li>  pode ser usado para inicializar um link <strong>lvalue</strong> constante ou um link <strong>rvalue</strong> , enquanto a vida √∫til do objeto se estende √† vida √∫til do link; </li><li>  se usado como argumento ao chamar uma fun√ß√£o que possui 2 vers√µes sobrecarregadas: uma aceita uma refer√™ncia <strong>lvalue</strong> constante e a outra uma refer√™ncia <strong>rvalue</strong> , a vers√£o que aceita a refer√™ncia <strong>rvalue</strong> √© selecionada.  √â essa propriedade usada para implementar a <em>sem√¢ntica de movimenta√ß√£o</em> : </li></ul><br><pre> <code class="plaintext hljs">class A { public: A() = default; A(const A&amp;) { std::cout &lt;&lt; "A::A(const A&amp;)\n"; } A(A&amp;&amp;) { std::cout &lt;&lt; "A::A(A&amp;&amp;)\n"; } }; ......... A a; A b(a); //  A(const A&amp;) A c(std::move(a)); //  A(A&amp;&amp;)</code> </pre> <br><blockquote>  Tecnicamente, A&amp;&amp; √© um <strong>rvalue</strong> e pode ser usado para inicializar uma refer√™ncia <strong>lvalue</strong> constante e uma refer√™ncia <strong>rvalue</strong> .  Mas, gra√ßas a essa propriedade, n√£o h√° ambiguidade; √© aceita uma op√ß√£o de construtor que aceita uma refer√™ncia <strong>rvalue</strong> . </blockquote><br><h2 id="lvalue">  lvalue </h2><br><p>  Propriedades: </p><br><ul><li>  todas <strong>as</strong> propriedades de <strong>glvalue</strong> (veja acima); </li><li>  voc√™ pode pegar o endere√ßo (usando o operador un√°rio interno <code>&amp;</code> ); </li><li>  valores modific√°veis ‚Äã‚Äãpodem estar no lado esquerdo do operador de atribui√ß√£o ou de operadores compostos; </li><li>  pode ser usado para inicializar uma refer√™ncia a um valor <strong>l</strong> (constante e n√£o constante). </li></ul><br><p>  As seguintes express√µes pertencem √† categoria <strong>lvalue</strong> : </p><br><ul><li>  o nome de uma vari√°vel, fun√ß√£o ou campo de classe de qualquer tipo.  Mesmo que a vari√°vel seja uma refer√™ncia <strong>rvalue</strong> , o nome dessa vari√°vel na express√£o √© um <strong>lvalue</strong> ; </li></ul><br><pre> <code class="plaintext hljs">void func() {} ......... auto* func_ptr = &amp;func; // :     auto&amp; func_ref = func; // :     int&amp;&amp; rrn = int(123); auto* pn = &amp;rrn; // :    auto&amp; rn = rrn; // :  lvalue-</code> </pre> <br><ul><li>  chamar uma fun√ß√£o ou um operador sobrecarregado que retorne uma refer√™ncia <strong>lvalue</strong> ou uma express√£o de convers√£o para o tipo de uma refer√™ncia <strong>lvalue</strong> ; </li><li>  operadores de atribui√ß√£o internos, operadores de atribui√ß√£o compostos ( <code>=</code> , <code>+=</code> , <code>/=</code> , etc.), pr√©-incremento e pr√©-incremento <code>--b</code> ( <code>++a</code> , <code>--b</code> ), operador de desrefer√™ncia de ponteiro interno ( <code>*p</code> ); </li><li>  operador interno de acesso por √≠ndice ( <code>a[n]</code> ou <code>n[a]</code> ), quando um dos operandos √© uma matriz <strong>lvalue</strong> ; </li><li>  chamar uma fun√ß√£o ou uma instru√ß√£o sobrecarregada que retorna uma refer√™ncia de <strong>rvalue</strong> para uma fun√ß√£o; </li><li>  literal de cadeia como <code>"Hello, world!"</code>  . </li></ul><br><blockquote>  Um literal de string difere de todos os outros literais em C ++ precisamente por ser um valor <strong>l</strong> (embora imut√°vel).  Por exemplo, voc√™ pode obter seu endere√ßo: </blockquote><br><pre> <code class="plaintext hljs">auto* p = &amp;‚ÄùHello, world!‚Äù; //   ,   </code> </pre> <br><h2 id="prvalue">  prvalue </h2><br><p>  Propriedades: </p><br><ul><li>  todas as propriedades <strong>rvalue</strong> (veja acima); </li><li>  n√£o pode ser polim√≥rfico: os tipos de express√£o est√°tica e din√¢mica sempre coincidem; </li><li>  n√£o pode ser de um tipo incompleto (exceto o tipo de <strong>nulo</strong> , isso ser√° discutido abaixo); </li><li>  n√£o pode ter um tipo abstrato ou ser uma matriz de elementos de um tipo abstrato. </li></ul><br><p>  As seguintes express√µes pertencem √† categoria <strong>prvalue</strong> : </p><br><ul><li>  literal (exceto string), por exemplo <code>42</code> , <code>true</code> ou <code>nullptr</code> ; </li><li>  uma chamada de fun√ß√£o ou um operador sobrecarregado que retorna uma n√£o refer√™ncia ( <code>str.substr(1, 2)</code> , <code>str1 + str2</code> , <code>it++</code> ) ou uma express√£o de convers√£o para um tipo de n√£o refer√™ncia (por exemplo, <code>static_cast&lt;double&gt;(x)</code> , <code>std::string{}</code> , <code>(int)42</code> ); </li><li>  p√≥s-incremento e p√≥s-decremento <code>b--</code> ( <code>a++</code> , <code>b--</code> ), opera√ß√µes matem√°ticas <code>b--</code> ( <code>a + b</code> , <code>a % b</code> , <code>a &amp; b</code> , <code>a &lt;&lt; b</code> , etc.), opera√ß√µes l√≥gicas incorporadas ( <code>a &amp;&amp; b</code> , <code>a || b</code> <code>!a</code> , etc.), opera√ß√µes de compara√ß√£o ( <code>a &lt; b</code> , <code>a == b</code> , <code>a &gt;= b</code> , etc.), a opera√ß√£o interna de obter o endere√ßo ( <code>&amp;a</code> ); </li><li>  <strong>esse</strong> ponteiro; </li><li>  item de listagem; </li><li>  par√¢metro at√≠pico de modelo, se n√£o for uma classe; </li><li>  express√£o lambda, por exemplo <code>[](int x){ return x * x; }</code>  <code>[](int x){ return x * x; }</code> </li></ul><br><h2 id="xvalue">  xvalue </h2><br><p>  Propriedades: </p><br><ul><li>  todas as propriedades <strong>rvalue</strong> (veja acima); </li><li>  todas <strong>as</strong> propriedades <strong>glvalue</strong> (veja acima). </li></ul><br><p>  Exemplos de express√µes <strong>xvalue</strong> : </p><br><ul><li>  chamar uma fun√ß√£o ou operador <strong>interno</strong> que retorna uma refer√™ncia <strong>rvalue</strong> , por exemplo <em>std :: move (x)</em> ; </li></ul><br><blockquote>  e, de fato, para o resultado de chamar <em>std :: move (),</em> voc√™ n√£o pode obter um endere√ßo na mem√≥ria ou inicializar um link para ele, mas, ao mesmo tempo, essa express√£o pode ser polim√≥rfica: </blockquote><br><pre> <code class="plaintext hljs">struct XA { virtual void f() { std::cout &lt;&lt; "XA::f()\n"; } }; struct XB : public XA { virtual void f() { std::cout &lt;&lt; "XB::f()\n"; } }; XA&amp;&amp; xa = XB(); auto* p = &amp;std::move(xa); //  auto&amp; r = std::move(xa); //  std::move(xa).f(); //  ‚ÄúXB::f()‚Äù</code> </pre> <br><ul><li>  operador interno de acesso por √≠ndice ( <code>a[n]</code> ou <code>n[a]</code> ) quando um dos operandos √© uma matriz <strong>rvalue</strong> . </li></ul><br><h2 id="nekotorye-osobye-sluchai">  Alguns casos especiais </h2><br><h3 id="operator-zapyataya">  Operador de v√≠rgula </h3><br><p>  Para o operador de v√≠rgula interno, a categoria de express√£o sempre corresponde √† categoria de express√£o do segundo operando. </p><br><pre> <code class="plaintext hljs">int n = 0; auto* pn = &amp;(1, n); // lvalue auto&amp; rn = (1, n); // lvalue 1, n = 2; // lvalue auto* pt = &amp;(1, int(123)); // , rvalue auto&amp; rt = (1, int(123)); // , rvalue</code> </pre> <br><h2 id="vyrazheniya-tipa-void">  Express√µes vazias </h2><br><p>  As chamadas para fun√ß√µes que retornam <strong>void</strong> , digitam express√µes de convers√£o para <strong>void</strong> e lan√ßam exce√ß√µes s√£o consideradas express√µes de <strong>pr√©-valor</strong> , mas n√£o podem ser usadas para inicializar refer√™ncias ou como argumentos para fun√ß√µes. </p><br><h2 id="ternarnyy-operator-sravneniya">  Operador de compara√ß√£o tern√°rio </h2><br><p>  Defini√ß√£o da categoria de express√£o <code>a ? b : c</code>  <code>a ? b : c</code> - o caso n√£o √© trivial, tudo depende das categorias do segundo e terceiro argumentos ( <code>b</code> e <code>c</code> ): </p><br><ul><li>  se <code>b</code> ou <code>c</code> forem do tipo <strong>nulo</strong> , a categoria e o tipo da express√£o inteira corresponder√£o √† categoria e ao tipo do outro argumento.  Se os dois argumentos forem do tipo <strong>nulo</strong> , o resultado ser√° um <strong>pr√©-valor do</strong> tipo <strong>nulo</strong> ; </li><li>  se <code>b</code> s√£o <strong>glvalue do</strong> mesmo tipo, o resultado √© um <strong>glvalue do</strong> mesmo tipo; </li><li>  em outros casos, o resultado √© prvalue. </li></ul><br><p>  Para o operador tern√°rio, s√£o definidas v√°rias regras segundo as quais convers√µes impl√≠citas podem ser aplicadas aos argumentos bec, mas isso est√° um pouco al√©m do <strong><em>escopo do artigo; se</em></strong> voc√™ estiver interessado, recomendo <strong><em>consultar a se√ß√£o Operador condicional [expr.cond]</em></strong> da norma. </p><br><pre> <code class="plaintext hljs">int n = 1; int v = (1 &gt; 2) ? throw 1 : n; // lvalue, .. throw   void,    n ((1 &lt; 2) ? n : v) = 2; //  lvalue,  ,   ((1 &lt; 2) ? n : int(123)) = 2; //   , ..    prvalue</code> </pre> <br><h2 id="obrascheniya-k-polyam-i-metodam-klassov-i-struktur">  Refer√™ncias a campos e m√©todos de classes e estruturas </h2><br><p>  Para express√µes do formato <code>am</code> <code>p-&gt;m</code> (aqui estamos falando sobre o operador interno <code>-&gt;</code> ), as seguintes regras se aplicam: </p><br><ul><li>  se <code>m</code> for um elemento de enumera√ß√£o ou um m√©todo de classe n√£o est√°tica, a express√£o inteira ser√° considerada <strong>prvalue</strong> (embora o link n√£o possa ser inicializado com essa express√£o); </li><li>  se <code>a</code> √© um <strong>rvalue</strong> e <code>m</code> √© um campo n√£o est√°tico de um tipo n√£o de refer√™ncia, a express√£o inteira pertence √† categoria <strong>xvalue</strong> ; </li><li>  caso contr√°rio, √© um valor <strong>l</strong> . </li></ul><br><p>  Para ponteiros para os alunos ( <code>a.*mp</code> <code>p-&gt;*mp</code> ), as regras s√£o semelhantes: </p><br><ul><li>  se <code>mp</code> √© um ponteiro para um m√©todo de classe, ent√£o toda a express√£o √© considerada <strong>prvalue</strong> ; </li><li>  se <code>a</code> √© um <strong>rvalue</strong> e <code>mp</code> √© um ponteiro para um campo de dados, toda a express√£o se refere ao <strong>xvalue</strong> ; </li><li>  caso contr√°rio, √© um valor <strong>l</strong> . </li></ul><br><h2 id="bitovye-polya">  Campos de bits </h2><br><p>  Os campos de bits s√£o uma ferramenta conveniente para programa√ß√£o de baixo n√≠vel; no entanto, sua implementa√ß√£o fica um pouco fora da estrutura geral das categorias de express√£o.  Por exemplo, uma chamada para um campo de bits parece ser um valor <strong>l</strong> , <strong>porque</strong> pode estar presente no lado esquerdo do operador de atribui√ß√£o.  Ao mesmo tempo, n√£o funcionar√° para pegar o endere√ßo do campo de bits ou inicializar um link n√£o constante por eles.  Voc√™ pode inicializar uma refer√™ncia constante para um campo de bit, mas uma c√≥pia tempor√°ria do objeto ser√° criada: </p><br><blockquote>  <strong><em>Campos de bits [class.bit]</em></strong> <br>  <em>Se o inicializador para uma refer√™ncia do tipo const T &amp; for um valor l que se refere a um campo de bits, a refer√™ncia ser√° vinculada a um tempor√°rio inicializado para conter o valor do campo de bits;</em>  <em>a refer√™ncia n√£o est√° vinculada diretamente ao campo de bits.</em> </blockquote><br><pre> <code class="plaintext hljs">struct BF { int f:3; }; BF b; bf = 1; // OK auto* pb = &amp;b.f; //  auto&amp; rb = bf; // </code> </pre> <br><h2 id="vmesto-zaklyucheniya">  Em vez de uma conclus√£o </h2><br><p>  Como mencionei na introdu√ß√£o, a descri√ß√£o acima n√£o afirma ser completa, mas apenas fornece uma id√©ia geral das categorias de express√µes.  Essa vis√£o fornecer√° uma compreens√£o um pouco melhor dos par√°grafos do Standard e das mensagens de erro do compilador. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441742/">https://habr.com/ru/post/pt441742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441728/index.html">Resumindo o concurso online para o jogo Blotto</a></li>
<li><a href="../pt441732/index.html">Notas do Biorobot</a></li>
<li><a href="../pt441736/index.html">Automatize a convers√£o de arquivos do Word para outros formatos</a></li>
<li><a href="../pt441738/index.html">Fundamentos termoac√∫sticos</a></li>
<li><a href="../pt441740/index.html">Habra megarating: os melhores artigos e estat√≠sticas de Habr h√° 12 anos. Parte 1/2</a></li>
<li><a href="../pt441744/index.html">Obtendo links para perfis Vk a partir dos resultados do SearchFace usando Python (mas isso n√£o √© exato)</a></li>
<li><a href="../pt441750/index.html">Projetos no CodeFest: Como um gerente pode sobreviver em um mundo em constante mudan√ßa?</a></li>
<li><a href="../pt441752/index.html">ZTE mostrou um rel√≥gio de smartphone Œ±</a></li>
<li><a href="../pt441754/index.html">Kubernetes hist√≥rias de sucesso em produ√ß√£o. Parte 10: Reddit</a></li>
<li><a href="../pt441756/index.html">Para a plataforma russa de PCs industriais, eles usaram os processadores Baikal-T1 e Alt OS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>