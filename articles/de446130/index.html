<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏼 🤚🏼 👩🏼 Ereignisaggregator für Ereignis Unity3d 🕑 👦🏽 🙋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Idee, einen eigenen erweiterten Ereignisaggregator für Unity3d zu schreiben, ist längst überfällig. Nachdem ich mehrere Artikel zu diesem Thema ge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ereignisaggregator für Ereignis Unity3d</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446130/">  Die Idee, einen eigenen erweiterten Ereignisaggregator für Unity3d zu schreiben, ist längst überfällig.  Nachdem ich mehrere Artikel zu diesem Thema gelesen hatte, stellte ich fest, dass es nicht genug „Richtiges“ (in Unity3d) und den für mich erforderlichen Aggregator gibt. Alle Lösungen sind reduziert und verfügen nicht über die erforderliche Funktionalität. <br><br><h3>  Erforderliche Funktionalität: </h3><br><ol><li>  Jede Klasse kann jedes Ereignis abonnieren (häufig bilden Aggregatoren in einer Einheit bestimmte Gameobject-Abonnenten). </li><li>  Die Möglichkeit des doppelten Abonnierens einer bestimmten Instanz für ein bestimmtes Ereignis sollte ausgeschlossen werden (in Standardtools müssen Sie dies selbst befolgen). </li><li>  Es sollte sowohl manuelles als auch automatisches Abbestellen von Funktionen geben, wenn eine Instanz gelöscht oder Monobekh deaktiviert wird (ich möchte abonnieren und kein Dampfbad nehmen, das der Abonnent plötzlich den Huf zurückwirft). </li><li>  Ereignisse sollten in der Lage sein, Daten / Links beliebiger Komplexität zu übertragen (ich möchte in einer Zeile abonnieren und den gesamten Datensatz ohne Probleme abrufen). </li></ol><a name="habracut"></a><br><h3>  Wo kann man es anwenden? </h3><br><ol><li>  Dies ist ideal für die Benutzeroberfläche, wenn Daten von einem Objekt ohne Verbindung weitergeleitet werden müssen. </li><li>  Meldungen über Datenänderungen, einige Analoga des reaktiven Codes. </li><li>  Zur Abhängigkeitsinjektion </li><li>  Globale Rückrufe </li></ol><br><h3>  Schwachstellen </h3><br><ol><li> Aufgrund von Überprüfungen toter Abonnenten und Takes (ich werde später offenbaren) ist der Code langsamer als ähnliche Lösungen </li><li>  Klasse / Struktur wird als Kern des Ereignisses verwendet. Um keinen Speicher + das Hauptproblem zuzuweisen, wird nicht empfohlen, Ereignisse im Update als Spam zu versenden. </li></ol><br><h3>  Allgemeine Ideologie </h3><br>  Die allgemeine Ideologie ist, dass eine Veranstaltung für uns ein spezifisches und relevantes Datenpaket ist.  Angenommen, wir haben eine Taste auf einer Schnittstelle / einem Joystick gedrückt.  Und wir möchten ein Ereignis mit Anzeichen für das Drücken einer bestimmten Taste zur weiteren Verarbeitung senden.  Das Ergebnis der Verarbeitung von Klicks sind visuelle Änderungen an der Benutzeroberfläche und eine Aktion in der Logik.  Dementsprechend kann die Verarbeitung / das Abonnement an zwei verschiedenen Orten erfolgen. <br><br>  <b>Wie der Ereigniskörper / das Datenpaket in meinem Fall aussieht:</b> <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel für einen Ereigniskörper</b> <div class="spoiler_text"><pre><code class="javascript hljs">public struct ClickOnButtonEvent   {     public int ButtonID; <span class="hljs-comment"><span class="hljs-comment">//     enum    }</span></span></code> </pre> <br></div></div><br>  <b>Wie das Veranstaltungsabonnement aussieht:</b> <br><br><pre> <code class="javascript hljs">public <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AddListener&lt;T&gt;(object listener, Action&lt;T&gt; action)</code> </pre><br>  Um sich anzumelden, müssen wir Folgendes angeben: <br>  Ein Objekt, das ein Abonnent ist (normalerweise ist es die Klasse selbst, in der sich das Abonnement befindet, dies ist jedoch nicht erforderlich. Der Abonnent kann eine der Klasseninstanzen aus den Klassenfeldern angeben. <br>  Typ / Ereignis, das wir abonnieren.  Dies ist die Schlüsselessenz dieses Aggregators. Für uns ist eine bestimmte Art von Klasse ein Ereignis, das wir abhören und verarbeiten. <br>  Am besten in Awake und OnEnable abonnieren; <br><br>  <b>Beispiel</b> <br><br><pre> <code class="javascript hljs">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ private <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { EventAggregator.AddListener&lt;ClickOnButtonEvent&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ClickButtonListener); } private <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ClickButtonListener(ClickOnButtonEvent obj) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"  "</span></span> + obj.ButtonID); } }</code> </pre><br><h3>  Betrachten Sie einen komplexeren Fall, um zu verdeutlichen, was der Chip ist </h3><br>  <b>Wir haben Charaktersymbole, die:</b> <br><ol><li>  Wissen Sie, an welchen Charakter sie gebunden sind. </li><li>  Reflektieren Sie die Menge an Mana, HP, Exp und Status (Betäubung, Blindheit, Angst, Wahnsinn). </li></ol><br>  <b>Und hier können Sie mehrere Veranstaltungen durchführen</b> <br><br>  So ändern Sie die Indikatoren: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct CharacterStateChanges { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Character Character; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Hp; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Mp; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Xp; }</code> </pre> <br>  So ändern Sie den negativen Status: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct CharacterNegativeStatusEvent { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Character Character; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Statuses Statuses; <span class="hljs-comment"><span class="hljs-comment">//enum  }</span></span></code> </pre><br>  Warum bestehen wir in beiden Fällen die Zeichenklasse?  Hier ist der Teilnehmer und sein Handler: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ EventAggregator.AddListener&lt;CharacterNegativeStatusEvent&gt; (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, CharacterNegativeStatusListener); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CharacterNegativeStatusListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharacterNegativeStatusEvent obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj.Character != _character) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; _currentStatus = obj.Statuses; }</code> </pre><br>  Dies ist der Marker, anhand dessen wir das Ereignis verarbeiten und verstehen, was genau wir brauchen. <br>  <b>Nehmen Sie an, Sie abonnieren direkt die Zeichenklasse.</b>  <b>Und sie spammen?</b> <br>  Es wird schwierig zu debütieren sein, es ist besser für eine Gruppe von Klassen / Ereignissen, ein eigenes separates Ereignis zu erstellen. <br><br>  <b>Warum sollte man innerhalb des Events einfach nicht den Charakter setzen und alles daraus nehmen?</b> <br>  Übrigens ist es möglich, aber häufig gibt es in Klassen Sichtbarkeitsbeschränkungen, und die für das Ereignis erforderlichen Daten sind möglicherweise von außen nicht sichtbar. <br><br>  <b>Ist die Klasse zu schwer, um als Marker verwendet zu werden?</b> <br>  Tatsächlich wird in den meisten Fällen kein Marker benötigt, eine Gruppe aktualisierter Klassen ist eher selten.  Normalerweise benötigt eine bestimmte Entität ein Ereignis - ein Controller- / Ansichtsmodell, das normalerweise den Status des ersten Zeichens anzeigt.  Und so gibt es immer eine banale Lösung - IDs verschiedener Typen (von Inam bis zu komplexem Hash usw.). <br><br><h3>  Was ist unter der Haube und wie funktioniert es? </h3><br><div class="spoiler">  <b class="spoiler_title">Direkt Aggregatorcode</b> <div class="spoiler_text"><pre> <code class="java hljs">namespace GlobalEventAggregator <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> delegate <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> EventHandler&lt;T&gt;(T e); { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventContainer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDebugable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> event EventHandler&lt;T&gt; _eventKeeper; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly Dictionary&lt;WeakReference, EventHandler&lt;T&gt;&gt; _activeListenersOfThisType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;WeakReference, EventHandler&lt;T&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> string Error = <span class="hljs-string"><span class="hljs-string">"null"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasDuplicates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object listener)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _activeListenersOfThisType.Keys.Any(k =&gt; k.Target == listener); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddToEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object listener, EventHandler&lt;T&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newAction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeakReference(listener); _activeListenersOfThisType.Add(newAction, action); _eventKeeper += _activeListenersOfThisType[newAction]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveFromEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object listener)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentEvent = _activeListenersOfThisType.Keys.FirstOrDefault(k =&gt; k.Target == listener); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentEvent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { _eventKeeper -= _activeListenersOfThisType[currentEvent]; _activeListenersOfThisType.Remove(currentEvent); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object listener, EventHandler&lt;T&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ _eventKeeper += action; _activeListenersOfThisType.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeakReference(listener), action); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_activeListenersOfThisType.Keys.Any(k =&gt; k.Target.ToString() == Error)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> failObjList = _activeListenersOfThisType.Keys.Where(k =&gt; k.Target.ToString() == Error).ToList(); foreach (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fail in failObjList) { _eventKeeper -= _activeListenersOfThisType[fail]; _activeListenersOfThisType.Remove(fail); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_eventKeeper != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) _eventKeeper(t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> string </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DebugInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ string info = string.Empty; foreach (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c in _activeListenersOfThisType.Keys) { info += c.Target.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> info; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventAggregator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;Type, object&gt; GlobalListeners = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Type, object&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventAggregator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SceneManager.sceneUnloaded += ClearGlobalListeners; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearGlobalListeners</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scene scene)</span></span></span><span class="hljs-function"> </span></span>{ GlobalListeners.Clear(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AddListener&lt;T&gt;(object listener, Action&lt;T&gt; action) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = typeof(T); EventHandler&lt;T&gt; handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventHandler&lt;T&gt;(action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GlobalListeners.ContainsKey(key)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lr = (EventContainer&lt;T&gt;)GlobalListeners[key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lr.HasDuplicates(listener)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; lr.AddToEvent(listener, handler); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } GlobalListeners.Add(key, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventContainer&lt;T&gt;(listener, handler)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Invoke&lt;T&gt;(T data) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = typeof(T); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GlobalListeners.ContainsKey(key)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eventContainer = (EventContainer&lt;T&gt;)GlobalListeners[key]; eventContainer.Invoke(data); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RemoveListener&lt;T&gt;(object listener) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = typeof(T); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GlobalListeners.ContainsKey(key)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eventContainer = (EventContainer&lt;T&gt;)GlobalListeners[key]; eventContainer.RemoveFromEvent(listener); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> string </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DebugInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ string info = string.Empty; foreach (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listener in GlobalListeners) { info += <span class="hljs-string"><span class="hljs-string">"     "</span></span> + listener.Key.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = (IDebugable)listener.Value; info += t.DebugInfo() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> info; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDebugable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">string </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DebugInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } }</code> </pre> <br></div></div><br>  <b>Beginnen wir mit dem Haupt</b> <br><br>  Dies ist ein Wörterbuch, in dem der Schlüssel Typ und der Wert Container ist <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventContainer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDebugable</span></span></span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;Type, object&gt; GlobalListeners = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Type, object&gt;();</code> </pre> <br>  Warum speichern wir den Container als Objekt?  Das Wörterbuch kann keine Generika speichern.  Dank des Schlüssels können wir das Objekt jedoch schnell auf den gewünschten Typ bringen. <br><br>  <b>Was enthält der Container?</b> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> event EventHandler&lt;T&gt; _eventKeeper; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly Dictionary&lt;WeakReference, EventHandler&lt;T&gt;&gt; _activeListenersOfThisType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;WeakReference, EventHandler&lt;T&gt;&gt;();</code> </pre> <br>  Es enthält eine generische Multidelegate und eine Sammlung, in der der Schlüssel das Objekt ist, das der Abonnent ist, und der Wert dieselbe Handlermethode ist.  Tatsächlich enthält dieses Wörterbuch alle Objekte und Methoden, die zu diesem Typ gehören.  Infolgedessen rufen wir ein Multidelegate auf, und er ruft alle Abonnenten an. Dies ist ein „ehrliches“ Ereignissystem, bei dem es keine Einschränkungen für den Abonnenten gibt. In den meisten anderen Aggregatoren wird jedoch eine Sammlung von Klassen, die entweder von einer speziellen Schnittstelle verallgemeinert oder von einer Klasse geerbt werden, die das System implementiert, unter der Haube iteriert Nachrichten. <br><br>  Wenn ein Multidelegate aufgerufen wird, wird geprüft, ob tote Schlüssel vorhanden sind, die Sammlung wird von Leichen gereinigt, und anschließend wird ein Multidelegate mit relevanten Abonnenten aufgenommen.  Dies braucht Zeit, aber wenn die Funktionalität der Ereignisse getrennt ist, hat ein Ereignis 3-5 Abonnenten, sodass die Überprüfung nicht so beängstigend ist und der Vorteil des Komforts offensichtlicher ist.  Für Netzwerk-Storys mit tausend oder mehr Abonnenten ist es besser, diesen Aggregator nicht zu verwenden.  Obwohl die Frage offen bleibt - wenn Sie die Prüfung auf Leichen entfernen, was schneller ist -, iterieren Sie über ein Array von Abonnenten von 1k oder rufen Sie einen Multi-Delegaten von 1k-Abonnenten an. <br><br><h3>  Merkmale der Verwendung </h3><br>  Ein Abonnement wird am besten in Awake gepusht. <br><br>  Wenn ein Objekt aktiv ein- und ausgeschaltet wird, ist es besser, Awake und OnEnable zu abonnieren. Es wird nicht zweimal signiert, aber die Möglichkeit, dass ein inaktives GameObject für tot gehalten wird, wird ausgeschlossen. <br><br>  Rechnungsereignisse sind besser nicht vor dem Start, wenn alle Abonnenten erstellt und registriert werden. <br><br>  Der Aggregator bereinigt die Liste beim Entladen der Szene.  In einigen Aggregatoren wird empfohlen, das Laden der Szene zu bereinigen. Dies ist eine Datei. Das Ereignis zum Laden der Szene erfolgt nach Awake / OnEnable. Die hinzugefügten Abonnenten werden gelöscht. <br><br>  Der Aggregator hat - öffentliche statische Zeichenfolge DebugInfo (), Sie können sehen, welche Klassen welche Ereignisse abonniert haben. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>GitHub-Repository</b></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446130/">https://habr.com/ru/post/de446130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446118/index.html">Open Rack v3: Was erwartet Sie vom neuen Standard für die Server-Rack-Architektur?</a></li>
<li><a href="../de446120/index.html">US-Telekommunikation zur Bekämpfung von Telefon-Spam</a></li>
<li><a href="../de446124/index.html">Digitale Veranstaltungen in Moskau vom 1. bis 7. April</a></li>
<li><a href="../de446126/index.html">Freizeitgedanken einer untätigen Person über Kryptographie und Datenschutz</a></li>
<li><a href="../de446128/index.html">Röntgenphonogramme kehren zurück: Massive Attacke, Jonsi und andere veröffentlichten Aufzeichnungen „on the Bones“</a></li>
<li><a href="../de446132/index.html">92,7% machen Backups, der Datenverlust stieg um 30%. Was ist los?</a></li>
<li><a href="../de446134/index.html">Abhängigkeitsinjektion beim Flattern</a></li>
<li><a href="../de446136/index.html">Meine Marmormaschine 3D gedruckt</a></li>
<li><a href="../de446142/index.html">Flache Erde: Experimente und Beweise</a></li>
<li><a href="../de446144/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 292 (25. März - 31. März)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>