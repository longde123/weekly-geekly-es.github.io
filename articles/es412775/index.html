<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèß üëè üèê Experiencia personal: pasar del desarrollo de C de bajo nivel a la programaci√≥n Java üëµüèΩ üåª üöÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El art√≠culo refleja la experiencia personal del autor, un √°vido programador de microcontroladores que, despu√©s de muchos a√±os de experiencia en el des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Experiencia personal: pasar del desarrollo de C de bajo nivel a la programaci√≥n Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412775/"><img src="https://habrastorage.org/webt/vn/27/lu/vn27lubocfjfz-oiaqgsy7eig5o.jpeg"><br><br>  El art√≠culo refleja la experiencia personal del autor, un √°vido programador de microcontroladores que, despu√©s de muchos a√±os de experiencia en el desarrollo de microcontroladores en C (y un poco en C ++), tuvo la oportunidad de participar en un importante proyecto de Java para desarrollar software para decodificadores de TV con Android.  Durante este proyecto, pude recopilar notas sobre diferencias interesantes entre los lenguajes Java y C / C ++, evaluar diferentes enfoques para escribir programas.  El art√≠culo no pretende ser una referencia; no examina la eficiencia y la productividad de los programas Java.  Es m√°s bien una colecci√≥n de observaciones personales.  A menos que se especifique lo contrario, esta es una versi√≥n de Java SE 7. <br><a name="habracut"></a><br><h2>  Diferencias de sintaxis y construcciones de control </h2><br>  En resumen: las diferencias son m√≠nimas, la sintaxis es muy similar.  Los bloques de c√≥digo tambi√©n est√°n formados por un par de llaves {}.  Las reglas para compilar identificadores son las mismas que para C / C ++.  La lista de palabras clave es casi la misma que en C / C ++.  Tipos de datos integrados: similares a los de C / C ++.  Matrices: todas se declaran tambi√©n entre corchetes. <br><br>  Las construcciones de control if-else, while, do-while, for, switch tambi√©n son casi completamente id√©nticas.  Es de destacar que en Java hab√≠a etiquetas familiares para los programadores en C (aquellas que se usan con la palabra clave goto y cuyo uso se desaconseja).  Sin embargo, Java excluy√≥ la posibilidad de cambiar a una etiqueta usando goto.  Las etiquetas solo deben usarse para salir de bucles anidados: <br><br><pre><code class="java hljs">outer: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { inner: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> inner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> outer; } }</code> </pre> <br>  Para mejorar la legibilidad de los programas en Java, se ha agregado una oportunidad interesante para separar los bits de n√∫meros largos con un gui√≥n bajo: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value1 = <span class="hljs-number"><span class="hljs-number">1_500_000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> value2 = <span class="hljs-number"><span class="hljs-number">0xAA_BB_CC_DD</span></span>;</code> </pre> <br>  Externamente, un programa Java no es muy diferente de un programa familiar de C. La principal diferencia visual es que Java no permite funciones, variables, definiciones de nuevos tipos (estructuras), constantes, etc., que se encuentran "libremente" en el archivo fuente.  Java es un lenguaje orientado a objetos, por lo que todas las entidades del programa deben pertenecer a alguna clase.  Otra diferencia significativa es la falta de un preprocesador.  Estas dos diferencias se describen con m√°s detalle a continuaci√≥n. <br><br><h2>  Enfoque de objeto en lenguaje C </h2><br>  Cuando escribimos programas grandes en C, b√°sicamente tenemos que trabajar con objetos.  El papel del objeto aqu√≠ lo realiza una estructura que describe una cierta esencia del "mundo real": <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   ‚Äì ¬´¬ª struct Data { int field; char *str; /* ... */ };</span></span></code> </pre> <br>  Tambi√©n en C hay m√©todos para procesar "objetos" -estructuras - funciones.  Sin embargo, las funciones no se fusionan esencialmente con los datos.  S√≠, generalmente se colocan en un archivo, pero cada vez es necesario pasar un puntero al objeto para que se procese en la funci√≥n "t√≠pica": <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data *ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result_code; }</code> </pre> <br>  Puede usar el "objeto" solo despu√©s de asignar memoria para almacenarlo: <br><br><pre> <code class="java hljs">Data *data = malloc(sizeof(Data));</code> </pre> <br>  En un programa en C, generalmente se define una funci√≥n que es responsable de la inicializaci√≥n del "objeto" antes de su primer uso: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data *data)</span></span></span><span class="hljs-function"> </span></span>{ data-&gt;field = <span class="hljs-number"><span class="hljs-number">1541</span></span>; data-&gt;str = NULL; }</code> </pre> <br>  Entonces el ciclo de vida de un "objeto" en C suele ser as√≠: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*    "" */</span></span> struct Data *data = malloc(sizeof(Data)); <span class="hljs-comment"><span class="hljs-comment">/*  "" */</span></span> init(data); <span class="hljs-comment"><span class="hljs-comment">/*   "" */</span></span> process(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"string"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*  ,  ""     . */</span></span> free(data);</code> </pre> <br>  Ahora enumeramos los posibles errores de tiempo de ejecuci√≥n que puede realizar el programador en el ciclo de vida del "objeto": <br><br><ol><li>  Olv√≠dese de asignar memoria para el "objeto" </li><li>  Especifique la cantidad incorrecta de memoria asignada </li><li>  Olv√≠date de inicializar el "objeto" </li><li>  Olv√≠date de liberar memoria despu√©s de usar el objeto </li></ol><br>  Puede ser extremadamente dif√≠cil detectar tales errores, ya que el compilador no los detecta y aparecen durante la operaci√≥n del programa.  Adem√°s, su efecto puede ser muy diverso y afectar otras variables y "objetos" del programa. <br><br><h2>  Enfoque de objetos Java </h2><br>  Frente a la programaci√≥n orientada a objetos OOP, probablemente escuchaste sobre una de las ballenas OOP: la encapsulaci√≥n.  En Java, a diferencia de C, los datos y los m√©todos para procesarlos se combinan y son objetos "verdaderos".  En t√©rminos de OOP, esto se llama encapsulaci√≥n.  Una clase es una descripci√≥n de un objeto, el an√°logo m√°s cercano de una clase en C es definir un nuevo tipo usando typedef struct.  En t√©rminos de Java, esas funciones que pertenecen a una clase se denominan m√©todos. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   class Entity { public int field; //   public String str; //   //  public int process(int arg1, String arg2) { /* ... */ return resultCode; } //  public Entity() { field = 1541; str = "value"; } }</span></span></code> </pre> <br>  La ideolog√≠a del lenguaje Java se basa en la afirmaci√≥n "todo es un objeto".  Por lo tanto, no es sorprendente que Java proh√≠ba la creaci√≥n de ambos m√©todos (funciones) y campos de datos (variables) por separado de la clase.  Incluso el m√©todo main () familiar, desde el cual se inicia el programa, debe pertenecer a una de las clases. <br><br>  Una definici√≥n de clase en Java es an√°loga a una declaraci√≥n de estructura en C. Al describir una clase, no crea nada en la memoria.  Un objeto de esta clase aparece en el momento de su creaci√≥n por el nuevo operador.  La creaci√≥n de un objeto en Java es un an√°logo de la asignaci√≥n de memoria en el lenguaje C, pero, a diferencia de este √∫ltimo, se llama autom√°ticamente a un m√©todo especial durante la creaci√≥n del objeto: el constructor de objetos.  El constructor asume el papel de la inicializaci√≥n inicial del objeto, un an√°logo de la funci√≥n init () discutida anteriormente.  El nombre del constructor debe coincidir con el nombre de la clase.  El constructor no puede devolver un valor. <br><br>  El ciclo de vida de un objeto en un programa Java es el siguiente: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   (   ,  ) Entity entity = new Entity(); //    entity.process(123, "argument");</span></span></code> </pre> <br>  Tenga en cuenta que el n√∫mero de posibles errores en el programa Java es mucho menor que en el programa C. S√≠, a√∫n puede olvidarse de crear el objeto antes del primer uso (que, sin embargo, conducir√° a una NullPointerException f√°cilmente depurada), pero en cuanto a los otros errores inherentes C programas, la situaci√≥n est√° cambiando fundamentalmente: <br><br><ol><li>  No hay operador sizeof () en Java.  El compilador de Java calcula la cantidad de memoria para almacenar el objeto.  Por lo tanto, no es posible especificar el tama√±o incorrecto de la selecci√≥n. </li><li>  La inicializaci√≥n del objeto ocurre en el momento de la creaci√≥n.  Es imposible olvidarse de la inicializaci√≥n. </li><li>  La memoria ocupada por el objeto no necesita ser liberada; el recolector de basura hace este trabajo.  Es imposible olvidar eliminar un objeto despu√©s de su uso; hay menos probabilidad de que se produzca un efecto de "p√©rdida de memoria". </li></ol><br>  Entonces, todo en Java es un objeto de una clase u otra.  Las excepciones son primitivas que se han agregado al lenguaje para mejorar el rendimiento y el consumo de memoria.  M√°s sobre primitivas est√° abajo. <br><br><h2>  Recolector de memoria y basura </h2><br>  Java conserva los conceptos familiares de mont√≥n y pila para C / C ++, un programador.  Al crear un objeto con el nuevo operador, la memoria para almacenar el objeto se toma prestada del mont√≥n.  Sin embargo, un enlace a un objeto (un enlace es un an√°logo de un puntero), si el objeto creado no es parte de otro objeto, se coloca en la pila.  En el mont√≥n se almacenan los "cuerpos" de los objetos, y en la pila hay variables locales: referencias a objetos y tipos primitivos.  Si el mont√≥n existe durante la ejecuci√≥n del programa y est√° disponible para todos los subprocesos del programa, la pila pertenece al m√©todo y existe solo durante su ejecuci√≥n, y tambi√©n es inaccesible para otros subprocesos del programa. <br><br>  Java es innecesario y a√∫n m√°s: no puede liberar manualmente la memoria ocupada por un objeto.  El recolector de basura realiza este trabajo en modo autom√°tico.  El tiempo de ejecuci√≥n supervisa si es posible alcanzar cada objeto en el mont√≥n desde la ubicaci√≥n actual del programa siguiendo los enlaces de un objeto a otro.  De lo contrario, dicho objeto se reconoce como "basura" y se convierte en candidato para su eliminaci√≥n. <br><br>  Es importante tener en cuenta que la eliminaci√≥n en s√≠ no ocurre en el momento en que el objeto "ya no es necesario": el recolector de basura decide la eliminaci√≥n, y la eliminaci√≥n se puede retrasar tanto como sea necesario hasta que el programa finalice. <br><br>  Por supuesto, el trabajo del recolector de basura requiere una sobrecarga del procesador.  Pero a cambio, alivia al programador de un gran dolor de cabeza asociado con la necesidad de liberar memoria despu√©s del final del uso de "objetos".  De hecho, "tomamos" la memoria cuando la necesitamos y la usamos, sin pensar que necesitamos liberarla despu√©s de nosotros mismos. <br><br>  Hablando de variables locales, debemos recordar el enfoque de Java para su inicializaci√≥n.  Si en C / C ++ una variable local no inicializada contiene un valor aleatorio, entonces el compilador de Java simplemente no permitir√° que se deje sin inicializar: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-comment"><span class="hljs-comment">//  . System.out.println("" + i); //  !</span></span></code> </pre><br><h2>  Enlaces - Punteros de repuesto </h2><br>  Java no tiene punteros; en consecuencia, un programador de Java no tiene la capacidad de cometer uno de los muchos errores que ocurren al trabajar con punteros.  Cuando crea un objeto, obtiene un enlace a este objeto: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  entity ‚Äì  . Entity entity = new Entity();</span></span></code> </pre><br>  En C, el programador ten√≠a una opci√≥n: c√≥mo pasar, por ejemplo, una estructura a una funci√≥n.  Podr√≠as pasar por valor: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    . int func(Data data);    ‚Äì   : //    . void process(Data *data);</span></span></code> </pre> <br>  Pasar por valor garantizaba que la funci√≥n no cambiar√≠a los datos en la estructura, pero era ineficaz en t√©rminos de rendimiento: en el momento en que se llam√≥ a la funci√≥n, se cre√≥ una copia de la estructura.  Pasar por un puntero es mucho m√°s eficiente: de hecho, la direcci√≥n en la memoria donde se encuentra la estructura se pas√≥ a la funci√≥n. <br><br>  En Java, solo hab√≠a una forma de pasar un objeto a un m√©todo: por referencia.  Pasar por referencia en Java es an√°logo a pasar por un puntero en C: <br><ul><li>  no se produce la copia (clonaci√≥n) de memoria, </li><li>  de hecho, se transmite la direcci√≥n de la ubicaci√≥n de este objeto. </li></ul><br>  Sin embargo, a diferencia del puntero del lenguaje C, un enlace Java no puede incrementarse / decrementarse.  "Ejecutar" a trav√©s de los elementos de una matriz utilizando un enlace a √©l en Java no funcionar√°.  Todo lo que se puede hacer con un enlace es darle un valor diferente. <br><br>  Por supuesto, la ausencia de punteros como tales reduce el n√∫mero de posibles errores, sin embargo, el an√°logo del puntero nulo permanece en el lenguaje, una referencia nula denotada por la palabra clave nula. <br><br>  Una referencia nula es un dolor de cabeza para un programador de Java, ya que  obliga a que la referencia del objeto sea comprobada por nula antes de usarla o que maneje las excepciones NullPointerException.  Si esto no se hace, el programa se bloquear√°. <br><br>  Por lo tanto, todos los objetos en Java se pasan a trav√©s de enlaces.  Los tipos de datos primitivos (int, long, char ...) se pasan por valor (a continuaci√≥n se ofrece m√°s informaci√≥n sobre primitivas). <br><br><h2>  Caracter√≠sticas del enlace Java </h2><br>  El acceso a cualquier objeto en el programa es a trav√©s de un enlace; esto claramente tiene un efecto positivo en el rendimiento, pero puede sorprender a un novato: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   entity1   . Entity entity1 = new Entity(); entity1.field = 123; //   entity2,     entity1. //    !   ! Entity entity2 = entity1; //   entity1  entity2         . entity2.field = 777; //  entity1.field  777. System.out.println(entity1.field);</span></span></code> </pre> <br>  Argumentos del m√©todo y valores de retorno: todo se pasa a trav√©s del enlace.  Adem√°s de las ventajas, hay un inconveniente en comparaci√≥n con los lenguajes C / C ++, donde podemos prohibir expl√≠citamente que las funciones cambien el valor pasado a trav√©s de un puntero usando un calificador const: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct Data* data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ! //    ,    ! data-&gt;field = 0; }</span></span></code> </pre> <br>  Es decir, el lenguaje C le permite rastrear este error en la etapa de compilaci√≥n.  Java tambi√©n tiene la palabra clave const, pero est√° reservada para futuras versiones y actualmente no se utiliza en absoluto.  Hasta cierto punto, la palabra clave final debe cumplir su funci√≥n.  Sin embargo, no protege el objeto pasado al m√©todo de los cambios: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Entity data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . //    final,    . data.field = 0; } }</span></span></code> </pre> <br>  La cuesti√≥n es que la palabra clave final en este caso se aplica al enlace, y no al objeto al que apunta el enlace.  Si final se aplica a la primitiva, el compilador se comporta como se esperaba: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . value = 0; }</span></span></code> </pre> <br>  Los enlaces de Java son muy similares a los enlaces de lenguaje C ++. <br><br><h2>  Primitivas de Java </h2><br>  Cada objeto Java, adem√°s de los campos de datos, contiene informaci√≥n de soporte.  Si queremos operar, por ejemplo, en bytes separados y cada byte est√° representado por un objeto, entonces, en el caso de una matriz de bytes, la sobrecarga de memoria puede exceder muchas veces el tama√±o utilizable. <br>  Para que Java siga siendo lo suficientemente eficiente en los casos descritos anteriormente, se agreg√≥ al lenguaje soporte para tipos primitivos, primitivos. <br><table><tbody><tr><th>  Primitivo </th><th>  Vista </th><th>  Profundidad de bits </th><th>  Posible an√°logo en C </th></tr><tr><td>  byte </td><td rowspan="5">  Entero </td><td>  8 </td><td>  char </td></tr><tr><td>  corta </td><td>  16 </td><td>  corta </td></tr><tr><td>  char </td><td>  16 </td><td>  wchar_t </td></tr><tr><td>  int </td><td>  32 </td><td>  int (largo) </td></tr><tr><td>  largo </td><td>  64 </td><td>  largo </td></tr><tr><td>  flotar </td><td>  N√∫meros de punto flotante </td><td>  32 </td><td>  flotar </td></tr><tr><td>  doble </td><td></td><td>  64 </td><td>  doble </td></tr><tr><td>  booleano </td><td>  L√≥gico </td><td>  - </td><td>  int (C89) / bool (C99) </td></tr></tbody></table><br>  Todas las primitivas tienen sus an√°logos en el lenguaje C. Sin embargo, el est√°ndar C no determina el tama√±o exacto de los tipos enteros; en cambio, el rango de valores que este tipo puede almacenar es fijo.  A menudo, el programador quiere garantizar la misma profundidad de bits para diferentes m√°quinas, lo que lleva a la aparici√≥n de tipos como uint32_t en el programa, aunque todas las funciones de la biblioteca requieren argumentos del tipo int. <br>  Este hecho no puede atribuirse a las ventajas del lenguaje. <br><br>  Las primitivas enteras de Java, a diferencia de C, tienen profundidades de bits fijas.  Por lo tanto, no tiene que preocuparse por la profundidad de bits real de la m√°quina en la que se ejecuta el programa Java, as√≠ como por el orden de los bytes ("red" o "Intel").  Este hecho ayuda a comprender el principio "se escribe una vez, se ejecuta en todas partes". <br><br>  Adem√°s, en Java todas las primitivas enteras est√°n firmadas (el lenguaje carece de la palabra clave sin signo).  Esto elimina la dificultad de usar variables con y sin signo en una sola expresi√≥n inherente a C. <br><br>  En conclusi√≥n, el orden de bytes en primitivas de m√∫ltiples bytes en Java es fijo (byte bajo en direcci√≥n baja, Little-endian, orden inverso). <br><br>  Las desventajas de la implementaci√≥n de operaciones con primitivas en Java incluyen el hecho de que aqu√≠, como en el programa C / C ++, puede ocurrir el desbordamiento de la cuadr√≠cula de bits, sin que se produzcan excepciones: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">2_147_483_640</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = <span class="hljs-number"><span class="hljs-number">2_147_483_640</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = (i1 + i2); <span class="hljs-comment"><span class="hljs-comment">// r = -16</span></span></code> </pre> <br>  Entonces, los datos en Java est√°n representados por dos tipos de entidades: objetos y primitivas.  Las primitivas violan el concepto de "todo es un objeto", pero en algunas situaciones son demasiado efectivas para no usarlas. <br><br><h2>  Herencia </h2><br>  La herencia es otra ballena OOP de la que probablemente hayas o√≠do hablar.  Si responde brevemente la pregunta "por qu√© la herencia es necesaria", la respuesta ser√° "reutilizaci√≥n de c√≥digo". <br><br>  Suponga que programa en C y tiene una "clase" bien escrita y depurada: una estructura y funciones para procesarla.  A continuaci√≥n, surge la necesidad de crear una "clase" similar, pero con una funcionalidad mejorada, y a√∫n se necesita la "clase" b√°sica.  En el caso del lenguaje C, solo tiene una forma de resolver este problema: la composici√≥n.  Se trata de crear una nueva estructura extendida - "clase", que debe contener un puntero a la estructura base de "clase": <br><br><pre> <code class="java hljs">struct Base { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> field1; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *field2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baseMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Base *obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span></span>; struct Extended { struct Base *base; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> auxField; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extendedMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Extended *obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{ baseMethod(obj-&gt;base, <span class="hljs-number"><span class="hljs-number">123</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Java como lenguaje orientado a objetos le permite ampliar la funcionalidad de las clases existentes utilizando el mecanismo de herencia: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   class Base { protected int baseField; private int hidden; public void baseMethod() { } } //   -   . class Extended extends Base { public void extendedMethod() { //    public  protected     . baseField = 123; baseMethod(); // !   private  ! hidden = 123; } }</span></span></code> </pre> <br>  Cabe se√±alar que Java de ninguna manera proh√≠be el uso de la composici√≥n como una forma de extender la funcionalidad de las clases ya escritas.  Adem√°s, en muchas situaciones, la composici√≥n es preferible a la herencia. <br><br>  Gracias a la herencia, las clases en Java est√°n organizadas en una estructura jer√°rquica, cada clase necesariamente tiene uno y solo un "padre" y puede tener cualquier n√∫mero de "hijos".  A diferencia de C ++, una clase en Java no puede heredar de m√°s de un padre (esto resuelve el problema de la "herencia de diamantes"). <br><br>  Durante la herencia, la clase derivada llega a su ubicaci√≥n todos los campos y m√©todos p√∫blicos y protegidos de su clase base, as√≠ como la clase base de su clase base, y as√≠ sucesivamente en la jerarqu√≠a de herencia. <br><br>  En la parte superior de la jerarqu√≠a de herencia se encuentra el progenitor com√∫n de todas las clases Java: la clase Object, la √∫nica que no tiene un padre. <br><br><h2>  Identificaci√≥n din√°mica de tipo </h2><br>  Uno de los puntos clave del lenguaje Java es el soporte para la identificaci√≥n din√°mica de tipo (RTTI).  En palabras simples, RTTI le permite sustituir un objeto de una clase derivada donde se requiere una referencia a la base: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     Base link; //         link = new Extended();</span></span></code> </pre><br>  Al tener un enlace en tiempo de ejecuci√≥n, puede determinar el tipo verdadero del objeto al que se refiere el enlace, utilizando el operador instanceof: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Base) { <span class="hljs-comment"><span class="hljs-comment">// false } else if (link instanceof Extended) { // true }</span></span></code> </pre> <br><h2>  M√©todo de anulaciones </h2><br>  Redefinir un m√©todo o funci√≥n significa reemplazar su cuerpo en la etapa de ejecuci√≥n del programa.  Los programadores de C son conscientes de la capacidad de un lenguaje para cambiar el comportamiento de una funci√≥n durante la ejecuci√≥n del programa.  Se trata de usar punteros de funci√≥n.  Por ejemplo, puede incluir un puntero a una funci√≥n en la estructura de la estructura y asignar varias funciones al puntero para cambiar el algoritmo de procesamiento de datos de esta estructura: <br><br><pre> <code class="java hljs">struct Object { <span class="hljs-comment"><span class="hljs-comment">//   . void (*process)(struct Object *); int data; }; void divideByTwo(struct Object *obj) { obj-&gt;data = obj-&gt;data / 2; } void square(struct Object *obj) { obj-&gt;data = obj-&gt;data * obj-&gt;data; } struct Object obj; obj.data = 123; obj.process = divideByTwo; obj.process(&amp;obj); // 123 / 2 = 61 obj.process = square; obj.process(&amp;obj); // 61 * 61 = 3721</span></span></code> </pre> <br>  En Java, como en otros lenguajes OOP, los m√©todos de anulaci√≥n est√°n inextricablemente vinculados a la herencia.  Una clase derivada obtiene acceso a los m√©todos p√∫blicos y protegidos de la clase base.  Adem√°s del hecho de que puede llamarlos, puede cambiar el comportamiento de uno de los m√©todos de la clase base sin cambiar su firma.  Para hacer esto, es suficiente definir un m√©todo con exactamente la misma firma en la clase derivada: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   -   . class Extended extends Base { //  . public void method() { /* ... */ } //     ! // E      . //     . public void method(int i) { /* ... */ } }</span></span></code> </pre> <br>  Es muy importante que la firma (nombre del m√©todo, valor de retorno, argumentos) coincida exactamente.  Si el nombre del m√©todo coincide y los argumentos difieren, entonces el m√©todo se sobrecarga, m√°s sobre lo que se muestra a continuaci√≥n. <br><br><h2>  Polimorfismo </h2><br>  Al igual que la encapsulaci√≥n y la herencia, la tercera ballena OOP, el polimorfismo, tambi√©n tiene alg√∫n tipo de an√°logo en el lenguaje C orientado a los procedimientos. <br><br>  Supongamos que tenemos varias "clases" de estructuras con las que desea realizar el mismo tipo de acci√≥n, y la funci√≥n que realiza esta acci√≥n debe ser universal, debe "poder" trabajar con cualquier "clase" como argumento.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Una posible soluci√≥n es la siguiente: </font></font><br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Ids { ID_A, ID_B }; struct ClassA { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassA obj)</span></span></span><span class="hljs-function"> </span></span>{ obj-&gt;id = ID_A; } struct ClassB { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassB obj)</span></span></span><span class="hljs-function"> </span></span>{ obj-&gt;id = ID_B; } <span class="hljs-comment"><span class="hljs-comment">/* klass -   ClassA, ClassB, ... */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commonFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *klass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)klass; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (id) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID_A: ClassA *obj = (ClassA *) klass; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID_B: ClassB *obj = (ClassB *) klass; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La soluci√≥n parece engorrosa, pero el objetivo se logra: la funci√≥n universal commonFunc () acepta el "objeto" de cualquier "clase" como argumento. </font><font style="vertical-align: inherit;">Un requisito previo es una estructura de "clase" en el primer campo que debe contener un identificador por el cual se determina la "clase" real del objeto. </font><font style="vertical-align: inherit;">Tal soluci√≥n es posible debido al uso del argumento con el tipo "void *". </font><font style="vertical-align: inherit;">Sin embargo, se puede pasar un puntero de cualquier tipo a dicha funci√≥n, por ejemplo, "int *". </font><font style="vertical-align: inherit;">Esto no causar√° errores de compilaci√≥n, pero en tiempo de ejecuci√≥n el programa se comportar√° de manera impredecible.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora veamos c√≥mo se ve el polimorfismo en Java (sin embargo, como en cualquier otro lenguaje OOP). </font><font style="vertical-align: inherit;">Supongamos que tenemos muchas clases que deber√≠an procesarse de la misma manera por alg√∫n m√©todo. </font><font style="vertical-align: inherit;">A diferencia de la soluci√≥n para el lenguaje C presentada anteriormente, este m√©todo polim√≥rfico DEBE incluirse en todas las clases del conjunto dado, y todas sus versiones DEBEN tener la misma firma.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A continuaci√≥n, debe obligar al compilador a llamar exactamente la versi√≥n del m√©todo que pertenece a la clase correspondiente. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_set_of_class_ klass)</span></span></span><span class="hljs-function"> </span></span>{ klass.method(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es decir, el m√©todo ejecutor (), que puede estar en cualquier parte del programa, debe poder trabajar con cualquier clase del conjunto (A, B o C). </font><font style="vertical-align: inherit;">De alguna manera debemos "decirle" al compilador que _set_of_class_ denota nuestras muchas clases. </font><font style="vertical-align: inherit;">Aqu√≠ la herencia es √∫til: es necesario hacer todas las clases a partir de los derivados del conjunto de alguna clase base, que contendr√° un m√©todo polim√≥rfico:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} }   executor()   : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Base klass)</span></span></span><span class="hljs-function"> </span></span>{ klass.method(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y ahora cualquier clase que sea heredera de Base (gracias a la identificaci√≥n din√°mica de tipo) se le puede pasar como argumento: </font></font><br><br><pre> <code class="java hljs">executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A()); executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B()); executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependiendo de qu√© objeto de clase se pase como argumento, se llamar√° a un m√©todo que pertenezca a esta clase. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La palabra clave abstract le permite excluir el cuerpo del m√©todo (hacerlo abstracto, en t√©rminos de OOP). </font><font style="vertical-align: inherit;">De hecho, le estamos diciendo al compilador que este m√©todo debe ser anulado en las clases derivadas de √©l. </font><font style="vertical-align: inherit;">Si este no es el caso, se produce un error de compilaci√≥n. </font><font style="vertical-align: inherit;">Una clase que contiene al menos un m√©todo abstracto tambi√©n se llama resumen. </font><font style="vertical-align: inherit;">El compilador requiere marcar tales clases tambi√©n con la palabra clave abstract.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estructura del proyecto Java </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, todos los archivos fuente tienen la extensi√≥n * .java. </font><font style="vertical-align: inherit;">Faltan los archivos de encabezado * .h y los prototipos de funciones o clases. </font><font style="vertical-align: inherit;">Cada archivo fuente Java debe contener al menos una clase. </font><font style="vertical-align: inherit;">El nombre de la clase se acostumbra a escribir, comenzando con una letra may√∫scula. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Varios archivos con c√≥digo fuente se pueden combinar en un paquete. </font><font style="vertical-align: inherit;">Para hacer esto, se deben cumplir las siguientes condiciones:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los archivos con c√≥digo fuente deben estar en el mismo directorio en el sistema de archivos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El nombre de este directorio debe coincidir con el nombre del paquete. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al comienzo de cada archivo fuente, se debe indicar el paquete al que pertenece este archivo, por ejemplo: </font></font></li></ol><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.company.pkg;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para garantizar la unicidad de los nombres de paquetes dentro del mundo, se propone utilizar el nombre de dominio de la empresa "invertido". </font><font style="vertical-align: inherit;">Sin embargo, esto no es un requisito y cualquier nombre puede usarse en el proyecto local. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n se recomienda que especifique nombres de paquete en min√∫sculas. </font><font style="vertical-align: inherit;">Para que puedan distinguirse f√°cilmente de los nombres de clase.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ocultamiento de la implementaci√≥n. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro aspecto de la encapsulaci√≥n es la separaci√≥n de la interfaz y la implementaci√≥n. Si la interfaz es accesible para las partes externas del programa (externas al m√≥dulo o clase), entonces la implementaci√≥n est√° oculta. En la literatura, a menudo se dibuja una analog√≠a de caja negra cuando la implementaci√≥n interna "no es visible" desde el exterior, pero lo que se introduce en la entrada de la caja y lo que da es "visible". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En C, las implementaciones de ocultaci√≥n se realizan dentro de un m√≥dulo, marcando funciones que no deber√≠an ser visibles desde el exterior con la palabra clave est√°tica. Los prototipos de las funciones que componen la interfaz del m√≥dulo se colocan en el archivo de encabezado. Un m√≥dulo en C significa un par: un archivo fuente con la extensi√≥n * .c y un encabezado con la extensi√≥n * .h.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java tambi√©n tiene la palabra clave est√°tica, pero no afecta la "visibilidad" del m√©todo o campo desde el exterior. </font><font style="vertical-align: inherit;">Para controlar la "visibilidad" hay 3 modificadores de acceso: privado, protegido, p√∫blico. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los campos y m√©todos de una clase marcada como privada solo est√°n disponibles dentro de ella. </font><font style="vertical-align: inherit;">Los campos y m√©todos protegidos tambi√©n son accesibles para los descendientes de clase. </font><font style="vertical-align: inherit;">El modificador p√∫blico significa que el elemento marcado es accesible desde fuera de la clase, es decir, es parte de la interfaz. </font><font style="vertical-align: inherit;">Tambi√©n es posible que no haya un modificador, en este caso el acceso al elemento de clase est√° limitado por el paquete en el que se encuentra la clase. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se recomienda que al escribir una clase, inicialmente marque todos los campos de la clase como privados y extienda los derechos de acceso seg√∫n sea necesario.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√©todo de sobrecarga </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una de las caracter√≠sticas molestas de la biblioteca est√°ndar de C es la presencia de todo un zool√≥gico de funciones que realizan esencialmente lo mismo, pero difieren en el tipo de argumento, por ejemplo: fabs (), fabsf (), fabsl () - funciones para obtener el valor absoluto para double, float y long tipos dobles respectivamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java (as√≠ como C ++) admite un mecanismo de sobrecarga de m√©todos: puede haber varios m√©todos dentro de una clase con un nombre completamente id√©ntico, pero que difieren en tipo y n√∫mero de argumentos. </font><font style="vertical-align: inherit;">Por el n√∫mero de argumentos y su tipo, el compilador elegir√° la versi√≥n necesaria del m√©todo en s√≠, es muy conveniente y mejora la legibilidad del programa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, a diferencia de C ++, los operadores no pueden sobrecargarse. </font><font style="vertical-align: inherit;">La excepci√≥n son los operadores "+" y "+ =", que inicialmente est√°n sobrecargados para las cadenas de cadenas.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caracteres y cadenas en Java </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En C, debe trabajar con cadenas de terminal nulo representadas por punteros al primer car√°cter: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str; <span class="hljs-comment"><span class="hljs-comment">//  ASCII  wchar_t *strw; //   "" </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dichas l√≠neas deben terminar con un car√°cter nulo. </font><font style="vertical-align: inherit;">Si se "borra" accidentalmente, una cadena se considerar√° una secuencia de bytes en la memoria hasta el primer car√°cter nulo. </font><font style="vertical-align: inherit;">Es decir, si otras variables del programa se colocan en la memoria despu√©s de la l√≠nea, luego de modificar una l√≠nea tan da√±ada, sus valores pueden (y muy probablemente se distorsionar√°n). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, un programador en C no est√° obligado a usar cadenas cl√°sicas de terminal nulo, sino que aplica una implementaci√≥n de un tercero, pero aqu√≠ debe tenerse en cuenta que todas las funciones de la biblioteca est√°ndar requieren cadenas de terminal nulo como argumentos. </font><font style="vertical-align: inherit;">Adem√°s, el est√°ndar C no define la codificaci√≥n utilizada, este punto tambi√©n debe ser controlado por el programador.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, el tipo de caracteres primitivo (as√≠ como el contenedor de caracteres, sobre los siguientes contenedores) representan un solo car√°cter de acuerdo con el est√°ndar Unicode. Se utiliza la codificaci√≥n UTF-16, respectivamente, un car√°cter ocupa 2 bytes en la memoria, lo que le permite codificar casi todos los caracteres de los idiomas utilizados actualmente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los caracteres se pueden especificar por su Unicode:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch1 = <span class="hljs-string"><span class="hljs-string">'\u20BD'</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el Unicode de un personaje excede el m√°ximo de 216 para char, entonces dicho personaje debe estar representado por int. En la cadena, ocupar√° 2 caracteres de 16 bits, pero de nuevo, los caracteres con un c√≥digo superior a 216 se usan extremadamente raramente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las cadenas Java son implementadas por la clase String incorporada y almacenan caracteres char de 16 bits. La clase String contiene todo o casi todo lo que se requiere para trabajar con cadenas. No hay necesidad de pensar en el hecho de que la l√≠nea necesariamente debe terminar con cero, aqu√≠ es imposible "borrar" imperceptiblemente este car√°cter de terminaci√≥n cero o acceder a la memoria m√°s all√° de la l√≠nea. En general, cuando trabaja con cadenas en Java, el programador no piensa en c√≥mo se almacena la cadena en la memoria.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como se mencion√≥ anteriormente, Java no permite la sobrecarga del operador (como en C ++), sin embargo, la clase String es una excepci√≥n, solo que los operadores de combinaci√≥n de l√≠neas "+" y "+ =" se sobrecargan inicialmente. </font></font><br><br><pre> <code class="java hljs">String str1 = <span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> + <span class="hljs-string"><span class="hljs-string">"World!"</span></span>; String str2 = <span class="hljs-string"><span class="hljs-string">"Hello, "</span></span>; str2 += <span class="hljs-string"><span class="hljs-string">"World!"</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cabe destacar que las cadenas en Java son inmutables: una vez creadas, no permiten su cambio. </font><font style="vertical-align: inherit;">Cuando intentamos cambiar la l√≠nea, por ejemplo, as√≠:</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; str.toUpperCase(); System.out.println(str); <span class="hljs-comment"><span class="hljs-comment">//   "Hello, World!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces la cadena original en realidad no cambia. </font><font style="vertical-align: inherit;">En cambio, se crea una copia modificada de la cadena original, que a su vez tambi√©n es inmutable:</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; String str2 = str.toUpperCase(); System.out.println(str2); <span class="hljs-comment"><span class="hljs-comment">//   "HELLO, WORLD!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, cada cambio de una cadena en realidad resulta en la creaci√≥n de un nuevo objeto (de hecho, en casos de fusi√≥n de cadenas, el compilador puede optimizar el c√≥digo y usar la clase StringBuilder, que se discutir√° m√°s adelante). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sucede que el programa a menudo necesita cambiar la misma l√≠nea. </font><font style="vertical-align: inherit;">En tales casos, para optimizar la velocidad del programa y el consumo de memoria, puede evitar la creaci√≥n de nuevos objetos de fila. </font><font style="vertical-align: inherit;">Para estos fines, se debe usar la clase StringBuilder:</font></font><br><br><pre> <code class="java hljs">String sourceString = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; StringBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(sourceString); builder.setCharAt(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); builder.setCharAt(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); builder.append(<span class="hljs-string"><span class="hljs-string">"!!"</span></span>); String changedString = builder.toString(); System.out.println(changedString); <span class="hljs-comment"><span class="hljs-comment">//   "Hell0, W0rld!!!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por separado, vale la pena mencionar la comparaci√≥n de cadenas. </font><font style="vertical-align: inherit;">Un error t√≠pico de un programador Java novato es comparar cadenas usando el operador "==":</font></font><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    "Yes" // ! if (usersInput == "Yes") { //    }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dicho c√≥digo no contiene formalmente errores en la etapa de compilaci√≥n o errores de tiempo de ejecuci√≥n, pero funciona de manera diferente de lo que cabr√≠a esperar. </font><font style="vertical-align: inherit;">Dado que todos los objetos y cadenas, incluso en Java, est√°n representados por enlaces, la comparaci√≥n con el operador "==" proporciona una comparaci√≥n de enlaces, no valores de objetos. </font><font style="vertical-align: inherit;">Es decir, el resultado ser√° verdadero solo si 2 enlaces realmente se refieren a la misma l√≠nea. </font><font style="vertical-align: inherit;">Si las cadenas son objetos diferentes en la memoria, y necesita comparar sus contenidos, entonces necesita usar el m√©todo equals ():</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (usersInput.equals(<span class="hljs-string"><span class="hljs-string">"Yes"</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lo m√°s sorprendente es que, en algunos casos, la comparaci√≥n con el operador "==" funciona correctamente: </font></font><br><br><pre> <code class="java hljs">String someString = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>, anotherString = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   "true": System.out.println(someString == anotherString);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto se debe a que, en realidad, someString y anotherString se refieren al mismo objeto en la memoria. </font><font style="vertical-align: inherit;">El compilador coloca los mismos literales de cadena en el conjunto de cadenas: se produce el llamado internamiento. </font><font style="vertical-align: inherit;">Luego, cada vez que aparece el mismo literal de cadena en el programa, se utiliza un enlace a la cadena desde el grupo. </font><font style="vertical-align: inherit;">El internamiento de cadenas es precisamente posible debido a la propiedad de inmutabilidad de las cadenas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si bien la comparaci√≥n del contenido de las cadenas solo est√° permitida por el m√©todo equals (), en Java es posible usar cadenas correctamente en construcciones de may√∫sculas y min√∫sculas (comenzando con Java 7):</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(); <span class="hljs-comment"><span class="hljs-comment">// ... switch (str) { case "string_value_1": // ... break; case "string_value_2": // ... break; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curiosamente, cualquier objeto Java se puede convertir en una cadena. </font><font style="vertical-align: inherit;">El m√©todo toString () correspondiente se define en la clase base para todas las clases de la clase Object.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enfoque de manejo de errores </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando programe en C, puede encontrar el siguiente enfoque de manejo de errores. Cada funci√≥n de una biblioteca devuelve un tipo int. Si la funci√≥n es exitosa, entonces este resultado es 0. Si el resultado no es cero, esto indica un error. Muy a menudo, el c√≥digo de error se pasa a trav√©s del valor devuelto por la funci√≥n. Dado que la funci√≥n solo puede devolver un valor y ya est√° ocupada por el c√≥digo de error, el resultado real de la funci√≥n debe devolverse a trav√©s del argumento como un puntero, por ejemplo, as√≠:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data **result, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> errorCode; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorCode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por cierto, este es uno de los casos cuando en un programa en C se hace necesario usar un puntero a un puntero. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A veces usan un enfoque diferente. La funci√≥n no devuelve un c√≥digo de error, sino directamente el resultado de su ejecuci√≥n, generalmente en forma de puntero. Una situaci√≥n de error se indica con un puntero nulo. Luego, la biblioteca generalmente contiene una funci√≥n separada que devuelve el c√≥digo del √∫ltimo error:</font></font><br><br><pre> <code class="java hljs">struct Data* function(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *arg); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLastError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De una forma u otra, cuando se programa en C, el c√≥digo que hace el trabajo "√∫til" y el c√≥digo responsable de manejar los errores se entrelazan, lo que obviamente no hace que el programa sea f√°cil de leer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, si lo desea, puede usar los enfoques descritos anteriormente, pero aqu√≠ puede aplicar una forma completamente diferente de manejar los errores: manejo de excepciones (sin embargo, como en C ++). La ventaja del manejo de excepciones es que, en este caso, el c√≥digo "√∫til" y el c√≥digo responsable del manejo de errores y contingencias est√°n separados l√≥gicamente entre s√≠. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto se logra utilizando construcciones try-catch: el c√≥digo "√∫til" se coloca en la secci√≥n try, y el c√≥digo de manejo de errores se coloca en la secci√≥n catch.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//       try (FileReader reader = new FileReader("path\\to\\file.txt")) { //    -   . while (reader.read() != -1){ // ... } } catch (IOException ex) { //     }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay situaciones en las que no es posible procesar correctamente el error en el lugar de su aparici√≥n. </font><font style="vertical-align: inherit;">En tales casos, se coloca una indicaci√≥n en la firma del m√©todo de que el m√©todo puede causar este tipo de excepci√≥n:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora, la llamada a este m√©todo debe estar necesariamente enmarcada en un bloque try-catch, o el m√©todo de llamada tambi√©n debe estar marcado para que pueda lanzar esta excepci√≥n. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Falta de preprocesador </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No importa cu√°n conveniente sea el preprocesador familiar para los programadores de C / C ++, est√° ausente en el lenguaje Java. </font><font style="vertical-align: inherit;">Los desarrolladores de Java probablemente decidieron que se usa solo para garantizar la portabilidad de los programas, y dado que Java se ejecuta en todas partes (casi), no se necesita un preprocesador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede compensar la falta de un preprocesador utilizando un campo de indicador est√°tico y verificar su valor en el programa, cuando sea necesario. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si estamos hablando de la organizaci√≥n de las pruebas, entonces es posible usar anotaciones junto con la reflexi√≥n (reflexi√≥n).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Una matriz tambi√©n es un objeto. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando se trabaja con matrices en C, la salida del √≠ndice m√°s all√° de los l√≠mites de la matriz es un error muy insidioso. </font><font style="vertical-align: inherit;">El compilador no lo informar√° de ninguna manera, y durante la ejecuci√≥n, el programa no se detendr√° con el mensaje correspondiente:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> array[<span class="hljs-number"><span class="hljs-number">5</span></span>]; array[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-number"><span class="hljs-number">666</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo m√°s probable es que el programa contin√∫e la ejecuci√≥n, pero el valor de la variable que se encuentra despu√©s de la matriz de matriz en el ejemplo anterior se distorsionar√°. La depuraci√≥n de este tipo de error puede no ser f√°cil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, el programador est√° protegido de este tipo de errores dif√≠ciles de diagnosticar. Cuando intenta ir m√°s all√° de los l√≠mites de la matriz, se genera una excepci√≥n ArrayIndexOutOfBoundsException. Si la captura de excepci√≥n no se program√≥ utilizando la construcci√≥n try-catch, el programa se bloquea y se env√≠a un mensaje correspondiente al flujo de error est√°ndar que indica el archivo con el c√≥digo fuente y el n√∫mero de l√≠nea donde se super√≥ la matriz. Es decir, el diagn√≥stico de tales errores se convierte en un asunto trivial.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este comportamiento del programa Java es posible porque la matriz en Java est√° representada por un objeto. </font><font style="vertical-align: inherit;">No se puede cambiar el tama√±o de la matriz Java; su tama√±o est√° codificado en el momento en que se asigna la memoria. </font><font style="vertical-align: inherit;">En tiempo de ejecuci√≥n, obtener el tama√±o de la matriz es tan f√°cil como desgranar peras:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arraySize = array.length; <span class="hljs-comment"><span class="hljs-comment">// 10</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si hablamos de matrices multidimensionales, entonces, en comparaci√≥n con el lenguaje C, Java ofrece una oportunidad interesante para organizar matrices "en escalera". </font><font style="vertical-align: inherit;">Para el caso de una matriz bidimensional, el tama√±o de cada fila individual puede diferir del resto:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>][]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.length; i++) { array[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como en C, los elementos de la matriz se encuentran en la memoria uno por uno, por lo que el acceso a la matriz se considera el m√°s eficiente. </font><font style="vertical-align: inherit;">Si necesita realizar operaciones de inserci√≥n / eliminaci√≥n de elementos, o crear estructuras de datos m√°s complejas, debe usar colecciones, como un conjunto (Conjunto), una lista (Lista), un mapa (Mapa). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debido a la falta de punteros y la incapacidad de incrementar los enlaces, el acceso a los elementos de la matriz es posible mediante √≠ndices.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colecciones </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A menudo, la funcionalidad de las matrices no es suficiente, entonces debe usar estructuras de datos din√°micas. Dado que la biblioteca C est√°ndar no contiene una implementaci√≥n lista de estructuras de datos din√°micas, debe usar la implementaci√≥n en c√≥digos fuente o en forma de bibliotecas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A diferencia de C, la biblioteca est√°ndar de Java contiene un amplio conjunto de implementaciones de estructuras de datos din√°micos o colecciones, expresadas en t√©rminos de Java. Todas las colecciones se dividen en 3 grandes clases: listas, conjuntos y mapas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las listas (matrices din√°micas) le permiten agregar / eliminar elementos. Muchos no aseguran el orden de los elementos agregados, pero garantizan que no haya elementos duplicados. Las tarjetas o matrices asociativas operan con pares clave-valor, y el valor clave es √∫nico: no puede haber 2 pares con las mismas claves en la tarjeta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para listas, conjuntos y mapas, hay muchas implementaciones, cada una de las cuales est√° optimizada para una operaci√≥n espec√≠fica. Por ejemplo, las listas son implementadas por las clases ArrayList y LinkedList, con ArrayList que proporciona un mejor rendimiento al acceder a un elemento arbitrario, y LinkedList es m√°s eficiente al insertar / eliminar elementos en el medio de la lista.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo los objetos Java completos pueden almacenarse en colecciones (de hecho, referencias a objetos), por lo tanto, es imposible crear una colecci√≥n de primitivas directamente (int, char, byte, etc.). </font><font style="vertical-align: inherit;">En este caso, se deben usar las clases de contenedor apropiadas:</font></font><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Primitivo </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Clase de envoltura </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> byte </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Byte </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> corta </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Corto </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> char </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Personaje </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> int </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entero </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> largo </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Largo </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flotar </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flotador </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> doble </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Doble </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> booleano </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Booleano </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afortunadamente, cuando se programa en Java, no es necesario seguir la coincidencia exacta del tipo primitivo y su "envoltorio". </font><font style="vertical-align: inherit;">Si el m√©todo recibe un argumento, por ejemplo, de tipo Integer, se le puede pasar el tipo int. </font><font style="vertical-align: inherit;">Y viceversa, donde se requiere el tipo int, puede usar Integer de forma segura. </font><font style="vertical-align: inherit;">Esto fue posible gracias al mecanismo incorporado de Java para empacar / desempaquetar primitivas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De los momentos desagradables, debe mencionarse que la biblioteca est√°ndar de Java contiene clases de colecci√≥n antiguas que se implementaron sin √©xito en las primeras versiones de Java y que no deber√≠an usarse en nuevos programas. </font><font style="vertical-align: inherit;">Estas son las clases Enumeraci√≥n, Vector, Pila, Diccionario, Tabla hash, Propiedades.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generalizaciones </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las colecciones se usan com√∫nmente como tipos de datos gen√©ricos. </font><font style="vertical-align: inherit;">La esencia de las generalizaciones en este caso es que especificamos el tipo principal de la colecci√≥n, por ejemplo, ArrayList, y entre par√©ntesis angulares especificamos el tipo de par√°metro, que en este caso determina el tipo de elementos almacenados en la lista:</font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esto permite que el compilador rastree el intento de agregar un objeto de un tipo que no sea el par√°metro de tipo especificado: </font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  ! list.add("First");</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es muy importante que el par√°metro tipo se borre durante la ejecuci√≥n del programa, y ‚Äã‚Äãno hay diferencia entre, por ejemplo, un objeto de la clase </font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ArrayList &lt;Integer&gt; </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y objeto de clase </font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ArrayList &lt;String&gt;. </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como resultado, no hay forma de averiguar el tipo de elementos de colecci√≥n durante la ejecuci√≥n del programa: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsInteger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ! if (list instanceof List&lt;Integer&gt;) { return true; } return false; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Una soluci√≥n parcial puede ser el siguiente enfoque: tome el primer elemento de la colecci√≥n y determine su tipo: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsInteger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!list.isEmpty() &amp;&amp; list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Integer) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero este enfoque no funcionar√° si la lista est√° vac√≠a. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A este respecto, las generalizaciones de Java son significativamente inferiores a las generalizaciones de C ++. </font><font style="vertical-align: inherit;">Las generalizaciones de Java en realidad sirven para "cortar" algunos de los posibles errores en la etapa de compilaci√≥n.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iterar sobre todos los elementos de una matriz o colecci√≥n </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al programar en C, a menudo debe iterar sobre todos los elementos de la matriz: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SIZE; i++) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cometer un error aqu√≠ es m√°s simple, simplemente especifique el tama√±o incorrecto de la matriz SIZE o coloque "&lt;=" en lugar de "&lt;". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, adem√°s de la forma "habitual" de la instrucci√≥n for, hay una forma de iterar sobre todos los elementos de una matriz o colecci√≥n (a menudo llamada foreach en otros idiomas):</font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// ... for (Integer i : list) { // ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqu√≠ se garantiza que clasificaremos todos los elementos de la lista, se eliminan los errores inherentes a la forma "habitual" de la declaraci√≥n for. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colecciones varias </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dado que todos los objetos se heredan del Objeto ra√≠z, Java tiene una oportunidad interesante para crear listas con varios tipos reales de elementos: </font></font><br><br><pre> <code class="java hljs">List list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"First"</span></span>)); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">2</span></span>)); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Double(<span class="hljs-number"><span class="hljs-number">3.0</span></span>));         <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object o : list) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String) { <span class="hljs-comment"><span class="hljs-comment">// ... } else if (o instanceof Integer) { // ... } else if (o instanceof Double) { // ... } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Traslados </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparando C / C ++ y Java, es imposible no darse cuenta de la cantidad de enumeraciones funcionales que se implementan en Java. </font><font style="vertical-align: inherit;">Aqu√≠ la enumeraci√≥n es una clase completa, y los elementos de enumeraci√≥n son objetos de esta clase. </font><font style="vertical-align: inherit;">Esto permite que un elemento de enumeraci√≥n establezca varios campos de cualquier tipo en correspondencia:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Colors { <span class="hljs-comment"><span class="hljs-comment">//     -   . RED ((byte)0xFF, (byte)0x00, (byte)0x00), GREEN ((byte)0x00, (byte)0xFF, (byte)0x00), BLUE ((byte)0x00, (byte)0x00, (byte)0xFF), WHITE ((byte)0xFF, (byte)0xFF, (byte)0xFF), BLACK ((byte)0x00, (byte)0x00, (byte)0x00); //  . private byte r, g, b; //  . private Colors(byte r, byte g, byte b) { this.r = r; this.g = g; this.b = b; } //  . public double getLuma() { return 0.2126 * r + 0.7152 * g + 0.0722 * b; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como clase completa, una enumeraci√≥n puede tener m√©todos y, utilizando un constructor privado, puede establecer los valores de campo de elementos de enumeraci√≥n individuales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay una oportunidad regular para obtener una representaci√≥n de cadena de un elemento de enumeraci√≥n, un n√∫mero de serie y tambi√©n una matriz de todos los elementos:</font></font><br><br><pre> <code class="java hljs">Colors color = Colors.BLACK; String str = color.toString(); <span class="hljs-comment"><span class="hljs-comment">// "BLACK" int i = color.ordinal(); // 4 Colors[] array = Colors.values(); // [RED, GREEN, BLUE, WHITE, BLACK]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y viceversa: mediante la representaci√≥n de cadena, puede obtener un elemento de enumeraci√≥n y tambi√©n llamar a sus m√©todos: </font></font><br><br><pre> <code class="java hljs">Colors red = Colors.valueOf(<span class="hljs-string"><span class="hljs-string">"RED"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Colors.RED Double redLuma = red.getLuma(); // 0.2126 * 255</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Naturalmente, las enumeraciones se pueden usar en construcciones de may√∫sculas y min√∫sculas. </font></font><br><br><h2>  Conclusiones </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, los lenguajes C y Java est√°n dise√±ados para resolver problemas completamente diferentes. Pero, si comparamos el proceso de desarrollo de software en estos dos idiomas, entonces, de acuerdo con las impresiones subjetivas del autor, el lenguaje Java supera significativamente C en la conveniencia y velocidad de los programas de escritura. El entorno de desarrollo (IDE) desempe√±a un papel importante para proporcionar comodidad. El autor trabaj√≥ con IntelliJ IDEA IDE. Al programar en Java, no tiene que "temer" constantemente para cometer un error: a menudo, el entorno de desarrollo le dir√° lo que debe arreglarse y, a veces, lo har√° por usted. Si se produjo un error de tiempo de ejecuci√≥n, el tipo de error y el lugar de su aparici√≥n en el c√≥digo fuente siempre se indican en el registro; la lucha contra tales errores se convierte en un asunto trivial. Un programador en C no necesita hacer esfuerzos inhumanos para cambiar a Java, y todo porque la sintaxis del lenguaje ha cambiado ligeramente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si esta experiencia ser√° interesante para los lectores, en el pr√≥ximo art√≠culo hablaremos sobre la experiencia de usar el mecanismo JNI (ejecutar c√≥digo nativo C / C ++ desde una aplicaci√≥n Java). </font><font style="vertical-align: inherit;">El mecanismo JNI es indispensable cuando desea controlar la resoluci√≥n de la pantalla, el m√≥dulo Bluetooth y, en otros casos, cuando las capacidades de los servicios y administradores de Android no son suficientes.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es412775/">https://habr.com/ru/post/es412775/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es412763/index.html">Uso de la placa de recarga Firefly-RK3288 con el SoC RockChip RK3288 Sensor t√©rmico digital Microchip I2C - MCP9808</a></li>
<li><a href="../es412765/index.html">Introducci√≥n al nuevo sistema de tarjeta de mosaico Unity</a></li>
<li><a href="../es412767/index.html">CMG impacto 2016 revisi√≥n de la conferencia</a></li>
<li><a href="../es412769/index.html">Hice PWA y lo puse en tres tiendas de aplicaciones. Y aqu√≠ est√° lo que descubr√≠.</a></li>
<li><a href="../es412773/index.html">Astro-aeroespacial de Minsk</a></li>
<li><a href="../es412777/index.html">Construcci√≥n de columnas de obras maestras del mundo: QUAD 11L: los mejores "estantes" de las dos mil</a></li>
<li><a href="../es412779/index.html">SSLH: Ocultar SSH / HTTPS / OpenVPN / Telegram detr√°s de un solo puerto 443</a></li>
<li><a href="../es412781/index.html">El fan√°tico de NES ha permitido lanzar juegos de SNES en la consola</a></li>
<li><a href="../es412783/index.html">Instalaci√≥n del proxy MTProto Telegram desde la fuente en Centos 7</a></li>
<li><a href="../es412785/index.html">Master of Management y Freelancer. La historia en tres partes.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>