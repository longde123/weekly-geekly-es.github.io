<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∑ üë©üèª‚Äçü§ù‚Äçüë®üèø üëü OOP est√° morto, viva OOP üéç üí™ üëá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fontes de inspira√ß√£o 
 Este post surgiu gra√ßas a uma publica√ß√£o recente de Aras Prantskevichus sobre um relat√≥rio destinado a programadores juniores. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OOP est√° morto, viva OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441174/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png" alt="imagem"></div><br><h1>  Fontes de inspira√ß√£o </h1><br>  Este post surgiu gra√ßas a uma publica√ß√£o recente de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">Aras Prantskevichus</a> sobre um relat√≥rio destinado a programadores juniores.  Ele fala sobre como se adaptar √†s novas arquiteturas do ECS.  Aras segue o padr√£o usual ( <em>explica√ß√£o abaixo</em> ): mostra exemplos do terr√≠vel c√≥digo de POO e depois demonstra que o modelo relacional ( <em>mas o chama de ‚ÄúECS‚Äù em vez de relacional</em> ) √© uma √≥tima alternativa.  De maneira alguma eu critico Aras - sou um grande f√£ de seu trabalho e o elogio por sua excelente apresenta√ß√£o!  Escolhi a apresenta√ß√£o dele em vez de centenas de outros posts sobre ECS na Internet, porque ele fez esfor√ßos extras e publicou um reposit√≥rio git para estudo em paralelo com a apresenta√ß√£o.  Ele cont√©m um pequeno ‚Äújogo‚Äù simples, usado como exemplo da sele√ß√£o de diferentes solu√ß√µes arquitet√¥nicas.  Este pequeno projeto me permitiu demonstrar meus coment√°rios sobre um material espec√≠fico, ent√£o obrigado, Aras! <br><br>  Os slides Aras est√£o dispon√≠veis aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">http://aras-p.info/texts/files/2018Academy - ECS-DoD.pdf</a> , e o c√≥digo est√° no github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">https://github.com/aras-p/dod-playground</a> . <br><br>  N√£o analisarei (ainda?) A arquitetura do ECS resultante deste relat√≥rio, mas focarei no c√≥digo de "POO ruim" (semelhante ao truque) desde o in√≠cio.  Mostrarei como realmente ficaria se todas as viola√ß√µes dos princ√≠pios do OOD (design orientado a objetos, design orientado a objetos) fossem corrigidas corretamente. <br><br>  <strong>Spoiler: eliminar todas as viola√ß√µes de OOD leva a melhorias de desempenho semelhantes √†s convers√µes de Aras para ECS, tamb√©m usa menos RAM e requer menos linhas de c√≥digo que a vers√£o do ECS!</strong> <br><br>  <em>TL; DR: Antes de concluir que o OOP √© um saco e as unidades do ECS, fa√ßa uma pausa e examine o OOD (para saber como usar o OOP corretamente) e tamb√©m entenda o modelo relacional (para saber como aplicar o ECS corretamente).</em> <br><a name="habracut"></a><br>  Venho participando de muitas discuss√µes sobre o ECS no f√≥rum h√° muito tempo, em parte porque acho que esse modelo n√£o existe como um termo separado ( <em>spoiler: essa √© apenas uma vers√£o ad-hoc do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">modelo relacional</a></em> ), mas tamb√©m porque quase <em>todas as</em> postagens, apresenta√ß√µes ou artigos que promovem um padr√£o de ECS seguem a seguinte estrutura: <br><br><ol><li>  Mostre um exemplo de c√≥digo OOP terr√≠vel, cuja implementa√ß√£o apresenta falhas terr√≠veis devido ao uso excessivo de heran√ßa (o que significa que essa implementa√ß√£o viola muitos princ√≠pios do OOD). <br></li><li>  Mostrar que a composi√ß√£o √© uma solu√ß√£o melhor que a heran√ßa (e sem mencionar que o OOD realmente nos d√° a mesma li√ß√£o). <br></li><li>  Mostre que o modelo relacional √© √≥timo para jogos (mas chame de "ECS"). </li></ol><br>  Essa estrutura me enfurece porque: <strong>(A)</strong> esse √© um truque "cheio" ... compara macio a quente (c√≥digo ruim e bom c√≥digo) ... e isso √© injusto, mesmo se feito sem inten√ß√£o e n√£o √© necess√°rio para demonstrar que a nova arquitetura √© boa;  e, mais importante: <strong>(B)</strong> tem um efeito colateral - essa abordagem suprime o conhecimento e desmotiva inadvertidamente os leitores do conhecimento de estudos realizados por meio s√©culo.  Eles come√ßaram a escrever sobre o modelo relacional na d√©cada de 1960.  Ao longo dos anos 70 e 80, esse modelo melhorou significativamente.  Os iniciantes geralmente t√™m perguntas como "em <em>que classe voc√™ deseja colocar esses dados?</em> ". E em resposta, muitas vezes, s√£o informados de algo vago, como " <em>voc√™ s√≥ precisa ganhar experi√™ncia e aprender a entender interiormente</em> " ... mas nos anos 70 essa pergunta era ativamente estudado e, no caso geral, foi deduzida uma resposta formal;  isso √© chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">normaliza√ß√£o do banco de dados</a> .  Descartando a pesquisa existente e chamando o ECS de uma solu√ß√£o completamente nova e moderna, voc√™ esconde esse conhecimento dos iniciantes. <br><br>  Os fundamentos da programa√ß√£o orientada a objetos foram estabelecidos h√° muito tempo, se n√£o antes ( <em>esse estilo come√ßou a ser explorado no trabalho da d√©cada de 1950</em> )!  No entanto, foi nos anos 90 que a orienta√ß√£o a objetos se tornou moda, viral e rapidamente se transformou no paradigma de programa√ß√£o dominante.  Ocorreu a explos√£o de popularidade de muitas novas linguagens OO, incluindo Java e o C ++ ( <em>vers√£o padronizada</em> ).  No entanto, como isso se deveu ao hype, todos <em>precisavam</em> conhecer esse conceito de alto perfil para escrever em seu curr√≠culo, mas apenas alguns realmente se interessaram.  Essas novas linguagens criaram as palavras-chave - <em>classe</em> , <em>virtual</em> , <em>extende</em> , <em>implementa</em> - dentre muitos recursos do OO, e acredito que √© por isso que naquele momento o OO estava dividido em duas entidades separadas que vivem suas pr√≥prias vidas. <br><br>  Vou me referir ao uso desses recursos de linguagem inspirados em OO como " <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">OOP</a></strong> " e ao uso de t√©cnicas de design / arquitetura inspiradas em OO " <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">OOD</a></strong> ".  Tudo rapidamente pegou o POO.  As institui√ß√µes educacionais t√™m cursos de OO que preparam novos programadores de OOP ... no entanto, o conhecimento do OOD fica para tr√°s. <br><br>  Acredito que o c√≥digo que usa os recursos de linguagem do OOP, mas n√£o segue os princ√≠pios do design do OOD, <strong>n√£o</strong> √© <strong>um c√≥digo OO</strong> .  A maioria das cr√≠ticas contra o OOP usa, por exemplo, c√≥digo estripado, que n√£o √© realmente um c√≥digo OO. <br><br>  O c√≥digo OOP tem uma reputa√ß√£o muito ruim e, principalmente, porque a maioria do c√≥digo OOP n√£o segue os princ√≠pios do OOD e, portanto, n√£o √© um c√≥digo OO "verdadeiro". <br><br><h1>  Antecedentes </h1><br>  Como dito acima, a d√©cada de 90 se tornou o pico da moda OO, e foi nessa √©poca que a ‚ÄúOOP ruim‚Äù foi provavelmente a pior.  Se voc√™ estudou POO naquele momento, provavelmente aprendeu sobre os ‚Äúquatro pilares da POO‚Äù: <br><br><ul><li>  Abstra√ß√£o </li><li>  Encapsulamento </li><li>  Polimorfismo </li><li>  Heran√ßa </li></ul><br>  Prefiro cham√°-los n√£o de quatro pilares, mas de "quatro ferramentas de POO".  Essas s√£o ferramentas que <em><strong>voc√™ pode</strong></em> usar para resolver problemas.  No entanto, n√£o basta apenas descobrir como a ferramenta funciona, voc√™ precisa saber quando us√°-la ... Por parte dos professores, √© irrespons√°vel ensinar √†s pessoas uma nova ferramenta, sem dizer a eles quando vale a pena us√°-las.  No in√≠cio dos anos 2000, houve resist√™ncia ao uso indevido ativo dessas ferramentas, uma esp√©cie de "segunda onda" do pensamento OOD.  O resultado foi o surgimento das mnem√¥nicas do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">SOLID</a> , que forneceram uma maneira r√°pida de avaliar os pontos fortes da arquitetura.  Deve-se notar que essa sabedoria foi realmente difundida nos anos 90, mas ainda n√£o recebeu um acr√¥nimo legal, que permitiu que eles fossem fixados em cinco princ√≠pios b√°sicos ... <br><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">O princ√≠pio da responsabilidade exclusiva</a></strong> ( <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">princ√≠pio da responsabilidade √∫nica</a></strong> ).  Cada classe deve ter apenas um motivo para a mudan√ßa.  Se a classe "A" tiver duas responsabilidades, ser√° necess√°rio criar a classe "B" e "C" para processar cada uma delas individualmente e, em seguida, criar "A" a partir de "B" e "C". </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">O princ√≠pio de abertura / fechamento</a></strong> ( <b>O</b> pen / princ√≠pio fechado).  O software muda com o tempo ( <em>ou seja, seu suporte √© importante</em> ).  Tente colocar as partes com maior probabilidade de altera√ß√£o nas <em>implementa√ß√µes (</em> <em>ou seja, em classes espec√≠ficas</em> ) e crie <em>interfaces com</em> base nas partes que provavelmente n√£o ser√£o alteradas ( <em>por exemplo, classes base abstratas</em> ). <br></li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">O princ√≠pio da substitui√ß√£o de Barbara Liskov</a></strong> (princ√≠pio da substitui√ß√£o de Iskov).  Cada implementa√ß√£o de uma interface deve 100% atender aos requisitos dessa interface, ou seja,  qualquer algoritmo que trabalha com uma interface deve funcionar com qualquer implementa√ß√£o. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">O princ√≠pio da separa√ß√£o da interface</a></strong> ( <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">princ√≠pio da segrega√ß√£o da interface</a></strong> ).  Torne as interfaces o mais pequenas poss√≠vel, para que cada parte do c√≥digo "conhe√ßa" a menor quantidade de base de c√≥digo, por exemplo, evite depend√™ncias desnecess√°rias.  Essa dica tamb√©m √© boa para C ++, onde os tempos de compila√ß√£o se tornam enormes se voc√™ n√£o a seguir. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">O princ√≠pio da invers√£o de depend√™ncia</a></strong> ( <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">princ√≠pio de invers√£o de depend√™ncia</a></strong> ).  Em vez de duas implementa√ß√µes espec√≠ficas que se comunicam diretamente (e dependem uma da outra), elas geralmente podem ser separadas formalizando sua interface de comunica√ß√£o como uma terceira classe, usada como interface entre elas.  Pode ser uma classe base abstrata que define as chamadas dos m√©todos usados ‚Äã‚Äãentre eles, ou mesmo apenas uma estrutura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">POD</a> que define os dados transferidos entre eles. </li><li>  Outro princ√≠pio n√£o est√° inclu√≠do no acr√¥nimo SOLID, mas tenho certeza de que √© muito importante: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">‚ÄúPreferir composi√ß√£o sobre heran√ßa‚Äù</a></strong> (princ√≠pio de reutiliza√ß√£o de compostos).  A composi√ß√£o <em>√© a escolha certa por padr√£o</em> .  A heran√ßa deve ser deixada para os casos em que √© absolutamente necess√°rio. </li></ul><br>  Ent√£o, temos o SOLID-C (++) <img alt=":)" height="20" src="https://habrastorage.org/getpro/habr/post_images/e8d/c8c/1e8/e8dc8c1e846d52073e8f2a944b2006fa.png" width="20"><br><br>  Abaixo vou me referir a esses princ√≠pios, chamando-os de siglas - SRP, OCP, LSP, ISP, DIP, CRP ... <br><br>  Mais algumas notas: <br><br><ul><li>  No OOD, os conceitos de <em>interfaces</em> e <em>implementa√ß√µes</em> n√£o podem ser vinculados a nenhuma palavra-chave OOP espec√≠fica.  Em C ++, geralmente criamos interfaces com <em>classes base abstratas</em> e <em>fun√ß√µes virtuais</em> e, em seguida, <em>implementa√ß√µes</em> herdam dessas classes base ... mas essa √© apenas uma maneira espec√≠fica de implementar o princ√≠pio da interface.  Em C ++, tamb√©m podemos usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">PIMPL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">ponteiros opacos</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">tipagem de pato</a> , typedef, etc. ... Voc√™ pode criar uma estrutura OOD e implement√°-la em C, na qual n√£o h√° palavras-chave da linguagem OOP!  Portanto, quando falo de <em>interfaces</em> , n√£o quero dizer necessariamente fun√ß√µes <em>virtuais</em> - estou falando do princ√≠pio de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">ocultar a implementa√ß√£o</a> .  As interfaces <em>podem</em> ser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">polim√≥rficas</a> , mas na maioria das vezes elas s√£o!  O polimorfismo √© raramente usado corretamente, mas as interfaces s√£o um conceito fundamental para todos os softwares. <br><ul><li>  Como deixei claro acima, se voc√™ criar uma estrutura POD que simplesmente armazena alguns dados para transmiss√£o de uma classe para outra, essa estrutura ser√° usada como uma <em>interface</em> - essa √© uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">descri√ß√£o</a> formal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">dos dados</a> . <br></li><li>  Mesmo se voc√™ apenas criar uma classe separada com as partes <em>p√∫blica</em> e <em>privada</em> , tudo o que est√° na parte comum √© uma <em>interface</em> e tudo na parte privada √© uma <em>implementa√ß√£o</em> . </li></ul></li><li>  Na verdade, a heran√ßa possui (pelo menos) dois tipos - heran√ßa de interface e heran√ßa de implementa√ß√£o. <br><ul><li>  No C ++, a heran√ßa de interface inclui classes b√°sicas abstratas com fun√ß√µes virtuais puras, PIMPL, typedef condicional.  Em Java, a heran√ßa da interface √© expressa atrav√©s da palavra-chave <em>implementements</em> . </li><li>  No C ++, a heran√ßa de implementa√ß√µes ocorre toda vez que as classes base cont√™m algo diferente de fun√ß√µes virtuais puras.  Em Java, a heran√ßa de implementa√ß√£o √© expressa usando a <em>palavra-chave extends</em> . </li><li>  OOD tem muitas regras para herdar interfaces, mas geralmente vale a pena considerar a heran√ßa de implementa√ß√µes como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">"c√≥digo com uma mordida"</a> ! </li></ul></li></ul><br>  E, finalmente, devo mostrar alguns exemplos do terr√≠vel treinamento em OOP e como ele leva ao c√≥digo incorreto na vida real (e √† m√° reputa√ß√£o do OOP). <br><br><ol><li>  Ao aprender hierarquias / heran√ßa, voc√™ pode ter recebido uma tarefa semelhante: <strong><em>suponha que voc√™ tenha um aplicativo universit√°rio que contenha um diret√≥rio de alunos e funcion√°rios.</em></strong>  <strong><em>Voc√™ pode criar a classe base Person e, em seguida, a classe Student e a classe Staff, herdadas de Person.</em></strong> <br><br>  N√£o n√£o n√£o  Aqui eu vou parar voc√™.  A implica√ß√£o t√°cita do princ√≠pio LSP √© que <em>as hierarquias de classe</em> e os <em>algoritmos que as processam</em> s√£o simbi√≥ticos.  Estas s√£o duas metades de todo o programa.  OOP √© uma extens√£o da programa√ß√£o processual e ainda est√° principalmente associada a esses procedimentos.  Se n√£o soubermos que tipos de algoritmos funcionar√£o com <i>alunos</i> e <em>funcion√°rios</em> ( <em>e quais algoritmos ser√£o simplificados devido ao polimorfismo</em> ), ser√° completamente irrespons√°vel come√ßar a criar a estrutura das hierarquias de classe.  Primeiro voc√™ precisa conhecer os algoritmos <em>e os</em> dados. </li><li>  Quando voc√™ aprendeu hierarquias / heran√ßa, provavelmente recebeu uma tarefa semelhante: <b><i>suponha que voc√™ tenha uma classe de formas.</i></b>  <b><i>Tamb√©m temos quadrados e ret√¢ngulos como subclasses.</i></b>  <b><i>Um quadrado deve ser um ret√¢ngulo ou um ret√¢ngulo um quadrado?</i></b> <br><br>  Este √© realmente um bom exemplo para demonstrar a diferen√ßa entre heran√ßa de implementa√ß√µes e heran√ßa de interfaces. <br><ul><li>  Se voc√™ usar a abordagem de heran√ßa de implementa√ß√£o, desconsidere completamente o LSP e, de um ponto de vista pr√°tico, pense na possibilidade de reutilizar o c√≥digo, usando a heran√ßa como ferramenta. <br><br>  Desse ponto de vista, o seguinte √© perfeitamente l√≥gico: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> Square { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br>  O quadrado tem apenas a largura e o ret√¢ngulo tem a largura + altura, ou seja, expandindo o quadrado com o componente de altura, obtemos um ret√¢ngulo! <br><ul><li>  Como voc√™ deve ter adivinhado, a OOD diz que fazer isso ( <em>provavelmente</em> ) est√° errado.  Eu disse <em>"provavelmente"</em> porque aqui voc√™ pode discutir sobre as caracter√≠sticas impl√≠citas da interface ... tudo bem. <br><br>  Um quadrado sempre tem a mesma altura e largura; portanto, a partir da interface do quadrado, √© perfeitamente verdade supor que a √°rea √© "largura * largura". <br><br>  Herdando de um quadrado, a classe de ret√¢ngulos (de acordo com o LSP) <strong>deve</strong> obedecer √†s regras da interface do quadrado.  Qualquer algoritmo que funcione corretamente para um quadrado tamb√©m deve funcionar corretamente para um ret√¢ngulo. </li><li>  Pegue outro algoritmo: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Square*&gt; shapes; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> area = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s : shapes) area += s-&gt;width * s-&gt;width;</code> </pre> <br>  Funcionar√° corretamente para quadrados (calculando a soma de suas √°reas), mas n√£o funcionar√° para ret√¢ngulos. <br><br>  Portanto, o ret√¢ngulo viola o princ√≠pio LSP. </li></ul></li><li>  Se voc√™ usar a abordagem de heran√ßa da interface, nem Quadrado nem Ret√¢ngulo herdar√£o um do outro.  As interfaces para o quadrado e o ret√¢ngulo s√£o realmente diferentes e uma n√£o √© um superconjunto da outra. <br></li><li>  Portanto, OOD desencoraja o uso da heran√ßa de implementa√ß√£o.  Como mencionado acima, se voc√™ deseja reutilizar o c√≥digo, o OOD diz que a composi√ß√£o √© a escolha certa! <br><ul><li>  Portanto, a vers√£o <i>correta</i> do c√≥digo (ruim) acima para a hierarquia de heran√ßa das implementa√ß√µes do C ++ √© semelhante a esta: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * width; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Square, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * height; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br><ul><li>  "Virtual p√∫blico" em Java significa "implementos".  Usado ao implementar a interface. <br></li><li>  "Privado" permite que voc√™ estenda a classe base sem herdar sua interface - nesse caso, o ret√¢ngulo <b>n√£o</b> √© <b>um</b> quadrado, embora seja herdado. <br></li></ul></li><li>  N√£o recomendo escrever esse c√≥digo, mas se voc√™ quiser usar a heran√ßa de implementa√ß√µes, precisar√° fazer exatamente isso! </li></ul></li></ul></li></ol><br>  TL; DR - sua classe OOP lhe disse como era a heran√ßa.  Sua classe OOD que faltava deveria ter lhe dito para n√£o us√°-la 99% do tempo! <br><br><h1>  Conceitos de entidade / componente </h1><br>  Tendo lidado com os pr√©-requisitos, vamos prosseguir para onde Aras come√ßou - o chamado ponto de partida de uma "OOP t√≠pica". <br><br>  Mas para iniciantes, mais uma adi√ß√£o - Aras chama esse c√≥digo de "OOP tradicional", e eu quero contestar isso.  Esse c√≥digo pode ser t√≠pico para OOP no mundo real, mas, como nos exemplos acima, viola todos os tipos de princ√≠pios b√°sicos de OO, portanto, n√£o deve ser considerado tradicional. <br><br>  <a href="" rel="external nofollow">Iniciarei</a> com o primeiro commit antes que ele come√ßasse a refazer a estrutura para o ECS: <a href="" rel="external nofollow">‚ÄúFa√ßa funcionar novamente no Windows‚Äù 3529f232510c95f53112bbfff87df6bbc6aa1fae</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------- // super simple "component system" class GameObject; class Component; typedef std::vector&lt;Component*&gt; ComponentVector; typedef std::vector&lt;GameObject*&gt; GameObjectVector; // Component base class. Knows about the parent game object, and has some virtual methods. class Component { public: Component() : m_GameObject(nullptr) {} virtual ~Component() {} virtual void Start() {} virtual void Update(double time, float deltaTime) {} const GameObject&amp; GetGameObject() const { return *m_GameObject; } GameObject&amp; GetGameObject() { return *m_GameObject; } void SetGameObject(GameObject&amp; go) { m_GameObject = &amp;go; } bool HasGameObject() const { return m_GameObject != nullptr; } private: GameObject* m_GameObject; }; // Game object class. Has an array of components. class GameObject { public: GameObject(const std::string&amp;&amp; name) : m_Name(name) { } ~GameObject() { // game object owns the components; destroy them when deleting the game object for (auto c : m_Components) delete c; } // get a component of type T, or null if it does not exist on this game object template&lt;typename T&gt; T* GetComponent() { for (auto i : m_Components) { T* c = dynamic_cast&lt;T*&gt;(i); if (c != nullptr) return c; } return nullptr; } // add a new component to this game object void AddComponent(Component* c) { assert(!c-&gt;HasGameObject()); c-&gt;SetGameObject(*this); m_Components.emplace_back(c); } void Start() { for (auto c : m_Components) c-&gt;Start(); } void Update(double time, float deltaTime) { for (auto c : m_Components) c-&gt;Update(time, deltaTime); } private: std::string m_Name; ComponentVector m_Components; }; // The "scene": array of game objects. static GameObjectVector s_Objects; // Finds all components of given type in the whole scene template&lt;typename T&gt; static ComponentVector FindAllComponentsOfType() { ComponentVector res; for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) res.emplace_back(c); } return res; } // Find one component of given type in the scene (returns first found one) template&lt;typename T&gt; static T* FindOfType() { for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) return c; } return nullptr; }</span></span></code> </pre> <br>  Sim, √© dif√≠cil descobrir centenas de linhas de c√≥digo imediatamente, ent√£o vamos come√ßar gradualmente ... Precisamos de outro aspecto dos pr√©-requisitos - era popular o uso de heran√ßa nos jogos dos anos 90 para resolver todos os problemas de reutiliza√ß√£o de c√≥digo.  Voc√™ tinha Entidade, Personagem extens√≠vel, Jogador e monstro extens√≠veis e assim por diante ... Essa √© uma heran√ßa de implementa√ß√µes, como descrevemos anteriormente ( <em>"c√≥digo com um estrangulamento"</em> ), e parece que √© certo come√ßar com ela, mas, como resultado, leva a base de c√≥digo inflex√≠vel.  Porque OOD tem o princ√≠pio de "composi√ß√£o sobre heran√ßa" descrito acima.  Ent√£o, nos anos 2000, o princ√≠pio de ‚Äúcomposi√ß√£o sobre heran√ßa‚Äù se tornou popular, e os desenvolvedores de jogos come√ßaram a escrever um c√≥digo semelhante. <br><br>  O que esse c√≥digo faz?  Bem, n√£o √© bom <img alt=":D" height="20" src="https://habrastorage.org/getpro/habr/post_images/4c3/d02/890/4c3d028909133f97a7a351651c98c08b.png" title=": D" width="20"><br><br>  Em resumo, <strong>esse c√≥digo reimplementa um recurso existente do idioma - composi√ß√£o</strong> como uma biblioteca de tempo de execu√ß√£o, e n√£o como um recurso do idioma.  Voc√™ pode imaginar isso como se o c√≥digo estivesse realmente criando uma nova metalinguagem sobre C ++ e uma m√°quina virtual (VM) para executar essa metalinguagem.  No jogo de demonstra√ß√£o Aras, esse c√≥digo n√£o √© necess√°rio ( <em>iremos remov√™-lo completamente em breve!</em> ) E serve apenas para reduzir o desempenho do jogo em cerca de 10 vezes. <br><br>  Mas o que ele realmente faz?  Esse √© o conceito de "Sistema de propriedade / componente <strong>C</strong> " ( <em>√†s vezes por algum motivo chamado "Sistema de unidade / componente <strong>C</strong> "</em> ), mas √© completamente diferente do conceito de "Sistema de unidade <strong>C /</strong> componente" sistema de componentes "(" sistema de componentes de entidades ") ( <em>que por raz√µes √≥bvias nunca √© chamado de" sistemas de sistemas</em> de componentes de componentes da <em>comunidade</em> ). Formaliza v√°rios princ√≠pios do "CE": <br><br><ul><li>  o jogo ser√° constru√≠do a partir de n√£o ter recursos de "Entidades" ("Entidade") ( <em>neste exemplo chamado</em> GameObjects), que consistem em "componentes" ("Componente"). </li><li>  Os GameObjects implementam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">o padr√£o "localizador de servi√ßo"</a> - seus componentes filhos ser√£o consultados por tipo. </li><li>  Os componentes sabem a que GameObject eles pertencem - eles podem encontrar componentes que est√£o no mesmo n√≠vel consultando o GameObject principal. <br></li><li>  A composi√ß√£o pode ter apenas um n√≠vel de profundidade (os <em>componentes n√£o podem ter seus pr√≥prios componentes filho, GameObjects n√£o pode ter GameObjects filho</em> ). <br></li><li>  O GameObject pode ter apenas um componente de cada tipo ( <em>em algumas estruturas, este √© um requisito obrigat√≥rio, em outras n√£o</em> ). <br></li><li>  Cada componente (provavelmente) muda ao longo do tempo de alguma maneira n√£o especificada, portanto a interface cont√©m uma "atualiza√ß√£o de vazio virtual". <br></li><li>  GameObjects pertencem a uma cena que pode executar consultas em todos os GameObjects (e, portanto, em todos os componentes). </li></ul><br>  Um conceito semelhante era muito popular nos anos 2000 e, apesar de suas limita√ß√µes, acabou por ser flex√≠vel o suficiente para criar in√∫meros jogos tanto na √©poca quanto nos dias de hoje. <br><br>  No entanto, isso n√£o √© necess√°rio.  Sua linguagem de programa√ß√£o j√° tem suporte √† composi√ß√£o como um recurso da linguagem - n√£o h√° necessidade de um conceito inchado para acess√°-lo ... Por que, ent√£o, esses conceitos existem?  Bem, para ser sincero, eles permitem que voc√™ execute <em>composi√ß√£o din√¢mica em tempo de execu√ß√£o</em> .  Em vez de definir os tipos de GameObject no c√≥digo, voc√™ pode carreg√°-los dos arquivos de dados.  E isso √© muito conveniente, porque permite que designers de jogos / n√≠veis criem seus pr√≥prios tipos de objetos ... No entanto, na maioria dos projetos de jogos, existem muito poucos designers e literalmente um ex√©rcito inteiro de programadores, ent√£o eu diria que essa √© uma oportunidade importante.  Pior ainda, essa n√£o √© a √∫nica maneira de implementar uma composi√ß√£o em tempo de execu√ß√£o!  Por exemplo, o Unity usa C # como sua "linguagem de script" e muitos outros jogos usam suas alternativas, por exemplo, Lua - uma ferramenta conveniente para os designers podem gerar c√≥digo C # / Lua para definir novos objetos de jogo sem a necessidade de um conceito t√£o inchado!  Adicionaremos novamente esse "recurso" no pr√≥ximo post e o faremos para que n√£o nos custe uma redu√ß√£o de dez vezes no desempenho ... <br><br>  Vamos avaliar esse c√≥digo de acordo com o OOD: <br><br><ul><li>  GameObject :: GetComponent usa dynamic_cast.  A maioria das pessoas dir√° que dynamic_cast √© um ‚Äúc√≥digo com estrangulamento‚Äù, uma grande dica de que voc√™ tem um bug em algum lugar.  Eu diria isso - isso √© evid√™ncia de que voc√™ violou o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">LSP</a> - voc√™ tem algum tipo de algoritmo que funciona com a interface base, mas precisa conhecer detalhes diferentes da implementa√ß√£o.  Por esse motivo espec√≠fico, o c√≥digo tem um cheiro ruim. <br></li><li>  GameObject, em princ√≠pio, n√£o √© ruim, se voc√™ imagina que implementa o modelo "localizador de servi√ßo" ... mas se voc√™ for al√©m das cr√≠ticas do ponto de vista do OOD, esse modelo cria conex√µes impl√≠citas entre partes do projeto, e eu acho ( <em>sem um link para a Wikipedia que possa suportar com conhecimento da ci√™ncia da computa√ß√£o</em> ) que os canais impl√≠citos de comunica√ß√£o s√£o um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">antipadr√£o</a> e devem preferir canais expl√≠citos de comunica√ß√£o.  O mesmo argumento se aplica ao inchado "conceito de eventos" que √†s vezes √© usado em jogos ... <br></li><li>  Quero declarar que um componente √© uma viola√ß√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">SRP</a> porque sua interface ( <em>atualiza√ß√£o de cancelamento virtual (hora)</em> ) √© muito ampla.  O uso da "atualiza√ß√£o de v√°cuo virtual" no desenvolvimento de jogos √© onipresente, mas eu tamb√©m diria que √© antipadr√£o.  Um bom software deve permitir que voc√™ pense facilmente sobre o fluxo de controle e o fluxo de dados.  Colocar <em>cada elemento do c√≥digo de jogo</em> atr√°s da chamada "atualiza√ß√£o de v√°cuo virtual" ofusca completamente o fluxo de controle e o fluxo de dados.  O IMHO, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">efeitos colaterais</a> invis√≠veis, tamb√©m chamados de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">efeitos de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">longo alcance</a> , s√£o algumas das fontes mais comuns de bugs, e a "atualiza√ß√£o de v√°cuo virtual" garante que quase tudo seja um efeito colateral invis√≠vel. <br></li><li>  Embora o objetivo da classe Component seja habilitar a composi√ß√£o, ele o faz por heran√ßa, o que √© uma viola√ß√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">CRP</a> . </li><li>  O √∫nico lado bom deste exemplo √© que o c√≥digo do jogo √© um exagero para cumprir os princ√≠pios do SRP e ISP - ele √© dividido em muitos componentes simples com muito pouca responsabilidade, o que √© √≥timo para reutilizar o c√≥digo. <br><br>  No entanto, ele n√£o √© t√£o bom em manter o DIP - muitos componentes t√™m conhecimento direto um do outro. </li></ul><br>  Portanto, todo o c√≥digo mostrado acima pode realmente ser exclu√≠do.  Toda essa estrutura.  Exclua GameObject (tamb√©m chamado Entity em outras estruturas), remova Component, exclua FindOfType.  Isso faz parte de uma VM in√∫til que viola os princ√≠pios de OOD e desacelera enormemente o nosso jogo. <br><br><h1>  Composi√ß√£o sem estruturas (ou seja, usando recursos da pr√≥pria linguagem de programa√ß√£o) </h1><br>  Se removermos a estrutura de composi√ß√£o e n√£o tivermos a classe base Component, como nossos GameObjects conseguir√£o usar a composi√ß√£o e consistir em componentes?  Como o t√≠tulo diz, em vez de escrever esta VM inchada e criar GameObjects em uma estranha metalinguagem, vamos escrev√™-los em C ++ porque somos programadores de jogos e esse √© literalmente o nosso trabalho. <br><br>  Aqui est√° o commit que removeu a estrutura de Entidade / Componente: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">https://github.com/hodgman/dod-playground/commit/f42290d0217d700dea2ed002f2f3b1dc45e8c27c</a> <br><br>  Aqui est√° a vers√£o original do c√≥digo-fonte: <a href="" rel="external nofollow">https://github.com/hodgman/dod-playground/blob/3529f232510c95f53112bbfff87df6bbc6aa1fae/source/game.cpp</a> <br><br>  Aqui est√° a vers√£o modificada do c√≥digo-fonte: <a href="" rel="external nofollow">https://github.com/hodgman/dod-playground/blob/f42290d0217d700dea2ed002f2f3b1dc45e8c27c/source/game.cpp</a> <br><br>  Brevemente sobre as mudan√ßas: <br><br><ul><li>  Removido ": public Component" de cada tipo de componente. <br></li><li>  Adicionado um construtor para cada tipo de componente. <br><ul><li>  OOD √© basicamente encapsular o estado de uma classe, mas como essas classes s√£o pequenas / simples, n√£o h√° nada a esconder: uma interface √© uma descri√ß√£o dos dados.  No entanto, um dos principais motivos pelos quais o encapsulamento √© o pilar principal √© que ele nos permite garantir a verdade constante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">dos invariantes de classe</a> ... ou se o invariante estiver quebrado, basta examinar o c√≥digo de implementa√ß√£o encapsulado para encontrar o erro.  Neste exemplo de c√≥digo, vale a pena adicionar construtores para implementar uma invari√°vel simples - todos os valores devem ser inicializados. </li></ul></li><li>  Renomeei os m√©todos gerais de ‚ÄúUpdate‚Äù para que seus nomes reflitam o que eles realmente fazem - UpdatePosition for MoveComponent e ResolveCollisions for AvoidComponent. <br></li><li>  Eu removi tr√™s blocos de c√≥digo codificados que se assemelhavam a um modelo / pr√©-fabricado - o c√≥digo que cria um GameObject contendo tipos espec√≠ficos de Componente e o substitui por tr√™s classes C ++. <br></li><li>  Antipattern eliminado "atualiza√ß√£o de vazio virtual". <br></li><li>  Em vez de os componentes se procurarem atrav√©s do modelo "localizador de servi√ßo", o jogo os liga explicitamente durante a constru√ß√£o. </li></ul><br><h2>  Os objetos </h2><br>  Portanto, em vez deste c√≥digo de "m√°quina virtual": <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// create regular objects that move for (auto i = 0; i &lt; kObjectCount; ++i) { GameObject* go = new GameObject("object"); // position it within world bounds PositionComponent* pos = new PositionComponent(); pos-&gt;x = RandomFloat(bounds-&gt;xMin, bounds-&gt;xMax); pos-&gt;y = RandomFloat(bounds-&gt;yMin, bounds-&gt;yMax); go-&gt;AddComponent(pos); // setup a sprite for it (random sprite index from first 5), and initial white color SpriteComponent* sprite = new SpriteComponent(); sprite-&gt;colorR = 1.0f; sprite-&gt;colorG = 1.0f; sprite-&gt;colorB = 1.0f; sprite-&gt;spriteIndex = rand() % 5; sprite-&gt;scale = 1.0f; go-&gt;AddComponent(sprite); // make it move MoveComponent* move = new MoveComponent(0.5f, 0.7f); go-&gt;AddComponent(move); // make it avoid the bubble things AvoidComponent* avoid = new AvoidComponent(); go-&gt;AddComponent(avoid); s_Objects.emplace_back(go); }</span></span></code> </pre> <br>  Agora temos c√≥digo C ++ regular: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegularObject</span></span></span><span class="hljs-class"> {</span></span> PositionComponent pos; SpriteComponent sprite; MoveComponent move; AvoidComponent avoid; RegularObject(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WorldBoundsComponent&amp; bounds) : move(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) <span class="hljs-comment"><span class="hljs-comment">// position it within world bounds , pos(RandomFloat(bounds.xMin, bounds.xMax), RandomFloat(bounds.yMin, bounds.yMax)) // setup a sprite for it (random sprite index from first 5), and initial white color , sprite(1.0f, 1.0f, 1.0f, rand() % 5, 1.0f) { } }; ... // create regular objects that move regularObject.reserve(kObjectCount); for (auto i = 0; i &lt; kObjectCount; ++i) regularObject.emplace_back(bounds);</span></span></code> </pre> <br><h2>  Algoritmos </h2><br>  Outra grande mudan√ßa foi feita nos algoritmos.  Lembre-se, no come√ßo eu disse que interfaces e algoritmos funcionam em simbiose e deveriam influenciar a estrutura um do outro?  Portanto, o antipattern " <em>Virtual Void Update</em> " se tornou o inimigo aqui tamb√©m.  O c√≥digo inicial cont√©m o algoritmo principal do loop, consistindo apenas nisso: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// go through all objects for (auto go : s_Objects) { // Update all their components go-&gt;Update(time, deltaTime);</span></span></code> </pre> <br>  Voc√™ pode argumentar que √© bonito e simples, mas IMHO √© muito, muito ruim.  Isso ofusca completamente o <em>fluxo de</em> <em>controle</em> e o <em>fluxo de dados</em> dentro do jogo.  Se queremos entender nosso software, se queremos dar suporte a ele, se queremos adicionar coisas novas, otimiz√°-lo e execut√°-lo com efici√™ncia em v√°rios n√∫cleos de processador, precisamos entender o fluxo de controle e o fluxo de dados.  Portanto, a "atualiza√ß√£o de cancelamento virtual" deve ser incendiada. <br><br>  Em vez disso, criamos um loop principal mais expl√≠cito, que simplifica bastante o entendimento do fluxo de controle (o <em>fluxo de dados ainda √© ofuscado, mas corrigiremos isso nos seguintes commits</em> ). <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Update all positions for (auto&amp; go : s_game-&gt;regularObject) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } for (auto&amp; go : s_game-&gt;avoidThis) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } // Resolve all collisions for (auto&amp; go : s_game-&gt;regularObject) { ResolveCollisions(deltaTime, go, s_game-&gt;avoidThis); }</span></span></code> </pre> <br>  A desvantagem desse estilo √© que, para <em>cada novo tipo de objeto</em> adicionado ao jogo, precisamos adicionar v√°rias linhas ao loop principal.  Voltarei a isso em um post subsequente desta s√©rie. <br><br><h1>  Desempenho </h1><br>  Existem muitas viola√ß√µes enormes de OOD, algumas decis√µes ruins s√£o tomadas ao escolher uma estrutura e existem muitas oportunidades de otimiza√ß√£o, mas eu as abordarei no pr√≥ximo post da s√©rie.  No entanto, j√° nesta fase, est√° claro que a vers√£o com "OOD fixo" corresponde quase completamente ou vence o c√≥digo "ECS" final a partir do final da apresenta√ß√£o ... E tudo o que fizemos foi apenas pegar o c√≥digo pseudo-OOP ruim e cumprir com os princ√≠pios OOP (e tamb√©m excluiu centenas de linhas de c√≥digo)! <br><br><div style="text-align:center;"><img alt="img" src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png"></div><br><h1>  Pr√≥ximas etapas </h1><br>  Aqui, quero considerar uma variedade muito maior de problemas, incluindo a solu√ß√£o dos problemas restantes de OOD, objetos imut√°veis ‚Äã‚Äã( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">programa√ß√£o em estilo funcional</a> ) e as vantagens que eles podem trazer em discuss√µes sobre fluxos de dados, passagem de mensagens, aplica√ß√£o da l√≥gica DOD ao nosso c√≥digo OOD, aplicando sabedoria relevante no c√≥digo OOD, removendo essas classes de ‚Äúentidades‚Äù com as quais acabamos e usando apenas componentes puros, usando estilos diferentes para conectar componentes (comparando ponteiros e  a responsabilidade de levar) componentes de contentores do mundo real, a vers√£o ECS-revis√£o para melhor otimiza√ß√£o, bem como uma maior otimiza√ß√£o, n√£o mencionada no relat√≥rio Aras <em>(como multi-threading / SIMD).</em>  A ordem n√£o ser√° necessariamente essa, e talvez eu n√£o considere todas as op√ß√µes acima ... <br><br><h1>  Adi√ß√£o </h1><br>  Os links para o artigo se espalharam al√©m dos c√≠rculos dos desenvolvedores de jogos, ent√£o adicionarei: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">ECS</a> " ( <em>este artigo da Wikipedia √© ruim, a prop√≥sito, combina os conceitos de EC e ECS, e isso n√£o √© o mesmo ...</em> ) - esse √© um modelo falso que circula nas comunidades desenvolvedores de jogos.  De fato, √© uma vers√£o do modelo relacional em que "entidades" s√£o apenas IDs que designam um objeto sem forma, "componentes" s√£o linhas em tabelas espec√≠ficas que fazem refer√™ncia a IDs e "sistemas" s√£o c√≥digos de procedimentos que podem modificar componentes .  Esse ‚Äúmodelo‚Äù sempre foi posicionado como uma solu√ß√£o para o problema da aplica√ß√£o excessiva de heran√ßa, mas n√£o √© mencionado que a aplica√ß√£o excessiva de heran√ßa realmente viola as recomenda√ß√µes da OOP.  Da√≠ minha indigna√ß√£o.  Esta n√£o √© a "√∫nica maneira verdadeira" de escrever software.  A publica√ß√£o foi projetada para garantir que as pessoas realmente aprendam sobre os princ√≠pios de design existentes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441174/">https://habr.com/ru/post/pt441174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441158/index.html">Como a √©tica se tornou a quest√£o mais cara do Vale do Sil√≠cio e a filosofia se tornou sua solu√ß√£o mais pr√°tica</a></li>
<li><a href="../pt441160/index.html">Como aprender a determinar quando dizer n√£o</a></li>
<li><a href="../pt441166/index.html">Obtemos a senha mestra do gerenciador de senhas bloqueadas 1Password 4</a></li>
<li><a href="../pt441168/index.html">DataChannels QUIC: Primeiros Passos</a></li>
<li><a href="../pt441172/index.html">Como o mercado de impress√£o 3D cresceu em 2018 e o que isso significa para os neg√≥cios</a></li>
<li><a href="../pt441180/index.html">Nublado com possibilidade de publicidade n√£o desativ√°vel no c√©u estrelado</a></li>
<li><a href="../pt441182/index.html">Abordagem m√°quina-sinest√©sica para detectar ataques DDoS na rede. Parte 2</a></li>
<li><a href="../pt441184/index.html">A primeira confer√™ncia de jogos do Mail.ru Group</a></li>
<li><a href="../pt441186/index.html">Visualizador ASH: Reinicializa√ß√£o</a></li>
<li><a href="../pt441192/index.html">Usando o poder computacional de R para testar a hip√≥tese de igualdade de m√©dias</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>