<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÅ üîö ‚ùì MVCC di PostgreSQL-8. Pembekuan üç¶ üëéüèΩ ‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami mulai dengan masalah yang berkaitan dengan isolasi , membuat penyimpangan tentang pengorganisasian data pada tingkat rendah , dan berbicara secar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC di PostgreSQL-8. Pembekuan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/455590/">  Kami mulai dengan masalah yang berkaitan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">isolasi</a> , membuat penyimpangan tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengorganisasian data pada tingkat rendah</a> , dan berbicara secara rinci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang versi baris</a> dan bagaimana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">snapshots</a> diperoleh dari versi. <br><br>  Kemudian kami memeriksa berbagai jenis pembersihan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">intra-halaman</a> (bersama dengan HOT-update), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">reguler</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">otomatis</a> . <br><br>  Dan sampai pada topik terakhir dari siklus ini.  Hari ini kita akan berbicara tentang masalah pembungkus dan pembekuan id transaksi. <br><a name="habracut"></a><br><h1>  Transaksi Counter Overflow </h1><br>  PostgreSQL memiliki 32 bit yang dialokasikan untuk nomor transaksi.  Ini adalah jumlah yang cukup besar (sekitar 4 miliar), tetapi dengan operasi aktif dari server, itu mungkin habis.  Misalnya, pada beban 1000 transaksi per detik, ini akan terjadi setelah hanya satu setengah bulan operasi yang berkelanjutan. <br><br>  Tetapi kita berbicara tentang fakta bahwa mekanisme multi-versi bergantung pada urutan penomoran - kemudian dari dua transaksi, transaksi dengan angka yang lebih rendah dapat dianggap telah dimulai sebelumnya.  Oleh karena itu, jelas bahwa Anda tidak dapat mengatur ulang penghitung dan melanjutkan penomoran lagi. <br><br><img src="https://habrastorage.org/webt/cn/om/rg/cnomrgflv1bnkqme9k68bit4ad0.png"><br><br>  Mengapa 64 bit tidak dialokasikan untuk nomor transaksi - karena ini akan sepenuhnya menghilangkan masalah?  Faktanya adalah bahwa (seperti yang dibahas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> ) di header setiap versi baris disimpan dua nomor transaksi - xmin dan xmax.  Header sudah cukup besar, setidaknya 23 byte, dan peningkatan kedalaman bit akan menyebabkan peningkatannya oleh 8 byte lainnya.  Ini sama sekali tidak mungkin. <br><br><blockquote>  Nomor transaksi 64-bit diterapkan dalam produk perusahaan kami, Postgres Pro Enterprise, tetapi mereka juga tidak sepenuhnya jujur ‚Äã‚Äãdi sana: xmin dan xmax tetap 32-bit, dan tajuk halaman berisi halaman "permulaan era" yang umum. <br></blockquote><br>  Apa yang harus dilakukan  Alih-alih diagram linear, semua nomor transaksi diulang.  Untuk setiap transaksi, setengah dari angka "berlawanan arah jarum jam" dianggap milik masa lalu, dan setengah "searah jarum jam" ke masa depan. <br><br>  Usia transaksi adalah jumlah transaksi yang telah berlalu sejak muncul dalam sistem (terlepas dari apakah penghitung melewati nol atau tidak).  Ketika kami ingin memahami apakah satu transaksi lebih tua dari yang lain atau tidak, kami membandingkan usia mereka, bukan angka.  (Oleh karena itu, omong-omong, operasi "lebih besar" dan "kurang" tidak ditentukan untuk tipe data xid.) <br><br><img src="https://habrastorage.org/webt/8f/rk/ft/8frkftw38-c0-yfbjaz7m-au3va.png"><br><br>  Tetapi dalam sirkuit yang berulang, situasi yang tidak menyenangkan muncul.  Suatu transaksi yang berada di masa lalu yang jauh (transaksi 1 dalam gambar), setelah beberapa saat akan berada di setengah lingkaran yang berhubungan dengan masa depan.  Ini, tentu saja, melanggar aturan visibilitas dan akan menimbulkan masalah - perubahan yang dilakukan oleh transaksi 1 akan hilang begitu saja dari pandangan. <br><br><img src="https://habrastorage.org/webt/qp/vy/ag/qpvyagxruu4gik-rof6eqoxk1e4.png"><br><br><h1>  Pembekuan Versi dan Aturan Visibilitas </h1><br>  Untuk mencegah "perjalanan" dari masa lalu ke masa depan, proses pembersihan (selain membebaskan ruang di halaman) melakukan tugas lain.  Dia menemukan versi garis yang agak lama dan "dingin" (yang terlihat di semua gambar dan perubahan yang sudah tidak mungkin) dan dengan cara khusus menandai mereka - "membeku".  Versi beku baris dianggap lebih tua dari data biasa dan selalu terlihat di semua snapshot data.  Selain itu, tidak perlu lagi melihat nomor transaksi xmin, dan nomor ini dapat digunakan kembali dengan aman.  Dengan demikian, versi string yang beku selalu tetap ada di masa lalu. <br><br><img src="https://habrastorage.org/webt/2c/vn/yp/2cvnypkp70pikgco9rzjjiccob0.png"><br><br>  Untuk menandai nomor transaksi xmin sebagai beku, kedua bit petunjuk ditetapkan pada waktu yang sama - bit komit dan bit membatalkan. <br><br>  Perhatikan bahwa transaksi xmax tidak perlu dibekukan.  Kehadirannya berarti bahwa versi string ini tidak lagi relevan.  Setelah tidak lagi terlihat dalam snapshot data, versi baris ini akan dihapus. <br><br>  Untuk percobaan, buat tabel.  Kami mengatur fillfactor minimum untuknya sehingga hanya dua baris yang sesuai pada setiap halaman - sehingga akan lebih mudah bagi kami untuk mengamati apa yang terjadi.  Dan matikan otomatisasi untuk mengontrol waktu pembersihan sendiri. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tfreeze( id <span class="hljs-type"><span class="hljs-type">integer</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">300</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor = <span class="hljs-number"><span class="hljs-number">10</span></span>, autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre> <br>  Kami telah membuat beberapa varian fungsi, yang, menggunakan ekstensi pageinspect, menunjukkan versi garis yang ada di halaman.  Sekarang kita akan membuat varian lain dari fungsi yang sama: sekarang akan menampilkan beberapa halaman sekaligus dan menunjukkan usia transaksi xmin (usia fungsi sistem digunakan untuk ini): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno_from <span class="hljs-type"><span class="hljs-type">integer</span></span>, pageno_to <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin_age <span class="hljs-type"><span class="hljs-type">integer</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">+</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) = </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">+</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (f)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, age(t_xmin) xmin_age, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> generate_series(pageno_from, pageno_to) p(pageno), heap_page_items(get_raw_page(relname, pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> pageno, lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Harap dicatat bahwa tanda pembekuan (yang kami tunjukkan dengan huruf f dalam tanda kurung) ditentukan oleh instalasi simultan dari prompt yang dilakukan dan dibatalkan.  Banyak sumber (termasuk dokumentasi) menyebutkan nomor khusus FrozenTransactionId = 2, yang menandai transaksi beku.  Sistem seperti itu dioperasikan hingga versi 9.4, tetapi sekarang telah digantikan oleh bit tooltip - ini memungkinkan Anda untuk menyimpan nomor transaksi asli dalam versi baris, yang nyaman untuk keperluan dukungan dan debugging.  Namun, transaksi dengan nomor 2 masih dapat terjadi di sistem yang lebih lama, bahkan ditingkatkan ke versi terbaru. <br><br>  Kami juga membutuhkan ekstensi pg_visibilitas, yang memungkinkan Anda melihat ke peta visibilitas: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_visibility;</code> </pre><br>  Sebelum PostgreSQL 9.6, peta visibilitas berisi satu bit per halaman;  itu menandai halaman yang hanya berisi versi string yang "cukup lama" yang sudah dijamin akan terlihat di semua gambar.  Idenya di sini adalah bahwa jika halaman ditandai di peta visibilitas, maka untuk versi garisnya Anda tidak perlu memeriksa aturan visibilitas. <br><br>  Dimulai dengan versi 9.6, peta beku ditambahkan ke lapisan yang sama - satu bit lebih per halaman.  Peta beku menandai halaman di mana semua versi baris dibekukan. <br><br>  Kami memasukkan beberapa baris ke dalam tabel dan segera melakukan pembersihan untuk membuat peta visibilitas: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tfreeze(id, s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id, <span class="hljs-string"><span class="hljs-string">'FOO'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>) g(id); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze;</code> </pre><br>  Dan kita melihat bahwa kedua halaman sekarang ditandai di peta visibilitas (all_visible), tetapi belum dibekukan (all_frozen): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | f (2 rows)</code> </pre><br>  Usia transaksi yang membuat baris (xmin_age) adalah 1 - ini adalah transaksi terakhir yang dilakukan pada sistem: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+--------+---------+----------+-------+-------- (0,1) | normal | 697 (c) | 1 | 0 (a) | (0,1) (0,2) | normal | 697 (c) | 1 | 0 (a) | (0,2) (1,1) | normal | 697 (c) | 1 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 1 | 0 (a) | (1,2) (4 rows)</code> </pre><br><h1>  Usia minimum untuk pembekuan </h1><br>  Tiga parameter utama mengontrol pembekuan, dan kami akan mempertimbangkannya pada gilirannya. <br><br>  Mari kita mulai dengan <em>vacuum_freeze_min_age</em> , yang mendefinisikan usia transaksi minimum xmin di mana versi string dapat dibekukan.  Semakin rendah nilai ini, biaya overhead yang lebih tidak perlu mungkin berubah menjadi: jika kita berurusan dengan "panas", secara aktif mengubah data, maka pembekuan lebih banyak dan lebih banyak versi baru akan sia-sia.  Dalam hal ini, lebih baik menunggu. <br><br>  Nilai default untuk parameter ini menetapkan bahwa transaksi mulai membeku setelah 50 juta transaksi lainnya berlalu sejak muncul: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> vacuum_freeze_min_age;</code> </pre><pre> <code class="plaintext hljs"> vacuum_freeze_min_age ----------------------- 50000000 (1 row)</code> </pre><br>  Untuk melihat bagaimana pembekuan terjadi, kami mengurangi nilai parameter ini menjadi satu. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> vacuum_freeze_min_age = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Dan kami akan memperbarui satu baris di halaman nol.  Versi baru akan sampai ke halaman yang sama karena nilai fillfactor kecil. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Inilah yang kita lihat sekarang di halaman data: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+--------+---------+----------+-------+-------- (0,1) | normal | 697 (c) | 2 | 698 | (0,3) (0,2) | normal | 697 (c) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (c) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  Sekarang baris yang lebih tua dari <em>vacuum_freeze_min_age</em> = 1 harus dibekukan.  Tetapi perhatikan bahwa garis nol tidak ditandai di peta visibilitas (bit direset oleh perintah UPDATE, yang mengubah halaman), dan yang pertama tetap diperiksa: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | f | f 1 | t | f (2 rows)</code> </pre><br>  Kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">telah mengatakan</a> bahwa pembersihan hanya memindai halaman yang tidak ditandai di peta visibilitas.  Dan ternyata: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+---------------+---------+----------+-------+-------- (0,1) | redirect to 3 | | | | (0,2) | normal | 697 (f) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 (c) | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (c) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  Pada halaman nol, satu versi dibekukan, tetapi halaman pertama tidak mempertimbangkan pembersihan sama sekali.  Jadi, jika hanya versi saat ini yang tersisa di halaman, maka pembersihan tidak akan sampai ke halaman seperti itu dan tidak akan membekukannya. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | f (2 rows)</code> </pre><br><h1>  Umur untuk membekukan seluruh tabel </h1><br>  Untuk tetap membekukan versi baris yang tersisa di halaman yang tidak dilihat oleh pembersihan, parameter kedua disediakan: <em>vacuum_freeze_table_age</em> .  Ini menentukan usia transaksi, di mana pembersihan mengabaikan peta visibilitas dan melewati semua halaman tabel untuk dibekukan. <br><br>  Setiap tabel menyimpan nomor transaksi, yang diketahui bahwa semua transaksi lama dijamin akan dibekukan (pg_class.relfrozenxid).  Dengan usia transaksi yang diingat ini, nilai parameter <em>vacuum_freeze_table_age dibandingkan</em> . <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 694 | 5 (1 row)</code> </pre><br>  Sebelum PostgreSQL 9.6, pembersihan melakukan pemindaian tabel penuh untuk memastikan bahwa semua halaman dirayapi.  Untuk meja besar, operasi ini panjang dan menyedihkan.  Masalah ini diperburuk oleh fakta bahwa jika pembersihan gagal mencapai akhir (misalnya, administrator yang tidak sabar mengganggu pelaksanaan perintah), itu perlu dimulai dari awal. <br><br>  Dimulai dengan versi 9.6, berkat peta beku (yang kita lihat di kolom all_frozen di output pg_visibility_map), membersihkan bypass hanya halaman-halaman yang belum ditandai di peta.  Ini bukan hanya jumlah pekerjaan yang jauh lebih kecil, tetapi juga ketahanan terhadap gangguan: jika proses pembersihan dihentikan dan dimulai lagi, dia tidak perlu lagi melihat halaman yang sudah dia tandai dalam peta pembekuan terakhir kali. <br><br>  Dengan satu atau lain cara, semua halaman dalam tabel dibekukan sekali dalam ( <em>vacuum_freeze_table_age</em> - <em>vacuum_freeze_min_age</em> ) transaksi.  Dengan nilai default, ini terjadi sekali per juta transaksi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> vacuum_freeze_table_age;</code> </pre><pre> <code class="plaintext hljs"> vacuum_freeze_table_age ------------------------- 150000000 (1 row)</code> </pre><br>  Dengan demikian, jelas bahwa terlalu banyak <em>vacuum_freeze_min_age</em> tidak boleh diatur, karena alih-alih mengurangi overhead, ini akan mulai meningkatkannya. <br><br>  Mari kita lihat bagaimana seluruh tabel dibekukan, dan untuk melakukan ini, kurangi <em>vacuum_freeze_table_age</em> menjadi 5 sehingga kondisi untuk pembekuan terpenuhi. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> vacuum_freeze_table_age = <span class="hljs-number"><span class="hljs-number">5</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Mari kita bersihkan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze;</code> </pre><br>  Sekarang, karena seluruh tabel telah dijamin untuk diverifikasi, jumlah transaksi yang dibekukan dapat ditingkatkan - kami yakin bahwa halaman tersebut tidak memiliki transaksi yang lebih lama, yang tidak dibekukan. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 698 | 1 (1 row)</code> </pre><br>  Sekarang semua versi baris pada halaman pertama dibekukan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+---------------+---------+----------+-------+-------- (0,1) | redirect to 3 | | | | (0,2) | normal | 697 (f) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 (c) | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (f) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (f) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  Selain itu, halaman pertama ditandai di peta beku: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | t (2 rows)</code> </pre><br><h1>  Umur untuk respons "agresif" </h1><br>  Penting agar versi baris dibekukan tepat waktu.  Jika muncul situasi di mana transaksi yang belum dibekukan berisiko memasuki masa depan, PostgreSQL akan macet untuk mencegah potensi masalah. <br><br>  Apa yang bisa menjadi alasan untuk ini?  Ada berbagai alasan. <br><br><ul><li>  Pembersihan otomatis dapat dimatikan, dan pembersihan rutin tidak dimulai.  Kami sudah mengatakan bahwa ini tidak perlu, tetapi secara teknis itu mungkin. </li><li>  Bahkan pembersihan otomatis yang disertakan tidak datang ke database yang tidak digunakan (ingat parameter <em>track_counts</em> dan database <em>templat0</em> ). </li><li>  Seperti yang kita lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terakhir kali</a> , membersihkan melompati tabel di mana data hanya ditambahkan, tetapi tidak dihapus atau diubah. </li></ul><br>  Dalam kasus tersebut, operasi <em>pembersihan otomatis</em> ‚Äúagresif‚Äù disediakan, dan diatur oleh parameter <em>autovacuum_freeze_max_age</em> .  Jika dalam tabel mana pun dari basis data apa pun mungkin ada transaksi yang dibekukan lebih tua dari usia yang ditentukan dalam parameter, pembersihan otomatis dimulai secara paksa (bahkan jika dinonaktifkan) dan cepat atau lambat akan mencapai tabel masalah (terlepas dari kriteria yang biasa). <br><br>  Nilai standarnya cukup konservatif: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> autovacuum_freeze_max_age;</code> </pre><pre> <code class="plaintext hljs"> autovacuum_freeze_max_age --------------------------- 200000000 (1 row)</code> </pre><br>  Batas untuk <em>autovacuum_freeze_max_age</em> adalah 2 miliar transaksi, dan nilai 10 kali lebih kecil digunakan.  Ini masuk akal: meningkatkan nilai kami meningkatkan risiko bahwa untuk waktu yang tersisa, pembersihan otomatis tidak punya waktu untuk membekukan semua versi garis yang diperlukan. <br><br>  Selain itu, nilai parameter ini menentukan ukuran struktur XACT: karena seharusnya tidak ada transaksi lama dalam sistem yang Anda mungkin perlu mengetahui statusnya, pembersihan otomatis menghapus file segmen XACT yang tidak perlu, membebaskan ruang. <br><br>  Mari kita lihat bagaimana pembersihan menangani tabel append-only, menggunakan tfreeze sebagai contoh.  Untuk tabel ini, pembersihan otomatis umumnya dinonaktifkan, tetapi ini tidak akan menjadi hambatan. <br><br>  Mengubah parameter <em>autovacuum_freeze_max_age</em> membutuhkan server restart.  Tetapi semua parameter yang dibahas di atas juga dapat diatur pada tingkat tabel individu menggunakan parameter penyimpanan.  Biasanya masuk akal untuk melakukan ini dalam kasus-kasus khusus, ketika meja benar-benar membutuhkan perawatan khusus. <br><br>  Jadi, kita akan mengatur <em>autovacuum_freeze_max_age</em> di level tabel (dan pada saat yang sama mengembalikan fillfactor normal juga).  Sayangnya, nilai minimum yang mungkin adalah 100.000: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_freeze_max_age = <span class="hljs-number"><span class="hljs-number">100000</span></span>, fillfactor = <span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre><br>  Sayangnya, karena kita harus menyelesaikan 100.000 transaksi untuk mereproduksi situasi yang menarik minat kita.  Tetapi, tentu saja, untuk tujuan praktis, ini adalah nilai yang sangat, sangat rendah. <br><br>  Karena kami akan menambahkan data, kami akan memasukkan 100.000 baris ke tabel - masing-masing dalam transaksi kami.  Dan lagi saya harus membuat reservasi bahwa dalam praktiknya ini tidak boleh dilakukan.  Tapi sekarang kita hanya menjelajah, kita bisa. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> foo(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INSERT</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INTO</span></span></span><span class="pgsql"> tfreeze </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">VALUES</span></span></span><span class="pgsql"> (id, </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'FOO'</span></span></span><span class="pgsql">); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">COMMIT</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FOR</span></span></span><span class="pgsql"> i </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">IN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">101</span></span></span><span class="pgsql"> .. </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">100100</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CALL</span></span></span><span class="pgsql"> foo(i); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span>;</code> </pre><br>  Seperti yang bisa kita lihat, usia transaksi terakhir yang dibekukan dalam tabel telah melampaui nilai ambang: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+-------- 698 | 100006 (1 row)</code> </pre><br>  Tetapi jika Anda menunggu sebentar sekarang, maka di log pesan server akan ada entri tentang kekosongan agresif tabel "test.public.tfreeze" otomatis, jumlah transaksi beku akan berubah, dan usianya akan kembali ke kesopanan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 100703 | 3 (1 row)</code> </pre><br><blockquote>  Ada juga yang namanya membekukan multi-transaksi, tetapi kami belum akan membicarakannya - kami akan menundanya hingga kami berbicara tentang kunci agar tidak menjadi yang terdepan. <br></blockquote><br><h1>  Pembekuan manual </h1><br>  Terkadang lebih mudah untuk mengontrol pembekuan secara manual daripada menunggu kedatangan pembersihan otomatis. <br><br>  Anda dapat membekukan perintah secara manual menggunakan perintah VACUUM FREEZE - semua versi baris akan dibekukan, tanpa memandang usia transaksi (seolah-olah <em>autovacuum_freeze_min_age</em> = 0 parameter).  Ketika sebuah tabel dibangun kembali dengan perintah VACUUM FULL atau CLUSTER, semua baris juga dibekukan. <br><br>  Untuk membekukan semua basis data, Anda dapat menggunakan utilitas: <br><br><pre> <code class="plaintext hljs">vacuumdb --all --freeze</code> </pre><br>  Data juga dapat dibekukan selama pemuatan awal menggunakan perintah COPY dengan menentukan parameter FREEZE.  Untuk melakukan ini, tabel harus dibuat (atau dikosongkan dengan perintah TRUNCATE) dengan cara yang sama <br>  transaksi sebagai SALINAN. <br><br>  Karena ada aturan visibilitas terpisah untuk baris beku, baris tersebut akan terlihat dalam snapshot data dari transaksi lain yang melanggar aturan isolasi biasa (ini berlaku untuk transaksi dengan tingkat Repeatable Read atau Serializable). <br><br>  Untuk memverifikasi ini, di sesi lain, mulailah transaksi dengan tingkat isolasi Baca Berulang: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><br>  Perhatikan bahwa transaksi ini membuat snapshot data, tetapi tidak mengakses tabel tfreeze.  Sekarang kita akan mengosongkan tabel tfreeze dan memuat baris baru ke dalamnya dalam satu transaksi.  Jika transaksi paralel membaca konten tfreeze, perintah TRUNCATE akan dikunci hingga akhir transaksi. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> tfreeze; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">FROM stdin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FREEZE</span></span>;</code> </pre><pre> <code class="plaintext hljs">1 FOO 2 BAR 3 BAZ \.</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Sekarang transaksi paralel melihat data baru, meskipun ini memecah isolasi: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tfreeze;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Tapi, karena pemuatan data seperti itu tidak mungkin terjadi secara teratur, ini biasanya tidak menjadi masalah. <br><br>  Lebih buruk lagi, COPY WITH FREEZE tidak berfungsi dengan peta visibilitas - halaman yang dimuat tidak ditandai sebagai hanya berisi versi garis yang dapat dilihat oleh semua orang.  Karena itu, ketika Anda pertama kali mengakses tabel, pembersihan dipaksa untuk memproses ulang semuanya dan membuat peta visibilitas.  Lebih buruk lagi, halaman data memiliki tanda visibilitas penuh di header mereka sendiri, jadi membersihkan tidak hanya membaca seluruh tabel, tetapi juga sepenuhnya menulis ulang, meletakkan bit yang diinginkan.  Sayangnya, solusi untuk masalah ini tidak harus menunggu lebih awal dari versi 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskusi</a> ). <br><br><h1>  Kesimpulan </h1><br>  Ini menyimpulkan seri artikel saya tentang isolasi dan multiversion PostgreSQL.  Terima kasih atas perhatian Anda dan terutama atas komentarnya - mereka meningkatkan materi dan sering menunjukkan area yang membutuhkan perhatian lebih pada bagian saya. <br><br>  Tetap bersama kami, untuk dilanjutkan! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455590/">https://habr.com/ru/post/id455590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455580/index.html">Animasi Aplikasi Mobile yang Harus Dimiliki</a></li>
<li><a href="../id455582/index.html">Navigasi di toko: melalui augmented reality ke rak yang diinginkan</a></li>
<li><a href="../id455584/index.html">Wawancara khusus dengan kekuatan internal perusahaan: melalui kesalahan penemuan</a></li>
<li><a href="../id455586/index.html">Seri Kuliah tentang Robotika oleh Profesor Gregor Sch√∂ner, Direktur Institute of Neuroinformatics (INI) Bochum, Jerman</a></li>
<li><a href="../id455588/index.html">Cara mendidik komunitas Anda agar tidak menari dengan rebana</a></li>
<li><a href="../id455592/index.html">Virus menyerang perusahaan industri sebagai ancaman terhadap keamanan fisik</a></li>
<li><a href="../id455594/index.html">Microsoft Edge dari CVE hingga RCE pada Windows 10</a></li>
<li><a href="../id455596/index.html">DevConfX :: Management - laporan manajer dengan kata-kata sederhana</a></li>
<li><a href="../id455598/index.html">Tingkatkan segera Exim ke 4,92 - ada infeksi aktif</a></li>
<li><a href="../id455600/index.html">Platform 3DEXPERIENCE Membantu Menciptakan Transportasi Publik di Masa Depan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>