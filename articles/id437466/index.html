<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌦️ ♑️ 👨🏿‍🏭 Mesin byte untuk benteng (dan tidak hanya) di Native American (bagian 4) 🚞 😎 🧑🏽‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dan lagi saya melebih-lebihkan volume artikel! Saya merencanakan bahwa ini akan menjadi artikel terakhir, di mana kami akan membuat kompiler dan melak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mesin byte untuk benteng (dan tidak hanya) di Native American (bagian 4)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437466/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="Fort Byte Car (dan banyak lagi) Penduduk Asli Amerika"><br><br>  Dan lagi saya melebih-lebihkan volume artikel!  Saya merencanakan bahwa ini akan menjadi artikel terakhir, di mana kami akan membuat kompiler dan melakukan pengujian.  Tetapi volumenya ternyata besar, dan saya memutuskan untuk membagi artikel menjadi dua. <br><br>  Pada artikel ini, kita akan melakukan hampir semua fungsi dasar dari kompiler.  Ini akan hidup kembali, dan dimungkinkan untuk menulis, menyusun, dan mengeksekusi kode yang cukup serius.  Dan kami akan melakukan pengujian di bagian selanjutnya.  (Omong-omong, bagian sebelumnya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiga</a> ). <br><br>  Saya menulis untuk pertama kalinya di Habré, mungkin itu tidak selalu baik-baik saja.  Menurut pendapat saya, artikel 2, 3 ternyata agak kering, banyak kode, sedikit deskripsi.  Kali ini saya akan mencoba melakukan sesuatu yang berbeda, fokus pada deskripsi ide-ide itu sendiri.  Nah, kodenya ... kodenya, tentu saja akan!  Siapa yang ingin mengerti secara menyeluruh, kesempatan seperti itu akan terjadi.  Dalam banyak kasus, saya akan meletakkan kode di bawah spoiler.  Dan, tentu saja, Anda selalu dapat melihat sumber lengkap di github. <br><br>  Kompiler akan terus menulis untuk beberapa waktu di assembler, tetapi kemudian pergi ke benteng dan terus menulis kompilator pada diri kita sendiri.  Ini akan menyerupai Baron Munchausen, yang menarik rambutnya dari rawa.  Tapi, sebagai permulaan, saya akan menguraikan bagaimana kompiler di benteng bekerja.  Selamat datang di kucing! <br><a name="habracut"></a><br><h4>  Bagaimana cara kerja kompiler? </h4><br>  Memori di benteng terdiri dari sebuah fragmen yang berkelanjutan di mana entri kamus disusun secara berurutan.  Setelah selesai mereka diikuti oleh area memori bebas.  Byte gratis pertama ditunjukkan oleh variabel h.  Ada juga kata yang sering digunakan di sini, yang mendorong alamat byte bebas pertama pada stack, ditentukan dengan sangat sederhana: <br><br><pre><code class="cpp hljs">: here h @ ;</code> </pre> <br><img src="https://habrastorage.org/webt/bd/eg/sq/bdegsqg7t06egwbvxoib9lqk_nc.png"><br><br>  Perlu disebutkan kata allot, yang menyimpan jumlah byte yang ditentukan dengan menggerakkan pointer h.  Kata allot dapat didefinisikan sebagai berikut: <br><br><pre> <code class="cpp hljs">: allot h +! ;</code> </pre> <br>  Bahkan, kompiler menggunakan mode juru bahasa khusus ditambah beberapa kata-kata khusus.  Jadi, dengan satu kalimat, Anda bisa menggambarkan seluruh prinsip penyusun di benteng.  Mode apa yang digunakan penerjemah ditentukan oleh variabel status.  Jika nol, maka mode eksekusi diatur, jika tidak - mode kompilasi.  Kita sudah terbiasa dengan mode eksekusi, di dalamnya kata-kata dari buffer input dieksekusi satu demi satu.  Tetapi dalam mode kompilasi mereka tidak dieksekusi, tetapi dikompilasi ke dalam memori oleh pointer h.  Dengan demikian, penunjuk bergerak maju. <br><br>  Di benteng klasik, kata "," digunakan untuk mengkompilasi nilai integer, kata "c," digunakan untuk mengkompilasi byte.  Sistem kami menggunakan nilai kedalaman bit yang berbeda (8, 16, 32, 64), oleh karena itu, kami juga akan membuat kata "w," dan "i,".  Kami juga membuat kata "str," yang akan mengkompilasi string, mengambil dua nilai dari stack - alamat dan panjang string. <br><br>  Kata-kata kompiler khusus digunakan untuk membentuk struktur kontrol.  Ini adalah kata-kata jika, kemudian, lakukan, loop, dan lainnya.  Kata-kata ini dieksekusi bahkan dalam mode kompilasi.  Misalnya, kata jika mengkompilasi perintah byte cabang bersyarat (? Nbranch) saat eksekusi.  Agar sistem tahu kata-kata apa yang perlu dieksekusi dalam mode kompilasi, dan tidak dikompilasi, flag langsung (tanda) digunakan.  Kami sudah memilikinya di bidang bendera entri kamus.  Dalam kode sumber assembler, itu disebut f_immediate.  Untuk mengatur tanda ini, gunakan kata langsung.  Tidak memiliki parameter, bendera langsung ditetapkan pada kata terakhir dalam kamus. <br><br>  Sekarang mari kita beralih dari teori ke praktek! <br><br><h4>  Persiapan </h4><br>  Pada awalnya, kita perlu melakukan beberapa perintah byte sederhana dalam bahasa assembly yang kita butuhkan.  Inilah mereka: memindahkan (menyalin area memori), mengisi (mengisi area memori), operasi bit (dan, atau, xor, membalikkan), perintah bit shift (rshift, lshift).  Mari kita lakukan rpick yang sama (ini sama dengan pick, ini hanya bekerja dengan stack kembali, bukan tumpukan data). <br><br><div class="spoiler">  <b class="spoiler_title">Perintah-perintah ini sangat sederhana, ini adalah kodenya</b> <div class="spoiler_text"><pre> <code class="cpp hljs">b_move = <span class="hljs-number"><span class="hljs-number">0x66</span></span> bcmd_move: pop rcx pop rdi pop rsi repz movsb jmp _next b_fill = <span class="hljs-number"><span class="hljs-number">0x67</span></span> bcmd_fill: pop rax pop rcx pop rdi repz stosb jmp _next b_rpick = <span class="hljs-number"><span class="hljs-number">0x63</span></span> bcmd_rpick: pop rcx push [rbp + rcx * <span class="hljs-number"><span class="hljs-number">8</span></span>] jmp _next b_and = <span class="hljs-number"><span class="hljs-number">0x58</span></span> bcmd_and: pop rax <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> [rsp], rax jmp _next b_or = <span class="hljs-number"><span class="hljs-number">0x59</span></span> bcmd_or: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> [rsp], rax jmp _next b_xor = <span class="hljs-number"><span class="hljs-number">0x5A</span></span> bcmd_xor: pop rax xor [rsp], rax jmp _next b_invert = <span class="hljs-number"><span class="hljs-number">0x5B</span></span> bcmd_invert: notq [rsp] jmp _next b_rshift = <span class="hljs-number"><span class="hljs-number">0x5C</span></span> bcmd_rshift: pop rcx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz _next <span class="hljs-number"><span class="hljs-number">1</span></span>: shrq [rsp] dec rcx jnz <span class="hljs-number"><span class="hljs-number">1b</span></span> jmp _next b_lshift = <span class="hljs-number"><span class="hljs-number">0x5D</span></span> bcmd_lshift: pop rcx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz _next <span class="hljs-number"><span class="hljs-number">1</span></span>: shlq [rsp] dec rcx jnz <span class="hljs-number"><span class="hljs-number">1b</span></span> jmp _next</code> </pre> </div></div><br>  Masih perlu membuat kata kata.  Ini sama dengan blword, tetapi pembatas khusus ditunjukkan pada stack.  Saya tidak memberikan kode, itu dapat ditemukan di sumbernya.  Saya membuat copy / paste kata-kata blworld dan mengganti perintah perbandingan. <br><br>  Sebagai kesimpulan, kami membuat kata syscall.  Dengan itu, akan dimungkinkan untuk melakukan operasi sistem yang hilang, misalnya, bekerja dengan file.  Solusi semacam itu tidak akan berfungsi jika independensi platform diperlukan.  Tetapi sistem ini sekarang digunakan untuk pengujian, jadi biarkanlah untuk sekarang.  Jika perlu, semua operasi dapat dikonversi ke perintah byte, sama sekali tidak sulit.  Perintah syscall akan menerima 6 parameter untuk panggilan sistem dan nomor panggilan dari tumpukan.  Ini akan mengembalikan satu parameter.  Penugasan parameter dan nilai pengembalian ditentukan oleh nomor panggilan sistem. <br><br><pre> <code class="cpp hljs">b_syscall = <span class="hljs-number"><span class="hljs-number">0xFF</span></span> bcmd_syscall: sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> mov [rbp], r8 pop rax pop r9 pop r8 pop r10 pop rdx pop rsi pop rdi syscall push rax mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre><br>  Dan sekarang mari kita lanjutkan langsung ke kompiler. <br><br><h4>  Kompiler </h4><br>  Mari kita buat variabel h, semuanya sederhana di sini. <br><br><pre> <code class="cpp hljs"> item h h: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre>  Kami akan menulis inisialisasi di baris awal: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># forth last_item context @ ! h dup 8 + swap ! quit start: .byte b_call16 .word forth - . - 2 .byte b_call16 .word last_item - . - 2 .byte b_call16 .word context - . - 2 .byte b_get .byte b_set .byte b_call16 .word h - . - 2 .byte b_dup, b_num8, b_add, b_swap, b_set .byte b_quit</span></span></code> </pre><br>  Mari kita buat kata di sini: <br><br><pre> <code class="cpp hljs"> item here .byte b_call8, h - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_get .byte b_exit</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Dan juga kata-kata untuk menyusun nilai: "membagikan" dan "c,", "w,", "i,", ",", "str,"</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : allot h +! ; item allot allot: .byte b_call8, h - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_setp, b_exit # : , here ! <span class="hljs-number"><span class="hljs-number">8</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">","</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set, b_num8, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : i, here i! <span class="hljs-number"><span class="hljs-number">4</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"i,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set32, b_num4, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : w, here w! <span class="hljs-number"><span class="hljs-number">2</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"w,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set16, b_num2, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : c, here c! <span class="hljs-number"><span class="hljs-number">1</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"c,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set8, b_num1, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : str, dup -rot dup c, here swap move <span class="hljs-number"><span class="hljs-number">1</span></span>+ h +!; item <span class="hljs-string"><span class="hljs-string">"str,"</span></span> c_str: .byte b_dup, b_mrot, b_dup callb c_8 callb here .byte b_swap, b_move callb h .byte b_setp .byte b_exit</code> </pre></div></div><br>  Sekarang mari kita membuat variabel keadaan dan dua kata untuk mengontrol nilainya: "[" dan "]".  Biasanya kata-kata ini digunakan untuk melakukan sesuatu pada saat kompilasi.  Karenanya, kata "[" mematikan mode kompilasi, dan kata "]" menyalakannya.  Tetapi tidak ada yang mencegah mereka digunakan dalam kasus lain ketika perlu untuk mengaktifkan atau menonaktifkan mode kompilasi.  Kata "[" akan menjadi kata pertama kami dengan tanda langsung.  Jika tidak, ia tidak akan dapat mematikan mode kompilasi, karena akan dikompilasi, tidak dieksekusi. <br><br><pre> <code class="cpp hljs"> item state .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item <span class="hljs-string"><span class="hljs-string">"]"</span></span> .byte b_num1 callb state .byte b_set, b_exit item <span class="hljs-string"><span class="hljs-string">"["</span></span>, f_immediate .byte b_num0 callb state .byte b_set, b_exit</code> </pre><br>  Gilirannya datang untuk kata $ compile.  Ini akan mengambil alamat entri kamus dari tumpukan dan mengkompilasi kata yang ditentukan.  Untuk mengkompilasi kata dalam implementasi Fort biasa, cukup untuk menerapkan kata "," ke alamat eksekusi.  Semuanya jauh lebih rumit di sini.  Pertama, ada dua jenis kata - bytecode dan kode mesin.  Yang pertama dikompilasi oleh byte, dan yang terakhir oleh perintah byte panggilan.  Dan kedua - kami memiliki sebanyak empat varian dari perintah panggilan: call8, call16, call32 dan call64.  Empat?  Tidak!  Ketika saya menulis kompiler, saya menambahkan 16 lagi ke empat ini!  :) <br><br>  Bagaimana ini bisa terjadi?  Kita harus melakukan penyimpangan kecil. <br><br><h4>  Meningkatkan perintah panggilan </h4><br>  Ketika kompiler mulai bekerja, saya menemukan bahwa dalam banyak kasus (tetapi tidak semua) perintah call8 sudah cukup.  Ini adalah ketika kata yang dipanggil adalah dalam 128 byte.  Saya pikir - dan bagaimana memastikan bahwa ini terjadi di hampir semua kasus?  Bagaimana cara menempatkan lebih dari 256 nilai dalam satu byte? <br>  Poin pertama yang saya perhatikan adalah bahwa di benteng panggilan selalu menuju ke alamat yang lebih rendah.  Ini berarti bahwa Anda dapat mengulang perintah panggilan sedemikian rupa sehingga hanya dapat memanggil alamat yang lebih rendah, tetapi untuk 256 byte, bukan 128. Itu lebih baik. <br><br>  Tetapi jika Anda menaruh beberapa bit di suatu tempat ... Ternyata ada di mana!  Kami memiliki dua byte: satu byte adalah perintah, yang kedua adalah offset.  Tetapi tidak ada yang mencegah bit perintah yang lebih rendah dari menempatkan bit parameter yang tinggi (offset).  Untuk mesin byte, sepertinya bukan satu perintah panggilan, ada beberapa.  Ya, dengan cara ini kita menempati beberapa sel tabel kode byte-perintah dengan satu perintah, tetapi kadang-kadang ada baiknya melakukannya.  Perintah panggilan adalah salah satu perintah yang paling sering digunakan, jadi saya memutuskan untuk memasukkan 4 bit offset dalam perintah.  Dengan demikian, Anda bisa melakukan panggilan pada jarak 4.095 byte!  Ini berarti bahwa perintah panggilan singkat seperti itu akan digunakan hampir selalu.  Saya menempatkan perintah ini dengan kode 0xA0 dan baris berikut muncul di tabel perintah: <br><br><pre> <code class="cpp hljs">.quad bcmd_call8b0, bcmd_call8b1, bcmd_call8b2, bcmd_call8b3, bcmd_call8b4, bcmd_call8b5, bcmd_call8b6, bcmd_call8b7 # <span class="hljs-number"><span class="hljs-number">0xA0</span></span> .quad bcmd_call8b8, bcmd_call8b9, bcmd_call8b10, bcmd_call8b11, bcmd_call8b12, bcmd_call8b13, bcmd_call8b14, bcmd_call8b15</code> </pre> <br>  Perintah byte pertama ini hanya membuat panggilan ke arah alamat yang lebih rendah pada offset yang ditentukan dalam parameter (hingga 255).  Sisanya menambahkan offset yang sesuai ke parameter.  bcmd_call8b1 menambahkan 256, bcmd_call8b2 menambahkan 512, dan seterusnya.  Saya membuat perintah panggilan pertama secara terpisah, sisanya dengan makro. <br><br>  Perintah pertama: <br><br><pre> <code class="cpp hljs">b_call8b0 = <span class="hljs-number"><span class="hljs-number">0xA0</span></span> bcmd_call8b0: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 sub r8, rax jmp _next</code> </pre><br>  Makro dan membuat sisa perintah panggilan <br><br><pre> <code class="cpp hljs">.macro call8b N b_call8b\N = <span class="hljs-number"><span class="hljs-number">0xA</span></span>\N bcmd_call8b\N: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 add rax, \N * <span class="hljs-number"><span class="hljs-number">256</span></span> mov [rbp], r8 sub r8, rax jmp _next .endm call8b <span class="hljs-number"><span class="hljs-number">1</span></span> call8b <span class="hljs-number"><span class="hljs-number">2</span></span> call8b <span class="hljs-number"><span class="hljs-number">3</span></span> call8b <span class="hljs-number"><span class="hljs-number">4</span></span> call8b <span class="hljs-number"><span class="hljs-number">5</span></span> call8b <span class="hljs-number"><span class="hljs-number">6</span></span> call8b <span class="hljs-number"><span class="hljs-number">7</span></span> call8b <span class="hljs-number"><span class="hljs-number">8</span></span> call8b <span class="hljs-number"><span class="hljs-number">9</span></span> call8b <span class="hljs-number"><span class="hljs-number">10</span></span> call8b <span class="hljs-number"><span class="hljs-number">11</span></span> call8b <span class="hljs-number"><span class="hljs-number">12</span></span> call8b <span class="hljs-number"><span class="hljs-number">13</span></span> call8b <span class="hljs-number"><span class="hljs-number">14</span></span> call8b <span class="hljs-number"><span class="hljs-number">15</span></span></code> </pre><br>  Yah, saya redid perintah call8 lama untuk memanggil maju, karena kita sudah memiliki 16 tim membuat panggilan kembali.  Apa pun kebingungannya, saya menamainya b_call8f: <br><br><pre> <code class="cpp hljs">b_call8f = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8f: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next</code> </pre><br>  Ngomong-ngomong, untuk kenyamanan, saya membuat makro yang di assembler secara otomatis mengkompilasi panggilan yang terkait kembali dalam 4095. Dan kemudian saya tidak pernah perlu :) <br><br><pre> <code class="cpp hljs">.macro callb adr .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> \adr &gt; . .error <span class="hljs-string"><span class="hljs-string">"callb do not for forward!"</span></span> .endif .byte b_call8b0 + (. - \adr + <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> .byte (. - \adr + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> .endm</code> </pre> <br>  Dan sekarang ... <br><br><h4>  Kompilasi tim </h4><br>  Jadi, kami mendapatkan algoritma kompilasi perintah yang agak rumit.  Jika ini adalah perintah byte, kompilasi hanya byte (kode perintah byte).  Dan jika kata ini sudah ditulis dalam bytecode, Anda perlu mengkompilasi panggilannya dengan perintah panggilan, memilih salah satu dari dua puluh.  Lebih tepatnya 19, jadi kami tidak memiliki panggilan ke depan, dan call8f tidak akan digunakan untuk benteng. <br><br>  Jadi pilihannya adalah ini.  Jika offset terletak dalam 0 ...- 4095, pilih perintah bcmd_call8b dengan kode 0xA0, menempatkan empat bit offset paling signifikan dalam bit perintah yang paling tidak signifikan.  Pada saat yang sama, untuk mesin byte, kode untuk salah satu dari perintah bcmd_call8b0 adalah bcmd_call8b15. <br><br>  Jika offset mundur lebih besar dari atau sama dengan 4095, maka kami menentukan dimensi offset mana yang ditempatkan dan menggunakan perintah yang sesuai dari call16 / 32/64.  Harus diingat bahwa offset untuk tim-tim ini ditandatangani.  Mereka dapat menyebabkan maju dan mundur.  Misalnya, panggilan16 dapat memanggil jarak 32767 di kedua arah. <br><br>  Inilah implementasinya sebagai hasilnya: <br><br>  <b>$ kompilasi</b> <br><br>  Kompilasi sebuah kata.  Sebagai parameter, ambil alamat entri kamus dari kata yang dikompilasi.  Bahkan, ia memeriksa flag f_code, menghitung alamat kode (cfa), dan memanggil compile_b atau compile_c (jika flag diatur). <br><br>  <b>compile_c</b> <br><br>  Mengkompilasi perintah byte.  Kata paling sederhana di sini dijelaskan di benteng seperti ini: <br><br><pre> <code class="cpp hljs">: compile_c c@ c, ;</code> </pre> <br>  <b>compile_b</b> <br>  Dibutuhkan alamat bytecode pada stack dan mengkompilasi panggilannya. <br><br>  <b>test_bv</b> <br><br>  Dibutuhkan offset dari tumpukan (dengan tanda) dan menentukan kedalaman bit mana yang digunakan (1, 2, 4, atau 8 byte).  Mengembalikan nilai 0, 1, 2, atau 3. Dengan menggunakan kata ini, Anda dapat menentukan mana yang akan digunakan dari perintah call16 / 32/64.  Kata ini akan berguna ketika menyusun angka (pilihan dari lit8 / 16/32/64). <br><br>  Omong-omong, Anda dapat memulai sistem dan "bermain-main" di konsol benteng dengan kata-kata ini.  Sebagai contoh: <br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; 222 test_bv ( 2 ): 222 1 &gt; drop drop ( 0 ): &gt; 1000000 test_bv ( 2 ): 1000000 2 &gt; drop drop ( 0 ): &gt; -33 test_bv ( 2 ): -33 0 &gt;</code> </pre> <br>  <b>test_bvc</b> <br><br>  Dibutuhkan offset (dengan tanda) dari tumpukan dan menentukan perintah panggilan mana yang digunakan.  Bahkan, ia memeriksa untuk melihat apakah offset terletak dalam 0 ... -4095, dan mengembalikan 0. Dalam hal ini, jika tidak ada hit dalam interval ini, ia memanggil test_bv. <br><br><div class="spoiler">  <b class="spoiler_title">Hanya itu yang diperlukan untuk mengkompilasi perintah.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : test_bvc dup <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;= over FFF &lt;= <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ... item test_bvc test_bvc: .byte b_dup, b_neg .byte b_num0 .byte b_gteq .byte b_over, b_neg .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0xFFF</span></span> .byte b_lteq .byte b_and .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_num0 .byte b_exit item test_bv test_bv: .byte b_dup, b_lit8, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, b_gteq, b_over, b_lit8, <span class="hljs-number"><span class="hljs-number">0x7f</span></span>, b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - ., b_num0 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0x8001</span></span> .byte b_gteq .byte b_over .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0x7ffe</span></span> .byte b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_num1, b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_dup .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80000002</span></span> .byte b_gteq .byte b_over .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x7ffffffd</span></span> .byte b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_num2, b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_num3 .byte b_exit #  - item compile_c compile_c: .byte b_get8 callb c_8 .byte b_exit #   - item compile_b compile_b: callb here .byte b_num2, b_add .byte b_sub callb test_bvc .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop .byte b_neg .byte b_dup .byte b_lit8, <span class="hljs-number"><span class="hljs-number">8</span></span> .byte b_rshift .byte b_lit8, b_call8b0 .byte b_or callb c_8 callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_drop, b_lit8, b_call16 callb c_8 .byte b_wm callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_lit8, b_call32 callb c_8 .byte b_num3, b_sub callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_lit8, b_call64 callb c_8 .byte b_lit8, <span class="hljs-number"><span class="hljs-number">7</span></span>, b_sub callb c_64 .byte b_exit #: $compile dup c@ <span class="hljs-number"><span class="hljs-number">0x80</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cfa compile_c <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cfa compile_b then ; item <span class="hljs-string"><span class="hljs-string">"$compile"</span></span> _compile: .byte b_dup, b_get8, b_lit8, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - ., b_cfa callb compile_c .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_cfa callb compile_b .byte b_exit</code> </pre><br></div></div><br>  Sekarang kita perlu mengkompilasi nomornya. <br><br><h4>  Menyusun angka (literal) </h4><br>  Menulis seluruh subtitle, siap untuk secara khusus menggambarkan kompilasi dari literal, tetapi ternyata tidak ada yang istimewa untuk dijelaskan :) <br><br>  Kami telah melakukan separuh pekerjaan dalam kata test_bv.  Tetap hanya untuk memanggil test_bv, dan, tergantung pada hasilnya, kompilasi lit8 / 16/32/64, dan kemudian nilai yang sesuai dari ukuran 1, 2, 4 atau 8 byte. <br><br><div class="spoiler">  <b class="spoiler_title">Kami melakukan ini dengan mendefinisikan kata compile_n</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#   item compile_n compile_n: callb test_bv .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop, b_lit8, b_lit8 callb c_8 callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_drop, b_lit8, b_lit16 callb c_8 callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_lit8, b_lit32 callb c_8 callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_lit8, b_lit64 callb c_8 callb c_64 .byte b_exit</code> </pre></div></div><br><h4>  Ubah penerjemah </h4><br>  Semuanya siap mengkompilasi perintah dan literal.  Sekarang perlu dibangun ke dalam interpreter.  Modifikasi ini sederhana.  Di mana perintah dieksekusi, tambahkan cek negara.  Jika status bukan nol dan kata itu tidak berisi flag langsung, alih-alih eksekusi Anda harus memanggil $ compile.  Dan tentang hal yang sama dilakukan di mana nomor tersebut diperoleh dari input stream.  Jika statusnya nol, tinggalkan saja nomornya di tumpukan, dan jika tidak, panggil compile_n. <br><br><div class="spoiler">  <b class="spoiler_title">Ini penerjemahnya</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_mrot .byte b_drop .byte b_drop callb state .byte b_get .byte b_qnbranch8, irpt_execute - . #  <span class="hljs-number"><span class="hljs-number">0</span></span>,    .byte b_dup, b_get8, b_lit8, f_immediate, b_and #  immediate    .byte b_qbranch8, irpt_execute - . #    -   #   ! callb _compile .byte b_branch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . irpt_execute: .byte b_cfa #  ,    (state = <span class="hljs-number"><span class="hljs-number">0</span></span>  immediate  ) .byte b_execute .byte b_branch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_drop .byte b_over, b_over .byte b_numberq # ,    .byte b_qbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . #     <span class="hljs-number"><span class="hljs-number">0</span></span>, ,      <span class="hljs-number"><span class="hljs-number">3</span></span> .byte b_type #    .byte b_strp #   .byte <span class="hljs-number"><span class="hljs-number">19</span></span> #     .ascii <span class="hljs-string"><span class="hljs-string">" : word not found!\n"</span></span> .byte b_quit #    <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_nip, b_nip #  ,     ( b_over, b_over) #   -   callb state # ,    .byte b_get .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . #   -     ;   -   #   callb compile_n <span class="hljs-number"><span class="hljs-number">2</span></span>: #       .byte b_depth #    .byte b_zlt # ,   <span class="hljs-number"><span class="hljs-number">0</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>&lt;) .byte b_qnbranch8, interpret_ok - . #   ,    ,   .byte b_strp #    .byte <span class="hljs-number"><span class="hljs-number">14</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\nstack fault!\n"</span></span> .byte b_quit #    interpret_ok: .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre></div></div><br>  Sekarang kita selangkah lagi dari kompiler ... <br><br><h4>  Definisi kata-kata baru (kata ":") </h4><br>  Sekarang, jika kita mengatur variabel status ke nilai bukan nol, proses kompilasi akan dimulai.  Tetapi hasilnya akan sia-sia, kita tidak bisa memenuhinya, atau bahkan menemukannya di memori.  Untuk memungkinkannya melakukan semua ini, perlu untuk memformat hasil kompilasi dalam bentuk artikel kamus.  Untuk melakukan ini, sebelum mengaktifkan mode kompilasi, Anda perlu membuat judul untuk kata tersebut. <br><br>  Header harus berisi bendera, bidang komunikasi, dan nama.  Di sini kita memiliki kisah yang akrab - bidang komunikasi dapat 1, 2, 4, atau 8 byte.  Mari kita buat kata compile_1248, yang akan membantu kita membentuk bidang komunikasi semacam itu.  Dibutuhkan dua angka pada stack - offset dan nilai yang dihasilkan oleh perintah test_bv. <br><br><div class="spoiler">  <b class="spoiler_title">compile_1248</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#    , ,     #     ,  test_dv item compile_1248 compile_1248: .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . .byte b_drop callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: callb c_64 .byte b_exit</code> </pre></div></div><br>  Sekarang buat kata $ create.  Ini akan bermanfaat bagi kita lebih dari sekali.  Anda dapat menggunakannya kapan pun Anda perlu membuat judul untuk entri kamus.  Ini akan mengambil dua nilai dari tumpukan - alamat nama kata yang dibuat dan panjangnya.  Setelah mengeksekusi kata ini, alamat entri kamus yang dibuat akan muncul di tumpukan. <br><br><div class="spoiler">  <b class="spoiler_title">$ buat</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : $create here current @ @ here - test_bv dup c, compile_1248 -rot str, current @ ! <span class="hljs-string"><span class="hljs-string">' var0 here c!; item "$create" create: callb here callb current .byte b_get, b_get callb here .byte b_sub callb test_bv .byte b_dup callb c_8 callb compile_1248 .byte b_mrot callb c_str #       callb current .byte b_get, b_set #     - var0,      here #   ,    -    ,    #     ,     #    1 allot   ,   .byte b_lit8, b_var0 callb here .byte b_set8 .byte b_exit</span></span></code> </pre> </div></div><br>  Kata berikutnya akan mengambil nama kata baru dari aliran input menggunakan kata blword dan memanggil $ create, membuat kata baru dengan nama yang ditentukan. <br><br><div class="spoiler">  <b class="spoiler_title">buat_in</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> item <span class="hljs-string"><span class="hljs-string">"create_in"</span></span> create_in: .byte b_blword .byte b_dup .byte b_qbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp #   (     ) .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> #     <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\ncreate_in - name not found!\n"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: callb create .byte b_exit</code> </pre></div></div><br>  Dan akhirnya, buatlah kata ":".  Ini akan membuat kata baru menggunakan create_in dan mengatur mode kompilasi, itu tidak diinstal.  Dan jika dipasang, itu memberikan kesalahan.  Kata ":" akan memiliki tanda langsung. <br><br><div class="spoiler">  <b class="spoiler_title">kata:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : : create_in <span class="hljs-number"><span class="hljs-number">1</span></span> state dup @ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .<span class="hljs-string"><span class="hljs-string">" : - no execute state!"</span></span> then ! <span class="hljs-number"><span class="hljs-number">110</span></span> ; immediate item <span class="hljs-string"><span class="hljs-string">":"</span></span>, f_immediate colon: callb create_in .byte b_num1 callb state .byte b_dup .byte b_get .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . .byte b_strp #   (     ) .byte <span class="hljs-number"><span class="hljs-number">4f</span></span> - <span class="hljs-number"><span class="hljs-number">3f</span></span> #     <span class="hljs-number"><span class="hljs-number">3</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\n: - no execute state!\n"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_set .byte b_lit8, <span class="hljs-number"><span class="hljs-number">110</span></span> .byte b_exit</code> </pre></div></div><br>  Jika seseorang melihat kode tersebut, maka dia melihat bahwa kata ini melakukan sesuatu yang lain :) <br><br>  Dan ini 110 ??? <br><br>  Ya, kata ini juga mendorong angka 110 ke tumpukan, dan itulah sebabnya.  Ketika dikompilasi, berbagai konstruksi harus menjadi satu kesatuan.  Misalnya, setelah jika harus maka.  Dan kata yang dibuat menggunakan ":" harus diakhiri dengan ";".  Untuk memeriksa kondisi ini, kata-kata khusus dari kompiler meletakkan nilai-nilai tertentu pada tumpukan dan memeriksa keberadaannya.  Misalnya, kata ":" memberi nilai 110, dan kata ";"  memeriksa apakah 110 berada di atas tumpukan. Jika ini bukan masalahnya, maka ini merupakan kesalahan.  Jadi, struktur kontrol tidak berpasangan. <br><br>  Pemeriksaan semacam itu dilakukan dalam semua kata-kata seperti kompiler, oleh karena itu, kami akan membuat kata khusus untuk ini - "Pasangan?"  Ini akan mengambil dua nilai dari tumpukan, dan melemparkan kesalahan jika tidak sama. <br><br>  Juga, dengan kata-kata seperti itu, Anda sering harus memeriksa bahwa mode kompilasi diatur.  Mari kita membuat kata "Negara" untuk ini. <br><br><div class="spoiler">  <b class="spoiler_title">"pasangan" negara</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#: ?pairs = ifnot <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> then .<span class="hljs-string"><span class="hljs-string">" \nerror: no pairs operators"</span></span> quit then ; item <span class="hljs-string"><span class="hljs-string">"?pairs"</span></span> .byte b_eq, b_qbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\nerror: no pairs operators"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_exit #: ?state state @ <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span><span class="hljs-string"><span class="hljs-string">" error: no compile state"</span></span> then ; item <span class="hljs-string"><span class="hljs-string">"?state"</span></span> callb state .byte b_get, b_zeq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\nerror: no compile state"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_exit</code> </pre></div></div><br>  Itu saja!  Kami tidak akan mengkompilasi apa pun di assembler secara manual :) <br><br>  Tetapi sampai akhir, kompiler belum ditulis, jadi pada awalnya Anda harus menggunakan beberapa metode yang tidak biasa ... <br><br><h4>  Mari kita siap mengkompilasi kompiler yang dibuat dengan kompiler yang dibuat </h4><br>  Untuk memulai, Anda dapat memeriksa bagaimana kata ":" bekerja dengan menyusun sesuatu yang sederhana.  Mari kita buat, misalnya, kata: <br><br><pre> <code class="cpp hljs">: ^<span class="hljs-number"><span class="hljs-number">2</span></span> dup * ;</code> </pre> <br>  Kata ini mengkuadratkan.  Tetapi kita tidak memiliki kata ";" apa yang harus dilakukan?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menulis kata keluar sebagai gantinya, dan itu mengkompilasi. </font><font style="vertical-align: inherit;">Dan kemudian matikan mode kompilasi dengan kata "[" dan turunkan nilai 110:</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : ^2 dup * exit [ drop ( 0 ): &gt; 4 ^2 ( 1 ): 16 &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu berhasil! </font><font style="vertical-align: inherit;">Mari kita </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lanjutkan ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kita akan terus menulis benteng di benteng, kita perlu memikirkan di mana kode sumber benteng akan, dan kapan harus menyusun. </font><font style="vertical-align: inherit;">Mari kita buat pilihan termudah. </font><font style="vertical-align: inherit;">Kode sumber benteng akan ditempatkan dalam kode sumber di assembler, sebagai string teks. </font><font style="vertical-align: inherit;">Dan agar ia tidak mengambil terlalu banyak ruang, kami akan menempatkannya segera setelah alamat di sini, di area memori bebas. </font><font style="vertical-align: inherit;">Tentu saja, kita memerlukan area ini untuk kompilasi, tetapi kecepatan "pelarian" interpretasi akan lebih besar daripada kebutuhan akan memori baru. </font><font style="vertical-align: inherit;">Dengan demikian, kode yang dikompilasi akan mulai menimpa sumber di benteng, mulai dari awal, tetapi kita tidak akan memerlukannya lagi, karena kita telah membaca dan menggunakan bagian ini.</font></font><br><br><pre> <code class="cpp hljs">fcode: .ascii <span class="hljs-string"><span class="hljs-string">" 2 2 + . quit"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi, di awal garis ada baiknya menempatkan selusin spasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat ini bekerja, kami mengubah bytecode awal sehingga tib, #tib arahkan ke baris ini. </font><font style="vertical-align: inherit;">Pada akhirnya ada berhenti untuk memasuki baris perintah normal sistem.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memulai bytecode telah menjadi seperti ini</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">start: .byte b_call16 .word forth - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word last_item - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word context - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_set .byte b_call16 .word vhere - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_dup .byte b_call16 .word h - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word definitions - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word tib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_lit16 .word fcode_end - fcode .byte b_call16 .word ntib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word interpret - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_quit</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luncurkan! </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth 4 ( 0 ): &gt;</code> </pre><br>  Hebat! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan sekarang ... </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kompilasi kompiler dengan kompiler </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, kita menulis kode di baris fcode. </font><font style="vertical-align: inherit;">Hal pertama yang harus dilakukan, tentu saja, adalah kata ";".</font></font><br><br><pre> <code class="cpp hljs">: ; ?state <span class="hljs-number"><span class="hljs-number">110</span></span> ?pairs lit8 [ blword <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> find cfa c@ c, ] c, <span class="hljs-number"><span class="hljs-number">0</span></span> state ! <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> [ current @ @ dup c@ <span class="hljs-number"><span class="hljs-number">96</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swap c! drop</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya akan membuat beberapa penjelasan. </font></font><br><br><pre> <code class="plaintext hljs">?state 110 ?pairs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di sini kita memeriksa bahwa keadaan kompilasi benar-benar diatur, dan 110 ada di stack. Jika tidak, akan ada interupsi karena kesalahan. </font></font><br><br><pre> <code class="plaintext hljs">lit8 [ blword exit find cfa c@ c, ]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini kita kompilasi perintah yang menyala dengan bytecode dari perintah keluar. </font><font style="vertical-align: inherit;">Saya harus masuk ke mode eksekusi, menemukan kata keluar, mendapatkan alamat eksekusi, dan mendapatkan kode perintah dari sana. </font><font style="vertical-align: inherit;">Semua ini diperlukan karena kami belum memiliki kata kompilasi. </font><font style="vertical-align: inherit;">Jika ya, alih-alih semua ini, itu akan cukup untuk hanya menulis "kompilasi keluar" :)</font></font><br><br><pre> <code class="plaintext hljs">c, 0 state !</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini akan mengkompilasi perintah keluar ketika kata ";" dijalankan, dan kemudian mode interpretasi akan ditetapkan. </font><font style="vertical-align: inherit;">Kata "[" tidak dapat digunakan di sini, karena memiliki tanda langsung dan dieksekusi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sekarang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi kita perlu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengkompilasi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perintah tersebut ke dalam kata ";" sehingga mereka mematikan mode kompilasi.</font></font><br><br><pre> <code class="plaintext hljs">exit [</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami sudah mengalami ini. </font><font style="vertical-align: inherit;">Kata keluar dikompilasi dan mode kompilasi dimatikan. </font><font style="vertical-align: inherit;">Semuanya, kata ";" </font><font style="vertical-align: inherit;">dikompilasi. </font><font style="vertical-align: inherit;">Dan apa lagi yang tertulis di sana lebih jauh?</font></font><br><br><pre> <code class="plaintext hljs">current @ @ dup c@ 96 or swap c! drop</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda perlu mengatur bendera langsung untuk kata baru. </font><font style="vertical-align: inherit;">Inilah yang dilakukan oleh urutan yang ditunjukkan, kecuali untuk kata drop. </font><font style="vertical-align: inherit;">Kata drop menghapus 110 yang dilupakan yang menempatkan kata ":" di awal penciptaan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang semuanya! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami meluncurkan dan mencoba.</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : ^3 dup dup * * ; ( 0 ): &gt; 6 ^3 . 216 ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada! </font><font style="vertical-align: inherit;">Ini adalah kata pertama yang dikompilasi oleh kompiler kami “untuk nyata”. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi kita masih tidak memiliki kondisi, tidak ada loop, dan banyak lagi ... Mari kita mulai dengan kata kecil tapi sangat penting untuk membuat kompiler: segera. </font><font style="vertical-align: inherit;">Ini menetapkan atribut langsung pada kata terakhir yang dibuat:</font></font><br><br><pre> <code class="cpp hljs">: immediate current @ @ dup c@ <span class="hljs-number"><span class="hljs-number">96</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swap c! ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urutan yang akrab :) Baru-baru ini, ini ditulis secara manual, ini tidak akan diperlukan lagi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang mari kita buat beberapa kata kecil tapi berguna:</font></font><br><br><pre> <code class="cpp hljs">: hex <span class="hljs-number"><span class="hljs-number">16</span></span> base ! ; : decimal <span class="hljs-number"><span class="hljs-number">10</span></span> base ! ; : bl <span class="hljs-number"><span class="hljs-number">32</span></span> ; : tab <span class="hljs-number"><span class="hljs-number">9</span></span> ; : lf <span class="hljs-number"><span class="hljs-number">10</span></span> ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heks dan desimal mengatur sistem angka yang sesuai. </font><font style="vertical-align: inherit;">Sisanya adalah konstanta untuk mendapatkan kode karakter yang sesuai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami juga membuat kata untuk menyalin garis dengan counter </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:: cmove di atas c @ 1+ move; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan sekarang kita akan terlibat dalam kondisi. </font><font style="vertical-align: inherit;">Secara umum, jika ada kompilasi kata, itu akan terlihat seperti ini:</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ?state compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate : then ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs dup here swap - swap c! ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua kata-kata ini di awal memverifikasi bahwa mode kompilasi diatur dan menghasilkan kesalahan jika ini tidak terjadi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata if mengkompilasi cabang kondisional, cadangan byte untuk parameter perintah cabang kondisional, dan mendorong alamat byte tersebut ke stack. Kemudian ia mendorong nilai kontrol 111 ke stack. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata itu kemudian memeriksa keberadaan nilai kontrol 111, dan kemudian menulis offset ke alamat di stack.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan segera buat kata lain. </font><font style="vertical-align: inherit;">Itu pada awalnya mengkompilasi perintah lompatan tanpa syarat untuk memotong cabang lain. </font><font style="vertical-align: inherit;">Dengan cara yang sama seperti jika, offset transisi belum diketahui, ia hanya dicadangkan, dan alamatnya didorong ke stack. </font><font style="vertical-align: inherit;">Nah, setelah itu, hal yang persis sama dilakukan seperti pada saat itu: alamat transisi tangkapan diatur ke cabang yang lain. </font><font style="vertical-align: inherit;">Sesuatu lebih sulit untuk dijelaskan daripada kode itu sendiri :) Jika seseorang ingin mengetahuinya secara menyeluruh, lebih baik untuk menguraikan pekerjaan dari kode yang disederhanakan secara maksimal:</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, ; immediate : then dup here swap - swap c! ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nah, sekarang kita memprogram kode asli. </font><font style="vertical-align: inherit;">Karena kami tidak memiliki kompilasi kata, kami menerapkan trik yang sama seperti ketika membuat kata ";":</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ?state lit8 [ blword ?nbranch8 find cfa c@ c, ] c, here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate : then ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs dup here swap - swap c! ; immediate : <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs lit8 [ blword branch8 find cfa c@ c, ] c, here <span class="hljs-number"><span class="hljs-number">0</span></span> c, swap dup here swap - swap c! <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang Anda dapat mencoba mengkompilasi kondisi tersebut. </font><font style="vertical-align: inherit;">Mari kita membuat, misalnya, kata yang mencetak 1000 jika ada 5 di stack, dan 0 dalam kasus lain:</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test 5 = if 1000 . else 0 . then ; ( 0 ): &gt; 22 test 0 ( 0 ): &gt; 3 test 0 ( 0 ): &gt; 5 test 1000 ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jelas bahwa hasil seperti itu tidak langsung bekerja, ada kesalahan, ada debugging. </font><font style="vertical-align: inherit;">Tetapi pada akhirnya, kondisinya berhasil!</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penyimpangan kecil tentang panjang perintah transisi</font></font></b> <div class="spoiler_text">  ,       ,      127 .       . ,  ,       .     ,   ,        .   8   ,    40  127    .   ,       ? <br><br>   .   —    16 . <br><br>      . 16        —    . ,      ,     call,      . , 11     ( 1023   ).         300  1000  .      ,        .      3  ,     8    .    :   (?nbranch),    (?branch)   (branch).  — 24 . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memiliki kondisi, hidup menjadi lebih mudah :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita membuat kata. "(Dot-quote). Ini menampilkan teks yang ditentukan ketika dieksekusi. Digunakan dengan cara ini:</font></font><br><br><pre> <code class="cpp hljs">.<span class="hljs-string"><span class="hljs-string">"    "</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat menggunakan kata ini hanya dalam mode kompilasi. </font><font style="vertical-align: inherit;">Ini akan menjadi jelas setelah kami menganalisis perangkat kata ini:</font></font><br><br><pre> <code class="cpp hljs">: .<span class="hljs-string"><span class="hljs-string">" ?state 34 word dup if lit8 [ blword (."</span></span>) find cfa c@ c, ] c, str, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop then ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata ini dieksekusi dalam mode kompilasi. Dibutuhkan string dari input stream hingga tanda kutip (34 kata). Jika baris tidak dapat diperoleh, itu tidak menghasilkan apa-apa. Meskipun, di sini akan lebih baik untuk mendapatkan diagnosis. Tetapi untuk keluaran baris, kata ini persis seperti yang kita lakukan :) Jika perlu, maka Anda dapat mendefinisikan kembali kata ini, sudah dengan diagnostik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika dimungkinkan untuk mendapatkan string, perintah byte (. ") Dikompilasi, dan kemudian string diterima. Perintah byte ini (tanda kutip titik-titik dalam tanda kurung), ketika dieksekusi, menampilkan string yang dikompilasi di belakang byte perintah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Periksa.</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test ."    " ; ( 0 ): &gt; test     ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan akhirnya, mari kita buat kompilasi kata. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jelas bahwa dalam mode kompilasi kata ini harus mengambil nama kata berikutnya dari aliran, temukan di kamus. Dan kemudian akan ada opsi: itu bisa berupa perintah byte, atau bisa juga kata yang ditulis dalam kode byte. Kata-kata ini harus dikompilasi dengan berbagai cara. Oleh karena itu, kita akan membuat dua kata tambahan: "(compile_b)" dan "(compile_c)". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_b) akan mengkompilasi perintah panggilan untuk memanggil bytecode. Parameter akan menjadi kata 64-bit - alamat bytecode dipanggil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_c) akan mengkompilasi perintah byte. Dengan demikian, parameter dari perintah ini akan menjadi satu byte - kode perintah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nah, kata kompilasi itu sendiri akan mengkompilasi (compile_b) atau (compile_c) dengan parameter yang sesuai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai dengan (compile_c),seperti dengan yang paling sederhana:</font></font><br><br><pre> <code class="cpp hljs">: (compile_c) r&gt; dup c@ swap <span class="hljs-number"><span class="hljs-number">1</span></span>+ &gt;rc, ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terlepas dari kesederhanaannya, pertama-tama kita menulis kata dalam bytecode, yang dengan sendirinya memiliki parameter. Karena itu, saya akan berkomentar. Setelah memasukkan (compile_c), alamat kembali terletak di tumpukan kembali, karena tidak basi. Ini adalah alamat byte berikutnya setelah perintah panggilan. Situasi pada saat panggilan ditunjukkan di bawah ini. A0 - kode perintah panggilan, XX - parameter perintah panggilan - alamat panggilan (offset) dari kode byte kata (compile_c).</font></font><br><br><img src="https://habrastorage.org/webt/vj/jh/kh/vjjhkhqa7e35ygxdzclv0lf4-pw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alamat pengirim menunjukkan byte NN. Biasanya ada kode untuk byte perintah berikutnya. Tetapi kata kita memiliki parameter, jadi NN hanyalah parameter dari kata "(compile_c)", yaitu, kode byte dari perintah yang dikompilasi. Anda perlu membaca byte ini dan mengubah alamat pengirim dengan menggerakkannya maju ke perintah byte berikutnya. Ini dilakukan dengan urutan “r&gt; dup c @ swap 1+&gt; r”. Urutan ini menarik alamat pengirim dari tumpukan kembali ke tumpukan reguler, mengambil satu byte darinya, menambahkan satu padanya (mengembalikan alamat), dan mengembalikannya kembali ke tumpukan kembali. Perintah yang tersisa "c," mengkompilasi kode perintah byte yang diperoleh dari parameter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_b) tidak jauh lebih rumit:</font></font><br><br><pre> <code class="cpp hljs">: (compile_b) r&gt; dup @ swap <span class="hljs-number"><span class="hljs-number">8</span></span> + &gt;r compile_b ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semuanya sama di sini, hanya parameter 64-bit yang dibaca, dan kata compile_b digunakan untuk mengkompilasi kata, yang telah kita buat untuk kompiler. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan sekarang kata kompilasi. </font><font style="vertical-align: inherit;">Seperti yang sudah dibahas, ia membaca nama kata, menemukannya dan mengkompilasi salah satu dari dua perintah sebelumnya. </font><font style="vertical-align: inherit;">Saya tidak akan berkomentar tentang itu, kami telah menerapkan dan membongkar semua konstruksi yang digunakan.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompilasi kata</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">: compile blword over over find dup <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dup c@ <span class="hljs-number"><span class="hljs-number">128</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cfa c@ (compile_b) [ blword (compile_c) find cfa , ] c, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cfa (compile_b) [ blword (compile_b) find cfa , ] , then drop drop <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop .<span class="hljs-string"><span class="hljs-string">" compile: "</span></span> type .<span class="hljs-string"><span class="hljs-string">" - not found"</span></span> then ; immediate</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk memeriksa kata yang dibuat, kami membuat, dengan bantuannya, kata ifnot. </font></font><br><br><pre> <code class="cpp hljs">: ifnot ?state compile ?branch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lihat itu! </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test 5 = ifnot 1000 . else 0 . then ; ( 0 ): &gt; 22 test 1000 ( 0 ): &gt; 3 test 1000 ( 0 ): &gt; 5 test 0 ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semuanya baik-baik saja! Dan inilah saatnya untuk melakukan siklus ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada artikel ini kita akan membuat siklus dengan suatu syarat. Benteng memiliki dua opsi untuk satu siklus dengan suatu syarat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opsi pertama adalah mulai ... sampai. Kata sampai menghilangkan nilai dari tumpukan, dan jika tidak sama dengan nol, siklus berakhir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilihan kedua adalah mulai ... sementara ... ulangi. Dalam hal ini, pemeriksaan terjadi ketika kata saat dieksekusi. Loop keluar jika nilai pada stack adalah nol. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siklus di benteng dibuat dengan cara yang sama dengan kondisi - pada transisi bersyarat dan tanpa syarat. Saya membawa kode, komentar, saya pikir, tidak diperlukan.</font></font><br><br><pre> <code class="cpp hljs">: begin ?state here <span class="hljs-number"><span class="hljs-number">112</span></span> ; immediate : until ?state <span class="hljs-number"><span class="hljs-number">112</span></span> ?pairs compile ?nbranch8 here - c, ; immediate : <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ?state <span class="hljs-number"><span class="hljs-number">112</span></span> ?pairs compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">113</span></span> ; immediate : repeat ?state <span class="hljs-number"><span class="hljs-number">113</span></span> ?pairs swap compile branch8 here - c, dup here swap - swap c! ; immediate</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hari ini kami selesai dengan kompiler. </font><font style="vertical-align: inherit;">Hanya ada sedikit yang tersisa. </font><font style="vertical-align: inherit;">Dari fungsi-fungsi kunci yang belum diimplementasikan hanya siklus dengan penghitung. </font><font style="vertical-align: inherit;">Dan itu juga layak untuk membuat perintah loop keluar. </font><font style="vertical-align: inherit;">Kami akan melakukannya lain kali. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi kami tidak mengalami perintah siklus! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami melakukan ini dengan menulis kata kata standar. </font><font style="vertical-align: inherit;">Kami akhirnya harus melihat kamus kami. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melakukan ini, pada awalnya, kami membuat kata tautan @. </font><font style="vertical-align: inherit;">Ini akan mengekstrak bidang komunikasi dari entri kamus (diimbangi dengan entri sebelumnya). </font><font style="vertical-align: inherit;">Seperti yang kita ingat, bidang komunikasi dapat memiliki ukuran yang berbeda: 1, 2, 4 atau 8 byte. </font><font style="vertical-align: inherit;">Kata ini akan mengambil tumpukan alamat entri kamus, dan mengembalikan dua nilai: alamat bidang nama dan nilai bidang komunikasi.</font></font><br><br><pre> <code class="cpp hljs">: link@ dup c@ <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> swap <span class="hljs-number"><span class="hljs-number">1</span></span>+ swap dup <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">1</span></span>+ swap c@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dup <span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">2</span></span> + swap w@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">4</span></span> + swap i@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop dup <span class="hljs-number"><span class="hljs-number">8</span></span> + swap @ then then then ;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan sekarang Anda dapat membuat kata-kata: </font></font><br><br><pre> <code class="cpp hljs">: words context @ @ <span class="hljs-number"><span class="hljs-number">0</span></span> begin + dup link@ swap count type tab emit dup <span class="hljs-number"><span class="hljs-number">0</span></span>= until drop drop ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meluncurkan ... </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; words words link@ repeat while until begin ifnot compile (compile_b) (compile_c) ." else then if cmove tab bl decimal hex immediate ; bye ?state ?pairs : str, interpret $compile compile_b compile_n compile_1248 compile_c c, w, i, , allot here h test_bv test_bvc [ ] state .s &gt;in #tib tib . #&gt; #s 60 # hold span holdpoint holdbuf base quit execute cfa find word blword var16 var8 (.") (") count emit expect type lshift rshift invert xor or and &gt;= &lt;= &gt; &lt; = 0&gt; 0&lt; 0= bfind compare syscall fill move rpick r@ r&gt; &gt;r -! +! i! i@ w! w@ c! c@ ! @ depth roll pick over -rot rot swap drop dup abs /mod mod / * - + 1+ 1- exit ?nbranch16 ?nbranch8 ?branch16 ?branch8 branch16 branch8 call8b0 call64 call32 call16 call8f lit64 lit32 lit16 lit8 8 4 3 2 1 0 context definitions current forth ( 0 ): &gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini dia, kekayaan kita :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya ingin mengatakan segalanya ... tidak, mari kita tetap memungkinkan untuk menentukan file dengan program benteng untuk kompilasi dan eksekusi sebagai parameter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami membuat perintah syscall untuk membuka, menutup, dan membaca file. </font><font style="vertical-align: inherit;">Kami mendefinisikan konstanta yang diperlukan untuknya.</font></font><br><br><pre> <code class="cpp hljs">: file_open <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> syscall ; : file_close <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> syscall ; : file_read <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> syscall ; : file_O_RDONLY <span class="hljs-number"><span class="hljs-number">0</span></span> ; : file_O_WRONLY <span class="hljs-number"><span class="hljs-number">1</span></span> ; : file_O_RDWR <span class="hljs-number"><span class="hljs-number">3</span></span> ;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang Anda dapat membuat kata awal _start: </font></font><br><br><pre> <code class="cpp hljs">: _start <span class="hljs-number"><span class="hljs-number">0</span></span> pick <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> pick file_O_RDONLY <span class="hljs-number"><span class="hljs-number">0</span></span> file_open dup <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .\<span class="hljs-string"><span class="hljs-string">" error: \" . quit then dup here 32 + 32768 file_read dup 0&lt; if .\" error: \" . quit then swap file_close drop #tib ! here 32 + tib ! 0 &gt;in ! interpret then ;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata ini akan dimuat dari file dan menjalankan program benteng apa pun. </font><font style="vertical-align: inherit;">Lebih tepatnya, penerjemah akan mengeksekusi semua yang ada di file ini. </font><font style="vertical-align: inherit;">Dan mungkin ada, misalnya, kompilasi kata-kata baru dan eksekusi mereka. </font><font style="vertical-align: inherit;">Nama file ditunjukkan oleh parameter pertama saat startup. </font><font style="vertical-align: inherit;">Saya tidak akan merinci, tetapi parameter peluncuran di Linux dilewatkan melalui tumpukan. </font><font style="vertical-align: inherit;">Kata _start akan mencapainya dengan perintah 0 pick (jumlah parameter) dan 2 pick (pointer ke parameter pertama). </font><font style="vertical-align: inherit;">Untuk sistem benteng, nilai-nilai ini berada di luar tumpukan, tetapi Anda bisa mendapatkannya dengan perintah pilih. </font><font style="vertical-align: inherit;">Ukuran file dibatasi hingga 32 KB, sementara tidak ada manajemen memori. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang tinggal menulis di baris fcode di akhir:</font></font><br><br><pre> <code class="cpp hljs">_start quit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat file test.f dan tulis sesuatu di benteng. </font><font style="vertical-align: inherit;">Misalnya, algoritma Euclidean untuk menemukan faktor umum terbesar:</font></font><br><br><pre> <code class="cpp hljs">: NOD begin over over &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> over over &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> swap over - swap <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> over - then repeat drop ; <span class="hljs-number"><span class="hljs-number">23101</span></span> <span class="hljs-number"><span class="hljs-number">44425</span></span> NOD . bye</code> </pre><br>  Kita mulai. <br><br><pre> <code class="plaintext hljs">$ ./forth test.f 1777 Bye! $</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jawabannya benar. </font><font style="vertical-align: inherit;">Kata itu dikompilasi, kemudian dipenuhi. </font><font style="vertical-align: inherit;">Hasilnya ditampilkan, maka perintah bye dieksekusi. </font><font style="vertical-align: inherit;">Jika Anda menghapus dua baris terakhir, kata NOD akan ditambahkan ke kamus dan sistem akan pergi ke baris perintahnya. </font><font style="vertical-align: inherit;">Anda sudah dapat menulis program :-)</font></font><br><br>  Itu saja.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siapa peduli, Anda dapat mengunduh sumber atau biner siap pakai untuk Linux di x86-64 dari Github: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/hal9000cc/forth64</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sumber datang dengan lisensi </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNU GPL v2</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCH v1 - Do What You Want :-)</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437466/">https://habr.com/ru/post/id437466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437454/index.html">Ulasan Arithmometer Felix M.</a></li>
<li><a href="../id437456/index.html">Younger: Ulasan Telepon IP Snom D315 dan D305</a></li>
<li><a href="../id437458/index.html">Registrasi wajib dengan penawaran IMEI harus dibayar</a></li>
<li><a href="../id437460/index.html">32 GB contoh flash drive palsu</a></li>
<li><a href="../id437464/index.html">Harga TypeScript</a></li>
<li><a href="../id437468/index.html">Retropie Dreamcast</a></li>
<li><a href="../id437470/index.html">Beberapa kata sederhana tentang pertahanan rudal</a></li>
<li><a href="../id437472/index.html">Transisi dari kantor ke udalenka: berbagi pengalaman dan peretasan kehidupan</a></li>
<li><a href="../id437474/index.html">Optimalkan kinerja game dengan opsi impor suara Unity</a></li>
<li><a href="../id437476/index.html">Ok Yandex! Di mana Tujuan Jangkauan kami?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>