<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏾 🧖🏻 ❇️ Se concentrer sur la propriété 🎊 👵🏾 👙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remarque traducteur: l'enregistrement est daté du 13 mai 2014, donc certains détails, y compris le code source, peuvent ne pas correspondre à l'état a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Se concentrer sur la propriété</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418735/"><p>  <em>Remarque</em>  <em>traducteur: l'enregistrement est daté du 13 mai 2014, donc certains détails, y compris le code source, peuvent ne pas correspondre à l'état actuel des choses.</em>  <em>La réponse à la question de savoir pourquoi la traduction d'un article aussi long est nécessaire sera la valeur de son contenu pour former une compréhension de l'un des concepts fondamentaux de la langue Rust, comme la maîtrise de la langue.</em> </p><br><p>  Au fil du temps, je suis devenu convaincu qu'il valait mieux abandonner la distinction entre variables locales mutables et immuables dans Rust.  Au moins, beaucoup de gens sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sceptiques</a> à ce sujet.  Je voulais exprimer ma position en public.  Je donnerai divers motifs: philosophiques, techniques et pratiques, ainsi que la défense principale du système actuel.  (Remarque: j'ai vu cela comme Rust RFC, mais j'ai décidé que le ton était meilleur pour un article de blog et je n'ai pas le temps de le réécrire maintenant.) </p><a name="habracut"></a><br><h2 id="poyasnenie">  Explication </h2><br><p>  J'ai écrit cet article de manière assez décisive et je crois que la ligne que je défends sera correcte.  Cependant, si nous ne finissons pas de soutenir le système actuel, ce ne sera pas un désastre ou quelque chose comme ça.  Il a ses avantages, et dans l'ensemble je le trouve assez agréable.  Je pense simplement que nous pouvons l'améliorer. </p><br><h2 id="odnim-slovom">  En un mot </h2><br><p> Je voudrais supprimer la distinction entre les variables locales immuables et mutables et renommer les pointeurs <code>&amp;mut</code> en <code>&amp;my</code> , <code>&amp;only</code> ou <code>&amp;uniq</code> (cela ne <code>&amp;uniq</code> aucune différence pour moi).  Si seulement il n'y avait pas de mot-clé <code>mut</code> . </p><br><h2 id="filosofskiy-motiv">  Motif philosophique </h2><br><p>  La principale raison pour laquelle je veux le faire est parce que je pense que cela rendra le langage plus cohérent et plus facile à comprendre.  Essentiellement, cela nous réorientera de parler de <em>mutabilité</em> pour parler d' <em>utiliser des alias</em> (que j'appellerai «partage», voir ci-dessous). </p><br><p>  La variabilité devient une conséquence de l'unicité: "Vous pouvez toujours changer tout ce à quoi vous avez un accès unique. Les données partagées sont généralement immuables, mais si vous en avez besoin, vous pouvez les changer en utilisant une sorte de type de <code>Cell</code> ." </p><br><p>  En d'autres termes, au fil du temps, il est devenu clair pour moi que des problèmes avec la course aux données et la sécurité de la mémoire surviennent lorsque vous avez à la fois l'utilisation d'alias et la mutabilité.  Une approche fonctionnelle pour résoudre ce problème consiste à éliminer la mutabilité.  L'approche de Rust serait de supprimer l'utilisation d'alias.  Cela nous donne une histoire qui peut être racontée et qui nous aidera à la comprendre. </p><br><p>  Une note sur la terminologie: je pense que nous devrions nous référer à l' <em>utilisation des alias</em> comme <em>séparation</em> <em>ni la «pseudonymisation» ne permet de comprendre les enjeux</em> ).  Dans le passé, nous avons évité cela en raison de ses références multithread.  Cependant, si / lorsque nous mettons en œuvre les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plans de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parallélisation des données</a> que j'ai proposés, cette connotation n'est pas entièrement inappropriée.  En fait, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">étant donné la relation étroite</a> entre la sécurité de la mémoire et la course aux données, je veux vraiment promouvoir cette connotation. </p><br><h2 id="obrazovatelnyy-motiv">  Motif éducatif </h2><br><p>  Je pense que les règles actuelles sont plus difficiles à comprendre qu'elles ne devraient l'être.  Il n'est pas évident, par exemple, que <code>&amp;mut T</code> n'implique aucune propriété partagée.  De plus, la désignation <code>&amp;mut T</code> implique que <code>&amp;T</code> n'implique aucune mutabilité, qui n'est pas entièrement exacte, en raison de types tels que <code>Cell</code> .  Et il est impossible de s'entendre sur comment les appeler (les «liens mutables / immuables» sont les plus courants, mais ce n'est pas tout à fait correct). </p><br><p>  En revanche, un type comme <code>&amp;my T</code> ou <code>&amp;only T</code> semble simplifier l'explication.  Il s'agit d'un <em>lien unique</em> - naturellement, vous ne pouvez pas forcer deux d'entre eux à pointer vers le même endroit.  Et la <em>mutabilité</em> est une chose orthogonale: elle vient de l'unicité, mais elle vaut également pour les cellules.  Et le type <code>&amp;T</code> est juste son contraire, un <em>lien partagé</em> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC PR # 58</a> fournit un certain nombre d'arguments similaires.  Je ne les répéterai pas ici. </p><br><h2 id="prakticheskiy-motiv">  Motif pratique </h2><br><p>  Actuellement, il existe un écart entre les pointeurs empruntés, qui peuvent être partagés ou mutables + uniques, et les variables locales qui sont toujours uniques, mais peuvent être mutables ou immuables.  Le résultat final est que les utilisateurs doivent publier des annonces <code>mut</code> sur des choses qui ne sont pas directement modifiables. </p><br><h3 id="lokalnye-peremennye-ne-mogut-byt-smodelirovany-s-ispolzovaniem-ssylok">  Les variables locales ne peuvent pas être modélisées à l'aide de références </h3><br><p>  Ce phénomène se produit parce que les liens ne sont pas aussi expressifs que les variables locales.  En général, cela empêche l'abstraction.  Permettez-moi de vous donner quelques exemples pour expliquer ce que je veux dire.  Imaginez que j'ai une structure d'environnement qui stocke un pointeur sur un compteur d'erreurs: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span></span> { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre> <br><p>  Maintenant, je peux créer des instances de cette structure (et les utiliser): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_condition { *env.errors += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  OK, imaginez maintenant que je veux séparer le code qui modifie les <code>env.errors</code> une fonction distincte.  Je pourrais penser que puisque la variable <code>env</code> n'est pas déclarée comme mutable, je peux utiliser le lien immuable <code>&amp;</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; helper(&amp;env); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">helper</span></span></span></span>(env: &amp;Env) { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_condition { *env.errors += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  } }</span></span></code> </pre> <br><p>  Mais ce n'est pas le cas.  Le problème est que <code>&amp;Env</code> est un type de propriété partagée ( <em>note du traducteur: comme vous le savez, plus d'une référence d'objet immuable peut exister à la fois</em> ), et donc les <code>env.errors</code> dans un espace qui permet une propriété distincte de l'objet <code>env</code> .  Pour que ce code fonctionne, je dois déclarer <code>env</code> comme mutable et utiliser le lien <code>&amp;mut</code> ( <em>note du traducteur: <code>&amp;mut</code> ) pour dire au compilateur que <code>env</code> est unique en propriété, car une seule référence d'objet mutable peut exister à la fois et la course aux données est exclue, mais <code>mut</code> parce que vous ne pouvez pas créer une référence mutable à un objet immuable</em> ): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; helper(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> env);</code> </pre> <br><p>  Ce problème se pose parce que nous savons que les variables locales sont uniques, mais nous ne pouvons pas mettre ces connaissances dans une référence empruntée sans les rendre mutables. </p><br><p>  Ce problème se produit dans un certain nombre d'autres endroits.  Jusqu'à présent, nous avons écrit à ce sujet de différentes manières, mais je continue d'être hanté par le sentiment que nous parlons d'une pause, qui ne devrait tout simplement pas l'être. </p><br><h3 id="proverka-tipov-primenitelno-k-zamykaniyam">  Vérification de type pour les fermetures </h3><br><p>  Nous avons dû contourner cette limitation en cas de fermeture.  Les fermetures <em>sont généralement</em> ouvertes dans des structures telles que <code>Env</code> , mais pas tout à fait.  C'est parce que je ne veux pas exiger que les variables locales soient déclarées <code>mut</code> si elles sont utilisées via <code>&amp;mut</code> dans une fermeture.  En d'autres termes, prenez du code, par exemple: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { do_something(|| *errors += <span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br><p>  Une expression décrivant la fermeture créera en fait une instance de la structure <code>Env</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClosureEnv</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt; { errors: &amp;uniq &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre> <br><p>  Consultez le lien <code>&amp;uniq</code> .  Ce n'est pas quelque chose que l'utilisateur final peut saisir.  Cela signifie un pointeur "unique mais pas nécessairement modifiable".  Cela est nécessaire pour passer la vérification de type.  Si l'utilisateur tentait d'écrire cette structure manuellement, il devrait écrire <code>&amp;mut &amp;mut usize</code> , ce qui nécessiterait à son tour que le paramètre d' <code>errors</code> soit déclaré comme <code>mut errors: &amp;mut usize</code> . </p><br><h3 id="nezapakovannye-zamykaniya-i-procedury">  Fermetures et procédures déballées </h3><br><p>  Je prédis que cette restriction est un problème pour les fermetures non emballées.  Permettez-moi d'élaborer sur la conception que j'envisageais.  Fondamentalement, l'idée était que l'expression <code>||</code>  est équivalent à un nouveau type structurel qui implémente l'un des traits <code>Fn</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fn</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FnMut</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FnOnce</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); }</code> </pre> <br><p>  Le type exact sera sélectionné en fonction du type attendu, à compter d'aujourd'hui.  Dans ce cas, les consommateurs de fermetures peuvent écrire deux choses: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;&gt;(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: T) { ... }</code> </pre> <br><p>  Nous ... voulons probablement corriger la syntaxe, peut-être ajouter du sucre comme <code>FnMut(usize) -&gt; usize</code> , ou enregistrer | usize |  -&gt; utiliser, etc.  Ce n'est pas si important, il est important que nous passions la fermeture <em>en valeur</em> .  Veuillez noter que conformément aux règles actuelles de DST (Dynamically-Sized Types), il est permis de passer un type par valeur comme argument au <code>FnMut&lt;usize, usize&gt;</code> , donc l'argument <code>FnMut&lt;usize, usize&gt;</code> est un DST valide et n'est pas un problème. </p><br><p>  <em>A part</em> : ce projet n'est pas terminé, et je décrirai tous les détails dans un message séparé. </p><br><p>  Le problème est qu'un lien <code>&amp;mut</code> est nécessaire pour appeler une fermeture.  Étant donné que la fermeture est transmise par valeur, les utilisateurs devront à nouveau écrire <code>mut</code> où il semble hors de propos: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> closure: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = closure.call(<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><p>  C'est le même problème que dans l'exemple <code>Env</code> ci-dessus: ce qui <em>se</em> passe <em>réellement</em> ici, c'est que le <code>FnMut</code> veut juste un lien <em>unique</em> , mais comme il ne fait pas partie du système de type, il demande un lien <em>mutable</em> . </p><br><p>  Maintenant, nous pouvons peut-être contourner cela de différentes manières.  Une option que nous pourrions faire est de <code>||</code>  la syntaxe ne se développerait pas dans un «certain type structurel», mais plutôt dans un «type structurel ou un pointeur vers un type structurel, comme dicté par l'inférence de type».  Dans ce cas, l'appelant pourrait écrire: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = closure.call(<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><p>  Je ne veux pas dire que c'est la fin du monde.  Mais c'est un autre pas en avant dans les distorsions croissantes que nous devons traverser pour maintenir cet écart entre les variables locales et les références. </p><br><h3 id="drugie-chasti-api">  Autres pièces API </h3><br><p>  Je n'ai pas fait d'étude approfondie, mais, bien sûr, cette différence se glisse ailleurs.  Par exemple, pour lire à partir de <code>Socket</code> , j'ai besoin d'un pointeur unique, donc je dois le déclarer mutable.  Par conséquent, parfois cela ne fonctionne pas: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> socket = Socket::new(); socket.read() <span class="hljs-comment"><span class="hljs-comment">// :   </span></span></code> </pre> <br><p>  Naturellement, selon ma suggestion, un tel code fonctionnerait bien.  Vous recevrez toujours un message d'erreur si vous essayez de lire à partir de <code>&amp;Socket</code> , mais il lira alors quelque chose comme "il est impossible de créer un lien unique vers un lien partagé", que je considère personnellement plus compréhensible. </p><br><h2 id="no-razve-nam-ne-nuzhen-mut-dlya-bezopasnosti">  Mais n'avons-nous pas besoin de <code>mut</code> pour la sécurité? </h2><br><p>  Non, pas du tout.  Les programmes Rust seraient également bons si vous déclariez toutes les liaisons comme <code>mut</code> .  Le compilateur est parfaitement capable de suivre les variables locales qui changent à un moment donné - précisément parce qu'elles sont <em>locales</em> à la fonction actuelle.  Ce qui importe vraiment au système de caractères, c'est l'unicité. </p><br><p>  Le sens que je vois dans les règles d'application actuelles de <code>mut</code> , et je ne nierai pas qu'il a de la valeur, c'est avant tout qu'elles aident à déclarer l'intention.  Autrement dit, lorsque je lis le code, je sais quelles variables peuvent être réaffectées.  D'un autre côté, je passe également beaucoup de temps à lire du code C ++ et, franchement, je n'ai jamais remarqué qu'il s'agit d'une pierre d'achoppement majeure.  (Il en va de même pour le temps que j'ai passé à lire du code en Java, JavaScript, Python ou Ruby.) </p><br><p>  Il est également vrai que je trouve parfois des bogues parce que j'ai déclaré la variable comme <code>mut</code> et oublié de la changer.  Je pense que nous pourrions obtenir des avantages similaires avec d'autres contrôles plus agressifs (par exemple, aucune des variables utilisées dans la condition de boucle ne change dans le corps de la boucle).  Personnellement, je ne me souviens pas d'être confronté à la situation inverse: c'est-à-dire que si le compilateur dit que quelque chose doit être mutable, cela signifie toujours que j'ai oublié le mot-clé <code>mut</code> quelque part.  (Réfléchissez: à quand remonte la dernière fois que vous avez répondu à une erreur du compilateur concernant une modification non valide en faisant autre chose que de restructurer le code pour rendre la modification valide?) </p><br><h2 id="alternativy">  Alternatives </h2><br><p>  Je vois trois alternatives au système actuel: </p><br><ol><li>  Celui que j'ai présenté où vous jetez simplement la «mutabilité» et ne suivez que l'unicité. </li><li>  Celui où vous avez trois types de référence: <code>&amp;</code> , <code>&amp;uniq</code> et <code>&amp;mut</code> .  (Comme je l'ai écrit, c'est en fait le système de type que nous avons aujourd'hui, du moins du point de vue d'un vérificateur d'emprunt.) </li><li><p>  Une option plus rigoureuse, dans laquelle les variables non mutantes sont toujours considérées comme séparées.  Cela signifierait que vous auriez à écrire: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> p = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors; <span class="hljs-comment"><span class="hljs-comment">// ,  `p`   ,  `mut`. *p += 1;</span></span></code> </pre> <br><p>  Vous devez déclarer <code>p</code> comme <code>mut</code> , car sinon la variable serait considérée comme distincte, même s'il s'agit d'une variable locale, et donc la modification de <code>*p</code> pas autorisée.  Ce qui est étrange dans ce schéma, c'est que la variable locale N'AUTORISE PAS la propriété séparée, et nous le savons avec certitude, car lorsque vous essayez de créer son alias, elle se déplacera, le destructeur démarrera dessus, etc.  Autrement dit, nous avons toujours le concept de «propriété», qui est différent de «ne permet pas la propriété séparée». </p><br><p>  D'un autre côté, si nous décrivions ce système, en disant que la mutabilité est héritée via des pointeurs <code>&amp;mut</code> , sans même bégayer sur la propriété partagée, cela pourrait avoir du sens. </p><br></li></ol><br><p>  De ces trois, je préfère définitivement le n ° 1.  C'est le plus simple, et maintenant je suis le plus intéressé par la façon dont nous pouvons simplifier la rouille en préservant son caractère.  Sinon, je donne la préférence à celle que nous avons en ce moment. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Fondamentalement, je trouve que les règles actuelles concernant la mutabilité ont une certaine valeur, mais elles sont coûteuses.  Ils sont une sorte d'abstraction qui coule: c'est-à-dire qu'ils racontent une histoire simple, qui s'avère en fait incomplète.  Cela conduit à la confusion lorsque les gens passent d'une compréhension initiale, dans laquelle <code>&amp;mut</code> reflète le fonctionnement de la mutabilité, à une compréhension complète: parfois <code>mut</code> nécessaire que pour garantir l'unicité, et parfois la mutabilité est obtenue sans le mot-clé <code>mut</code> . </p><br><p>  De plus, nous devons agir avec prudence afin de maintenir la fiction, qui <code>mut</code> désigne la mutabilité et non l'unicité.  Nous avons ajouté des cas spéciaux pour que l'emprunteur vérifie les fermetures.  Nous devons rendre les règles concernant la mutabilité <code>&amp;mut</code> mutabilité plus complexes en général.  Nous devons soit ajouter <code>mut</code> aux fermetures pour pouvoir les appeler, soit rendre la syntaxe des fermetures ouverte de manière moins évidente.  Et ainsi de suite. </p><br><p>  Au final, tout se transforme en une langue plus complexe dans son ensemble.  Au lieu de simplement penser à la propriété partagée et à l'unicité, l'utilisateur devrait penser à la propriété partagée et à la mutabilité, et les deux sont en quelque sorte foirés. </p><br><p>  Je ne pense pas que cela en vaille la peine. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418735/">https://habr.com/ru/post/fr418735/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418723/index.html">Patch AndroidX</a></li>
<li><a href="../fr418725/index.html">Constante magique</a></li>
<li><a href="../fr418727/index.html">Où et comment entrer dans les intégrations de graphiques</a></li>
<li><a href="../fr418729/index.html">Tout ce que vous avez longtemps demandé en une seule version - CLion 2018.2</a></li>
<li><a href="../fr418733/index.html">Visualiser les commentaires des chaînes YouTube des communautés touhou internationales et locales</a></li>
<li><a href="../fr418737/index.html">Ablation laser, verre tellurique et dopant Er2O3</a></li>
<li><a href="../fr418739/index.html">Centre de technologie additive: Imprimantes 3D industrielles Systèmes 3D, Stratasys, SLM, EOS</a></li>
<li><a href="../fr418741/index.html">Ajoutez le chiffrement et passez au SIP standard</a></li>
<li><a href="../fr418743/index.html">Première place au ML Boot Camp VI</a></li>
<li><a href="../fr418747/index.html">Résolution de problèmes: comment résoudre efficacement les problèmes en équipe?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>