<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§õüèæ üßñüèª ‚ùáÔ∏è Se concentrer sur la propri√©t√© üéä üëµüèæ üëô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remarque traducteur: l'enregistrement est dat√© du 13 mai 2014, donc certains d√©tails, y compris le code source, peuvent ne pas correspondre √† l'√©tat a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Se concentrer sur la propri√©t√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418735/"><p>  <em>Remarque</em>  <em>traducteur: l'enregistrement est dat√© du 13 mai 2014, donc certains d√©tails, y compris le code source, peuvent ne pas correspondre √† l'√©tat actuel des choses.</em>  <em>La r√©ponse √† la question de savoir pourquoi la traduction d'un article aussi long est n√©cessaire sera la valeur de son contenu pour former une compr√©hension de l'un des concepts fondamentaux de la langue Rust, comme la ma√Ætrise de la langue.</em> </p><br><p>  Au fil du temps, je suis devenu convaincu qu'il valait mieux abandonner la distinction entre variables locales mutables et immuables dans Rust.  Au moins, beaucoup de gens sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sceptiques</a> √† ce sujet.  Je voulais exprimer ma position en public.  Je donnerai divers motifs: philosophiques, techniques et pratiques, ainsi que la d√©fense principale du syst√®me actuel.  (Remarque: j'ai vu cela comme Rust RFC, mais j'ai d√©cid√© que le ton √©tait meilleur pour un article de blog et je n'ai pas le temps de le r√©√©crire maintenant.) </p><a name="habracut"></a><br><h2 id="poyasnenie">  Explication </h2><br><p>  J'ai √©crit cet article de mani√®re assez d√©cisive et je crois que la ligne que je d√©fends sera correcte.  Cependant, si nous ne finissons pas de soutenir le syst√®me actuel, ce ne sera pas un d√©sastre ou quelque chose comme √ßa.  Il a ses avantages, et dans l'ensemble je le trouve assez agr√©able.  Je pense simplement que nous pouvons l'am√©liorer. </p><br><h2 id="odnim-slovom">  En un mot </h2><br><p> Je voudrais supprimer la distinction entre les variables locales immuables et mutables et renommer les pointeurs <code>&amp;mut</code> en <code>&amp;my</code> , <code>&amp;only</code> ou <code>&amp;uniq</code> (cela ne <code>&amp;uniq</code> aucune diff√©rence pour moi).  Si seulement il n'y avait pas de mot-cl√© <code>mut</code> . </p><br><h2 id="filosofskiy-motiv">  Motif philosophique </h2><br><p>  La principale raison pour laquelle je veux le faire est parce que je pense que cela rendra le langage plus coh√©rent et plus facile √† comprendre.  Essentiellement, cela nous r√©orientera de parler de <em>mutabilit√©</em> pour parler d' <em>utiliser des alias</em> (que j'appellerai ¬´partage¬ª, voir ci-dessous). </p><br><p>  La variabilit√© devient une cons√©quence de l'unicit√©: "Vous pouvez toujours changer tout ce √† quoi vous avez un acc√®s unique. Les donn√©es partag√©es sont g√©n√©ralement immuables, mais si vous en avez besoin, vous pouvez les changer en utilisant une sorte de type de <code>Cell</code> ." </p><br><p>  En d'autres termes, au fil du temps, il est devenu clair pour moi que des probl√®mes avec la course aux donn√©es et la s√©curit√© de la m√©moire surviennent lorsque vous avez √† la fois l'utilisation d'alias et la mutabilit√©.  Une approche fonctionnelle pour r√©soudre ce probl√®me consiste √† √©liminer la mutabilit√©.  L'approche de Rust serait de supprimer l'utilisation d'alias.  Cela nous donne une histoire qui peut √™tre racont√©e et qui nous aidera √† la comprendre. </p><br><p>  Une note sur la terminologie: je pense que nous devrions nous r√©f√©rer √† l' <em>utilisation des alias</em> comme <em>s√©paration</em> <em>ni la ¬´pseudonymisation¬ª ne permet de comprendre les enjeux</em> ).  Dans le pass√©, nous avons √©vit√© cela en raison de ses r√©f√©rences multithread.  Cependant, si / lorsque nous mettons en ≈ìuvre les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plans de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parall√©lisation des donn√©es</a> que j'ai propos√©s, cette connotation n'est pas enti√®rement inappropri√©e.  En fait, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©tant donn√© la relation √©troite</a> entre la s√©curit√© de la m√©moire et la course aux donn√©es, je veux vraiment promouvoir cette connotation. </p><br><h2 id="obrazovatelnyy-motiv">  Motif √©ducatif </h2><br><p>  Je pense que les r√®gles actuelles sont plus difficiles √† comprendre qu'elles ne devraient l'√™tre.  Il n'est pas √©vident, par exemple, que <code>&amp;mut T</code> n'implique aucune propri√©t√© partag√©e.  De plus, la d√©signation <code>&amp;mut T</code> implique que <code>&amp;T</code> n'implique aucune mutabilit√©, qui n'est pas enti√®rement exacte, en raison de types tels que <code>Cell</code> .  Et il est impossible de s'entendre sur comment les appeler (les ¬´liens mutables / immuables¬ª sont les plus courants, mais ce n'est pas tout √† fait correct). </p><br><p>  En revanche, un type comme <code>&amp;my T</code> ou <code>&amp;only T</code> semble simplifier l'explication.  Il s'agit d'un <em>lien unique</em> - naturellement, vous ne pouvez pas forcer deux d'entre eux √† pointer vers le m√™me endroit.  Et la <em>mutabilit√©</em> est une chose orthogonale: elle vient de l'unicit√©, mais elle vaut √©galement pour les cellules.  Et le type <code>&amp;T</code> est juste son contraire, un <em>lien partag√©</em> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC PR # 58</a> fournit un certain nombre d'arguments similaires.  Je ne les r√©p√©terai pas ici. </p><br><h2 id="prakticheskiy-motiv">  Motif pratique </h2><br><p>  Actuellement, il existe un √©cart entre les pointeurs emprunt√©s, qui peuvent √™tre partag√©s ou mutables + uniques, et les variables locales qui sont toujours uniques, mais peuvent √™tre mutables ou immuables.  Le r√©sultat final est que les utilisateurs doivent publier des annonces <code>mut</code> sur des choses qui ne sont pas directement modifiables. </p><br><h3 id="lokalnye-peremennye-ne-mogut-byt-smodelirovany-s-ispolzovaniem-ssylok">  Les variables locales ne peuvent pas √™tre mod√©lis√©es √† l'aide de r√©f√©rences </h3><br><p>  Ce ph√©nom√®ne se produit parce que les liens ne sont pas aussi expressifs que les variables locales.  En g√©n√©ral, cela emp√™che l'abstraction.  Permettez-moi de vous donner quelques exemples pour expliquer ce que je veux dire.  Imaginez que j'ai une structure d'environnement qui stocke un pointeur sur un compteur d'erreurs: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span></span> { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre> <br><p>  Maintenant, je peux cr√©er des instances de cette structure (et les utiliser): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_condition { *env.errors += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  OK, imaginez maintenant que je veux s√©parer le code qui modifie les <code>env.errors</code> une fonction distincte.  Je pourrais penser que puisque la variable <code>env</code> n'est pas d√©clar√©e comme mutable, je peux utiliser le lien immuable <code>&amp;</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; helper(&amp;env); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">helper</span></span></span></span>(env: &amp;Env) { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_condition { *env.errors += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  } }</span></span></code> </pre> <br><p>  Mais ce n'est pas le cas.  Le probl√®me est que <code>&amp;Env</code> est un type de propri√©t√© partag√©e ( <em>note du traducteur: comme vous le savez, plus d'une r√©f√©rence d'objet immuable peut exister √† la fois</em> ), et donc les <code>env.errors</code> dans un espace qui permet une propri√©t√© distincte de l'objet <code>env</code> .  Pour que ce code fonctionne, je dois d√©clarer <code>env</code> comme mutable et utiliser le lien <code>&amp;mut</code> ( <em>note du traducteur: <code>&amp;mut</code> ) pour dire au compilateur que <code>env</code> est unique en propri√©t√©, car une seule r√©f√©rence d'objet mutable peut exister √† la fois et la course aux donn√©es est exclue, mais <code>mut</code> parce que vous ne pouvez pas cr√©er une r√©f√©rence mutable √† un objet immuable</em> ): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; helper(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> env);</code> </pre> <br><p>  Ce probl√®me se pose parce que nous savons que les variables locales sont uniques, mais nous ne pouvons pas mettre ces connaissances dans une r√©f√©rence emprunt√©e sans les rendre mutables. </p><br><p>  Ce probl√®me se produit dans un certain nombre d'autres endroits.  Jusqu'√† pr√©sent, nous avons √©crit √† ce sujet de diff√©rentes mani√®res, mais je continue d'√™tre hant√© par le sentiment que nous parlons d'une pause, qui ne devrait tout simplement pas l'√™tre. </p><br><h3 id="proverka-tipov-primenitelno-k-zamykaniyam">  V√©rification de type pour les fermetures </h3><br><p>  Nous avons d√ª contourner cette limitation en cas de fermeture.  Les fermetures <em>sont g√©n√©ralement</em> ouvertes dans des structures telles que <code>Env</code> , mais pas tout √† fait.  C'est parce que je ne veux pas exiger que les variables locales soient d√©clar√©es <code>mut</code> si elles sont utilis√©es via <code>&amp;mut</code> dans une fermeture.  En d'autres termes, prenez du code, par exemple: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { do_something(|| *errors += <span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br><p>  Une expression d√©crivant la fermeture cr√©era en fait une instance de la structure <code>Env</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClosureEnv</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt; { errors: &amp;uniq &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre> <br><p>  Consultez le lien <code>&amp;uniq</code> .  Ce n'est pas quelque chose que l'utilisateur final peut saisir.  Cela signifie un pointeur "unique mais pas n√©cessairement modifiable".  Cela est n√©cessaire pour passer la v√©rification de type.  Si l'utilisateur tentait d'√©crire cette structure manuellement, il devrait √©crire <code>&amp;mut &amp;mut usize</code> , ce qui n√©cessiterait √† son tour que le param√®tre d' <code>errors</code> soit d√©clar√© comme <code>mut errors: &amp;mut usize</code> . </p><br><h3 id="nezapakovannye-zamykaniya-i-procedury">  Fermetures et proc√©dures d√©ball√©es </h3><br><p>  Je pr√©dis que cette restriction est un probl√®me pour les fermetures non emball√©es.  Permettez-moi d'√©laborer sur la conception que j'envisageais.  Fondamentalement, l'id√©e √©tait que l'expression <code>||</code>  est √©quivalent √† un nouveau type structurel qui impl√©mente l'un des traits <code>Fn</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fn</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FnMut</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FnOnce</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); }</code> </pre> <br><p>  Le type exact sera s√©lectionn√© en fonction du type attendu, √† compter d'aujourd'hui.  Dans ce cas, les consommateurs de fermetures peuvent √©crire deux choses: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;&gt;(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: T) { ... }</code> </pre> <br><p>  Nous ... voulons probablement corriger la syntaxe, peut-√™tre ajouter du sucre comme <code>FnMut(usize) -&gt; usize</code> , ou enregistrer | usize |  -&gt; utiliser, etc.  Ce n'est pas si important, il est important que nous passions la fermeture <em>en valeur</em> .  Veuillez noter que conform√©ment aux r√®gles actuelles de DST (Dynamically-Sized Types), il est permis de passer un type par valeur comme argument au <code>FnMut&lt;usize, usize&gt;</code> , donc l'argument <code>FnMut&lt;usize, usize&gt;</code> est un DST valide et n'est pas un probl√®me. </p><br><p>  <em>A part</em> : ce projet n'est pas termin√©, et je d√©crirai tous les d√©tails dans un message s√©par√©. </p><br><p>  Le probl√®me est qu'un lien <code>&amp;mut</code> est n√©cessaire pour appeler une fermeture.  √âtant donn√© que la fermeture est transmise par valeur, les utilisateurs devront √† nouveau √©crire <code>mut</code> o√π il semble hors de propos: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> closure: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = closure.call(<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><p>  C'est le m√™me probl√®me que dans l'exemple <code>Env</code> ci-dessus: ce qui <em>se</em> passe <em>r√©ellement</em> ici, c'est que le <code>FnMut</code> veut juste un lien <em>unique</em> , mais comme il ne fait pas partie du syst√®me de type, il demande un lien <em>mutable</em> . </p><br><p>  Maintenant, nous pouvons peut-√™tre contourner cela de diff√©rentes mani√®res.  Une option que nous pourrions faire est de <code>||</code>  la syntaxe ne se d√©velopperait pas dans un ¬´certain type structurel¬ª, mais plut√¥t dans un ¬´type structurel ou un pointeur vers un type structurel, comme dict√© par l'inf√©rence de type¬ª.  Dans ce cas, l'appelant pourrait √©crire: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = closure.call(<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><p>  Je ne veux pas dire que c'est la fin du monde.  Mais c'est un autre pas en avant dans les distorsions croissantes que nous devons traverser pour maintenir cet √©cart entre les variables locales et les r√©f√©rences. </p><br><h3 id="drugie-chasti-api">  Autres pi√®ces API </h3><br><p>  Je n'ai pas fait d'√©tude approfondie, mais, bien s√ªr, cette diff√©rence se glisse ailleurs.  Par exemple, pour lire √† partir de <code>Socket</code> , j'ai besoin d'un pointeur unique, donc je dois le d√©clarer mutable.  Par cons√©quent, parfois cela ne fonctionne pas: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> socket = Socket::new(); socket.read() <span class="hljs-comment"><span class="hljs-comment">// :   </span></span></code> </pre> <br><p>  Naturellement, selon ma suggestion, un tel code fonctionnerait bien.  Vous recevrez toujours un message d'erreur si vous essayez de lire √† partir de <code>&amp;Socket</code> , mais il lira alors quelque chose comme "il est impossible de cr√©er un lien unique vers un lien partag√©", que je consid√®re personnellement plus compr√©hensible. </p><br><h2 id="no-razve-nam-ne-nuzhen-mut-dlya-bezopasnosti">  Mais n'avons-nous pas besoin de <code>mut</code> pour la s√©curit√©? </h2><br><p>  Non, pas du tout.  Les programmes Rust seraient √©galement bons si vous d√©clariez toutes les liaisons comme <code>mut</code> .  Le compilateur est parfaitement capable de suivre les variables locales qui changent √† un moment donn√© - pr√©cis√©ment parce qu'elles sont <em>locales</em> √† la fonction actuelle.  Ce qui importe vraiment au syst√®me de caract√®res, c'est l'unicit√©. </p><br><p>  Le sens que je vois dans les r√®gles d'application actuelles de <code>mut</code> , et je ne nierai pas qu'il a de la valeur, c'est avant tout qu'elles aident √† d√©clarer l'intention.  Autrement dit, lorsque je lis le code, je sais quelles variables peuvent √™tre r√©affect√©es.  D'un autre c√¥t√©, je passe √©galement beaucoup de temps √† lire du code C ++ et, franchement, je n'ai jamais remarqu√© qu'il s'agit d'une pierre d'achoppement majeure.  (Il en va de m√™me pour le temps que j'ai pass√© √† lire du code en Java, JavaScript, Python ou Ruby.) </p><br><p>  Il est √©galement vrai que je trouve parfois des bogues parce que j'ai d√©clar√© la variable comme <code>mut</code> et oubli√© de la changer.  Je pense que nous pourrions obtenir des avantages similaires avec d'autres contr√¥les plus agressifs (par exemple, aucune des variables utilis√©es dans la condition de boucle ne change dans le corps de la boucle).  Personnellement, je ne me souviens pas d'√™tre confront√© √† la situation inverse: c'est-√†-dire que si le compilateur dit que quelque chose doit √™tre mutable, cela signifie toujours que j'ai oubli√© le mot-cl√© <code>mut</code> quelque part.  (R√©fl√©chissez: √† quand remonte la derni√®re fois que vous avez r√©pondu √† une erreur du compilateur concernant une modification non valide en faisant autre chose que de restructurer le code pour rendre la modification valide?) </p><br><h2 id="alternativy">  Alternatives </h2><br><p>  Je vois trois alternatives au syst√®me actuel: </p><br><ol><li>  Celui que j'ai pr√©sent√© o√π vous jetez simplement la ¬´mutabilit√©¬ª et ne suivez que l'unicit√©. </li><li>  Celui o√π vous avez trois types de r√©f√©rence: <code>&amp;</code> , <code>&amp;uniq</code> et <code>&amp;mut</code> .  (Comme je l'ai √©crit, c'est en fait le syst√®me de type que nous avons aujourd'hui, du moins du point de vue d'un v√©rificateur d'emprunt.) </li><li><p>  Une option plus rigoureuse, dans laquelle les variables non mutantes sont toujours consid√©r√©es comme s√©par√©es.  Cela signifierait que vous auriez √† √©crire: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> p = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors; <span class="hljs-comment"><span class="hljs-comment">// ,  `p`   ,  `mut`. *p += 1;</span></span></code> </pre> <br><p>  Vous devez d√©clarer <code>p</code> comme <code>mut</code> , car sinon la variable serait consid√©r√©e comme distincte, m√™me s'il s'agit d'une variable locale, et donc la modification de <code>*p</code> pas autoris√©e.  Ce qui est √©trange dans ce sch√©ma, c'est que la variable locale N'AUTORISE PAS la propri√©t√© s√©par√©e, et nous le savons avec certitude, car lorsque vous essayez de cr√©er son alias, elle se d√©placera, le destructeur d√©marrera dessus, etc.  Autrement dit, nous avons toujours le concept de ¬´propri√©t√©¬ª, qui est diff√©rent de ¬´ne permet pas la propri√©t√© s√©par√©e¬ª. </p><br><p>  D'un autre c√¥t√©, si nous d√©crivions ce syst√®me, en disant que la mutabilit√© est h√©rit√©e via des pointeurs <code>&amp;mut</code> , sans m√™me b√©gayer sur la propri√©t√© partag√©e, cela pourrait avoir du sens. </p><br></li></ol><br><p>  De ces trois, je pr√©f√®re d√©finitivement le n ¬∞ 1.  C'est le plus simple, et maintenant je suis le plus int√©ress√© par la fa√ßon dont nous pouvons simplifier la rouille en pr√©servant son caract√®re.  Sinon, je donne la pr√©f√©rence √† celle que nous avons en ce moment. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Fondamentalement, je trouve que les r√®gles actuelles concernant la mutabilit√© ont une certaine valeur, mais elles sont co√ªteuses.  Ils sont une sorte d'abstraction qui coule: c'est-√†-dire qu'ils racontent une histoire simple, qui s'av√®re en fait incompl√®te.  Cela conduit √† la confusion lorsque les gens passent d'une compr√©hension initiale, dans laquelle <code>&amp;mut</code> refl√®te le fonctionnement de la mutabilit√©, √† une compr√©hension compl√®te: parfois <code>mut</code> n√©cessaire que pour garantir l'unicit√©, et parfois la mutabilit√© est obtenue sans le mot-cl√© <code>mut</code> . </p><br><p>  De plus, nous devons agir avec prudence afin de maintenir la fiction, qui <code>mut</code> d√©signe la mutabilit√© et non l'unicit√©.  Nous avons ajout√© des cas sp√©ciaux pour que l'emprunteur v√©rifie les fermetures.  Nous devons rendre les r√®gles concernant la mutabilit√© <code>&amp;mut</code> mutabilit√© plus complexes en g√©n√©ral.  Nous devons soit ajouter <code>mut</code> aux fermetures pour pouvoir les appeler, soit rendre la syntaxe des fermetures ouverte de mani√®re moins √©vidente.  Et ainsi de suite. </p><br><p>  Au final, tout se transforme en une langue plus complexe dans son ensemble.  Au lieu de simplement penser √† la propri√©t√© partag√©e et √† l'unicit√©, l'utilisateur devrait penser √† la propri√©t√© partag√©e et √† la mutabilit√©, et les deux sont en quelque sorte foir√©s. </p><br><p>  Je ne pense pas que cela en vaille la peine. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418735/">https://habr.com/ru/post/fr418735/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418723/index.html">Patch AndroidX</a></li>
<li><a href="../fr418725/index.html">Constante magique</a></li>
<li><a href="../fr418727/index.html">O√π et comment entrer dans les int√©grations de graphiques</a></li>
<li><a href="../fr418729/index.html">Tout ce que vous avez longtemps demand√© en une seule version - CLion 2018.2</a></li>
<li><a href="../fr418733/index.html">Visualiser les commentaires des cha√Ænes YouTube des communaut√©s touhou internationales et locales</a></li>
<li><a href="../fr418737/index.html">Ablation laser, verre tellurique et dopant Er2O3</a></li>
<li><a href="../fr418739/index.html">Centre de technologie additive: Imprimantes 3D industrielles Syst√®mes 3D, Stratasys, SLM, EOS</a></li>
<li><a href="../fr418741/index.html">Ajoutez le chiffrement et passez au SIP standard</a></li>
<li><a href="../fr418743/index.html">Premi√®re place au ML Boot Camp VI</a></li>
<li><a href="../fr418747/index.html">R√©solution de probl√®mes: comment r√©soudre efficacement les probl√®mes en √©quipe?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>