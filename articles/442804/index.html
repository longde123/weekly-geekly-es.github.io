<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôãüèΩ üôçüèº üò® MVCC-1. Aislamiento üó£Ô∏è üéÖüèº üìø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Con este art√≠culo, comienzo una serie de bucles (¬øo un bucle de series? En general, una gran idea) sobre la estructura interna de PostgreSQ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-1. Aislamiento</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/442804/">  Hola Habr!  Con este art√≠culo, comienzo una serie de bucles (¬øo un bucle de series? En general, una gran idea) sobre la estructura interna de PostgreSQL. <br><br>  El material se basar√° en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cursos de capacitaci√≥n</a> administrativa que realizamos con Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">pluzanov</a> .  No a todos les gusta ver un video (definitivamente no me gusta), pero leer diapositivas, incluso con comentarios, es completamente "incorrecto". <br><br>  Por supuesto, los art√≠culos no repetir√°n el contenido de los cursos uno a uno.  Solo hablar√© sobre c√≥mo funciona todo, omitiendo la administraci√≥n en s√≠, pero intentar√© hacerlo con m√°s detalle y detalle.  Y creo que ese conocimiento es √∫til para el desarrollador de la aplicaci√≥n, no menos que el administrador. <br><br>  Me centrar√© en aquellos que ya tienen experiencia en el uso de PostgreSQL y, al menos en t√©rminos generales, imaginen lo que est√° sucediendo.  Para los principiantes, el texto ser√° un poco pesado.  Por ejemplo, no dir√© una palabra sobre c√≥mo instalar PostgreSQL y ejecutar psql. <br><br>  Las cosas que se discutir√°n no cambian mucho de una versi√≥n a otra, pero usar√© el 11¬∫ PostgreSQL actual. <br><br>  El primer ciclo est√° dedicado a cuestiones relacionadas con el aislamiento y la multiversion, y su plan es el siguiente: <br><br><ol><li>  Aislamiento, tal como lo entienden el est√°ndar y PostgreSQL (este art√≠culo); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Capas, archivos, p√°ginas</a> : lo que est√° sucediendo a nivel f√≠sico; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Versiones de fila, transacciones virtuales y anidadas</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instant√°neas de datos y visibilidad de versiones de fila, horizonte de eventos</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Limpieza en la p√°gina y actualizaciones CALIENTES</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Limpieza normal</a> (aspiradora); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Limpieza autom√°tica</a> (autovacuum); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El contador de transacciones se desborda y se congela</a> . </li></ol><br>  Pues vamos. <br><a name="habracut"></a><br><h1>  ¬øQu√© es el aislamiento y por qu√© es importante? </h1><br>  Probablemente, al menos, todos conocen la existencia de transacciones, conocieron el acr√≥nimo ACID y escucharon acerca de los niveles de aislamiento.  Pero todav√≠a hay que conocer la opini√≥n de que esta es una teor√≠a que no es necesaria en la pr√°ctica.  Por lo tanto, pasar√© un tiempo tratando de explicar por qu√© esto es realmente importante. <br><br>  Es poco probable que est√© encantado si la aplicaci√≥n recibe datos incorrectos de la base de datos o si la aplicaci√≥n escribe datos incorrectos en la base de datos. <br><br>  Pero, ¬øqu√© son los datos "correctos"?  Se sabe que a nivel de base de datos, puede crear restricciones de integridad (como NOT NULL o UNIQUE).  Si los datos siempre satisfacen las restricciones de integridad (y esto es as√≠ porque el DBMS lo garantiza), entonces son hol√≠sticos. <br><br>  <em>¬øSon correctos</em> e <em>integrales</em> , lo mismo?  En realidad no  No todas las restricciones se pueden formular a nivel de base de datos.  Parte de las restricciones es demasiado complicada, por ejemplo, cubre varias tablas a la vez.  E incluso si la restricci√≥n, en principio, pudiera definirse en la base de datos, pero por alguna raz√≥n no lo hizo, no significa que pueda ser violada. <br><br>  Entonces, la <em>correcci√≥n es</em> m√°s estricta que la <em>integridad</em> , pero no sabemos exactamente qu√© es.  Queda por reconocer que el est√°ndar de correcci√≥n es una aplicaci√≥n que, como queremos creer, est√° escrita <em>correctamente</em> y nunca se equivoca.  En cualquier caso, si la aplicaci√≥n no viola la integridad, pero viola la correcci√≥n, el DBMS no lo sabr√° y no le atrapar√° la mano. <br><br>  De ahora en adelante, llamaremos a la correcci√≥n el t√©rmino consistencia. <br><br>  Supongamos, sin embargo, que la aplicaci√≥n solo ejecuta la secuencia correcta de declaraciones.  ¬øCu√°l es el papel del DBMS entonces, si la aplicaci√≥n es correcta? <br><br>  En primer lugar, resulta que una secuencia correcta de declaraciones puede alterar temporalmente la coherencia de los datos, y esto, curiosamente, es normal.  Un ejemplo trillado pero comprensible es transferir fondos de una cuenta a otra.  La regla de coherencia puede sonar as√≠: una <em>transferencia nunca cambia la cantidad total de dinero en las cuentas</em> (dicha regla es bastante dif√≠cil de escribir en SQL como una restricci√≥n de integridad, por lo que existe a nivel de aplicaci√≥n y es invisible para el DBMS).  Una transferencia consta de dos operaciones: la primera reduce los fondos en una cuenta, la segunda, aumenta en otra.  La primera operaci√≥n viola la consistencia de los datos, la segunda, restaura. <br><br><blockquote>  Un buen ejercicio es implementar la regla descrita anteriormente a nivel de restricciones de integridad.  ¬øEres d√©bil?  ¬© ¬© <br></blockquote><br>  ¬øQu√© sucede si la primera operaci√≥n se completa y la segunda no?  Despu√©s de todo, es f√°cil: durante la segunda operaci√≥n, se puede perder electricidad, el servidor puede caerse, la divisi√≥n por cero puede ocurrir, pero nunca se sabe.  Est√° claro que se est√° violando la coherencia, y esto no debe permitirse.  En principio, es posible resolver tales situaciones a nivel de aplicaci√≥n a costa de esfuerzos incre√≠bles, pero, afortunadamente, no es necesario: el DBMS se encarga de esto.  Pero para esto, ella debe saber que dos operaciones constituyen un todo indivisible.  Esa es una <em>transacci√≥n</em> . <br><br>  Resulta interesante: sabiendo que las operaciones constituyen una transacci√≥n, el DBMS ayuda a mantener la coherencia al garantizar la atomicidad de las transacciones, sin saber nada sobre reglas de coherencia espec√≠ficas. <br><br>  Pero hay un segundo punto, m√°s sutil.  Tan pronto como aparecen varias transacciones simult√°neas en el sistema que son absolutamente correctas una por una, juntas pueden funcionar incorrectamente.  Esto se debe al hecho de que el orden de las operaciones es mixto: no se puede suponer que todas las operaciones de una transacci√≥n se realizan primero, y solo luego todas las operaciones de otra. <br><br>  Una nota sobre simultaneidad.  De hecho, al mismo tiempo, las transacciones pueden ejecutarse en un sistema con un procesador multin√∫cleo, con una matriz de discos, etc. Pero todas las mismas consideraciones son ciertas para un servidor que ejecuta comandos secuencialmente, en modo de tiempo compartido: tantos ciclos, una transacci√≥n se ejecuta, tantos ciclos son diferentes .  A veces, el t√©rmino ejecuci√≥n <em>competitiva</em> se utiliza para resumir. <br><br>  Las situaciones en que las transacciones correctas no funcionan juntas correctamente se denominan <em>anomal√≠as de</em> ejecuci√≥n simult√°nea. <br><br>  Un ejemplo simple: si una aplicaci√≥n quiere obtener los datos correctos de la base de datos, al menos no deber√≠a ver cambios en otras transacciones no confirmadas.  De lo contrario, no solo puede obtener datos inconsistentes, sino tambi√©n ver algo que nunca ha estado en la base de datos (si la transacci√≥n se cancela).  Esta anomal√≠a se llama <em>lectura sucia</em> . <br><br>  Si hay otras anomal√≠as m√°s complejas, que trataremos un poco m√°s adelante. <br><br>  Por supuesto, es imposible rechazar la ejecuci√≥n simult√°nea: de lo contrario, ¬øqu√© tipo de rendimiento se puede discutir?  Pero no puede trabajar con datos incorrectos. <br><br>  Y nuevamente el DBMS viene al rescate.  Puede hacer que las transacciones se ejecuten <em>como si</em> fueran secuencialmente, <em>como si</em> una tras otra.  En otras palabras, <em>aislados</em> unos de otros.  En realidad, el DBMS puede realizar operaciones confusas, pero al mismo tiempo garantizar que el resultado de la ejecuci√≥n simult√°nea coincida con el resultado de cualquiera de las posibles ejecuciones secuenciales.  Y esto elimina cualquier posible anomal√≠a. <br><br>  Entonces, llegamos a la definici√≥n: <br><br><blockquote>  Una transacci√≥n es el conjunto de operaciones realizadas por una aplicaci√≥n que transfiere la base de datos de un estado correcto a otro estado correcto (consistencia), siempre que la transacci√≥n sea completa (atomicidad) y sin interferencia de otras transacciones (aislamiento). <br></blockquote><br>  Esta definici√≥n combina las tres primeras letras del acr√≥nimo ACID.  Est√°n tan estrechamente relacionados entre s√≠ que simplemente no tiene sentido considerar uno sin el otro.  De hecho, es dif√≠cil arrancar la letra D (durabilidad).  Despu√©s de todo, en caso de un bloqueo del sistema, los cambios en las transacciones no confirmadas permanecen en √©l, con lo que debe hacer algo para restaurar la consistencia de los datos. <br><br>  Todo estar√≠a bien, pero implementar un aislamiento completo es una tarea t√©cnicamente dif√≠cil, junto con una reducci√≥n en el rendimiento del sistema.  Por lo tanto, en la pr√°ctica, muy a menudo (no siempre, pero casi siempre) se aplica aislamiento debilitado, lo que evita algunas, pero no todas, las anomal√≠as.  Y esto significa que parte del trabajo para garantizar la exactitud de los datos recae en la aplicaci√≥n.  Es por eso que es muy importante comprender qu√© nivel de aislamiento se utiliza en el sistema, qu√© garantiza que ofrece y cu√°les no, y c√≥mo escribir el c√≥digo correcto en tales condiciones. <br><br><h1>  Niveles de aislamiento SQL y anomal√≠as </h1><br>  El est√°ndar SQL ha descrito durante mucho tiempo cuatro niveles de aislamiento.  Estos niveles se determinan enumerando las anomal√≠as permitidas o no permitidas al realizar transacciones en ese nivel.  Por lo tanto, para hablar sobre estos niveles, debe familiarizarse con las anomal√≠as. <br><br>  Enfatizo que en esta parte estamos hablando del est√°ndar, es decir, de cierta teor√≠a en la que la pr√°ctica se basa en gran medida, pero que al mismo tiempo est√° en desacuerdo.  Por lo tanto, todos los ejemplos aqu√≠ son especulativos.  Utilizar√°n las mismas operaciones en las cuentas de los clientes: esto es bastante obvio, aunque, es cierto, no tiene nada que ver con c√≥mo se organizan las operaciones bancarias. <br><br><h2>  Actualizaci√≥n perdida </h2><br>  Comencemos con la <em>actualizaci√≥n perdida</em> .  Esta anomal√≠a ocurre cuando dos transacciones leen la misma fila en la tabla, luego una transacci√≥n actualiza esta fila y, despu√©s de eso, la segunda transacci√≥n tambi√©n actualiza la misma fila, sin tener en cuenta los cambios realizados por la primera transacci√≥n. <br><br>  Por ejemplo, dos transacciones aumentar√°n la cantidad en la misma cuenta en 100 ‚ÇΩ.  La primera transacci√≥n lee el valor actual (1000 ‚ÇΩ), luego la segunda transacci√≥n lee el mismo valor.  La primera transacci√≥n aumenta la cantidad (resulta 1100 ‚ÇΩ) y escribe este valor.  La segunda transacci√≥n hace lo mismo: obtiene los mismos 1.100 ‚ÇΩ y los escribe.  Como resultado, el cliente perdi√≥ 100 ‚ÇΩ. <br><br>  El est√°ndar no permite actualizaciones perdidas en ning√∫n nivel de aislamiento. <br><br><h2>  Lectura sucia y lectura sin compromiso </h2><br>  Con <em>una lectura sucia</em> ya nos hemos encontrado arriba.  Esta anomal√≠a ocurre cuando una transacci√≥n lee cambios pendientes realizados por otra transacci√≥n. <br><br>  Por ejemplo, la primera transacci√≥n transfiere todo el dinero de la cuenta del cliente a otra cuenta, pero no registra el cambio.  Otra transacci√≥n lee el estado de la cuenta, recibe 0 ‚ÇΩ y se niega a emitir efectivo al cliente, a pesar de que la primera transacci√≥n se interrumpe y cancela sus cambios, por lo que el valor 0 nunca existi√≥ en la base de datos. <br><br>  El est√°ndar permite la lectura sucia en el nivel de lectura no comprometida. <br><br><h2>  Lectura no repetida y lectura comprometida </h2><br>  La anomal√≠a de <em>lectura no repetida</em> ocurre cuando una transacci√≥n lee la misma l√≠nea dos veces, y en el intervalo entre lecturas, la segunda transacci√≥n cambia (o elimina) esta l√≠nea y confirma los cambios.  Entonces, la primera transacci√≥n obtendr√° resultados diferentes. <br><br>  Por ejemplo, deje que la regla de coherencia <em>proh√≠ba los importes negativos en las cuentas de los clientes</em> .  La primera transacci√≥n reducir√° la cantidad en la cuenta en 100 ‚ÇΩ.  Comprueba el valor actual, obtiene 1000 ‚ÇΩ y decide que es posible una reducci√≥n.  En este momento, la segunda transacci√≥n reduce el monto en la cuenta a cero y registra los cambios.  Si ahora la primera transacci√≥n volviera a verificar la cantidad, recibir√≠a 0 ‚ÇΩ (pero ya hab√≠a decidido disminuir el valor y la cuenta "va a menos"). <br><br>  El est√°ndar permite la lectura no repetida en los niveles de lectura no confirmada y lectura confirmada.  Pero la lectura sucia Read Committed no lo permite. <br><br><h2>  Lectura fantasma y lectura repetible </h2><br>  <em>La lectura fantasma</em> ocurre cuando una transacci√≥n lee un conjunto de l√≠neas dos veces bajo la misma condici√≥n, y en el intervalo entre lecturas, la segunda transacci√≥n agrega l√≠neas que satisfacen esta condici√≥n (y confirma los cambios).  Entonces la primera transacci√≥n recibir√° diferentes conjuntos de filas. <br><br>  Por ejemplo, suponga que una regla de coherencia <em>proh√≠be que un cliente tenga m√°s de 3 cuentas</em> .  La primera transacci√≥n va a abrir una nueva cuenta, verifica su n√∫mero actual (digamos, 2) y decide que es posible abrirlo.  En este momento, la segunda transacci√≥n tambi√©n abre una nueva cuenta para el cliente y registra los cambios.  Si ahora la primera transacci√≥n verificara dos veces la cantidad, recibir√≠a 3 (pero ya est√° abriendo otra cuenta y el cliente tiene 4 de ellas). <br><br>  La lectura fantasma est√° permitida por el est√°ndar en los niveles de Lectura no confirmada, Lectura comprometida y Lectura repetible.  Pero en el nivel de lectura repetible, la lectura no repetida no est√° permitida. <br><br><h2>  Falta de anomal√≠as y serializables </h2><br>  El est√°ndar define otro nivel, Serializable, en el que no se permiten anomal√≠as.  Y esto no es lo mismo que prohibir una actualizaci√≥n perdida y una lectura sucia, no repetida y fantasma. <br><br>  El hecho es que hay significativamente m√°s anomal√≠as conocidas que las enumeradas en el est√°ndar, y a√∫n se desconoce un n√∫mero desconocido. <br><br>  Serializable deber√≠a prevenir <em>todas las</em> anormalidades <em>en general</em> .  Esto significa que a este nivel, el desarrollador de la aplicaci√≥n no necesita pensar en ejecutarse simult√°neamente.  Si las transacciones realizan las secuencias correctas de declaraciones, trabajando solas, los datos ser√°n consistentes con la operaci√≥n simult√°nea de estas transacciones. <br><br><h2>  Placa resumen </h2><br>  Ahora puede traer una mesa conocida para todos.  Pero aqu√≠, para mayor claridad, se le agrega la √∫ltima columna, que no est√° en el est√°ndar. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  cambios perdidos </th><th>  lectura sucia </th><th>  lectura no repetida </th><th>  lectura fantasma </th><th>  otras anomal√≠as </th></tr><tr><th>  Leer no comprometido </th><th>  - </th><th>  si </th><th>  si </th><th>  si </th><th>  si </th></tr><tr><th>  Leer comprometido </th><th>  - </th><th>  - </th><th>  si </th><th>  si </th><th>  si </th></tr><tr><th>  Lectura repetible </th><th>  - </th><th>  - </th><th>  - </th><th>  si </th><th>  si </th></tr><tr><th>  Serializable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br><h2>  ¬øPor qu√© exactamente estas anomal√≠as? </h2><br>  ¬øPor qu√© solo se enumeran algunas de las muchas posibles anomal√≠as en el est√°ndar, y por qu√© son estas? <br><br>  Aparentemente, nadie parece saberlo con certeza.  Pero la pr√°ctica aqu√≠ definitivamente super√≥ la teor√≠a, por lo que es posible que luego no pensemos en otras anomal√≠as (discurso sobre el est√°ndar SQL: 92). <br><br>  Adem√°s, se supuso que el aislamiento deber√≠a construirse sobre enclavamientos.  La idea del <em>protocolo de bloqueo de dos fases</em> (2PL) ampliamente utilizado es que durante la transacci√≥n, la transacci√≥n bloquea las l√≠neas con las que est√° trabajando y, cuando se completa, libera los bloqueos.  Simplificando enormemente, mientras m√°s bloqueos captura una transacci√≥n, mejor se a√≠sla de otras transacciones.  Pero el rendimiento del sistema sufre a√∫n m√°s, porque en lugar de trabajar juntos, las transacciones comienzan a alinearse para las mismas l√≠neas. <br><br>  Me parece que la diferencia entre los niveles de aislamiento del est√°ndar se explica precisamente por el n√∫mero de bloqueos necesarios. <br><br>  Si una transacci√≥n bloquea las filas modificadas para que no cambien, pero no para leer, obtenemos el nivel Leer no confirmado: no se permiten cambios perdidos, pero se pueden leer datos no confirmados. <br><br>  Si la transacci√≥n bloquea las l√≠neas mutables de lectura y cambio, obtenemos el nivel de lectura confirmada: no puede leer datos no confirmados, pero cuando accede a la l√≠nea nuevamente, puede obtener un valor diferente (lectura no repetida). <br><br>  Si una transacci√≥n bloquea tanto l√≠neas legibles como mutables tanto de lectura como de cambio, obtenemos el nivel de Lectura repetible: la lectura repetida de la l√≠nea producir√° el mismo valor. <br><br>  Pero hay un problema con Serializable: no es posible bloquear una fila que a√∫n no existe.  Debido a esto, la posibilidad de lectura fantasma permanece: otra transacci√≥n puede agregar (pero no eliminar) una fila que se encuentra en las condiciones de una consulta ejecutada previamente, y esta fila se volver√° a buscar. <br><br>  Por lo tanto, para implementar el nivel de Serializable, los bloqueos ordinarios no son suficientes: debe bloquear no las filas, sino las condiciones (predicados).  Tales cerraduras se llamaban <em>predicado</em> .  Se propusieron en 1976, pero su aplicabilidad pr√°ctica est√° limitada por condiciones bastante simples, por lo que est√° claro c√≥mo combinar dos predicados diferentes.  Hasta donde yo s√©, no ha llegado a la implementaci√≥n de tales bloqueos en ning√∫n sistema. <br><br><h1>  Niveles de aislamiento PostgreSQL </h1><br>  Con el tiempo, el aislamiento de instant√°neas reemplaz√≥ los <em>protocolos de</em> administraci√≥n de transacciones de bloqueo.  Su idea es que cada transacci√≥n funcione con una instant√°nea consistente de los datos en un cierto punto en el tiempo, en el que solo caen los cambios que se registraron antes de la creaci√≥n de la instant√°nea. <br><br>  Tal aislamiento no permite autom√°ticamente la lectura sucia.  Formalmente, en PostgreSQL, puede especificar el nivel de lectura no confirmada, pero funcionar√° como lectura confirmada.  Por lo tanto, no hablaremos m√°s sobre el nivel Leer no confirmado. <br><br>  PostgreSQL implementa una versi√≥n <em>m√∫ltiple</em> de este protocolo.  La idea de las versiones m√∫ltiples es que varias versiones de la misma cadena pueden coexistir en un DBMS.  Esto le permite crear una instant√°nea de los datos utilizando las versiones disponibles y sobrevivir con un m√≠nimo de bloqueos.  De hecho, solo se bloquean los cambios repetidos en la misma l√≠nea.  Todas las dem√°s operaciones se realizan al mismo tiempo: las transacciones de escritura nunca bloquean las transacciones de lectura, y las transacciones de lectura nunca bloquean a nadie. <br><br>  Usando instant√°neas de datos, el aislamiento en PostgreSQL es m√°s estricto de lo que requiere el est√°ndar: el nivel de lectura repetible no solo permite lecturas no repetitivas, sino tambi√©n fantasmas (aunque no proporciona un aislamiento completo).  Y esto se logra sin p√©rdida de efectividad. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  cambios perdidos </th><th>  lectura sucia </th><th>  lectura no repetida </th><th>  lectura fantasma </th><th>  otras anomal√≠as </th></tr><tr><th>  Leer no comprometido </th><th>  - </th><th>  - </th><th>  si </th><th>  si </th><th>  si </th></tr><tr><th>  Leer comprometido </th><th>  - </th><th>  - </th><th>  si </th><th>  si </th><th>  si </th></tr><tr><th>  Lectura repetible </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  si </th></tr><tr><th>  Serializable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br>  C√≥mo se implementa la versi√≥n m√∫ltiple "bajo el cap√≥", hablaremos en los siguientes art√≠culos, y ahora veremos en detalle cada uno de los tres niveles a trav√©s de los ojos del usuario (como saben, lo m√°s interesante est√° oculto detr√°s de "otras anomal√≠as").  Para hacer esto, cree una tabla de cuentas.  Alice y Bob tienen $ 1,000 cada uno, pero Bob tiene dos cuentas abiertas: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, number <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>, client <span class="hljs-type"><span class="hljs-type">text</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>);</code> </pre> <br><h2>  Leer comprometido </h2><br><h3>  Falta de lectura sucia </h3><br>  Es f√°cil verificar que los datos sucios no se puedan leer.  Comencemos la transacci√≥n.  Por defecto, utilizar√° el nivel de aislamiento de lectura confirmada: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> transaction_isolation ----------------------- read committed (1 row)</code> </pre><br>  M√°s precisamente, el nivel predeterminado lo establece el par√°metro, se puede cambiar si es necesario: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> default_transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> default_transaction_isolation ------------------------------- read committed (1 row)</code> </pre><br>  Entonces, en una transacci√≥n abierta, retiramos fondos de la cuenta, pero no registramos los cambios.  La transacci√≥n ve sus propios cambios: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 1 | 1001 | alice | 800.00 (1 row)</code> </pre><br>  En la segunda sesi√≥n, comenzamos otra transacci√≥n con el mismo nivel de lectura confirmada.  Para distinguir entre diferentes transacciones, los comandos de la segunda transacci√≥n ser√°n sangrados y tachados. <br><br>  Para repetir los comandos anteriores (lo cual es √∫til), debe abrir dos terminales y ejecutar psql en cada uno.  En el primero, puede ingresar comandos de una transacci√≥n, y en el segundo, comandos de otra. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+--------- | 1 | 1001 | alice | 1000.00 | (1 row)</code> </pre><br>  Como se esperaba, otra transacci√≥n no ve cambios no confirmados: no se permite la lectura sucia. <br><br><h3>  Lectura no repetida </h3><br>  Ahora deje que la primera transacci√≥n confirme los cambios y la segunda vuelva a ejecutar la misma solicitud. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  La solicitud ya est√° recibiendo nuevos datos: esta es la anomal√≠a de la <em>lectura no repetida</em> , que est√° permitida en el nivel de lectura confirmada. <br><br>  <em>Conclusi√≥n pr√°ctica</em> : en una transacci√≥n es imposible tomar decisiones basadas en los datos le√≠dos por la declaraci√≥n anterior, porque todo puede cambiar entre las veces que se ejecutan las declaraciones.  Aqu√≠ hay un ejemplo cuyas variaciones son tan comunes en el c√≥digo de la aplicaci√≥n que es un antipatr√≥n cl√°sico: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre><br>  Durante el tiempo que transcurre entre la verificaci√≥n y la actualizaci√≥n, otras transacciones pueden cambiar el estado de la cuenta seg√∫n lo deseado, de modo que tal "cheque" no guarde nada.  Es conveniente imaginar que entre los operadores de una transacci√≥n, cualquier otro operador de otras transacciones puede "encajar", por ejemplo, as√≠: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-comment"><span class="hljs-comment">----- | UPDATE accounts SET amount = amount - 200 WHERE id = 1; | COMMIT; ----- UPDATE accounts SET amount = amount - 1000 WHERE id = 1; END IF;</span></span></code> </pre><br>  Si, reorganizando los operadores, puede arruinar todo, entonces el c√≥digo est√° escrito incorrectamente.  Y no se enga√±e a s√≠ mismo de que tal combinaci√≥n de circunstancias no suceder√°, suceder√°. <br><br>  ¬øC√≥mo escribir el c√≥digo correctamente?  Las oportunidades, como regla, se reducen a lo siguiente: <br><br><ul><li>  No escribas c√≥digo. <br>  Esto no es una broma.  Por ejemplo, en este caso, la verificaci√≥n se convierte f√°cilmente en una restricci√≥n de integridad: <br> <code>ALTER TABLE accounts ADD CHECK amount &gt;= 0;</code> <br>  Ahora, no se necesitan verificaciones: es suficiente simplemente realizar la acci√≥n y, si es necesario, manejar la excepci√≥n que surgir√° en el caso de un intento de violar la integridad. <br></li><li>  Use una sola declaraci√≥n SQL. <br>  Los problemas de consistencia surgen debido al hecho de que en el intervalo entre operadores puede finalizar otra transacci√≥n y los datos visibles cambiar√°n.  Y si solo hay un operador, entonces no hay huecos. <br>  PostgreSQL tiene suficientes herramientas para resolver problemas complejos con una sola declaraci√≥n SQL.  Observamos las expresiones de tabla general (CTE), en las que, entre otras cosas, puede usar las instrucciones INSERT / UPDATE / DELETE, as√≠ como la instrucci√≥n INSERT ON CONFLICT, que implementa la l√≥gica "insertar, y si ya hay una fila, actualizar" en una instrucci√≥n. <br></li><li>  Bloqueos de usuario. <br>  El √∫ltimo recurso es establecer manualmente un bloqueo exclusivo en todas las filas necesarias (SELECCIONAR PARA ACTUALIZAR) o en toda la tabla (TABLA DE BLOQUEO).  Esto siempre funciona, pero niega los beneficios de las versiones m√∫ltiples: en lugar de ejecutar simult√°neamente, parte de las operaciones se realizar√°n secuencialmente. <br></li></ul><br><h3>  Lectura inconsistente </h3><br>  Antes de embarcarse en el siguiente nivel de aislamiento, uno tiene que admitir que no todo es tan simple.  La implementaci√≥n de PostgreSQL es tal que permite otras anomal√≠as menos conocidas que no est√°n reguladas por el est√°ndar. <br><br>  Digamos que la primera transacci√≥n comenz√≥ a transferir fondos de una cuenta Bob a otra: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  En este momento, otra transacci√≥n calcula el saldo de Bob, y el c√°lculo se realiza en un ciclo en todas las cuentas de Bob.  De hecho, la transacci√≥n comienza desde la primera cuenta (y, obviamente, ve el estado anterior): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | -------- | 100.00 | (1 row)</code> </pre><br>  En este punto, la primera transacci√≥n se completa con √©xito: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Y el otro lee el estado de la segunda cuenta (y ya ve un nuevo valor): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | --------- | 1000.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Por lo tanto, la segunda transacci√≥n recibi√≥ un total de 1100 ‚ÇΩ, es decir, datos incorrectos.  Esta es una anomal√≠a de <em>lectura inconsistente</em> . <br><br>  ¬øC√≥mo evitar tal anomal√≠a al permanecer en Read Committed?  Por supuesto, use un operador.  Por ejemplo, as√≠: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><br>  Hasta ahora, he argumentado que la visibilidad de los datos solo puede cambiar entre operadores, pero ¬øes tan obvio?  Y si la solicitud lleva mucho tiempo, ¬øpuede ver parte de los datos en un estado y parte en el otro? <br><br>  Compru√©balo  Una forma conveniente de hacer esto es insertar un retraso artificial en el operador llamando a la funci√≥n pg_sleep.  Su par√°metro establece el tiempo de retraso en segundos. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount, pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Mientras esta construcci√≥n est√° en progreso, en otra transacci√≥n, transferimos los fondos de regreso: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  El resultado muestra que el operador ve los datos en el estado en que estaban en el momento en que comenzaron.  Esto es ciertamente correcto. <br><br><pre> <code class="plaintext hljs"> amount | pg_sleep ---------+---------- 0.00 | 1000.00 | (2 rows)</code> </pre><br>  Pero aqu√≠ no es tan simple.  PostgreSQL le permite definir funciones, mientras que las funciones tienen el concepto de una <em>categor√≠a de variabilidad</em> .  Si se llama a una funci√≥n <em>vol√°til</em> (con la categor√≠a VOL√ÅTIL) en una solicitud, y se ejecuta otra solicitud en esta funci√≥n, entonces esta solicitud dentro de la funci√≥n ver√° datos que no son consistentes con los datos de la solicitud principal. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_amount(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> amount </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> accounts a </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> a.id = get_amount.id; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">VOLATILE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> get_amount(id), pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  En este caso, obtenemos datos incorrectos: se pierden 100:: <br><br><pre> <code class="plaintext hljs"> get_amount | pg_sleep ------------+---------- 100.00 | 800.00 | (2 rows)</code> </pre><br>  Insisto en que tal efecto solo es posible en el nivel de aislamiento de lectura comprometida, y solo con la categor√≠a de variabilidad VOL√ÅTIL.  El problema es que este nivel de aislamiento y esta categor√≠a de variabilidad se usan por defecto, as√≠ que debo admitir que el rastrillo se encuentra muy bien.  ¬°No pises! <br><br><h3>  Lectura inconsistente a cambio de cambios perdidos </h3><br>  Se puede obtener una lectura inconsistente dentro del marco de un operador, de una manera algo inesperada, durante una actualizaci√≥n. <br><br>  Veamos qu√© sucede cuando intenta cambiar la misma fila con dos transacciones.  Bob ahora tiene 1000 ‚ÇΩ en dos cuentas: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><br>  Comenzamos una transacci√≥n que reduce el saldo de Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br>  Al mismo tiempo, otra transacci√≥n genera intereses en todas las cuentas de clientes con un saldo total igual o superior a 1000 ‚ÇΩ: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br>  La ejecuci√≥n de una instrucci√≥n UPDATE consta de dos partes.  Primero, se ejecuta un SELECT, que selecciona las filas que coinciden con la condici√≥n para la actualizaci√≥n.  Como el cambio de la primera transacci√≥n no es fijo, la segunda transacci√≥n no puede verlo y no afecta la elecci√≥n de las l√≠neas para calcular el inter√©s.  Por lo tanto, las cuentas de Bob caen bajo la condici√≥n y, una vez completada la actualizaci√≥n, su saldo deber√≠a aumentar en 10 ‚ÇΩ. <br><br>  La segunda etapa de ejecuci√≥n: las filas seleccionadas se actualizan una tras otra.  Aqu√≠ la segunda transacci√≥n se ve obligada a "congelarse", porque la l√≠nea id = 3 ya est√° bloqueada por la primera transacci√≥n. <br><br>  Mientras tanto, la primera transacci√≥n confirma los cambios: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  ¬øCu√°l ser√° el resultado? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+---------- 2 | 2001 | bob | 202.0000 3 | 2002 | bob | 707.0000 (2 rows)</code> </pre><br>  S√≠, por un lado, el comando ACTUALIZAR no deber√≠a ver cambios en la segunda transacci√≥n.  Pero, por otro lado, no debe perder los cambios registrados en la segunda transacci√≥n. <br><br>  Despu√©s de liberar el bloqueo, ACTUALIZAR vuelve a leer la l√≠nea que est√° tratando de actualizar (¬°pero solo una!).  El resultado es que Bob acumul√≥ 9 ‚ÇΩ, basado en la cantidad de 900 ‚ÇΩ.  Pero si Bob tuviera 900 ‚ÇΩ, sus cuentas no deber√≠an haber sido incluidas en la muestra. <br><br>  Entonces, la transacci√≥n recibe datos incorrectos: algunas de las filas son visibles en un punto en el tiempo, algunas en el otro.  En lugar de una actualizaci√≥n perdida, nuevamente tenemos una anomal√≠a en la <em>lectura inconsistente</em> . <br><br><blockquote>  Los lectores atentos notan que con un poco de ayuda de la aplicaci√≥n en el nivel Compromiso de lectura, puede obtener una actualizaci√≥n perdida.  Por ejemplo, as√≠: <br><br><pre> <code class="pgsql hljs"> x := (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = x + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  La base de datos no tiene la culpa: recibe dos sentencias SQL y no sabe nada de que el valor de x + 100 est√© relacionado de alguna manera con accounts.amount.  No escriba c√≥digo de esta manera. <br></blockquote><br><h2>  Lectura repetible </h2><br><h3>  Falta de lecturas no repetidas y fantasmas </h3><br>  El nombre del nivel de aislamiento en s√≠ mismo indica que la lectura es repetible.  Verificaremos esto, y al mismo tiempo nos convenceremos de la ausencia de lecturas fantasmas.  Para hacer esto, en la primera transacci√≥n, devuelva las cuentas de Bob a su estado anterior y cree una nueva cuenta para Charlie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">200.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">800.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'3001'</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+---------+-------- 1 | 1001 | alice | 800.00 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  En la segunda sesi√≥n, comenzamos la transacci√≥n con el nivel de Lectura repetible, indic√°ndolo en el comando BEGIN (el nivel de la primera transacci√≥n no es importante). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><br>  Ahora la primera transacci√≥n confirma los cambios, y la segunda vuelve a ejecutar la misma solicitud. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  La segunda transacci√≥n contin√∫a viendo exactamente los mismos datos que al principio: ni los cambios en las l√≠neas existentes ni las nuevas l√≠neas son visibles. <br><br>  En este nivel, no tiene que preocuparse de que algo cambie entre los dos operadores. <br><br><h3>  Error de serializaci√≥n a cambio de cambios perdidos </h3><br>  Dijimos anteriormente que al actualizar la misma fila con dos transacciones en el nivel Confirmar lectura, puede producirse una anomal√≠a de lectura inconsistente.  Esto se debe al hecho de que la transacci√≥n pendiente vuelve a leer la fila bloqueada y, por lo tanto, no la ve en el mismo momento en el tiempo que el resto de las filas. <br><br>  En el nivel de lectura repetible, dicha anomal√≠a no est√° permitida, pero si ocurre, no se puede hacer nada; por lo tanto, la transacci√≥n finaliza con un error de serializaci√≥n.  Verificamos repitiendo el mismo escenario con porcentajes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| ERROR: could not serialize access due to concurrent update</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Los datos se mantuvieron consistentes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 700.00 (2 rows)</code> </pre><br>  Se producir√° el mismo error en el caso de cualquier otro cambio de fila competitivo, incluso si las columnas de inter√©s para nosotros no han cambiado realmente. <br><br>  <em>Conclusi√≥n pr√°ctica</em> : si la aplicaci√≥n utiliza el nivel de aislamiento de lectura repetible para escribir transacciones, deber√≠a estar lista para repetir transacciones que terminaron en un error de serializaci√≥n.  Para transacciones de solo lectura, tal resultado no es posible. <br><br><h3>  Entrada inconsistente </h3><br>  Entonces, en PostgreSQL, en el nivel de aislamiento de lectura repetible, se evitan todas las anomal√≠as descritas en el est√°ndar.  Pero no todo en absoluto.  Resulta que hay <em>exactamente dos</em> anomal√≠as que siguen siendo posibles.  (Esto es cierto no solo para PostgreSQL, sino tambi√©n para otras implementaciones de aislamiento basadas en instant√°neas). <br><br>  La primera de estas anomal√≠as es un <em>registro inconsistente</em> . <br><br>  Deje que se aplique esta regla de coherencia: <em>se permiten montos negativos en las cuentas del cliente si el monto total en todas las cuentas de este cliente no es negativo</em> . <br><br>  La primera transacci√≥n recibe el monto en las cuentas de Bob: 900 ‚ÇΩ. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum -------- 900.00 (1 row)</code> </pre><br>  La segunda transacci√≥n recibe la misma cantidad. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | -------- | 900.00 | (1 row)</code> </pre><br>  La primera transacci√≥n cree con raz√≥n que el monto de una de las cuentas se puede reducir en 600 ‚ÇΩ. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Y la segunda transacci√≥n llega a la misma conclusi√≥n.  Pero reduce otra puntuaci√≥n: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+--------- 2 | 2001 | bob | -400.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br>  Logramos que el saldo de Bob sea menos, aunque cada una de las transacciones funciona correctamente individualmente. <br><br><h3>  Anomal√≠a de solo lectura </h3><br>  Esta es la segunda y √∫ltima de las anomal√≠as posibles en el nivel de lectura repetible.  Para demostrarlo, necesitar√° tres transacciones, dos de las cuales modificar√°n los datos y la tercera, solo lectura. <br><br>  Pero primero, restaure el estado de la cuenta de Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 3 | 2002 | bob | 100.00 2 | 2001 | bob | 900.00 (2 rows)</code> </pre><br>  La primera transacci√≥n cobra intereses de Bob sobre la cantidad de fondos en todas las cuentas.  El inter√©s se acredita a una de sus cuentas: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br>  Luego, otra transacci√≥n retira dinero de otra cuenta de Bob y captura sus cambios: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Si en este momento se confirma la primera transacci√≥n, no habr√° anomal√≠a: podr√≠amos suponer que la primera transacci√≥n se complet√≥ primero, y luego la segunda (pero no al rev√©s, porque la primera transacci√≥n vio el estado de la cuenta id = 3 antes de que esta cuenta fuera cambiado por la segunda transacci√≥n). <br><br>  Pero suponga que en este momento comienza la tercera transacci√≥n (solo lectura), que lee el estado de alguna cuenta que no se ve afectada por las dos primeras transacciones: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><br>  Y solo despu√©s de eso se completa la primera transacci√≥n: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  ¬øQu√© estado deber√≠a ver ahora la tercera transacci√≥n? <br><br><pre> <code class="pgsql hljs">| <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Una vez iniciada, la tercera transacci√≥n podr√≠a ver cambios en la segunda transacci√≥n (que ya se hab√≠a confirmado), pero no en la primera (que a√∫n no se ha confirmado).  Por otro lado, ya hemos establecido anteriormente que la segunda transacci√≥n debe considerarse que comenz√≥ despu√©s de la primera.  Cualquiera que sea el estado que vea la tercera transacci√≥n, ser√° inconsistente: esta es la anomal√≠a de solo la transacci√≥n de lectura.  Pero en el nivel de lectura repetible, est√° permitido: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 2 | 2001 | bob | 900.00 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h2>  Serializable </h2><br>  En el nivel serializable, se evitan todas las anomal√≠as posibles.  De hecho, Serializable se implementa como un complemento de aislamiento basado en instant√°neas de datos.  Esas anomal√≠as que no ocurren durante la Lectura Repetible (como sucia, no repetible, lectura fantasma) tampoco ocurren en el nivel Serializable.  Y esas anomal√≠as que surgen (grabaci√≥n inconsistente y anomal√≠a de solo la transacci√≥n de lectura) se detectan y la transacci√≥n se cancela; el error de serializaci√≥n ya familiar no pudo serializar el acceso. <br><br><h3>  Entrada inconsistente </h3><br>  Para ilustrar, repetimos el escenario con una anomal√≠a de grabaci√≥n inconsistente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum ---------- 910.0000 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | ---------- | 910.0000 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ERROR: could not serialize access due to read/write dependencies among transactions DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt. HINT: The transaction might succeed if retried.</code> </pre><br>  Adem√°s del nivel de lectura repetible, una aplicaci√≥n que utiliza el nivel de aislamiento serializable debe repetir las transacciones que terminaron en un error de serializaci√≥n, que tambi√©n nos informa la sugerencia en el mensaje de error. <br><br>  Obtenemos la simplicidad de la programaci√≥n, pero el precio es la ruptura forzada de una cierta proporci√≥n de transacciones y la necesidad de repetirlas.  Toda la pregunta, por supuesto, es qu√© tan grande es esta participaci√≥n.  Si solo se terminaran esas transacciones que realmente se cruzan de manera incompatible en los datos con otras transacciones, todo estar√≠a bien.  Pero tal implementaci√≥n inevitablemente resultar√≠a ser intensiva en recursos e ineficiente, ya que tendr√≠a que rastrear las operaciones con cada fila. <br><br>  De hecho, la implementaci√≥n de PostgreSQL es tal que permite disparadores negativos falsos: algunas transacciones completamente normales que simplemente "no tienen suerte" se romper√°n.  Como veremos m√°s adelante, esto depende de muchas razones, por ejemplo, la disponibilidad de √≠ndices adecuados o la cantidad de RAM disponible.  Adem√°s, hay otras restricciones de implementaci√≥n (bastante serias), por ejemplo, las solicitudes en el nivel Serializable no funcionar√°n en las r√©plicas, no se utilizar√°n planes de ejecuci√≥n paralelos para ellas.  Y aunque el trabajo para mejorar la implementaci√≥n no se detiene, las restricciones existentes reducen el atractivo de este nivel de aislamiento. <br><blockquote>  Los planes paralelos aparecer√°n en PostgreSQL 12 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parche</a> ).  Y las consultas sobre r√©plicas pueden ganar en PostgreSQL 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otro parche</a> ). <br></blockquote><br><h3>  Anomal√≠a de solo lectura </h3><br>  Para que solo una transacci√≥n de lectura no pueda conducir a una anomal√≠a y no pueda sufrirla, PostgreSQL ofrece un mecanismo interesante: dicha transacci√≥n puede bloquearse hasta que su ejecuci√≥n sea segura.  Este es el √∫nico caso donde una declaraci√≥n SELECT puede ser bloqueada por actualizaciones de fila.  As√≠ es como se ve: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 900.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  La tercera transacci√≥n es declarada expl√≠citamente solo por el lector (SOLO LEER) y diferida (DEFERRABLE): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFERRABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><br>  Cuando intenta ejecutar una solicitud, la transacci√≥n se bloquea, porque de lo contrario su ejecuci√≥n provocar√° una anomal√≠a. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Y solo despu√©s de que se confirma la primera transacci√≥n, la tercera contin√∫a ejecut√°ndose: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 2 | 2001 | bob | 910.0000 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Otra nota importante: si se usa el aislamiento serializable, entonces todas las transacciones en la aplicaci√≥n deben usar este nivel.  No puede mezclar transacciones confirmadas de lectura (o lectura repetible) con serializable.  Es decir, puede mezclar algo, pero Serializable se comportar√° como una Lectura repetible sin previo aviso.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por qu√© sucede esto, lo consideraremos m√°s adelante cuando hablemos sobre la implementaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, si decide usar Serializble, es mejor establecer globalmente el nivel predeterminado (aunque esto, por supuesto, no proh√≠be especificar el nivel incorrecto expl√≠citamente):</font></font><br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> default_transaction_isolation = <span class="hljs-string"><span class="hljs-string">'serializable'</span></span>;</code> </pre><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se puede encontrar una presentaci√≥n m√°s rigurosa de los problemas relacionados con las transacciones, la coherencia y las anomal√≠as en </font><font style="vertical-align: inherit;">el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libro</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curso de conferencias de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boris Asenovich Novikov </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">,</font></a><font style="vertical-align: inherit;"> "Fundamentos de las tecnolog√≠as de bases de datos".</font></font><br></blockquote><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øQu√© nivel de aislamiento debo usar? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El nivel de aislamiento de lectura comprometida se usa por defecto en PostgreSQL, y parece que este nivel se usa en la gran mayor√≠a de las aplicaciones. Es conveniente porque es posible una interrupci√≥n de la transacci√≥n solo en caso de falla, pero no para evitar inconsistencias. En otras palabras, no se puede producir un error de serializaci√≥n.</font></font><br><br>        ,     .          ,     .         SQL-,      .   ,       ,     ,              . <br><br>   Repeatable Read    , , ,  .        ,     ,      . , , .          Read Committed   , ,   ,   SQL-. <br><br> ,  Serializable      ,     . ,     ‚Äî        .    ,   ,           .   ,   Serializable    ,  ,        . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442804/">https://habr.com/ru/post/442804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442790/index.html">El registro est√° abierto para Allure Server Meetup en San Petersburgo</a></li>
<li><a href="../442794/index.html">Te invitamos a la conferencia ‚ÄúArquitecto (de TI) en proyectos y organizaciones de TI‚Äù</a></li>
<li><a href="../442796/index.html">Encuesta: tecnolog√≠as en la nube en SIG y servicios de geodatos</a></li>
<li><a href="../442798/index.html">Monitorear pings entre anfitriones de Kubernetes es nuestra receta</a></li>
<li><a href="../442800/index.html">Telegram simple bot en Python en 30 minutos</a></li>
<li><a href="../442806/index.html">El programa preliminar DUMP-2019 est√° listo. Oradores de Evil Martians, Tinkoff.ru, HTML Academy, SkyEng, 2GIS</a></li>
<li><a href="../442808/index.html">Te invitamos a la Fiesta Droid, una reuni√≥n dedicada a cuestiones pr√°cticas del desarrollo de aplicaciones y dispositivos Android.</a></li>
<li><a href="../442810/index.html">Mitos de la f√≠sica popular, continuaci√≥n: Gravedad</a></li>
<li><a href="../442812/index.html">"No veo ninguna raz√≥n para usar Python para trabajar con Spark, excepto la pereza"</a></li>
<li><a href="../442814/index.html">Han pasado 10 a√±os, y nadie ha descubierto c√≥mo usar la cadena de bloques. ¬øY aqu√≠ otra vez?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>