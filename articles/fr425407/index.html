<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äç‚öñÔ∏è ‚ûó ‚õµÔ∏è Firecore - un jeu amusant sur AVR ü•ù ü¶ç ‚õ∞Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je veux partager une autre construction √† long terme du soir, qui montre que vous pouvez faire des jeux m√™me sur du mat√©riel faible. 

 √Ä propos de ce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Firecore - un jeu amusant sur AVR</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425407/"><img src="https://habrastorage.org/webt/dv/yz/hr/dvyzhr-e4xxmj6jbln7ngiti5d0.png"><br><br>  Je veux partager une autre construction √† long terme du soir, qui montre que vous pouvez faire des jeux m√™me sur du mat√©riel faible. <br><br>  √Ä propos de ce que vous deviez faire, comment cela a √©t√© d√©cid√© et comment faire quelque chose de plus qu'un simple clone de Pong - bienvenue chez Cat. <br><br>  Attention: grand article, trafic et insertions de code multiples! <br><a name="habracut"></a><br><h3>  En bref sur le jeu </h3><hr>  Shoot`em up!  - maintenant sur AVR. <br><br>  En fait, c'est un autre shmap, donc une fois de plus, le personnage principal <s>Shepard</s> doit sauver la galaxie d'une attaque soudaine de personnes inconnues, se frayant un chemin dans l'espace √† travers les √©toiles et les champs d'ast√©ro√Ødes nettoyant simultan√©ment chaque syst√®me stellaire. <br>  L'ensemble du jeu est √©crit en C et C ++ sans utiliser la biblioth√®que Wire d'Arduino. <br><br>  Le jeu propose 4 navires (ce dernier est disponible apr√®s le passage), chacun avec ses propres caract√©ristiques: <br><ul><li>  maniabilit√©; </li><li>  durabilit√©; </li><li>  puissance des armes √† feu. </li></ul><br>  √âgalement impl√©ment√©: <br><ul><li>  Graphiques couleur 2D; </li><li>  puissance pour les armes; </li><li>  les patrons √† la fin des niveaux; </li><li>  niveaux avec ast√©ro√Ødes (et leur animation de rotation); </li><li>  changement de couleur d'arri√®re-plan aux niveaux (et pas seulement l'espace noir); </li><li>  le mouvement des √©toiles en arri√®re-plan √† diff√©rentes vitesses (pour l'effet de la profondeur); </li><li>  notation et sauvegarde en EEPROM; </li><li>  les m√™mes sons (coups de feu, explosions, etc.); </li><li>  une mer d'adversaires identiques. </li></ul><br><h3>  Plateforme </h3><hr>  Le retour du fant√¥me. <br><br><blockquote>  Je pr√©ciserai √† l'avance que cette plateforme doit √™tre per√ßue comme l'ancienne console de jeu de la <s>premi√®re</s> troisi√®me g√©n√©ration (80s, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">shiru8bit</a> ). <br></blockquote><br>  De plus, les modifications mat√©rielles par rapport au mat√©riel d'origine sont interdites, ce qui garantit le lancement sur toute autre carte identique d√®s la sortie de la bo√Æte. <br>  Ce jeu a √©t√© √©crit pour la carte Arduino Esplora, mais le transfert vers GBA ou toute autre plate-forme, je pense, ne sera pas difficile. <br>  N√©anmoins, m√™me sur cette ressource, ce forum n'a √©t√© couvert que quelques fois, et d'autres conseils ne valaient pas la peine d'√™tre mentionn√©s, malgr√© la communaut√© assez large de chacun: <br><ul><li>  GameBuino META: </li><li>  Pokitto; </li><li>  makerBuino; </li><li>  Arduboy; </li><li>  UzeBox / FuzeBox; </li><li>  et bien d'autres. </li></ul><br>  Pour commencer, ce qui n'est pas sur Esplora: <br><ul><li>  beaucoup de m√©moire (ROM 28kb, RAM 2,5kb); </li><li>  puissance (CPU 8 bits √† 16 MHz); </li><li>  DMA </li><li>  g√©n√©rateur de caract√®res; </li><li>  des zones de m√©moire allou√©es ou des registres sp√©ciaux.  destination (palette, tuiles, fond, etc.); </li><li>  contr√¥ler la luminosit√© de l'√©cran (oh, tant d'effets √† la poubelle); </li><li>  extenseurs d'espace d'adressage (mappeurs); </li><li>  d√©bogueur ( <s>mais qui en a besoin quand il y a un √©cran entier!</s> ). </li></ul><br>  Je vais continuer avec le fait qu'il y a: <br><ul><li>  SPI mat√©riel (peut fonctionner √† la vitesse F_CPU / 2); </li><li>  √©cran bas√© sur ST7735 160x128 1,44 "; </li><li>  une pinc√©e de minuteries (seulement 4 pi√®ces); </li><li>  une pinc√©e de GPIO; </li><li>  une poign√©e de boutons (5pcs. + joystick √† deux axes); </li><li>  peu de capteurs (√©clairage, acc√©l√©rom√®tre, thermom√®tre); </li><li>  √©metteur d' <s>irritation</s> piezo buzzer. </li></ul><br>  Apparemment, il n'y a presque rien.  Il n'est pas surprenant que personne ne veuille faire quoi que ce soit avec elle, sauf le clone de Pong et deux ou trois matchs pour tout ce temps! <br>  Le fait est peut-√™tre que l'√©criture sous le contr√¥leur ATmega32u4 (et similaires) est similaire √† la programmation pour Intel 8051 (qui a presque 40 ans au moment de la publication), o√π vous devez observer un grand nombre de conditions et recourir √† diverses astuces et astuces. <br><br><h3>  Traitement p√©riph√©rique </h3><hr>  Un pour tout! <br><br>  Apr√®s avoir examin√© le circuit, il a √©t√© clairement vu que tous les p√©riph√©riques sont connect√©s via l'expandeur GPIO (multiplexeur 74HC4067D plus MUX) et sont commut√©s √† l'aide du GPIO PF4, PF5, PF6, PF7 ou du grignotage PORTF senior, et la sortie MUX est lue sur GPIO - PF1. <br>  Il est tr√®s pratique de commuter l'entr√©e en attribuant simplement des valeurs au port PORTF par masque et en n'oubliant en aucun cas le quartet mineur: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> getAnalogMux(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> chMux) { MUX_PORTX = ((MUX_PORTX &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>) | ((chMux&lt;&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">0xF0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readADC(); }</code> </pre> <br>  Sondage de clic sur le bouton: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_MIN_LVL 800 bool readSwitchButton(uint8_t btn) { bool state = true; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(getAnalogMux(btn) &gt; SW_BTN_MIN_LVL) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// low state == pressed state = false; } return state; }</span></span></span></span></code> </pre><br>  Voici les valeurs du port F: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_1_MUX 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_2_MUX 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_3_MUX 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_4_MUX 12</span></span></code> </pre><br>  En ajoutant un peu plus: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_A SW_BTN_4_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_B SW_BTN_1_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_X SW_BTN_2_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_Y SW_BTN_3_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> buttonIsPressed(a) readSwitchButton(a)</span></span></code> </pre><br>  Vous pouvez interroger en toute s√©curit√© la bonne croix: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateBtnStates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_A)) btnStates.aBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_B)) btnStates.bBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_X)) btnStates.xBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_Y)) btnStates.yBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Veuillez noter que l'√©tat pr√©c√©dent n'est pas r√©initialis√©, sinon vous pouvez manquer le fait d'appuyer sur la touche (cela fonctionne √©galement comme une protection suppl√©mentaire contre le bavardage). <br><br><h3>  Sfx </h3><hr>  Un bourdonnement. <br><br>  Que faire s'il n'y a pas de DAC, pas de puce de Yamaha et qu'il n'y a qu'un rectangle PWM 1 bit pour le son? <br>  Au d√©but, cela ne semble pas tellement, mais, malgr√© cela, le PWM rus√© est utilis√© ici pour recr√©er la technique ¬´audio PDM¬ª et avec son aide, vous pouvez le faire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">.</a> <br><br>  Quelque chose de similaire est fourni par la biblioth√®que de Gamebuino et tout ce qui est n√©cessaire est de transf√©rer le g√©n√©rateur de popping vers un autre GPIO et le temporisateur vers Esplora (sortie timer4 et OCR4D).  Pour un fonctionnement correct, timer1 est √©galement utilis√© pour g√©n√©rer des interruptions et recharger le registre OCR4D avec de nouvelles donn√©es. <br><br>  Le moteur Gamebuino utilise des mod√®les sonores (comme dans la musique de tracker), ce qui √©conomise beaucoup d'espace, mais vous devez faire tous les √©chantillons vous-m√™me, il n'y a pas de biblioth√®ques avec celles pr√™tes √† l'emploi. <br>  Il convient de mentionner que ce moteur est li√© √† une p√©riode de mise √† jour d'environ 1/50 s ou 20 images / s. <br><br>  Pour lire les mod√®les sonores, apr√®s avoir lu le wiki sur le format audio, j'ai esquiss√© une interface graphique simple sur Qt.  Il n'√©met pas de son de la m√™me mani√®re, mais donne une id√©e approximative de la fa√ßon dont le motif sonnera et vous permet de le charger, de l'enregistrer et de le modifier. <br><br><h3>  Graphisme </h3><hr>  Immortal Pixelart. <br><br>  L'affichage code les couleurs sur deux octets (RGB565), mais comme les images dans ce format prendront beaucoup, elles ont toutes √©t√© index√©es par la palette pour √©conomiser de l'espace, ce que j'ai d√©j√† d√©crit plus d'une fois dans mes articles pr√©c√©dents. <br>  Contrairement √† Famicom / NES, il n'y a pas de limites de couleur pour l'image et il y a plus de couleurs disponibles dans la palette. <br><br>  Chaque image du jeu est un tableau d'octets dans lequel les donn√©es suivantes sont stock√©es: <br><ul><li>  largeur, hauteur; </li><li>  marqueur de d√©but de donn√©es; </li><li>  dictionnaire (le cas √©ch√©ant, mais plus √† ce sujet plus tard); </li><li>  charge utile; </li><li>  marqueur de fin de donn√©es. </li></ul><br>  Par exemple, une telle image (agrandie 10 fois): <br><img src="https://habrastorage.org/webt/zk/rr/es/zkrresh27swmtvck9fagoemando.png"><br><br>  dans le code, cela ressemblera √† ceci: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pic_t</span></span> weaponLaserPic1[] PROGMEM = { <span class="hljs-number"><span class="hljs-number">0x0f</span></span>,<span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x32</span></span>,<span class="hljs-number"><span class="hljs-number">0xa2</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>,<span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x06</span></span>,<span class="hljs-number"><span class="hljs-number">0x22</span></span>,<span class="hljs-number"><span class="hljs-number">0x41</span></span>,<span class="hljs-number"><span class="hljs-number">0xad</span></span>,<span class="hljs-number"><span class="hljs-number">0x03</span></span>,<span class="hljs-number"><span class="hljs-number">0x41</span></span>,<span class="hljs-number"><span class="hljs-number">0x22</span></span>,<span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x06</span></span>,<span class="hljs-number"><span class="hljs-number">0xa2</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x23</span></span>,<span class="hljs-number"><span class="hljs-number">0xff</span></span>, };</code> </pre><br>  O√π sans navire dans ce genre?  Apr√®s des centaines de croquis de test avec une diff√©rence de pixels, seuls ces navires restaient pour le joueur: <br><img src="https://habrastorage.org/webt/ao/4y/jm/ao4yjmxt3bl3ydqrjajnmgy4ms8.png"><br>  Il est √† noter que les navires n'ont pas de flamme dans les carreaux (ici c'est pour plus de clart√©), il est appliqu√© s√©par√©ment pour cr√©er une animation de l'√©chappement du moteur. <br><br>  N'oubliez pas les pilotes de chaque navire: <br><img src="https://habrastorage.org/webt/fk/fj/xf/fkfjxfoscgeu69pabaolb4zt6mo.png"><br><br>  La variation des navires ennemis n'est pas trop grande, mais permettez-moi de vous rappeler qu'il n'y a pas trop d'espace, alors voici trois navires: <br><img src="https://habrastorage.org/webt/w2/-v/o3/w2-vo3itdzkpoptpywwgjn5ytc8.png"><br><br>  Sans bonus canoniques sous forme d'am√©lioration des armes et de restauration de la sant√©, le joueur ne durera pas longtemps: <br><img src="https://habrastorage.org/webt/kw/gw/7d/kwgw7duf5hnztuobgg_pwclk8nm.png"><br><br>  Bien s√ªr, avec l'augmentation de la puissance des canons, le type d'obus √©mis change: <br><img src="https://habrastorage.org/webt/yq/dn/67/yqdn67u3cvbmzbn0j46v9iiievy.png"><br><br>  Comme il √©tait √©crit au d√©but, le jeu a un niveau avec des ast√©ro√Ødes, il vient apr√®s chaque deuxi√®me boss.  Il est int√©ressant de noter qu'il existe de nombreux objets mobiles et rotatifs de diff√©rentes tailles.  De plus, lorsqu'un joueur les frappe, ils s'effondrent partiellement, devenant plus petits. <br><blockquote>  Astuce: les gros ast√©ro√Ødes gagnent plus de points. <br></blockquote><br><img src="https://habrastorage.org/webt/d6/hg/9a/d6hg9atxd8gzj9m9njyhac4i7bq.gif"><br><img src="https://habrastorage.org/webt/ow/pv/yf/owpvyfbgmn45yueagrafne4w2ng.gif"><br><img src="https://habrastorage.org/webt/jc/eh/r_/jcehr_zvccitvi24lcdmxiiewik.gif"><br>  Pour cr√©er cette animation simple, 12 petites images suffisent: <br><img src="https://habrastorage.org/webt/yr/uz/g3/yruzg3mwjlg3bv_z2pljhzyql68.png"><br>  Ils sont divis√©s en trois pour chaque taille (grande, moyenne et petite) et pour chaque angle de rotation, vous avez besoin de 4 autres degr√©s de rotation de 0, 90, 180 et 270 degr√©s.  Dans le jeu, il suffit de remplacer le pointeur du tableau par l'image √† un intervalle √©gal cr√©ant ainsi l'illusion de rotation. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotateAsteroid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">asteroid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;asteroid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(RN &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { asteroid.sprite.pPic = getAsteroidPic(asteroid); ++asteroid.angle; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveAsteroids</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;asteroid : asteroids) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(asteroid.onUse) { updateSprite(&amp;asteroid.sprite); rotateAsteroid(asteroid); ...</code> </pre><br>  Cela se fait uniquement en raison du manque de capacit√©s mat√©rielles, et une impl√©mentation logicielle comme la transformation Affine prendra plus que les images elles-m√™mes et sera tr√®s lente. <br><br><div class="spoiler">  <b class="spoiler_title">Un morceau de satin pour ceux qui sont int√©ress√©s.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/el/uf/0l/eluf0lkcjsygvumvmosh_yzreig.png"><br>  Vous pouvez remarquer une partie des prototypes et ce qui n'appara√Æt qu'au g√©n√©rique apr√®s avoir pass√© le jeu. <br></div></div><br>  En plus des graphiques simples, pour √©conomiser de l'espace et ajouter un effet r√©tro, les glyphes minuscules et tous les glyphes jusqu'√† 30 et apr√®s 127 octets d'ASCII ont √©t√© supprim√©s de la police. <br><blockquote>  Important! <br>  N'oubliez pas que const et constexpr sur AVR ne signifient pas du tout que les donn√©es seront dans la m√©moire du programme, ici, pour cela, vous devez √©galement utiliser PROGMEM. <br>  Cela est d√ª au fait que le noyau AVR est bas√© sur l'architecture Harvard, donc des codes d'acc√®s sp√©ciaux pour le CPU sont n√©cessaires pour acc√©der aux donn√©es. <br></blockquote><br><h3>  Serrer la galaxie </h3><hr>  Le moyen le plus simple d'emballer est le RLE. <br><br>  Apr√®s avoir √©tudi√© les donn√©es compress√©es, vous pouvez remarquer que le bit le plus significatif de l'octet de charge utile dans la plage de 0x00 √† 0x50 n'est pas utilis√©.  Cela vous permet d'ajouter les donn√©es et le marqueur de d√©but pour le d√©but de r√©p√©tition (0x80), et l'octet suivant pour indiquer le nombre de r√©p√©titions, ce qui vous permet de compresser une s√©rie de 257 (+2 du fait que RLE de deux octets est stupide) d'octets identiques en seulement deux. <br>  Impl√©mentation et affichage du d√©compresseur: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawPico_RLE_P</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pPic)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> repeatColor; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> tmpInd, repeatTimes; alphaReplaceColorId = getAlphaReplaceColorId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpData = getPicSize(pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); tftSetAddrWindow(x, y, x+tmpData.u8Data1, y+tmpData.u8Data2); ++pPic; <span class="hljs-comment"><span class="hljs-comment">// make offset to picture data while((tmpInd = getPicByte(++pPic)) != PIC_DATA_END) { // get color index or repeat times if(tmpInd &amp; RLE_MARK) { // is it color index? tmpInd &amp;= DATA_MARK; // get color index to repeat repeatTimes = getPicByte(++pPic)+1; // zero RLE does not exist! } ++repeatTimes; // get color from colorTable by color index repeatColor = palette_RAM[(tmpInd == ALPHA_COLOR_ID) ? alphaReplaceColorId : tmpInd]; do { pushColorFast(repeatColor); } while(--repeatTimes); } }</span></span></code> </pre><br>  L'essentiel est de ne pas afficher l'image en dehors de l'√©cran, sinon ce sera des ordures, car il n'y a pas de contr√¥le de bordure ici. <br>  L'image de test est d√©compress√©e en ~ 39 ms.  en m√™me temps, occupant 3040 octets, alors que sans compression, il faudrait 11 200 octets ou 22 400 octets sans indexation. <br><br>  Image test (agrandie 2 fois): <br><img src="https://habrastorage.org/webt/ao/nl/6n/aonl6nxjmfjhbsmp0uc4n6h7w0e.png"><br>  Dans l'image ci-dessus, vous pouvez voir entrelac√©, mais √† l'√©cran, il est liss√© par le mat√©riel, cr√©ant un effet similaire √† CRT et en m√™me temps augmentant consid√©rablement le taux de compression. <br><br><h3>  Le RLE n'est pas une panac√©e </h3><hr>  Nous sommes trait√©s pour le d√©j√†-vu. <br><br>  Comme vous le savez, RLE va bien avec les conditionneurs de type LZ.  WiKi est venu √† la rescousse avec une liste de m√©thodes de compression.  L'impulsion √©tait la vid√©o de "GameHut" sur l'analyse de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intro</a> impossible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans Sonic 3D Blast.</a> <br>  Apr√®s avoir √©tudi√© de nombreux emballeurs (LZ77, LZW, LZSS, LZO, RNC, etc.), je suis arriv√© √† la conclusion que leurs d√©balleurs: <br><ul><li>  n√©cessitent beaucoup de RAM pour les donn√©es d√©compress√©es (au moins 64 Ko et plus); </li><li>  volumineux et lent (certains ont besoin de construire des arbres Huffman pour chaque sous-unit√©); </li><li>  avoir un faible taux de compression avec une petite fen√™tre (exigences de RAM tr√®s strictes); </li><li>  avoir des ambigu√Øt√©s avec l'octroi de licences. </li></ul><br>  Apr√®s des mois d'adaptations futiles, il a √©t√© d√©cid√© de modifier le packer existant. <br>  Par analogie avec les compresseurs de type LZ, pour obtenir une compression maximale, l'acc√®s au dictionnaire a √©t√© utilis√©, mais au niveau des octets - les paires d'octets les plus fr√©quemment r√©p√©t√©es sont remplac√©es par un pointeur d'un octet dans le dictionnaire. <br>  Mais il y a un hic: comment distinguer un octet de ¬´combien de r√©p√©titions¬ª d'un ¬´marqueur de dictionnaire¬ª? <br>  Apr√®s une longue s√©ance avec un morceau de papier et un jeu magique avec des chauves-souris, cela est apparu: <br><blockquote><ul><li>  ¬´Marqueur de dictionnaire¬ª est un marqueur RLE (0x80) + octet de donn√©es (0x50) + num√©ro de position dans le dictionnaire; </li><li>  limiter l'octet ¬´combien de r√©p√©titions¬ª √† la taille du marqueur de dictionnaire - 1 (0xCF); </li><li>  le dictionnaire ne peut pas utiliser la valeur 0xff (c'est pour le marqueur de fin d'image). </li></ul><br></blockquote><br>  En appliquant tout cela, nous obtenons une taille de dictionnaire fixe: pas plus de 46 paires d'octets et une r√©duction RLE √† 209 octets.  √âvidemment, toutes les images ne peuvent pas √™tre empaquet√©es comme ceci, mais elles ne le seront plus. <br>  Dans les deux algorithmes, la structure de l'image compress√©e sera la suivante: <br><ul><li>  1 octet par largeur et hauteur; </li><li>  1 octet pour la taille du dictionnaire, c'est un pointeur marqueur vers le d√©but des donn√©es compress√©es; </li><li>  de 0 √† 92 octets du dictionnaire; </li><li>  1 √† N octets de donn√©es compress√©es. </li></ul><br>  L'utilitaire packer r√©sultant sur D (pickoPacker) est suffisant pour mettre dans un dossier avec des fichiers * .png index√©s et ex√©cuter √† partir du terminal (ou cmd).  Si vous avez besoin d'aide, ex√©cutez l'option "-h" ou "--help". <br>  Apr√®s l'ex√©cution de l'utilitaire, nous obtenons des fichiers * .h, dont le contenu est pratique √† transf√©rer au bon endroit dans le projet (il n'y a donc pas de protection). <br><br>  Avant le d√©ballage, l'√©cran, le dictionnaire et les donn√©es initiales sont pr√©par√©s: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawPico_DIC_P</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pPic)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpData = getPicSize(pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); tftSetAddrWindow(x, y, x+tmpData.u8Data1, y+tmpData.u8Data2); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> tmpByte, unfoldPos, dictMarker; alphaReplaceColorId = getAlphaReplaceColorId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pDict = &amp;pPic[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// save dictionary pointer pPic += getPicByte(&amp;pPic[2]); // make offset to picture data do { unfoldPos = dictMarker = 0; do { if((tmpByte = getPicByte(++pPic)) != PIC_DATA_END) { if(tmpByte &lt; DICT_MARK) { buf_packed[unfoldPos] = tmpByte; } else { dictMarker = 1; setPicWData(&amp;buf_packed[unfoldPos]) = getPicWData(pDict, tmpByte); ++unfoldPos; } ++unfoldPos; } else { break; } } while((unfoldPos &lt; MAX_UNFOLD_SIZE) //&amp;&amp; (unfoldPos) &amp;&amp; ((tmpByte &gt; DATA_MARK) || (tmpByte &gt; MAX_DATA_LENGTH))); if(unfoldPos) { buf_packed[unfoldPos] = PIC_DATA_END; // mark end of chunk printBuf_RLE( dictMarker ? unpackBuf_DIC(pDict) : &amp;buf_packed[0] ); // V2V3 decoder } } while(unfoldPos); }</span></span></code> </pre><br>  Un morceau de donn√©es lu peut √™tre emball√© dans un dictionnaire, nous le v√©rifions et le d√©ballons donc: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPackedMark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptr &gt;= DICT_MARK) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*(++ptr) != PIC_DATA_END); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint8_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackBuf_DIC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pDict)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> swap = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dictMarker = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> getBufferPtr = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a[], <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b[]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> swap ? &amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>] : &amp;b[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptrP = getBufferPtr(buf_unpacked, buf_packed); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptrU = getBufferPtr(buf_packed, buf_unpacked); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(dictMarker) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptrP &gt;= DICT_MARK) { setPicWData(ptrU) = getPicWData(pDict, *ptrP); ++ptrU; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *ptrU = *ptrP; } ++ptrU; ++ptrP; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptrP == PIC_DATA_END) { *ptrU = *ptrP; <span class="hljs-comment"><span class="hljs-comment">// mark end of chunk swap = !swap; ptrP = getBufferPtr(buf_unpacked, buf_packed); ptrU = getBufferPtr(buf_packed, buf_unpacked); dictMarker = findPackedMark(ptrP); } } return getBufferPtr(buf_unpacked, buf_packed); }</span></span></code> </pre><br>  Maintenant, √† partir du tampon re√ßu, nous d√©compressons le RLE de mani√®re famili√®re et l'afficher √† l'√©cran: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printBuf_RLE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> repeatColor; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> repeatTimes, tmpByte; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tmpByte = *pData) != PIC_DATA_END) { <span class="hljs-comment"><span class="hljs-comment">// get color index or repeat times if(tmpByte &amp; RLE_MARK) { // is it RLE byte? tmpByte &amp;= DATA_MARK; // get color index to repeat repeatTimes = *(++pData)+1; // zero RLE does not exist! } ++repeatTimes; ++pData; // get color from colorTable by color index repeatColor = palette_RAM[(tmpByte == ALPHA_COLOR_ID) ? alphaReplaceColorId : tmpByte]; do { pushColorFast(repeatColor); } while(--repeatTimes); } }</span></span></code> </pre><br>  √âtonnamment, le remplacement de l'algorithme n'a pas affect√© de mani√®re significative le temps de d√©ballage et est d'environ 47 ms.  C'est presque 8 ms.  plus longtemps, mais l'image de test ne prend que 1650 octets! <br><br><h3>  Jusqu'√† la derni√®re mesure </h3><hr>  Presque tout peut √™tre fait plus rapidement! <br><br>  Malgr√© la pr√©sence de mat√©riel SPI, le noyau AVR offre beaucoup de maux de t√™te lors de son utilisation. <br>  On sait depuis longtemps que SPI sur AVR, en plus de fonctionner √† la vitesse F_CPU / 2, poss√®de √©galement un registre de donn√©es de seulement 1 octet (il n'est pas possible de charger 2 octets √† la fois). <br>  De plus, presque tout le code SPI sur AVR que j'ai rencontr√© fonctionne selon ce sch√©ma: <br><ul><li>  T√©l√©charger les donn√©es SPDR </li><li>  interroger le bit SPIF dans le SPSR en boucle. </li></ul><br>  Comme vous pouvez le voir, la fourniture continue de donn√©es, comme cela se fait sur le STM32, ne sent pas ici.  Mais, m√™me ici, vous pouvez acc√©l√©rer la sortie des deux d√©balleurs de ~ 3 ms! <br><br>  En ouvrant la fiche technique et en consultant la section ¬´Horloges du jeu d'instructions¬ª, vous pouvez calculer les co√ªts du processeur lors de la transmission d'un octet via SPI: <br><ul><li>  1 cycle pour le chargement du registre avec de nouvelles donn√©es; </li><li>  2 temps par bit (ou 16 temps par octet); </li><li>  1 barre par magie de ligne d'horloge (un peu plus tard sur ¬´NOP¬ª); </li><li>  1 horloge pour v√©rifier le bit d'√©tat dans SPSR (ou 2 horloge sur la branche); </li></ul><br>  Au total, pour transmettre un pixel (deux octets), 38 cycles d'horloge ou ~ 425600 cycles d'horloge pour l'image de test (11 200 octets) doivent √™tre d√©pens√©s. <br>  Sachant que F_CPU == 16 MHz, nous obtenons <s>0,0000000625</s> 62,5 nanosecondes par cycle d'horloge ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Process0169</a> ), en multipliant les valeurs, nous obtenons ~ 26 millisecondes.  La question se pose: ¬´D'o√π ai-je √©crit plus t√¥t que le temps de d√©ballage est de 39 ms.  et 47 ms. "?  Tout est simple - logique de d√©ballage + gestion des interruptions. <br><br>  Voici un exemple de sortie d'interruption: <br><img src="https://habrastorage.org/webt/du/ks/p1/duksp1nkfluio5sgfwyimgo9aik.png"><br>  et sans interruption: <br><img src="https://habrastorage.org/webt/v7/hp/xq/v7hpxqzhvsazrct5sbq7dkywq1w.png"><br>  Les graphiques montrent que le temps entre le r√©glage de la fen√™tre d'adresse dans l'√©cran VRAM et le d√©but du transfert de donn√©es dans la version sans interruption est moindre et qu'il n'y a presque pas d'√©cart entre les octets pendant la transmission (le graphique est uniforme). <br>  Malheureusement, vous ne pouvez pas d√©sactiver les interruptions pour chaque sortie d'image, sinon le son et le c≈ìur de tout le jeu se briseront (plus √† ce sujet plus tard). <br><br>  Il a √©t√© √©crit ci-dessus √† propos d'un certain "NOP magique" pour une ligne d'horloge.  Le fait est que pour stabiliser le CLK et d√©finir le drapeau SPIF, exactement 1 cycle d'horloge est n√©cessaire et au moment o√π ce drapeau est lu, il est d√©j√† d√©fini, ce qui √©vite de se ramifier en 2 barres sur l'instruction BREQ. <br>  Voici un exemple sans NOP: <br><img src="https://habrastorage.org/webt/vp/ia/w5/vpiaw5asga4dqawu3byh03k9gii.png"><br>  et avec lui: <br><img src="https://habrastorage.org/webt/jg/-q/4b/jg-q4b4ot1sy445kc5rvoyq-ixe.png"><br><br>  La diff√©rence semble insignifiante, juste quelques microsecondes, mais si vous prenez une √©chelle diff√©rente: <br>  Grand NOP: <br><img src="https://habrastorage.org/webt/nf/ds/gi/nfdsgii8xkar_f6jo5fihrpx8ei.png"><br>  et avec elle trop grande: <br><img src="https://habrastorage.org/webt/8z/d9/e9/8zd9e9l79lnhj9qshrykzxxptmw.png"><br>  alors la diff√©rence devient beaucoup plus sensible, atteignant ~ 4,3 ms. <br><br>  Faisons maintenant le sale tour suivant: <br><blockquote>  Nous √©changeons l'ordre de chargement et de lecture des registres et vous ne pouvez pas attendre chaque deuxi√®me octet du drapeau SPIF, mais v√©rifiez-le uniquement avant de charger le premier octet du pixel suivant. <br></blockquote><br>  Nous appliquons les connaissances et d√©ployons la fonction "pushColorFast (repeatColor);": <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPDR_TX_WAIT(a) asm volatile(a); while((SPSR &amp; (1&lt;&lt;SPIF)) == 0); typedef union { uint16_t val; struct { uint8_t lsb; uint8_t msb; }; } SPDR_t; ... do { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ESPLORA_OPTIMIZE SPDR_t in = {.val = repeatColor}; SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); SPDR = in.msb; SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"nop"</span></span></span><span class="hljs-meta">); SPDR = in.lsb; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> pushColorFast(repeatColor); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } while(--repeatTimes); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ESPLORA_OPTIMIZE SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// dummy wait to stable SPI #endif }</span></span></span></span></code> </pre><br>  Malgr√© l'interruption de la minuterie, l'utilisation de l'astuce ci-dessus donne un gain de pr√®s de 6 ms.: <br><img src="https://habrastorage.org/webt/ba/ah/hm/baahhmqnnvjznm1ssuihfi-ryhu.png"><br><br>  C'est ainsi que la simple connaissance du fer vous permet d'en tirer un peu plus et de produire quelque chose de similaire: <br><img src="https://habrastorage.org/webt/xo/fj/wv/xofjwvtbu_w_4leeunorug-axri.gif"><br><br><h3>  Collisions au Colis√©e </h3><hr>  La bataille des bo√Ætes. <br><br>  Pour commencer, l'ensemble des objets (navires, coquillages, ast√©ro√Ødes, bonus) sont des structures (sprites) avec les param√®tres suivants: <br><ul><li>  coordonn√©es X, Y actuelles; </li><li>  nouvelles coordonn√©es X, Y; </li><li>  pointeur sur l'image. </li></ul><br>  √âtant donn√© que l'image stocke la largeur et la hauteur, il n'est pas n√©cessaire de dupliquer ces param√®tres, de plus, une telle organisation simplifie la logique √† bien des √©gards. <br><br>  Le calcul lui-m√™me est rendu simple au banal - bas√© sur l'intersection des rectangles.  Bien qu'il ne soit pas suffisamment pr√©cis et ne calcule pas les conflits futurs, c'est plus que suffisant. <br>  La v√©rification s'effectue alternativement sur les axes X et Y. De ce fait, l'absence d'intersection sur l'axe X r√©duit le calcul de la collision. <br><blockquote>  Tout d'abord, le c√¥t√© droit du premier rectangle avec le c√¥t√© gauche du deuxi√®me rectangle est v√©rifi√© pour la partie commune de l'axe X. En cas de succ√®s, une v√©rification similaire est effectu√©e pour le c√¥t√© gauche du premier et le c√¥t√© droit du deuxi√®me rectangle. <br>  Apr√®s avoir d√©tect√© avec succ√®s les intersections le long de l'axe X, une v√©rification est effectu√©e de la m√™me mani√®re pour les c√¥t√©s sup√©rieur et inf√©rieur des rectangles le long de l'axe Y. <br></blockquote><br>  Ce qui pr√©c√®de semble beaucoup plus facile qu'il n'y para√Æt: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSpriteCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sprite_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pSprOne, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sprite_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pSprTwo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpDataOne = getPicSize(pSprOne-&gt;pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpDataTwo = getPicSize(pSprTwo-&gt;pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ----------- Check X position ----------- */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> objOnePosEndX = (pSprOne-&gt;pos.Old.x + tmpDataOne.u8Data1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(objOnePosEndX &gt;= pSprTwo-&gt;pos.Old.x) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> objTwoPosEndX = (pSprTwo-&gt;pos.Old.x + tmpDataTwo.u8Data1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pSprOne-&gt;pos.Old.x &gt;= objTwoPosEndX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// nope, different X positions } // ok, objects on same X lines; Go next... } else { return false; // nope, absolutelly different X positions } /* ---------------------------------------- */ /* ----------- Check Y position ----------- */ uint8_t objOnePosEndY = (pSprOne-&gt;pos.Old.y + tmpDataOne.u8Data2); if(objOnePosEndY &gt;= pSprTwo-&gt;pos.Old.y) { uint8_t objTwoPosEndY = (pSprTwo-&gt;pos.Old.y + tmpDataTwo.u8Data2); if(pSprOne-&gt;pos.Old.y &lt;= objTwoPosEndY) { // ok, objects on same Y lines; Go next... // yep, if we are here // then, part of one object collide wthith another object return true; } else { return false; // nope, different Y positions } } else { return false; // nope, absolutelly different Y positions } }</span></span></code> </pre><br>  Reste √† ajouter ceci au jeu: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkInVadersCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(aliens[<span class="hljs-number"><span class="hljs-number">0</span></span>].weapon.ray) gopher; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(alien.alive) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checkSpriteCollision(&amp;ship.sprite, &amp;alien.sprite)) { gopher.sprite.pos.Old = alien.sprite.pos.Old; rocketEpxlosion(&amp;gopher); <span class="hljs-comment"><span class="hljs-comment">// now make gopher to explode \(^_^)/ removeSprite(&amp;alien.sprite); alien.alive = false; score -= SCORE_PENALTY; if(score &lt; 0) score = 0; } } } }</span></span></code> </pre><br><br><h3>  Courbe de B√©zier </h3><hr>  Rails spatiaux. <br><br>  Comme dans tout autre jeu de ce genre, les navires ennemis doivent se d√©placer le long des courbes. <br>  Il a √©t√© d√©cid√© de mettre en ≈ìuvre des courbes quadratiques comme la plus simple pour le contr√¥leur et cette t√¢che.  Trois points leur suffisent: l'initiale (P0), la finale (P2) et l'imaginaire (P1).  Les deux premiers sp√©cifient le d√©but et la fin de la ligne, le dernier point d√©crit le type de courbure. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Excellent article sur les courbes.</a> <br>  Comme il s'agit d'une courbe param√©trique de B√©zier, elle a √©galement besoin d'un param√®tre suppl√©mentaire - le nombre de points interm√©diaires entre les points de d√©but et de fin. <br><br>  Au total, nous obtenons ici une telle structure: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// 7 bytes position_t P0; position_t P1; position_t P2; uint8_t totalSteps; } bezier_t;</span></span></code> </pre>  Dans ce document, position_t est une structure de deux octets de coordonn√©es X et Y. <br>  La recherche d'un point pour chaque coordonn√©e est calcul√©e √† l'aide de cette formule (thx Wiki): <br>  B = ((1.0 - t) ^ 2) P0 + 2t (1.0 - t) P1 + (t ^ 2) P2, <br>  t [&gt; = 0 &amp;&amp; &lt;= 1] <br><br>  Pendant longtemps, sa mise en ≈ìuvre a √©t√© r√©solue de front sans calcul √† virgule fixe: <br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = ((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)pItemLine-&gt;step)/((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)pLine-&gt;totalSteps); pPos-&gt;x = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P0.x + <span class="hljs-number"><span class="hljs-number">2</span></span>*t*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P1.x + t*t*pLine-&gt;P2.x; pPos-&gt;y = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P0.y + <span class="hljs-number"><span class="hljs-number">2</span></span>*t*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P1.y + t*t*pLine-&gt;P2.y; ...</code> </pre><br>  Bien s√ªr, cela ne peut pas √™tre laiss√©.  Apr√®s tout, se d√©barrasser du flotteur pourrait non seulement am√©liorer la vitesse, mais aussi lib√©rer la ROM, de sorte que les impl√©mentations suivantes ont √©t√© trouv√©es: <br><ul><li>  avrfix; </li><li>  stdfix; </li><li>  libfixmath; </li><li>  fixedptc. </li></ul><br>  Le premier reste un cheval noir, car il s'agit d'une biblioth√®que compil√©e et ne voulait pas jouer avec le d√©sassembleur. <br><br>  Le deuxi√®me candidat du bundle GCC n'a pas non plus fonctionn√©, car le avr-gcc utilis√© n'√©tait pas corrig√© et le type "short _Accum" n'√©tait pas disponible. <br><br>  La troisi√®me option, malgr√© le fait qu'il dispose d'un grand nombre de tapis.  fonctions, a des op√©rations binaires cod√©es en dur sur des bits sp√©cifiques sous le format Q16.16, ce qui rend impossible le contr√¥le des valeurs de Q et I. <br><br>  Ce dernier peut √™tre consid√©r√© comme une version simplifi√©e de "fixedmath", mais le principal avantage est la possibilit√© de contr√¥ler non seulement la taille de la variable, qui par d√©faut est de 32 bits avec le format Q24.8, mais aussi les valeurs de Q et I. <br><br>  R√©sultats des tests √† diff√©rents param√®tres: <br><table><tbody><tr><th>  Tapez </th><th>  QI </th><th>  Drapeaux suppl√©mentaires </th><th>  Octet ROM </th><th>  Tms. * </th></tr><tr><td>  flotter </td><td>  - </td><td>  - </td><td>  4236 </td><td>  35 </td></tr><tr><td>  fixedmath </td><td>  16.16 </td><td>  - </td><td>  4796 </td><td>  119 </td></tr><tr><td>  fixedmath </td><td>  16.16 </td><td>  FIXMATH_NO_OVERFLOW </td><td>  4664 </td><td>  89 </td></tr><tr><td>  fixedmath </td><td>  16.16 </td><td>  FIXMATH_OPTIMIZE_8BIT </td><td>  5036 </td><td>  92 </td></tr><tr><td>  fixedmath </td><td>  16.16 </td><td>  _NO_OVERFLOW + _8BIT </td><td>  4916 </td><td>  89 </td></tr><tr><td>  fixedptc </td><td>  24,8 </td><td>  FIXEDPT_BITS 32 </td><td>  4420 </td><td>  64 </td></tr><tr><td>  fixedptc </td><td>  9.7 </td><td>  FIXEDPT_BITS 16 </td><td>  3490 </td><td>  31 </td></tr></tbody></table>  * La v√©rification a √©t√© effectu√©e sur le patron: "195,175,145,110,170,70,170" et la cl√© "-Os". <br><br>  Le tableau montre que les deux biblioth√®ques ont utilis√© plus de ROM et se sont r√©v√©l√©es pires que le code compil√© de GCC lors de l'utilisation de float. <br>  On voit √©galement qu'une petite r√©vision du format Q9.7 et une diminution de la variable √† 16 bits ont donn√© une acc√©l√©ration de 4 ms.  et lib√©rer la ROM √† ~ 50 octets. <br><br>  L'effet attendu √©tait une diminution de la pr√©cision et une augmentation du nombre d'erreurs: <br><img src="https://habrastorage.org/webt/sz/v0/yt/szv0ytpsb0ogl5hkp39blbggvzw.png"><br>  qui dans ce cas n'est pas critique. <br><br><h3>  Allouer des ressources </h3><hr>  Les mardis et jeudis ne fonctionnent qu'une heure. <br><br>  Dans la plupart des cas, tous les calculs sont effectu√©s √† chaque image, ce qui n'est pas toujours justifi√©, car il peut ne pas y avoir assez de temps dans l'image pour calculer quelque chose et vous devrez tromper en alternant, en comptant les images ou en les sautant.  Je suis donc all√© plus loin - j'ai compl√®tement abandonn√© le personnel. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir tout divis√© en petites t√¢ches, que ce soit: calculer les collisions, traiter le son, les boutons et afficher les graphiques, il suffit de les ex√©cuter √† un certain intervalle, et l'inertie de l'≈ìil et la possibilit√© de mettre √† jour seulement une partie de l'√©cran feront l'affaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous g√©rons tout cela non pas une fois avec le syst√®me d'exploitation, mais avec la machine d'√©tat que j'ai cr√©√©e il y a quelques ann√©es, ou, plus simplement, pas le gestionnaire de t√¢ches tinySM. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je r√©p√®te les raisons de l'utiliser √† la place de n'importe quel RTOS:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exigences ROM plus faibles (~ 250 octets de base); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exigences de RAM plus faibles (~ 9 octets par t√¢che); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> principe de travail simple et compr√©hensible; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©terminisme du comportement; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> moins de temps processeur perdu; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> laisse l'acc√®s au fer; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ind√©pendant de la plateforme; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √©crit en C et facile √† encapsuler en C ++; </font></font></li><li> <s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avait besoin de mon propre v√©lo.</font></font></s> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme je l'ai d√©j√† d√©crit, les t√¢ches sont organis√©es en un tableau de pointeurs vers des structures, o√π un pointeur vers une fonction et son intervalle d'appel sont stock√©s. </font><font style="vertical-align: inherit;">Ce regroupement simplifie la description du jeu en plusieurs √©tapes, ce qui vous permet √©galement de r√©duire le nombre de branches et de basculer dynamiquement l'ensemble des t√¢ches. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, pendant l'√©cran de d√©marrage, 7 t√¢ches sont effectu√©es et pendant le jeu, il y a d√©j√† 20 t√¢ches (toutes les t√¢ches sont d√©crites dans le fichier gameTasks.c). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devez d'abord d√©finir certaines macros pour votre commodit√©:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> T(a) a##Task #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_N(a) const taskParams_t T(a) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK(a,b) TASK_N(a) PROGMEM = {.pFunc=a, .timeOut=b} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_P(a) (taskParams_t*)&amp;T(a) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_ARR_N(a) const tasksArr_t a##TasksArr[] #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_ARR(a) TASK_ARR_N(a) PROGMEM #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_END NULL</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La d√©claration de t√¢che cr√©e en fait une structure, initialise ses champs et la place dans la ROM: </font></font><br><pre> <code class="cpp hljs">TASK(updateBtnStates, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chacune de ces structures occupe 4 octets de ROM (deux par pointeur et deux par intervalle). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un bon avantage des macros est que cela ne fonctionne pas pour cr√©er plus d'une structure unique pour chaque fonction. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir d√©clar√© les t√¢ches n√©cessaires, nous les ajoutons au tableau et les mettons √©galement en ROM:</font></font><br><pre> <code class="cpp hljs">TASK_ARR( game ) = { TASK_P(updateBtnStates), TASK_P(playMusic), TASK_P(drawStars), TASK_P(moveShip), TASK_P(drawShip), TASK_P(checkFireButton), TASK_P(pauseMenu), TASK_P(drawPlayerWeapon), TASK_P(checkShipHealth), TASK_P(drawSomeGUI), TASK_P(checkInVaders), TASK_P(drawInVaders), TASK_P(moveInVaders), TASK_P(checkInVadersRespawn), TASK_P(checkInVadersRay), TASK_P(checkInVadersCollision), TASK_P(dropWeaponGift), TASK_END };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsque vous d√©finissez l'indicateur USE_DYNAMIC_MEM sur 0 pour la m√©moire statique, la principale chose √† retenir est d'initialiser les pointeurs vers le magasin de t√¢ches en RAM et de d√©finir le nombre maximal d'entre eux qui seront ex√©cut√©s: </font></font><br><pre> <code class="cpp hljs">... tasksContainer_t tasksContainer; taskFunc_t tasksArr[MAX_GAME_TASKS]; ... initTasksArr(&amp;tasksContainer, &amp;tasksArr[<span class="hljs-number"><span class="hljs-number">0</span></span>], MAX_GAME_TASKS); ‚Ä¶</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©finition des t√¢ches √† ex√©cuter: </font></font><br><pre> <code class="cpp hljs">... addTasksArray_P(gameTasksArr); ‚Ä¶</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La protection contre les d√©bordements est contr√¥l√©e par l'indicateur USE_MEM_PANIC, si vous √™tes s√ªr du nombre de t√¢ches, vous pouvez le d√©sactiver pour enregistrer la ROM. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il ne reste plus qu'√† ex√©cuter le gestionnaire:</font></font><br><pre> <code class="cpp hljs">... runTasks(); ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä l'int√©rieur se trouve une boucle infinie qui contient la logique de base. </font><font style="vertical-align: inherit;">Une fois √† l'int√©rieur, la pile est √©galement restaur√©e gr√¢ce √† "__attribute__ ((noreturn))". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la boucle, les √©l√©ments du tableau sont analys√©s en alternance pour la n√©cessit√© d'appeler la t√¢che apr√®s l'expiration de l'intervalle. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le comptage des intervalles a √©t√© effectu√© sur la base de timer0 en tant que syst√®me avec un quantum de 1 ms ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malgr√© la r√©partition r√©ussie des t√¢ches dans le temps, elles se chevauchaient parfois (gigue), ce qui provoquait une d√©coloration √† court terme de tout et de tout dans le jeu. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il fallait d√©finitivement d√©cider, mais comment? </font><font style="vertical-align: inherit;">√Ä propos de la fa√ßon dont tout a √©t√© profil√© la prochaine fois, mais pour l'instant, essayez de trouver l'≈ìuf de P√¢ques dans la source.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La fin </font></font></h3><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donc, en utilisant beaucoup d'astuces (et beaucoup d'autres dont je n'ai pas d√©crit), tout s'est av√©r√© tenir dans une ROM de 24 Ko et 1500 octets de RAM. </font><font style="vertical-align: inherit;">Si vous avez des questions, je me ferai un plaisir d'y r√©pondre.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ceux qui n'ont pas trouv√© ou n'ont pas cherch√© d'oeuf de P√¢ques:</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> creuser sur le c√¥t√©: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invadersMagicRespawn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!alien.alive) { alien.respawnTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rien de remarquable, non? </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raaaaazvorachivaem macro envahisseursMagicRespawn:</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tftSetTextSize(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { tftSetCP437(RN &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>); tftSetTextColorBG((((RN % <span class="hljs-number"><span class="hljs-number">192</span></span> + <span class="hljs-number"><span class="hljs-number">64</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFC</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>), COLOR_BLACK); tftDrawCharInt(((RN % <span class="hljs-number"><span class="hljs-number">26</span></span>) * <span class="hljs-number"><span class="hljs-number">6</span></span>), ((RN &amp; <span class="hljs-number"><span class="hljs-number">15</span></span>) * <span class="hljs-number"><span class="hljs-number">8</span></span>), (RN % <span class="hljs-number"><span class="hljs-number">255</span></span>)); tftPrintAt_P(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">58</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)creditP0); } } a(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!alien.alive) { alien.respawnTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre><br>   ¬´(void)¬ª    ,  ¬´action()¬ª          10 ,    ¬´disablePause();¬ª.               ¬´Matrix Falling code¬ª    .       130  ROM. <br></div></div><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour construire et ex√©cuter il suffit de mettre le dossier (ou lien) "esploraAPI" dans "/ arduino / biblioth√®ques /". </font></font><br><br>  R√©f√©rences: <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un jeu;</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esploraAPI;</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emballeur pickoPacker;</font></font></a> </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PS Vous pouvez voir et entendre √† quoi cela ressemble un peu plus tard lorsque je fais une vid√©o acceptable. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425407/">https://habr.com/ru/post/fr425407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425395/index.html">10 faits physiques que vous auriez d√ª conna√Ætre √† l'√©cole mais que vous ne saviez peut-√™tre pas</a></li>
<li><a href="../fr425397/index.html">10 biblioth√®ques que tous les d√©veloppeurs Android devraient conna√Ætre</a></li>
<li><a href="../fr425401/index.html">Rapport du Club de Rome 2018, chapitre 1.11: technologies perturbatrices et r√©volution num√©rique</a></li>
<li><a href="../fr425403/index.html">Le cr√©ateur de Craigslist finance: un site contre les fausses nouvelles, la discrimination et les exc√®s des g√©ants de l'Internet</a></li>
<li><a href="../fr425405/index.html">Nouveaux types de puissance</a></li>
<li><a href="../fr425409/index.html">DevBoy: faire un g√©n√©rateur de signaux</a></li>
<li><a href="../fr425411/index.html">Scrum est mort</a></li>
<li><a href="../fr425413/index.html">Les joons sont-ils si bons?</a></li>
<li><a href="../fr425415/index.html">Perl 5: comment les macros masquaient les erreurs</a></li>
<li><a href="../fr425417/index.html">Flash pour tout le monde. Tous les tableaux Flash de QSAN</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>