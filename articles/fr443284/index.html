<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôëÔ∏è üë∂üèº ‚úùÔ∏è Index dans PostgreSQL - 4 (Btree) üí´ ‚úäüèø üßòüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons d√©j√† discut√© du moteur d'indexation PostgreSQL et de l' interface des m√©thodes d'acc√®s , ainsi que de l'index de hachage , l'une des m√©thod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Index dans PostgreSQL - 4 (Btree)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/443284/">  Nous avons d√©j√† discut√© du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moteur d'indexation</a> PostgreSQL et de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interface des m√©thodes d'acc√®s</a> , ainsi que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de l'index de hachage</a> , l'une des m√©thodes d'acc√®s.  Nous allons maintenant consid√©rer B-tree, l'indice le plus traditionnel et le plus utilis√©.  Cet article est volumineux, alors soyez patient. <br><br><h1>  Btree </h1><br><h2>  La structure </h2><br>  Le type d'index B-tree, impl√©ment√© comme m√©thode d'acc√®s "btree", convient aux donn√©es qui peuvent √™tre tri√©es.  En d'autres termes, les op√©rateurs "sup√©rieur", "sup√©rieur ou √©gal", "inf√©rieur", "inf√©rieur ou √©gal" et "√©gal" doivent √™tre d√©finis pour le type de donn√©es.  Notez que les m√™mes donn√©es peuvent parfois √™tre tri√©es diff√©remment, ce qui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nous ram√®ne</a> au concept de famille d'op√©rateurs. <br><a name="habracut"></a><br>  Comme toujours, les lignes d'index de l'arborescence B sont regroup√©es dans des pages.  Dans les pages feuilles, ces lignes contiennent des donn√©es √† indexer (cl√©s) et des r√©f√©rences aux lignes de table (TID).  Dans les pages internes, chaque ligne fait r√©f√©rence √† une page enfant de l'index et contient la valeur minimale dans cette page. <br><br>  Les arbres B ont quelques traits importants: <br><br><ul><li>  Les arbres B sont √©quilibr√©s, c'est-√†-dire que chaque page feuille est s√©par√©e de la racine par le m√™me nombre de pages internes.  Par cons√©quent, la recherche d'une valeur prend le m√™me temps. <br></li><li>  Les arbres B sont √† plusieurs branches, c'est-√†-dire que chaque page (g√©n√©ralement 8 Ko) contient un grand nombre de (centaines) TID.  En cons√©quence, la profondeur des arbres B est assez petite, en fait jusqu'√† 4 √† 5 pour les tr√®s grandes tables. <br></li><li>  Les donn√©es de l'index sont tri√©es dans un ordre non d√©croissant (√† la fois entre les pages et √† l'int√©rieur de chaque page), et les pages de m√™me niveau sont connect√©es les unes aux autres par une liste bidirectionnelle.  Par cons√©quent, nous pouvons obtenir un ensemble de donn√©es ordonn√© simplement en parcourant une liste dans l'une ou l'autre direction sans retourner √† la racine √† chaque fois. <br></li></ul><br>  Voici un exemple simplifi√© de l'index sur un champ avec des cl√©s enti√®res. <br><br><img src="https://habrastorage.org/web/2e4/4f4/003/2e44f400317048c78e4cec04ab45e48e.png"><br><br>  La toute premi√®re page de l'index est une m√©tapage, qui fait r√©f√©rence √† la racine de l'index.  Les n≈ìuds internes sont situ√©s sous la racine et les pages feuilles se trouvent dans la ligne la plus basse.  Les fl√®ches vers le bas repr√©sentent les r√©f√©rences des n≈ìuds feuilles aux lignes de table (TID). <br><br><h3>  Recherche par √©galit√© </h3><br>  Consid√©rons la recherche d'une valeur dans un arbre par la condition " <em>indexed-field</em> = <em>expression</em> ".  Disons, nous sommes int√©ress√©s par la cl√© de 49. <br><br><img src="https://habrastorage.org/web/9fd/814/c9e/9fd814c9e79443b2a774403a817bf734.png"><br><br>  La recherche commence par le n≈ìud racine et nous devons d√©terminer vers lequel des n≈ìuds enfants descendre.  En connaissant les cl√©s du n≈ìud racine (4, 32, 64), nous d√©terminons donc les plages de valeurs dans les n≈ìuds enfants.  Puisque 32 ‚â§ 49 &lt;64, nous devons descendre jusqu'au deuxi√®me n≈ìud enfant.  Ensuite, le m√™me processus est r√©p√©t√© r√©cursivement jusqu'√† ce que nous atteignions un n≈ìud feuille √† partir duquel les TID n√©cessaires peuvent √™tre obtenus. <br><br>  En r√©alit√©, un certain nombre de d√©tails compliquent ce processus apparemment simple.  Par exemple, un index peut contenir des cl√©s non uniques et il peut y avoir tellement de valeurs √©gales qu'elles ne tiennent pas sur une seule page.  Pour revenir √† notre exemple, il semble que nous devrions descendre du n≈ìud interne sur la r√©f√©rence √† la valeur de 49. Mais, comme le montre clairement la figure, de cette fa√ßon, nous allons ignorer l'une des touches "49" dans la page feuille pr√©c√©dente .  Par cons√©quent, une fois que nous avons trouv√© une cl√© exactement √©gale dans une page interne, nous devons descendre d'une position √† gauche, puis parcourir les lignes d'index du niveau sous-jacent de gauche √† droite √† la recherche de la cl√© recherch√©e. <br><br>  (Une autre complication est que pendant la recherche, d'autres processus peuvent modifier les donn√©es: l'arborescence peut √™tre reconstruite, les pages peuvent √™tre divis√©es en deux, etc. Tous les algorithmes sont con√ßus pour ces op√©rations simultan√©es pour ne pas interf√©rer les uns avec les autres et ne pas provoquer de verrous suppl√©mentaires dans la mesure du possible, mais nous √©viterons de d√©velopper ce point.) <br><br><h3>  Recherche par in√©galit√© </h3><br>  Lors de la recherche par la condition " <em>champ index√©</em> ‚â§ <em>expression</em> " (ou " <em>champ index√©</em> ‚â• <em>expression</em> "), nous trouvons d'abord une valeur (le cas √©ch√©ant) dans l'index par la condition d'√©galit√© " <em>champ index√©</em> = <em>expression</em> ", puis nous parcourons Feuilleter les pages dans le bon sens jusqu'√† la fin. <br><br>  La figure illustre ce processus pour n ‚â§ 35: <br><br><img src="https://habrastorage.org/web/35e/62a/f80/35e62af80ca44349b7728ad806226208.png"><br><br>  Les op√©rateurs ¬´sup√©rieur¬ª et ¬´moins¬ª sont pris en charge de la m√™me mani√®re, sauf que la valeur initialement trouv√©e doit √™tre supprim√©e. <br><br><h3>  Recherche par gamme </h3><br>  Lors de la recherche par plage " <em>expression1</em> ‚â§ <em>champ index√©</em> ‚â§ <em>expression2</em> ", nous trouvons une valeur par condition " <em>champ index√©</em> = <em>expression1</em> ", puis continuons √† parcourir les pages de feuille pendant que la condition " <em>champ index√©</em> ‚â§ <em>expression2</em> " est remplie;  ou vice versa: commencez par la deuxi√®me expression et marchez dans une direction oppos√©e jusqu'√† atteindre la premi√®re expression. <br><br>  La figure montre ce processus pour la condition 23 ‚â§ n ‚â§ 64: <br><br><img src="https://habrastorage.org/web/2d6/b24/d86/2d6b24d86fb24c9ab437cc8155658e58.png"><br><br><h2>  Exemple </h2><br>  Voyons un exemple de ce √† quoi ressemblent les plans de requ√™te.  Comme d'habitude, nous utilisons la base de donn√©es de d√©monstration, et cette fois, nous allons consid√©rer la table des avions.  Il ne contient que neuf lignes et le planificateur choisit de ne pas utiliser l'index, car la table enti√®re tient sur une seule page.  Mais ce tableau nous int√©resse √† des fins d'illustration. <br><br><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts;</code> </pre> <pre> <code class="plaintext hljs"> aircraft_code | model | range ---------------+---------------------+------- 773 | Boeing 777-300 | 11100 763 | Boeing 767-300 | 7900 SU9 | Sukhoi SuperJet-100 | 3000 320 | Airbus A320-200 | 5700 321 | Airbus A321-200 | 5600 319 | Airbus A319-100 | 6700 733 | Boeing 737-300 | 4200 CN1 | Cessna 208 Caravan | 1200 CR2 | Bombardier CRJ-200 | 2700 (9 rows)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts(range); demo=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>;</code> </pre><br>  (Ou explicitement, "cr√©ez un index sur les avions en utilisant btree (range)", mais c'est un arbre B qui est construit par d√©faut.) <br><br>  Recherche par √©galit√©: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> range = <span class="hljs-number"><span class="hljs-number">3000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------- Index Scan using aircrafts_range_idx on aircrafts Index Cond: (range = 3000) (2 rows)</code> </pre><br>  Recherche par in√©galit√©: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">3000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------- Index Scan using aircrafts_range_idx on aircrafts Index Cond: (range &lt; 3000) (2 rows)</code> </pre><br>  Et par gamme: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">5000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------- Index Scan using aircrafts_range_idx on aircrafts Index Cond: ((range &gt;= 3000) AND (range &lt;= 5000)) (2 rows)</code> </pre><br><h2>  Tri </h2><br>  Soulignons une fois de plus le fait qu'avec tout type d'analyse (index, index uniquement ou bitmap), la m√©thode d'acc√®s "btree" renvoie les donn√©es ordonn√©es, que nous pouvons clairement voir dans les figures ci-dessus. <br><br>  Par cons√©quent, si une table a un index sur la condition de tri, l'optimiseur consid√©rera les deux options: l'analyse d'index de la table, qui retourne facilement les donn√©es tri√©es, et l'analyse s√©quentielle de la table avec tri ult√©rieur du r√©sultat. <br><br><h3>  Ordre de tri </h3><br>  Lors de la cr√©ation d'un index, nous pouvons sp√©cifier explicitement l'ordre de tri.  Par exemple, nous pouvons cr√©er un index par plages de vol de cette fa√ßon notamment: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts(range <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>);</code> </pre><br>  Dans ce cas, des valeurs plus grandes apparaissent dans l'arborescence √† gauche, tandis que des valeurs plus petites apparaissent √† droite.  Pourquoi cela peut-il √™tre n√©cessaire si nous pouvons parcourir les valeurs index√©es dans les deux sens? <br><br>  Le but est des index multi-colonnes.  Cr√©ons une vue pour montrer les mod√®les d'avion avec une division conventionnelle en vaisseaux √† courte, moyenne et longue port√©e: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> model, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts; demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v;</code> </pre><pre> <code class="plaintext hljs"> model | class ---------------------+------- Boeing 777-300 | 3 Boeing 767-300 | 2 Sukhoi SuperJet-100 | 1 Airbus A320-200 | 2 Airbus A321-200 | 2 Airbus A319-100 | 2 Boeing 737-300 | 2 Cessna 208 Caravan | 1 Bombardier CRJ-200 | 1 (9 rows)</code> </pre><br>  Et cr√©ons un index (en utilisant l'expression): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts( (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>), model);</code> </pre><br>  Maintenant, nous pouvons utiliser cet index pour obtenir des donn√©es tri√©es par les deux colonnes dans l'ordre croissant: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model;</code> </pre><pre> <code class="plaintext hljs"> class | model -------+--------------------- 1 | Bombardier CRJ-200 1 | Cessna 208 Caravan 1 | Sukhoi SuperJet-100 2 | Airbus A319-100 2 | Airbus A320-200 2 | Airbus A321-200 2 | Boeing 737-300 2 | Boeing 767-300 3 | Boeing 777-300 (9 rows)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------- Index Scan using aircrafts_case_model_idx on aircrafts (1 row)</code> </pre><br>  De m√™me, nous pouvons effectuer la requ√™te pour trier les donn√©es dans l'ordre d√©croissant: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> class | model -------+--------------------- 3 | Boeing 777-300 2 | Boeing 767-300 2 | Boeing 737-300 2 | Airbus A321-200 2 | Airbus A320-200 2 | Airbus A319-100 1 | Sukhoi SuperJet-100 1 | Cessna 208 Caravan 1 | Bombardier CRJ-200 (9 rows)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------- Index Scan BACKWARD using aircrafts_case_model_idx on aircrafts (1 row)</code> </pre><br>  Cependant, nous ne pouvons pas utiliser cet index pour obtenir des donn√©es tri√©es par une colonne en ordre d√©croissant et par l'autre colonne en ordre croissant.  Cela n√©cessitera un tri s√©par√©: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------- Sort Sort Key: (CASE ... END), aircrafts.model DESC -&gt; Seq Scan on aircrafts (3 rows)</code> </pre><br>  (Notez qu'en dernier recours, le planificateur a choisi le balayage s√©quentiel ind√©pendamment du param√®tre "enable_seqscan = off" effectu√© pr√©c√©demment. En effet, ce param√®tre n'interdit pas le balayage de la table, mais d√©finit uniquement son co√ªt astronomique - veuillez consulter le plan avec "Co√ªts sur".) <br><br>  Pour que cette requ√™te utilise l'index, ce dernier doit √™tre construit avec le sens de tri requis: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> aircrafts_case_asc_model_desc_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts( (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------- Index Scan using aircrafts_case_asc_model_desc_idx on aircrafts (1 row)</code> </pre><br><h3>  Ordre des colonnes </h3><br>  Un autre probl√®me qui se pose lors de l'utilisation d'index multi-colonnes est l'ordre de listage des colonnes dans un index.  Pour B-tree, cet ordre est d'une importance capitale: les donn√©es √† l'int√©rieur des pages seront tri√©es par le premier champ, puis par le second, et ainsi de suite. <br><br>  Nous pouvons repr√©senter l'indice que nous avons construit sur des intervalles de plage et des mod√®les de mani√®re symbolique comme suit: <br><br><img src="https://habrastorage.org/web/90c/71b/c8b/90c71bc8b51441b7b3c0df21b6a8888b.png"><br><br>  En fait, un si petit index conviendra √† coup s√ªr √† une page racine.  Dans la figure, il est d√©lib√©r√©ment distribu√© sur plusieurs pages pour plus de clart√©. <br><br>  Il ressort clairement de ce tableau que la recherche par des pr√©dicats tels que "classe = 3" (recherche uniquement par le premier champ) ou "classe = 3 et mod√®le = 'Boeing 777-300'" "(recherche par les deux champs) fonctionnera efficacement. <br><br>  Cependant, la recherche par le pr√©dicat ¬´model = 'Boeing 777-300'¬ª sera beaucoup moins efficace: √† partir de la racine, nous ne pouvons pas d√©terminer vers quel n≈ìud enfant descendre, par cons√©quent, nous devrons descendre vers chacun d'eux.  Cela ne signifie pas qu'un indice comme celui-ci ne peut jamais √™tre utilis√© - son efficacit√© est en cause.  Par exemple, si nous avions trois classes d'avions et un grand nombre de mod√®les dans chaque classe, nous aurions √† parcourir environ un tiers de l'indice et cela aurait pu √™tre plus efficace que le balayage complet de la table ... ou pas. <br><br>  Cependant, si nous cr√©ons un index comme celui-ci: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts( model, (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>));</code> </pre><br>  l'ordre des champs va changer: <br><br><img src="https://habrastorage.org/web/458/c5f/d22/458c5fd22e26467d9f0c56e308d8db5f.png"><br><br>  Avec cet index, la recherche par le pr√©dicat "model = 'Boeing 777-300'" fonctionnera efficacement, mais la recherche par le pr√©dicat "class = 3" ne fonctionnera pas. <br><br><h3>  Nulls </h3><br>  La m√©thode d'acc√®s "Btree" indexe les valeurs NULL et prend en charge la recherche par conditions IS NULL et IS NOT NULL. <br><br>  Prenons le tableau des vols, o√π les NULL se produisent: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights(actual_arrival); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------- Bitmap Heap Scan on flights Recheck Cond: (actual_arrival IS NULL) -&gt; Bitmap Index Scan on flights_actual_arrival_idx Index Cond: (actual_arrival IS NULL) (4 rows)</code> </pre><br>  Les valeurs NULL sont situ√©es √† l'une ou √† l'autre extr√©mit√© des n≈ìuds terminaux selon la fa√ßon dont l'index a √©t√© cr√©√© (NULLS FIRST ou NULLS LAST).  Ceci est important si une requ√™te inclut le tri: l'index peut √™tre utilis√© si la commande SELECT sp√©cifie le m√™me ordre de NULL dans sa clause ORDER BY que l'ordre sp√©cifi√© pour l'index construit (NULLS FIRST ou NULLS LAST). <br><br>  Dans l'exemple suivant, ces ordres sont les m√™mes, par cons√©quent, nous pouvons utiliser l'index: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS LAST</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------- Index Scan using flights_actual_arrival_idx on flights (1 row)</code> </pre><br>  Et ici, ces ordres sont diff√©rents, et l'optimiseur choisit un balayage s√©quentiel avec un tri ult√©rieur: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS FIRST</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------- Sort Sort Key: actual_arrival NULLS FIRST -&gt; Seq Scan on flights (3 rows)</code> </pre><br>  Pour utiliser l'index, il doit √™tre cr√©√© avec des valeurs NULL situ√©es au d√©but: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_nulls_first_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights(actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS FIRST</span></span>); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS FIRST</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------- Index Scan using flights_nulls_first_idx on flights (1 row)</code> </pre><br>  Des probl√®mes comme celui-ci sont certainement dus au fait que les valeurs NULL ne sont pas triables, c'est-√†-dire que le r√©sultat de la comparaison pour NULL et toute autre valeur n'est pas d√©fini: <br><br><pre> <code class="pgsql hljs">demo=# \pset <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &lt; <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- NULL (1 row)</code> </pre><br>  Cela va √† l'encontre du concept d'arbre B et ne correspond pas au sch√©ma g√©n√©ral.  Les NULL, cependant, jouent un r√¥le si important dans les bases de donn√©es que nous devons toujours leur faire des exceptions. <br><br>  √âtant donn√© que les valeurs NULL peuvent √™tre index√©es, il est possible d'utiliser un index m√™me sans aucune condition impos√©e √† la table (car l'index contient des informations sur toutes les lignes de la table √† coup s√ªr).  Cela peut avoir du sens si la requ√™te n√©cessite un classement des donn√©es et que l'index garantit l'ordre requis.  Dans ce cas, le planificateur peut plut√¥t choisir l'acc√®s √† l'index pour √©conomiser sur un tri s√©par√©. <br><br><h2>  Propri√©t√©s </h2><br>  Examinons les propri√©t√©s de la m√©thode d'acc√®s "btree" (des requ√™tes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ont d√©j√† √©t√© fournies</a> ). <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- btree | can_order | t btree | can_unique | t btree | can_multi_col | t btree | can_exclude | t</code> </pre><br>  Comme nous l'avons vu, B-tree peut ordonner les donn√©es et prend en charge l'unicit√© - et c'est la seule m√©thode d'acc√®s √† nous fournir des propri√©t√©s comme celles-ci.  Les index multicolonnes sont √©galement autoris√©s, mais d'autres m√©thodes d'acc√®s (mais pas toutes) peuvent √©galement prendre en charge de tels index.  Nous discuterons de la prise en charge de la contrainte EXCLUDE la prochaine fois, et non sans raison. <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | t index_scan | t bitmap_scan | t backward_scan | t</code> </pre><br>  La m√©thode d'acc√®s "Btree" prend en charge les deux techniques pour obtenir des valeurs: l'analyse d'index, ainsi que l'analyse bitmap.  Et comme nous avons pu le voir, la m√©thode d'acc√®s peut parcourir l'arborescence √† la fois "en avant" et "en arri√®re". <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | t desc | f nulls_first | f nulls_last | t orderable | t distance_orderable | f returnable | t search_array | t search_nulls | t</code> </pre><br>  Les quatre premi√®res propri√©t√©s de cette couche expliquent comment les valeurs exactes d'une certaine colonne sp√©cifique sont ordonn√©es.  Dans cet exemple, les valeurs sont tri√©es dans l'ordre croissant ("asc") et les valeurs NULL sont fournies en dernier ("nulls_last").  Mais comme nous l'avons d√©j√† vu, d'autres combinaisons sont possibles. <br><br>  La propri√©t√© "Search_array" indique la prise en charge d'expressions comme celle-ci par l'index: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> aircraft_code <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'733'</span></span>,<span class="hljs-string"><span class="hljs-string">'763'</span></span>,<span class="hljs-string"><span class="hljs-string">'773'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------- Index Scan using aircrafts_pkey on aircrafts Index Cond: (aircraft_code = ANY ('{733,763,773}'::bpchar[])) (2 rows)</code> </pre><br>  La propri√©t√© "renvoyable" indique la prise en charge de l'analyse d'index uniquement, ce qui est raisonnable car les lignes de l'index stockent elles-m√™mes les valeurs index√©es (contrairement √† l'index de hachage, par exemple).  Ici, il est logique de dire quelques mots sur la couverture des index bas√©s sur l'arbre B. <br><br><h3>  Index uniques avec lignes suppl√©mentaires </h3><br>  Comme nous l'avons vu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©c√©demment</a> , un index de couverture est celui qui stocke toutes les valeurs n√©cessaires pour une requ√™te, l'acc√®s √† la table elle-m√™me n'√©tant pas (presque) requis.  Un index unique peut sp√©cifiquement couvrir. <br><br>  Mais supposons que nous voulons ajouter les colonnes suppl√©mentaires n√©cessaires pour une requ√™te √† l'index unique.  Cependant, l'unicit√© de ces valeurs composites ne garantit pas l'unicit√© de la cl√©, et deux index sur les m√™mes colonnes seront alors n√©cessaires: un unique pour prendre en charge la contrainte d'int√©grit√© et un autre pour √™tre utilis√© comme couverture.  C'est inefficace √† coup s√ªr. <br><br>  Dans notre entreprise, Anastasiya Lubennikova <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">lubennikovaav a</a> am√©lior√© la m√©thode "btree" afin que des colonnes suppl√©mentaires, non uniques, puissent √™tre incluses dans un index unique.  Nous esp√©rons que ce correctif sera adopt√© par la communaut√© pour faire partie de PostgreSQL, mais cela ne se produira pas d√®s la version 10. √Ä ce stade, le correctif est disponible dans Pro Standard 9.5+, et voici √† quoi il ressemble comme. <br><br><blockquote>  En fait, ce correctif a √©t√© valid√© pour PostgreSQL 11. <br></blockquote><br>  Prenons le tableau des r√©servations: <br><br><pre> <code class="pgsql hljs">demo=# \d bookings</code> </pre><pre> <code class="plaintext hljs"> Table "bookings.bookings" Column | Type | Modifiers --------------+--------------------------+----------- book_ref | character(6) | not null book_date | timestamp with time zone | not null total_amount | numeric(10,2) | not null Indexes: "bookings_pkey" PRIMARY KEY, btree (book_ref) Referenced by: TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)</code> </pre><br>  Dans ce tableau, la cl√© primaire (book_ref, code de r√©servation) est fournie par un index "btree" r√©gulier.  Cr√©ons un nouvel index unique avec une colonne suppl√©mentaire: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> bookings_pkey2 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> bookings(book_ref) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span> (book_date);</code> </pre><br>  Maintenant, nous rempla√ßons l'index existant par un nouveau (dans la transaction, pour appliquer toutes les modifications simultan√©ment): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>; demo=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> bookings_pkey <span class="hljs-keyword"><span class="hljs-keyword">cascade</span></span>; demo=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">primary key</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> bookings_pkey2; demo=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> tickets <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreign key</span></span> (book_ref) <span class="hljs-keyword"><span class="hljs-keyword">references</span></span> bookings (book_ref); demo=# <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>;</code> </pre><br>  Voici ce que nous obtenons: <br><br><pre> <code class="pgsql hljs">demo=# \d bookings</code> </pre><pre> <code class="plaintext hljs"> Table "bookings.bookings" Column | Type | Modifiers --------------+--------------------------+----------- book_ref | character(6) | not null book_date | timestamp with time zone | not null total_amount | numeric(10,2) | not null Indexes: "bookings_pkey2" PRIMARY KEY, btree (book_ref) INCLUDE (book_date) Referenced by: TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)</code> </pre><br>  D√©sormais, un seul et m√™me index fonctionne comme unique et sert d'index de couverture pour cette requ√™te, par exemple: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> book_ref, book_date <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> book_ref = <span class="hljs-string"><span class="hljs-string">'059FC4'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------- Index Only Scan using bookings_pkey2 on bookings Index Cond: (book_ref = '059FC4'::bpchar) (2 rows)</code> </pre><br><h2>  Cr√©ation de l'index </h2><br>  Il est bien connu, mais non moins important, que pour une table de grande taille, il est pr√©f√©rable d'y charger des donn√©es sans index et de cr√©er les index n√©cessaires ult√©rieurement.  Ce n'est pas seulement plus rapide, mais tr√®s probablement l'indice aura une taille plus petite. <br><br>  Le fait est que la cr√©ation de l'index "btree" utilise un processus plus efficace que l'insertion de valeurs par ligne dans l'arbre.  En gros, toutes les donn√©es disponibles dans le tableau sont tri√©es et des pages feuilles de ces donn√©es sont cr√©√©es.  Ensuite, les pages internes sont "construites" sur cette base jusqu'√† ce que toute la pyramide converge vers la racine. <br><br>  La vitesse de ce processus d√©pend de la taille de la RAM disponible, qui est limit√©e par le param√®tre "maintenance_work_mem".  Ainsi, l'augmentation de la valeur du param√®tre peut acc√©l√©rer le processus.  Pour les index uniques, une m√©moire de taille "work_mem" est allou√©e en plus de "maintenance_work_mem". <br><br><h3>  S√©mantique de comparaison </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La derni√®re fois,</a> nous avons mentionn√© que PostgreSQL a besoin de savoir quelles fonctions de hachage appeler des valeurs de diff√©rents types et que cette association est stock√©e dans la m√©thode d'acc√®s "hachage".  De m√™me, le syst√®me doit comprendre comment ordonner les valeurs.  Cela est n√©cessaire pour les tri, les regroupements (parfois), les jointures de fusion, etc.  PostgreSQL ne se lie pas aux noms d'op√©rateurs (tels que&gt;, &lt;, =) car les utilisateurs peuvent d√©finir leur propre type de donn√©es et donner aux op√©rateurs correspondants des noms diff√©rents.  Une famille d'op√©rateurs utilis√©e par la m√©thode d'acc√®s "btree" d√©finit √† la place des noms d'op√©rateurs. <br><br>  Par exemple, ces op√©rateurs de comparaison sont utilis√©s dans la famille d'op√©rateurs "bool_ops": <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> opfamily_operator, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'bool_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> amopstrategy;</code> </pre><pre> <code class="plaintext hljs"> opfamily_operator | amopstrategy ---------------------+-------------- &lt;(boolean,boolean) | 1 &lt;=(boolean,boolean) | 2 =(boolean,boolean) | 3 &gt;=(boolean,boolean) | 4 &gt;(boolean,boolean) | 5 (5 rows)</code> </pre><br>  Ici, nous pouvons voir cinq op√©rateurs de comparaison, mais comme d√©j√† mentionn√©, nous ne devons pas nous fier √† leurs noms.  Pour comprendre quelle comparaison chaque op√©rateur fait, le concept de strat√©gie est introduit.  Cinq strat√©gies sont d√©finies pour d√©crire la s√©mantique des op√©rateurs: <br><br><ul><li>  1 - moins </li><li>  2 - inf√©rieur ou √©gal </li><li>  3 - √©gal </li><li>  4 - sup√©rieur ou √©gal </li><li>  5 - plus </li></ul><br>  Certaines familles d'op√©rateurs peuvent contenir plusieurs op√©rateurs mettant en ≈ìuvre une strat√©gie.  Par exemple, la famille d'op√©rateurs "integer_ops" contient les op√©rateurs suivants pour la strat√©gie 1: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> opfamily_operator <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'integer_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopstrategy = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opfamily_operator;</code> </pre><pre> <code class="plaintext hljs"> opfamily_operator ---------------------- &lt;(integer,bigint) &lt;(smallint,smallint) &lt;(integer,integer) &lt;(bigint,bigint) &lt;(bigint,integer) &lt;(smallint,integer) &lt;(integer,smallint) &lt;(smallint,bigint) &lt;(bigint,smallint) (9 rows)</code> </pre><br>  Gr√¢ce √† cela, l'optimiseur peut √©viter les conversions de types lors de la comparaison des valeurs de diff√©rents types contenus dans une famille d'op√©rateurs. <br><br><h3>  Prise en charge de l'index pour un nouveau type de donn√©es </h3><br>  La documentation fournit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple</a> de cr√©ation d'un nouveau type de donn√©es pour les nombres complexes et d'une classe d'op√©rateur pour trier les valeurs de ce type.  Cet exemple utilise le langage C, ce qui est absolument raisonnable lorsque la vitesse est critique.  Mais rien ne nous emp√™che d'utiliser du SQL pur pour la m√™me exp√©rience afin d'essayer de mieux comprendre la s√©mantique de comparaison. <br><br>  Cr√©ons un nouveau type composite avec deux champs: les parties r√©elles et imaginaires. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> complex <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (re <span class="hljs-type"><span class="hljs-type">float</span></span>, im <span class="hljs-type"><span class="hljs-type">float</span></span>);</code> </pre><br>  Nous pouvons cr√©er une table avec un champ du nouveau type et ajouter quelques valeurs √† la table: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> numbers(x complex); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> ((<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">10.0</span></span>)), ((<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>)), ((<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>));</code> </pre><br>  Maintenant une question se pose: comment ordonner des nombres complexes si aucune relation d'ordre n'est d√©finie pour eux au sens math√©matique? <br><br>  Il s'av√®re que les op√©rateurs de comparaison sont d√©j√† d√©finis pour nous: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> x;</code> </pre><pre> <code class="plaintext hljs"> x -------- (0,10) (1,1) (1,3) (3 rows)</code> </pre><br>  Par d√©faut, le tri s'effectue par composant pour un type composite: les premiers champs sont compar√©s, puis les deuxi√®mes, etc., √† peu pr√®s de la m√™me mani√®re que les cha√Ænes de texte sont compar√©es caract√®re par caract√®re.  Mais nous pouvons d√©finir un ordre diff√©rent.  Par exemple, les nombres complexes peuvent √™tre trait√©s comme des vecteurs et ordonn√©s par le module (longueur), qui est calcul√© comme la racine carr√©e de la somme des carr√©s des coordonn√©es (le th√©or√®me de Pythagore).  Pour d√©finir un tel ordre, cr√©ons une fonction auxiliaire qui calcule le module: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> modulus(a complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> sqrt(a.re*a.re + a.im*a.im); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Nous allons maintenant d√©finir syst√©matiquement des fonctions pour les cinq op√©rateurs de comparaison en utilisant cette fonction auxiliaire: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_lt(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &lt; modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_le(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &lt;= modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_eq(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) = modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_ge(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &gt;= modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_gt(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &gt; modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Et nous allons cr√©er des op√©rateurs correspondants.  Pour illustrer qu'ils n'ont pas besoin d'√™tre appel√©s "&gt;", "&lt;", etc., donnons-leur des noms "bizarres". <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&lt;#(leftarg=complex, rightarg=complex, procedure=complex_lt); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&lt;=#(leftarg=complex, rightarg=complex, procedure=complex_le); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #=#(leftarg=complex, rightarg=complex, procedure=complex_eq); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&gt;=#(leftarg=complex, rightarg=complex, procedure=complex_ge); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&gt;#(leftarg=complex, rightarg=complex, procedure=complex_gt);</code> </pre><br>  √Ä ce stade, nous pouvons comparer les chiffres: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>)::complex #&lt;# (<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">3.0</span></span>)::complex;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br>  En plus de cinq op√©rateurs, la m√©thode d'acc√®s ¬´btree¬ª n√©cessite de d√©finir une fonction (excessive mais pratique): elle doit retourner -1, 0 ou 1 si la premi√®re valeur est inf√©rieure, √©gale ou sup√©rieure √† la seconde un.  Cette fonction auxiliaire est appel√©e support.  D'autres m√©thodes d'acc√®s peuvent n√©cessiter la d√©finition d'autres fonctions de support. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_cmp(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">case</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">when</span></span></span><span class="pgsql"> modulus(a) &lt; modulus(b) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">then</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">-1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">when</span></span></span><span class="pgsql"> modulus(a) &gt; modulus(b) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">then</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">else</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">end</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Nous sommes maintenant pr√™ts √† cr√©er une classe d'op√©rateurs (et la famille d'op√©rateurs du m√™me nom sera cr√©√©e automatiquement): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> complex_ops <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> complex <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> btree <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> #&lt;#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> #&lt;=#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> #=#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> #&gt;=#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> #&gt;#, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> complex_cmp(complex,complex);</code> </pre><br>  Maintenant, le tri fonctionne comme vous le souhaitez: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> x;</code> </pre><pre> <code class="plaintext hljs"> x -------- (1,1) (1,3) (0,10) (3 rows)</code> </pre><br>  Et il sera certainement soutenu par l'index "btree". <br><br>  Pour compl√©ter l'image, vous pouvez obtenir des fonctions de support en utilisant cette requ√™te: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amp.amprocnum, amp.amproc, amp.amproclefttype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, amp.amprocrighttype::<span class="hljs-type"><span class="hljs-type">regtype</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opfamily opf, pg_am am, pg_amproc amp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'complex_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amp.amprocfamily = opf.oid;</code> </pre><pre> <code class="plaintext hljs"> amprocnum | amproc | amproclefttype | amprocrighttype -----------+-------------+----------------+----------------- 1 | complex_cmp | complex | complex (1 row)</code> </pre><br><h2>  Internes </h2><br>  Nous pouvons explorer la structure interne de B-tree en utilisant l'extension "pageinspect". <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  M√©tapage d'index: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bt_metap(<span class="hljs-string"><span class="hljs-string">'ticket_flights_pkey'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> magic | version | root | level | fastroot | fastlevel --------+---------+------+-------+----------+----------- 340322 | 2 | 164 | 2 | 164 | 2 (1 row)</code> </pre><br>  Le plus int√©ressant ici est le niveau d'index: l'index sur deux colonnes pour une table avec un million de lignes requis aussi peu que 2 niveaux (hors racine). <br><br>  Informations statistiques sur le bloc 164 (racine): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, live_items, dead_items, avg_item_size, page_size, free_size <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bt_page_stats(<span class="hljs-string"><span class="hljs-string">'ticket_flights_pkey'</span></span>,<span class="hljs-number"><span class="hljs-number">164</span></span>);</code> </pre><pre> <code class="plaintext hljs"> type | live_items | dead_items | avg_item_size | page_size | free_size ------+------------+------------+---------------+-----------+----------- r | 33 | 0 | 31 | 8192 | 6984 (1 row)</code> </pre><br>  Et les donn√©es du bloc (le champ "data", qui est ici sacrifi√© √† la largeur de l'√©cran, contient la valeur de la cl√© d'indexation en repr√©sentation binaire): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> itemoffset, ctid, itemlen, left(data,<span class="hljs-number"><span class="hljs-number">56</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'ticket_flights_pkey'</span></span>,<span class="hljs-number"><span class="hljs-number">164</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid | itemlen | data ------------+---------+---------+---------------------------------------------------------- 1 | (3,1) | 8 | 2 | (163,1) | 32 | 1d 30 30 30 35 34 33 32 33 30 35 37 37 31 00 00 ff 5f 00 3 | (323,1) | 32 | 1d 30 30 30 35 34 33 32 34 32 33 36 36 32 00 00 4f 78 00 4 | (482,1) | 32 | 1d 30 30 30 35 34 33 32 35 33 30 38 39 33 00 00 4d 1e 00 5 | (641,1) | 32 | 1d 30 30 30 35 34 33 32 36 35 35 37 38 35 00 00 2b 09 00 (5 rows)</code> </pre><br>  Le premier √©l√©ment concerne les techniques et sp√©cifie la limite sup√©rieure de tous les √©l√©ments du bloc (un d√©tail d'impl√©mentation dont nous n'avons pas discut√©), tandis que les donn√©es elles-m√™mes commencent par le deuxi√®me √©l√©ment.  Il est clair que le n≈ìud enfant le plus √† gauche est le bloc 163, suivi du bloc 323, et ainsi de suite.  Ils peuvent √† leur tour √™tre explor√©s en utilisant les m√™mes fonctions. <br><br>  Maintenant, suivant une bonne tradition, il est logique de lire la documentation, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichier README</a> et le code source. <br><br>  Pourtant, une autre extension potentiellement utile est " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">amcheck</a> ", qui sera incorpor√©e dans PostgreSQL 10, et pour les versions inf√©rieures, vous pouvez l'obtenir depuis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> .  Cette extension v√©rifie la coh√©rence logique des donn√©es dans les arbres B et nous permet de d√©tecter √† l'avance les d√©fauts. <br><blockquote>  C'est vrai, "amcheck" fait partie de PostgreSQL √† partir de la version 10. <br></blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Continuez √† lire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443284/">https://habr.com/ru/post/fr443284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443274/index.html">Compilation de nouvelles sur l'industrie du jeu du 8 mars au dimanche</a></li>
<li><a href="../fr443276/index.html">Planificateur de requ√™tes surprise dans la base de donn√©es PostgreSQL</a></li>
<li><a href="../fr443278/index.html">Le crypto-√©change Coinbase perd des utilisateurs en raison de l'achat d'une startup pour les cr√©ateurs de logiciels espions de la Hacking Team</a></li>
<li><a href="../fr443280/index.html">L'histoire de la fa√ßon dont j'ai assembl√© un home cin√©ma de 120 pouces √† partir de tuyaux, de cordes, d'un √©cran pliant et de velours noir</a></li>
<li><a href="../fr443282/index.html">Que devons-nous construire une blockchain?</a></li>
<li><a href="../fr443286/index.html">TDMS Fairway. M√©canisme de remplissage automatique pour les principales inscriptions sur les dessins et les d√©tails des documents</a></li>
<li><a href="../fr443288/index.html">Navigation dans les projets multi-modules</a></li>
<li><a href="../fr443290/index.html">Zen Erlang [et Elixir - env. traducteur]</a></li>
<li><a href="../fr443292/index.html">Nous √©tudions le principe de fonctionnement des unit√©s em √† l'aide de l'exemple de la t√¢che ¬´Agencement d'un pr√©chargeur flexible¬ª</a></li>
<li><a href="../fr443294/index.html">Qu'est-ce qui est autoris√© par Jupyter?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>