<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👧 🎳 👩🏼‍🔬 Internals Go: agrupar variáveis ​​de loop no fechamento 🕵️ 🙋🏼 👃🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje decidi traduzir para você um pequeno artigo sobre o interior da implementação dos chamados fechamentos ou fechamentos. Além disso, você aprenderá...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Internals Go: agrupar variáveis ​​de loop no fechamento</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/468863/"><p><img src="https://habrastorage.org/webt/a2/v0/es/a2v0es8qfgkdntuzeattfznxanq.jpeg"></p><br><p>  <em>Hoje decidi traduzir para você um pequeno artigo sobre o interior da implementação dos chamados fechamentos ou fechamentos.</em>  <em>Além disso, você aprenderá como o Go tenta determinar automaticamente se deve usar um ponteiro / link ou valor em diferentes casos.</em>  <em>Compreender essas coisas evitará erros.</em>  <em>E é só que todo esse interior é bem interessante, eu acho!</em> </p><br><p>  <em>E também gostaria de convidá-lo para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Golang Conf 2019</a> , que será realizado em 7 de outubro em Moscou.</em>  <em>Sou membro do comitê do programa da conferência, e meus colegas e eu escolhemos muitos relatórios igualmente graves e muito, muito interessantes.</em>  <em>O que eu amo!</em> </p><br><p>  <em>Abaixo do recado, passo a palavra ao autor.</em> </p><a name="habracut"></a><br><br><p>  Há uma página no wiki da Go intitulada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Erros Frequentes</a> .  Curiosamente, existe apenas um exemplo: uso indevido de variáveis ​​de loop com goroutines: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, val := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> values { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(val) }() }</code> </pre> <br><p>  Este código produzirá o último valor da matriz de valores len (valores) vezes.  A correção do código é muito simples: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// assume the type of each value is string for _, val := range values { go func(val string) { fmt.Println(val) }(val) }</span></span></code> </pre> <br><p>  Este exemplo é suficiente para entender o problema e nunca mais cometer um erro.  Mas se você estiver interessado em conhecer os detalhes da implementação, este artigo fornecerá um entendimento profundo do problema e da solução. </p><br><h1 id="bazovye-veschi-peredacha-po-znacheniyu-i-peredacha-po-ssylke">  Coisas básicas: passagem por valor e passagem por referência </h1><br><p>  Em Go, há uma diferença na passagem de objetos por valor e por referência [1].  Vamos começar com o <strong>exemplo 1</strong> [2]: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> foobyval(i) } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre><br><p>  Provavelmente, ninguém tem dúvidas de que o resultado exibirá valores de 0 a 4. Provavelmente em algum tipo de ordem aleatória. </p><br><p>  Vejamos o <strong>exemplo 2</strong> . </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(*n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> foobyref(&amp;i) } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Como resultado, o seguinte será exibido: </p><br><p>  5 <br>  5 <br>  5 <br>  5 <br>  5 </p><br><p>  Entender por que o resultado é justo nos dará 80% da compreensão da essência do problema.  Portanto, vamos levar algum tempo para encontrar os motivos. </p><br><p>  E a resposta está aí na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especificação da linguagem Go</a> .  A especificação diz: </p><br><blockquote>  Variáveis ​​declaradas na instrução de inicialização são reutilizadas em cada loop. </blockquote><p>  Isso significa que, quando o programa está sendo executado, há apenas um objeto ou parte da memória para a variável i, e não é criado um novo para cada ciclo.  Este objeto assume um novo valor a cada iteração. </p><br><p>  Vejamos a diferença no código de máquina gerado [3] para o loop nos exemplos 1 e 2. Vamos começar com o exemplo 1. </p><br><pre> <code class="plaintext hljs">0x0026 00038 (go-func-byval.go:14) MOVL $8, (SP) 0x002d 00045 (go-func-byval.go:14) LEAQ "".foobyval·f(SB), CX 0x0034 00052 (go-func-byval.go:14) MOVQ CX, 8(SP) 0x0039 00057 (go-func-byval.go:14) MOVQ AX, 16(SP) 0x003e 00062 (go-func-byval.go:14) CALL runtime.newproc(SB) 0x0043 00067 (go-func-byval.go:13) MOVQ "".i+24(SP), AX 0x0048 00072 (go-func-byval.go:13) INCQ AX 0x004b 00075 (go-func-byval.go:13) CMPQ AX, $5 0x004f 00079 (go-func-byval.go:13) JLT 33</code> </pre> <br><p>  A instrução Go se torna uma chamada para a função runtime.newproc.  A mecânica desse processo é muito interessante, mas vamos deixar isso para o próximo artigo.  Agora, estamos mais interessados ​​no que acontece com a variável i.  Ele é armazenado no registrador AX, que é passado por valor através da pilha para a função foobyval [4] como argumento.  "Por valor", neste caso, parece copiar o valor do registrador AX para a pilha.  E alterar o AX no futuro não afeta o que é passado para a função foobyval. </p><br><p>  E aqui está o exemplo 2: </p><br><pre> <code class="plaintext hljs">0x0040 00064 (go-func-byref.go:14) LEAQ "".foobyref·f(SB), CX 0x0047 00071 (go-func-byref.go:14) MOVQ CX, 8(SP) 0x004c 00076 (go-func-byref.go:14) MOVQ AX, 16(SP) 0x0051 00081 (go-func-byref.go:14) CALL runtime.newproc(SB) 0x0056 00086 (go-func-byref.go:13) MOVQ "".&amp;i+24(SP), AX 0x005b 00091 (go-func-byref.go:13) INCQ (AX) 0x005e 00094 (go-func-byref.go:13) CMPQ (AX), $5 0x0062 00098 (go-func-byref.go:13) JLT 57</code> </pre> <br><p>  O código é muito semelhante - com apenas uma diferença, mas muito importante.  Agora no AX está o endereço i, e não seu valor.  Observe também que o incremento e a comparação do loop são feitos no (AX), não no AX.  E então, quando colocamos o AX na pilha, passamos o endereço i para a função.  A mudança (AX) também será vista na goroutine. </p><br><p>  Sem surpresas.  No final, passamos um ponteiro para um número na função foobyref. <br>  Durante a operação, o ciclo termina mais rápido do que qualquer uma das goroutines criadas começa a funcionar.  Quando começarem a trabalhar, eles terão um ponteiro para a mesma variável i, e não para uma cópia.  E qual é o valor de i neste momento?  O valor é 5. O mesmo em que o ciclo parou.  E é por isso que todas as goroutines derivam 5. </p><br><h1 id="metody-so-znacheniem-vs-metody-s-ukazatelem">  Métodos com um valor VS métodos com um ponteiro </h1><br><p>  Comportamento semelhante pode ser observado ao criar goroutines que invocam qualquer método.  Isso é indicado pela mesma página da wiki.  Veja o <strong>exemplo 3</strong> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mi MyInt)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(mi) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ms := []MyInt{<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, m := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ms { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> m.Show() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Este exemplo exibe os elementos da matriz ms.  Em ordem aleatória, como esperávamos.  Um <strong>exemplo</strong> muito semelhante <strong>4</strong> usa um método de ponteiro para o método Show: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mi *MyInt)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(*mi) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ms := []MyInt{<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, m := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ms { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> m.Show() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Tente adivinhar qual será a conclusão: 90, impresso cinco vezes.  O motivo é o mesmo do exemplo mais simples 2. Aqui, o problema é menos perceptível devido ao açúcar sintático no Go ao usar métodos de ponteiro.  Se nos exemplos, ao mudar do exemplo 1 para o exemplo 2, alteramos i para &amp; i, aqui a chamada parece a mesma!  m.Show () nos dois exemplos, e o comportamento é diferente. </p><br><p>  Não é uma combinação muito feliz de dois recursos do Go, me parece.  Nada no local da chamada indica transmissão por referência.  E você precisará examinar a implementação do método Show para ver exatamente como a chamada ocorrerá (e o método, é claro, pode estar em um arquivo ou pacote completamente diferente). </p><br><p>  Na maioria dos casos, esse recurso é útil.  Escrevemos código mais limpo.  Mas aqui, passar por referência leva a efeitos inesperados. </p><br><h1 id="zamykaniya">  Curto-circuito </h1><br><p>  Finalmente chegamos ao fechamento.  Vejamos o <strong>exemplo 5</strong> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foobyval(i) }() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Ele imprimirá o seguinte: </p><br><p>  5 <br>  5 <br>  5 <br>  5 <br>  5 </p><br><p>  E isso apesar do fato de que eu é passado por valor para foobyval no fechamento.  Semelhante ao exemplo 1. Mas por quê?  Vejamos a visualização do loop do assembler: </p><br><pre> <code class="plaintext hljs">0x0040 00064 (go-closure.go:14) LEAQ "".main.func1·f(SB), CX 0x0047 00071 (go-closure.go:14) MOVQ CX, 8(SP) 0x004c 00076 (go-closure.go:14) MOVQ AX, 16(SP) 0x0051 00081 (go-closure.go:14) CALL runtime.newproc(SB) 0x0056 00086 (go-closure.go:13) MOVQ "".&amp;i+24(SP), AX 0x005b 00091 (go-closure.go:13) INCQ (AX) 0x005e 00094 (go-closure.go:13) CMPQ (AX), $5 0x0062 00098 (go-closure.go:13) JLT 57</code> </pre> <br><p>  O código é muito semelhante ao Exemplo 2: observe que i é representado por um endereço no registro do AX.  Ou seja, passamos i por referência.  E isso apesar do fato de que foobyval é chamado.  O corpo do loop chama a função usando runtime.newproc, mas de onde vem essa função? </p><br><p>  Func1 é criado pelo compilador e é um fechamento.  O compilador alocou o código de fechamento como uma função separada e o chama de main.  O principal problema dessa alocação é como lidar com variáveis ​​que os fechamentos usam, mas que claramente não são argumentos. </p><br><p>  É assim que o corpo de func1 se parece: </p><br><pre> <code class="plaintext hljs">0x0000 00000 (go-closure.go:14) MOVQ (TLS), CX 0x0009 00009 (go-closure.go:14) CMPQ SP, 16(CX) 0x000d 00013 (go-closure.go:14) JLS 56 0x000f 00015 (go-closure.go:14) SUBQ $16, SP 0x0013 00019 (go-closure.go:14) MOVQ BP, 8(SP) 0x0018 00024 (go-closure.go:14) LEAQ 8(SP), BP 0x001d 00029 (go-closure.go:15) MOVQ "".&amp;i+24(SP), AX 0x0022 00034 (go-closure.go:15) MOVQ (AX), AX 0x0025 00037 (go-closure.go:15) MOVQ AX, (SP) 0x0029 00041 (go-closure.go:15) CALL "".foobyval(SB) 0x002e 00046 (go-closure.go:16) MOVQ 8(SP), BP 0x0033 00051 (go-closure.go:16) ADDQ $16, SP 0x0037 00055 (go-closure.go:16) RET</code> </pre> <br><p>  É interessante aqui que a função tenha um argumento em 24 (SP), que é um ponteiro para int: dê uma olhada na linha MOVQ (AX), AX, que recebe um valor antes de passá-lo para foobyval.  De fato, o func1 se parece com isso: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { foobyval(*i) }    main   - : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> func1(&amp;i) }</code> </pre><br><p>  Recebeu o equivalente ao exemplo 2, e isso explica a conclusão.  Em linguagem técnica, diríamos que i é uma variável livre dentro de um fechamento e essas variáveis ​​são capturadas por referência em Go. </p><br><p>  Mas este é sempre o caso?  Surpreendentemente, a resposta é não.  Em alguns casos, variáveis ​​livres são capturadas por valor.  Aqui está uma variação do nosso exemplo: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { ii := i <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foobyval(ii) }() }</code> </pre> <br><p>  Este exemplo produzirá 0, 1, 2, 3, 4 em ordem aleatória.  Mas por que o comportamento aqui é diferente do Exemplo 5? </p><br><p>  Acontece que esse comportamento é um artefato da heurística que o compilador Go usa quando trabalha com fechamentos. </p><br><h1 id="smotrim-pod-kapot">  Nós olhamos sob o capô </h1><br><p>  Se você não estiver familiarizado com a arquitetura do compilador Go, recomendo que você leia meus artigos anteriores sobre este tópico: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> . </p><br><p>  A árvore de sintaxe específica (em oposição ao abstrato) que é obtida analisando o código é assim: </p><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>: *syntax.CallStmt { . Tok: <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> . Call: *syntax.CallExpr { . . Fun: *syntax.FuncLit { . . . Type: *syntax.FuncType { . . . . ParamList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . . . ResultList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . . } . . . Body: *syntax.BlockStmt { . . . . List: []syntax.Stmt (<span class="hljs-number"><span class="hljs-number">1</span></span> entries) { . . . . . <span class="hljs-number"><span class="hljs-number">0</span></span>: *syntax.ExprStmt { . . . . . . X: *syntax.CallExpr { . . . . . . . Fun: foobyval @ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-closure.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span> . . . . . . . ArgList: []syntax.Expr (<span class="hljs-number"><span class="hljs-number">1</span></span> entries) { . . . . . . . . <span class="hljs-number"><span class="hljs-number">0</span></span>: i @ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-closure.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span> . . . . . . . } . . . . . . . HasDots: <span class="hljs-literal"><span class="hljs-literal">false</span></span> . . . . . . } . . . . . } . . . . } . . . . Rbrace: syntax.Pos {} . . . } . . } . . ArgList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . HasDots: <span class="hljs-literal"><span class="hljs-literal">false</span></span> . } }</code> </pre> <br><p>  A função chamada é representada pelo nó FuncLit, uma função constante.  Quando essa árvore é convertida em AST (árvore de sintaxe abstrata), o destaque dessa função constante como uma separada é o resultado.  Isso acontece no método noder.funcLit, que vive em gc / encerramento.go. </p><br><p>  Em seguida, o verificador tipe conclui a transformação e obtemos a seguinte representação para a função no AST: </p><br><pre> <code class="go hljs">main.func1: . DCLFUNC l(<span class="hljs-number"><span class="hljs-number">14</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) FUNC-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DCLFUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-function"> . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CALLFUNC</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(15)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> . . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NAME</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(8)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(0)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PFUNC)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">used</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CALLFUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-function"> . . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NAME</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">il</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(15)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(0)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PAUTOHEAP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">used</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span></code> </pre> <br><p>  Observe que o valor passado para foobyval é NAME-main.i, ou seja, apontamos explicitamente para a variável da função que encerra o fechamento. </p><br><p>  Nesse estágio, o estágio do compilador, chamado capturevars, ou seja, "capturando variáveis", entra em operação.  Seu objetivo é decidir como capturar "variáveis ​​fechadas" (ou seja, variáveis ​​livres usadas em fechamentos).  Aqui está um comentário da função de compilador correspondente, que também descreve heurísticas: </p><br><p>  // capturevars é chamado em uma fase separada após todas as verificações de tipo. <br>  // Decide se deve capturar a variável por valor ou por referência. <br>  // Usamos captura por valor para valores &lt;= 128 bytes que não alteram mais o valor após a captura (essencialmente constantes). </p><br><p>  Quando capturevars é chamado no Exemplo 5, ele decide que a variável de loop i deve ser capturada por referência e adiciona o sinalizador addrtaken apropriado a ela.  Isso pode ser visto na saída AST: </p><br><pre> <code class="go hljs">FOR l(<span class="hljs-number"><span class="hljs-number">13</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) . LT l(<span class="hljs-number"><span class="hljs-number">13</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> . . NAME-main.ia(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) g(<span class="hljs-number"><span class="hljs-number">1</span></span>) l(<span class="hljs-number"><span class="hljs-number">13</span></span>) x(<span class="hljs-number"><span class="hljs-number">0</span></span>) class(PAUTOHEAP) esc(h) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) addrtaken assigned used <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br><p>  Para a variável de loop, a heurística de seleção "por valor" não funciona, pois a variável altera seu valor após a chamada (lembre-se da cotação da especificação de que a variável de loop é reutilizada a cada iteração).  Portanto, a variável i é capturada por referência. <br>  Nessa variação do nosso exemplo, onde temos ii: = i, ii não é mais usado e, portanto, é capturado pelo valor [5]. </p><br><p>  Assim, vemos um exemplo impressionante de sobreposição inesperada de dois recursos diferentes de uma linguagem.  Em vez de usar uma nova variável a cada iteração do loop, o Go reutiliza a mesma.  Isso, por sua vez, leva ao desencadeamento de heurísticas e à escolha da captura por referência, e isso leva a um resultado inesperado.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Go FAQ</a> diz que esse comportamento pode ser um erro de design. </p><br><blockquote>  Esse comportamento (não use uma nova variável) provavelmente é um erro ao criar um idioma.  Talvez possamos corrigi-lo em versões futuras, mas devido à compatibilidade com versões anteriores, não podemos fazer nada na versão 1 do Go. </blockquote><p>  Se você está ciente do problema, provavelmente não entrará nesse rake.  Mas lembre-se de que variáveis ​​livres sempre podem ser capturadas por referência.  Para evitar erros, certifique-se de que apenas variáveis ​​somente leitura sejam capturadas ao usar goroutin.  Isso também é importante devido a possíveis problemas nos voos de dados. </p><br><hr><br><p>  [1] Alguns leitores notaram que, estritamente falando, não existe o conceito de "passagem por referência" no Go, porque tudo é passado por valor, incluindo indicadores.  Neste artigo, quando você vê "passagem por referência", quero dizer "passagem por endereço" e é explícito em alguns casos (como passar &amp; n para uma função que espera * int) e, em alguns casos, implícito, como nos posteriores partes do artigo. </p><br><p>  [2] A seguir, uso o tempo. Durma como uma maneira rápida e suja de aguardar a conclusão de todas as goroutines.  Sem isso, o main terminará antes que as goroutines comecem a funcionar.  A maneira certa de fazer isso seria usar algo como WaitGroup ou canal concluído. </p><br><p>  [3] A representação do assembler para todos os exemplos neste artigo foi obtida usando o comando go tool compile -l -S.  O sinalizador -l desativa a função inlining e torna o código do assembler mais legível. </p><br><p>  [4] Foobyval não é chamado diretamente, pois a chamada passa.  Em vez disso, o endereço é passado como o segundo argumento (16 (SP)) para a função runtime.newproc, e o argumento para foobyval (neste caso, i) aumenta a pilha. </p><br><p>  [5] Como exercício, adicione ii = 10 como a última linha do loop for (após chamar go).  Qual foi a sua conclusão?  Porque </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt468863/">https://habr.com/ru/post/pt468863/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt468849/index.html">Engenharia reversa do processador desconhecido em um único programa</a></li>
<li><a href="../pt468851/index.html">Implementação de animação no React Native</a></li>
<li><a href="../pt468853/index.html">A história de uma aplicação bem-sucedida do SPR em um projeto Legacy</a></li>
<li><a href="../pt468859/index.html">“Roteador para bombeamento”: ajuste do equipamento TP-Link para provedores de Internet</a></li>
<li><a href="../pt468861/index.html">Positive Technologies dá vida à 'cidade hacker' no ciberbeat de standoff na HITB + CyberWeek</a></li>
<li><a href="../pt468873/index.html">Um trem particular que arruinou a conveniência</a></li>
<li><a href="../pt468875/index.html">Episódio de Hashrate e Depreciação Desmoronado</a></li>
<li><a href="../pt468877/index.html">Uma abordagem alternativa para exibir carga durante a paginação</a></li>
<li><a href="../pt468879/index.html">No início da memória do computador</a></li>
<li><a href="../pt468883/index.html">Natalia Kozlovskaya: “Quem se importa com quem desenha o OpenStreetMap: homens ou mulheres?”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>