<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüëß üé≥ üë©üèº‚Äçüî¨ Internals Go: agrupar vari√°veis ‚Äã‚Äãde loop no fechamento üïµÔ∏è üôãüèº üëÉüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje decidi traduzir para voc√™ um pequeno artigo sobre o interior da implementa√ß√£o dos chamados fechamentos ou fechamentos. Al√©m disso, voc√™ aprender√°...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Internals Go: agrupar vari√°veis ‚Äã‚Äãde loop no fechamento</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/468863/"><p><img src="https://habrastorage.org/webt/a2/v0/es/a2v0es8qfgkdntuzeattfznxanq.jpeg"></p><br><p>  <em>Hoje decidi traduzir para voc√™ um pequeno artigo sobre o interior da implementa√ß√£o dos chamados fechamentos ou fechamentos.</em>  <em>Al√©m disso, voc√™ aprender√° como o Go tenta determinar automaticamente se deve usar um ponteiro / link ou valor em diferentes casos.</em>  <em>Compreender essas coisas evitar√° erros.</em>  <em>E √© s√≥ que todo esse interior √© bem interessante, eu acho!</em> </p><br><p>  <em>E tamb√©m gostaria de convid√°-lo para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Golang Conf 2019</a> , que ser√° realizado em 7 de outubro em Moscou.</em>  <em>Sou membro do comit√™ do programa da confer√™ncia, e meus colegas e eu escolhemos muitos relat√≥rios igualmente graves e muito, muito interessantes.</em>  <em>O que eu amo!</em> </p><br><p>  <em>Abaixo do recado, passo a palavra ao autor.</em> </p><a name="habracut"></a><br><br><p>  H√° uma p√°gina no wiki da Go intitulada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Erros Frequentes</a> .  Curiosamente, existe apenas um exemplo: uso indevido de vari√°veis ‚Äã‚Äãde loop com goroutines: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, val := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> values { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(val) }() }</code> </pre> <br><p>  Este c√≥digo produzir√° o √∫ltimo valor da matriz de valores len (valores) vezes.  A corre√ß√£o do c√≥digo √© muito simples: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// assume the type of each value is string for _, val := range values { go func(val string) { fmt.Println(val) }(val) }</span></span></code> </pre> <br><p>  Este exemplo √© suficiente para entender o problema e nunca mais cometer um erro.  Mas se voc√™ estiver interessado em conhecer os detalhes da implementa√ß√£o, este artigo fornecer√° um entendimento profundo do problema e da solu√ß√£o. </p><br><h1 id="bazovye-veschi-peredacha-po-znacheniyu-i-peredacha-po-ssylke">  Coisas b√°sicas: passagem por valor e passagem por refer√™ncia </h1><br><p>  Em Go, h√° uma diferen√ßa na passagem de objetos por valor e por refer√™ncia [1].  Vamos come√ßar com o <strong>exemplo 1</strong> [2]: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> foobyval(i) } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre><br><p>  Provavelmente, ningu√©m tem d√∫vidas de que o resultado exibir√° valores de 0 a 4. Provavelmente em algum tipo de ordem aleat√≥ria. </p><br><p>  Vejamos o <strong>exemplo 2</strong> . </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(*n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> foobyref(&amp;i) } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Como resultado, o seguinte ser√° exibido: </p><br><p>  5 <br>  5 <br>  5 <br>  5 <br>  5 </p><br><p>  Entender por que o resultado √© justo nos dar√° 80% da compreens√£o da ess√™ncia do problema.  Portanto, vamos levar algum tempo para encontrar os motivos. </p><br><p>  E a resposta est√° a√≠ na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especifica√ß√£o da linguagem Go</a> .  A especifica√ß√£o diz: </p><br><blockquote>  Vari√°veis ‚Äã‚Äãdeclaradas na instru√ß√£o de inicializa√ß√£o s√£o reutilizadas em cada loop. </blockquote><p>  Isso significa que, quando o programa est√° sendo executado, h√° apenas um objeto ou parte da mem√≥ria para a vari√°vel i, e n√£o √© criado um novo para cada ciclo.  Este objeto assume um novo valor a cada itera√ß√£o. </p><br><p>  Vejamos a diferen√ßa no c√≥digo de m√°quina gerado [3] para o loop nos exemplos 1 e 2. Vamos come√ßar com o exemplo 1. </p><br><pre> <code class="plaintext hljs">0x0026 00038 (go-func-byval.go:14) MOVL $8, (SP) 0x002d 00045 (go-func-byval.go:14) LEAQ "".foobyval¬∑f(SB), CX 0x0034 00052 (go-func-byval.go:14) MOVQ CX, 8(SP) 0x0039 00057 (go-func-byval.go:14) MOVQ AX, 16(SP) 0x003e 00062 (go-func-byval.go:14) CALL runtime.newproc(SB) 0x0043 00067 (go-func-byval.go:13) MOVQ "".i+24(SP), AX 0x0048 00072 (go-func-byval.go:13) INCQ AX 0x004b 00075 (go-func-byval.go:13) CMPQ AX, $5 0x004f 00079 (go-func-byval.go:13) JLT 33</code> </pre> <br><p>  A instru√ß√£o Go se torna uma chamada para a fun√ß√£o runtime.newproc.  A mec√¢nica desse processo √© muito interessante, mas vamos deixar isso para o pr√≥ximo artigo.  Agora, estamos mais interessados ‚Äã‚Äãno que acontece com a vari√°vel i.  Ele √© armazenado no registrador AX, que √© passado por valor atrav√©s da pilha para a fun√ß√£o foobyval [4] como argumento.  "Por valor", neste caso, parece copiar o valor do registrador AX para a pilha.  E alterar o AX no futuro n√£o afeta o que √© passado para a fun√ß√£o foobyval. </p><br><p>  E aqui est√° o exemplo 2: </p><br><pre> <code class="plaintext hljs">0x0040 00064 (go-func-byref.go:14) LEAQ "".foobyref¬∑f(SB), CX 0x0047 00071 (go-func-byref.go:14) MOVQ CX, 8(SP) 0x004c 00076 (go-func-byref.go:14) MOVQ AX, 16(SP) 0x0051 00081 (go-func-byref.go:14) CALL runtime.newproc(SB) 0x0056 00086 (go-func-byref.go:13) MOVQ "".&amp;i+24(SP), AX 0x005b 00091 (go-func-byref.go:13) INCQ (AX) 0x005e 00094 (go-func-byref.go:13) CMPQ (AX), $5 0x0062 00098 (go-func-byref.go:13) JLT 57</code> </pre> <br><p>  O c√≥digo √© muito semelhante - com apenas uma diferen√ßa, mas muito importante.  Agora no AX est√° o endere√ßo i, e n√£o seu valor.  Observe tamb√©m que o incremento e a compara√ß√£o do loop s√£o feitos no (AX), n√£o no AX.  E ent√£o, quando colocamos o AX na pilha, passamos o endere√ßo i para a fun√ß√£o.  A mudan√ßa (AX) tamb√©m ser√° vista na goroutine. </p><br><p>  Sem surpresas.  No final, passamos um ponteiro para um n√∫mero na fun√ß√£o foobyref. <br>  Durante a opera√ß√£o, o ciclo termina mais r√°pido do que qualquer uma das goroutines criadas come√ßa a funcionar.  Quando come√ßarem a trabalhar, eles ter√£o um ponteiro para a mesma vari√°vel i, e n√£o para uma c√≥pia.  E qual √© o valor de i neste momento?  O valor √© 5. O mesmo em que o ciclo parou.  E √© por isso que todas as goroutines derivam 5. </p><br><h1 id="metody-so-znacheniem-vs-metody-s-ukazatelem">  M√©todos com um valor VS m√©todos com um ponteiro </h1><br><p>  Comportamento semelhante pode ser observado ao criar goroutines que invocam qualquer m√©todo.  Isso √© indicado pela mesma p√°gina da wiki.  Veja o <strong>exemplo 3</strong> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mi MyInt)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(mi) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ms := []MyInt{<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, m := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ms { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> m.Show() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Este exemplo exibe os elementos da matriz ms.  Em ordem aleat√≥ria, como esper√°vamos.  Um <strong>exemplo</strong> muito semelhante <strong>4</strong> usa um m√©todo de ponteiro para o m√©todo Show: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mi *MyInt)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(*mi) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ms := []MyInt{<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, m := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ms { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> m.Show() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Tente adivinhar qual ser√° a conclus√£o: 90, impresso cinco vezes.  O motivo √© o mesmo do exemplo mais simples 2. Aqui, o problema √© menos percept√≠vel devido ao a√ß√∫car sint√°tico no Go ao usar m√©todos de ponteiro.  Se nos exemplos, ao mudar do exemplo 1 para o exemplo 2, alteramos i para &amp; i, aqui a chamada parece a mesma!  m.Show () nos dois exemplos, e o comportamento √© diferente. </p><br><p>  N√£o √© uma combina√ß√£o muito feliz de dois recursos do Go, me parece.  Nada no local da chamada indica transmiss√£o por refer√™ncia.  E voc√™ precisar√° examinar a implementa√ß√£o do m√©todo Show para ver exatamente como a chamada ocorrer√° (e o m√©todo, √© claro, pode estar em um arquivo ou pacote completamente diferente). </p><br><p>  Na maioria dos casos, esse recurso √© √∫til.  Escrevemos c√≥digo mais limpo.  Mas aqui, passar por refer√™ncia leva a efeitos inesperados. </p><br><h1 id="zamykaniya">  Curto-circuito </h1><br><p>  Finalmente chegamos ao fechamento.  Vejamos o <strong>exemplo 5</strong> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foobyval(i) }() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Ele imprimir√° o seguinte: </p><br><p>  5 <br>  5 <br>  5 <br>  5 <br>  5 </p><br><p>  E isso apesar do fato de que eu √© passado por valor para foobyval no fechamento.  Semelhante ao exemplo 1. Mas por qu√™?  Vejamos a visualiza√ß√£o do loop do assembler: </p><br><pre> <code class="plaintext hljs">0x0040 00064 (go-closure.go:14) LEAQ "".main.func1¬∑f(SB), CX 0x0047 00071 (go-closure.go:14) MOVQ CX, 8(SP) 0x004c 00076 (go-closure.go:14) MOVQ AX, 16(SP) 0x0051 00081 (go-closure.go:14) CALL runtime.newproc(SB) 0x0056 00086 (go-closure.go:13) MOVQ "".&amp;i+24(SP), AX 0x005b 00091 (go-closure.go:13) INCQ (AX) 0x005e 00094 (go-closure.go:13) CMPQ (AX), $5 0x0062 00098 (go-closure.go:13) JLT 57</code> </pre> <br><p>  O c√≥digo √© muito semelhante ao Exemplo 2: observe que i √© representado por um endere√ßo no registro do AX.  Ou seja, passamos i por refer√™ncia.  E isso apesar do fato de que foobyval √© chamado.  O corpo do loop chama a fun√ß√£o usando runtime.newproc, mas de onde vem essa fun√ß√£o? </p><br><p>  Func1 √© criado pelo compilador e √© um fechamento.  O compilador alocou o c√≥digo de fechamento como uma fun√ß√£o separada e o chama de main.  O principal problema dessa aloca√ß√£o √© como lidar com vari√°veis ‚Äã‚Äãque os fechamentos usam, mas que claramente n√£o s√£o argumentos. </p><br><p>  √â assim que o corpo de func1 se parece: </p><br><pre> <code class="plaintext hljs">0x0000 00000 (go-closure.go:14) MOVQ (TLS), CX 0x0009 00009 (go-closure.go:14) CMPQ SP, 16(CX) 0x000d 00013 (go-closure.go:14) JLS 56 0x000f 00015 (go-closure.go:14) SUBQ $16, SP 0x0013 00019 (go-closure.go:14) MOVQ BP, 8(SP) 0x0018 00024 (go-closure.go:14) LEAQ 8(SP), BP 0x001d 00029 (go-closure.go:15) MOVQ "".&amp;i+24(SP), AX 0x0022 00034 (go-closure.go:15) MOVQ (AX), AX 0x0025 00037 (go-closure.go:15) MOVQ AX, (SP) 0x0029 00041 (go-closure.go:15) CALL "".foobyval(SB) 0x002e 00046 (go-closure.go:16) MOVQ 8(SP), BP 0x0033 00051 (go-closure.go:16) ADDQ $16, SP 0x0037 00055 (go-closure.go:16) RET</code> </pre> <br><p>  √â interessante aqui que a fun√ß√£o tenha um argumento em 24 (SP), que √© um ponteiro para int: d√™ uma olhada na linha MOVQ (AX), AX, que recebe um valor antes de pass√°-lo para foobyval.  De fato, o func1 se parece com isso: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { foobyval(*i) }    main   - : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> func1(&amp;i) }</code> </pre><br><p>  Recebeu o equivalente ao exemplo 2, e isso explica a conclus√£o.  Em linguagem t√©cnica, dir√≠amos que i √© uma vari√°vel livre dentro de um fechamento e essas vari√°veis ‚Äã‚Äãs√£o capturadas por refer√™ncia em Go. </p><br><p>  Mas este √© sempre o caso?  Surpreendentemente, a resposta √© n√£o.  Em alguns casos, vari√°veis ‚Äã‚Äãlivres s√£o capturadas por valor.  Aqui est√° uma varia√ß√£o do nosso exemplo: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { ii := i <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foobyval(ii) }() }</code> </pre> <br><p>  Este exemplo produzir√° 0, 1, 2, 3, 4 em ordem aleat√≥ria.  Mas por que o comportamento aqui √© diferente do Exemplo 5? </p><br><p>  Acontece que esse comportamento √© um artefato da heur√≠stica que o compilador Go usa quando trabalha com fechamentos. </p><br><h1 id="smotrim-pod-kapot">  N√≥s olhamos sob o cap√¥ </h1><br><p>  Se voc√™ n√£o estiver familiarizado com a arquitetura do compilador Go, recomendo que voc√™ leia meus artigos anteriores sobre este t√≥pico: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> . </p><br><p>  A √°rvore de sintaxe espec√≠fica (em oposi√ß√£o ao abstrato) que √© obtida analisando o c√≥digo √© assim: </p><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>: *syntax.CallStmt { . Tok: <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> . Call: *syntax.CallExpr { . . Fun: *syntax.FuncLit { . . . Type: *syntax.FuncType { . . . . ParamList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . . . ResultList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . . } . . . Body: *syntax.BlockStmt { . . . . List: []syntax.Stmt (<span class="hljs-number"><span class="hljs-number">1</span></span> entries) { . . . . . <span class="hljs-number"><span class="hljs-number">0</span></span>: *syntax.ExprStmt { . . . . . . X: *syntax.CallExpr { . . . . . . . Fun: foobyval @ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-closure.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span> . . . . . . . ArgList: []syntax.Expr (<span class="hljs-number"><span class="hljs-number">1</span></span> entries) { . . . . . . . . <span class="hljs-number"><span class="hljs-number">0</span></span>: i @ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-closure.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span> . . . . . . . } . . . . . . . HasDots: <span class="hljs-literal"><span class="hljs-literal">false</span></span> . . . . . . } . . . . . } . . . . } . . . . Rbrace: syntax.Pos {} . . . } . . } . . ArgList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . HasDots: <span class="hljs-literal"><span class="hljs-literal">false</span></span> . } }</code> </pre> <br><p>  A fun√ß√£o chamada √© representada pelo n√≥ FuncLit, uma fun√ß√£o constante.  Quando essa √°rvore √© convertida em AST (√°rvore de sintaxe abstrata), o destaque dessa fun√ß√£o constante como uma separada √© o resultado.  Isso acontece no m√©todo noder.funcLit, que vive em gc / encerramento.go. </p><br><p>  Em seguida, o verificador tipe conclui a transforma√ß√£o e obtemos a seguinte representa√ß√£o para a fun√ß√£o no AST: </p><br><pre> <code class="go hljs">main.func1: . DCLFUNC l(<span class="hljs-number"><span class="hljs-number">14</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) FUNC-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DCLFUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-function"> . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CALLFUNC</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(15)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> . . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NAME</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(8)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(0)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PFUNC)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">used</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CALLFUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-function"> . . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NAME</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">il</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(15)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(0)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PAUTOHEAP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">used</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span></code> </pre> <br><p>  Observe que o valor passado para foobyval √© NAME-main.i, ou seja, apontamos explicitamente para a vari√°vel da fun√ß√£o que encerra o fechamento. </p><br><p>  Nesse est√°gio, o est√°gio do compilador, chamado capturevars, ou seja, "capturando vari√°veis", entra em opera√ß√£o.  Seu objetivo √© decidir como capturar "vari√°veis ‚Äã‚Äãfechadas" (ou seja, vari√°veis ‚Äã‚Äãlivres usadas em fechamentos).  Aqui est√° um coment√°rio da fun√ß√£o de compilador correspondente, que tamb√©m descreve heur√≠sticas: </p><br><p>  // capturevars √© chamado em uma fase separada ap√≥s todas as verifica√ß√µes de tipo. <br>  // Decide se deve capturar a vari√°vel por valor ou por refer√™ncia. <br>  // Usamos captura por valor para valores &lt;= 128 bytes que n√£o alteram mais o valor ap√≥s a captura (essencialmente constantes). </p><br><p>  Quando capturevars √© chamado no Exemplo 5, ele decide que a vari√°vel de loop i deve ser capturada por refer√™ncia e adiciona o sinalizador addrtaken apropriado a ela.  Isso pode ser visto na sa√≠da AST: </p><br><pre> <code class="go hljs">FOR l(<span class="hljs-number"><span class="hljs-number">13</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) . LT l(<span class="hljs-number"><span class="hljs-number">13</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> . . NAME-main.ia(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) g(<span class="hljs-number"><span class="hljs-number">1</span></span>) l(<span class="hljs-number"><span class="hljs-number">13</span></span>) x(<span class="hljs-number"><span class="hljs-number">0</span></span>) class(PAUTOHEAP) esc(h) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) addrtaken assigned used <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br><p>  Para a vari√°vel de loop, a heur√≠stica de sele√ß√£o "por valor" n√£o funciona, pois a vari√°vel altera seu valor ap√≥s a chamada (lembre-se da cota√ß√£o da especifica√ß√£o de que a vari√°vel de loop √© reutilizada a cada itera√ß√£o).  Portanto, a vari√°vel i √© capturada por refer√™ncia. <br>  Nessa varia√ß√£o do nosso exemplo, onde temos ii: = i, ii n√£o √© mais usado e, portanto, √© capturado pelo valor [5]. </p><br><p>  Assim, vemos um exemplo impressionante de sobreposi√ß√£o inesperada de dois recursos diferentes de uma linguagem.  Em vez de usar uma nova vari√°vel a cada itera√ß√£o do loop, o Go reutiliza a mesma.  Isso, por sua vez, leva ao desencadeamento de heur√≠sticas e √† escolha da captura por refer√™ncia, e isso leva a um resultado inesperado.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Go FAQ</a> diz que esse comportamento pode ser um erro de design. </p><br><blockquote>  Esse comportamento (n√£o use uma nova vari√°vel) provavelmente √© um erro ao criar um idioma.  Talvez possamos corrigi-lo em vers√µes futuras, mas devido √† compatibilidade com vers√µes anteriores, n√£o podemos fazer nada na vers√£o 1 do Go. </blockquote><p>  Se voc√™ est√° ciente do problema, provavelmente n√£o entrar√° nesse rake.  Mas lembre-se de que vari√°veis ‚Äã‚Äãlivres sempre podem ser capturadas por refer√™ncia.  Para evitar erros, certifique-se de que apenas vari√°veis ‚Äã‚Äãsomente leitura sejam capturadas ao usar goroutin.  Isso tamb√©m √© importante devido a poss√≠veis problemas nos voos de dados. </p><br><hr><br><p>  [1] Alguns leitores notaram que, estritamente falando, n√£o existe o conceito de "passagem por refer√™ncia" no Go, porque tudo √© passado por valor, incluindo indicadores.  Neste artigo, quando voc√™ v√™ "passagem por refer√™ncia", quero dizer "passagem por endere√ßo" e √© expl√≠cito em alguns casos (como passar &amp; n para uma fun√ß√£o que espera * int) e, em alguns casos, impl√≠cito, como nos posteriores partes do artigo. </p><br><p>  [2] A seguir, uso o tempo. Durma como uma maneira r√°pida e suja de aguardar a conclus√£o de todas as goroutines.  Sem isso, o main terminar√° antes que as goroutines comecem a funcionar.  A maneira certa de fazer isso seria usar algo como WaitGroup ou canal conclu√≠do. </p><br><p>  [3] A representa√ß√£o do assembler para todos os exemplos neste artigo foi obtida usando o comando go tool compile -l -S.  O sinalizador -l desativa a fun√ß√£o inlining e torna o c√≥digo do assembler mais leg√≠vel. </p><br><p>  [4] Foobyval n√£o √© chamado diretamente, pois a chamada passa.  Em vez disso, o endere√ßo √© passado como o segundo argumento (16 (SP)) para a fun√ß√£o runtime.newproc, e o argumento para foobyval (neste caso, i) aumenta a pilha. </p><br><p>  [5] Como exerc√≠cio, adicione ii = 10 como a √∫ltima linha do loop for (ap√≥s chamar go).  Qual foi a sua conclus√£o?  Porque </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt468863/">https://habr.com/ru/post/pt468863/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt468849/index.html">Engenharia reversa do processador desconhecido em um √∫nico programa</a></li>
<li><a href="../pt468851/index.html">Implementa√ß√£o de anima√ß√£o no React Native</a></li>
<li><a href="../pt468853/index.html">A hist√≥ria de uma aplica√ß√£o bem-sucedida do SPR em um projeto Legacy</a></li>
<li><a href="../pt468859/index.html">‚ÄúRoteador para bombeamento‚Äù: ajuste do equipamento TP-Link para provedores de Internet</a></li>
<li><a href="../pt468861/index.html">Positive Technologies d√° vida √† 'cidade hacker' no ciberbeat de standoff na HITB + CyberWeek</a></li>
<li><a href="../pt468873/index.html">Um trem particular que arruinou a conveni√™ncia</a></li>
<li><a href="../pt468875/index.html">Epis√≥dio de Hashrate e Deprecia√ß√£o Desmoronado</a></li>
<li><a href="../pt468877/index.html">Uma abordagem alternativa para exibir carga durante a pagina√ß√£o</a></li>
<li><a href="../pt468879/index.html">No in√≠cio da mem√≥ria do computador</a></li>
<li><a href="../pt468883/index.html">Natalia Kozlovskaya: ‚ÄúQuem se importa com quem desenha o OpenStreetMap: homens ou mulheres?‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>