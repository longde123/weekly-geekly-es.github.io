<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîû üôåüèΩ ü§≥üèæ Escribimos el cargador FPGA en LabVIEW. Parte 2 üê∂ üë©üèΩ üç¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Descargue la configuraci√≥n a FPGA a trav√©s de USB o desmonte FTDI MPSSE 
 Escribimos el cargador FPGA en LabVIEW. Parte 1 


 En el primer art√≠culo, p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribimos el cargador FPGA en LabVIEW. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429448/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descargue la configuraci√≥n a FPGA a trav√©s de USB o desmonte FTDI MPSSE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Escribimos el cargador FPGA en LabVIEW.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> </p><br><img src="https://habrastorage.org/webt/2m/nu/6l/2mnu6ljkhtj-pydr_chsebgpp_i.jpeg"><br><br>  En el primer art√≠culo, probamos el algoritmo de carga en el viejo C; en el segundo art√≠culo, descubrimos c√≥mo organizar un programa en LabVIEW e implementar una interfaz de usuario simple.  Esta vez nos familiarizaremos con los nuevos m√©todos de trabajo en LabVIEW, analizaremos las caracter√≠sticas del manejo de errores y completaremos el proyecto: implementamos el protocolo para cargar el archivo de configuraci√≥n en el FPGA. <a name="habracut"></a><br><br><h2 id="obrabotka-oshibok">  Manejo de errores </h2><br><p> Abra el c√≥digo fuente, analice la funci√≥n MPSSE_open.  A pesar de la simplicidad algor√≠tmica (las funciones se llaman una tras otra), se requieren algunos elementos de API D2XX para importar: <code>FT_OpenEx</code> , <code>FT_ResetDevice</code> , <code>FT_Purge</code> , <code>FT_SetUSBParameters</code> , <code>FT_SetChars</code> , <code>FT_SetTimeouts</code> , <code>FT_SetLatencyTimer</code> , <code>FT_SetFlowControl</code> <code>FT_SetBitMode</code>  Como se mostr√≥ en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> , la importaci√≥n de funciones se lleva a cabo utilizando el nodo <code>Call library Function</code> .  Este nodo tiene terminales dedicadas para el control de errores.  LabVIEW tiene una regla simple: todos los <abbr title="Dispositivo virtual">VI</abbr> deben rastrear errores e informar errores devueltos por terminales de error.  La mayor√≠a de los VI incorporados lo siguen estrictamente.  Espero que todos entiendan lo importante que es controlar y manejar los errores, especialmente en la etapa de depuraci√≥n, pero hay otra raz√≥n por la cual esto es tan importante que no es obvio para los programadores "cl√°sicos".  LabVIEW no tiene una secuencia estricta de dispositivos en el diagrama de bloques: el dispositivo se ejecuta cuando los datos est√°n listos en sus entradas.  Si los datos de la salida de un VI se transfieren a la entrada de otro VI, entonces est√° claro que al principio el primer VI funcionar√°, solo despu√©s del segundo.  Pero, ¬øqu√© pasa si no hay transferencia de datos y los VI realizan acciones independientes?  Por supuesto, puede utilizar la engorrosa "Estructura de secuencia plana", pero es mucho m√°s conveniente conectar los dispositivos entre s√≠ mediante una secuencia de errores. </p><br><p>  Al importar funciones D2XX, encontramos dos tipos de errores.  El primero, que es un error de importaci√≥n directa, devuelve el bloque de <code>Call library Function</code> .  El segundo es un error de la biblioteca en s√≠; casi todas las funciones lo <code>FT_STATUS</code> trav√©s de <code>FT_STATUS</code> .  Todos los valores posibles se describen como enum en el archivo de encabezado ftd2xx.h.  Aunque es suficiente saber que el valor <code>FT_OK</code> es la ausencia de un error, y todos los dem√°s valores son c√≥digos de error, me gustar√≠a rastrear no solo el hecho del error en s√≠, sino tambi√©n qu√© error ocurri√≥ y d√≥nde ocurri√≥ exactamente. </p><br><p>  En LabVIEW, los datos de error se propagan a trav√©s de grupos de <code>error</code> .  Este es un tipo de datos dedicado tan especial; LabVIEW tiene muchos VI y funciones para trabajar con √©l.  El cl√∫ster de error consta de tres elementos: una variable l√≥gica: muestra el estado, un n√∫mero entero con signo, un c√≥digo de error, una cadena, la fuente del error.  El estado indica si se ha producido un error, el c√≥digo de error determina su tipo y es utilizado por VI especiales para generar un informe.  La l√≠nea da una idea m√°s detallada de exactamente d√≥nde ocurri√≥ el error.  LabVIEW acept√≥ que si el estado es <code>TRUE</code> , entonces esto es un error, si el estado es <code>FALSE</code> , pero el c√≥digo no es cero y la l√≠nea descriptiva no est√° vac√≠a, entonces esto es una <em>advertencia</em> , si el estado es <code>FALSE</code> , el c√≥digo es cero y la l√≠nea est√° vac√≠a, no hay error. </p><br><img src="https://habrastorage.org/webt/pm/ku/gv/pmkugvhr1yzt6uarss9lfnmthuc.png"><br><br><p>  LabVIEW contiene una base de datos interna en la cual cada c√≥digo de error est√° asociado con su descripci√≥n.  Para cada tipo de error, se asigna un rango especial de valores de c√≥digo.  Por ejemplo, para los errores asociados con la operaci√≥n de la red, se asignan varios rangos: de ‚Äì2147467263 a ‚Äì1967390460, de 61 a 65, de 116 a 118 y 122, 1101, 1114, 1115, 1132 a 1134, de 1139 a 1143 y de 1178 a 1185 Para los errores definidos por el usuario, se reservan dos rangos de ‚Äì8999 a ‚Äì8000 y de 5000 a 9999. De estos rangos, podemos elegir valores para los c√≥digos de error de la biblioteca D2XX. </p><br><p>  Creemos un VI que reciba el estado de la funci√≥n D2XX como entrada y convierta este estado en un cluster de error de LabVIEW.  La mayor√≠a de las funciones y VIs en LabVIEW, habiendo recibido el estado <code>TRUE</code> en la entrada <code>Error In</code> , no ejecutan su c√≥digo, sino que transmiten informaci√≥n de <code>Error Out</code> terminal <code>Error Out</code> .  Esto le permite transferir efectivamente informaci√≥n sobre la fuente a trav√©s de toda la cadena al controlador de errores, eliminando la ejecuci√≥n de c√≥digo en modo de emergencia.  Es deseable que nuestros VI se comporten de manera similar. </p><br><p>  Organicemos la lista de estados D2XX en forma de <code>enum</code> y col√≥quela en un tipo separado (en el art√≠culo anterior hicimos esto con los tipos FTDI). </p><br><div class="spoiler">  <b class="spoiler_title">enumeraci√≥n FT_Status</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/mb/bp/kp/mbbpkpzguefjrdg2p4l2n7-rpg0.png"></div></div><br><p>  Guardamos el nuevo VI con el nombre FT_error.vi.  Agregamos dos cl√∫steres <code>Error In</code> y <code>Error Out</code> panel frontal, puede encontrarlos en el panel "Array, Matrix &amp; Cluster".  Los conectamos a los terminales en el panel de conexi√≥n en las esquinas inferior izquierda e inferior derecha, respectivamente, como ya se mencion√≥ en el art√≠culo anterior, esta es la ubicaci√≥n de los terminales de flujo de error adoptados por LabVIEW.  Agregamos la estructura <code>Case</code> al diagrama de bloques, le damos el cl√∫ster <code>Error In</code> a la entrada <code>Case selector</code> , despu√©s de lo cual la estructura <code>Case</code> cambia de color y divide dos sub-diagramas: "Sin error" - color verde y "Error" - color rojo.  Dentro del caso de error, transferimos el cl√∫ster de error desde el terminal selector directamente al t√∫nel de salida en el borde derecho.  Y en el caso verde, agregamos otro <code>Case</code> , dependiendo del estado, determinar√° si se debe crear un error (el estado no es igual a FT_OK), o dejarlo como est√°: omita el cl√∫ster de error de entrada para salir sin cambiar. </p><br><p>  Para convertir t√©cnicamente el c√≥digo de error en un cl√∫ster, puede usar el VI <code>Error Cluster From Error Code VI</code> .  Este <abbr title="Sub instrumento virtual. El es un subpribor">SubVI</abbr> agrega una cadena de llamadas a la descripci√≥n del error, para que podamos determinar no solo <strong>lo que</strong> sucedi√≥, sino tambi√©n <strong>d√≥nde</strong> sucedi√≥. </p><br><p>  Para seleccionar el texto correspondiente al estado de entrada (FT_Status), use el bloque de propiedades: seleccione "RingText.Text".  El texto del error se env√≠a a la entrada del <code>error message</code> de <code>Error Cluster From Error Code VI</code> . <br>  No olvides dibujar un √≠cono "parlante". </p><br><div class="spoiler">  <b class="spoiler_title">FT_error.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xx/xw/ub/xxxwubdzodjs1jfaywcbjamsrtg.png"><br>  <em>Panel de subinstrumentos frontal (frontal)</em> </p><br><p><img src="https://habrastorage.org/webt/ja/wu/te/jawuteahiriyixrjpcgbm91esjo.png"><br>  <em>Diagrama de bloques</em>  <em>Error de entrada</em> </p><br><p><img src="https://habrastorage.org/webt/yd/qf/lp/ydqflp1m-zexy_zvvdx8drixu9e.png"><br>  <em>Diagrama de bloques</em>  <em>No hay error en la entrada y el estado es FT_OK</em> </p><br><p><img src="https://habrastorage.org/webt/1h/wp/7m/1hwp7mcprzgv3mf9oz3jenbco4q.png"><br>  <em>Diagrama de bloques</em>  <em>No hay error en la entrada, pero el estado es diferente de FT_OK</em> </p><br></div></div><br><p>  Para probar FT_error, puede crear un VI vac√≠o, agregar el VI creado all√≠ y ver c√≥mo cambiar√° el valor al inicio si se aplican varios estados. </p><br><div class="spoiler">  <b class="spoiler_title">Prueba FT_error.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/rn/_r/be/rn_rbewvlb--au_hi3nosghkjmk.png"><br>  <em>Panel frontal (frontal) del dispositivo</em> </p><br><p><img src="https://habrastorage.org/webt/ju/44/fz/ju44fzmyx2aly2-fraydjrkyffg.png"><br>  <em>Diagrama de bloques</em> </p></div></div><br><p>  Ahora, despu√©s de cualquier llamada de funci√≥n desde la API D2XX, usaremos SubVI FT_error.vi.  Un grupo de errores pasar√° por todos los VI a lo largo de la jerarqu√≠a de llamadas. </p><br><p>  En los VI de nivel superior, debemos decidir qu√© hacer con el error detectado: puede mostrar un mensaje en el cuadro de di√°logo, escribirlo en el archivo del informe, ignorarlo o simplemente "en silencio" finalizar la aplicaci√≥n.  El cuadro de di√°logo es la forma m√°s f√°cil y popular de informar errores.  Tambi√©n es conveniente para un programador novato, ya que no hay nada que hacer.  En cada VI, el modo de <strong>manejo autom√°tico de errores</strong> est√° habilitado por defecto ( <strong>Habilitar manejo autom√°tico de errores</strong> , ubicado en la categor√≠a Ejecuci√≥n del men√∫ Propiedades del VI).  Funciona as√≠: si en alg√∫n nodo el terminal de salida <code>Error Out</code> no est√° conectado a ning√∫n lado, y se produce un error en este nodo, LabVIEW detiene la aplicaci√≥n y muestra un cuadro de di√°logo.  Si el terminal <code>Error Out</code> del nodo est√° conectado, el flujo de error se propaga seg√∫n lo programado y no se producen acciones adicionales.  Sin embargo, la ventana de mensajes se puede llamar mediante programaci√≥n, para esto debe usar el <code>General Error Handler</code> y <code>Simple Error Handler</code> controlador de <code>Simple Error Handler</code> (ubicados en el panel de di√°logo e interfaz de usuario).  En este caso, podemos usar la informaci√≥n de error para completar el programa.  En un diagrama de bloques, se ve as√≠: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/u9/8y/_p/u98y_paluq1jtgm2gylcaceydgs.png"></a> <br>  <em>Imagen en la que se puede hacer clic</em> </p><br><p>  Cuando se produce un error, el programa se suspender√°, aparecer√° una ventana de informe, despu√©s de cerrar la ventana, el programa se cerrar√° correctamente. </p><br><div class="spoiler">  <b class="spoiler_title">Ventana de informe</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9g/mh/lc/9gmhlc7e8mf-2uqzheifbdtgdek.png"></p></div></div><br><h2 id="otkryt-i-zakryt-ftdi">  Abrir y cerrar FTDI </h2><br><p>  Entonces, volvamos a la funci√≥n <code>MPSSE_open</code> .  Crea un nuevo <abbr title="Instrumento virtual">VI</abbr> .  En primer lugar, agregue los terminales para el flujo de error.  Agregue una estructura de selecci√≥n y seleccione la entrada <code>Error In</code> en el selector.  En el caso verde, importamos las funciones en el orden y con los par√°metros como en el prototipo de Sishny.  Todos los nodos del <code>Call Library Function Node</code> conectados en una cadena por un flujo de error.  En el caso rojo a trav√©s del t√∫nel conectamos <code>Error In</code> con el terminal de salida del error. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/4p/qq/zx/4pqqzxgwcgsbb-jcvepvyaj6jam.png"></a> <br>  <em>Imagen en la que se puede hacer clic</em> </p><br><p><img src="https://habrastorage.org/webt/5z/uq/k6/5zuqk6hmya20zgu9ddnciwgj5a0.png"><br>  <em>VI MPSSE_open.vi</em> </p><br><p>  Se suministra una l√≠nea con la descripci√≥n de FTDI ( <code>Description</code> ) a la entrada de SubVI, en la salida est√° <code>Handle</code> y un chip FTDI inicializado en modo MPSSE. </p><br><p>  Creemos un VP que termine de trabajar con FTDI y ya puede verificar el rendimiento en el hardware. </p><br><div class="spoiler">  <b class="spoiler_title">FT_Close.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/1e/te/g3/1eteg3uh0t2t16y9yho_kxjbufe.png"><br>  <em>Diagrama de bloques</em> </p><br><p><img src="https://habrastorage.org/webt/ki/ez/tt/kiezttogb-2n4zl1qe893hfc55w.png"><br>  <em>Panel frontal</em> </p></div></div><br><p>  En el art√≠culo anterior, para depurar la interfaz, creamos el stub VI SP_FT_MPSSE_FPGA.vi, ahora es el momento de llenarlo.  Agregue MPSSE_open.vi y FT_Close.vi a su diagrama de bloques.  En esta etapa, es bastante dif√≠cil evaluar si la inicializaci√≥n fue correcta, sin embargo, un valor <code>Handle</code> distinto de cero en la salida de MPSSE_open.vi y la ausencia de un error nos dir√° mucho. </p><br><p><img src="https://habrastorage.org/webt/ci/rn/q5/cirnq5ik2_g5p-wbz3cmfcxzquo.png"><br>  <em>Diagrama de flujo SP_FT_MPSSE_FPGA.vi</em> </p><br><p>  Para ver el valor de <code>Handle</code> puede usar la "Ventana de vigilancia de la sonda".  Esta es una conveniente herramienta de depuraci√≥n que le permite mostrar el valor de los datos en cualquier (casi cualquier) cable durante la ejecuci√≥n del dispositivo.  Para configurar la muestra en la l√≠nea, debe seleccionar "Sonda" en el men√∫ contextual de esta l√≠nea.  Se abrir√° la ventana "Probe Watch Window", y aparecer√° un n√∫mero con el n√∫mero de muestra en la l√≠nea.  En la imagen de arriba es "3". </p><br><div class="spoiler">  <b class="spoiler_title">Ventana de reloj de sonda</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/yq/qv/u_/yqqvu_pkihohde2in-uy7sttt-i.png"><br>  <em>En la l√≠nea Handle, el valor 698389336</em> </p></div></div><br><p>  Genial  Iniciamos los VI de nivel superior, conectamos la placa de depuraci√≥n a la computadora.  Aparece una descripci√≥n del chip FTDI conectado en la lista "Seleccionar un dispositivo", haga clic en el bot√≥n "Programa" y ... no sucede nada.  Solo en la ventana "Probe Watch" apareci√≥ el valor <code>Handle</code> .  Y eso est√° bien. </p><br><p>  Apagamos el tablero, se borra la lista de dispositivos.  Haga clic en "Programa".  Aqu√≠ es donde aparece la ventana de informe de errores. </p><br><div class="spoiler">  <b class="spoiler_title">Ventana de informe</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9g/mh/lc/9gmhlc7e8mf-2uqzheifbdtgdek.png"></p></div></div><br><p>  Despu√©s de hacer clic en el bot√≥n "Continuar", el VI completa su trabajo. </p><br><p>  Est√° prohibido presionar el bot√≥n si no se encuentran dispositivos.  Modificamos el controlador de eventos "Timeout" del caso.  Perm√≠tame recordarle que los chips FTDI conectados a una PC se escanean dos veces por segundo, si se detectan y pueden usarse para programar FPGA, sus descriptores se agregan a la <code>Devices list</code> trav√©s de la propiedad <code>Strings[]</code> .  Creamos la propiedad <code>Disabled</code> para "Programaci√≥n", y si no se encuentran dispositivos adecuados, apague y oscurezca el bot√≥n. </p><br><div class="spoiler">  <b class="spoiler_title">Tiempo de espera del caso</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/wx/nf/5n/wxnf5n-ttwqqrsmbtydmttzcghw.png"></a> <br>  <em>Imagen en la que se puede hacer clic</em> </p></div></div><br><h2 id="osvaivaem-gpio">  Dominar GPIO </h2><br><p>  Despu√©s de activar MPSSE, el trabajo se lleva a cabo a trav√©s del llamado "c√≥digo de <code>FT_Write</code> ", y solo se <code>FT_Write</code> , <code>FT_Read</code> y <code>FT_Queue</code> desde las <code>FT_Write</code> API <code>FT_Write</code> (para averiguar el estado del b√∫fer receptor).  Creamos el VI correspondiente a lo largo de la pista que creamos: FT_Write.vi, FT_Read.vi, FT_Queue.vi. </p><br><div class="spoiler">  <b class="spoiler_title">Un poco de rutina</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tw/or/ku/tworkua4o2qj3bntqoer1jb4o0u.png"><br>  <em>FT_Write.vi</em> </p><br><p><img src="https://habrastorage.org/webt/8k/pm/4s/8kpm4sdeaqgzlsctp-106wvtdz0.png"><br>  <em>Diagrama de bloques</em>  <em>FT_Write.vi</em> </p><br><p><img src="https://habrastorage.org/webt/i0/px/18/i0px189plvqpokb3sijjuxtxbei.png"><br>  <em>FT_Read.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ku/hm/xw/kuhmxw1j66symp05f0ergjkriag.png"><br>  <em>Diagrama de bloques</em>  <em>FT_Read.vi</em> </p><br><p><img src="https://habrastorage.org/webt/bf/2s/q_/bf2sq_t4uinirm94vmh-ugkzqzy.png"><br>  <em>FT_Queue.vi</em> </p><br><p><img src="https://habrastorage.org/webt/5p/zm/dv/5pzmdvtnhtdq0ivxzfs0t32nfjk.png"><br>  <em>Diagrama de bloques</em>  <em>FT_Queue.vi</em> </p></div></div><br><p>  Ahora, a partir de estos tres ladrillos, presentamos los VI para leer el puerto paralelo y escribir en √©l.  El valor se representa convenientemente como una matriz de variables booleanas. </p><br><div class="spoiler">  <b class="spoiler_title">MPSSE_Set_LByte.vi y MPSSE_Get_LByte.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/oy/uh/8l/oyuh8lrdyniwp6ub2pvgwrxtlvw.png"><br>  <em>MPSSE_Set_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/g4/ab/u-/g4abu-lurodnce0udnamj1ftsjm.png"><br>  <em>Diagrama de bloques</em>  <em>MPSSE_Set_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/7g/s9/5d/7gs95ddkb8pg9fjzt-s0vflzes4.png"><br>  <em>MPSSE_Get_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ki/dm/n_/kidmn_ewfihbrokreabs90538p0.png"><br>  <em>Diagrama de bloques</em>  <em>MPSSE_Get_LByte.vi</em> </p><br><p>  Confieso que era flojo para crear una lista con nombre para todos los c√≥digos de operaci√≥n, as√≠ que los dej√© en forma de n√∫meros m√°gicos. </p></div></div><br><p>  Como se indic√≥ en el primer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> , el protocolo de arranque FPGA pasivo en serie no es m√°s que un SPI con manipulaci√≥n de bandera adicional.  Se utilizan un total de cinco patas: las <em>l√≠neas DCLK</em> , <em>DATA [0]</em> , <em>nCONFIG</em> deben configurarse como salidas, las <em>l√≠neas</em> <em>nSTATUS</em> , <em>CONF_DONE</em> como entradas. </p><br><div class="spoiler">  <b class="spoiler_title">Pinout de dise√±o de tabla</b> <div class="spoiler_text"><table><thead><tr><th>  Pin FPGA </th><th>  Nombre pin </th><th>  Pin </th><th>  MPSSE </th><th>  Direcci√≥n </th><th>  por defecto </th></tr></thead><tbody><tr><td>  DCLK </td><td>  BDBUS0 </td><td>  38 </td><td>  TCK / SK </td><td>  Fuera </td><td>  0 0 </td></tr><tr><td>  DATOS [0] </td><td>  BDBUS1 </td><td>  39 </td><td>  TDI / DO </td><td>  Fuera </td><td>  1 </td></tr><tr><td>  nCONFIG </td><td>  BDBUS2 </td><td>  40 </td><td>  TDO / DI </td><td>  Fuera </td><td>  1 </td></tr><tr><td>  n ESTADO </td><td>  BDBUS3 </td><td>  41 </td><td>  TMS / CS </td><td>  En </td><td>  1 </td></tr><tr><td>  CONF_DONE </td><td>  BDBUS4 </td><td>  43 </td><td>  GPIOL0 </td><td>  En </td><td>  1 </td></tr></tbody></table></div></div><br><p>  Necesitamos un VP que pueda cambiar el valor en el tramo seleccionado sin afectar a todos los dem√°s.  En primer lugar, cree <code>Enum</code> con n√∫meros de serie de las patas en el puerto, gu√°rdelo como "Strict Type Def" en el archivo SP_LBYTE_BITS.ctl.  Creamos un nuevo VI, agregamos los terminales de flujo de error familiares.  Leemos el valor actual del puerto paralelo usando MPSSE_Get_LByte.vi, usamos la funci√≥n <code>Replace Array Subset</code> para modificar el bit deseado y escribimos el valor nuevamente en el puerto (MPSSE_Set_LByte.vi). </p><br><div class="spoiler">  <b class="spoiler_title">SP_Set_Flag.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/y7/d3/ap/y7d3aps-9ima93quyatag0ggkui.png"><br>  <em>SP_Set_Flag.vi</em> </p><br><p><img src="https://habrastorage.org/webt/jn/ae/h4/jnaeh4ewehebgcba9fstkxnxa4o.png"><br>  <em>Diagrama de bloques</em>  <em>SP_Set_Flag.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ud/mt/jx/udmtjxpekkcskrmisie8t2h4hfw.png"><br>  <em>Enum SP_LBYTE_BITS.ctl</em> </p></div></div><br><p>  Para comenzar la configuraci√≥n, el MPSSE debe generar una transici√≥n de baja a alta en la l√≠nea <em>nCONFIG</em> .  Tan pronto como el FPGA est√© listo para recibir datos, formar√° un alto nivel en la l√≠nea <em>nSTATUS</em> .  En esta etapa, todo est√° listo para el experimento en hierro.  En el diagrama de bloques SP_FT_MPSSE_FPGA.v agregamos la l√≠nea de control <em>nCONFIG</em> : despu√©s de la inicializaci√≥n del MPSSE, le damos un nivel bajo y luego alto.  Despu√©s de cada operaci√≥n (para la depuraci√≥n) leemos el estado de las patas del puerto. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/5q/8g/u1/5q8gu1k9oezxomhdblxqyjbxxas.png"><br>  <em>Durante el inicio</em> </p><br><p><img src="https://habrastorage.org/webt/nj/qv/bv/njqvbvi3dibaezauuqh4t2thdo8.png"><br>  <em>Diagrama de bloques</em> </p></div></div><br><p>  En general, durante el lanzamiento de VI, est√° claro que el FPGA responde a la transici√≥n en la l√≠nea <em>nCONFIG</em> : el cero se establece en el tramo <em>nSTATUS</em> , y luego uno.  Pero no ser√° superfluo monitorear esto con un osciloscopio.  Casi cualquier osciloscopio de dos canales con disparo por gatillo (en espera) es adecuado.  Canal <strong>A</strong> (pista azul) Puse en el punto de control del circuito <em>nCONFIG</em> , canal <strong>B</strong> (pista roja) - cadena <em>nSTATUS</em> .  El disparador se establece en el borde descendente del canal <strong>A.</strong> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ca/b9/ti/cab9tizq5kpbnbguzew2avmi_je.png"></a> <br>  <em>Se puede hacer clic en la imagen.</em>  <em>Con los detalles!</em> </p><br><h2 id="rabota-s-faylom">  Trabajar con archivo </h2><br><p>  FPGA est√° listo para aceptar el archivo de configuraci√≥n.  ¬øEstamos listos para transferir el archivo a la FPGA? </p><br><p>  LabVIEW contiene un amplio conjunto de herramientas para trabajar con archivos.  No puedo decir que la funcionalidad sea suficiente para absolutamente todo el rango de tareas, pero las operaciones b√°sicas como <em>leer</em> y <em>escribir</em> son f√°ciles y agradables.  El conjunto b√°sico de VI para trabajar con archivos se puede encontrar en el panel "E / S de archivo".  Para resolver el problema, debe abrir el archivo de configuraci√≥n, evaluar su tama√±o (necesitamos saber cu√°ntos bytes enviar el FPGA), leerlo y cerrarlo.  Todo es simple y uno tras otro.  Usamos <code>Open/Create/Replace File</code> , <code>Get File Size</code> , <code>Read from Binary File</code> , <code>Close File</code> <code>refnum</code> , combinarlos con la cadena de flujo de error y <code>refnum</code> : un n√∫mero, como un descriptor de archivo, se crea cuando el archivo se abre y debe transferirse a la entrada de otros VI que trabajan con este archivo </p><br><p>  Hasta ahora, no tenemos d√≥nde deshacernos de los datos le√≠dos, pero si realmente desea verificar la operatividad de la cadena, puede crear un indicador de tipo <code>String</code> y configurarlo un poco.  En el men√∫ contextual, active la opci√≥n "Pantalla hexadecimal", active la barra de desplazamiento vertical (Elementos visibles -&gt; Barra de desplazamiento vertical) y despu√©s del inicio, observaremos el contenido del archivo de configuraci√≥n binario. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/7w/r8/dy/7wr8dyzaxomkxwmqioien0rn2om.png"><br>  <em>Panel frontal</em>  <em>Nos fijamos en el contenido del archivo.</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/qf/8l/vv/qf8lvvjj6xtwo_be0aiu-3aa2co.png"></a> <br>  <em>Diagrama de bloques</em>  <em>Karinka clicable</em> </p></div></div><br><p>  Dos l√≠neas de c√≥digo paralelas independientes formadas en el diagrama de bloques del VI, por lo tanto, se utilizan cadenas de error separadas para ellos.  Para reducir los flujos paralelos en un terminal de <code>Error Out</code> , se utiliza la funci√≥n <code>Merge Errors</code> .  Esta funci√≥n busca errores de entrada de arriba a abajo (s√≠, puede haber m√°s de dos terminales de entrada, se estira con el mouse) y devuelve el primero que encuentra.  Si no hay errores, devuelve el primer mensaje de advertencia.  Si no hay advertencias, entonces no hay error en la salida.  Es importante tener en cuenta que el orden de conexi√≥n de las entradas de <code>Merge Errors</code> determina la prioridad de los errores, y si se produce un error inmediatamente en dos cadenas, se ignorar√° el error inferior.  Esto debe ser tratado con cuidado. </p><br><p>  Si intentamos presionar el bot√≥n "Programa" en el VI de nivel superior sin seleccionar un archivo, la entrada SP_FT_MPSSE_FPGA.vi recibir√° una ruta vac√≠a, lo que causar√° el error "Error 1430. LabVIEW: (Hex 0x596) La ruta est√° vac√≠a o relativa. Debe usar un camino absoluto ".  Como dice mi amigo de la infancia: "¬°Trivialidades, esto es algo mundano!"  Y este error no es un error en absoluto, sino la falta de atenci√≥n del usuario.  No detendremos el programa y lo juraremos con una ventana con una cruz roja, simplemente eliminaremos el error con este c√≥digo de la transmisi√≥n y en el cuadro de di√°logo recomendamos al usuario que decida sobre el archivo.  Para filtrar el error, use el VI "Borrar errores" de la paleta "Di√°logo e interfaz de usuario".  Para mostrar el mensaje: "Di√°logo de un bot√≥n". </p><br><p><img src="https://habrastorage.org/webt/o2/nf/bm/o2nfbmdreh3hdppvxsabj7hsgt4.png"></p><br><div class="spoiler">  <b class="spoiler_title">Diagrama de bloques</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/-6/ik/cp/-6ikcptiqxx7uloza1v2g5y6wdo.png"></a> <br>  <em>Imagen en la que se puede hacer clic</em> </p></div></div><br><h2 id="zagruzka-konfiguracii">  Descargar configuraci√≥n </h2><br><p>  Para la transferencia de datos en serie, el procesador MPSSE necesita enviar el c√≥digo de operaci√≥n 0x18, los argumentos del comando ser√°n la longitud de la secuencia transmitida (dos bytes, comenzando con el m√°s bajo) y la secuencia de datos en s√≠.  La longitud est√° codificada menos uno.  Enviemos el bloque de datos como VI MPSSE_send. </p><br><div class="spoiler">  <b class="spoiler_title">MPSSE_Send.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/my/du/hi/myduhilu9cbsm8f3j_ceduagppq.png"><br>  <em>MPSSE_Send.vi</em> </p><br><p><img src="https://habrastorage.org/webt/fv/13/9m/fv139mrjy-t8l8cz-u82btswts8.png"><br>  <em>Diagrama de bloques</em> </p></div></div><br><p>  El tama√±o del b√∫fer de entrada ( <code>Array Size</code> ) se convierte en un tipo de doble byte <code>U16</code> , restamos uno, intercambiamos los bytes bajo y alto ( <code>Swap Bytes</code> ): debe enviar la longitud comenzando desde el m√°s bajo y convertir el n√∫mero de doble byte en una matriz de un solo byte ( <code>Type Cast</code> ). </p><br><p>  La funci√≥n <code>Type Cast</code> merece especial atenci√≥n.  Este es un convertidor de tipo tan universal, cuyo ingenio a veces es muy sorprendente.  En resumen, entonces: </p><br><p><img src="https://habrastorage.org/webt/k9/qp/0t/k9qp0tiyjs2ajjgisnhbfuaonpe.png"><br>  <em>Visualmente para el programador</em> </p><br><p>  Sin embargo, esto no es solo transmitir datos a un tipo diferente, tambi√©n es una interpretaci√≥n heur√≠stica.  Esta funci√≥n le permite realizar conversiones entre tipos de datos incompatibles, mientras que la funci√≥n no duda en alinear los datos de entrada e incluso eliminar las partes "adicionales".  Si el tipo de datos solicitado requiere m√°s memoria que los datos de entrada, la funci√≥n asignar√° la cantidad faltante.  Para un desarrollador novato, LabVIEW <code>Type Cast</code> puede convertirse en un salvavidas, pero con el crecimiento, es mejor rechazar dicho convertidor; est√° muy oculto a la vista y puede convertirse en una fuente de errores inesperados.  Es mejor usar m√©todos de conversi√≥n m√°s expl√≠citos, como <code>Coerce To Type</code> . </p><br><p>  Al inicializar el procesador MPSSE, establecemos el tama√±o m√°ximo permitido del b√∫fer para la transferencia de datos a 65536 bytes, por lo tanto, debemos dividir el archivo de configuraci√≥n en fragmentos cuyo tama√±o no exceda el tama√±o especificado.  Utilizaremos la funci√≥n <code>Array Subset</code> , esta funci√≥n selecciona una submatriz de la matriz que comienza con el elemento <code>index</code> y una <code>length</code> larga.  Lo dividiremos en un ciclo <code>While</code> , incrementaremos cada iteraci√≥n del √≠ndice en 65536, entre las iteraciones pasaremos el valor a trav√©s del registro de desplazamiento.  Tan pronto como no sea posible pellizcar 65536 bytes de la matriz principal, tomamos todo lo que queda, lo enviamos y detenemos el ciclo. </p><br><p>  Seg√∫n el protocolo de descarga, despu√©s de que se hayan transferido todos los datos, se deben aplicar dos pulsos de reloj m√°s para iniciar la inicializaci√≥n de FPGA.  Para hacer esto, despu√©s del ciclo, enviamos otro byte "vac√≠o". </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/vp/y4/wr/vpy4wrsts1szqayvnquvjtb2nzw.png"></a> <br>  <em>Imagen en la que se puede hacer clic</em> </p></div></div><br><p>  Para comprender el √©xito del firmware, consideramos los indicadores, y si <em>CONF_DONE se</em> establece en uno, informamos <em>al</em> nivel VI superior que todo est√° bien. </p><br><p>  El programa est√° completo.  Queda por asegurarse de que el FPGA se flashee con √©xito y la placa parpadee felizmente con LED. </p><br><h2 id="pro-imenovanie-vp">  Sobre VP Naming </h2><br><p>     ,             ,       LabVIEW, ,      SubVI.              .        : </p><br><ul><li>    ‚Äî  ,     FTDI,           API D2XX.            "FT",  FT_Close.vi  FT_Read.vi. </li><li>   ‚Äî     MPSSE.        "MPSSE". : MPSSE_open.vi, MPSSE_Set_LByte.vi, MPSSE_Get_LByte.vi. </li><li>   ‚Äî    "Passive Serial"  MPSSE.     "S". , SP_FT_MPSSE_FPGA.vi ( ,   )  SP_LBYTE_BITS.ctl. </li><li>  .   .    , . </li></ul><br><p>     ( ),             .          <em>subVI</em> . </p><br><h2 id="zaklyuchenie">  </h2><br><p>  ,     ,           . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ff/i0/fq/ffi0fqqs7gbi3aczbucvusrw2qi.jpeg"></p></div></div><br><p>         ,        LabVIEW,        .    ,     ,        ,         (    ).         . </p><br><h2 id="materialy-po-teme">  Materiales relacionados </h2><br><ol><li>  . LabVIEW:  .  Por.  .  .  .‚Äì .: <br>  , 2008 ‚Äì 400 .: . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">labview_mpsse</a> .   . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   </a> .    </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Software Application Development D2XX Programmer's Guide</a> .   API D2XX. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es429448/">https://habr.com/ru/post/es429448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de486174/index.html">Ich habe keinen Umsatz</a></li>
<li><a href="../es429420/index.html">La PlayStation Classic utiliza el emulador PCSX ReARMed para su funcionamiento, sin soluciones patentadas</a></li>
<li><a href="../es429422/index.html">UHCI, o el primer USB</a></li>
<li><a href="../es429424/index.html">Robotaxi de Daimler y Bosch aparecer√° en California</a></li>
<li><a href="../es429426/index.html">QGIS y exportaci√≥n de mosaicos</a></li>
<li><a href="../es429450/index.html">T√©cnicas de programaci√≥n generalizadas en Rust: c√≥mo traducimos Exonum de Iron a actix-web</a></li>
<li><a href="../es429452/index.html">El Pent√°gono comenz√≥ a desclasificar el malware de otras personas.</a></li>
<li><a href="../es429456/index.html">Ya es una historia: ¬ød√≥nde comenz√≥ la cultura de inicio en la d√©cada de 1930?</a></li>
<li><a href="../es429458/index.html">C√≥mo hice animaciones del Sistema Solar para un hijo de segundo grado</a></li>
<li><a href="../es429460/index.html">Resumen del informe "¬øQu√© sabemos sobre los microservicios" (HL2018, Avito, Vadim Madison)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>