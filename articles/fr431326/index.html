<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñçÔ∏è üÖ±Ô∏è ‚ñ™Ô∏è D√©tection de bords en temps r√©el √† l'aide de FPGA üßòüèø üëêüèª üò°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 


 Notre projet met en ≈ìuvre un syst√®me de d√©tection des contours en temps r√©el bas√© sur la capture de trames d'image √† partir d'une cam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©tection de bords en temps r√©el √† l'aide de FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431326/"><h2 id="introduction">  Pr√©sentation </h2><br><p>  Notre projet met en ≈ìuvre un syst√®me de d√©tection des contours en temps r√©el bas√© sur la capture de trames d'image √† partir d'une cam√©ra OV7670 et leur diffusion sur un moniteur VGA apr√®s application d'un filtre en niveaux de gris et d'un op√©rateur Sobel.  Notre conception est bas√©e sur une carte FPGA Cyclone IV qui nous permet d'optimiser les performances √† l'aide des puissantes fonctionnalit√©s du mat√©riel de bas niveau et des calculs parall√®les, ce qui est important pour r√©pondre aux exigences du syst√®me en temps r√©el. </p><br><p>  Nous avons utilis√© la carte de d√©veloppement ZEOWAA FPGA qui est bas√©e sur le cyclone IV (EP4CE6E22C8N).  Nous avons √©galement utilis√© Quartus Prime Lite Edition comme environnement de d√©veloppement et Verilog HDL comme langage de programmation.  De plus, nous avons utilis√© l'interface VGA int√©gr√©e pour piloter le moniteur VGA et GPIO (General Pins for Input and Output) pour connecter le mat√©riel externe √† notre carte. </p><br><p><img src="https://habrastorage.org/webt/j4/0g/l0/j40gl0a_funpi7k3om89bkjy2xc.png" alt="Carte de d√©veloppement FPGA ZEOWAA"></p><a name="habracut"></a><br><h2 id="architecture">  L'architecture </h2><br><p>  Notre conception est divis√©e en 3 parties principales: </p><br><ol><li>  Lecture des pixels de donn√©es de la cam√©ra. </li><li>  Impl√©mentation de notre algorithme de d√©tection des contours (convertisseur en niveaux de gris et op√©rateur Sobel). </li><li>  Affichage de l'image finale en s'interfa√ßant avec un moniteur VGA. </li></ol><br><p>  En outre, il existe un stockage m√©moire interm√©diaire entre la lecture / √©criture des donn√©es et l'exploitation de ces donn√©es.  Dans ce but, nous avons impl√©ment√© deux tampons qui fonctionnent comme un espace temporaire pour les pixels avant leur utilisation. </p><br><p><img src="https://habrastorage.org/webt/-m/ra/4n/-mra4ni51g8heajqfmzauskcbtu.jpeg" alt="L'architecture impl√©ment√©e"></p><br><p>  Notez qu'apr√®s avoir pris le pixel de la cam√©ra, nous ne l'avons pas stock√© directement dans la m√©moire tampon interm√©diaire.  Au lieu de cela, nous l'avons converti en niveaux de gris puis nous l'avons stock√© dans le tampon.  En effet, le stockage des pixels en niveaux de gris 8 bits n√©cessite moins de m√©moire que le stockage des pixels color√©s qui sont 16 bits.  De plus, nous avons un autre tampon qui stocke les donn√©es apr√®s avoir appliqu√© l'op√©rateur Sobel pour les rendre pr√™tes √† √™tre affich√©es sur le moniteur. </p><br><p>  Voici les d√©tails de l'impl√©mentation de notre architecture: </p><cut></cut><br><h5 id="camera">  Appareil photo </h5><br><p>  Nous avons utilis√© la cam√©ra OV7670 qui est l'un des modules de cam√©ra les moins chers que nous ayons trouv√©s.  En outre, cette cam√©ra peut fonctionner sur 3,3 V et n'a pas besoin de protocoles de communication difficiles comme I2c ou SPI pour extraire les donn√©es de l'image.  Il ne n√©cessite qu'une interface SCCB similaire √† l'interface I2c pour d√©finir la configuration de la cam√©ra en termes de format de couleur (RGB565, RGB555, YUV, YCbCr 4: 2: 2), de r√©solution (VGA, QVGA, QQVGA, CIF, QCIF) et de nombreux autres param√®tres. </p><br><p><img src="https://habrastorage.org/webt/hj/47/uk/hj47ukzo4cqixn0tyzwegoerumg.jpeg" alt="Module cam√©ra OV7670"></p><br><p>  La vid√©o se compose d'images qui sont modifi√©es √† un rythme sp√©cifique.  Une image est une image compos√©e de lignes et de colonnes de pixels o√π chaque pixel est repr√©sent√© par des valeurs de couleur.  Dans ce projet, nous avons utilis√© la configuration par d√©faut de la cam√©ra o√π la taille du cadre est la r√©solution VGA 640 x 480 (0,3 m√©gapixels), et le format de couleur du pixel est RGB565 (5 bits pour le rouge, 6 bits pour le bleu, 5 bits pour le vert ) et le taux de changement des images est de 30 ips. </p><br><p>  Ci-dessous, les connexions de la cam√©ra au FPGA en utilisant le GPIO qui existe dans la carte de d√©veloppement: </p><br><table><thead><tr><th>  Broche dans l'appareil photo </th><th>  broche dans le FPGA </th><th>  La description </th><th>  Broche dans l'appareil photo </th><th>  broche dans le FPGA </th><th>  La description </th></tr></thead><tbody><tr><td>  3,3 V </td><td>  3,3 V </td><td>  Alimentation (+) </td><td>  GND </td><td>  GND </td><td>  Niveau d'alimentation au sol (-) </td></tr><tr><td>  Sdioc </td><td>  GND </td><td>  Horloge SCCB </td><td>  SDIOD </td><td>  GND </td><td>  Donn√©es SCCB </td></tr><tr><td>  VSYNC </td><td>  P31 </td><td>  Synchronisation verticale </td><td>  Href </td><td>  P55 </td><td>  Synchronisation horizontale </td></tr><tr><td>  PCLK </td><td>  P23 </td><td>  Horloge pixel </td><td>  Xclk </td><td>  P54 </td><td>  Horloge du syst√®me d'entr√©e (25 MHz) </td></tr><tr><td>  D7 </td><td>  P46 </td><td>  8e bit de donn√©es </td><td>  D6 </td><td>  P44 </td><td>  7e bit de donn√©es </td></tr><tr><td>  D5 </td><td>  P43 </td><td>  6e bit de donn√©es </td><td>  D4 </td><td>  P42 </td><td>  5e bit de donn√©es </td></tr><tr><td>  D3 </td><td>  P39 </td><td>  4e bit de donn√©es </td><td>  D2 </td><td>  P38 </td><td>  3e bit de donn√©es </td></tr><tr><td>  D1 </td><td>  P34 </td><td>  2e bit de donn√©es </td><td>  D0 </td><td>  P33 </td><td>  1er bit de donn√©es </td></tr><tr><td>  RESET (Active Low) </td><td>  3,3 V </td><td>  R√©initialiser la broche </td><td>  PWDN </td><td>  GND </td><td>  Broche de mise hors tension </td></tr></tbody></table><br><p>  Notez que nous n'avons pas utilis√© l'interface SCCB pour la configuration.  Donc, nous avons mis leurs fils correspondants au sol pour √©viter tout signal flottant pouvant affecter les donn√©es. </p><br><p>  Pour fournir l'horloge √† 25 MHz pour la cam√©ra, nous avons utilis√© une boucle √† verrouillage de phase (PLL) qui est un syst√®me de contr√¥le de fr√©quence en boucle ferm√©e pour fournir l'horloge n√©cessaire √† partir des 50 MHz fournis par la carte.  Pour impl√©menter la PLL, nous avons utilis√© l'outil de catalogue IP interne dans le logiciel Quartus. </p><cut></cut><br><p>  Cette cam√©ra utilise un signal de synchronisation verticale (VSYNC) pour contr√¥ler le processus d'envoi de la trame et le signal de synchronisation horizontale (HREF) pour contr√¥ler l'envoi de chaque ligne de la trame.  Cette cam√©ra utilise seulement 8 lignes de donn√©es (D0-D7) pour transf√©rer les bits qui repr√©sentent les valeurs de couleur du pixel alors que la cam√©ra divise la valeur de pixel RVB 16 bits en 2 parties (8 bits) et les envoie s√©par√©ment. </p><br><p>  Les figures ci-dessous de la fiche technique du module de cam√©ra OV7670 illustrent les signaux de synchronisation verticale et horizontale. </p><br><p><img src="https://habrastorage.org/webt/vu/9-/nr/vu9-nr2blv5dnrfezs1dsuja8ns.png" alt="Synchronisation de trame VGA"></p><br><p><img src="https://habrastorage.org/webt/q8/bb/nj/q8bbnji2ajbs3nxklpstw55mip8.png" alt="Calendrier horizontal"></p><br><p><img src="https://habrastorage.org/webt/sr/qt/5n/srqt5n3eoriiopfeq0icnpnf4z0.png" alt="Diagramme de synchronisation de sortie RGB565"></p><br><h5 id="grayscale-converter">  Convertisseur de niveaux de gris </h5><br><p>  Pour produire une image en niveaux de gris √† partir de son image color√©e d'origine, de nombreux facteurs doivent √™tre pris en consid√©ration, car l'image peut perdre le contraste, la nettet√©, l'ombre et la structure.  De plus, l'image doit conserver la luminance relative de l'espace colorim√©trique.  Plusieurs techniques lin√©aires et non lin√©aires sont utilis√©es pour convertir l'image couleur en niveaux de gris.  En cons√©quence, pour atteindre notre objectif, nous avons utilis√© la conversion colorim√©trique (pr√©servant la luminance perceptuelle) en niveaux de gris repr√©sent√©e dans l'√©quation suivante: </p><br><p><img src="https://habrastorage.org/webt/xo/na/bk/xonabkl8jpwg5zixxk9yl6hr8lw.png"></p><br><p>  Pour am√©liorer les performances en termes de calculs, il est plus rapide d'utiliser l'op√©rateur de d√©calage.  Par cons√©quent, l'√©quation ci-dessus peut √™tre r√©duite comme suit: </p><cut></cut><br><p><img src="https://habrastorage.org/webt/sm/6s/nr/sm6snrzc5z7nem3fsgamwy81xis.png"></p><br><p>  Par cons√©quent, apr√®s avoir captur√© une valeur de pixel (565 RVB) √† partir de la cam√©ra, elle peut √™tre imm√©diatement convertie en une valeur de pixel en niveaux de gris de 8 bits en appliquant la formule de conversion.  L'image en niveaux de gris est plus facile √† stocker dans la m√©moire et assez rapide pour servir les fonctionnalit√©s de notre syst√®me en temps r√©el car sa complexit√© est approximativement logarithmique et FPGA peut la rendre encore plus rapide en acc√©dant √† la m√©moire en parall√®le.  Apr√®s cela, l'image stock√©e est pr√™te √† impl√©menter l'algorithme de d√©tection de bord. </p><br><h5 id="intermediate-memory-the-buffer">  M√©moire interm√©diaire (le tampon) </h5><br><p>  Nous avons 2 tampons, le premier est utilis√© pour stocker les pixels apr√®s les avoir convertis en niveaux de gris et sa taille (8 bits x 150 x 150) et le second est utilis√© pour stocker les pixels apr√®s l'application de l'op√©rateur Sobel et le seuil de la valeur de sortie et sa taille (1 bit x 150 x 150).  Malheureusement, les tampons 150 x 150 ne stockent pas l'image enti√®re de la cam√©ra mais n'en stockent qu'une partie. </p><br><p>  Nous avons choisi la taille de nos tampons comme 150 x 150 en raison de la limitation de la m√©moire du cyclone IV car il ne dispose que de 276,480 Kbit tandis que nos deux tampons prennent 202,500 Kbit (150 x 150 x 9), ce qui √©quivaut √† 73,24% de la m√©moire d'origine de le cyclone IV et le reste de la m√©moire sont utilis√©s pour stocker l'algorithme et l'architecture.  De plus, nous avons essay√© (170 x 170) comme taille pour nos tampons qui prend 94,07% de la m√©moire ce qui ne laisse pas assez d'espace pour impl√©menter l'algorithme. </p><cut></cut><br><p>  Nos tampons sont de v√©ritables RAM √† double port qui peuvent lire et √©crire simultan√©ment dans diff√©rents cycles d'horloge.  Ici, nous avons cr√©√© notre impl√©mentation au lieu d'utiliser l'outil de catalogue IP dans le logiciel Quartus pour avoir plus de flexibilit√© dans l'impl√©mentation.  De plus, nous avons int√©gr√© les deux tampons dans un seul module au lieu d'avoir des modules diff√©rents. </p><br><h5 id="sobel-operator">  Op√©rateur Sobel </h5><br><p>  Nous avons utilis√© un premier op√©rateur de d√©tection de bord d√©riv√© qui est un op√©rateur de gradient de zone matricielle qui d√©termine le changement de luminance entre diff√©rents pixels.  Pour √™tre plus pr√©cis, car il s'agit d'une m√©thode simple et efficace en termes d'utilisation de la m√©moire et de complexit√© temporelle, nous avons utilis√© l'op√©rateur de gradient Sobel qui utilise un noyau 3x3 centr√© sur un pixel choisi pour repr√©senter la force du bord.  L'op√©rateur Sobel est la magnitude du gradient calcul√©e par: </p><br><p><img src="https://habrastorage.org/webt/1e/-8/aj/1e-8ajvp7o58vzzhc6d5euzljfa.png" alt="√âquation G"></p><br><p>  O√π Gx et Gy peuvent √™tre repr√©sent√©s √† l'aide de masques de convolution: </p><br><p><img src="https://habrastorage.org/webt/gq/3e/tb/gq3etbpr2ioaxrpzgmtbk8p0ppg.png" alt="Matrices de convolution Gx et Gy"></p><cut></cut><br><p>  Notez que les pixels les plus proches du centre du masque ont plus de poids.  De plus, G <sub>x</sub> et G <sub>y</sub> peuvent √™tre calcul√©s comme suit: </p><br><p><img src="https://habrastorage.org/webt/ji/wt/us/jiwtusibcq8rngnqe3hvy3kbzgu.png" alt="√âquations Gx et Gy"></p><br><p>  O√π p <sub>i</sub> est le pixel correspondant dans le tableau suivant, et la valeur de p <sub>i</sub> est une valeur en niveaux de gris de 8 bits: </p><br><p><img src="https://habrastorage.org/webt/-0/cd/4s/-0cd4stky-xqnhkaeulsuvujbam.png" alt="matrice de pixels"></p><br><p>  Il est courant d'approximer la magnitude du gradient de l'op√©rateur Sobel par des valeurs absolues: </p><br><p><img src="https://habrastorage.org/webt/jq/ga/tr/jqgatrro-agy4-hdyu_92umzdgi.png" alt="l'√©quation"></p><br><p>  Cette approximation est plus facile √† mettre en ≈ìuvre et plus rapide √† calculer, ce qui sert √† nouveau nos fonctionnalit√©s en termes de temps et de m√©moire. </p><br><p>  Voici le sch√©ma de principe de l'op√©rateur Sobel qui prend 9 pixels (8 bits) en entr√©e et produit une valeur de pixel (8 bits): </p><cut></cut><br><p><img src="https://habrastorage.org/webt/l4/eg/9w/l4eg9warlvign4ibbjq3ptcuvg4.jpeg" alt="Noyau Sobel"></p><br><p>  Et voici le sch√©ma fonctionnel d√©taill√© de la mise en ≈ìuvre de l'op√©rateur Sobel. </p><br><p><img src="https://habrastorage.org/webt/tg/0o/pg/tg0opgzckrosd2eaanar-jisy14.jpeg" alt="Noyau Sobel d√©taill√©"></p><br><h5 id="vga-monitor">  Moniteur VGA </h5><br><p>  Notre carte de d√©veloppement a une interface VGA int√©gr√©e qui a la capacit√© d'afficher seulement 8 couleurs sur le moniteur VGA car elle n'a que 3 bits pour contr√¥ler les couleurs via un bit pour le rouge, un pour le vert et un pour le bleu.  Cela a rendu notre d√©bogage plus difficile car il nous emp√™che d'afficher l'image de la cam√©ra directement sur le moniteur.  Nous avons donc utilis√© un seuil pour convertir les pixels en valeur 1 bit afin qu'il soit possible d'afficher l'image. </p><br><p>  L'interface VGA fonctionne comme l'appareil photo car elle fonctionne pixel par pixel du coin sup√©rieur gauche au coin inf√©rieur droit.  En utilisant la synchronisation verticale et horizontale, nous pouvons synchroniser les signaux qui contr√¥lent le flux de pixels. </p><br><p>  Le signal de synchronisation verticale est utilis√© pour repr√©senter l'indice de la ligne tandis que le signal de synchronisation horizontale est utilis√© pour repr√©senter l'indice de la colonne.  De plus, les deux signaux utilisent le porche avant, l'impulsion de synchronisation et le porche arri√®re comme signaux de synchronisation pour s√©parer l'ancienne ligne de la nouvelle ligne dans le signal de synchronisation horizontale, et l'ancienne trame de la nouvelle trame dans le signal de synchronisation verticale. </p><cut></cut><br><p><img src="https://habrastorage.org/webt/uv/3f/gv/uv3fgvrj_y9yuabjdhuxhvek0ak.png" alt="Diagramme de synchronisation du signal VGA"></p><br><p>  Nous avons utilis√© l'interface de signal VGA standard (640 x 480 @ 60 MHz).  Toutes les sp√©cifications standard du signal sont d√©crites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><h2 id="testing">  Test </h2><br><p>  Avant de tout assembler et de tester le syst√®me en temps r√©el.  Nous avons d'abord d√ª tester chaque partie s√©par√©ment.  Au d√©but, nous avons v√©rifi√© les valeurs et les signaux provenant de la cam√©ra en affichant certaines valeurs de pixels.  Ensuite, avec l'aide d'OpenCV utilisant le langage de programmation Python, nous avons pu appliquer le filtre Sobel sur plusieurs images pour comparer les r√©sultats avec notre algorithme et v√©rifier l'exactitude de notre logique.  De plus, nous avons test√© nos tampons et notre pilote VGA en affichant plusieurs images statiques sur le moniteur VGA apr√®s avoir appliqu√© l'op√©rateur Sobel et le seuillage.  De plus, en modifiant la valeur du seuil, la pr√©cision de l'image est affect√©e. </p><cut></cut><br><p>  Le code python que nous avons utilis√©: </p><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># This code is made to test the accuracy of our algorithm on FPGA import cv2 #import opencv library f = open("sample.txt",'w') # Open file to write on it the static image initialization lines img = cv2.imread('us.jpg') # Read the image which has our faces and its size 150x150 gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #convert to grayscale sobelx = cv2.Sobel(gray,cv2.CV_64F,1,0,ksize=3) #x-axis sobel operator sobely = cv2.Sobel(gray,cv2.CV_64F,0,1,ksize=3) #y-axis sobel operator abs_grad_x = cv2.convertScaleAbs(sobelx) abs_grad_y = cv2.convertScaleAbs(sobely) grad = abs_grad_x + abs_grad_y for i in range(0,150): for x in range(0,150): #read the pixels of the grayscaled image and Store them into file with specific format to initialize the buffer in FPGA code f.write("data_a[{:d}]&lt;=8'd{:d};\n".format(i*150+x,gray[i][x])) #apply threshold to be exactly like the code on FPGA if(grad[i][x] &lt; 100): grad[i][x] = 255 else: grad[i][x] = 0 cv2.imshow("rgb", img) #Show the real img cv2.imshow("gray",gray) #Show the grayscale img cv2.imshow("sobel",grad)#Show the result img cv2.waitKey(0) #Stop the img to see it</span></span></code> </pre> <cut></cut><br><h2 id="results">  R√©sultats </h2><br><p>  Gr√¢ce √† notre impl√©mentation, nous avons obtenu un syst√®me de d√©tection de bord en temps r√©el qui produit une image 150x150 apr√®s avoir appliqu√© le filtre en niveaux de gris et l'op√©rateur Sobel.  Le syst√®me impl√©ment√© fournit 30 fps.  La cam√©ra fonctionne sur une horloge de 25 MHz et le syst√®me, en g√©n√©ral, respecte les d√©lais en temps r√©el sans retard notable.  De plus, la valeur de seuil peut affecter la quantit√© de d√©tails et le bruit dans l'image finale. </p><br><p>  Voici une comparaison entre l'op√©rateur Sobel sur FPGA et l'op√©rateur sobel OpenCV: </p><br><p><img src="https://habrastorage.org/webt/pg/sl/rc/pgslrcclisueu2qpfghaav-yju8.png" alt="Comparaison"></p><br><p>  Voici une vid√©o illustrative des r√©sultats: </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/3a5/ea2/d49/3a5ea2d49eeb6e23f9ca4a64921d287a.jpg" alt="Vid√©o du projet"></a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici</a> le lien du d√©p√¥t sur Github qui contient tous les codes sources. </p><br><h2 id="future-improvements">  Am√©liorations futures </h2><br><p>  Comme nous utilisons FPGA Cyclone IV, nous sommes limit√©s √† sa capacit√© de m√©moire et au nombre de portes logiques.  Par cons√©quent, comme am√©lioration future, nous pouvons utiliser une source de m√©moire externe ou nous pouvons impl√©menter notre travail sur une autre carte afin que nous puissions afficher tous les pixels de l'image re√ßue de la cam√©ra. </p><br><p>  De plus, bien que l'op√©rateur Sobel soit rapide et simple √† mettre en ≈ìuvre, il est sensible au bruit.  Pour √©liminer le bruit produit, nous pouvons utiliser un filtre de bruit comme le filtre m√©dian non lin√©aire qui fonctionne parfaitement avec notre syst√®me si nous avions suffisamment de m√©moire pour impl√©menter un troisi√®me tampon.  Cela produira une image plus lisse avec des fonctionnalit√©s nettes supprim√©es. </p><br><p>  En cons√©quence, nous avons utilis√© l'interface VGA int√©gr√©e du FPGA qui ne peut produire qu'une image 3 bits.  Ainsi, nous n'avons pas pu afficher l'image en niveaux de gris car elle a besoin de 8 bits pour √™tre affich√©e.  Par cons√©quent, la mise en ≈ìuvre d'une autre interface ou l'utilisation d'une carte plus puissante am√©liorera la flexibilit√© d'affichage de l'image. </p><cut></cut><br><h2 id="conclusion">  Conclusion </h2><br><p>  Nous avons pu utiliser nos connaissances et notre compr√©hension des concepts cruciaux des syst√®mes embarqu√©s comme machines √† √©tats, parall√©lisme des calculs et interface mat√©rielle-logicielle pour cr√©er une application de d√©tection de bord efficace qui r√©pond √† nos objectifs. </p><br><h2 id="acknowledgment">  Remerciements </h2><br><p>  Ce projet est construit par une √©quipe compos√©e de deux √©tudiants: <strong>Hussein Youness</strong> et <strong>Hany Hamed</strong> en premi√®re ann√©e de baccalaur√©at en informatique √† l' <strong>Universit√© Innopolis</strong> en Russie. </p><br><p>  Ce projet fait partie du cours d' <strong>architecture informatique</strong> automne 2018 √† l' <strong>Universit√© Innopolis</strong> . </p><br><div class="spoiler">  <b class="spoiler_title">Les r√©f√©rences</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://eu.mouser.com/ProductDetail/Intel-Altera/EP4CE6E22C8N?qs=jblrfmjbeiF2FLmcokX%252bDw%3D%3D</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.voti.nl/docs/OV7670.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://embeddedprogrammer.blogspot.com/2012/07/hacking-ov7670-camera-module-sccb-cheat.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.intel.com/content/www/us/en/programmable/support/support-resources/operation-and-testing/pll-and-clock-management/pll-basics.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://knowledge.ni.com/KnowledgeArticleDetails?id=kA00Z000000P9T3SAK</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/ug/ug_megafunction_overview.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/ug/ug_ram_rom.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://www.cse.usf.edu/~r1k/MachineVisionBook/MachineVision.files/MachineVision_Chapter5.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.digikey.com/eewiki/pages/viewpage.action?pageId=15925278</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://tinyvga.com/vga-timing/640x480@60Hz</a> </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431326/">https://habr.com/ru/post/fr431326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431316/index.html">Vote sur la deuxi√®me version b√™ta du rapport r√©vis√© 7 sur le sch√©ma de langage algorithmique (grand langage)</a></li>
<li><a href="../fr431318/index.html">Cha√Æne de transcripteur Python ‚Üí 11l ‚Üí C ++ [pour acc√©l√©rer le code Python et plus]</a></li>
<li><a href="../fr431320/index.html">Etude IFR: le nombre de robots industriels en Russie est encore n√©gligeable</a></li>
<li><a href="../fr431322/index.html">It√©rations du cycle: comment s'est pass√©e la conf√©rence HolyJS et qu'en est-il de la prochaine</a></li>
<li><a href="../fr431324/index.html">Microsoft propose une alternative aux caract√®res personnalis√©s</a></li>
<li><a href="../fr431328/index.html">Kotlin, IT en Estonie et (du coup) le tunnel entre Tallinn et Helsinki: un entretien avec Anton Keks</a></li>
<li><a href="../fr431330/index.html">Week-end mobile: diffusion gratuite Mobius</a></li>
<li><a href="../fr431332/index.html">Aper√ßu des rapports DotNext 2018 les plus int√©ressants: version EastBanc Technologies</a></li>
<li><a href="../fr431334/index.html">Huawei: Protection de l'avion de contr√¥le</a></li>
<li><a href="../fr431338/index.html">Le livre "ADN. L'histoire de la r√©volution g√©n√©tique ¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>