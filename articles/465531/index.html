<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ご   Desempaquetar listas anidadas de profundidad indefinida   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy me gustar铆a hablar sobre c贸mo desempacar listas anidadas de profundidad indefinida. Esta es una tarea bastante no trivial, por lo que me gustar铆a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desempaquetar listas anidadas de profundidad indefinida</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465531/"><p>  Hoy me gustar铆a hablar sobre c贸mo desempacar listas anidadas de profundidad indefinida.  Esta es una tarea bastante no trivial, por lo que me gustar铆a contarles aqu铆 qu茅 son las implementaciones, sus ventajas y desventajas y una comparaci贸n de su rendimiento. </p><br><p>  El art铆culo constar谩 de varias secciones a continuaci贸n: </p><br><ul><li>  Las funciones </li><li>  Datos </li><li>  Resultados </li><li>  Conclusiones </li></ul><a name="habracut"></a><br><h1 id="chast-1-funkcii">  Parte 1. Funciones </h1><br><h2 id="zaimstvovannye-realizacii">  Implementaciones prestadas </h2><br><h3 id="outer_flatten_1">  outside_flatten_1 </h3><br><div class="spoiler">  <b class="spoiler_title">Implementaci贸n</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outer_flatten_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Based on C realization of this solution More on: https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html https://github.com/MSeifert04/iteration_utilities/blob/384948b4e82e41de47fa79fb73efc56c08549b01/src/deepflatten.c """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deepflatten(array)</code> </pre> </div></div><br><p>  Tom茅 esta funci贸n para analizar desde un paquete externo, iteration_utilities. </p><br><p>  La implementaci贸n se realiz贸 en C, dejando a Python una interfaz de llamada de funci贸n de alto nivel. <br>  La implementaci贸n de la funci贸n en C es bastante engorrosa, puede verla haciendo clic en el enlace del spoiler.  La funci贸n es un iterador. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Iterator, Generator &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> iteration_utilities <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deepflatten &gt;&gt;&gt; isinstance(deepflatten(a), Iterator) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; isinstance(deepflatten(a), Generator) <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Es dif铆cil decir sobre la complejidad del algoritmo implementado aqu铆, por lo que dejo este inter茅s a los usuarios de Habr. </p><br><p>  En general, tambi茅n me gustar铆a se帽alar que todas las dem谩s funciones de esta biblioteca son bastante r谩pidas y tambi茅n se implementan en C. </p><br><h3 id="outer_flatten_2">  exterior_flatten_2 </h3><br><div class="spoiler">  <b class="spoiler_title">Implementaci贸n</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outer_flatten_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" recursive algorithm, vaguely reminiscent of recursion_flatten. Based on next pattern: .. code:: python try: tree = iter(node) except TypeError: yield node more on: https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.collapse """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collapse(array)</code> </pre> </div></div><br><p>  La implementaci贸n de este m茅todo de desempaquetar listas anidadas tambi茅n se encuentra en el paquete externo, es decir, more_itertools. <br>  La funci贸n se realiza en Python puro, pero no es 贸ptima, en mi opini贸n.  Se puede ver una implementaci贸n detallada en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace de</a> documentaci贸n. <br>  La complejidad de este algoritmo es O (n * m). </p><br><h2 id="sobstvennye-realizacii">  Implementaciones propias </h2><br><h3 id="niccolum_flatten">  niccolum_flatten </h3><br><div class="spoiler">  <b class="spoiler_title">Implementaci贸n</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">niccolum_flatten</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Non recursive algorithm Based on pop/insert elements in current list """</span></span> new_array = array[:] ind = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> isinstance(new_array[ind], list): item = new_array.pop(ind) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> inner_item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reversed(item): new_array.insert(ind, inner_item) ind += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> IndexError: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new_array</code> </pre> </div></div><br><p>  Cuando de alguna manera habl茅 sobre los telegramas al p煤blico @ru_python_beginners sobre la implementaci贸n de desempaquetar listas anidadas de anidamiento indefinido, propuse mi propia versi贸n. </p><br><p>  Consiste en el hecho de que copiamos la lista original (para no cambiarla), y luego en el bucle while True verificamos mientras el elemento es una lista: lo revisamos e insertamos el resultado desde el principio. </p><br><p>  S铆, ahora entiendo que no se ve 贸ptimo y dif铆cil, porque  la reindexaci贸n ocurre cada vez (ya que agregamos y eliminamos de la parte superior de la lista), sin embargo, esta opci贸n tambi茅n tiene derecho a la vida y verificaremos su implementaci贸n junto con el resto. </p><br><p>  La complejidad de este algoritmo es O (n ^ 3 * m) debido a la reconstrucci贸n de la lista dos veces por cada iteraci贸n aprobada </p><br><h3 id="tishka_flatten">  tishka_flatten </h3><br><div class="spoiler">  <b class="spoiler_title">Implementaci贸n</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tishka_flatten</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Non recursive algorithm Based on append/extend elements to new list """</span></span> nested = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> nested: new = [] nested = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(i, list): new.extend(i) nested = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: new.append(i) data = new <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> </div></div><br><p>  Uno de los primeros tambi茅n mostr贸 la implementaci贸n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Tishka17</a> .  Consiste en el hecho de que dentro del ciclo while anidado itera sobre la lista existente con la clave nested = False, y si al menos una vez tiene una hoja, deja la bandera anidada = True y extiende esta hoja a la lista.  En consecuencia, resulta que para cada ejecuci贸n establece un nivel de anidamiento, cu谩ntos niveles de anidamiento habr谩, habr谩 tantos pases a trav茅s del ciclo.  Como se puede ver en la descripci贸n, no es el algoritmo m谩s 贸ptimo, pero a煤n as铆, es diferente del resto. <br>  La complejidad de este algoritmo es O (n * m). </p><br><h3 id="zart_flatten">  zart_flatten </h3><br><div class="spoiler">  <b class="spoiler_title">Implementaci贸n</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zart_flatten</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Non recursive algorithm Based on pop from old and append elements to new list """</span></span> queue, out = [a], [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> queue: elem = queue.pop(<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(elem, list): queue.extend(elem) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: out.append(elem) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out[::<span class="hljs-number"><span class="hljs-number">-1</span></span>]</code> </pre> </div></div><br><p>  Un algoritmo tambi茅n sugerido por uno de los participantes experimentados del chat.  En mi opini贸n, es bastante simple y limpio.  Su significado es que si el elemento es una lista, agregamos el resultado al final de la lista original, y si no, lo agregamos a la salida.  Lo llamar茅 debajo del mecanismo extender / agregar.  Como resultado, mostramos la lista plana resultante resultante invertida para preservar el orden original de los elementos. </p><br><p>  La complejidad de este algoritmo es O (n * m). </p><br><h3 id="recursive_flatten_iterator">  recursive_flatten_iterator </h3><br><div class="spoiler">  <b class="spoiler_title">Implementaci贸n</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursive_flatten_iterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arr: Iterable)</span></span></span><span class="hljs-function"> -&gt; Iterator:</span></span> <span class="hljs-string"><span class="hljs-string">""" Recursive algorithm based on iterator Usual solution to this problem """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arr: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(i, list): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> recursion_flatten(i) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> i</code> </pre> </div></div><br><p>  Probablemente la soluci贸n m谩s com煤n a este problema es a trav茅s de la recursividad y el rendimiento de.  Poco se puede decir: el algoritmo parece bastante simple y eficiente, aparte del hecho de que se realiza a trav茅s de la recursi贸n y, con un gran anidamiento, puede haber una pila de llamadas bastante grande. </p><br><p>  La complejidad de este algoritmo es O (n * m). </p><br><h3 id="recursive_flatten_generator">  recursive_flatten_generator </h3><br><div class="spoiler">  <b class="spoiler_title">Implementaci贸n</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursive_flatten_generator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Recursive algorithm Looks like recursive_flatten_iterator, but with extend/append """</span></span> lst = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(i, list): lst.extend(recursive_flatten_list(i)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: lst.append(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lst</code> </pre> </div></div><br><p>  Esta funci贸n es bastante similar a la anterior, solo se ejecuta no a trav茅s de un iterador, sino a trav茅s de un mecanismo recursivo de extensi贸n / adici贸n. </p><br><p>  La complejidad de este algoritmo es O (n * m). </p><br><h3 id="tishka_flatten_with_stack">  tishka_flatten_with_stack </h3><br><div class="spoiler">  <b class="spoiler_title">Implementaci贸n</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tishka_flatten_with_stack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(seq: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Non recursive algorithm Based on zart_flatten, but build on try/except pattern """</span></span> stack = [iter(seq)] new = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> stack: i = stack.pop() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: data = next(i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(data, list): stack.append(i) i = iter(data) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: new.append(data) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> StopIteration: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new</code> </pre> </div></div><br><p>  Un algoritmo m谩s que proporcion贸 Tishka, que, de hecho, es muy similar a zart_flatten, sin embargo, se implement贸 all铆 a trav茅s de un mecanismo simple de extensi贸n / adici贸n, luego a trav茅s de la iteraci贸n en un bucle infinito en el que se usa este mecanismo.  Por lo tanto, result贸 algo similar a zart_flatten, pero a trav茅s de la iteraci贸n y mientras True </p><br><p>  La complejidad de este algoritmo es O (n * m). </p><br><h1 id="chast-2-dannye">  Parte 2. Datos </h1><br><p>  Para probar la efectividad de estos algoritmos, necesitamos crear funciones para la generaci贸n autom谩tica de listas de un determinado anidamiento, que he tratado con 茅xito y le mostraremos el resultado a continuaci贸n: </p><br><h3 id="create_data_decreasing_depth">  create_data_decreasing_depth </h3><br><div class="spoiler">  <b class="spoiler_title">Implementaci贸n</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_data_decreasing_depth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( data: Union[List, Iterator], length: int, max_depth: int, _current_depth: int = None, _result: List = None )</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" creates data in depth on decreasing. Examples: &gt;&gt;&gt; data = create_data_decreasing_depth(list(range(1, 11)), length=5, max_depth=3) &gt;&gt;&gt; assert data == [[[1, 2, 3, 4, 5], 6, 7, 8, 9, 10]] &gt;&gt;&gt; data = create_data_decreasing_depth(list(range(1, 11)), length=2, max_depth=3) &gt;&gt;&gt; assert data == [[[1, 2], 3, 4], 5, 6], [[7, 8,] 9, 10]] """</span></span> _result = _result <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> [] _current_depth = _current_depth <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> max_depth data = iter(data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _current_depth - <span class="hljs-number"><span class="hljs-number">1</span></span>: _result.append(create_data_decreasing_depth( data=data, length=length, max_depth=max_depth, _current_depth=_current_depth - <span class="hljs-number"><span class="hljs-number">1</span></span>, _result=_result)) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: _current_length = length <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> _current_length: item = next(data) _result.append(item) _current_length -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> max_depth == _current_depth: _result += create_data_decreasing_depth( data=data, length=length, max_depth=max_depth) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _result <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> StopIteration: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _result</code> </pre> </div></div><br><p>  Esta funci贸n crea listas anidadas con anidamiento decreciente. </p><br><pre> <code class="python hljs"> &gt;&gt;&gt; data = create_data_decreasing_depth(list(range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>)), length=<span class="hljs-number"><span class="hljs-number">5</span></span>, max_depth=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> data == [[[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>], <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]] &gt;&gt;&gt; data = create_data_decreasing_depth(list(range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>)), length=<span class="hljs-number"><span class="hljs-number">2</span></span>, max_depth=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> data == [[[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>], [[<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>,] <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]]</code> </pre> <br><h3 id="create_data_increasing_depth">  create_data_increasing_depth </h3><br><div class="spoiler">  <b class="spoiler_title">Implementaci贸n</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_data_increasing_depth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( data: Union[List, Iterator], length: int, max_depth: int, _current_depth: int = None, _result: List = None )</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" creates data in depth to increase. Examples: &gt;&gt;&gt; data = create_data_increasing_depth(list(range(1, 11)), length=5, max_depth=3) &gt;&gt;&gt; assert data == [1, 2, 3, 4, 5, [6, 7, 8, 9, 10]] &gt;&gt;&gt; data = create_data_increasing_depth(list(range(1, 11)), length=2, max_depth=3) &gt;&gt;&gt; assert data == [1, 2, [3, 4, [5, 6]]], 7, 8, [9, 10]] """</span></span> _result = _result <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> [] _current_depth = _current_depth <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> max_depth data = iter(data) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: _current_length = length <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> _current_length: item = next(data) _result.append(item) _current_length -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> StopIteration: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _result <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _current_depth - <span class="hljs-number"><span class="hljs-number">1</span></span>: tmp_res = create_data_increasing_depth( data=data, length=length, max_depth=max_depth, _current_depth=_current_depth - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tmp_res: _result.append(tmp_res) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> max_depth == _current_depth: tmp_res = create_data_increasing_depth( data=data, length=length, max_depth=max_depth) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tmp_res: _result += tmp_res <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _result</code> </pre> </div></div><br><p>  Esta funci贸n crea listas anidadas con anidamiento creciente. </p><br><pre> <code class="python hljs"> &gt;&gt;&gt; data = create_data_increasing_depth(list(range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>)), length=<span class="hljs-number"><span class="hljs-number">5</span></span>, max_depth=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> data == [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, [<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]] &gt;&gt;&gt; data = create_data_increasing_depth(list(range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>)), length=<span class="hljs-number"><span class="hljs-number">2</span></span>, max_depth=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> data == [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]]], <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, [<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]]</code> </pre> <br><h3 id="generate_data">  generar_datos </h3><br><div class="spoiler">  <b class="spoiler_title">Implementaci贸n</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt; List[Tuple[str, Dict[str, Union[range, Num]]]]:</span></span> <span class="hljs-string"><span class="hljs-string">""" Generated collections of Data by pattern {amount_item}_amount_{length}_length_{max_depth}_max_depth where: .. py:attribute:: amount_item: len of flatten elements .. py:attribute:: length: len of elements at the same level of nesting .. py:attribute:: max_depth: highest possible level of nesting """</span></span> data = [] amount_of_elements = [<span class="hljs-number"><span class="hljs-number">10</span></span> ** i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>)] data_template = <span class="hljs-string"><span class="hljs-string">'{amount_item}_amount_{length}_length_{max_depth}_max_depth'</span></span> <span class="hljs-comment"><span class="hljs-comment"># amount_item doesn't need to be [1] for amount_item in amount_of_elements[1:]: for max_depth in amount_of_elements: # for exclude flatten list after generate data by create_data_increasing_depth if amount_item &gt; max_depth: # generate four types of length for length in range(0, max_depth + 1, math.ceil(max_depth / 4)): # min length must be 1 length = length or 1 data_name = data_template.format( amount_item=amount_item, length=length, max_depth=max_depth ) data_value = { 'data': range(amount_item), 'length': length, 'max_depth': max_depth } data.append((data_name, data_value)) # for not to produce more than 1 flat entity if max_depth == 1: break # this order is convenient for me data = sorted(data, key=lambda x: [x[1]['data'][-1], x[1]['max_depth'], x[1]['length']]) return data</span></span></code> </pre> </div></div><br><p>  Esta funci贸n crea directamente patrones para los datos de prueba.  Para hacer esto, genera encabezados creados por la plantilla. </p><br><pre> <code class="python hljs">data_template = <span class="hljs-string"><span class="hljs-string">'{amount_item}_amount_{length}_length_{max_depth}_max_depth'</span></span></code> </pre> <br><p>  Donde: </p><br><ul><li>  cantidad: el n煤mero total de elementos en la lista </li><li>  longitud: el n煤mero de elementos en un nivel de anidamiento </li><li>  max_depth: n煤mero m谩ximo de niveles de anidamiento </li></ul><br><p>  Los datos en s铆 se transfieren a las funciones anteriores para generar los datos necesarios.  En consecuencia, la salida, como veremos m谩s adelante, tendremos los siguientes datos (encabezados): </p><br><pre> <code class="plaintext hljs">10_amount_1_length_1_max_depth 100_amount_1_length_1_max_depth 100_amount_1_length_10_max_depth 100_amount_3_length_10_max_depth 100_amount_6_length_10_max_depth 100_amount_9_length_10_max_depth 1000_amount_1_length_1_max_depth 1000_amount_1_length_10_max_depth 1000_amount_3_length_10_max_depth 1000_amount_6_length_10_max_depth 1000_amount_9_length_10_max_depth 1000_amount_1_length_100_max_depth 1000_amount_25_length_100_max_depth 1000_amount_50_length_100_max_depth 1000_amount_75_length_100_max_depth 1000_amount_100_length_100_max_depth 10000_amount_1_length_1_max_depth 10000_amount_1_length_10_max_depth 10000_amount_3_length_10_max_depth 10000_amount_6_length_10_max_depth 10000_amount_9_length_10_max_depth 10000_amount_1_length_100_max_depth 10000_amount_25_length_100_max_depth 10000_amount_50_length_100_max_depth 10000_amount_75_length_100_max_depth 10000_amount_100_length_100_max_depth 10000_amount_1_length_1000_max_depth 10000_amount_250_length_1000_max_depth 10000_amount_500_length_1000_max_depth 10000_amount_750_length_1000_max_depth 10000_amount_1000_length_1000_max_depth</code> </pre> <br><h1 id="chast-3-rezultaty">  Parte 3. Resultados </h1><br><p>  Para perfilar la CPU, utilic茅 line_profiler <br>  Para graficar - timeit + matplotlib </p><br><h4 id="cpu-profayler">  CPU Profiler </h4><br><div class="spoiler">  <b class="spoiler_title">Conclusi贸n</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ kernprof -l funcs.py $ python -m line_profiler funcs.py.lprof Timer unit: 1e-06 s Total time: 1.7e-05 s File: funcs.py Function: outer_flatten_1 at line 11 Line # Hits Time Per Hit % Time Line Contents ============================================================== 11 @profile 12 def outer_flatten_1(array: Iterable) -&gt; List: 13 """ 14 Based on C realization of this solution 15 More on: 16 17 https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html 18 19 https://github.com/MSeifert04/iteration_utilities/blob/384948b4e82e41de47fa79fb73efc56c08549b01/src/deepflatten.c 20 """ 21 2 17.0 8.5 100.0 return deepflatten(array) Total time: 3.3e-05 s File: funcs.py Function: outer_flatten_2 at line 24 Line # Hits Time Per Hit % Time Line Contents ============================================================== 24 @profile 25 def outer_flatten_2(array: Iterable) -&gt; List: 26 """ 27 recursive algorithm, vaguely reminiscent of recursion_flatten. Based on next pattern: 28 29 .. code:: python 30 31 try: 32 tree = iter(node) 33 except TypeError: 34 yield node 35 36 more on: 37 https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.collapse 38 """ 39 2 33.0 16.5 100.0 return collapse(array) Total time: 0.105099 s File: funcs.py Function: niccolum_flatten at line 42 Line # Hits Time Per Hit % Time Line Contents ============================================================== 42 @profile 43 def niccolum_flatten(array: Iterable) -&gt; List: 44 """ 45 Non recursive algorithm 46 Based on pop/insert elements in current list 47 """ 48 49 2 39.0 19.5 0.0 new_array = array[:] 50 2 6.0 3.0 0.0 ind = 0 51 2 2.0 1.0 0.0 while True: 52 20002 7778.0 0.4 7.4 try: 53 21010 13528.0 0.6 12.9 while isinstance(new_array[ind], list): 54 1008 1520.0 1.5 1.4 item = new_array.pop(ind) 55 21014 13423.0 0.6 12.8 for inner_item in reversed(item): 56 20006 59375.0 3.0 56.5 new_array.insert(ind, inner_item) 57 20000 9423.0 0.5 9.0 ind += 1 58 2 2.0 1.0 0.0 except IndexError: 59 2 2.0 1.0 0.0 break 60 2 1.0 0.5 0.0 return new_array Total time: 0.137481 s File: funcs.py Function: tishka_flatten at line 63 Line # Hits Time Per Hit % Time Line Contents ============================================================== 63 @profile 64 def tishka_flatten(data: Iterable) -&gt; List: 65 """ 66 Non recursive algorithm 67 Based on append/extend elements to new list 68 69 """ 70 2 17.0 8.5 0.0 nested = True 71 1012 1044.0 1.0 0.8 while nested: 72 1010 1063.0 1.1 0.8 new = [] 73 1010 992.0 1.0 0.7 nested = False 74 112018 38090.0 0.3 27.7 for i in data: 75 111008 50247.0 0.5 36.5 if isinstance(i, list): 76 1008 1431.0 1.4 1.0 new.extend(i) 77 1008 1138.0 1.1 0.8 nested = True 78 else: 79 110000 42052.0 0.4 30.6 new.append(i) 80 1010 1406.0 1.4 1.0 data = new 81 2 1.0 0.5 0.0 return data Total time: 0.062931 s File: funcs.py Function: zart_flatten at line 84 Line # Hits Time Per Hit % Time Line Contents ============================================================== 84 @profile 85 def zart_flatten(a: Iterable) -&gt; List: 86 """ 87 Non recursive algorithm 88 Based on pop from old and append elements to new list 89 """ 90 2 20.0 10.0 0.0 queue, out = [a], [] 91 21012 12866.0 0.6 20.4 while queue: 92 21010 16849.0 0.8 26.8 elem = queue.pop(-1) 93 21010 17768.0 0.8 28.2 if isinstance(elem, list): 94 1010 1562.0 1.5 2.5 queue.extend(elem) 95 else: 96 20000 13813.0 0.7 21.9 out.append(elem) 97 2 53.0 26.5 0.1 return out[::-1] Total time: 0.052754 s File: funcs.py Function: recursive_flatten_generator at line 100 Line # Hits Time Per Hit % Time Line Contents ============================================================== 100 @profile 101 def recursive_flatten_generator(array: Iterable) -&gt; List: 102 """ 103 Recursive algorithm 104 Looks like recursive_flatten_iterator, but with extend/append 105 106 """ 107 1010 1569.0 1.6 3.0 lst = [] 108 22018 13565.0 0.6 25.7 for i in array: 109 21008 17060.0 0.8 32.3 if isinstance(i, list): 110 1008 6624.0 6.6 12.6 lst.extend(recursive_flatten_generator(i)) 111 else: 112 20000 13622.0 0.7 25.8 lst.append(i) 113 1010 314.0 0.3 0.6 return lst Total time: 0.054103 s File: funcs.py Function: recursive_flatten_iterator at line 116 Line # Hits Time Per Hit % Time Line Contents ============================================================== 116 @profile 117 def recursive_flatten_iterator(arr: Iterable) -&gt; Iterator: 118 """ 119 Recursive algorithm based on iterator 120 Usual solution to this problem 121 122 """ 123 124 22018 20200.0 0.9 37.3 for i in arr: 125 21008 19363.0 0.9 35.8 if isinstance(i, list): 126 1008 6856.0 6.8 12.7 yield from recursive_flatten_iterator(i) 127 else: 128 20000 7684.0 0.4 14.2 yield i Total time: 0.056111 s File: funcs.py Function: tishka_flatten_with_stack at line 131 Line # Hits Time Per Hit % Time Line Contents ============================================================== 131 @profile 132 def tishka_flatten_with_stack(seq: Iterable) -&gt; List: 133 """ 134 Non recursive algorithm 135 Based on zart_flatten, but build on try/except pattern 136 """ 137 2 24.0 12.0 0.0 stack = [iter(seq)] 138 2 5.0 2.5 0.0 new = [] 139 1012 357.0 0.4 0.6 while stack: 140 1010 435.0 0.4 0.8 i = stack.pop() 141 1010 328.0 0.3 0.6 try: 142 1010 330.0 0.3 0.6 while True: 143 22018 17272.0 0.8 30.8 data = next(i) 144 21008 18951.0 0.9 33.8 if isinstance(data, list): 145 1008 997.0 1.0 1.8 stack.append(i) 146 1008 1205.0 1.2 2.1 i = iter(data) 147 else: 148 20000 15413.0 0.8 27.5 new.append(data) 149 1010 425.0 0.4 0.8 except StopIteration: 150 1010 368.0 0.4 0.7 pass 151 2 1.0 0.5 0.0 return new</code> </pre> </div></div><br><h4 id="grafiki">  Gr谩ficos </h4><br><p>  Resultado general: </p><br><p><img src="https://habrastorage.org/webt/mv/hn/er/mvhner8sf4u_w9alvn647vudda0.png"></p><br><p>  Excluyendo las funciones m谩s lentas, obtenemos: </p><br><p><img src="https://habrastorage.org/webt/gs/nm/pg/gsnmpgozl3yv02xdzllnuqvlif0.png"></p><br><h1 id="chast-4-vyvody">  Parte 4. Conclusiones </h1><br><p>  Quiz谩s dir茅 lo obvio, pero, a pesar de la complejidad conocida de los algoritmos, el resultado puede no ser obvio.  Entonces, la funci贸n niccolum_flatten, cuya complejidad era la m谩s alta, entr贸 en la etapa final y se alej贸 del 煤ltimo lugar.  Y recursive_flatten_generator result贸 ser mucho m谩s r谩pido que recursive_flatten_iterator. </p><br><p>  En resumen, quiero decir en primer lugar que esto fue m谩s un estudio que una gu铆a para escribir algoritmos efectivos de desempaquetado de listas.  Por lo general, puede escribir la implementaci贸n m谩s simple sin pensar si es la m谩s r谩pida, porque  Peque帽os ahorros. </p><br><h3 id="poleznye-ssylki">  Enlaces utiles </h3><br><p>  Se pueden encontrar resultados m谩s completos <a href="">aqu铆.</a> <br>  Repositorio con c贸digo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu铆</a> <br>  Documentaci贸n v铆a esfinge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu铆</a> </p><br><p>  Si encuentra alg煤n error, escriba al telegrama de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Niccolum</a> o a lastsal@mail.ru. <br>  Estar茅 contento con la cr铆tica constructiva. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465531/">https://habr.com/ru/post/465531/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465521/index.html">Fly-fly-petal ... o una historia sobre c贸mo el dise帽ador de UX promocion贸 su producto en Instagram</a></li>
<li><a href="../465523/index.html">Otra serpiente de Android con Kivy, Python</a></li>
<li><a href="../465525/index.html">Informes m贸viles sobre Oracle BI EE 12c: uno, dos, tres. Metodolog铆a del curso CAD de Oracle BI EE 12c</a></li>
<li><a href="../465527/index.html">El largo viaje de RFC 4357 a RFC 8645 o c贸mo administrar las claves de cifrado</a></li>
<li><a href="../465529/index.html">Suspensi贸n sobre bloqueo</a></li>
<li><a href="../465535/index.html">Qui茅n implementa IPv6 y qu茅 dificulta su desarrollo</a></li>
<li><a href="../465537/index.html">Yandex: una casa inteligente para adultos</a></li>
<li><a href="../465539/index.html">766 km - un nuevo r茅cord de alcance para LoRaWAN</a></li>
<li><a href="../465541/index.html">De la empresa a la peque帽a y mediana empresa: compartimos nuestra experiencia en la adaptaci贸n de soluciones corporativas para peque帽as y medianas empresas con monetizaci贸n utilizando el modelo SaaS</a></li>
<li><a href="../465545/index.html">En diferentes lados del estado: c贸mo Facebook se fri贸 en el Congreso de los Estados Unidos, mientras Telegram luch贸 con el FSB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>