<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüöí üßùüèº üïï WBOIT en OpenGL: transparencia sin ordenar üëÇüèº üö£üèº üë©üèº‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hablaremos sobre "Transparencia combinada independiente del orden combinado" (en adelante WBOIT), la t√©cnica descrita en JCGT en 2013 ( enlace ). 

 C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WBOIT en OpenGL: transparencia sin ordenar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457284/">  Hablaremos sobre "Transparencia combinada independiente del orden combinado" (en adelante WBOIT), la t√©cnica descrita en JCGT en 2013 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> ). <br><a name="habracut"></a><br>  Cuando aparecen varios objetos transparentes en la pantalla, el color del p√≠xel depende de cu√°l est√© m√°s cerca del observador.  Aqu√≠ hay una f√≥rmula de mezcla de colores bien conocida para este caso: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;C_&amp;#xA0;{near}&amp;#xA0;\&amp;#xA0;alpha&amp;#xA0;+&amp;#xA0;C_&amp;#xA0;{far}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(1)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation"><span class="noError" style="display: inline-block;" aria-hidden="true">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \ begin {matrix} C = C_ {near} \ alpha + C_ {far} (1- \ alpha) && (1) \ end {matrix} </script></p><br>  El orden de la disposici√≥n de fragmentos es importante para √©l: el color del fragmento cercano y su opacidad se denotan como C <sub>cerca</sub> y <i>Œ±</i> , y el color resultante de todos los fragmentos que se encuentran detr√°s de √©l se denota como C <sub>lejos</sub> .  La opacidad es una propiedad que toma valores de 0 a 1, donde 0 significa que el objeto es tan transparente que no es visible y 1, que es tan opaco que no hay nada visible <i>detr√°s de √©l</i> . <br><br>  Para usar esta f√≥rmula, primero debe ordenar los fragmentos por profundidad.  ¬°Imagina cu√°nto dolor de cabeza implica esto!  En general, la clasificaci√≥n se debe hacer en cada cuadro.  Si est√° clasificando objetos, entonces algunos objetos de forma compleja tendr√°n que cortarse en pedazos y ordenarse por profundidad de las partes cortadas (en particular, para superficies de intersecci√≥n, esto definitivamente deber√° hacerse).  Si clasifica los fragmentos, la clasificaci√≥n se realizar√° en los sombreadores.  Este enfoque se denomina "Transparencia independiente del pedido" (OIT) y utiliza una lista vinculada almacenada en la memoria de la tarjeta de video.  Para predecir cu√°nta memoria tendr√° que asignarse para esta lista es casi irreal.  Y si no hay suficiente memoria, aparecer√°n artefactos en la pantalla. <br><br>  Afortunadamente para aquellos que pueden controlar cu√°ntos objetos transl√∫cidos se colocan en el escenario y d√≥nde est√°n relacionados entre s√≠.  Pero si hace CAD, tendr√° tantos objetos transparentes como desee el usuario, y se ubicar√°n al azar. <br><br>  Ahora comprende el deseo de algunas personas de simplificar sus vidas y encontrar una f√≥rmula para mezclar colores que no requiera clasificaci√≥n.  Tal f√≥rmula est√° en el art√≠culo al que me refer√≠ al principio.  Incluso hay varias f√≥rmulas all√≠, pero la mejor en opini√≥n de los autores (y en mi opini√≥n tambi√©n) es esta: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;{{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;C_i&amp;#xA0;\&amp;#xA0;alpha_i}&amp;#xA0;\&amp;#xA0;over&amp;#xA0;{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;\&amp;#xA0;alpha_i}}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i))&amp;#xA0;+&amp;#xA0;C_0&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(2)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matriz}</mtext></merror></math>" role="presentation"><span class="noError" style="display: inline-block;" aria-hidden="true">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matriz}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matriz}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> \ begin {matrix} C = {{\ sum_ {i = 1} ^ {n} C_i \ alpha_i} \ over {\ sum_ {i = 1} ^ {n} \ alpha_i}} (1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i)) + C_0 \ prod_ {i = 1} ^ {n} (1- \ alpha_i) && (2) \ end {matriz} </script></p><br><img src="https://habrastorage.org/webt/65/b9/oz/65b9ozbni1afvlupqfso9uve2ey.png" width="1000"><br><br>  En la captura de pantalla hay grupos de tri√°ngulos transl√∫cidos ubicados en cuatro capas de profundidad.  A la izquierda, se representan con la t√©cnica WBOIT.  A la derecha hay una imagen obtenida usando la f√≥rmula (1), combinaci√≥n cl√°sica de colores, teniendo en cuenta el orden de la disposici√≥n de los fragmentos.  A continuaci√≥n, lo llamar√© CODB (combinaci√≥n cl√°sica dependiente del orden). <br><br>  Antes de comenzar a renderizar objetos transparentes, debemos renderizar todos los opacos.  Despu√©s de eso, los objetos transparentes se representan con una prueba de profundidad, pero sin escribir en el b√∫fer de profundidad (esto se hace as√≠: <code>glEnable(GL_DEPTH_TEST); glDepthMask(GL_FALSE);</code> ).  Es decir, esto es lo que sucede en un punto con algunas coordenadas de pantalla (x, y): los fragmentos transparentes que est√°n m√°s cerca que los opacos pasan la prueba de profundidad, independientemente de c√≥mo est√©n ubicados en profundidad en relaci√≥n con los fragmentos transparentes ya dibujados y los fragmentos transparentes que aparecen m√°s lejos opaco, no pase la prueba de profundidad y, en consecuencia, se descartan. <br><br>  C <sub>0</sub> en la f√≥rmula (2) es el color de un fragmento opaco, sobre el cual se dibujan fragmentos transparentes, de los cuales tenemos n piezas, indicadas por los √≠ndices 1 a n.  C <sub>i</sub> es el color del i-√©simo fragmento transparente, <i>Œ± <sub>i</sub></i> es su opacidad. <br><br>  Si te fijas bien, entonces la f√≥rmula (2) es un poco como la f√≥rmula (1).  Si te imaginas eso <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  Est√° C <sub>cerca</sub> , C <sub>0</sub> est√° C <sub>lejos</sub> , y <img src="https://habrastorage.org/webt/li/tu/em/lituem-w98r3gl7cee5184y6b7q.png" width="100">  - esto es <i>Œ±</i> , entonces esta ser√° la primera f√≥rmula, uno a uno.  Y realmente <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  - este es el promedio ponderado de los colores de los fragmentos transparentes (el centro de masa se determina en la mec√°nica mediante la misma f√≥rmula), ser√° el color del fragmento C m√°s <sub>cercano</sub> .  C <sub>0</sub> es el color del fragmento opaco ubicado detr√°s de todos los fragmentos, para el cual calculamos este promedio ponderado, y pasar√° por C <sub>lejos</sub> .  Es decir, reemplazamos todos los fragmentos transparentes con un fragmento "promedio" y aplicamos la f√≥rmula est√°ndar para mezclar colores: la f√≥rmula (1).  ¬øCu√°l es esta astuta f√≥rmula para <i>Œ±</i> que nos ofrecen los autores del art√≠culo original? <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></msubsup><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="34.233ex" height="2.901ex" viewBox="0 -832 14738.9 1249" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-61" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-6C" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-70" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-68" x="1581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-61" x="2158" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMAIN-3D" x="2965" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMAIN-31" x="4021" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMAIN-2212" x="4744" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-70" x="5995" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-72" x="6498" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-6F" x="6950" y="0"></use><g transform="translate(7435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-64" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-6E" x="741" y="499"></use><g transform="translate(520,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMAIN-31" x="1124" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMAIN-28" x="9204" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMAIN-31" x="9594" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMAIN-2212" x="10316" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-61" x="11567" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-6C" x="12097" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-70" x="12395" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-68" x="12899" y="0"></use><g transform="translate(13475,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMATHI-69" x="748" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhC1TmH9PF8ev-ARbg3WjHeQqjHew#MJMAIN-29" x="14349" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msubsup><mo stretchy="false">(</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> \ alpha = 1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i) </script></p><br>  Esta es una funci√≥n escalar en el espacio n-dimensional, as√≠ que recordemos el an√°lisis diferencial de las funciones de varias variables.  Dado que todos los <i>Œ± <sub>i</sub></i> pertenecen al rango de 0 a 1, la derivada parcial con respecto a cualquiera de las variables siempre ser√° una constante no negativa.  Esto significa que la opacidad del fragmento "promedio" aumenta al aumentar la opacidad de cualquiera de los fragmentos transparentes, y esto es exactamente lo que necesitamos.  Adem√°s, aumenta linealmente. <br><br>  Si la opacidad de un fragmento es 0, entonces no es visible en absoluto, no afecta el color resultante. <br><br>  Si la opacidad de al menos un fragmento es 1, entonces <i>Œ±</i> es 1. Es decir, el fragmento opaco se vuelve invisible, lo que generalmente es bueno.  Solo los fragmentos transparentes ubicados detr√°s del fragmento con opacidad = 1 a√∫n brillan a trav√©s de √©l y afectan el color resultante: <br><br><img src="https://habrastorage.org/webt/3s/lm/3y/3slm3yxglf43xno7dyqu8g7ua-o.png" width="300"><br><br>  Aqu√≠, un tri√°ngulo naranja se encuentra arriba, verde debajo de √©l, y gris y cian debajo de verde, y todo esto contra un fondo negro.  Opacidad azul = 1, todos los dem√°s - 0.5.  La imagen de la derecha es lo que deber√≠a ser.  Como puede ver, WBOIT se ve asqueroso.  El √∫nico lugar donde aparece el color naranja normal es el borde del tri√°ngulo verde, rodeado por una l√≠nea blanca opaca.  Como acabo de decir, un fragmento opaco es invisible si la opacidad del fragmento transparente es 1. <br><br>  Esto se ve a√∫n mejor aqu√≠: <br><br><img src="https://habrastorage.org/webt/-3/dc/ey/-3dcey8p1s2ynmgq9oyatw1ojma.png" width="300"><br><br>  El tri√°ngulo naranja tiene una opacidad de 1, el verde con la transparencia desactivada simplemente se dibuja con los objetos opacos.  Parece que el tri√°ngulo VERDE brilla a trav√©s de NARANJA a trav√©s del tri√°ngulo naranja. <br><br>  Para que la imagen se vea decente, la forma m√°s f√°cil es no asignar objetos de alta opacidad.  En mi proyecto de trabajo, no permito establecer una opacidad mayor que 0.5.  Se trata de CAD en 3D, en el que los objetos se dibujan esquem√°ticamente y no se requiere un realismo especial, por lo que tal restricci√≥n est√° permitida all√≠. <br><br>  Con valores de opacidad bajos, las im√°genes de la izquierda y la derecha se ven casi iguales: <br><br><img src="https://habrastorage.org/webt/hz/pc/ud/hzpcud9vuojz7vk0rsofbidyumy.png" width="1000"><br><br>  Y con alto difieren notablemente: <br><br><img src="https://habrastorage.org/webt/iv/hq/_l/ivhq_lqrb8ofbxie323mtwpfg-q.png" width="1000"><br><br>  As√≠ es como se ve un poliedro transparente: <br><br><img src="https://habrastorage.org/webt/nm/oi/6u/nmoi6u1xvycmbwvt50z6pinofbg.png" width="500"><br><img src="https://habrastorage.org/webt/ej/9u/p1/ej9up1muignigkr73kn2mi5byrs.png" width="500"><br><br>  El poliedro tiene caras laterales naranjas y horizontales verdes.  Desafortunadamente, no entender√°s esto a primera vista, es decir  La imagen no parece convincente.  Donde hay una pared anaranjada al frente, necesita m√°s que naranja, y donde el verde es m√°s que verde.  Ser√° mucho mejor dibujar caras en un color: <br><br><img src="https://habrastorage.org/webt/a2/eg/bf/a2egbfdzwlwmaltuc4lpyna45gs.png" width="500"><br><br><h3>  WBOIT basado en profundidad </h3><br>  Para compensar de alguna manera la falta de clasificaci√≥n por profundidad, los autores del art√≠culo idearon varias opciones para agregar profundidad a la f√≥rmula (2).  Esto hace que la implementaci√≥n sea m√°s dif√≠cil y el resultado menos predecible y dependiente de las caracter√≠sticas de una escena tridimensional particular.  No profundic√© en este tema, as√≠ que a qui√©n le importa, propongo leer el art√≠culo. <br><br>  Se argumenta que WBOIT a veces es capaz de algo que la transparencia de clasificaci√≥n cl√°sica no puede.  Por ejemplo, dibuja humo como un sistema de part√≠culas usando solo dos part√≠culas, con humo oscuro y claro.  Cuando una part√≠cula pasa a trav√©s de otra, el color cl√°sico que se mezcla con la clasificaci√≥n da un resultado feo: el color del humo de la luz se vuelve muy oscuro.  El art√≠culo dice que WBOIT sensible a la profundidad permite una transici√≥n suave y se ve m√°s cre√≠ble.  Lo mismo puede decirse sobre el modelado de pieles y cabello en forma de tubos delgados. <br><br><h3>  C√≥digo </h3><br>  Ahora sobre c√≥mo implementar la f√≥rmula (2) en OpenGL.  El c√≥digo de ejemplo est√° en Github ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> ), y la mayor√≠a de las im√°genes en el art√≠culo son de all√≠.  Puedes coleccionar y jugar con mis tri√°ngulos.  Se utiliza el marco Qt. <br><br>  Para aquellos que reci√©n comienzan a estudiar la representaci√≥n de objetos transparentes, les recomiendo estos dos art√≠culos: <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aprender OpenGL.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lecci√≥n 4.3 - Mezclar colores</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Algoritmo de transparencia independiente del orden utilizando listas vinculadas en Direct3D 11 y OpenGL 4</a> <br><br>  El segundo, sin embargo, no es tan importante para comprender este material, pero el primero es una lectura obligada. <br><br>  Para calcular la f√≥rmula (2), necesitamos 2 framebuffers adicionales, 3 texturas multimuestra y un buffer de renderizado, en el que escribiremos la profundidad.  En la primera textura, colorTextureNT (NT significa no transparente), renderizaremos objetos opacos.  Tiene el tipo GL_RGB10_A2.  La segunda textura (colorTexture) ser√° del tipo GL_RGBA16F;  En los primeros 3 componentes de esta textura, escribiremos esta pieza de f√≥rmula (2): <img src="https://habrastorage.org/webt/9p/7i/vm/9p7ivmikwxs8ltenmceiumeogoo.png" width="70">  en el cuarto <img src="https://habrastorage.org/webt/i2/bg/uc/i2bguc_jhzovzvn6ybqfkkuds4q.png" width="50">  .  Otra textura del tipo GL_R16 (alphaTexture) contendr√° <img src="https://habrastorage.org/webt/ma/si/f0/masif074trzop-clpwvbwtfj92i.png" width="90">  . <br><br>  Primero debe crear estos objetos para obtener sus identificadores de OpenGL: <br><br><pre> <code class="cpp hljs"> f-&gt;glGenFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT ); f-&gt;glGenRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> <br>  Como dije, el marco Qt se usa aqu√≠, y todas las llamadas de OpenGL pasan por un objeto de tipo QOpenGLFunctions_4_5_Core, que siempre se denota como f para m√≠. <br><br>  Ahora debe asignar memoria: <br><br><pre> <code class="cpp hljs"> f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGB16F, w, h, GL_TRUE ); f-&gt;glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer); f-&gt;glRenderbufferStorageMultisample( GL_RENDERBUFFER, numOfSamples, GL_DEPTH_COMPONENT, w, h ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGBA16F, w, h, GL_TRUE ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_R16F, w, h, GL_TRUE );</code> </pre> <br>  Y configurar framebuffers: <br><br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer ); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D_MULTISAMPLE, alphaTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); GLenum attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1}; f-&gt;glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer );</code> </pre> <br>  En la segunda pasada de representaci√≥n, la salida del sombreador de fragmentos ir√° a dos texturas a la vez, y esto debe especificarse expl√≠citamente usando glDrawBuffers. <br><br>  La mayor parte de este c√≥digo se ejecuta una vez, al inicio del programa.  El c√≥digo que asigna memoria para texturas y buffers de renderizado se llama cada vez que se cambia el tama√±o de la ventana.  Luego viene el c√≥digo de representaci√≥n, que se llama cada vez que se vuelve a dibujar la ventana. <br><br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); <span class="hljs-comment"><span class="hljs-comment">// ...   ...</span></span></code> </pre> <br>  Simplemente dibujamos todos los objetos opacos en la textura colorTextureNT y escribimos las profundidades en el b√∫fer de renderizado.  Antes de usar el mismo renderbuffer en la siguiente etapa del dibujo, debe asegurarse de que todas las profundidades de los objetos opacos ya est√©n escritas all√≠.  Para esto, se utiliza GL_FRAMEBUFFER_BARRIER_BIT.  Despu√©s de representar objetos transparentes, llamamos a la funci√≥n ApplyTextures (), que iniciar√° la etapa final de representaci√≥n, en la que el sombreador de fragmentos leer√° los datos de las texturas colorTextureNT, colorTexture y alphaTexture para aplicar la f√≥rmula (2).  Las texturas deber√≠an haber sido completamente escritas para entonces, as√≠ que antes de llamar a ApplyTextures () usamos GL_TEXTURE_FETCH_BARRIER_BIT. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearColor[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearAlpha = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">0</span></span>, clearColor); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;clearAlpha); f-&gt;glMemoryBarrier(GL_FRAMEBUFFER_BARRIER_BIT); PrepareToTransparentRendering(); { <span class="hljs-comment"><span class="hljs-comment">// ...   ... } CleanupAfterTransparentRendering(); f-&gt;glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, defaultFBO); ApplyTextures();</span></span></code> </pre> <br>  defaultFBO es el framebuffer a trav√©s del cual mostramos la imagen.  En la mayor√≠a de los casos es 0, pero en Qt es QOpenGLWidget :: defaultFramebufferObject (). <br><br>  Cada vez que se llame al sombreador de fragmentos, tendremos informaci√≥n sobre el color y la opacidad del fragmento actual.  Pero a la salida en la textura colorTexture queremos obtener la suma (y en la textura alphaTexture el producto) de algunas funciones de estas cantidades.  La mezcla se usa para esto.  Adem√°s, dado que para la primera textura calculamos la suma, y ‚Äã‚Äãpara la segunda, el producto, la configuraci√≥n de fusi√≥n (glBlendFunc y glBlendEquation) para cada archivo adjunto debe establecerse por separado. <br><br>  Aqu√≠ est√° el contenido de la funci√≥n PrepareToTransparentRendering (): <br><br><pre> <code class="cpp hljs"> f-&gt;glEnable(GL_DEPTH_TEST); f-&gt;glDepthMask(GL_FALSE); f-&gt;glDepthFunc(GL_LEQUAL); f-&gt;glDisable(GL_CULL_FACE); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glEnable(GL_BLEND); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_ONE, GL_ONE); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_FUNC_ADD); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_DST_COLOR, GL_ZERO); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_FUNC_ADD);</code> </pre> <br>  Y el contenido de la funci√≥n CleanupAfterTransparentRendering (): <br><br><pre> <code class="cpp hljs"> f-&gt;glDepthMask(GL_TRUE); f-&gt;glDisable(GL_BLEND);</code> </pre> <br>  En mi sombreador de fragmentos, la opacidad se indica con la letra w.  El producto del color por w y w mismo lo sacamos a un par√°metro de salida, y 1 - w a otro.  Para cada par√°metro de salida, se establece un calificador de dise√±o en la forma "ubicaci√≥n = X", donde X es el √≠ndice del elemento en la matriz de archivos adjuntos, que pasamos a glDrawBuffers en la tercera lista (espec√≠ficamente, el par√°metro de salida con ubicaci√≥n = 0 se env√≠a a la textura vinculada a GL_COLOR_ATTACHMENT0 , y el par√°metro con ubicaci√≥n = 1 - en la textura adjunta a GL_COLOR_ATTACHMENT1).  Se utilizan los mismos n√∫meros en las funciones glBlendFunci y glBlendEquationi para indicar el n√∫mero de archivo adjunto para el que establecemos los par√°metros de fusi√≥n. <br><br>  Fragmento Shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core in vec3 color; layout (location = 0) out vec4 outData; layout (location = 1) out float alpha; layout (location = 2) uniform float w; void main() { outData = vec4(w * color, w); alpha = 1 - w; }</span></span></code> </pre> <br>  En la funci√≥n ApplyTextures (), simplemente dibujamos un rect√°ngulo sobre toda la ventana.  El sombreador de fragmentos solicita datos de todas las texturas que hemos creado, utilizando las coordenadas de pantalla actuales como coordenadas de textura y el n√∫mero de muestra actual (gl_SampleID) como el n√∫mero de muestra en la textura de m√∫ltiples muestras.  El uso de la variable gl_SampleID en el sombreador activa autom√°ticamente el modo cuando el sombreador de fragmentos se llama una vez para cada muestra (en condiciones normales, se llama una vez para el p√≠xel completo y el resultado se escribe en todas las muestras que estaban dentro de la primitiva). <br><br>  No hay nada notable en el sombreador de v√©rtices: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core const vec2 p[4] = vec2[4]( vec2(-1, -1), vec2( 1, -1), vec2( 1, 1), vec2(-1, 1) ); void main() { gl_Position = vec4(p[gl_VertexID], 0, 1); }</span></span></code> </pre> <br>  Fragmento Shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core out vec4 outColor; layout (location = 0) uniform sampler2DMS colorTextureNT; layout (location = 1) uniform sampler2DMS colorTexture; layout (location = 2) uniform sampler2DMS alphaTexture; void main() { ivec2 upos = ivec2(gl_FragCoord.xy); vec4 cc = texelFetch(colorTexture, upos, gl_SampleID); vec3 sumOfColors = cc.rgb; float sumOfWeights = cc.a; vec3 colorNT = texelFetch(colorTextureNT, upos, gl_SampleID).rgb; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (sumOfWeights == 0) { outColor = vec4(colorNT, 1.0); return; } float alpha = 1 - texelFetch(alphaTexture, upos, gl_SampleID).r; colorNT = sumOfColors / sumOfWeights * alpha + colorNT * (1 - alpha); outColor = vec4(colorNT, 1.0); }</span></span></code> </pre> <br>  Y finalmente, el contenido de la funci√≥n ApplyTextures (): <br><br><pre> <code class="cpp hljs"> f-&gt;glActiveTexture(GL_TEXTURE0); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); f-&gt;glActiveTexture(GL_TEXTURE1); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); f-&gt;glActiveTexture(GL_TEXTURE2); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glDisable(GL_DEPTH_TEST); f-&gt;glDrawArrays(GL_TRIANGLE_FAN, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Bueno, ser√≠a bueno liberar recursos de OpenGL despu√©s de que termine.  Tengo este c√≥digo llamado en el destructor de mi widget OpenGL: <br><br><pre> <code class="cpp hljs"> f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT); f-&gt;glDeleteRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457284/">https://habr.com/ru/post/457284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457262/index.html">An√°lisis de las calificaciones del campeonato de programaci√≥n entre desarrolladores de backend</a></li>
<li><a href="../457266/index.html">Crisis √°gil Que hacer</a></li>
<li><a href="../457270/index.html">Prisma-CMS como motor para crear MVP r√°pidamente</a></li>
<li><a href="../457276/index.html">Siete amenazas de bot para tu sitio</a></li>
<li><a href="../457282/index.html">"La muerte de Dios" o el colapso de las leyes generalmente aceptadas para construir equipos de TI y crear sistemas de TI en el siglo XXI</a></li>
<li><a href="../457286/index.html">La soluci√≥n de las tareas de WorldSkills del m√≥dulo de red en la competencia de "CCA". Parte 1 - Configuraci√≥n b√°sica</a></li>
<li><a href="../457288/index.html">Estaci√≥n de trabajo criptogr√°fica basada en tokens PKCS # 11. Firma electr√≥nica Parte 2</a></li>
<li><a href="../457290/index.html">Conferencia DEFCON 25. Garry Kasparov. "La √∫ltima batalla del cerebro". Parte 2</a></li>
<li><a href="../457292/index.html">WBOIT en OpenGL: transparencia sin ordenar</a></li>
<li><a href="../457294/index.html">"Live high" o mi historia desde la dilaci√≥n hasta el autodesarrollo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>