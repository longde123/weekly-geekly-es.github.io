<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵 🕙 ♈️ Arend - bahasa tipe dependen berbasis HoTT (bagian 2) 🤲 🚷 👨🏽‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bagian pertama artikel tentang bahasa Arend, kami memeriksa jenis induktif yang paling sederhana, fungsi rekursif, kelas dan set. 

 2. Menyortir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arend - bahasa tipe dependen berbasis HoTT (bagian 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/470632/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pada bagian pertama artikel</a> tentang bahasa Arend, kami memeriksa jenis induktif yang paling sederhana, fungsi rekursif, kelas dan set. <br><br><h2>  2. Menyortir Daftar di Arend </h2><br><h3>  2.1 Daftar Pesanan di Arend </h3><br>  Kami mendefinisikan jenis daftar yang dipesan sebagai pasangan yang terdiri dari daftar dan bukti pemesanannya.  Seperti yang telah kami katakan, dalam Arend, pasangan tergantung didefinisikan menggunakan kata kunci <code>\Sigma</code> .  Kami memberikan definisi dari jenis yang <code>Sorted</code> melalui perbandingan dengan sampel, terinspirasi oleh definisi dari artikel yang telah disebutkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang daftar dipesan.</a> <br><br><pre> <code class="plaintext hljs">\func SortedList (O : LinearOrder.Dec) =&gt; \Sigma (l : List O) (Sorted l) \data Sorted {A : LinearOrder.Dec} (xs : List A) \elim xs | nil =&gt; nilSorted | :-: x nil =&gt; singletonSorted | :-: x1 (:-: x2 xs) =&gt; consSorted ((x1 = x2) || (x1 &lt; x2)) (Sorted (x2 :-: xs))</code> </pre> <br>  Catatan: Arend dapat secara otomatis menyimpulkan bahwa tipe <code>Sorted</code> terkandung dalam <code>\Prop</code> universe.  Ini terjadi karena ketiga pola dalam definisi <code>Sorted</code> adalah saling eksklusif, dan konstruktor yang <code>consSorted</code> memiliki dua parameter, yang keduanya milik <code>\Prop</code> . <br>  Mari kita buktikan beberapa properti yang jelas dari predikat <code>Sorted</code> , katakan bahwa ekor dari daftar yang diurutkan itu sendiri adalah daftar yang dipesan (properti ini akan berguna bagi kita di masa depan). <br><a name="habracut"></a><br><pre> <code class="plaintext hljs">\func tail-sorted {O : LinearOrder.Dec} (x : O) (xs : List O) (A : Sorted (x :-: xs)) : Sorted xs \elim xs, A | nil, _ =&gt; nilSorted | :-: _ _, consSorted _ xs-sorted =&gt; xs-sorted</code> </pre> <br>  Dalam <code>tail-sorted</code> kami menggunakan pencocokan pola pada daftar <code>xs</code> dan predikat <code>Sorted</code> pada saat yang sama, di samping itu, kami menggunakan <i>karakter lewati</i> “_”, yang dapat diganti dengan variabel yang tidak digunakan. <br><br>  Orang mungkin bertanya apakah mungkin dalam Arend untuk membuktikan properti dari daftar yang dipesan, yang disebutkan dalam bagian 1.3 sebagai contoh dari fakta yang tidak dapat dibuktikan di Agda tanpa anotasi immaterialitas.  Ingatlah bahwa properti ini mengklaim bahwa untuk membuktikan kesetaraan dari daftar yang dipesan yang ditentukan melalui pasangan terikat, cukup untuk memeriksa kesetaraan komponen pertama dari pasangan tersebut. <br><br>  Dikatakan bahwa dalam Arend properti ini mudah diperoleh sebagai konsekuensi dari konstruksi <code>inProp</code> disebutkan di atas dan properti ekstensionalitas untuk pasangan <code>SigmaExt</code> bergantung. <br><br><pre> <code class="plaintext hljs">\func sorted-equality {A : LinearOrder.Dec} (l1 l2 : SortedList A) (P : l1.1 = l2.1) : l1 = l2 =&gt; SigmaPropExt Sorted l1 l2 P</code> </pre> <br>  Properti <code>SigmaPropExt</code> terbukti dalam modul <a href="">Paths</a> dari perpustakaan standar, dan banyak fakta lain dari bab kedua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku HoTT</a> , termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">properti ekstensionalitas fungsional</a> , juga terbukti di sana. <br><br>  Operator <code>.n</code> digunakan di Arend untuk mengakses proyektor tipe sigma dengan angka n (dalam kasus kami, tipe sigma adalah <code>SortedList A</code> , dan ekspresi <code>l1.1</code> berarti komponen pertama dari tipe ini adalah ekspresi dari tipe <code>List A</code> ). <br><br><h3>  2.2 Implementasi properti "menjadi permutasi" </h3><br>  Sekarang mari kita coba menerapkan fungsi pengurutan daftar di Arend.  Secara alami, kami ingin memiliki bukan implementasi sederhana dari algoritma pengurutan, tetapi implementasi bersama dengan bukti dari beberapa properti. <br><br>  Jelas, algoritma ini harus memiliki setidaknya 2 properti: <br>  1. Hasil algoritma harus berupa daftar yang diurutkan. <br>  2. Daftar yang dihasilkan harus permutasi dari daftar asli. <br><br>  Pertama, mari kita coba menerapkan properti "menjadi permutasi" dari daftar di Arend.  Untuk melakukan ini, kami menyesuaikan definisi yang diambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> untuk Arend. <br><br><pre> <code class="plaintext hljs">\truncated \data InsertSpec {A : \Set} (xs : List A) (a : A) (ys : List A) : \Prop \elim xs, ys | xs, :-: y ys =&gt; insertedHere (a = y) (xs = ys) | :-: x xs, :-: y ys =&gt; insertedThere (x = y) (InsertSpec xs a ys) \truncated \data Perm {A : \Set} (xs ys : List A) : \Prop | permInsert (xs' ys' : List A) (a : A) (Perm xs' ys') (InsertSpec xs' a xs) (InsertSpec ys' a ys) | permTrivial (xs = ys)</code> </pre> <br>  Predikat <code>InsertSpec</code> diperkenalkan oleh kami memiliki arti intuisi berikut: <code>InsertSpec xs a ys</code> persis berarti bahwa daftar <code>ys</code> adalah hasil dari memasukkan elemen a di dalam daftar <code>xs</code> (di posisi mana pun).  Dengan demikian, <code>InsertSpec</code> dapat diambil sebagai spesifikasi dari fungsi insert. <br><br>  Jelas bahwa tipe data <code>Perm</code> benar-benar mendefinisikan hubungan "menjadi permutasi": konstruktor <code>permInsert</code> tepat bahwa <code>xs</code> dan <code>ys</code> dapat diijinkan bersama jika <code>xs</code> dan <code>ys</code> diperoleh dengan memasukkan elemen yang sama ke dalam beberapa daftar <code>xs'</code> dan <code>ys'</code> Panjang lebih pendek, yang sudah permutasi satu sama lain. <br><br>  Untuk definisi kami tentang properti "menjadi permutasi", mudah untuk memverifikasi properti simetri. <br><br><pre> <code class="plaintext hljs">\func Perm-symmetric {A : \Set} {xs ys : List A} (P : Perm xs ys) : Perm ys xs \elim P | permTrivial xs=ys =&gt; permTrivial (inv xs=ys) | permInsert perm-xs'-ys' xs-spec ys-spec =&gt; permInsert (Perm-symmetric perm-xs'-ys') ys-spec xs-spec</code> </pre> <br>  Properti transitivitas juga puas untuk <code>Perm</code> , tetapi verifikasi jauh lebih rumit.  Karena properti ini tidak memainkan peran apa pun dalam penerapan algoritme penyortiran kami, kami serahkan pada pembaca sebagai latihan. <br><br><pre> <code class="plaintext hljs">\func Perm-transitive {A : \Set} (xs ys zs : List A) (P1 : Perm xs ys) (P2 : Perm ys zs) : Perm xs zs =&gt; {?}</code> </pre> <br><h3>  2.3 Perubahan tingkat homotopy jika dibandingkan dengan sampel </h3><br>  Sekarang mari kita coba mengimplementasikan fungsi yang memasukkan elemen ke dalam daftar yang diurutkan sehingga daftar yang dihasilkan tetap terurut.  Mari kita mulai dengan implementasi naif berikut. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : List O) (y : O) : List O \elim xs | nil =&gt; y :-: nil | :-: x xs' =&gt; \case LinearOrder.trichotomy xy \with {  | byLeft x=y =&gt; x :-: insert xs' y  | byRight (byLeft x&lt;y) =&gt; x :-: insert xs' y  | byRight (byRight y&lt;x) =&gt; y :-: x :-: xs' }</code> </pre> <br>  Konstruk <code>\case</code> memungkinkan pencocokan dengan sampel ekspresi arbitrer ( <code>\elim</code> dapat hanya digunakan pada level tertinggi dari definisi fungsi dan hanya untuk parameternya).  Jika Anda meminta Arend untuk memeriksa jenis <code>insert</code> , pesan kesalahan berikut akan ditampilkan. <br><br><pre> <code class="plaintext hljs">[ERROR] Data type '||' is truncated to the universe \Prop  which does not fit in the universe of the eliminator type: List OE In: | byLeft x-leq-y =&gt; x :-: insert xs' y While processing: insert</code> </pre> <br>  Masalahnya adalah bahwa di kelas <code>LinearOrder.Dec</code> definisi <code>trichotomy</code> diberikan menggunakan operator <code>||</code>  , yang, pada gilirannya, ditentukan menggunakan pemotongan proposisional.  Seperti yang telah disebutkan, untuk tipe yang dimiliki alam semesta <code>\Prop</code> , pencocokan dengan pola di Arend hanya diperbolehkan jika tipe ekspresi yang dihasilkan itu sendiri merupakan pernyataan (untuk fungsi di atas, hasilnya adalah tipe <code>List OE</code> , dan tipe ini adalah himpunan). <br><br>  Apakah ada cara untuk mengatasi masalah ini?  Cara termudah untuk menyelesaikan ini adalah mengubah definisi properti trikotomi.  Pertimbangkan definisi trikotomi berikut, dengan menggunakan tipe yang tidak terpotong <code>Or</code> alih-alih <code>||</code> terpotong  : <br><br><pre> <code class="plaintext hljs">\func set-trichotomy {A : StrictPoset} (xy : A) =&gt; ((x = y) `Or` (x &lt; y)) `Or` (y &lt; x)</code> </pre> <br>  Apakah definisi ini <code>trichotomy</code> dalam hal apa pun dari definisi <code>trichotomy</code> asli melalui <code>||</code>  ?  Mengapa kita bahkan menggunakan tipe terpotong proposisi jika hanya mempersulit hidup kita dan mencegah kita menggunakan pencocokan pola? <br><br>  Mari kita coba menjawab pertanyaan pertama sebagai permulaan: untuk pesanan <code>StrictPoset</code> ketat <code>StrictPoset</code> perbedaan antara <code>trichotomy</code> dan <code>set-trichotomy</code> sebenarnya tidak sama sekali.  Perhatikan bahwa jenis <code>set-trichotomy</code> adalah pernyataan.  Fakta ini mengikuti dari fakta bahwa ketiga alternatif dalam definisi trikotomi adalah saling eksklusif karena aksioma keteraturan, dan masing-masing dari ketiga jenis <code>x = y, x &lt; y, y &lt; x</code> sendiri merupakan pernyataan ( <code>x = y</code> adalah pernyataan, jadi seperti dalam definisi kelas <code>BaseSet</code> kami menuntut agar media <code>E</code> ditetapkan!). <br><br><pre> <code class="plaintext hljs">\func set-trichotomy-isProp {A : StrictPoset} (xy : A) (l1 l2 : set-trichotomy xy): l1 = l2 \elim l1, l2 | inl (inl l1), inl (inl l2) =&gt; pmap (\lam z =&gt; inl (inl z)) (Path.inProp l1 l2) | inl (inr l1), inl (inr l2) =&gt; pmap (\lam z =&gt; inl (inr z)) (Path.inProp l1 l2) | inr l1, inr l2 =&gt; pmap inr (Path.inProp l1 l2) | inl (inl l1), inl (inr l2) =&gt; absurd (lt-eq-false l1 l2) | inl (inr l1), inl (inl l2) =&gt; absurd (lt-eq-false l2 l1) | inl (inl l1), inr l2 =&gt; absurd (lt-eq-false (inv l1) l2) | inr l1, inl (inl l2) =&gt; absurd (lt-eq-false (inv l2) l1) | inl (inr l1), inr l2 =&gt; absurd (lt-lt-false l1 l2) | inr l1, inl (inr l2) =&gt; absurd (lt-lt-false l2 l1) \where {  \func lt-eq-false {A : StrictPoset} {xy : A} (l1 : x = y) (l2 : x &lt; y) : Empty =&gt;    A.&lt;-irreflexive x (transport (x &lt;) (inv l1) l2)  \func lt-lt-false {A : StrictPoset} {xy : A} (l1 : x &lt; y) (l2 : y &lt; x) : Empty =&gt;   A.&lt;-irreflexive x (A.&lt;-transitive _ _ _ l1 l2) }</code> </pre> <br>  Dalam daftar di atas, <code>absurd</code> adalah sebutan untuk prinsip ex falso quodlibet, yang didefinisikan dalam modul <a href="">Logic</a> .  Karena tipe <code>Empty</code> tidak memiliki konstruktor dalam definisi (lihat bagian 1.2), tidak perlu melalui kasus dalam definisi <code>absurd</code> : <br><br><pre> <code class="plaintext hljs">\func absurd {A : \Type} (x : Empty) : A</code> </pre> <br>  Karena kita sekarang tahu bahwa <code>set-trichotomy</code> adalah sebuah pernyataan, kita dapat memperoleh properti <code>set-trichotomy</code> dari properti <code>trichotomy</code> biasa dari pesanan yang dapat ditentukan.  Untuk melakukan ini, kita dapat menggunakan konstruksi <code>\return \level</code> , yang memberitahu timer Arend bahwa pada titik ini, pencocokan dengan pola adalah operasi yang diizinkan (dalam hal ini, kita harus menunjukkan bukti bahwa hasil dari fungsi <code>set-trichotomy-property</code> adalah pernyataan). <br><br><pre> <code class="plaintext hljs">\func set-trichotomy-property {A : LinearOrder.Dec} (xy : A) : set-trichotomy xy =&gt; \case A.trichotomy xy \return \level (set-trichotomy xy) (set-trichotomy-isProp xy) \with {  | byLeft x=y =&gt; inl (inl x=y)  | byRight (byLeft x&lt;y) =&gt; inl (inr x&lt;y)  | byRight (byRight y&lt;x) =&gt; inr (y&lt;x) }</code> </pre> <br>  Mari kita coba menjawab pertanyaan kedua, yaitu, mengapa, ketika merumuskan sifat-sifat objek matematika, lebih disukai menggunakan konstruksi yang tidak biasa, tetapi secara proposisi terpotong.  Pertimbangkan untuk ini sebuah fragmen dari definisi perintah linear non-linear (definisi lengkap <code>Lattice</code> dan <code>TotalOrder</code> dapat ditemukan dalam modul <a href="">LinearOrder</a> ): <br><br><pre> <code class="plaintext hljs">\class TotalOrder \extends Lattice { | totality (xy : E) : x &lt;= y || y &lt;= x }</code> </pre> <br>  Mari kita coba bayangkan sekarang bagaimana arti dari kelas <code>TotalOrder</code> akan berubah jika kita menulis definisi bidang totalitas melalui konstruksi yang tidak terpotong <code>Or</code> konstruksi. <br><br><pre> <code class="plaintext hljs">\class BadTotalOrder \extends Lattice { | badTotality (xy : E) : (x &lt;= y) `Or` (y &lt;= x) }</code> </pre> <br>  Dalam hal ini, tipe <code>(x &lt;= y) `Or` (y &lt;= x)</code> tidak lagi merupakan pernyataan, karena  dalam hal nilai <code>x</code> dan <code>y</code> sama <code>y</code> kedua alternatif dalam definisi <code>badTotality</code> dapat diimplementasikan, dan pilihan cabang kiri atau kanan dalam bukti <code>badTotality</code> benar-benar sewenang-wenang dan tetap pada kebijaksanaan pengguna - tidak ada alasan untuk memilih satu <code>Or</code> konstruktor ke yang lain. <br><br>  Sekarang sudah jelas apa perbedaan antara <code>TotalOrder</code> dan <code>BadTotalOrder</code> .  Dua set yang dipesan <code>O1 O2</code> : <code>TotalOrder</code> selalu sama ketika dimungkinkan untuk membuktikan kesetaraan set <code>O1.E, O2.E</code> dan perintah <code>O1.&lt;, O2.&lt;</code> Diberikan pada mereka (ini adalah properti yang diinginkan).  Di sisi lain, untuk <code>O1 O2</code> : <code>BadTotalOrder</code> untuk membuktikan kesetaraan <code>O1</code> dan <code>O2</code> hanya ketika, selain semua elemen <code>x</code> dari <code>E</code> persamaan <code>O1.badTotality xx</code> dan <code>O2.badTotality xx</code> . <br><br>  Dengan demikian, ternyata kelas <code>BadTotalOrder</code> secara intuitif perlu dipertimbangkan bukan sebagai "himpunan <code>BadTotalOrder</code> linear", tetapi sebagai "himpunan <code>BadTotalOrder</code> linier bersama dengan pilihan untuk setiap elemen <code>x</code> bidang <code>E</code> cabang <code>E</code> cabang kiri atau kanan <code>Or</code> dalam implementasi <code>badTotality xx</code> ". <br><br><h3>  2.4 Sortir Algoritma </h3><br>  Kami sekarang melanjutkan untuk menerapkan algoritma pengurutan.  Mari kita coba untuk memperbaiki implementasi naif dari fungsi <code>insert</code> dari bagian sebelumnya menggunakan properti <code>set-trichotomy-property</code> terbukti (dalam hal ini, karena pengaturan kurung yang lebih sukses dalam definisi <code>set-trichotomy</code> , kami telah mengurangi jumlah kasus yang dipertimbangkan). <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : List O) (y : O) : List O \elim xs | nil =&gt; y :-: nil | :-: x xs' =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; y :-: x :-: xs'  | inl x&lt;=y =&gt; x :-: insert xs' y }</code> </pre> <br>  Sekarang mari kita coba mengimplementasikan analog dari definisi ini untuk daftar yang diurutkan.  Kami akan menggunakan konstruksi khusus <code>\let … \in</code> , yang memungkinkan kami untuk menambahkan variabel lokal baru ke konteksnya. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : SortedList O \elim xs | (nil, _) =&gt; (y :-: nil, singletonSorted) | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; (y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted)  | inl x&lt;=y =&gt; \let (result, result-sorted) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y         \in (x :-: result, {?})</code> </pre> <br>  Kami meninggalkan di bukti fragmen tidak lengkap (ditunjukkan oleh ekspresi <code>{?}</code> ) Di tempat Anda ingin menunjukkan bahwa daftar <code>x :-: result</code> dipesan.  Meskipun dalam konteks terdapat bukti urutan daftar <code>result</code> , tetap bagi kami untuk memverifikasi bahwa <code>x</code> tidak melebihi nilai elemen pertama dari daftar <code>result</code> , yang tidak begitu mudah untuk diikuti dari tempat dalam konteks (untuk melihat semua tempat dalam target saat ini - inilah yang kami sebut cabang perhitungan sekarang - Anda perlu meminta pemeriksaan jenis dari fungsi <code>insert</code> ). <br><br>  Ternyata <code>insert</code> jauh lebih mudah diimplementasikan jika kita membuktikan urutan daftar yang dihasilkan secara paralel dengan bukti spesifikasi <code>insert</code> .  Ubah tanda tangan <code>insert</code> dan tulis bukti spesifikasi ini dalam kasus paling sederhana: <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : \Sigma (ys : SortedList O) (InsertSpec xs.1 y ys.1) \elim xs | (nil, _) =&gt; ((y :-: nil, singletonSorted), insertedHere idp idp) | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; ((y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted), insertedHere idp idp)  | inl x&lt;=y =&gt;   \let ((result, result-sorted), result-spec) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y   \in ((x :-: result, {?}), insertedThere idp result-spec)</code> </pre> <br>  Untuk satu fragmen yang dibiarkan tanpa bukti, Arend akan menampilkan nilai konteks berikut: <br><br><pre> <code class="plaintext hljs">Expected type: Sorted (x :-: (insert (\this, tail-sorted x \this \this) \this).1.1) Context:  result-sorted : Sorted (insert (\this, tail-sorted \this \this \this) \this).1.1  xs-sorted : Sorted (x :-: xs')  x : O  x&lt;=y : Or (x = y) (O.&lt; xy)  O : Dec  result : List O  y : O  xs' : List O  result-spec : InsertSpec xs' y (insert (xs', tail-sorted \this xs' \this) y).1.1</code> </pre> <br>  Untuk melengkapi buktinya, kita harus menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kekuatan penuh dari</a> operator <code>\case</code> : kita akan menggunakan pencocokan pola dengan 5 variabel berbeda, dan karena tipe-tipe dari beberapa variabel mungkin bergantung pada nilai-nilai variabel lain, kita akan menggunakan pencocokan pola dependen. <br><br>  Konstruksi usus besar secara eksplisit menunjukkan bagaimana jenis beberapa variabel yang dibandingkan tergantung pada nilai-nilai variabel lain (dengan demikian, dalam jenis variabel <code>xs-sorted, result-spec</code> dan <code>result-sorted</code> dalam setiap <code>\case</code> bukan <code>xs'</code> dan <code>result</code> akan cocok dengan sampel yang sesuai). <br><br>  Konstruk <code>\return</code> mengaitkan variabel yang digunakan untuk mencocokkan pola dengan jenis hasil yang diharapkan.  Dengan kata lain, dalam target saat ini, dalam setiap <code>\case</code> klausa, sampel yang sesuai akan diganti untuk variabel <code>result</code> .  Tanpa konstruksi ini, penggantian seperti itu tidak akan dilakukan, dan tujuan dari semua klausa <code>\case</code> akan bertepatan dengan target menggantikan ekspresi <code>\case</code> itu sendiri. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : \Sigma (ys : SortedList O) (InsertSpec xs.1 y ys.1) \elim xs  | (nil, _) =&gt; ((y :-: nil, singletonSorted), insertedHere idp idp)  | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {   | inr y&lt;x =&gt; ((y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted), insertedHere idp idp)   | inl x&lt;=y =&gt;     \let ((result, result-sorted), result-spec) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y     \in ((x :-: result,       \case result \as result, xs' \as xs', xs-sorted : Sorted (x :-: xs'), result-spec : InsertSpec xs' y result, result-sorted : Sorted result       \return Sorted (x :-: result) \with {        | nil, _, _, _, _ =&gt; singletonSorted        | :-: r rs, _, _, insertedHere y=r _, result-sorted =&gt; consSorted (transport (\lam z =&gt; (x = z) || (x &lt; z)) y=r (Or-to-|| x&lt;=y)) result-sorted        | :-: r rs, :-: x' _, consSorted x&lt;=x' _, insertedThere x2=r _, result-sorted =&gt; consSorted (transport (\lam z =&gt; (x = z) || (x &lt; z)) x2=r x&lt;=x') result-sorted }), insertedThere idp result-spec)</code> </pre> <br>  Dalam blok kode di atas, argumen kompleks pertama dari konstruktor yang <code>consSorted</code> dalam dua paragraf terakhir dari perbandingan pola layak mendapatkan komentar tambahan.  Untuk memahami apa arti kedua ekspresi ini, kami menggantinya dengan ekspresi <code>{?}</code> Dan meminta timer Arend untuk menentukan target di kedua posisi. <br><br>  Anda dapat melihat bahwa di sana dan di sana target saat ini adalah tipe <code>(x = r) || O.&lt; xr</code>  <code>(x = r) || O.&lt; xr</code> .  Selain itu, dalam konteks tujuan pertama, ada premis <br><br><pre> <code class="plaintext hljs">x&lt;=y : Or (x = y) (O.&lt; xy) y=r : y = r</code> </pre> <br>  dan dalam konteks premis kedua <br><br><pre> <code class="plaintext hljs">x&lt;=x' : (x = x') || O.&lt; xx' x2=r : x' = r.</code> </pre> <br>  Secara intuitif jelas: untuk membuktikan tujuan pertama, cukup untuk mengganti variabel <code>r</code> ke dalam pernyataan yang benar <code>Or (x = y) (O.&lt; xy)</code> , dan kemudian beralih ke tipe terpotong proposisi <code>||</code>  menggunakan fungsi <code>Or-to-||</code> didefinisikan dalam Bagian 1.3  .  Untuk membuktikan tujuan kedua, cukup gantikan <code>(x = x') || O.&lt; x x'</code>  <code>(x = x') || O.&lt; x x'</code> bukan variabel <code>x'</code> variabel <code>r</code> . <br><br>  Untuk memformalkan operasi substitusi ekspresi yang dijelaskan, fungsi <code>transport</code> khusus ada di perpustakaan Arend standar.  Pertimbangkan tanda tangannya: <br><br><pre> <code class="plaintext hljs">\func transport {A : \Type} (B : A -&gt; \Type) {aa' : A} (p : a = a') (b : B a) : B a'</code> </pre> <br>  Dalam kasus kami, alih-alih variabel <code>A</code> kita perlu mengganti tipe <code>OE</code> (dapat dihilangkan secara eksplisit jika argumen <code>transport</code> lainnya ditentukan), dan alih-alih <code>B</code> ekspresi <code>\lam (z : O) =&gt; (x = z) || (x &lt; z)</code>  <code>\lam (z : O) =&gt; (x = z) || (x &lt; z)</code> . <br><br>  Implementasi algoritma penyisipan penyisipan bersama dengan spesifikasi tidak lagi menyebabkan kesulitan khusus: untuk menyortir daftar <code>x :-: xs'</code> , pertama-tama kita menyortir ujung daftar <code>xs'</code> menggunakan panggilan rekursif untuk <code>insertSort</code> , dan kemudian memasukkan elemen <code>x</code> di dalam daftar ini sambil menjaga pesanan untuk membantu akses ke fungsi <code>insert</code> sudah diterapkan. <br><br><pre> <code class="plaintext hljs">\func insertSort {O : LinearOrder.Dec} (xs : List O) : \Sigma (result : SortedList O) (Perm xs result.1) \elim xs | nil =&gt; ((nil, nilSorted), permTrivial idp) | :-: x xs' =&gt; \let | (ys, perm-xs'-ys) =&gt; insertSort xs'                      | (zs, zs-spec) =&gt; insert ys x                  \in (zs, permInsert perm-xs'-ys (insertedHere idp idp) zs-spec)</code> </pre> <br>  Kami memenuhi tujuan awal dan menerapkan pengurutan daftar di Arend.  Seluruh kode Arend yang diberikan dalam paragraf ini dapat diunduh dalam satu file <a href="">dari sini</a> . <br><br>  Orang mungkin bertanya bagaimana kita harus mengubah implementasi dari fungsi <code>insert</code> jika alih- <code>LinearOrder.Dec</code> perintah <code>LinearOrder.Dec</code> ketat kita menggunakan perintah <code>LinearOrder.Dec</code> yang tidak ketat?  Seperti yang kita ingat, dalam definisi fungsi totalitas, penggunaan operasi terpotong <code>||</code>  cukup signifikan, yaitu definisi ini tidak setara dengan definisi di mana alih-alih <code>||</code>  digunakan oleh <code>Or</code> . <br><br>  Jawaban untuk pertanyaan ini adalah sebagai berikut: masih dimungkinkan untuk membuat analog <code>insert</code> untuk <code>TotalOrder</code> , namun, untuk ini kita harus membuktikan bahwa jenis fungsi <code>insert</code> adalah pernyataan (ini akan memungkinkan kita dalam definisi <code>insert</code> untuk membuat perbandingan dengan sampel sesuai dengan <code>totality xy</code> pernyataan). <br><br>  Dengan kata lain, kita harus membuktikan bahwa hanya ada satu daftar terurut hingga kesetaraan, yang merupakan hasil dari memasukkan elemen <code>y</code> ke dalam daftar berurutan <code>xs</code> .  Sangat mudah untuk melihat bahwa ini adalah fakta yang benar, tetapi bukti formalnya tidak lagi sepele.  Kami meninggalkan verifikasi fakta ini sebagai latihan untuk pembaca yang tertarik. <br><br><h2>  3. Pengamatan penutup </h2><br>  Dalam pengantar ini, kami berkenalan dengan konstruksi utama bahasa Arend, dan juga belajar bagaimana menggunakan mekanisme kelas.  Kami berhasil menerapkan algoritma paling sederhana beserta bukti spesifikasinya.  Jadi, kami telah menunjukkan bahwa Arend cukup cocok untuk menyelesaikan masalah "sehari-hari", seperti, misalnya, verifikasi program. <br><br>  Kami telah menyebutkan jauh dari semua fitur dan fitur Arend.  Sebagai contoh, kami hampir tidak mengatakan apa pun tentang <i>tipe dengan kondisi</i> yang memungkinkan Anda untuk "merekatkan" berbagai konstruktor tipe dengan beberapa nilai parameter khusus untuk konstruktor ini.  Misalnya, implementasi tipe integer di Arend diberikan menggunakan tipe dengan ketentuan sebagai berikut: <br><br><pre> <code class="plaintext hljs">\data Int | pos Nat | neg Nat \with { zero =&gt; pos zero }</code> </pre> <br>  Definisi ini mengatakan bahwa bilangan bulat terdiri dari dua salinan dari tipe bilangan alami, di mana nol "positif" dan "negatif" diidentifikasi.  Definisi seperti itu jauh lebih nyaman daripada definisi dari perpustakaan Coq standar, di mana "salinan negatif" dari bilangan asli harus "digeser oleh satu" sehingga salinan ini tidak berpotongan (itu jauh lebih nyaman ketika <code>neg 1</code> notasi berarti angka -1, tidak -2) . <br><br>  Kami tidak mengatakan apa-apa tentang algoritma untuk memperoleh tingkat predikatif dan homotopi di kelas dan instance mereka.  Kami juga hampir tidak menyebutkan jenis interval <code>I</code> , meskipun memainkan peran kunci dalam teori jenis dengan interval, yang merupakan dasar logis dari Arend.  Untuk memahami betapa pentingnya jenis ini, cukup untuk menyebutkan bahwa dalam jenis Arend, kesetaraan didefinisikan melalui konsep interval.     ,   ,     ,           (..    ). <br><br>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> HoTT   </a>  JetBrains Research. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470632/">https://habr.com/ru/post/id470632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470616/index.html">Solusi baru untuk paradoks Fermi (mengapa kita sendirian di alam semesta)</a></li>
<li><a href="../id470618/index.html">Pemodelan tematik berita menggunakan analisis faktor</a></li>
<li><a href="../id470620/index.html">Infrastruktur sebagai Kode: Cara Mengatasi Masalah dengan XP</a></li>
<li><a href="../id470622/index.html">Tinjauan Umum Metode Pemilihan Fitur</a></li>
<li><a href="../id470628/index.html">Pembuatan kapal simulator ruang angkasa</a></li>
<li><a href="../id470634/index.html">Identifikasi lintas komunitas di Instagram untuk mengidentifikasi minat pengguna</a></li>
<li><a href="../id470638/index.html">Metode kuasi-Newtonian, atau ketika ada terlalu banyak turunan kedua untuk Athos</a></li>
<li><a href="../id470640/index.html">Sizing Elasticsearch</a></li>
<li><a href="../id470642/index.html">Temui Yandex.Station Mini. Kisah besar perangkat kecil</a></li>
<li><a href="../id470644/index.html">Mengapa blog korporat terkadang suram: beberapa pengamatan dan tips</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>