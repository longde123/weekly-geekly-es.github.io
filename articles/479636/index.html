<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙉 🧜 ™️ Propia pila de navegación. ¿Mejor que ROS? 👸🏻 👜 🚍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este es el segundo artículo del equipo de configuración sobre nuestra experiencia en la creación de robots autónomos para las competiciones Eurobot Op...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Propia pila de navegación. ¿Mejor que ROS?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479636/">  Este es el segundo artículo del equipo de configuración sobre nuestra experiencia en la creación de robots autónomos para las competiciones Eurobot Open y el uso de ROS para esto. <br><br>  <a href="https://habr.com/ru/post/478836/">El primer artículo trata sobre la mecánica y la arquitectura general de los robots.</a> <br><br>  Los robots viajan en un campo plano y la mayoría de los obstáculos se conocen de antemano, sin embargo, los oponentes insidiosos pueden intentar robar nuestros recursos (y a veces queremos comer un par de docenas de puntos extra), mientras que queremos conducir al punto deseado lo más rápido posible y no tocar los obstáculos.  De una cámara externa en el campo, obtenemos datos sobre la posición del enemigo y sabemos dónde está ahora.  Sin embargo, no es suficiente conocer su posición: debe poder utilizar esta información. <br><br>  Hoy intentaremos conducir desde el punto A al punto B sin haber recorrido la cola de un gato que se ha quedado dormido en el campo.  En particular, explicaremos cómo construimos una ruta y controlamos la velocidad del robot, y explicaremos cómo iniciar todo en nuestra computadora. <br><br><img src="https://habrastorage.org/webt/om/x0/a6/omx0a6wfefbht9c1pialld-9vqy.png"><br><a name="habracut"></a><br><h3>  Tratando de salir con un poco de sangre </h3><br>  Al resolver este problema, puede llevar material preparado por escrito por profesionales, entonces no habrá tormento e invención de la próxima "bicicleta".  Usamos una plataforma con ruedas omnidireccionales, por lo que, aunque hubo un intento de utilizar una cepilladora local ya preparada de ROS, por varias razones, encontraron que esto no era prometedor.  A continuación puede ver la cantidad de material que necesita el diseñador de un planeador estándar: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @class TrajectoryPlanner * @brief Computes control velocities for a robot given a costmap, a plan, and the robot's position in the world. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrajectoryPlanner</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrajectoryPlannerTest</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//Need this for gtest to work public: /** * @brief Constructs a trajectory controller * @param world_model The WorldModel the trajectory controller uses to check for collisions * @param costmap A reference to the Costmap the controller should use * @param footprint_spec A polygon representing the footprint of the robot. (Must be convex) * @param inscribed_radius The radius of the inscribed circle of the robot * @param circumscribed_radius The radius of the circumscribed circle of the robot * @param acc_lim_x The acceleration limit of the robot in the x direction * @param acc_lim_y The acceleration limit of the robot in the y direction * @param acc_lim_theta The acceleration limit of the robot in the theta direction * @param sim_time The number of seconds to "roll-out" each trajectory * @param sim_granularity The distance between simulation points should be small enough that the robot doesn't hit things * @param vx_samples The number of trajectories to sample in the x dimension * @param vtheta_samples The number of trajectories to sample in the theta dimension * @param pdist_scale A scaling factor for how close the robot should stay to the path * @param gdist_scale A scaling factor for how aggresively the robot should pursue a local goal * @param occdist_scale A scaling factor for how much the robot should prefer to stay away from obstacles * @param heading_lookahead How far the robot should look ahead of itself when differentiating between different rotational velocities * @param oscillation_reset_dist The distance the robot must travel before it can explore rotational velocities that were unsuccessful in the past * @param escape_reset_dist The distance the robot must travel before it can exit escape mode * @param escape_reset_theta The distance the robot must rotate before it can exit escape mode * @param holonomic_robot Set this to true if the robot being controlled can take y velocities and false otherwise * @param max_vel_x The maximum x velocity the controller will explore * @param min_vel_x The minimum x velocity the controller will explore * @param max_vel_th The maximum rotational velocity the controller will explore * @param min_vel_th The minimum rotational velocity the controller will explore * @param min_in_place_vel_th The absolute value of the minimum in-place rotational velocity the controller will explore * @param backup_vel The velocity to use while backing up * @param dwa Set this to true to use the Dynamic Window Approach, false to use acceleration limits * @param heading_scoring Set this to true to score trajectories based on the robot's heading after 1 timestep * @param heading_scoring_timestep How far to look ahead in time when we score heading based trajectories * @param meter_scoring adapt parameters to costmap resolution * @param simple_attractor Set this to true to allow simple attraction to a goal point instead of intelligent cost propagation * @param y_vels A vector of the y velocities the controller will explore * @param angular_sim_granularity The distance between simulation points for angular velocity should be small enough that the robot doesn't hit things */ TrajectoryPlanner(WorldModel&amp; world_model, const costmap_2d::Costmap2D&amp; costmap, std::vector&lt;geometry_msgs::Point&gt; footprint_spec, double acc_lim_x = 1.0, double acc_lim_y = 1.0, double acc_lim_theta = 1.0, double sim_time = 1.0, double sim_granularity = 0.025, int vx_samples = 20, int vtheta_samples = 20, double pdist_scale = 0.6, double gdist_scale = 0.8, double occdist_scale = 0.2, double heading_lookahead = 0.325, double oscillation_reset_dist = 0.05, double escape_reset_dist = 0.10, double escape_reset_theta = M_PI_2, bool holonomic_robot = true, double max_vel_x = 0.5, double min_vel_x = 0.1, double max_vel_th = 1.0, double min_vel_th = -1.0, double min_in_place_vel_th = 0.4, double backup_vel = -0.1, bool dwa = false, bool heading_scoring = false, double heading_scoring_timestep = 0.1, bool meter_scoring = true, bool simple_attractor = false, std::vector&lt;double&gt; y_vels = std::vector&lt;double&gt;(0), double stop_time_buffer = 0.2, double sim_period = 0.1, double angular_sim_granularity = 0.025);</span></span></code> </pre> <br>  <i>Este es un ejemplo de inicialización de parámetros para regular velocidades y la trayectoria como un todo.</i> <br><br>  Parámetros importantes para un cálculo completo: <br><br><ol><li>  Parámetro world_model. </li><li>  Parámetro de mapa de costos: un enlace a un mapa que contiene obstáculos, así como su "extensión virtual", teniendo en cuenta la posible colisión. </li></ol><br>  De las ventajas de la pila estándar, puede resaltar la disponibilidad de documentación y la capacidad de encontrar información en los foros.  <a href="https://github.com/ros-planning/navigation" rel="nofollow">Puedes leer más en el sitio web oficial con documentación</a> <br><br>  Es importante mencionar que los paquetes ROS se escribieron para plataformas de dos ruedas y bajo Omni se optimizaron al aumentar el ángulo de rotación disponible cuando se mueve hasta 360 grados, lo que sin duda es una muleta. <br><br>  Después de analizar el proyecto, nos dimos cuenta de que habría dificultades para estudiar y complementar, así como también hay muchos chips pesados ​​que no necesitamos.  Parece, déjelos ser, pero usamos Odroid xu4 (el procesador del cual todavía estaba en Samsung s5), y los resultados de rendimiento fueron deprimentes, y el espacio para algo más potente (y la frambuesa 4 y el procesador jetson nano fuman nerviosamente en comparación con con él) no.  Tuve que abandonar la pila estándar e intentar crear nosotros mismos el planificador global, el planificador local y el regulador de trayectoria <br><br><img src="https://habrastorage.org/webt/ij/qe/es/ijqeesrak1vuhjqfr1ij6exr4_a.jpeg"><br><br><h3>  Planificador global, planificador local, regulador de trayectoria y todo todo </h3><br>  Se necesitan planeadores globales y locales para obtener indicaciones para llegar al destino.  ¿Por qué es necesaria la separación?  ¿Por qué no puedes tomar <a href="https://ru.wikipedia.org/wiki/A*" rel="nofollow">A *</a> y montarlo?  Como regla general, el planificador global, al construir una ruta, puede usar el mapa completo en su trabajo, por lo que el algoritmo debe ser lo más rápido posible, quizás incluso con algunas simplificaciones.  Para suavizar estas simplificaciones, también utilizan el planificador local, que, basándose en el resultado del planificador global (o simplemente en un área limitada alrededor del robot), trata de tener en cuenta todos los matices. <br><br>  Después de construir la ruta, sabemos a dónde debe ir el robot, pero ¿cómo se le puede informar al respecto?  Para hacer esto, hay un regulador de trayectoria.  Calcula a qué velocidad y en qué dirección debe moverse el robot en ese momento para no desviarse de la trayectoria.  En muchos sentidos, este paquete es responsable de lo rápido y hermoso que irá el robot. <br><br>  Además de estas tres entidades, hay un cuarto, un servidor de mapas, que le permite procesar convenientemente el estado del mundo.  Establece cómo describimos el mapa, qué posibilidades tenemos cuando trabajamos con el mapa y, de muchas maneras, determinamos la velocidad de los planeadores. <br><br>  Antes de continuar con la descripción de la pila de navegación, sería bueno describir las razones por las que se eligió cost_map como servidor de mapas.  En general, probamos diferentes opciones para el controlador de mapas: <a href="https://github.com/IntelRealSense/realsense-ros/tree/occupancy-mapping" rel="nofollow">Occupancy_grid</a> , <a href="http://wiki.ros.org/grid_map" rel="nofollow">Grid_map</a> , <a href="https://github.com/stonier/cost_map" rel="nofollow">Cost_map</a> , pero <a href="https://github.com/stonier/cost_map" rel="nofollow">decidimos</a> por el último. <br><br>  Razones: <br><br><ol><li>  Convenientemente interactuar con el mapa. </li><li>  Hay varios iteradores que necesitamos en varias formas (circular, lineal, rectangular, etc.). </li><li>  Puede almacenar múltiples capas de mapa con diferentes parámetros. </li><li>  Buena gestión de la memoria. </li><li>  Y lo más importante, la velocidad.  El mapa de cuadrícula funciona con doble tipo y, debido a esto, es varias veces más lento que los servidores de mapas que usan int8 para trabajar. </li></ol><br>  A pesar de que la cuadrícula de ocupación también funciona con int8, no puede presumir de la misma usabilidad, por lo que tuve que abandonarla. <br><br>  Desde el mapa, necesitamos saber dónde están las zonas libres, peligrosas e irresistibles.  Para cada objeto que está en el campo, podemos ajustar el campo de inflación, un valor que, dependiendo de la distancia al objeto, caracteriza la permeabilidad de la celda.  La inflación es la cola del gato, es fácil no notarlo, pero luego te arrepentirás durante mucho tiempo.  Mapeamos robots enemigos y agregamos una zona de peligro que solo el planificador local tiene en cuenta.  El planificador global ignora todos los puntos, si no son un obstáculo. <br><br><h4>  Planificador global </h4><br>  Lo primero que escribieron en navegación es el planificador global.  Se basa en el algoritmo theta *.  En resumen, esta es una <a href="https://ru.wikipedia.org/wiki/A*" rel="nofollow">A *</a> modificada, donde el énfasis está en encontrar el nodo padre, al que se puede llegar directamente, es decir.  No hay obstáculos para ella.  Esto nos permite construir caminos convenientes y suaves que se utilizan en el planificador local. <br><br><img src="https://habrastorage.org/webt/it/qs/e4/itqse4uuumbbzu8rxws07gapbn8.png"><br>  <i>Comparación de A * y theta *</i> <br><br>  Para el planificador global, tenemos un archivo con parámetros (params / path_planner.yaml) que describe los temas del mapa y los temas con la ubicación de todos los robots (para los cuatro robots en el campo, donde "nulo" es el tema con datos sobre el robot actual). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># small robot debug param list robot_id: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"small"</span></span></span><span class="hljs-meta"> ########################### # cost_map_server params ## ########################### cost_map_server/big_robot_size: 0.45 cost_map_server/little_robot_size: 0.45 cost_map_server/cube_size: 0.11 cost_map_server/inscribed_radius: 0.3 cost_map_server/inflation_radius: 0.3 cost_map_server/inflation_exponential_rate: 0.6 cost_map_server/big_robot1: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/big_robot"</span></span></span><span class="hljs-meta"> cost_map_server/big_robot2: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/enemy_robot1"</span></span></span><span class="hljs-meta"> cost_map_server/small_robot1: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"null"</span></span></span><span class="hljs-meta"> cost_map_server/small_robot2: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/enemy_robot2"</span></span></span><span class="hljs-meta"> cost_map_server/collision: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"collision"</span></span></span><span class="hljs-meta"> cost_map_server/image_resource_name: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"$(find cost_map_server)/param/image_resource.yaml"</span></span></span><span class="hljs-meta"> cost_map_server/min_diff_points: 0.01 ########################### ### path_planner params ### ########################### global_planner/path_layer: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"inflation_layer"</span></span></span><span class="hljs-meta"> global_planner/path_force_layer: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"obstacle_inflation_layer"</span></span></span><span class="hljs-meta"> global_planner/frame_id: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"map"</span></span></span><span class="hljs-meta"> global_planner/current_position: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"real_corr"</span></span></span><span class="hljs-meta"> global_planner/path_filter_epsilon: 0</span></span></code> </pre> <br>  También indica: <br><br><ol><li>  uno de los algoritmos que puedes elegir para construir una ruta, </li><li>  nombres de capas en las que construiremos la ruta en sí, </li><li>  un tema sobre nuestra posición, donde se emiten los datos filtrados (en nuestro caso es una combinación de datos de ubicación de la cámara y la odometría). </li></ol><br>  El algoritmo de búsqueda de ruta en sí mismo, Theta Star, se resalta en un archivo separado (src / global_planner.cpp) para la conveniencia de agregar nuevos algoritmos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cost_so_far[<span class="hljs-number"><span class="hljs-number">300</span></span>][<span class="hljs-number"><span class="hljs-number">200</span></span>]; PriorityPoint neighbors[<span class="hljs-number"><span class="hljs-number">8</span></span>]; PriorityPoint current; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> come_from[<span class="hljs-number"><span class="hljs-number">300</span></span>][<span class="hljs-number"><span class="hljs-number">200</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePath_ThetaStar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;cost_map::Index&gt; &amp;path, PriorityPoint start, PriorityPoint goal, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> layer, cost_map::CostMap &amp;cost_map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> grid_cost, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> only_cost)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::priority_queue&lt;PriorityPoint, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;PriorityPoint&gt;, myCompare&gt; openSet; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_x = cost_map.getSize()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_y = cost_map.getSize()[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::fill_n(*cost_so_far, max_x * max_y, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max()); cost_so_far[start.x][start.y] = <span class="hljs-number"><span class="hljs-number">0</span></span>; come_from[start.x][start.y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = start.x; come_from[start.x][start.y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = start.y; openSet.push(start); grid_cost=<span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!openSet.empty()) { current = openSet.top(); openSet.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == goal) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } current.GetNeighbors(neighbors); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> current_cost = cost_so_far[current.x][current.y]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parent_carent[<span class="hljs-number"><span class="hljs-number">2</span></span>] ={come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">0</span></span>], come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">1</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbors[i].OnMap(max_x, max_y)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> onLine = lineOfSight(parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>], parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>], neighbors[i].x, neighbors[i].y, cost_map, layer, grid_cost + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (onLine) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> new_cost = cost_so_far[parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>]][parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>]] + HeuristicEvclid(parent_carent, neighbors[i], grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y]) { cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost; neighbors[i].priority = HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>) + new_cost; openSet.push(neighbors[i]); come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>]; come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> neighbor_price = cost_map.at(layer, cost_map::Index({neighbors[i].x, neighbors[i].y})) + neighbors[i].priority; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> new_cost = current_cost + neighbor_price; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y]) { cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost; neighbors[i].priority =HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>) + new_cost; openSet.push(neighbors[i]); come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = current.x; come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = current.y; } } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (only_cost) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cost_so_far[current.x][current.y]; } path.clear(); PriorityPoint temp_point; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != start) { path.push_back({current.x, current.y}); temp_point.x = come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">0</span></span>]; temp_point.y = come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">1</span></span>]; current = temp_point; } path.push_back({current.x, current.y}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Un algoritmo para eliminar puntos adicionales en la ruta RamerDouglasPeucker también se asigna a un archivo separado. <br>  Elimina puntos del camino si está más allá de una distancia dada de la línea que conecta dos puntos vecinos. <br><br><img src="https://habrastorage.org/webt/en/_9/dw/en_9dw6khdarxbyf7gvrhpqg7b4.jpeg"><br><br><h4>  Planificador local </h4><br>  Él trabaja para nosotros sobre la base del descenso de gradiente en un campo potencial.  Como entrada, el camino desde el planificador global.  Sin embargo, esto no es todo de lo que es capaz.  En local_planner, hay servicios internos para elegir el modo de construcción de ruta.  Hay dos modos de funcionamiento en total: el modo de desplazamiento de puntos a lo largo del gradiente, utilizando múltiples pases en el mapa, así como el modo de desplazamiento, en el que calculamos inmediatamente el incremento en dos coordenadas y movemos el punto al borde de la zona segura.  Si el punto cae en varias de esas zonas, entonces cambiamos a los lugares de su intersección, porque allí es más seguro. <br><br>  El modo de operación es el siguiente: si no hay ningún obstáculo en el camino desde la iteración anterior, entonces rompemos el camino cada 2 cm y luego lo desplazamos a lo largo del gradiente; de ​​lo contrario, usamos el segundo modo de operación del planificador local. <br><br>  La segunda opción es bastante ligera y, como el planificador global, no carga mucho el procesador.  Utilizamos varias versiones de este algoritmo y varias manipulaciones con el mapa.  Por ejemplo, intentamos escribir un gráfico en el que los vértices se encuentran cada 10 cm y se desplazan por un máximo de 4 cm, después de lo cual se utilizó el algoritmo de Dijkstra en el gráfico obtenido para encontrar la distancia más pequeña.  El punto final en este caso usa el punto de desplazamiento más cercano.  Pero dicho algoritmo era más adecuado para el planificador global y decidimos abandonar esta implementación. <br><br>  También intentamos usar la construcción de caminos desde cero usando el método de descenso de gradiente.  Este método fue el primero que decidimos escribir.  Resultó no ser eficiente en memoria (ocupaba más de 400 mb de RAM pura, ya que usaba un mapa de costos con cada pasada) y lento.  El control de frecuencia se apagó debido a una optimización deficiente y la velocidad era inferior a 30 veces por segundo, lo que no nos convenía. <br><br>  Como resultado, decidimos usar el descenso de gradiente en un campo potencial basado en el camino del planeador global.  Resultó ser un algoritmo liviano y relativamente simple, que nos conviene completamente en términos de calidad de ruta, tiempo de trabajo y la cantidad de RAM utilizada en la región de 100-150 mb, que es varias veces menor que en las primeras iteraciones de desarrollo. <br><br><img src="https://habrastorage.org/webt/sg/oq/mo/sgoqmogivjs8elhylt74oqjqrdw.png"><br>  <i>Un ejemplo de una ruta desplazada por un cepillo local</i> <br><br>  A diferencia de global_planner, los parámetros en local_planner son extremadamente pequeños, lo que se debe a su simplicidad, porque todas las tareas más importantes recaen en global_planner: <br><br><pre> <code class="cpp hljs">grid_map_server/big_robot1 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/big_robot2 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/small_robot1 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/small_robot2 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> local_planner/radius : <span class="hljs-number"><span class="hljs-number">0.15</span></span> global_planner/frame_id : <span class="hljs-string"><span class="hljs-string">"map"</span></span></code> </pre> <br>  En este caso, configuramos: <br><br><ul><li>  Radios de zonas seguras para cada uno de los robots. </li><li>  Recorrido máximo de desplazamiento por cepillo local. </li><li>  El nombre de la capa de mapa con la que estamos trabajando. </li></ul><br>  En una clase separada se asignaron todas las funciones más importantes.  En este caso, es un desglose recursivo del camino, la creación de un planeador y constructores y destructores virtuales. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Planner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Planner(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> inflation_radius_, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> frame_id_) { inflation_radius = inflation_radius_; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">200</span></span>; j++) our_map[i][j] = <span class="hljs-number"><span class="hljs-number">3000.0</span></span>; } OurPath-&gt;poses.resize(<span class="hljs-number"><span class="hljs-number">50</span></span>); geometry_msgs::Pose pose; pose.position.x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; pose.position.y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>; i++) { OurPath-&gt;poses[i].pose = pose; } frame_id = frame_id_; } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Planner() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdatePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; ros::Publisher move_pub; ros::Publisher BigEnemyPub; ros::Publisher LittleEnemyPub; ros::Publisher local_path_publisher; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-comment"><span class="hljs-comment">// virtual double Calculate_Path_Len(); nav_msgs::Path* recursive_path(nav_msgs::Path *path, std::pair&lt;double, double&gt; start, std::pair&lt;double, double&gt; end, double epsilon, int &amp;index) { if (CalcDistance(start, end) &lt; (epsilon) || path-&gt;poses.size() &gt; 200) return path; double start_x = (start.first + end.first) / 2.0; double start_y = (start.second + end.second) / 2.0; index = find_out(path, start); geometry_msgs::PoseStamped pose; pose.pose.position.x = start_x; pose.pose.position.y = start_y; path-&gt;poses.insert(path-&gt;poses.begin() + index, pose); recursive_path(path, start, std::pair&lt;double, double&gt;{start_x, start_y}, epsilon, index); recursive_path(path, std::pair&lt;double, double&gt;{start_x, start_y}, end, epsilon, index); } int find_out(nav_msgs::Path *path, pair_double point) { int index = 0; for (int i = 0; i &lt; path-&gt;poses.size(); i++) if (path-&gt;poses[i].pose.position.x == point.first &amp;&amp; path-&gt;poses[i].pose.position.y == point.second) return ++i; return index; } void add_in_path(nav_msgs::Path* Path, geometry_msgs::PoseStamped pose, int&amp; Index) { Path-&gt;poses[Index % max_size] = pose; Index++; } double inflation_radius; double our_map[300][200]; int max_size = 49; std::string frame_id; nav_msgs::Path *path = new nav_msgs::Path; nav_msgs::Path *OurPath = new nav_msgs::Path; };</span></span></code> </pre> <br>  La clase LocalPlanning se heredó de ella, donde se encuentra todo el núcleo del planeador, es decir, desplazando puntos al borde de la zona segura y decidiendo qué hacer específicamente con la ruta. <br><br>  Todas las demás funciones se resaltan en un archivo separado fichi.hpp, y el descenso de gradiente en potencial_campo.hpp.  A continuación se muestra una instantánea de este archivo, que muestra las funciones para crear un campo potencial en el mapa cost_map: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcAttractivePotential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(grid_map::Index index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goalx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goaly)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(index[<span class="hljs-number"><span class="hljs-number">0</span></span>] - goalx, <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(index[<span class="hljs-number"><span class="hljs-number">1</span></span>] - goaly, <span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcPotential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> starty, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goalx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goaly, cost_map::CostMap &amp;cost_map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (&amp;our_map)[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">300</span></span></span></span><span class="hljs-function"><span class="hljs-params">][</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">200</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Use some magic for normalisation of Field double max_distance = (CalcAttractivePotential(grid_map::Index(startx, starty), goalx, goaly) + 15); if (max_distance == 0.0) { max_distance = 0.01; } for (cost_map::CircleIterator iterator(cost_map, grid_map::Position(startx / 100.0, starty / 100.0), max_distance / 100.); !iterator.isPastEnd(); ++iterator) { try { grid_map::Index index(*iterator); double uf; uf = cost_map.at("obstacle_inflation_layer", *iterator); // if we on free podouble - field is more less then if it not free podouble if ( uf &gt;= 10) { uf = 3000.0; // CP - is const variable } else uf += CalcAttractivePotential(index, goalx, goaly)/max_distance * 256; our_map[299-index(0)][199-index(1)] = uf; } catch(std::exception&amp; e) { ROS_INFO("Exception! %s", e.what() ); } } }</span></span></code> </pre> <br><h4>  Regulador de trayectoria </h4><br>  Por último, pero no menos importante, es el regulador de trayectoria.  Es responsable de convertir la ruta del planificador local en una ruta y proporciona la velocidad para el paso actual. <br><br>  Su primera versión, que utilizamos en la final de Eurobot 2018, es una mezcla del controlador pid de aceleración y frenado, donde el vector se normaliza al siguiente punto en el camino, en relación con la distancia al punto final. <br><br>  En resumen, el controlador PID es la suma de los tres estados del sistema que ayudan a corregir el sistema y los errores aleatorios que a veces ocurren. <br><br>  Estas funciones se seleccionaron empíricamente y dependen de la distancia al punto final de la ruta (puede ser cuadrática, cúbica, inversa, pero luego nos decidimos por la cuadrática).  Esto funcionó, pero lo único que no nos convenía era que el robot no podía frenar a tiempo a velocidades superiores a 0,7 metros por segundo.  Por lo tanto, cuando llegó el momento, decidimos reconstruir todo el algoritmo. <br><br>  La primera iteración en el camino hacia la nueva trayectoria fue el reemplazo del vector al que íbamos.  Ahora era la suma de los vectores para los próximos tres con diferentes coeficientes.  La segunda iteración fue la escritura mínima jerk.  En resumen, esta es una construcción de un polinomio de quinto grado, donde las coordenadas x e y dependen del tiempo de llegada a cada punto. <br><br><img src="https://habrastorage.org/webt/ho/mw/hd/homwhdagbnkgdlrigettcc6yook.png"><br>  <i>La figura muestra un gráfico de una de las coordenadas en función del tiempo, así como la velocidad a lo largo de esta coordenada.</i> <br><br>  Este tipo de regulador de trayectoria nos convenía más, ya que requería menos manipulación con la selección de diferentes coeficientes, porque todos los coeficientes son los valores en el polinomio, que se calcularon en función del tiempo de llegada, la velocidad y aceleración actuales, la velocidad de salida y la aceleración. <br><br>  El resultado de la reescritura de la trayectoria fue que logramos duplicar la velocidad promedio del robot. <br><br>  Como en los dos casos anteriores, todas las funciones principales se asignan en un archivo separado para facilitar la interacción.  Esta vez, la clase PlannerTrajectory es responsable de construir una trayectoria basada en MinimumJerk <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> velocity; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> acceleration; State(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> v_, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a_) : velocity(v_), acceleration(a_) {} State() { velocity = <span class="hljs-number"><span class="hljs-number">0</span></span>; acceleration = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlannerTrajectory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: nav_msgs::Path global_path; cost_map::CostMap *costmap_ptr; geometry_msgs::PoseStamped Goal_pred; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; trajectory_x; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; trajectory_y; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> average_velocity = <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Defualt or get from param // double max_velocity = 100; double coef_x[6]; double coef_y[6]; int frequency = 30; // Defualt or get from param // int index; public: PlannerTrajectory(cost_map::CostMap *costmap_, const int &amp;frequency_, const double &amp;max_velocity_, const double &amp;average_velocity_) { average_velocity = average_velocity;; max_velocity = max_velocity_; costmap_ptr = costmap_; frequency = frequency_; Goal_pred.pose.position.x = 0.0; Goal_pred.pose.position.y = 0.0; }</span></span></code> </pre> <br>  <i>La foto muestra todas las variables declaradas que utilizamos.</i> <br><br>  Todo lo demás se resalta en otro archivo (include / trajectory_regulator.h): recibir puntos de temas, decidir si pasar al siguiente punto (si está en un obstáculo, entonces no vamos) y mucho más. <br><br><h3>  Migrando a ROS Melodic </h3><br>  Hasta el año pasado, utilizamos el lanzamiento lte de ROS - ROS Kinetic.  Generalmente nos conviene, pero su apoyo está llegando a su fin el próximo año, y muchos de los paquetes que necesitamos comenzaron a salir exclusivamente para ROS Melodic.  Y luego resultó que el costmap_server que utilizamos no está bajo Melodic. <br><br>  Hubo un problema al procesar los datos de las tarjetas. <br><br>  Elegimos el mapa de cuadrícula, ya que la pila es similar, pero el comienzo del mapa está en un lugar diferente, y los valores del mapa en sí varían de 0 a 1. Esto se ha convertido en un gran problema en toda la pila de navegación.  Si antes el planificador global se lanzaba 50 veces por segundo (había restricciones de frecuencia y, por lo tanto, el procesador no se usaba demasiado, incluso en la mitad de un hilo), ahora allanó el camino cada dos segundos y lo consideró malo: cargó completamente un núcleo.  En 2 segundos, el robot podría cruzar todo el mapa.  Esto no nos convenía, y los intentos de paralelizar este proceso terminaron en un fracaso, porque entonces no quedaba rendimiento para otros proyectos (teniendo en cuenta los costos de la paralelización). <br><br>  Decidimos cambiar la pila nuevamente, abandonar el mapa de cuadrícula a favor de la cuadrícula de ocupación.  Ha aparecido un nuevo problema: la incapacidad de almacenar varias versiones de mapas al mismo tiempo (por ejemplo, un mapa completo con todos los obstáculos y un mapa estático con solo obstáculos dinámicos).  Tendría que cambiar la mitad del código, que no era particularmente confiable.  Por lo tanto, decidimos buscar soluciones alternativas a este problema. <br><br><h4>  Servidor de mapas de costos </h4><br>  Después de una larga búsqueda, encontramos mapas de horquillas costmap_serverr: <a href="" rel="nofollow">https://github.com/lelongg/cost_map.git</a> , extremadamente útiles para nuestro sistema de horquillas. <br><br><img src="https://habrastorage.org/webt/27/rb/oh/27rbohj3kefxprwtjqrg4mwtqjc.png"><br><br>  Y ahora, en lugar de dar servicio solo al mapa de cuadrícula, para la entrega, logramos calcular la ubicación probable del enemigo en función de la predicción del filtro de Kalman. <br><br><img src="https://habrastorage.org/webt/ni/pm/nz/nipmnzvhcrqdje1cu8glf9quude.png"><br><br>  Una de las cosas más importantes para un servidor de mapas es un archivo de mapa, que se utiliza para la creación inicial de todas las capas, que posteriormente solo se actualizan.  Es una imagen binaria png, donde el negro es un obstáculo y el blanco es una zona libre. <br><br><img src="https://habrastorage.org/webt/2b/l5/rg/2bl5rgpuecb7he51heslqpvcazm.png"><br><br>  También hay un archivo de configuración para la configuración cost_map_server.  Contiene temas con puntos enemigos, una zona de inflación y el tamaño del cuadrado, que también se pueden usar para poner la zona peligrosa del enemigo en el mapa. <br><br><pre> <code class="cpp hljs">########################### # cost_map_server params ## ########################### cost_map_server/big_robot_size: <span class="hljs-number"><span class="hljs-number">0.4</span></span> cost_map_server/little_robot_size: <span class="hljs-number"><span class="hljs-number">0.4</span></span> cost_map_server/cube_size: <span class="hljs-number"><span class="hljs-number">0.11</span></span> cost_map_server/inscribed_radius: <span class="hljs-number"><span class="hljs-number">0.25</span></span> cost_map_server/inflation_radius: <span class="hljs-number"><span class="hljs-number">0.25</span></span> cost_map_server/inflation_exponential_rate: <span class="hljs-number"><span class="hljs-number">0.6</span></span> cost_map_server/big_robot1: <span class="hljs-string"><span class="hljs-string">"/aruco/robot1"</span></span> cost_map_server/big_robot2: <span class="hljs-string"><span class="hljs-string">"/aruco/robot2"</span></span> cost_map_server/small_robot1: <span class="hljs-string"><span class="hljs-string">"/aruco/robot3"</span></span> cost_map_server/small_robot2: <span class="hljs-string"><span class="hljs-string">"/aruco/robot4"</span></span> cost_map_server/collision: <span class="hljs-string"><span class="hljs-string">"collision"</span></span> cost_map_server/image_resource_name: <span class="hljs-string"><span class="hljs-string">"$(find cost_map_server)/param/image_resource.yaml"</span></span> cost_map_server/min_diff_points: <span class="hljs-number"><span class="hljs-number">0.01</span></span></code> </pre> <br>  Todas las capas se publican solo si alguien se suscribe a ellas: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PublishChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ nav_msgs::OccupancyGrid msg; cost_map_msgs::CostMap cost_map_msg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle_inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toOccupancyGrid(costmap, <span class="hljs-string"><span class="hljs-string">"obstacle_layer"</span></span>, msg); obstacle_inflation_publisher.publish(msg); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toOccupancyGrid(costmap, <span class="hljs-string"><span class="hljs-string">"inflation_layer"</span></span>, msg); inflation_publisher.publish(msg); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cost_map_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toMessage(costmap, cost_map_msg); cost_map_publisher.publish(cost_map_msg); } }</code> </pre> <br><h3>  Ejecutar en su computadora </h3><br>  Para comenzar la pila completa, debe: <br><br><ul><li>  Poner ROS </li><li>  roslaunch cost_map_server cost_map_server_alone.launch - para iniciar el mapa </li><li>  roslaunch global_planner global_planner.launch: inicia el planeador global con parámetros </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosparam load $ (find local_planner) /param/param.yaml </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun local_planner local_planning </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun trayectoria_regulador trayectoria_regulador </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun global_planner mover </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun rviz </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> agregar capa_inflacion </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora enviando un mensaje al tema / gp / objetivo enviamos el robot al punto deseado </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado del lanzamiento de todos los elementos, tendrá una simulación lista para iniciar nuestra pila en su computadora. </font></font><a href="https://github.com/lelongg/cost_map" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Horquilla necesaria</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iRY5WHgAFns" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicialmente, necesitábamos una navegación que ayudara a nuestro robot a conducir de manera hermosa, rápida y precisa sobre ruedas omnidireccionales. </font><font style="vertical-align: inherit;">Durante la preparación para la competencia, ni un solo gato resultó herido, y el robot es guapo. </font><font style="vertical-align: inherit;">Como resultado, tenemos una pila de navegación ligera para concursos similares a eurobot, con lo que estamos bastante satisfechos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para nosotros, esta pila es mejor que la estándar, pero ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestro Telegrama: t.me/SetUpSber </font></font><br> <a href="https://github.com/ristle/EUrobotNavigation" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El repositorio de toda nuestra creatividad</font></font></a> <br><br><img src="https://habrastorage.org/webt/98/gl/4m/98gl4mdibk20qgavmhzkbdppu4w.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/479636/">https://habr.com/ru/post/479636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479620/index.html">Lógica inversa</a></li>
<li><a href="../479622/index.html">Cómo funciona el prototipo de transacciones anónimas en la cadena de bloques Waves</a></li>
<li><a href="../479624/index.html">El gendarme profesional de Postgres, Oleg Bartunov, le cuenta a Faride Roslovets sobre PostgreSQL y sus negocios en Rusia</a></li>
<li><a href="../479626/index.html">Resonador con un giro que los físicos no conocen</a></li>
<li><a href="../479630/index.html">Lucha por la atención</a></li>
<li><a href="../479642/index.html">Cómo las estúpidas decisiones al diseñar un avión de la Segunda Guerra Mundial llevaron a la creación del Macintosh</a></li>
<li><a href="../479646/index.html">Malos consejos o razones para seguir aprendiendo inglés después de intermedio</a></li>
<li><a href="../479650/index.html">Las 12 infografías dinámicas dinámicas de TI más interesantes</a></li>
<li><a href="../479654/index.html">Django vue generador</a></li>
<li><a href="../479656/index.html">PostgreSQL Antipatterns: estadísticas alrededor de la cabeza</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>