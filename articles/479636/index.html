<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôâ üßú ‚Ñ¢Ô∏è Propia pila de navegaci√≥n. ¬øMejor que ROS? üë∏üèª üëú üöç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este es el segundo art√≠culo del equipo de configuraci√≥n sobre nuestra experiencia en la creaci√≥n de robots aut√≥nomos para las competiciones Eurobot Op...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Propia pila de navegaci√≥n. ¬øMejor que ROS?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479636/">  Este es el segundo art√≠culo del equipo de configuraci√≥n sobre nuestra experiencia en la creaci√≥n de robots aut√≥nomos para las competiciones Eurobot Open y el uso de ROS para esto. <br><br>  <a href="https://habr.com/ru/post/478836/">El primer art√≠culo trata sobre la mec√°nica y la arquitectura general de los robots.</a> <br><br>  Los robots viajan en un campo plano y la mayor√≠a de los obst√°culos se conocen de antemano, sin embargo, los oponentes insidiosos pueden intentar robar nuestros recursos (y a veces queremos comer un par de docenas de puntos extra), mientras que queremos conducir al punto deseado lo m√°s r√°pido posible y no tocar los obst√°culos.  De una c√°mara externa en el campo, obtenemos datos sobre la posici√≥n del enemigo y sabemos d√≥nde est√° ahora.  Sin embargo, no es suficiente conocer su posici√≥n: debe poder utilizar esta informaci√≥n. <br><br>  Hoy intentaremos conducir desde el punto A al punto B sin haber recorrido la cola de un gato que se ha quedado dormido en el campo.  En particular, explicaremos c√≥mo construimos una ruta y controlamos la velocidad del robot, y explicaremos c√≥mo iniciar todo en nuestra computadora. <br><br><img src="https://habrastorage.org/webt/om/x0/a6/omx0a6wfefbht9c1pialld-9vqy.png"><br><a name="habracut"></a><br><h3>  Tratando de salir con un poco de sangre </h3><br>  Al resolver este problema, puede llevar material preparado por escrito por profesionales, entonces no habr√° tormento e invenci√≥n de la pr√≥xima "bicicleta".  Usamos una plataforma con ruedas omnidireccionales, por lo que, aunque hubo un intento de utilizar una cepilladora local ya preparada de ROS, por varias razones, encontraron que esto no era prometedor.  A continuaci√≥n puede ver la cantidad de material que necesita el dise√±ador de un planeador est√°ndar: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @class TrajectoryPlanner * @brief Computes control velocities for a robot given a costmap, a plan, and the robot's position in the world. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrajectoryPlanner</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrajectoryPlannerTest</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//Need this for gtest to work public: /** * @brief Constructs a trajectory controller * @param world_model The WorldModel the trajectory controller uses to check for collisions * @param costmap A reference to the Costmap the controller should use * @param footprint_spec A polygon representing the footprint of the robot. (Must be convex) * @param inscribed_radius The radius of the inscribed circle of the robot * @param circumscribed_radius The radius of the circumscribed circle of the robot * @param acc_lim_x The acceleration limit of the robot in the x direction * @param acc_lim_y The acceleration limit of the robot in the y direction * @param acc_lim_theta The acceleration limit of the robot in the theta direction * @param sim_time The number of seconds to "roll-out" each trajectory * @param sim_granularity The distance between simulation points should be small enough that the robot doesn't hit things * @param vx_samples The number of trajectories to sample in the x dimension * @param vtheta_samples The number of trajectories to sample in the theta dimension * @param pdist_scale A scaling factor for how close the robot should stay to the path * @param gdist_scale A scaling factor for how aggresively the robot should pursue a local goal * @param occdist_scale A scaling factor for how much the robot should prefer to stay away from obstacles * @param heading_lookahead How far the robot should look ahead of itself when differentiating between different rotational velocities * @param oscillation_reset_dist The distance the robot must travel before it can explore rotational velocities that were unsuccessful in the past * @param escape_reset_dist The distance the robot must travel before it can exit escape mode * @param escape_reset_theta The distance the robot must rotate before it can exit escape mode * @param holonomic_robot Set this to true if the robot being controlled can take y velocities and false otherwise * @param max_vel_x The maximum x velocity the controller will explore * @param min_vel_x The minimum x velocity the controller will explore * @param max_vel_th The maximum rotational velocity the controller will explore * @param min_vel_th The minimum rotational velocity the controller will explore * @param min_in_place_vel_th The absolute value of the minimum in-place rotational velocity the controller will explore * @param backup_vel The velocity to use while backing up * @param dwa Set this to true to use the Dynamic Window Approach, false to use acceleration limits * @param heading_scoring Set this to true to score trajectories based on the robot's heading after 1 timestep * @param heading_scoring_timestep How far to look ahead in time when we score heading based trajectories * @param meter_scoring adapt parameters to costmap resolution * @param simple_attractor Set this to true to allow simple attraction to a goal point instead of intelligent cost propagation * @param y_vels A vector of the y velocities the controller will explore * @param angular_sim_granularity The distance between simulation points for angular velocity should be small enough that the robot doesn't hit things */ TrajectoryPlanner(WorldModel&amp; world_model, const costmap_2d::Costmap2D&amp; costmap, std::vector&lt;geometry_msgs::Point&gt; footprint_spec, double acc_lim_x = 1.0, double acc_lim_y = 1.0, double acc_lim_theta = 1.0, double sim_time = 1.0, double sim_granularity = 0.025, int vx_samples = 20, int vtheta_samples = 20, double pdist_scale = 0.6, double gdist_scale = 0.8, double occdist_scale = 0.2, double heading_lookahead = 0.325, double oscillation_reset_dist = 0.05, double escape_reset_dist = 0.10, double escape_reset_theta = M_PI_2, bool holonomic_robot = true, double max_vel_x = 0.5, double min_vel_x = 0.1, double max_vel_th = 1.0, double min_vel_th = -1.0, double min_in_place_vel_th = 0.4, double backup_vel = -0.1, bool dwa = false, bool heading_scoring = false, double heading_scoring_timestep = 0.1, bool meter_scoring = true, bool simple_attractor = false, std::vector&lt;double&gt; y_vels = std::vector&lt;double&gt;(0), double stop_time_buffer = 0.2, double sim_period = 0.1, double angular_sim_granularity = 0.025);</span></span></code> </pre> <br>  <i>Este es un ejemplo de inicializaci√≥n de par√°metros para regular velocidades y la trayectoria como un todo.</i> <br><br>  Par√°metros importantes para un c√°lculo completo: <br><br><ol><li>  Par√°metro world_model. </li><li>  Par√°metro de mapa de costos: un enlace a un mapa que contiene obst√°culos, as√≠ como su "extensi√≥n virtual", teniendo en cuenta la posible colisi√≥n. </li></ol><br>  De las ventajas de la pila est√°ndar, puede resaltar la disponibilidad de documentaci√≥n y la capacidad de encontrar informaci√≥n en los foros.  <a href="https://github.com/ros-planning/navigation" rel="nofollow">Puedes leer m√°s en el sitio web oficial con documentaci√≥n</a> <br><br>  Es importante mencionar que los paquetes ROS se escribieron para plataformas de dos ruedas y bajo Omni se optimizaron al aumentar el √°ngulo de rotaci√≥n disponible cuando se mueve hasta 360 grados, lo que sin duda es una muleta. <br><br>  Despu√©s de analizar el proyecto, nos dimos cuenta de que habr√≠a dificultades para estudiar y complementar, as√≠ como tambi√©n hay muchos chips pesados ‚Äã‚Äãque no necesitamos.  Parece, d√©jelos ser, pero usamos Odroid xu4 (el procesador del cual todav√≠a estaba en Samsung s5), y los resultados de rendimiento fueron deprimentes, y el espacio para algo m√°s potente (y la frambuesa 4 y el procesador jetson nano fuman nerviosamente en comparaci√≥n con con √©l) no.  Tuve que abandonar la pila est√°ndar e intentar crear nosotros mismos el planificador global, el planificador local y el regulador de trayectoria <br><br><img src="https://habrastorage.org/webt/ij/qe/es/ijqeesrak1vuhjqfr1ij6exr4_a.jpeg"><br><br><h3>  Planificador global, planificador local, regulador de trayectoria y todo todo </h3><br>  Se necesitan planeadores globales y locales para obtener indicaciones para llegar al destino.  ¬øPor qu√© es necesaria la separaci√≥n?  ¬øPor qu√© no puedes tomar <a href="https://ru.wikipedia.org/wiki/A*" rel="nofollow">A *</a> y montarlo?  Como regla general, el planificador global, al construir una ruta, puede usar el mapa completo en su trabajo, por lo que el algoritmo debe ser lo m√°s r√°pido posible, quiz√°s incluso con algunas simplificaciones.  Para suavizar estas simplificaciones, tambi√©n utilizan el planificador local, que, bas√°ndose en el resultado del planificador global (o simplemente en un √°rea limitada alrededor del robot), trata de tener en cuenta todos los matices. <br><br>  Despu√©s de construir la ruta, sabemos a d√≥nde debe ir el robot, pero ¬øc√≥mo se le puede informar al respecto?  Para hacer esto, hay un regulador de trayectoria.  Calcula a qu√© velocidad y en qu√© direcci√≥n debe moverse el robot en ese momento para no desviarse de la trayectoria.  En muchos sentidos, este paquete es responsable de lo r√°pido y hermoso que ir√° el robot. <br><br>  Adem√°s de estas tres entidades, hay un cuarto, un servidor de mapas, que le permite procesar convenientemente el estado del mundo.  Establece c√≥mo describimos el mapa, qu√© posibilidades tenemos cuando trabajamos con el mapa y, de muchas maneras, determinamos la velocidad de los planeadores. <br><br>  Antes de continuar con la descripci√≥n de la pila de navegaci√≥n, ser√≠a bueno describir las razones por las que se eligi√≥ cost_map como servidor de mapas.  En general, probamos diferentes opciones para el controlador de mapas: <a href="https://github.com/IntelRealSense/realsense-ros/tree/occupancy-mapping" rel="nofollow">Occupancy_grid</a> , <a href="http://wiki.ros.org/grid_map" rel="nofollow">Grid_map</a> , <a href="https://github.com/stonier/cost_map" rel="nofollow">Cost_map</a> , pero <a href="https://github.com/stonier/cost_map" rel="nofollow">decidimos</a> por el √∫ltimo. <br><br>  Razones: <br><br><ol><li>  Convenientemente interactuar con el mapa. </li><li>  Hay varios iteradores que necesitamos en varias formas (circular, lineal, rectangular, etc.). </li><li>  Puede almacenar m√∫ltiples capas de mapa con diferentes par√°metros. </li><li>  Buena gesti√≥n de la memoria. </li><li>  Y lo m√°s importante, la velocidad.  El mapa de cuadr√≠cula funciona con doble tipo y, debido a esto, es varias veces m√°s lento que los servidores de mapas que usan int8 para trabajar. </li></ol><br>  A pesar de que la cuadr√≠cula de ocupaci√≥n tambi√©n funciona con int8, no puede presumir de la misma usabilidad, por lo que tuve que abandonarla. <br><br>  Desde el mapa, necesitamos saber d√≥nde est√°n las zonas libres, peligrosas e irresistibles.  Para cada objeto que est√° en el campo, podemos ajustar el campo de inflaci√≥n, un valor que, dependiendo de la distancia al objeto, caracteriza la permeabilidad de la celda.  La inflaci√≥n es la cola del gato, es f√°cil no notarlo, pero luego te arrepentir√°s durante mucho tiempo.  Mapeamos robots enemigos y agregamos una zona de peligro que solo el planificador local tiene en cuenta.  El planificador global ignora todos los puntos, si no son un obst√°culo. <br><br><h4>  Planificador global </h4><br>  Lo primero que escribieron en navegaci√≥n es el planificador global.  Se basa en el algoritmo theta *.  En resumen, esta es una <a href="https://ru.wikipedia.org/wiki/A*" rel="nofollow">A *</a> modificada, donde el √©nfasis est√° en encontrar el nodo padre, al que se puede llegar directamente, es decir.  No hay obst√°culos para ella.  Esto nos permite construir caminos convenientes y suaves que se utilizan en el planificador local. <br><br><img src="https://habrastorage.org/webt/it/qs/e4/itqse4uuumbbzu8rxws07gapbn8.png"><br>  <i>Comparaci√≥n de A * y theta *</i> <br><br>  Para el planificador global, tenemos un archivo con par√°metros (params / path_planner.yaml) que describe los temas del mapa y los temas con la ubicaci√≥n de todos los robots (para los cuatro robots en el campo, donde "nulo" es el tema con datos sobre el robot actual). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># small robot debug param list robot_id: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"small"</span></span></span><span class="hljs-meta"> ########################### # cost_map_server params ## ########################### cost_map_server/big_robot_size: 0.45 cost_map_server/little_robot_size: 0.45 cost_map_server/cube_size: 0.11 cost_map_server/inscribed_radius: 0.3 cost_map_server/inflation_radius: 0.3 cost_map_server/inflation_exponential_rate: 0.6 cost_map_server/big_robot1: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/big_robot"</span></span></span><span class="hljs-meta"> cost_map_server/big_robot2: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/enemy_robot1"</span></span></span><span class="hljs-meta"> cost_map_server/small_robot1: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"null"</span></span></span><span class="hljs-meta"> cost_map_server/small_robot2: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/enemy_robot2"</span></span></span><span class="hljs-meta"> cost_map_server/collision: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"collision"</span></span></span><span class="hljs-meta"> cost_map_server/image_resource_name: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"$(find cost_map_server)/param/image_resource.yaml"</span></span></span><span class="hljs-meta"> cost_map_server/min_diff_points: 0.01 ########################### ### path_planner params ### ########################### global_planner/path_layer: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"inflation_layer"</span></span></span><span class="hljs-meta"> global_planner/path_force_layer: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"obstacle_inflation_layer"</span></span></span><span class="hljs-meta"> global_planner/frame_id: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"map"</span></span></span><span class="hljs-meta"> global_planner/current_position: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"real_corr"</span></span></span><span class="hljs-meta"> global_planner/path_filter_epsilon: 0</span></span></code> </pre> <br>  Tambi√©n indica: <br><br><ol><li>  uno de los algoritmos que puedes elegir para construir una ruta, </li><li>  nombres de capas en las que construiremos la ruta en s√≠, </li><li>  un tema sobre nuestra posici√≥n, donde se emiten los datos filtrados (en nuestro caso es una combinaci√≥n de datos de ubicaci√≥n de la c√°mara y la odometr√≠a). </li></ol><br>  El algoritmo de b√∫squeda de ruta en s√≠ mismo, Theta Star, se resalta en un archivo separado (src / global_planner.cpp) para la conveniencia de agregar nuevos algoritmos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cost_so_far[<span class="hljs-number"><span class="hljs-number">300</span></span>][<span class="hljs-number"><span class="hljs-number">200</span></span>]; PriorityPoint neighbors[<span class="hljs-number"><span class="hljs-number">8</span></span>]; PriorityPoint current; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> come_from[<span class="hljs-number"><span class="hljs-number">300</span></span>][<span class="hljs-number"><span class="hljs-number">200</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePath_ThetaStar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;cost_map::Index&gt; &amp;path, PriorityPoint start, PriorityPoint goal, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> layer, cost_map::CostMap &amp;cost_map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> grid_cost, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> only_cost)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::priority_queue&lt;PriorityPoint, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;PriorityPoint&gt;, myCompare&gt; openSet; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_x = cost_map.getSize()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_y = cost_map.getSize()[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::fill_n(*cost_so_far, max_x * max_y, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max()); cost_so_far[start.x][start.y] = <span class="hljs-number"><span class="hljs-number">0</span></span>; come_from[start.x][start.y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = start.x; come_from[start.x][start.y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = start.y; openSet.push(start); grid_cost=<span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!openSet.empty()) { current = openSet.top(); openSet.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == goal) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } current.GetNeighbors(neighbors); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> current_cost = cost_so_far[current.x][current.y]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parent_carent[<span class="hljs-number"><span class="hljs-number">2</span></span>] ={come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">0</span></span>], come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">1</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbors[i].OnMap(max_x, max_y)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> onLine = lineOfSight(parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>], parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>], neighbors[i].x, neighbors[i].y, cost_map, layer, grid_cost + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (onLine) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> new_cost = cost_so_far[parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>]][parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>]] + HeuristicEvclid(parent_carent, neighbors[i], grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y]) { cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost; neighbors[i].priority = HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>) + new_cost; openSet.push(neighbors[i]); come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>]; come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> neighbor_price = cost_map.at(layer, cost_map::Index({neighbors[i].x, neighbors[i].y})) + neighbors[i].priority; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> new_cost = current_cost + neighbor_price; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y]) { cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost; neighbors[i].priority =HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>) + new_cost; openSet.push(neighbors[i]); come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = current.x; come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = current.y; } } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (only_cost) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cost_so_far[current.x][current.y]; } path.clear(); PriorityPoint temp_point; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != start) { path.push_back({current.x, current.y}); temp_point.x = come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">0</span></span>]; temp_point.y = come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">1</span></span>]; current = temp_point; } path.push_back({current.x, current.y}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Un algoritmo para eliminar puntos adicionales en la ruta RamerDouglasPeucker tambi√©n se asigna a un archivo separado. <br>  Elimina puntos del camino si est√° m√°s all√° de una distancia dada de la l√≠nea que conecta dos puntos vecinos. <br><br><img src="https://habrastorage.org/webt/en/_9/dw/en_9dw6khdarxbyf7gvrhpqg7b4.jpeg"><br><br><h4>  Planificador local </h4><br>  √âl trabaja para nosotros sobre la base del descenso de gradiente en un campo potencial.  Como entrada, el camino desde el planificador global.  Sin embargo, esto no es todo de lo que es capaz.  En local_planner, hay servicios internos para elegir el modo de construcci√≥n de ruta.  Hay dos modos de funcionamiento en total: el modo de desplazamiento de puntos a lo largo del gradiente, utilizando m√∫ltiples pases en el mapa, as√≠ como el modo de desplazamiento, en el que calculamos inmediatamente el incremento en dos coordenadas y movemos el punto al borde de la zona segura.  Si el punto cae en varias de esas zonas, entonces cambiamos a los lugares de su intersecci√≥n, porque all√≠ es m√°s seguro. <br><br>  El modo de operaci√≥n es el siguiente: si no hay ning√∫n obst√°culo en el camino desde la iteraci√≥n anterior, entonces rompemos el camino cada 2 cm y luego lo desplazamos a lo largo del gradiente; de ‚Äã‚Äãlo contrario, usamos el segundo modo de operaci√≥n del planificador local. <br><br>  La segunda opci√≥n es bastante ligera y, como el planificador global, no carga mucho el procesador.  Utilizamos varias versiones de este algoritmo y varias manipulaciones con el mapa.  Por ejemplo, intentamos escribir un gr√°fico en el que los v√©rtices se encuentran cada 10 cm y se desplazan por un m√°ximo de 4 cm, despu√©s de lo cual se utiliz√≥ el algoritmo de Dijkstra en el gr√°fico obtenido para encontrar la distancia m√°s peque√±a.  El punto final en este caso usa el punto de desplazamiento m√°s cercano.  Pero dicho algoritmo era m√°s adecuado para el planificador global y decidimos abandonar esta implementaci√≥n. <br><br>  Tambi√©n intentamos usar la construcci√≥n de caminos desde cero usando el m√©todo de descenso de gradiente.  Este m√©todo fue el primero que decidimos escribir.  Result√≥ no ser eficiente en memoria (ocupaba m√°s de 400 mb de RAM pura, ya que usaba un mapa de costos con cada pasada) y lento.  El control de frecuencia se apag√≥ debido a una optimizaci√≥n deficiente y la velocidad era inferior a 30 veces por segundo, lo que no nos conven√≠a. <br><br>  Como resultado, decidimos usar el descenso de gradiente en un campo potencial basado en el camino del planeador global.  Result√≥ ser un algoritmo liviano y relativamente simple, que nos conviene completamente en t√©rminos de calidad de ruta, tiempo de trabajo y la cantidad de RAM utilizada en la regi√≥n de 100-150 mb, que es varias veces menor que en las primeras iteraciones de desarrollo. <br><br><img src="https://habrastorage.org/webt/sg/oq/mo/sgoqmogivjs8elhylt74oqjqrdw.png"><br>  <i>Un ejemplo de una ruta desplazada por un cepillo local</i> <br><br>  A diferencia de global_planner, los par√°metros en local_planner son extremadamente peque√±os, lo que se debe a su simplicidad, porque todas las tareas m√°s importantes recaen en global_planner: <br><br><pre> <code class="cpp hljs">grid_map_server/big_robot1 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/big_robot2 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/small_robot1 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/small_robot2 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> local_planner/radius : <span class="hljs-number"><span class="hljs-number">0.15</span></span> global_planner/frame_id : <span class="hljs-string"><span class="hljs-string">"map"</span></span></code> </pre> <br>  En este caso, configuramos: <br><br><ul><li>  Radios de zonas seguras para cada uno de los robots. </li><li>  Recorrido m√°ximo de desplazamiento por cepillo local. </li><li>  El nombre de la capa de mapa con la que estamos trabajando. </li></ul><br>  En una clase separada se asignaron todas las funciones m√°s importantes.  En este caso, es un desglose recursivo del camino, la creaci√≥n de un planeador y constructores y destructores virtuales. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Planner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Planner(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> inflation_radius_, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> frame_id_) { inflation_radius = inflation_radius_; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">200</span></span>; j++) our_map[i][j] = <span class="hljs-number"><span class="hljs-number">3000.0</span></span>; } OurPath-&gt;poses.resize(<span class="hljs-number"><span class="hljs-number">50</span></span>); geometry_msgs::Pose pose; pose.position.x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; pose.position.y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>; i++) { OurPath-&gt;poses[i].pose = pose; } frame_id = frame_id_; } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Planner() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdatePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; ros::Publisher move_pub; ros::Publisher BigEnemyPub; ros::Publisher LittleEnemyPub; ros::Publisher local_path_publisher; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-comment"><span class="hljs-comment">// virtual double Calculate_Path_Len(); nav_msgs::Path* recursive_path(nav_msgs::Path *path, std::pair&lt;double, double&gt; start, std::pair&lt;double, double&gt; end, double epsilon, int &amp;index) { if (CalcDistance(start, end) &lt; (epsilon) || path-&gt;poses.size() &gt; 200) return path; double start_x = (start.first + end.first) / 2.0; double start_y = (start.second + end.second) / 2.0; index = find_out(path, start); geometry_msgs::PoseStamped pose; pose.pose.position.x = start_x; pose.pose.position.y = start_y; path-&gt;poses.insert(path-&gt;poses.begin() + index, pose); recursive_path(path, start, std::pair&lt;double, double&gt;{start_x, start_y}, epsilon, index); recursive_path(path, std::pair&lt;double, double&gt;{start_x, start_y}, end, epsilon, index); } int find_out(nav_msgs::Path *path, pair_double point) { int index = 0; for (int i = 0; i &lt; path-&gt;poses.size(); i++) if (path-&gt;poses[i].pose.position.x == point.first &amp;&amp; path-&gt;poses[i].pose.position.y == point.second) return ++i; return index; } void add_in_path(nav_msgs::Path* Path, geometry_msgs::PoseStamped pose, int&amp; Index) { Path-&gt;poses[Index % max_size] = pose; Index++; } double inflation_radius; double our_map[300][200]; int max_size = 49; std::string frame_id; nav_msgs::Path *path = new nav_msgs::Path; nav_msgs::Path *OurPath = new nav_msgs::Path; };</span></span></code> </pre> <br>  La clase LocalPlanning se hered√≥ de ella, donde se encuentra todo el n√∫cleo del planeador, es decir, desplazando puntos al borde de la zona segura y decidiendo qu√© hacer espec√≠ficamente con la ruta. <br><br>  Todas las dem√°s funciones se resaltan en un archivo separado fichi.hpp, y el descenso de gradiente en potencial_campo.hpp.  A continuaci√≥n se muestra una instant√°nea de este archivo, que muestra las funciones para crear un campo potencial en el mapa cost_map: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcAttractivePotential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(grid_map::Index index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goalx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goaly)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(index[<span class="hljs-number"><span class="hljs-number">0</span></span>] - goalx, <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(index[<span class="hljs-number"><span class="hljs-number">1</span></span>] - goaly, <span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcPotential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> starty, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goalx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goaly, cost_map::CostMap &amp;cost_map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (&amp;our_map)[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">300</span></span></span></span><span class="hljs-function"><span class="hljs-params">][</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">200</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Use some magic for normalisation of Field double max_distance = (CalcAttractivePotential(grid_map::Index(startx, starty), goalx, goaly) + 15); if (max_distance == 0.0) { max_distance = 0.01; } for (cost_map::CircleIterator iterator(cost_map, grid_map::Position(startx / 100.0, starty / 100.0), max_distance / 100.); !iterator.isPastEnd(); ++iterator) { try { grid_map::Index index(*iterator); double uf; uf = cost_map.at("obstacle_inflation_layer", *iterator); // if we on free podouble - field is more less then if it not free podouble if ( uf &gt;= 10) { uf = 3000.0; // CP - is const variable } else uf += CalcAttractivePotential(index, goalx, goaly)/max_distance * 256; our_map[299-index(0)][199-index(1)] = uf; } catch(std::exception&amp; e) { ROS_INFO("Exception! %s", e.what() ); } } }</span></span></code> </pre> <br><h4>  Regulador de trayectoria </h4><br>  Por √∫ltimo, pero no menos importante, es el regulador de trayectoria.  Es responsable de convertir la ruta del planificador local en una ruta y proporciona la velocidad para el paso actual. <br><br>  Su primera versi√≥n, que utilizamos en la final de Eurobot 2018, es una mezcla del controlador pid de aceleraci√≥n y frenado, donde el vector se normaliza al siguiente punto en el camino, en relaci√≥n con la distancia al punto final. <br><br>  En resumen, el controlador PID es la suma de los tres estados del sistema que ayudan a corregir el sistema y los errores aleatorios que a veces ocurren. <br><br>  Estas funciones se seleccionaron emp√≠ricamente y dependen de la distancia al punto final de la ruta (puede ser cuadr√°tica, c√∫bica, inversa, pero luego nos decidimos por la cuadr√°tica).  Esto funcion√≥, pero lo √∫nico que no nos conven√≠a era que el robot no pod√≠a frenar a tiempo a velocidades superiores a 0,7 metros por segundo.  Por lo tanto, cuando lleg√≥ el momento, decidimos reconstruir todo el algoritmo. <br><br>  La primera iteraci√≥n en el camino hacia la nueva trayectoria fue el reemplazo del vector al que √≠bamos.  Ahora era la suma de los vectores para los pr√≥ximos tres con diferentes coeficientes.  La segunda iteraci√≥n fue la escritura m√≠nima jerk.  En resumen, esta es una construcci√≥n de un polinomio de quinto grado, donde las coordenadas x e y dependen del tiempo de llegada a cada punto. <br><br><img src="https://habrastorage.org/webt/ho/mw/hd/homwhdagbnkgdlrigettcc6yook.png"><br>  <i>La figura muestra un gr√°fico de una de las coordenadas en funci√≥n del tiempo, as√≠ como la velocidad a lo largo de esta coordenada.</i> <br><br>  Este tipo de regulador de trayectoria nos conven√≠a m√°s, ya que requer√≠a menos manipulaci√≥n con la selecci√≥n de diferentes coeficientes, porque todos los coeficientes son los valores en el polinomio, que se calcularon en funci√≥n del tiempo de llegada, la velocidad y aceleraci√≥n actuales, la velocidad de salida y la aceleraci√≥n. <br><br>  El resultado de la reescritura de la trayectoria fue que logramos duplicar la velocidad promedio del robot. <br><br>  Como en los dos casos anteriores, todas las funciones principales se asignan en un archivo separado para facilitar la interacci√≥n.  Esta vez, la clase PlannerTrajectory es responsable de construir una trayectoria basada en MinimumJerk <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> velocity; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> acceleration; State(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> v_, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a_) : velocity(v_), acceleration(a_) {} State() { velocity = <span class="hljs-number"><span class="hljs-number">0</span></span>; acceleration = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlannerTrajectory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: nav_msgs::Path global_path; cost_map::CostMap *costmap_ptr; geometry_msgs::PoseStamped Goal_pred; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; trajectory_x; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; trajectory_y; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> average_velocity = <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Defualt or get from param // double max_velocity = 100; double coef_x[6]; double coef_y[6]; int frequency = 30; // Defualt or get from param // int index; public: PlannerTrajectory(cost_map::CostMap *costmap_, const int &amp;frequency_, const double &amp;max_velocity_, const double &amp;average_velocity_) { average_velocity = average_velocity;; max_velocity = max_velocity_; costmap_ptr = costmap_; frequency = frequency_; Goal_pred.pose.position.x = 0.0; Goal_pred.pose.position.y = 0.0; }</span></span></code> </pre> <br>  <i>La foto muestra todas las variables declaradas que utilizamos.</i> <br><br>  Todo lo dem√°s se resalta en otro archivo (include / trajectory_regulator.h): recibir puntos de temas, decidir si pasar al siguiente punto (si est√° en un obst√°culo, entonces no vamos) y mucho m√°s. <br><br><h3>  Migrando a ROS Melodic </h3><br>  Hasta el a√±o pasado, utilizamos el lanzamiento lte de ROS - ROS Kinetic.  Generalmente nos conviene, pero su apoyo est√° llegando a su fin el pr√≥ximo a√±o, y muchos de los paquetes que necesitamos comenzaron a salir exclusivamente para ROS Melodic.  Y luego result√≥ que el costmap_server que utilizamos no est√° bajo Melodic. <br><br>  Hubo un problema al procesar los datos de las tarjetas. <br><br>  Elegimos el mapa de cuadr√≠cula, ya que la pila es similar, pero el comienzo del mapa est√° en un lugar diferente, y los valores del mapa en s√≠ var√≠an de 0 a 1. Esto se ha convertido en un gran problema en toda la pila de navegaci√≥n.  Si antes el planificador global se lanzaba 50 veces por segundo (hab√≠a restricciones de frecuencia y, por lo tanto, el procesador no se usaba demasiado, incluso en la mitad de un hilo), ahora allan√≥ el camino cada dos segundos y lo consider√≥ malo: carg√≥ completamente un n√∫cleo.  En 2 segundos, el robot podr√≠a cruzar todo el mapa.  Esto no nos conven√≠a, y los intentos de paralelizar este proceso terminaron en un fracaso, porque entonces no quedaba rendimiento para otros proyectos (teniendo en cuenta los costos de la paralelizaci√≥n). <br><br>  Decidimos cambiar la pila nuevamente, abandonar el mapa de cuadr√≠cula a favor de la cuadr√≠cula de ocupaci√≥n.  Ha aparecido un nuevo problema: la incapacidad de almacenar varias versiones de mapas al mismo tiempo (por ejemplo, un mapa completo con todos los obst√°culos y un mapa est√°tico con solo obst√°culos din√°micos).  Tendr√≠a que cambiar la mitad del c√≥digo, que no era particularmente confiable.  Por lo tanto, decidimos buscar soluciones alternativas a este problema. <br><br><h4>  Servidor de mapas de costos </h4><br>  Despu√©s de una larga b√∫squeda, encontramos mapas de horquillas costmap_serverr: <a href="" rel="nofollow">https://github.com/lelongg/cost_map.git</a> , extremadamente √∫tiles para nuestro sistema de horquillas. <br><br><img src="https://habrastorage.org/webt/27/rb/oh/27rbohj3kefxprwtjqrg4mwtqjc.png"><br><br>  Y ahora, en lugar de dar servicio solo al mapa de cuadr√≠cula, para la entrega, logramos calcular la ubicaci√≥n probable del enemigo en funci√≥n de la predicci√≥n del filtro de Kalman. <br><br><img src="https://habrastorage.org/webt/ni/pm/nz/nipmnzvhcrqdje1cu8glf9quude.png"><br><br>  Una de las cosas m√°s importantes para un servidor de mapas es un archivo de mapa, que se utiliza para la creaci√≥n inicial de todas las capas, que posteriormente solo se actualizan.  Es una imagen binaria png, donde el negro es un obst√°culo y el blanco es una zona libre. <br><br><img src="https://habrastorage.org/webt/2b/l5/rg/2bl5rgpuecb7he51heslqpvcazm.png"><br><br>  Tambi√©n hay un archivo de configuraci√≥n para la configuraci√≥n cost_map_server.  Contiene temas con puntos enemigos, una zona de inflaci√≥n y el tama√±o del cuadrado, que tambi√©n se pueden usar para poner la zona peligrosa del enemigo en el mapa. <br><br><pre> <code class="cpp hljs">########################### # cost_map_server params ## ########################### cost_map_server/big_robot_size: <span class="hljs-number"><span class="hljs-number">0.4</span></span> cost_map_server/little_robot_size: <span class="hljs-number"><span class="hljs-number">0.4</span></span> cost_map_server/cube_size: <span class="hljs-number"><span class="hljs-number">0.11</span></span> cost_map_server/inscribed_radius: <span class="hljs-number"><span class="hljs-number">0.25</span></span> cost_map_server/inflation_radius: <span class="hljs-number"><span class="hljs-number">0.25</span></span> cost_map_server/inflation_exponential_rate: <span class="hljs-number"><span class="hljs-number">0.6</span></span> cost_map_server/big_robot1: <span class="hljs-string"><span class="hljs-string">"/aruco/robot1"</span></span> cost_map_server/big_robot2: <span class="hljs-string"><span class="hljs-string">"/aruco/robot2"</span></span> cost_map_server/small_robot1: <span class="hljs-string"><span class="hljs-string">"/aruco/robot3"</span></span> cost_map_server/small_robot2: <span class="hljs-string"><span class="hljs-string">"/aruco/robot4"</span></span> cost_map_server/collision: <span class="hljs-string"><span class="hljs-string">"collision"</span></span> cost_map_server/image_resource_name: <span class="hljs-string"><span class="hljs-string">"$(find cost_map_server)/param/image_resource.yaml"</span></span> cost_map_server/min_diff_points: <span class="hljs-number"><span class="hljs-number">0.01</span></span></code> </pre> <br>  Todas las capas se publican solo si alguien se suscribe a ellas: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PublishChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ nav_msgs::OccupancyGrid msg; cost_map_msgs::CostMap cost_map_msg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle_inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toOccupancyGrid(costmap, <span class="hljs-string"><span class="hljs-string">"obstacle_layer"</span></span>, msg); obstacle_inflation_publisher.publish(msg); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toOccupancyGrid(costmap, <span class="hljs-string"><span class="hljs-string">"inflation_layer"</span></span>, msg); inflation_publisher.publish(msg); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cost_map_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toMessage(costmap, cost_map_msg); cost_map_publisher.publish(cost_map_msg); } }</code> </pre> <br><h3>  Ejecutar en su computadora </h3><br>  Para comenzar la pila completa, debe: <br><br><ul><li>  Poner ROS </li><li>  roslaunch cost_map_server cost_map_server_alone.launch - para iniciar el mapa </li><li>  roslaunch global_planner global_planner.launch: inicia el planeador global con par√°metros </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosparam load $ (find local_planner) /param/param.yaml </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun local_planner local_planning </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun trayectoria_regulador trayectoria_regulador </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun global_planner mover </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun rviz </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> agregar capa_inflacion </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora enviando un mensaje al tema / gp / objetivo enviamos el robot al punto deseado </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado del lanzamiento de todos los elementos, tendr√° una simulaci√≥n lista para iniciar nuestra pila en su computadora. </font></font><a href="https://github.com/lelongg/cost_map" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Horquilla necesaria</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iRY5WHgAFns" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicialmente, necesit√°bamos una navegaci√≥n que ayudara a nuestro robot a conducir de manera hermosa, r√°pida y precisa sobre ruedas omnidireccionales. </font><font style="vertical-align: inherit;">Durante la preparaci√≥n para la competencia, ni un solo gato result√≥ herido, y el robot es guapo. </font><font style="vertical-align: inherit;">Como resultado, tenemos una pila de navegaci√≥n ligera para concursos similares a eurobot, con lo que estamos bastante satisfechos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para nosotros, esta pila es mejor que la est√°ndar, pero ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestro Telegrama: t.me/SetUpSber </font></font><br> <a href="https://github.com/ristle/EUrobotNavigation" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El repositorio de toda nuestra creatividad</font></font></a> <br><br><img src="https://habrastorage.org/webt/98/gl/4m/98gl4mdibk20qgavmhzkbdppu4w.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/479636/">https://habr.com/ru/post/479636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479620/index.html">L√≥gica inversa</a></li>
<li><a href="../479622/index.html">C√≥mo funciona el prototipo de transacciones an√≥nimas en la cadena de bloques Waves</a></li>
<li><a href="../479624/index.html">El gendarme profesional de Postgres, Oleg Bartunov, le cuenta a Faride Roslovets sobre PostgreSQL y sus negocios en Rusia</a></li>
<li><a href="../479626/index.html">Resonador con un giro que los f√≠sicos no conocen</a></li>
<li><a href="../479630/index.html">Lucha por la atenci√≥n</a></li>
<li><a href="../479642/index.html">C√≥mo las est√∫pidas decisiones al dise√±ar un avi√≥n de la Segunda Guerra Mundial llevaron a la creaci√≥n del Macintosh</a></li>
<li><a href="../479646/index.html">Malos consejos o razones para seguir aprendiendo ingl√©s despu√©s de intermedio</a></li>
<li><a href="../479650/index.html">Las 12 infograf√≠as din√°micas din√°micas de TI m√°s interesantes</a></li>
<li><a href="../479654/index.html">Django vue generador</a></li>
<li><a href="../479656/index.html">PostgreSQL Antipatterns: estad√≠sticas alrededor de la cabeza</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>