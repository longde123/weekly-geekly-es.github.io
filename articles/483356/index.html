<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤶🏿 🕓 👇🏽 Conteo de la comunidad "¿Qué?" Donde ¿Cuándo? ”(ChGK) o cuántos apretones de manos ante un amigo? 🥈 🚣🏿 🔦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! 


 Las vacaciones de año nuevo son un buen momento para  tomar un descanso de TI  Utiliza habilidades profesionales en tu pasatiempo favor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conteo de la comunidad "¿Qué?" Donde ¿Cuándo? ”(ChGK) o cuántos apretones de manos ante un amigo?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483356/"><img src="https://habrastorage.org/webt/sx/cv/ze/sxcvzemh1zfstlb99nne9_2hoxm.png"><br><p>  Hola Habr! </p><br><p>  Las vacaciones de año nuevo son un buen momento para <del>  tomar un descanso de TI </del>  Utiliza habilidades profesionales en tu pasatiempo favorito.  Buscando en el <a href="https://rating.chgk.info/" rel="nofollow">sitio de la clasificación deportiva ChGK</a> , encontré una excelente API que le permite obtener datos sobre todos los juegos de todos los torneos.  Entonces tuve la idea de construir un gráfico de la comunidad de expertos y probar la teoría de seis apretones de manos en una comunidad geográficamente dispersa y estrictamente fuera de línea.  Bajo katom imágenes de gráficos y estadísticas inútiles. </p><a name="habracut"></a><br><p>  Para empezar, un breve programa educativo, qué es el deporte ChGK. </p><br><div class="spoiler">  <b class="spoiler_title">¿Qué es el deporte ChGK?</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/w8/fb/yk/w8fbykni1pnbv0jgab0-9sbo4j4.jpeg" alt="Torneo deportivo ChGK"></p><br><p>  Estoy seguro de que con la versión televisiva de "¿Qué?  Donde  ¿Cuándo? ”El lector está familiarizado con la parte superior y las letras de los espectadores.  Sports ChGK es una extensión del formato de televisión que permite que varios equipos jueguen simultáneamente. </p><br><p>  En el café, la casa de la juventud, el salón de actos de la universidad, se reúnen varios equipos de hasta seis personas.  El anfitrión lee las preguntas, se da un minuto para reflexionar.  Al final del minuto, el equipo registra la respuesta al formulario de juego y sube.  Personas especialmente capacitadas llamadas golondrinas recogen papel.  Por lo general, se leen 36 preguntas por juego, divididas en tres rondas.  Quién respondió sobre todo, que bien hecho. </p><br><p>  Hay muchos torneos en ChGK, incluso hay un Campeonato Europeo y Mundial, estoy enviando a los curiosos a una <a href="http://lurkmore.to/%25D0%25A1%25D0%25BF%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25A7%25D0%2593%25D0%259A" rel="nofollow">fuente confiable de información</a> .  Y ejemplos de preguntas se pueden encontrar <a href="https://db.chgk.info/" rel="nofollow">aquí</a> . </p></div></div><br><h2 id="poluchenie-dannyh">  Recuperación de datos </h2><br><p>  Asumimos que los jugadores están familiarizados entre sí si jugaron al menos una vez en una mesa de juego.  Gracias a la <a href="https://rating.chgk.info/api-doc" rel="nofollow">buena API,</a> descargar datos sobre todos los torneos y todos los equipos no es un problema. </p><br><p>  Debajo de los spoilers, ni siquiera se usa Beautiful Soup, solo solicitudes.  Un cuaderno jupyter con todo el código fuente estará al final del artículo. </p><br><div class="spoiler">  <b class="spoiler_title">Descargar datos para todos los torneos</b> <div class="spoiler_text"><pre><code class="python hljs">url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/tournaments.json/?page={}'</span></span> df = pd.DataFrame(columns=[<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'start'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>): data = requests.get(url.format(i)).json() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data[<span class="hljs-string"><span class="hljs-string">"items"</span></span>]: df.loc[item[<span class="hljs-string"><span class="hljs-string">"idtournament"</span></span>]] = (item[<span class="hljs-string"><span class="hljs-string">"name"</span></span>], item[<span class="hljs-string"><span class="hljs-string">"date_start"</span></span>]) df.to_csv(<span class="hljs-string"><span class="hljs-string">'tournaments.csv'</span></span>)</code> </pre> </div></div><br><p>  Queda por descargar las listas de juegos de todos los torneos y recordar a todos los conocidos.  Inicialmente, planeé almacenar los hechos de un juego conjunto en un DataFrame, pero la velocidad de agregar nuevos registros fue deprimente.  Por lo tanto, estableceremos a partir de tuplas (id1, id2), donde id1, id2 son los identificadores de jugadores que están familiarizados entre sí.  Al mismo tiempo, elimine los duplicados. </p><br><div class="spoiler">  <b class="spoiler_title">Descargar composiciones y hacer conocidos</b> <div class="spoiler_text"><pre> <code class="python hljs">df = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'tournaments.csv'</span></span>).set_index(<span class="hljs-string"><span class="hljs-string">'Unnamed: 0'</span></span>) url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/tournaments/{}/recaps.json'</span></span> links = set() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> df.index: teams = requests.get(url.format(id)).json() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> team <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> teams: t = team[<span class="hljs-string"><span class="hljs-string">"recaps"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(t)): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(i + <span class="hljs-number"><span class="hljs-number">1</span></span>, len(t)): first = int(t[i][<span class="hljs-string"><span class="hljs-string">"idplayer"</span></span>]) second = int(t[j][<span class="hljs-string"><span class="hljs-string">"idplayer"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first &lt; second: links.add((first, second)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: links.add((second, first)) <span class="hljs-comment"><span class="hljs-comment">#    sleep(1) clear_output(wait=True) display('Current tournament: ' + str(df.index.get_loc(id) + 1) + '/' + str(len(df))) display('Links total: ' + str(len(links)))</span></span></code> </pre> </div></div><br><h2 id="poluchenie-grafa-i-issledovanie-komponent-svyaznosti">  Obtener un gráfico y explorar componentes conectados </h2><br><p>  Entonces, la preparación de datos ha terminado, ¡es hora de construir un gráfico!  Para hacer esto, utilizaremos la biblioteca <a href="https://networkx.github.io/" rel="nofollow">networkx</a> , <a href="https://networkx.github.io/" rel="nofollow">cuyas</a> capacidades son suficientes para nuestro clúster. </p><br><pre> <code class="python hljs">players = itertools.chain(*links) G = nx.Graph() G.add_nodes_from(players) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> links: G.add_edge(*t) print(nx.info(G))</code> </pre> <br><p>  Ahora hay alrededor de doscientas mil personas en la comunidad ChGK, y en promedio, un experto en una carrera ha jugado con 12 personas: </p><br><pre> <code class="plaintext hljs">Number of nodes: 198145 Number of edges: 1206076 Average degree: 12.1737</code> </pre> <br><p>  Es hora de descubrir cuántos componentes conectados hay en el gráfico de citas.  Networkx tiene una gran función llamada connected_components que hace justo lo que necesita: </p><br><pre> <code class="python hljs">clusters_l = [len(c) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)] print(clusters_l[:<span class="hljs-number"><span class="hljs-number">20</span></span>])</code> </pre> <br><p>  Casi las tres cuartas partes de los jugadores están en un componente conectado, el resto se divide en subgráficos muy pequeños.  Hay más de ocho mil de ellos. </p><br><pre> <code class="plaintext hljs">[145922, 153, 124, 74, 72, 56, 50, 47, 42, 40, 39, 39, 38, 38, 37, 36, 36, 36, 36, 35]</code> </pre> <br><p>  Incluso en una escala logarítmica, el dominio del componente principal se ve impresionante.  En el eje X, el número del componente del mayor al menor, en el eje Y, su tamaño (el eje es logarítmico). </p><br><img src="https://habrastorage.org/webt/c9/pa/ol/c9paolwikv7_cjugzxctqtpffwy.png"><br><p>  ¿Qué causó una distribución tan desigual de personas en componentes conectados?  En mi opinión, el punto es este: </p><br><ul><li>  un pequeño grupo de personas viene al juego por primera vez y, por lo tanto, forma un pequeño grupo para 4-6 personas; </li><li>  si la ciudad ya tiene una comunidad grande, dicho grupo se fusionará rápidamente con el principal: solo una persona necesita jugar para un equipo del grupo principal; </li><li>  si en la ciudad de ChGK acaba de aparecer, el grupo vivirá más tiempo, porque  Jugar para un equipo del grupo principal es más difícil. </li></ul><br><p>  El proceso se asemeja a la formación de gotas de lluvia en las nubes: una gran gota atrae a las pequeñas y crece rápidamente. </p><br><p>  Antes de tratar con el componente principal, veamos los componentes en primer o noveno lugar (considero que el componente principal es cero).  Probamos la hipótesis de que las personas en estos componentes son de la misma ciudad.  El conocedor no tiene ningún apego a la ciudad (lo cual es lógico en nuestro mundo moderno).  Sin embargo, puedes mirar el puerto de origen del equipo para el que jugó por última vez </p><br><div class="spoiler">  <b class="spoiler_title">Código de estadísticas de la ciudad</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>): _g = list(sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[i]) s = pd.Series() p_url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/players/{}/tournaments.json'</span></span> t_url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/teams/{}.json'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> player <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _g: data = requests.get(p_url.format(player)).json() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: team_id = data[item][<span class="hljs-string"><span class="hljs-string">"tournaments"</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">"idteam"</span></span>] data = requests.get(t_url.format(team_id)).json() town = data[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">"town"</span></span>] s.at[len(s)] = town print(<span class="hljs-string"><span class="hljs-string">' #{}'</span></span>.format(i)) print(s.value_counts())</code> </pre> </div></div><br><p>  Placa resumen: </p><br><div class="scrollable-table"><table><thead><tr><th>  Conectividad Componente No. </th><th>  Tamaño </th><th>  Ciudades </th></tr></thead><tbody><tr><td>  1 </td><td>  153 </td><td>  Kerch </td></tr><tr><td>  2 </td><td>  124 </td><td>  110 - Ust-Ilimsk, 12 - Vladivostok, 2 - Irkutsk </td></tr><tr><td>  3 </td><td>  74 </td><td>  Tambov - 72, <strong>Luxemburgo - 2</strong> </td></tr><tr><td>  4 4 </td><td>  72 </td><td>  Bosque </td></tr><tr><td>  5 5 </td><td>  56 </td><td>  Yeisk </td></tr><tr><td>  6 6 </td><td>  50 </td><td>  Bishkek </td></tr><tr><td>  7 7 </td><td>  47 </td><td>  <strong>Gorno-Altaysk</strong> </td></tr><tr><td>  8 </td><td>  42 </td><td>  Zhytomyr - 37, Glazov - 5 </td></tr><tr><td>  9 9 </td><td>  40 </td><td>  <strong>Gorno-Altaysk - 31, Moscú - 9</strong> </td></tr></tbody></table></div><br><p>  Sí, los pequeños grupos son casi en su totalidad de una ciudad.  Preste atención al componente de setenta y dos residentes de Tambov, que está asociado con Luxemburgo.  En el séptimo y noveno lugar se encuentran los componentes de Gorno-Altaysk, que por alguna razón no están interconectados.  Me imagino fácilmente la lucha de dos clanes de cenizas ChGK, como Montecca y Capulet, que luchan por el control de la ciudad. <br>  Supongo que en un futuro cercano estos componentes se fusionarán en el principal <del>  pero continuará luchando </del>  . </p><br><h2 id="osnovnaya-komponenta-svyaznosti">  El componente principal de la conectividad. </h2><br><p>  Entonces, llegamos al componente principal.  Obtendremos el subgráfico deseado y miraremos sus estadísticas: </p><br><pre> <code class="python hljs">subgraph_v = list(sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]) subgraph = G.subgraph(subgraph_v) print(nx.info(subgraph))</code> </pre> <br><p>  El número promedio de conexiones resultó ser más. </p><br><pre> <code class="plaintext hljs">Number of nodes: 145922 Number of edges: 1070504 Average degree: 14.6723</code> </pre> <br><p>  ¿Y cuál es el número máximo de conexiones por jugador? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(G.degree, key=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-number"><span class="hljs-number">1</span></span>], reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[:<span class="hljs-number"><span class="hljs-number">10</span></span>]: print(<span class="hljs-string"><span class="hljs-string">' {}   {} '</span></span>.format(t[<span class="hljs-number"><span class="hljs-number">0</span></span>], t[<span class="hljs-number"><span class="hljs-number">1</span></span>]))</code> </pre> <br><pre> <code class="plaintext hljs"> 42511   818   15051   798   29800   678   23020   666   16581   662   5328   657   29887   651   15811   645   30352   605   1055   602 </code> </pre> <br><p>  Francamente, estoy un poco sorprendido por los números.  Si juegas con un equipo nuevo cada vez, necesitarás 818/5 ≈ 164 juegos para llegar al primer lugar.  Increíble <br>  Recordaremos a los dos primeros expertos en esta calificación y utilizaremos más sus habilidades de comunicación. <br>  Calculemos cuántos conocidos más cercanos tiene un experto promedio: </p><br><div class="spoiler">  <b class="spoiler_title">Obtener datos y trazar</b> <div class="spoiler_text"><pre> <code class="python hljs">_count = <span class="hljs-number"><span class="hljs-number">50</span></span> values = nx.degree_histogram(subgraph) plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">80</span></span>) plt.plot(range(_count),values[:_count],<span class="hljs-string"><span class="hljs-string">'ro-'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># in-degree plt.xlabel(' ', fontsize=18) plt.xticks(range(0,_count, 5)) plt.ylabel(' ', fontsize=18) plt.title(' ', fontsize=22) plt.show()</span></span></code> </pre> </div></div><br><img src="https://habrastorage.org/webt/rt/cl/eh/rtclehktplh8tx_5mms3ny6gcom.png"><br><p>  En el eje X, el número de conocidos más cercanos, en el eje Y, el número de expertos que tiene el número correspondiente de conocidos.  Por ejemplo, aproximadamente 40,000 expertos tienen cada uno cinco conocidos. <br>  Tenga en cuenta que la moda tiene 5 conocidos (es curioso que hasta seis personas puedan estar en la mesa).  Al mismo tiempo, el promedio aritmético del número de conocidos es 14.67, y la mediana es 7. El hecho es que los caballeros de la clasificación anterior sobreestiman en gran medida el promedio.  Si cien personas no juegan en ChGK, y una tiene 800 conocidos, entonces, en promedio, juegan en ChGK. </p><br><h2 id="rasstoyaniya-do-igrokov">  Distancias a los jugadores </h2><br><p>  Porque  contar el diámetro de un gráfico de este tipo es un <a href="https://neerc.ifmo.ru/wiki/index.php%3Ftitle%3D%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%25D1%258B_%25D0%25BD%25D0%25B0_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D1%258C%25D1%258F%25D1%2585" rel="nofollow">poco difícil</a> , hagámoslo más fácil: tome una lista de varios jugadores y encuentre el máximo de las distancias más cortas entre ellos y otros expertos.  Como estos jugadores, tomé varios expertos conocidos, yo mismo, un jugador aleatorio y dos expertos con el mayor número de conocidos (ver calificación arriba).  Esto es lo que sucedió: </p><br><pre> <code class="python hljs">famous_players = {<span class="hljs-number"><span class="hljs-number">9808</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">5195</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">25882</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">29333</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">118622</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">42511</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">15051</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">118621</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> famous_players: print(<span class="hljs-string"><span class="hljs-string">'{}: {} -      '</span></span> .format(famous_players[key], nx.eccentricity(subgraph, v=key)))</code> </pre><br><pre> <code class="plaintext hljs"> : 12 -        : 12 -        : 12 -        : 12 -        : 13 -        : 12 -        : 13 -        : 13 -      </code> </pre><br><p>  Resulta que una formulación sólida de la teoría de seis apretones de manos (dos personas separadas por no más de cinco niveles de amigos mutuos) es incorrecta.  El diámetro del gráfico es muy probablemente 13-14. <br>  ¿Qué pasa con una redacción más débil (dos personas <strong>en promedio están</strong> separadas por no más de cinco niveles de amigos mutuos)? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> famous_players: paths = nx.shortest_path_length(subgraph, source=key).values() print(<span class="hljs-string"><span class="hljs-string">'{}: {} -      '</span></span> .format(famous_players[key], sum(paths) / len(paths)))</code> </pre><br><pre> <code class="plaintext hljs"> : 3.941461876893135 -        : 3.7971107852140182 -        : 3.89353216101753 -        : 3.8634887131481204 -        : 4.1443373857266215 -        : 3.575478680390894 -        : 3.608674497334192 -        : 4.564102739819904 -      </code> </pre><br><p>  Si aflojamos la redacción, entonces la teoría se cumple, en promedio entre expertos en 4-5 niveles de conocidos.  Trazamos cuántas personas están familiarizadas con el conocedor aleatorio A. Druzem directamente, a través de uno, dos, etc.  entendidos </p><br><div class="spoiler">  <b class="spoiler_title">Obtener datos y trazar</b> <div class="spoiler_text"><pre> <code class="python hljs">paths = nx.shortest_path_length(subgraph, source=<span class="hljs-number"><span class="hljs-number">9808</span></span>) neighbours = [<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> paths: neighbours[paths[k]] += <span class="hljs-number"><span class="hljs-number">1</span></span> _count = <span class="hljs-number"><span class="hljs-number">15</span></span> plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">80</span></span>) plt.plot(range(_count),neighbours[:_count],<span class="hljs-string"><span class="hljs-string">'ro-'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># in-degree plt.xlabel(' ', fontsize=18) plt.xticks(range(_count)) plt.ylabel(' ', fontsize=18) plt.title('  .', fontsize=22) plt.show()</span></span></code> </pre> </div></div><br><p>  En el eje X, el grado de conocimiento de A. Druzem (directamente, a través de uno, dos, etc.), en el eje Y, el número de expertos que están familiarizados con A. Druzem de esta manera. </p><br><img src="https://habrastorage.org/webt/fj/tt/sk/fjttskyhdbiw2qrmdux5ug1mnn8.png"><br><h2 id="socialnye-grafy">  Gráficos sociales </h2><br><p>  Porque  construir un gráfico para casi 200 mil personas no es una buena idea, lo haremos más fácil: construiremos el componente de conectividad Kerch y un gráfico de personas asociadas con el autor. </p><br><h3 id="kerchenskaya-komponenta">  Componente Kerch </h3><br><pre> <code class="python hljs">little_v = list(sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]) little = G.subgraph(little_v) plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">200</span></span>) pos = nx.kamada_kawai_layout(little) nx.draw(little, pos=pos, node_size=<span class="hljs-number"><span class="hljs-number">100</span></span>, edge_color=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>, node_color=[val <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (node, val) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> little.degree()], cmap=plt.cm.jet) plt.show()</code> </pre> <br><img src="https://habrastorage.org/webt/_p/tu/k6/_ptuk61dseuqzz0mviea_1jw4iy.png"><br><p>  Puede ver la separación de componentes en equipos.  Además, los equipos están interconectados con la ayuda, por regla general, de uno o dos conocedores sociables.  En el centro hay un núcleo bastante pequeño de expertos que jugaron con una gran cantidad de otros jugadores. </p><br><h3 id="graf-odnogo-cheloveka">  Cuenta de una persona </h3><br><p>  Encontraremos los conocidos más cercanos de una persona y veremos cómo están relacionados.  Para simplificar el gráfico, no agregaremos a la persona (ya está conectado con todos) </p><br><pre> <code class="python hljs">id = <span class="hljs-number"><span class="hljs-number">118622</span></span> ego_graph = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> G.neighbors(id)] <span class="hljs-comment"><span class="hljs-comment">#ego_graph.append(id) ego_graph = G.subgraph(ego_graph) plt.figure(figsize=(24, 16), dpi=200) pos = nx.kamada_kawai_layout(ego_graph) nx.draw(ego_graph, pos=pos, node_size=100, edge_color='gray', node_color=[val for (node, val) in ego_graph.degree()], cmap=plt.cm.jet) plt.show()</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ag/pq/xx/agpqxx0wdbosfslvdrrl0hu_x8u.png"><br><p>  El gráfico es mucho más denso, se puede distinguir un núcleo de 10-15 personas que están familiarizadas entre sí.  El tamaño máximo de clic es 13. </p><br><h2 id="zaklyuchenie">  Conclusión </h2><br><ul><li>  Es mucho más difícil conocer a una persona en el deporte ChGK que en una red social, necesita desconectarse y jugar al menos un torneo.  Al mismo tiempo, los expertos están dispersos por todo el mundo.  Sin embargo, la distancia <strong>promedio</strong> entre expertos es de hecho menos de cinco. </li><li>  El sitio de calificación utiliza <a href="https://rating.chgk.info/players.php%3Fshow_bacon_stats" rel="nofollow">el número Snyatkovsky</a> , que es un análogo <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D0%25BB%25D0%25BE_%25D0%25AD%25D1%2580%25D0%25B4%25D1%2591%25D1%2588%25D0%25B0" rel="nofollow">del número Erdös</a> en el mundo de ChGK.  El propio Sr. Snyatkovsky ocupa el tercer lugar en nuestro ranking de los conocedores más sociables. </li><li>  Código de un artículo en mi <a href="https://github.com/atepaevm/ChGK" rel="nofollow">github</a> . </li><li>  Por sus valiosos comentarios, el autor agradece al White Noise y Who Framed Roger Federer, Mikhail Akulov, Vera Terentyeva y <a href="https://habr.com/ru/users/firemoon/" class="user_link">Firemoon</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/483356/">https://habr.com/ru/post/483356/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../483346/index.html">¿Cómo cambiará blockchain la contabilidad?</a></li>
<li><a href="../483348/index.html">Cómo calcular la "similitud" de los números en los pasaportes. Y encuentra lo mismo incluso con errores tipográficos</a></li>
<li><a href="../483350/index.html">Novedades de nuestra documentación .NET (diciembre de 2019)</a></li>
<li><a href="../483352/index.html">Python en Visual Studio Code - Versión de enero de 2020</a></li>
<li><a href="../483354/index.html">Maldición del segundo mes</a></li>
<li><a href="../483360/index.html">Control de accionamiento eléctrico de potencia. Experiencia amateur</a></li>
<li><a href="../483364/index.html">Puede escribir código en el trabajo para ahorrar su tiempo libre.</a></li>
<li><a href="../483366/index.html">Historial de Internet: redes</a></li>
<li><a href="../483368/index.html">Crear el paquete de archivos x86_64 ELF para Linux</a></li>
<li><a href="../483372/index.html">Cómo entrenar una red neuronal DeepPavlov en una computadora portátil usando una GPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>