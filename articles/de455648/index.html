<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🤝‍👨🏼 🎆 🎓 Lebenszyklus ML 🗽 🔱 🛰️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einer echten ML-Implementierung macht das Lernen selbst ein Viertel des Aufwands aus. Die verbleibenden drei Viertel sind Datenaufbereitung durch S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lebenszyklus ML</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/455648/">  In einer echten ML-Implementierung macht das Lernen selbst ein Viertel des Aufwands aus.  Die verbleibenden drei Viertel sind Datenaufbereitung durch Schmerz und Bürokratie, eine komplexe Bereitstellung, die häufig in einem geschlossenen Kreislauf ohne Internetzugang, Einrichtung der Infrastruktur, Testen und Überwachen erfolgt.  Dokumente auf Hunderten von Blättern, manueller Modus, Modellversionskonflikte, Open Source und hartes Unternehmertum - all dies erwartet einen Datenwissenschaftler.  Aber er ist nicht an solchen „langweiligen“ betrieblichen Problemen interessiert, er möchte einen Algorithmus entwickeln, hohe Qualität erreichen, etwas zurückgeben und sich nicht mehr erinnern. <br><br>  Vielleicht ist ML irgendwo einfacher, einfacher, schneller und mit einem Knopf implementiert, aber wir haben solche Beispiele nicht gesehen.  Alles, was oben steht, ist die Erfahrung von Front Tier in den Bereichen Fintech und Telekommunikation.  Sergey Vinogradov, Experte für die Architektur hoch belasteter Systeme, für große Speicher und für die Analyse schwerer Datenmengen, sprach bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++</a> über ihn. <br><br><img src="https://habrastorage.org/webt/ss/7n/cm/ss7ncmtdsij0wncwt-uuzxneit8.jpeg"><br><a name="habracut"></a><br><h2>  Modelllebenszyklus </h2><br>  Normalerweise besteht der Lebenszyklus in unserem Fachgebiet aus drei Teilen.  Im ersten <strong>Fall kommt eine Aufgabe aus dem Geschäft</strong> .  Im zweiten <strong>Schritt bereiten</strong> ein <strong>Dateningenieur und / oder ein Datenwissenschaftler Daten vor</strong> und erstellen ein Modell.  Im dritten Teil beginnt das <strong>Chaos</strong> .  In den letzten beiden Fällen treten unterschiedliche interessante Situationen auf. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7GM9ac6ojtw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h3>  Alleskönner </h3><br>  Die erste häufige Situation ist, dass ein Datenwissenschaftler oder Dateningenieur Zugriff auf die Produkte hat, und sie sagen zu ihm: "Sie haben das alles getan, Sie wetten darauf." <br><br>  Eine Person nimmt ein <strong>Jupyter-Notizbuch</strong> oder ein Bündel von Notizbüchern, betrachtet sie ausschließlich als Bereitstellungsartefakt und beginnt auf einigen Servern freudig zu replizieren. <br><br>  Alles scheint in Ordnung zu sein, aber nicht immer.  Ich werde dir später sagen warum. <br><br><h3>  Gnadenlose Ausbeutung </h3><br>  Die zweite Geschichte ist komplizierter und findet normalerweise in Unternehmen statt, in denen die Ausbeutung einen Zustand leichten Wahnsinns erreicht hat.  Data Scientist bringt seine Lösung in Betrieb.  Sie öffnen diese Black Box und sehen etwas Schreckliches: <br><br><ul><li>  Notizbücher </li><li>  Essiggurke verschiedener Versionen; </li><li>  Haufen von Skripten: Es ist nicht klar, wo und wann sie ausgeführt werden sollen und wo die von ihnen generierten Daten gespeichert werden sollen. </li></ul><br>  In diesem Puzzle stößt die Ausnutzung auf Versionsinkompatibilität.  Beispielsweise hat ein Datenwissenschaftler keine bestimmte Version der Bibliothek angegeben, und die Operation wurde spätestens ausgeführt.  Nach einer Weile greift der Datenwissenschaftler zurück: <br><br>  <em>- Sie haben scikit-learn auf die falsche Version eingestellt, jetzt sind alle Metriken weg!</em>  <em>Sie müssen auf die vorherige Version zurücksetzen.</em> <br><br>  Dies bricht den Stoß vollständig und die Ausbeutung leidet. <br><br><h3>  Bürokratie </h3><br>  In Unternehmen mit grünen Logos erhält der Datenwissenschaftler, wenn er in Betrieb genommen wird und das Modell mitbringt, normalerweise ein 800-Blatt-Dokument als Antwort: „Befolgen Sie diese Anweisung, sonst wird Ihr Produkt nie das Licht der Welt erblicken.“ <br><br>  Der traurige Datenwissenschaftler geht, wirft alles auf die Hälfte und gibt dann auf - er ist nicht daran interessiert. <br><br><h3>  Bereitstellen </h3><br>  Angenommen, ein Datenwissenschaftler hat alle Kreise durchlaufen und am Ende wurde alles bereitgestellt.  Aber er wird nicht verstehen können, dass alles so funktioniert, wie es sollte.  Nach meiner Erfahrung gibt es in denselben gesegneten Banken keine Überwachung von Data-Science-Produkten. <br><br>  Es ist gut, wenn der Spezialist die Ergebnisse seiner Arbeit in die Datenbank schreibt.  Nach einer Weile wird er sie empfangen und sehen, was im Inneren passiert.  Dies ist jedoch nicht immer der Fall.  Wenn ein Unternehmen und ein Datenwissenschaftler einfach glauben, dass alles gut und gut funktioniert, führt dies zu erfolglosen Fällen. <br><br><h3>  MFI </h3><br>  Irgendwie haben wir eine Scoring-Engine für eine große Mikrofinanzorganisation entwickelt.  Sie ließen uns nicht zum Produkt gehen, sondern nahmen uns einfach eine Kaskade von Modellen ab, installierten sie und starteten sie.  Die Testergebnisse der Modelle haben sie zufriedengestellt.  Aber nach 6 Monaten kamen sie zurück: <br><br>  <em>- Alles ist schlecht.</em>  <em>Das Geschäft läuft nicht, wir werden immer schlechter.</em>  <em>Es scheint, dass die Modelle ausgezeichnet sind, aber die Ergebnisse fallen, Betrug und Ausfall immer mehr und weniger Geld.</em>  <em>Wofür haben wir dich bezahlt?</em>  <em>Lass es uns richtig machen.</em> <br><br>  Gleichzeitig wird wieder kein Zugriff auf das Modell gewährt.  Die Protokolle wurden vor sechs Monaten für einen Monat entladen.  Wir haben das Entladen für einen weiteren Monat untersucht und sind zu dem Schluss gekommen, dass die IT-Abteilung des MFI irgendwann die Eingabedaten geändert hat und anstelle von Dokumenten in JSON begonnen hat, Dokumente in XML zu senden.  Das Modell erwartete json, erhielt aber XML, war traurig und dachte, dass es keine Daten an der Eingabe gab. <br><br><blockquote>  Wenn keine Daten vorliegen, ist die Einschätzung des Geschehens anders.  Ohne Überwachung kann dies nicht erkannt werden. </blockquote><br><h3>  Neue Version, Kaskade und Tests </h3><br>  Oft sind wir mit der Tatsache konfrontiert, dass das Modell gut funktioniert, aber aus irgendeinem Grund wurde eine <strong>neue Version</strong> entwickelt.  Das Modell muss wieder irgendwie hereingebracht werden und wieder durch alle Kreise der Hölle gehen.  Es ist gut, wenn die Bibliotheksversionen mit denen des Vorgängermodells identisch sind. Wenn nicht, beginnt die Bereitstellung von neuem ... <br><br>  Manchmal möchten wir eine neue Version <strong>testen,</strong> bevor wir <strong>sie</strong> in den Kampf ziehen. Legen <strong>Sie</strong> sie auf den <strong>Prüfstand</strong> , sehen Sie sich denselben Verkehrsstrom an und stellen Sie sicher, dass sie gut ist.  Dies ist wieder die vollständige Bereitstellungskette.  Darüber hinaus haben wir die Systeme so eingerichtet, dass nach diesem Modell keine realen Ergebnisse erzielt werden, wenn es um die Bewertung geht, sondern nur die Ergebnisse zur weiteren Analyse überwacht und analysiert wurden. <br><br>  Es gibt Situationen, in denen eine <strong>Modellkaskade verwendet wird.</strong>  Wenn die Ergebnisse der folgenden Modelle von den vorherigen abhängen, müssen Sie irgendwie eine Interaktion zwischen ihnen herstellen und dies alles irgendwo behalten. <br><br><h2>  Wie löse ich solche Probleme? </h2><br>  Oft löst eine Person Probleme <strong>manuell</strong> , insbesondere in kleinen Unternehmen.  Er weiß, wie alles funktioniert, denkt an alle Versionen von Modellen und Bibliotheken, weiß, wo und welche Skripte funktionieren, welche Storefronts sie erstellen.  Das ist alles wunderbar.  Besonders schön sind die Geschichten, die der manuelle Modus hinterlässt. <br><br>  <strong>Die Geschichte des Erbes</strong> .  Ein guter Mann arbeitete in einer kleinen Bank.  Einmal ging er in ein südliches Land und kehrte nicht zurück.  Danach haben wir eine Vererbung erhalten: eine Reihe von Code, der Storefronts generiert, an denen Modellmodelle arbeiten.  Der Code ist wunderschön, er funktioniert, aber wir kennen nicht die genaue Version des Skripts, das diese oder jene Storefront generiert.  In der Schlacht sind alle Schaufenster vorhanden und alle werden gestartet.  Wir haben zwei Monate lang versucht, dieses komplizierte Gewirr zu erkennen und es irgendwie zu strukturieren. <br><br>  <strong>In einem harten Unternehmen</strong> wollen sich die Leute nicht mit allen Arten von Python, Jupitern usw. beschäftigen. Sie sagen: <br><br>  <em>- Kaufen wir IBM SPSS, installieren und alles wird großartig.</em>  <em>Probleme mit der Versionierung, mit Datenquellen, mit der Bereitstellung dort irgendwie gelöst.</em> <br><br>  Dieser Ansatz hat ein Existenzrecht, aber nicht jeder kann es sich leisten.  In jedem Fall ist dies eine so hochwertige gezackte Nadel.  Sie sitzen darauf, aber es klappt nicht, auszusteigen - Kerben.  Und es kostet normalerweise viel. <br><br>  <strong>Open Source ist das</strong> Gegenteil des vorherigen Ansatzes.  Die Entwickler surften im Internet und fanden viele Open Source-Lösungen, die ihre Aufgaben in unterschiedlichem Maße lösen.  Dies ist ein großartiger Weg, aber für uns selbst haben wir keine Lösungen gefunden, die unsere Anforderungen zu 100% erfüllen. <br><br>  Deshalb haben wir uns für die klassische Option entschieden - <strong>unsere Entscheidung</strong> .  Seine Krücken, Fahrräder, alle ihre eigenen, einheimischen. <br><br><h2>  Was wollen wir von unserer Entscheidung? </h2><br><br>  <strong>Schreiben Sie nicht alles selbst</strong> .  Wir möchten Komponenten, insbesondere Infrastrukturkomponenten, verwenden, die sich bewährt haben und mit der Funktionsweise in den Institutionen vertraut sind, mit denen wir zusammenarbeiten.  Wir schreiben nur eine Umgebung, die die Arbeit des Datenwissenschaftlers leicht von der Arbeit von DevOps isoliert. <br><br>  <strong>Verarbeiten Sie Daten in zwei Modi: sowohl im Batch-Modus - Batch als auch in Echtzeit</strong> .  Unsere Aufgaben umfassen beide Betriebsarten. <br><br>  <strong>Einfache Bereitstellung und in einem geschlossenen Umkreis</strong> .  Bei der Arbeit mit vertraulichen privaten Daten besteht keine Internetverbindung.  Zu diesem Zeitpunkt sollte alles schnell und genau zur Produktion gelangen.  Aus diesem Grund haben wir uns mit Gitlab, der darin enthaltenen CI / CD-Pipeline und Docker befasst. <br><br><blockquote>  Ein Modell ist kein Selbstzweck.  Wir lösen nicht das Problem des Modellbaus, sondern ein Geschäftsproblem. </blockquote><br>  Innerhalb der Pipeline müssen Regeln und ein Konglomerat von Modellen vorhanden sein, die die <strong>Versionierung aller</strong> Pipelinekomponenten unterstützen. <br><br>  Was ist mit Pipeline gemeint?  In Russland ist das Bundesgesetz 115 zur Bekämpfung der Geldwäsche und der Finanzierung des Terrorismus in Kraft.  Nur das Inhaltsverzeichnis der Empfehlungen der Zentralbank belegt 16 Bildschirme.  Dies sind einfache Regeln, die eine Bank erfüllen kann, wenn sie über solche Daten verfügt, oder nicht, wenn sie keine Daten hat. <br><br>  Die Bewertung eines Kreditnehmers, einer Finanztransaktion oder eines anderen Geschäftsprozesses ist ein Datenstrom, den wir verarbeiten.  Ein Stream muss diese Art von Regel durchlaufen.  Diese Regeln werden vom Analysten auf einfache Weise beschrieben.  Er ist kein Datenwissenschaftler, kennt aber das Gesetz oder andere Anweisungen gut.  Der Analyst setzt sich und beschreibt im Klartext die Überprüfung der Daten. <br><br>  <strong>Erstellen Sie Kaskaden von Modellen</strong> .  Oft entsteht eine Situation, in der das nächste Modell die in früheren Modellen erhaltenen Werte für seine Arbeit verwendet. <br><br>  <strong>Testen Sie Hypothesen schnell.</strong>  Ich wiederhole die vorherige These: Ein Datenwissenschaftler hat eine Art Modell erstellt, es dreht sich im Kampf und funktioniert gut.  Aus irgendeinem Grund hat der Spezialist eine bessere Lösung gefunden, möchte aber den etablierten Workflow nicht ruinieren.  Der Datenwissenschaftler hängt ein neues Modell an denselben Kampfverkehr im Kampfsystem.  Sie beteiligt sich nicht direkt an der Entscheidungsfindung, sondern bedient denselben Verkehr, berücksichtigt einige Schlussfolgerungen und diese Schlussfolgerungen werden irgendwo gespeichert. <br><br>  <strong>Einfache Wiederverwendungsfunktion.</strong>  Viele Aufgaben haben den gleichen Komponententyp, insbesondere diejenigen, die sich auf das Extrahieren von Features oder Regeln beziehen.  Wir möchten diese Komponenten in andere Pipelines ziehen. <br><br><h2>  Was hast du beschlossen zu tun? </h2><br>  Zuerst wollen wir überwachen.  Und zwei seiner Art. <br><br><h3>  Überwachung </h3><br>  <strong>Technische Überwachung.</strong>  Wenn Pipeline-Komponenten bereitgestellt werden, sollten sie im Betrieb sehen, was mit der Komponente passiert: wie sie Speicher, CPU und Festplatte verbraucht. <br><br>  <strong>Geschäftsüberwachung.</strong>  Dies ist ein Tool für Datenwissenschaftler, mit dem Sie von den technischen Nuancen der Implementierung abstrahieren können.  Auf der Entwurfsebene hilft die Konstruktion dabei, zu bestimmen, welche Modellmetriken für die Überwachung verfügbar sein sollen, z. B. die Verteilung von Features oder die Bewertung von Serviceergebnissen. <br><br>  Ein Datenwissenschaftler definiert Metriken und sollte sich keine Gedanken darüber machen, wie sie in das Überwachungssystem gelangen.  Das einzig Wichtige ist, dass er diese Metriken und das Erscheinungsbild des Dashboards definiert hat, auf dem die Metriken angezeigt werden.  Dann startete der Spezialist alles in der Produktion, setzte es ein und nach einer Weile flossen die Metriken in die Überwachung ein.  Ein Datenwissenschaftler ohne Zugriff auf das Produkt kann also sehen, was im Modell geschieht. <br><br><h3>  Testen </h3><br>  Testen Sie die <strong>Pipeline auf Konsistenz</strong> .  Angesichts der Besonderheiten der Pipeline ist dies eine Art Rechengraph.  Wir wollen verstehen, dass wir ein Diagramm implementieren, wir können es umgehen und einen Ausweg finden. <br><br>  Das Diagramm enthält Komponenten - Module.  Alle Module müssen den Unit- und Integrationstest bestehen.  Der Prozess sollte für einen Datenwissenschaftler transparent und einfach sein. <br><br>  Der Entwickler beschreibt das Modell und testet es alleine oder mit Hilfe eines anderen.  Fügt alles in Gitlab ein, die durch Continuous Integration konfigurierte Pipeline wird ausgelöst, getestet und sieht Ergebnisse.  Wenn alles gut ist - es geht weiter, nein - es beginnt von neuem. <br><br>  Der Datenwissenschaftler konzentriert sich auf das Modell und weiß nicht, was sich unter der Haube befindet.  Dafür bekommt er mehrere Dinge. <br><br><ul><li>  <strong>Eine API zur Integration in den Kern des</strong> <strong>Systems selbst</strong> über den Datenbus - Nachrichtenbus.  In diesem Fall muss der Spezialist beschreiben, was in seinem Modell, dem Einstiegspunkt und der Verbindung mit verschiedenen Komponenten innerhalb der Pipeline ein- und ausgeht. </li><li>  Nach dem Training des Modells wird ein <strong>Artefakt</strong> angezeigt <strong>- eine XGBoost-</strong> oder <strong>Pickle-</strong> <strong>Datei</strong> .  Der Datenwissenschaftler hat einen Executer für die Arbeit mit Artefakten - er muss die Pipelinekomponenten in das System integrieren. </li><li>  Einfache und transparente API für Datenwissenschaftler zur Überwachung des Betriebs von Pipelinekomponenten - technische und geschäftliche Überwachung. </li><li>  <strong>Eine einfache und transparente Infrastruktur</strong> zur Integration in Datenquellen und zur Erhaltung der Arbeitsergebnisse. </li></ul><br>  Oft arbeiten Modelle für uns, und nach einer Weile kommt ein Audit, das die gesamte Geschichte des Dienstes auffrischen möchte.  Das Audit möchte die Richtigkeit der Arbeit und die Abwesenheit von Betrug unsererseits überprüfen.  Es werden einfache Tools benötigt, damit jeder Auditor, der sich mit SQL auskennt, in ein spezielles Repository gelangen und sehen kann, wie alles funktioniert, welche Entscheidungen getroffen wurden und warum. <br><br>  Wir haben den Grundstein für zwei wichtige Geschichten für uns gelegt. <br><br>  <strong>Customer Journey.</strong>  Dies ist eine Gelegenheit, die Mechanismen zur Aufbewahrung der gesamten Kundenhistorie zu nutzen - was mit dem Kunden als Teil der Geschäftsprozesse passiert ist, die auf diesem System implementiert sind. <br><br>  Möglicherweise verfügen wir über externe Datenquellen, z. B. DMP-Plattformen.  Von ihnen erhalten wir Informationen über menschliches Verhalten im Netzwerk und auf mobilen Geräten.  Dies kann sich auf den LTV und die Bewertungsmodelle seines Modells auswirken.  Wenn der Kreditnehmer zu spät bezahlt, können wir vorhersagen, dass dies keine böswillige Absicht ist - es gibt einfach Probleme.  In diesem Fall wenden wir weiche Expositionsmethoden gegenüber dem Kreditnehmer an.  Wenn die Probleme behoben sind, schließt der Kunde das Darlehen.  Wenn er das nächste Mal kommt, werden wir seine ganze Geschichte kennen.  Datenwissenschaftler erhalten eine visuelle Historie aus dem Modell und führen die Bewertung im Lichtmodus durch. <br><br>  <strong>Identifizierung von Anomalien</strong> .  Wir sind ständig mit einer sehr komplexen Welt konfrontiert.  Beispielsweise können Schwachstellen bei der beschleunigten Bewertung von MFIs eine Quelle für automatischen Betrug sein. <br><br>  Customer Journey ist ein Konzept für den schnellen und einfachen Zugriff auf den Datenstrom, der das Modell durchläuft.  Das Modell macht es einfach, Anomalien zu erkennen, die zum Zeitpunkt des Massenauftretens für Betrug charakteristisch sind. <br><br><h2>  Wie ist alles angeordnet? </h2><br>  Ohne zu zögern haben wir <strong>Kafka</strong> als Message Bus Patch genommen.  Dies ist eine gute Lösung, die von vielen unserer Kunden verwendet wird. Der Betrieb kann damit arbeiten. <br><br><img src="https://habrastorage.org/webt/uu/5k/3r/uu5k3rnxw7lu4iulruewhzmif8w.jpeg"><br><br><blockquote>  Einige Systemkomponenten werden möglicherweise bereits im Unternehmen selbst verwendet.  Wir bauen das System nicht erneut auf, sondern verwenden das, was sie bereits haben. </blockquote><br>  <strong>Datenspeicherung ist</strong> in diesem Fall der Speicher, über den der Client normalerweise bereits verfügt.  Dies können Hadoop-, relationale und nicht relationale Datenbanken sein.  Wir können mit HDFS, Hive, Impala, Greenplum und PostgreSQL sofort arbeiten.  Wir betrachten diese Speicher als Quelle für Schaufenster. <br><br>  Daten kommen im Lager an, durchlaufen unsere ETL oder die ETL des Kunden, falls er eine hat.  Wir bauen Schaufenster, die in Modellen weiter verwendet werden.  Die Datenspeicherung wird im schreibgeschützten Modus verwendet. <br><br><h3>  Unsere Entwicklungen </h3><br>  <strong>Tafel</strong>  Der Name stammt von einer ziemlich seltsamen Praxis von Mathematikern der 30-40er Jahre.  Dies ist der Manager von Pipelines, die im Administrationssystem leben.  Blackboard hat eine Art Meta-Speicher.  Es speichert die Pipelines selbst und die Konfigurationen, die zum Initialisieren aller Komponenten erforderlich sind. <br><br>  Alle Systemarbeiten beginnen mit der Tafel.  Wie durch ein Wunder landete die Pipeline in Meta Storage, Blackboard hat dies nach einer Weile verstanden, zieht die aktuelle Version der Pipeline heraus, initialisiert sie und sendet ein Signal in Kafka. <br><br>  Es gibt eine <strong>Laufzeitumgebung</strong> .  Es basiert auf Dockern und kann auf Server repliziert werden, auch in der privaten Cloud des Kunden. <br><br>  Aus der Box kommt der <strong>Hauptdarsteller :: Init</strong> - dies ist der Initialisierer.  Dies ist ein Geist, der nur zwei Dinge tun kann: <strong>Komponenten</strong> <strong>bauen</strong> und <strong>zerstören</strong> .  Er erhält einen Befehl von Blackboard: "Hier ist die Pipeline, sie muss auf solchen und solchen Servern mit solchen und solchen Ressourcen in solchen und solchen Mengen gestartet werden - Arbeit!"  Dann beginnt der Schauspieler alles. <br><br>  Mathematisch gesehen ist ein Akteur eine Funktion, die ein oder mehrere Objekte als Eingabe verwendet, den Status von Objekten mithilfe eines darin enthaltenen Algorithmus ändert, am Ausgang ein neues Objekt generiert oder den Status eines vorhandenen Objekts ändert. <br><br>  Technisch gesehen ist ein Schauspieler ein Python-Programm.  Läuft in einem Docker-Container mit seiner Umgebung. <br><br>  Der Schauspieler weiß nichts über die Existenz anderer Schauspieler.  Die einzige Entität, die weiß, dass zusätzlich zum Akteur die gesamte Pipeline als Ganzes existiert - dies ist Blackboard.  Es überwacht den Ausführungsstatus aller Akteure innerhalb des Systems und behält den aktuellen Status bei, der sich in der Überwachung als Bild des gesamten Geschäftsprozesses als Ganzes ausdrückt. <br><br>  Actor :: Init erzeugt viele Docker-Container.  Darüber hinaus können Akteure mit der Datenspeicherung arbeiten. <br><br>  Das System selbst verfügt über eine <strong>Ereignisspeicherkomponente</strong> .  Als Ereignisspeicher verwenden wir <strong>ClickHouse</strong> .  Die Aufgabe ist einfach: Alle Informationen, die zwischen dem Schauspieler über Kafka ausgetauscht werden, werden in ClickHouse gespeichert.  Dies erfolgt <strong>zur weiteren Prüfung</strong> .  Dies ist das Pipeline-Betriebsprotokoll. <br><br>  Schauspieler können auch für <strong>Customer Journey entwickelt werden</strong> .  Sie sehen Änderungen im Pipeline-Protokoll und können im laufenden Betrieb die Fenster neu erstellen, die erforderlich sind, damit Modelle oder Komponenten mit den Regeln arbeiten können, die sich bereits in der Pipeline befinden.  Dies ist ein fortlaufender Prozess zum Ändern von Daten. <br><br>  Die Überwachung basiert eher primitiv auf <strong>Prometheus</strong> .  Der Akteur erhält eine grundlegende API und sendet in einem geschlossenen Modus, der für den Entwickler transparent genug ist, Nachrichten mit Metriken an Kafka.  Prometheus liest Metriken aus Kafka und speichert sie in seinem Repository. <br><br>  Zur Visualisierung verwenden wir <strong>Grafana</strong> . <br><br><h3>  Zwei Integrationspunkte </h3><br>  Der erste ist der Punkt der Integration mit Datenquellen, die über ETLs zum Data Warehouse gelangen.  Der zweite Integrationspunkt, wenn ein Dienst bereits von einem Datenkonsumenten verwendet wird, z. B. ein Scoring-Dienst. <br><br>  Wir haben <strong>Apache ServiceMix genommen.</strong>  Erfahrungsgemäß sind diese Integrationspunkte vom gleichen Typ mit demselben Protokolltyp: SOAP, RESTful, seltener Warteschlangen.  Jedes Mal möchten wir keinen eigenen Konstruktor oder Service entwickeln, um den nächsten SOAP-Service zu generieren.  Daher nehmen wir ServiceMix und beschreiben es in der SDL, in der die Datenmodelle dieses Dienstes und die darin vorhandenen Methoden erstellt werden.  Dann schieben wir den Router in ServiceMix durch und er generiert den Service selbst. <br><br>  Von uns selbst haben wir eine schwierige Synchron-Asynchron-Konvertierung hinzugefügt.  Alle Anforderungen, die im System gespeichert sind, sind asynchron und werden über den Nachrichtenbus gesendet. <br><br>  Die meisten Bewertungsdienste sind synchron.  ServiceMix-Anforderungen kommen entweder über REST oder SOAP.  Zu diesem Zeitpunkt durchläuft er unser Gateway, das das Wissen über die HTTP-Sitzung beibehält.  Dann sendet er eine Nachricht an Kafka, sie läuft durch eine Pipeline und eine Lösung wird generiert. <br><br>  Möglicherweise gibt es jedoch noch keine Lösung.  Zum Beispiel ist etwas abgefallen oder es gibt eine schwierige SLA, um eine Entscheidung zu treffen, und Gateway überwacht: "OK, ich habe eine Anfrage erhalten, er ist in einem anderen Kafka-Thema zu mir gekommen, oder es ist nichts zu mir gekommen, aber mein Timeout-Auslöser hat funktioniert."  Andererseits erfolgt die Konvertierung von synchron zu asynchron, und innerhalb derselben HTTP-Sitzung gibt es eine Antwort an den Verbraucher mit dem Ergebnis der Arbeit.  Dies kann ein Fehler oder eine normale Prognose sein. <br><br>  An diesem Ort haben wir übrigens dank der großartigen und leistungsstarken Open Source einen geschmacklosen Hund gefressen.  Wir haben ServiceMix aus einer der neuesten Versionen und Kafka aus früheren Versionen verwendet und alles hat perfekt funktioniert.  Wir haben in diesem Gateway geschrieben, basierend auf den Cubes, die bereits in ServiceMix enthalten waren.  Als die neue Version von Kafka herauskam, haben wir sie gerne aufgenommen, aber es stellte sich heraus, dass sich die Unterstützung für die Überschriften in der zuvor existierenden Nachricht in Kafka geändert hatte.  Das Gateway in ServiceMix kann nicht mehr mit ihnen arbeiten.  Um dies zu verstehen, haben wir viel Zeit verbracht.  Aus diesem Grund haben wir unser Gateway erstellt, das mit neuen Versionen von Kafka kompatibel ist.  Wir haben den ServiceMix-Entwicklern über das Problem geschrieben und die Antwort erhalten: "Danke, wir werden Ihnen in den nächsten Versionen definitiv helfen!" <br><br>  Daher sind wir gezwungen, Aktualisierungen zu überwachen und regelmäßig etwas zu ändern. <br><br>  <strong>Infrastruktur ist Gitlab.</strong>  Wir verwenden fast alles, was darin enthalten ist. <br><br><ul><li>  Code-Repository. </li><li>  Setzt die Integration fort / setzt die Lieferpipeline fort. </li><li>  Registrierung zum Verwalten einer Registrierung von Docker-Containern. </li></ul><br><h3>  Komponenten </h3><br>  Wir haben 5 Komponenten entwickelt: <br><br><ul><li>  <strong>Blackboard</strong> - Pipeline-Lebenszyklusmanagement.  Wo, was und mit welchen Parametern soll von der Pipeline ausgeführt werden. </li><li>  <strong>Der Feature-Extraktor</strong> funktioniert einfach - wir informieren den Feature-Extraktor darüber, dass wir an der Eingabe ein solches und ein solches Datenmodell erhalten, wählen die erforderlichen Felder aus den Daten aus und ordnen sie bestimmten Werten zu.  Zum Beispiel erhalten wir das Geburtsdatum des Kunden, konvertieren es in das Alter und verwenden es als Funktion in unserem Modell.  Der Feature-Extraktor ist für die Datenanreicherung verantwortlich. </li><li>  <strong>Regelbasierte Engine</strong> - Überprüfung der Daten gemäß den Regeln.  Dies ist eine einfache Beschreibungssprache, mit der eine Person, die mit der Konstruktion von &lt;code&gt; if, else &lt;code /&gt; -Blöcken vertraut ist, die Regeln für die Überprüfung innerhalb des Systems beschreiben kann. </li><li>  <strong>Machine Learning Engine</strong> - Ermöglicht es Ihnen, den Executor auszuführen, das trainierte Modell zu initialisieren und es an die Eingabedaten zu senden.  Am Ausgang nimmt das Modell Daten auf. </li><li>  <strong>Entscheidungsmodul</strong> - Entscheidungsmodul, Verlassen des Diagramms.  Wenn Sie eine Kaskade von Modellen haben, zum Beispiel verschiedene Zweige der Kreditnehmerbewertung, müssen Sie sich irgendwo für das Thema Geld entscheiden.  Das Regelwerk für die Lösung sollte einfach sein. ,     LTV- —     ,     ,  . </li></ul><br><br><h3>   </h3><br>         .  —  ,    .  —      ,      . <br><br>   pipeline    . <br><img src="https://habrastorage.org/webt/o7/vy/dj/o7vydjrruyfittwhwzumh_gc_rq.jpeg"><br><ul><li>   <strong>Feature extractor</strong> :  ,        ,      . </li><li> <strong> </strong> . ,  -:  , ,       18. </li><li>  <strong> .</strong>    ,    .     ,      ,        pipeline. </li><li>  <strong>Decision engine</strong> .             . </li><li>  <strong></strong> . </li></ul><br>      yaml.         .    ,  ,        .           yaml. <br><br>  pipeline,   ,   : feature extractor, rules, models, decision engine,    .   — <strong>      Docker-</strong> .    Registry,   Docker-. -,   ,    . ,  ,      Docker-       . <br><br><h3>  Pipeline </h3><br>     ,     <strong>Python</strong> —         . Feature extractor, ,   decision engine   Python. <br><br> Pipeline   <strong>yaml.</strong>      meta storage     —   <strong></strong> . <br><br>  Runtime environment   10 ,  Blackboard  ,    pipeline    10 .  ,      : , , IP-    Kafka, , .       . <br><br>     GitLab.      Ansible. ,    .           ,      50 000    Ansible  . <br><br><h2>   ? </h2><br>  GitLab  pipeline.    GitLab. CI  ,   ,  ,  .   <strong>GitLab Runner</strong> ,    Docker-  ,    pipeline.    —    Registry. <br><br><img src="https://habrastorage.org/webt/gz/dx/hr/gzdxhruymhjm2_wejqybqizdp0i.jpeg"><br><br>  Docker  ,       .   Docker-        .   CI pipeline    pipeline  -  Meta Storage,    Blackboard. <br><br> Blackboard    Meta Storage —   , , ,   -.   Docker-     , , . <br><br> -   Blackboard  Meta Storage      :   ,  Kafka,   .  ,    ,   Docker-    ,     . <br><br>  ,    Docker-,  — pipeline ! <br><br>      DigitalOcean.     AWS  Scaleway,     . <br><br>    ,        .  pipeline         . ,    . <br><br><h3>    ? </h3><br>   —   .  ,   pipeline,     real-time   . <br><br><ul><li> 2 Feature extractor  .     1 , .. json    . </li><li> 8  — 8  ML engine.      XGBoost. </li><li> 18     RB engine (115 ).   1000     . </li><li> 1 decision engine. </li></ul><br>       200   .  2 Feature extractor, 8 , 18   1 decision engine      1,2 . <br><br><h3>  </h3><br> <strong>Discovery .</strong>  ,   -   .  ,      ,    .    .      Meta Storage. <br><br> <strong>  pipeline</strong> .    ,  <strong>BPM</strong> .        yaml      ,     ,      . <br><br> <strong>    .</strong>       Java, Scala, R.    Python,       ,     .    API   ,   pipeline      . <br><br><h2>  Was ist das Ergebnis? </h2><br>    —     .    —   .   <strong> </strong> ,      .  ,         .     —     2018 . <br><br>         ,      .    —    ,   ,    . <br><br> <strong>    ,   </strong> .     ,    ,    notebook   ,     . <br><br><blockquote> , -      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,           .  ,     , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UseData Conf</a> .  ,    ,       ,   16 . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455648/">https://habr.com/ru/post/de455648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455638/index.html">Alan Kay hat keine Objekte erfunden</a></li>
<li><a href="../de455640/index.html">Marvin Minskys „The Emotion Machine“: Kapitel 4. „Wie wir Bewusstsein erkennen“</a></li>
<li><a href="../de455642/index.html">Die Architektur des verteilten Nachrichtenwarteschlangendienstes in Yandex.Cloud</a></li>
<li><a href="../de455644/index.html">Wir verwenden Daten in der Praxis</a></li>
<li><a href="../de455646/index.html">Sicherheitswoche 24: Werks-Backdoors auf Android-Smartphones</a></li>
<li><a href="../de455650/index.html">Wie wir ein neuronales Netzwerk trainiert haben, um Schrauben zu klassifizieren</a></li>
<li><a href="../de455652/index.html">Deep Learning gegen gesunden Menschenverstand: Entwicklung eines Chat-Bots</a></li>
<li><a href="../de455658/index.html">Legendärer Intel Core i7-2600K: Testen von Sandy Bridge im Jahr 2019 (Teil 3)</a></li>
<li><a href="../de455662/index.html">Großes mechanisches Display mit Nockenmechanismus als Decoder</a></li>
<li><a href="../de455666/index.html">Aufbau von Outbound Sales in einem IT-Service-Unternehmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>