<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìñ üôèüèΩ üíü L'utilisation de BSP dans Doom est-elle vraiment une initiative ing√©nieuse? üë∏üèΩ üë®üèΩ‚Äç‚öïÔ∏è üñ±Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le summum de la technologie de l'√©poque. 

 En 1993, id Software a sorti Doom , un jeu de tir √† la premi√®re personne qui s'est rapidement transform√© e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L'utilisation de BSP dans Doom est-elle vraiment une initiative ing√©nieuse?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482614/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/268/1a6/7cd/2681a67cd1d82d83879143c036a95ca4.jpg"></div><br>  <i>Le summum de la technologie de l'√©poque.</i> <br><br>  En 1993, id Software a sorti <em>Doom</em> , un jeu de tir √† la premi√®re personne qui s'est rapidement transform√© en ph√©nom√®ne.  Aujourd'hui, on pense que c'est l'un des jeux qui a eu le plus grand impact dans l'histoire. <br><br>  Dix ans apr√®s la sortie de <em>Doom</em> , en 2003, le journaliste David Kouchner a publi√© un livre d'id Software intitul√© <a rel="nofollow" href="https://www.amazon.com/dp/0812972155/%3Ftag%3Darstech20-20"><em>Masters of Doom</em></a> , qui est depuis devenu une description canonique du processus de cr√©ation de <em>Doom</em> .  J'ai lu <em>Masters of Doom il y a</em> quelques ann√©es et je ne me souviens de presque rien, mais une histoire d'un livre sur le programmeur principal John Carmack a √©t√© conserv√©e dans ma m√©moire.  Ma description ne sera pas enti√®rement exacte (voir ci-dessous pour plus de d√©tails), mais en bref, au d√©but du d√©veloppement de <em>Doom</em> , Carmack s'est rendu compte que le rendu 3D qu'il avait √©crit pour le jeu commen√ßait √† ralentir lors du rendu de certains niveaux.  C'√©tait inacceptable, car <em>Doom</em> devait devenir un jeu actif et m√™me effr√©n√©.  R√©alisant que le probl√®me du moteur de rendu √©tait si fondamental qu'il devrait chercher un algorithme de rendu plus optimal, Carmack a commenc√© √† lire des articles de recherche.  En cons√©quence, il a mis en ≈ìuvre une technique appel√©e partitionnement d'espace binaire (BSP), qui n'avait jamais √©t√© utilis√©e auparavant dans les jeux vid√©o, et a ainsi consid√©rablement acc√©l√©r√© le moteur <em>Doom</em> . <br><br>  Cette histoire de la fa√ßon dont Carmack a appliqu√© la recherche scientifique de pointe aux jeux vid√©o m'a toujours impressionn√©.  √Ä mon avis, c'est gr√¢ce √† cela que Carmack est devenu une figure si l√©gendaire.  Il m√©rite d'√™tre connu comme un brillant programmeur de jeux vid√©o arch√©typal pour de nombreuses raisons, mais en tant que principal, je me souviens toujours de l'√©pisode avec la lecture d'articles scientifiques et la partition binaire de l'espace. <br><a name="habracut"></a><br>  De toute √©vidence, cette histoire est impressionnante, car le terme ¬´partition binaire de l'espace¬ª semble √™tre quelque chose de compliqu√© non seulement pour la mise en ≈ìuvre, mais m√™me pour la compr√©hension.  Pendant longtemps, j'ai suppos√© que Carmack avait fait un bond intellectuel, mais comme je ne savais pas ce qu'est une partition binaire de l'espace et √† quel point cette technique √©tait nouvelle lorsque Carmack a d√©cid√© de l'utiliser, je n'√©tais pas compl√®tement s√ªr.  Quelle a √©t√© l'ing√©niosit√© de l'ajout d'une partition d'espace binaire √† <em>Doom</em> √† une √©chelle allant d'Homer Simpson √† Albert Einstein? <br><br>  Je me suis √©galement demand√© d'o√π venait le BSP et comment l'id√©e est arriv√©e √† Carmack.  Par cons√©quent, ce poste sera consacr√© non seulement √† John Carmack et <em>Doom</em> , mais √©galement √† l'historique de la structure des donn√©es de ¬´l'arbre de partition d'espace binaire¬ª (ou arbre BSP).  Il s'est av√©r√© que l'arbre BSP, comme de nombreux autres aspects des sciences informatiques, trouve son origine dans des recherches men√©es pour l'arm√©e. <br><br>  Oui, c'est vrai: E1M1, le premier niveau <em>Doom</em> , est apparu gr√¢ce √† l'US Air Force. <br><br><h2>  T√¢che VSD </h2><br>  L'arbre BSP est une solution √† l'une des t√¢ches les plus difficiles en infographie.  Pour rendre une sc√®ne en trois dimensions, le moteur de rendu doit d√©terminer ce qui est visible et ce qui ne l'est pas √† partir du point courant.  Ce n'est pas particuli√®rement difficile si vous avez beaucoup de temps, mais un moteur de jeu en temps r√©el qui se respecte devrait d√©terminer les parties visibles et invisibles du monde au moins 30 fois par seconde. <br><br>  Cette t√¢che est souvent appel√©e t√¢che de d√©termination de la surface visible (VSD).  Le programmeur Michael Abrash, qui a travaill√© avec Carmack sur <em>Quake</em> (le prochain jeu d'ID Software apr√®s <em>Doom</em> ), a √©crit sur la t√¢che VSD dans son c√©l√®bre livre <a href="http://www.jagregory.com/abrash-black-book/"><em>Graphics Programming Black Book</em></a> : <br><br><blockquote>  Je veux parler de la t√¢che graphique la plus difficile, √† mon avis,: d√©terminer les surfaces visibles (dessiner la surface souhait√©e dans chaque pixel) et son proche parent - la t√¢che d'√©limination (le plus rapidement possible, lancer des polygones invisibles pour acc√©l√©rer la d√©termination des surfaces visibles).  Par souci de concision, je d√©signerai par l'abr√©viation VSD √† la fois la d√©finition des surfaces visibles et l'√©cr√™tage. <br><br>  Pourquoi est-ce que je consid√®re VSD comme la t√¢che 3D la plus difficile?  Bien que les probl√®mes de pixellisation, tels que le mappage de texture, soient √©galement des t√¢ches √©tonnantes et importantes, ce sont des t√¢ches d'une √©chelle assez finie, dont la solution est d√©plac√©e vers l'apparition d'acc√©l√©rateurs 3D sur l'√©quipement;  en outre, ils ne s'adaptent que lorsque la r√©solution de l'√©cran est augment√©e, ce qui est tout √† fait supportable. <br><br>  En revanche, VSD est une t√¢che illimit√©e, et maintenant des dizaines de solutions sont utilis√©es pour le r√©soudre.  Plus important encore, les performances na√Øves du VSD s'adaptent directement √† la complexit√© de la sc√®ne, qui augmente g√©n√©ralement en tant que fonction carr√©e ou cubique, de sorte qu'il devient rapidement le facteur limitant du rendu des mondes r√©alistes. </blockquote><br>  Abrash a √©crit sur la complexit√© du probl√®me VSD √† la fin des ann√©es 90, quelques ann√©es apr√®s que <em>Doom ait</em> prouv√© que les gens ordinaires voulaient pouvoir jouer √† des jeux graphiquement lourds sur leurs ordinateurs personnels.  Au d√©but des ann√©es 90, lorsque id Software commen√ßait tout juste √† publier des jeux, ils devaient travailler efficacement sur des ordinateurs inappropri√©s: les machines personnelles √©taient con√ßues pour fonctionner avec du texte, des feuilles de calcul et d'autres applications similaires.  Pour atteindre cet objectif, la soci√©t√© a d√ª aborder la fiction, notamment dans le cas de plusieurs jeux 3D publi√©s par id Software avant <em>Doom</em> .  Dans ces jeux, la conception de tous les niveaux √©tait limit√©e de mani√®re √† simplifier la solution du probl√®me VSD. <br><br>  Par exemple, dans <em>Wolfenstein 3D</em> , le jeu qu'id Software a sorti juste avant <em>Doom</em> , chaque niveau √©tait compos√© de murs align√©s le long des axes.  En d'autres termes, dans l'univers Wolfenstein, il pourrait y avoir des murs nord / sud ou des murs est / ouest, et pas d'autres.  De plus, les murs pourraient √™tre plac√©s √† des distances fixes dans la grille - tous les couloirs ont une largeur d'une cellule de grille, ou de deux, etc., mais jamais de 2,5 cellules.  Bien que cela signifiait que l'√©quipe d'id Software pouvait cr√©er des niveaux qui semblaient presque identiques, cette restriction a permis √† Carmack d'√©crire tr√®s facilement un moteur de rendu pour <em>Wolfenstein</em> . <br><br>  <em>Le</em> rendu <em>Wolfenstein a</em> r√©solu le probl√®me des VSD en d√©pla√ßant les rayons (ray marching) dans le monde virtuel depuis l'√©cran.  En r√®gle g√©n√©rale, les rendus rendus par rayons sont des rendus de diffusion de rayons - ils sont souvent lents car la r√©solution du probl√®me VSD dans raycaster n√©cessite de trouver la premi√®re intersection entre le rayon et un objet dans le monde, ce qui n√©cessite beaucoup de calculs.  Mais comme tous les murs de <em>Wolfenstein</em> sont bord√©s d'une grille, les seules lignes o√π une poutre peut traverser le mur seront les lignes de la grille.  Par cons√©quent, il suffit que le moteur de rendu v√©rifie chacun de ces points d'intersection.  Si le rendu commence par v√©rifier le point d'intersection le plus proche du point de vue du joueur, puis v√©rifie le second √† proximit√©, etc., et se termine lorsqu'il rencontre le premier mur, le probl√®me VSD est r√©solu de la mani√®re la plus triviale.  Le faisceau s'est simplement d√©plac√© vers l'avant de chaque pixel jusqu'√† ce qu'il rencontre quelque chose, ce qui est tr√®s bon march√© en termes de vitesse d'horloge du processeur.  Et comme tous les murs ont la m√™me hauteur, il nous suffit d'√©mettre des rayons pour chaque <em>colonne de</em> pixels. <br><br>  Cette simplification du rendu a rendu <em>Wolfenstein</em> assez rapide pour travailler sur les PC domestiques faibles de l'√©poque, alors qu'il n'y avait pas de cartes graphiques sp√©cialis√©es.  Mais une telle approche ne fonctionnerait pas dans <em>Doom</em> , car l'√©quipe d'id a d√©cid√© que dans son nouveau jeu, il y aurait de nouveaux √©l√©ments tels que des murs diagonaux, des escaliers et des plafonds de diff√©rentes hauteurs.  La marche de rayons ne convenait plus, donc Carmack a √©crit un autre type de rendu.  Le rendu <em>Wolfenstein</em> , o√π le faisceau √©tait utilis√© pour chaque colonne de pixels, a √©t√© repouss√© de l'image et le rendu <em>Doom</em> √©tait cens√© √™tre repouss√© des objets.  Cela signifiait qu'au lieu de traverser les pixels de l'√©cran et de d√©terminer leur couleur, le rendu <em>Doom</em> devait parcourir les objets de la sc√®ne et projeter chacun d'eux tour √† tour sur l'√©cran. <br><br>  Dans un tel moteur de rendu, un moyen simple de r√©soudre le probl√®me VSD consiste √† utiliser un z-buffer.  Chaque fois que nous projetons un objet sur l'√©cran, une v√©rification est effectu√©e pour chaque pixel que nous voulons dessiner.  Si la partie de l'objet √† dessiner est plus proche du joueur que l'objet d√©j√† dessin√© dans le pixel, alors nous pouvons r√©√©crire ses informations.  Sinon, vous devez laisser le pixel inchang√©.  Cette approche est simple, mais le z-buffer n√©cessite beaucoup de m√©moire et le moteur de rendu peut toujours d√©penser un tas d'horloges de processeur pour projeter une g√©om√©trie de niveau que le joueur ne verra pas. <br><br>  Au d√©but des ann√©es 1990, la solution z-buffer avait un autre inconv√©nient: sur les PC compatibles IBM utilisant un syst√®me d'adaptateur vid√©o appel√© VGA, l'√©criture dans le tampon de trame de sortie √©tait une op√©ration co√ªteuse.  Par cons√©quent, le temps consacr√© au rendu des pixels, qui sera alors simplement √©cras√©, a consid√©rablement r√©duit les performances du rendu. <br><br>  √âtant donn√© que l'√©criture dans le tampon d'image √©tait si ch√®re, le rendu id√©al √©tait de commencer par dessiner les objets les plus proches du lecteur, puis les objets imm√©diatement derri√®re eux, et ainsi de suite, jusqu'√† ce que l'√©criture sur chaque pixel de l'√©cran soit termin√©e.  √Ä ce stade, le rendu aurait d√ª comprendre qu'il √©tait temps de s'arr√™ter, √©conomisant ainsi tout le temps qu'il pouvait passer √† explorer des objets √©loign√©s que le joueur ne voyait pas.  Mais ordonner des objets de sc√®ne de cette mani√®re, du plus proche au plus √©loign√©, revient √† r√©soudre le probl√®me VSD.  La question se pose √† nouveau devant nous: que peut voir un joueur? <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HQYsFshbkYw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Au d√©but, Carmack a essay√© de r√©soudre ce probl√®me en s'appuyant sur le sch√©ma de niveau <em>Doom</em> .  Son rendu a commenc√© par dessiner les murs de la pi√®ce dans laquelle se trouve le joueur, puis il a coul√© dans les pi√®ces voisines pour dessiner des murs dans ces pi√®ces, qui pourraient √™tre visibles depuis la pi√®ce actuelle.  Si chaque pi√®ce √©tait convexe, cela r√©soudrait le probl√®me VSD.  Les pi√®ces non convexes peuvent √™tre divis√©es en ¬´secteurs¬ª convexes.  Vous pouvez voir √† quoi cette technique de rendu pourrait ressembler √† un fort ralentissement dans <a href="https://youtu.be/HQYsFshbkYw%3Ft%3D822">la vid√©o ci</a> - <a href="https://youtu.be/HQYsFshbkYw%3Ft%3D822">dessus</a> , o√π un utilisateur YouTuber avec le surnom Bisqwit montre son propre moteur de rendu qui fonctionne selon le m√™me algorithme g√©n√©ral.  Cet algorithme a √©t√© utilis√© avec succ√®s dans le jeu Duke Nukem 3D, sorti trois ans apr√®s <em>Doom</em> , lorsque les processeurs sont devenus plus puissants.  Mais en 1993, √† cette √©poque, le rendu <em>Doom</em> utilisant cet algorithme a rencontr√© des probl√®mes avec des niveaux complexes.  Cela √©tait particuli√®rement √©vident lorsque les secteurs √©taient int√©gr√©s les uns aux autres, et c'√©tait la seule fa√ßon de cr√©er, par exemple, des escaliers circulaires.  Les escaliers circulaires n√©cessitaient plusieurs descentes r√©cursives vers le secteur d√©j√† trac√©, r√©duisant consid√©rablement la vitesse du moteur. <br><br>  √Ä peu pr√®s √† la m√™me √©poque, lorsque l'√©quipe d'identification s'est rendu compte que le moteur <em>Doom √©tait</em> peut-√™tre trop lent, id Software a √©t√© invit√© √† porter <em>Wolfenstein 3D</em> sur Super Nintendo.  SNES √©tait encore moins puissant que les PC compatibles IBM de l'√©poque, et il s'est av√©r√© que le moteur de rendu <em>Wolfenstein</em> avec la technologie de d√©filement des rayons, malgr√© sa simplicit√©, ne fonctionnait pas sur un √©quipement Super Nintendo avec une vitesse suffisante.  Par cons√©quent, Carmack a commenc√© √† chercher un meilleur algorithme.  En fait, c'est pour le port Super Nintendo de <em>Wolfenstein</em> que Carmack a d'abord explor√© et impl√©ment√© le partitionnement de l'espace binaire.  √Ä <em>Wolfenstein,</em> c'√©tait assez simple car tous les murs √©taient parall√®les aux axes;  <em>Doom rend</em> plus difficile.  Mais Carmack s'est rendu compte que les arbres BSP r√©soudraient √©galement les probl√®mes de vitesse dans <em>Doom</em> . <br><br><h2>  Division d'espace binaire </h2><br>  Le partitionnement d'espace binaire simplifie la solution du probl√®me VSD en pr√©-fractionnant la sc√®ne 3D.  Pour l'instant, il vous suffit de comprendre pourquoi le partitionnement est utile: si vous tracez une ligne (qui est en fait un plan en 3D) √† travers toute la sc√®ne, sachant de quel c√¥t√© de la ligne se trouve le lecteur ou la cam√©ra, nous saurons √©galement que rien n'est l'autre c√¥t√© de la ligne ne pourra pas obstruer les objets du c√¥t√© de la ligne o√π se trouve la cam√©ra.  Si vous r√©p√©tez le processus plusieurs fois, nous obtenons une sc√®ne 3D, divis√©e en plusieurs sections.  Ce ne sera pas une am√©lioration par rapport √† la sc√®ne d'origine, sauf que nous en savons maintenant plus sur la fa√ßon dont les diff√©rentes parties de la sc√®ne peuvent se chevaucher. <br><br>  Les premiers √† √©crire sur cette division de la sc√®ne 3D ont √©t√© des chercheurs essayant de d√©terminer pour l'US Air Force si les graphiques informatiques sont suffisamment progressifs pour √™tre utilis√©s dans les simulateurs de vol.  Ils ont publi√© leurs r√©sultats dans un rapport de 1969 intitul√© ¬´Recherche sur l'utilisation d'images g√©n√©r√©es par ordinateur dans la simulation visuelle¬ª.  Le rapport conclut que les graphiques informatiques peuvent √™tre utilis√©s pour former les pilotes;  Dans le m√™me temps, les chercheurs ont averti que la mise en ≈ìuvre du syst√®me serait compliqu√©e par la t√¢che de VSD: <br><br><blockquote>  L'une des t√¢ches les plus importantes qui devront √™tre r√©solues lors du calcul des images en temps r√©el est la t√¢che prioritaire, ou lignes cach√©es.  Dans notre perception visuelle quotidienne du monde qui nous entoure, la nature elle-m√™me r√©sout ce probl√®me avec une simplicit√© triviale;  le point d'un objet opaque chevauche tous les autres points qui se trouvent le long de la m√™me ligne de vis√©e et sont plus √©loign√©s.  Dans le cas d'un ordinateur, cette t√¢che est tr√®s difficile.  La quantit√© de calcul n√©cessaire pour d√©terminer la priorit√©, dans le cas g√©n√©ral, cro√Æt de fa√ßon exponentielle avec la complexit√© croissante de l'environnement, et d√©passe rapidement la charge de calcul associ√©e √† la recherche d'images d'objets en tenant compte de la perspective. </blockquote><br>  Une solution mentionn√©e par ces chercheurs, qui selon eux a d√©j√† √©t√© utilis√©e dans un projet de la NASA, est bas√©e sur la cr√©ation de ce que j'appellerai la ¬´matrice de chevauchement¬ª.  Les chercheurs soulignent qu'un avion divisant une sc√®ne en deux parties peut √™tre utilis√© pour r√©soudre "tout conflit de priorit√©s" entre des objets situ√©s sur les c√¥t√©s oppos√©s de l'avion.  Dans le cas g√©n√©ral, vous devrez peut-√™tre ajouter ces plans √† la sc√®ne de mani√®re explicite, mais pour une certaine structure g√©om√©trique, vous pouvez vous fier aux faces existantes des objets.  Les chercheurs d√©montrent l'exemple ci-dessous, o√π <em>p1</em> , <em>p2</em> et <em>p3</em> sont des surfaces de division.  Si le point de vue de la cam√©ra est √† l'avant ou sur le c√¥t√© "vrai" de l'un de ces plans, alors <em>pi</em> vaut 1. La matrice montre la relation entre les trois objets en fonction des trois plans de s√©paration et de l'emplacement du point de vue de la cam√©ra - si l'objet <em>ai</em> chevauche l'objet <em>aj</em> , alors l'√©l√©ment <em>aij de la</em> matrice sera √©gal √† 1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d24/7b5/fda/d247b5fdab1c47b5772d3a3c922c1664.png"></div><br>  Les chercheurs ont propos√© d'impl√©menter cette matrice dans le mat√©riel et de la recalculer dans chaque trame.  En fait, la matrice devrait agir comme un grand commutateur ou une sorte de z-buffer int√©gr√©.  Lors du rendu de l'objet actuel, la vid√©o n'est pas sortie pour des parties de l'objet lorsque 1 est dans la colonne d'objet, mais l'objet de ligne correspondant est dessin√©. <br><br>  Un inconv√©nient s√©rieux de cette approche est qu'une matrice de taille <em>n <sup>2 est</sup></em> n√©cessaire pour d√©crire une sc√®ne avec <em>n</em> objets.  Par cons√©quent, les chercheurs ont d√©cid√© de v√©rifier s'il est possible de pr√©senter la matrice de chevauchement sous la forme d'une ¬´liste de priorit√©s¬ª, qui aura une taille de <em>n</em> seulement et de sp√©cifier l'ordre dans lequel les objets doivent √™tre dessin√©s.  Ils ont imm√©diatement remarqu√© que dans certaines sc√®nes, par exemple, dans celle illustr√©e ci-dessus, la commande est impossible √† r√©aliser (car il y a un cycle de chevauchement), ils ont donc consacr√© beaucoup de temps √† la d√©finition math√©matique des sc√®nes ¬´bonnes¬ª et ¬´mauvaises¬ª.  En fin de compte, ils sont arriv√©s √† la conclusion qu'au moins pour les ¬´bonnes¬ª sc√®nes (et le concepteur de sc√®ne peut facilement √©viter les ¬´mauvais¬ª cas), une liste de priorit√©s peut √™tre g√©n√©r√©e.  Mais ils ont quitt√© la g√©n√©ration de la liste comme un exercice pour le lecteur.  Il semble que la principale contribution de ce travail de 1969 soit d'indiquer qu'au moins <em>th√©oriquement, il</em> devrait √™tre possible d'utiliser des plans de division pour organiser les objets dans la sc√®ne. <br><br>  Et ce n'est que dans un article de 1980 intitul√© ¬´Sur la g√©n√©ration de surfaces visibles par les structures d'arbres A Priori¬ª qu'un algorithme sp√©cifique a √©t√© d√©montr√© √† cet effet.  Dans cet article, √©crit par Henry Fuchs, Zvi Kedem et Bruce Naylor, l'arbre BSP a √©t√© d√©crit pour la premi√®re fois.  Les auteurs affirment que leur nouvelle structure de donn√©es est ¬´une solution, une approche alternative, utilis√©e pour la premi√®re fois il y a dix ans, mais en raison de certaines difficult√©s moins r√©pandues¬ª - ils r√©agissent donc √† la d√©cision choisie dans les travaux de l'US Air Force en 1969.  Apr√®s avoir construit une arborescence BSP, elle peut √™tre facilement utilis√©e pour organiser les objets avec priorit√© dans la sc√®ne. <br><br>  Fuchs, Kedem et Naylor ont fourni une description assez claire du fonctionnement de l'arborescence BSP, mais j'essaierai de donner un aspect moins formel, mais bref. <br><br>  Nous commen√ßons par s√©lectionner un polygone dans la sc√®ne et faisons du plan dans lequel le polygone se trouve un plan de division.  Ce polygone unique devient √©galement le n≈ìud racine de l'arbre.  Les polygones restants de la sc√®ne se trouveront d'un c√¥t√© ou de l'autre du plan de division racine.  Les polygones sur le c√¥t√© "avant" ou dans le demi-espace "avant" du plan apparaissent dans le sous-arbre gauche du n≈ìud racine, et les polygones sur le c√¥t√© "arri√®re" ou dans le demi-espace "arri√®re" du plan apparaissent dans le sous-arbre droit.  Ensuite, nous r√©p√©tons r√©cursivement ce processus, en s√©lectionnant des polygones des sous-arbres gauche et droit comme nouvelles surfaces de division pour leurs propres demi-espaces, qui g√©n√®rent d'autres demi-espaces et sous-arbres.  Le processus se termine √† la fin des polygones. <br><br>  Disons que nous voulons rendre la g√©om√©trie de la sc√®ne d'avant en arri√®re.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Ceci est appel√© ¬´l'algorithme de l'artiste¬ª car cela signifie que les polygones plus √©loign√©s de la cam√©ra seront remplis de polygones plus proches de la cam√©ra, cr√©ant le rendu correct.) Pour ce faire, nous avons juste besoin de faire le tour de notre arbre BSP dans l'ordre; la d√©cision de dessiner le sous-arbre gauche ou droit est bas√©e sur la position du point de vue de la cam√©ra - dans le demi-espace avant ou arri√®re par rapport au plan de division associ√© √† ce n≈ìud. C'est-√†-dire que dans chaque n≈ìud de l'arbre, nous rendons d'abord tous les polygones du c√¥t√© "√©loign√©" du plan, puis le polygone du plan de s√©paration, puis les polygones du c√¥t√© "proche" du plan. Les polygones ¬´proche¬ª et ¬´√©loign√©¬ª sont d√©finis par rapport au point de vue de la cam√©ra. Cela r√©sout le probl√®me VSD parce que, comme nous l'avons appris il y a quelques paragraphes,les polygones de l'autre c√¥t√© du plan de s√©paration ne peuvent pas chevaucher quoi que ce soit de la face avant.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le diagramme ci-dessous montre la construction et la travers√©e d'une arborescence BSP qui d√©crit une simple sc√®ne 2D. </font><font style="vertical-align: inherit;">En 2D, des lignes de division sont utilis√©es √† la place des plans de division, mais l'id√©e de base reste la m√™me.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f72/00b/aac/f7200baac3a914eb6fe62ca131b1e3cc.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/564/e28/9bf/564e289bf6d44182b3db68c8ad7178c0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/07a/f5a/63807af5af2f3bfa8c7ec73a81c36035.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une caract√©ristique tr√®s pratique de l'arborescence BSP que Fuchs, Kedem et Naylor soulignent √† plusieurs reprises est qu'il ne doit √™tre construit qu'une seule fois. </font><font style="vertical-align: inherit;">Cela semble surprenant, mais un arbre BSP peut √™tre utilis√© pour rendre la sc√®ne quel que soit le point de vue de la cam√©ra. </font><font style="vertical-align: inherit;">L'arbre BSP reste utilisable jusqu'√† ce que les polygones de sc√®ne se d√©placent. </font><font style="vertical-align: inherit;">C'est pourquoi l'arborescence BSP est si utile pour le rendu en temps r√©el - tout le travail complexe de construction d'un arbre peut √™tre fait √† l'avance, et non au moment du rendu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuchs, Kedem et Naylor rapportent que des recherches plus pouss√©es n√©cessitent la cr√©ation d'un ¬´bon¬ª arbre BSP. La qualit√© de l'arborescence BSP d√©pend des polygones que vous choisissez pour d√©finir les plans de s√©paration. Plus t√¥t, j'ai saut√© ce point, mais si vous utilisez un plan qui intersecte d'autres polygones lors du fractionnement, alors pour que l'algorithme BSP fonctionne, vous devez diviser les polygones crois√©s en deux, de sorte qu'une moiti√© se r√©f√®re √† un demi-espace et l'autre √† l'autre. Si cela se produit souvent, la construction d'un arbre BSP augmente consid√©rablement le nombre de polygones dans la sc√®ne.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bruce Naylor, l'un des auteurs de l'article de 1980, a √©crit plus tard √† ce sujet dans son article de 1993, Constructing Good Partitioning Trees. </font><font style="vertical-align: inherit;">Selon le coll√®gue de Carmack et co-fondateur d'id Software, John Romero, cet article √©tait l'une des ≈ìuvres que Carmack a lues lorsqu'il a essay√© d'impl√©menter des arbres BSP dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbres BSP dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappelons que dans la premi√®re version du rendu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">Carmack a essay√© d'√©tablir l'ordre de rendu de la g√©om√©trie de niveau en remplissant le rendu hors de la pi√®ce o√π se trouve le joueur dans les pi√®ces voisines. Les arborescences BSP √©taient un moyen plus pratique de d√©terminer cet ordre, car elles √©vitaient le probl√®me du rendu du rendu √† plusieurs reprises dans une pi√®ce (ou secteur), gaspillant ainsi les cycles du processeur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬´Ajouter des arbres BSP √† </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª dans la pratique signifiait ajouter un g√©n√©rateur d'arbre BSP √† l'√©diteur de niveau </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Apr√®s avoir termin√© le niveau </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un arbre BSP a √©t√© g√©n√©r√© √† partir de la g√©om√©trie de niveau. Selon Fabien Sanglar, le processus de g√©n√©ration pourrait prendre jusqu'√† huit secondes pour un niveau et 11 minutes pour tous les niveaux du premier </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Le processus de g√©n√©ration a √©t√© si long en partie en raison du fait que l'algorithme de g√©n√©ration Carmack BSP essaie de trouver un ¬´bon¬ª arbre BSP en utilisant diverses heuristiques. Un retard de huit secondes serait impardonnable pendant le jeu, mais lors de la g√©n√©ration pr√©liminaire, il semblait tout √† fait acceptable, compte tenu de l'augmentation des performances que les arbres BSP fournissaient au moteur de rendu. L'arbre BSP g√©n√©r√© d'un niveau individuel a √©t√© enregistr√© en tant que partie des donn√©es de niveau charg√©es dans le jeu lors de son lancement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carmack a apport√© un changement important √† l'algorithme d'arbre BSP d√©crit dans un article de 1980: apr√®s le lancement de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et en lisant l'arborescence BSP du niveau actuel dans la m√©moire, le moteur de rendu utilise cet arbre pour dessiner des objets non pas d'avant en avant, mais d'avant en arri√®re. Dans un article de 1980, Fuchs, Kedem et Naylor ont montr√© comment un arbre BSP peut √™tre utilis√© pour impl√©menter un algorithme d'artiste avec un rendu dos √† dos, mais une grande quantit√© de repeinture se produit dans l'algorithme de l'artiste, ce qui pourrait √™tre co√ªteux sur les PC compatibles IBM. Par cons√©quent, le rendu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> commence par une g√©om√©trie plus proche du joueur, puis dessine le plus loin. Un tel ordre inverse est facile √† impl√©menter √† l'aide d'une arborescence BSP, car vous pouvez simplement prendre une d√©cision de retour arri√®re √† chaque n≈ìud de l'arborescence. Pour √©viter que la g√©om√©trie la plus √©loign√©e ne soit dessin√©e au-dessus du plus proche, le rendu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilise une sorte de z-buffer implicite, qui offre de nombreux avantages d'un z-buffer normal, tout en consommant beaucoup moins de m√©moire. Il existe un tableau qui suit le chevauchement dans la dimension horizontale et deux autres tableaux qui suivent le chevauchement dans la direction verticale au-dessus et en dessous de l'√©cran. Le moteur de rendu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pourrait se passer de l'utilisation d'un v√©ritable z-buffer, car </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , √† proprement parler, n'√©tait pas un jeu compl√®tement en trois dimensions. Des structures de donn√©es moins co√ªteuses y travaillaient parce que </font><font style="vertical-align: inherit;">certains √©l√©ments n'√©taient pas possibles </font><font style="vertical-align: inherit;">dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : le tableau de chevauchement horizontal fonctionnait parce qu'il n'y avait pas de murs en pente, et les tableaux de chevauchement vertical fonctionnaient parce qu'il n'y avait pas de murs dans lesquels, par exemple, il y en avait deux l'une au-dessus des autres fen√™tres.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a74/23c/5de/a7423c5dead349917bd826ee3efa70b9.png"></div><br> <i><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom II</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aussi complexe que son pr√©d√©cesseur.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a7/82b/b4a/3a782bb4a5a2c4a44e5821c897239533.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais personne ne s'est plaint de la r√©p√©tition du sang.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d0/0e4/443/3d00e4443a7e46c3418e11dac4eec839.png"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un nouveau mot dans les technologies Quake La</font></font></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seule t√¢che d√©licate qui reste est de savoir comment int√©grer les personnages </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom en</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mouvement </font><font style="vertical-align: inherit;">dans la g√©om√©trie statique des niveaux dessin√©s √† l'aide de l'arborescence BSP. </font><font style="vertical-align: inherit;">Les ennemis dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne pouvaient pas faire partie de l'arbre BSP parce qu'ils se d√©pla√ßaient; </font><font style="vertical-align: inherit;">L'arbre BSP ne fonctionne qu'avec une g√©om√©trie fixe. </font><font style="vertical-align: inherit;">Par cons√©quent, le rendu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dessine d'abord la g√©om√©trie statique du niveau, en suivant (√† l'aide d'une autre structure de donn√©es √©conome en m√©moire) les segments de l'√©cran dans lesquels le dessin a √©t√© effectu√©. Il attire ensuite les ennemis de l'arri√®re vers l'avant, les tronquant le long des segments de l'√©cran qui les chevauchent. Ce processus n'est pas aussi optimal que le rendu avec un arbre BSP, mais comme il y a g√©n√©ralement moins d'ennemis que la g√©om√©trie, la vitesse n'est pas un probl√®me ici. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'utilisation d'arbres BSP dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom a</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √©t√© une grande victoire. De toute √©vidence, Carmack √©tait assez vif d'esprit pour r√©aliser que les arbres BSP seraient la solution id√©ale. Mais cette d√©cision √©tait-elle </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ing√©nieuse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans </font></font><a href="http://fabiensanglard.net/gebbdoom/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">son excellent livre sur le moteur de jeu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fabien Sanglar cite John Romero, qui a d√©clar√© que l'article de Bruce Naylor ¬´Construire de bons arbres de partitionnement¬ª concernait principalement l'utilisation des arbres BSP pour couper les faces arri√®re des mod√®les 3D. Selon Romero, Carmack pensait que l'algorithme pourrait encore √™tre utile pour </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , alors il l'a impl√©ment√©. Ceci est tout √† fait louable pour Carmack car il implique qu'il a vu l'utilit√© des arbres BSP dans les jeux vid√©o en temps r√©el m√™me lorsque d'autres personnes utilisaient encore cette technique pour rendre des sc√®nes statiques. La m√™me histoire flatteuse se trouve dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masters of Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Kouchner a sugg√©r√© √† Carmack de lire l'article de Naylor et s'est demand√©: "Et si vous pouviez utiliser l'arborescence BSP pour cr√©er non seulement une image 3D, mais un monde virtuel entier?" </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces r√©sultats ignorent l'histoire de l'arborescence BSP. Lorsque les chercheurs de l'US Air Force ont r√©alis√© pour la premi√®re fois que le fractionnement d'une sc√®ne pouvait aider √† acc√©l√©rer le rendu, ils √©taient int√©ress√©s </font><em><font style="vertical-align: inherit;">par l'</font></em><font style="vertical-align: inherit;"> acc√©l√©ration en </font><em><font style="vertical-align: inherit;">temps r√©el</font></em><font style="vertical-align: inherit;"> du rendu</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car finalement ils ont essay√© de cr√©er un simulateur de vol. L'exemple du simulateur de vol est √† nouveau mentionn√© dans un article de 1980. Fuchs, Kedem et Naylor √©crivent que l'arbre BSP peut √™tre utile dans un simulateur de vol que les pilotes utilisent pour effectuer plusieurs atterrissages sur le m√™me a√©roport. Comme la g√©om√©trie de l'a√©roport ne change jamais, un arbre BSP ne peut √™tre g√©n√©r√© qu'une seule fois. De toute √©vidence, ils pensaient √† la simulation en temps r√©el. Dans l'introduction de l'article, ils expliquent m√™me leurs recherches en testant la possibilit√© d'utiliser un syst√®me graphique en temps r√©el pour cr√©er des images en 1/30 seconde au maximum.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autrement dit, Carmack n'a pas √©t√© le premier √† penser √† utiliser des arbres BSP dans la simulation graphique en temps r√©el. Bien s√ªr, pr√©dire que les arbres BSP peuvent √™tre utilis√©s de cette mani√®re et les impl√©menter sont des choses compl√®tement diff√©rentes. Mais m√™me avec l'impl√©mentation, Carmack pourrait avoir plus d'informations contextuelles qu'on ne le pense habituellement. L' </font></font><a href="https://en.wikipedia.org/wiki/Binary_space_partitioning"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article du WSP sur les arbres BSP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sugg√®re que Carmack a fait r√©f√©rence √† l'article de 1991 de Chen et Gordon, ainsi qu'au manuel de 1990 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computer Graphics: Principles and Practice</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Bien que cette d√©claration ne soit pas √©tay√©e par une citation, elle peut √™tre vraie. Un article de 1991 de Chen et Gordon d√©crit le rendu d'avant en arri√®re √† l'aide d'arbres BSP, qui est essentiellement la m√™me solution utilis√©e par </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jusqu'√† la structure de donn√©es ¬´z-buffer implicite¬ª, qui ne permet pas de tracer des polygones distants au-dessus des polygones voisins. L'article fournit une excellente vue d'ensemble des arbres BSP, ainsi qu'un pseudocode pour la construction et l'affichage d'un arbre. (Gr√¢ce √† la merveilleuse biblioth√®que de mon universit√©, j'ai pu faire d√©filer l'√©dition 1990.) Le manuel </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computer Graphics: Principles and Practice</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un ouvrage classique sur l'infographie, donc Carmack pourrait en avoir un aussi.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6f/134/2a9/b6f1342a90a1ce11fafca1f265f65fda.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Niveau sous-secteur E1M1: Hangar.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quoi qu'il en soit, Carmack a fait face √† une nouvelle t√¢che - "Comment puis-je cr√©er un jeu de tir √† la premi√®re personne qui fonctionne sur un ordinateur avec un processeur qui n'est m√™me pas capable d'effectuer des op√©rations en virgule flottante?" - a men√© ses propres recherches et a prouv√© que les arbres BSP sont Il s'agit d'une structure de donn√©es utile pour les jeux vid√©o en temps r√©el. Je pense toujours que c'est un r√©sultat impressionnant, m√™me si l'arbre BSP a √©t√© invent√© dix ans plus t√¥t, et a √©t√© √©tudi√© th√©oriquement avec suffisamment de d√©tails au moment o√π Carmack a lu √† ce sujet. Peut-√™tre que la principale r√©alisation que nous devrions louer est le moteur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans son ensemble, qui est devenu un excellent exemple de code. J'en ai d√©j√† parl√© une fois, mais je r√©p√®te que le livre de Fabien Sanglar sur le moteur de jeu</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game Engine Black Book: DOOM</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) est un excellent aper√ßu de tous les composants r√©fl√©chis du moteur de jeu et de leur interaction. </font><font style="vertical-align: inherit;">Nous ne devons pas oublier que la t√¢che VSD n'√©tait qu'une des nombreuses t√¢ches que Carmack devait r√©soudre pour que le moteur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonctionne </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Et qu'il a pu, en plus de tout, lire sur la structure de donn√©es complexe inconnue de la plupart des programmeurs, et l'impl√©menter. </font><font style="vertical-align: inherit;">Cela en dit long sur le niveau de ses connaissances techniques et son engagement envers l'id√©al.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr482614/">https://habr.com/ru/post/fr482614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482598/index.html">Fausses photos du groupe Dyatlov</a></li>
<li><a href="../fr482604/index.html">5 personnages des ann√©es 1920 qui, apr√®s 100 ans, sont mont√©s dans les nuages</a></li>
<li><a href="../fr482608/index.html">AMA avec Habr # 15. Nouvel an et la version la plus courte! Clavarder</a></li>
<li><a href="../fr482610/index.html">Lancez l'√©cran TFT transflectif sur SSD1283A avec STM32</a></li>
<li><a href="../fr482612/index.html">Busi-board d'ing√©nierie touchante, nouvel an et b√©n√©voles</a></li>
<li><a href="../fr482620/index.html">Slurm: Habr, bonnes vacances ...</a></li>
<li><a href="../fr482622/index.html">Simulation de courir sous la pluie</a></li>
<li><a href="../fr482626/index.html">Surveillance des applications avec Logger.Backends</a></li>
<li><a href="../fr482628/index.html">Regardez "Little Green Spider of Time"</a></li>
<li><a href="../fr482634/index.html">Mais l'essence est quelque chose, ou minimiser le code source est plus facile qu'il n'y para√Æt.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>