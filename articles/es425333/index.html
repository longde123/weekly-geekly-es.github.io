<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🌾 👨‍🚒 🤰🏿 Arranca tú mismo, llega la primavera (Parte 2) 🐠 👩🏾‍🤝‍👨🏽 👩🏿‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Evgeny EvgenyBorisov Borisov (NAYA Technologies) y Kirill tolkkv Tolkachev (Cyan.Finance, Twitter ) continúan hablando sobre el uso de Spring Boot par...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arranca tú mismo, llega la primavera (Parte 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/425333/"><p>  Evgeny <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">EvgenyBorisov</a> Borisov (NAYA Technologies) y Kirill <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">tolkkv</a> Tolkachev (Cyan.Finance, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Twitter</a> ) continúan hablando sobre el uso de Spring Boot para resolver los problemas del imaginario Braavos Iron Bank.  En la segunda parte, nos centraremos en los perfiles y sutilezas del lanzamiento de la aplicación. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c19/236/8c6/c192368c6d6e05d473201da0031d3ccc.png"><br><br></p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7Cq5zEm2wq0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  La primera parte del artículo se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </p><br><p>  Entonces, hasta hace poco, el cliente vino y solo exigió enviar un cuervo.  Ahora la situación ha cambiado.  Ha llegado el invierno, el muro ha caído. </p><br><p> En primer lugar, el principio de emisión de préstamos está cambiando.  Si antes con una probabilidad del 50% se entregaba a todos excepto a Starks, ahora ahora se entrega solo a aquellos que pagan deudas.  Por lo tanto, estamos cambiando las reglas para emitir préstamos en nuestra lógica de negocios.  Pero solo para las sucursales del banco, que se encuentran donde ya ha llegado el invierno, en todo lo demás todo permanece como antes.  Les recuerdo que este es un servicio que decide si otorgar un préstamo o no.  Simplemente haremos otro servicio que funcionará solo en invierno. </p><br><p>  Vamos a nuestra lógica de negocios: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WhiteListBasedProphetService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProphetService</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-meta"><span class="hljs-meta">@Override</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willSurvive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;  } }</code> </pre> <br><p>  Ya tenemos una lista de quienes pagan deudas. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">spring</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">application</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.name</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">money-raven</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jpa</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.hibernate</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ddl-auto</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">validate</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ironbank</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span><span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span><span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>:   <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>  : <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>: ,   : <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span></code> </pre> <br><p>  Y hay una clase que ya está asociada con la propiedad: <code></code> . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProphetProperties</span></span></span><span class="hljs-class"> </span></span>{ List&lt;String&gt; ; }</code> </pre> <br><p>  Como en tiempos anteriores, simplemente lo inyectamos aquí: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WhiteListBasedProphetService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProphetService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ProphetProperties prophetProperties; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willSurvive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br><p>  Recuerde acerca de la inyección del constructor (sobre anotaciones mágicas): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WhiteListBasedProphetService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProphetService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ProphetProperties prophetProperties; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willSurvive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br><p>  Casi terminado </p><br><p>  Ahora debemos dar solo a aquellos que pagan deudas: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WhiteListBasedProphetService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProphetService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ProphetProperties prophetProperties; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willSurvive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prophetProperties.get().contains(name); } }</code> </pre> <br><p>  Pero aquí tenemos un pequeño problema.  Ahora tenemos dos implementaciones: los servicios antiguos y los nuevos. </p><br><pre> <code class="java hljs">Description Parameter <span class="hljs-number"><span class="hljs-number">1</span></span> of constructor in com.ironbank.moneyraven.service.TransferMoneyProphecyBackend… - nameBasedProphetService: defined in file [/Users/tolkv/git/conferences/spring-boot-ripper… - WhileListBackendProphetService: defined in file [/Users/tolkv/git/conferences/spring-boot-ripper...</code> </pre> <br><p>  Es lógico dividir estos beans en diferentes perfiles.  Perfil de <code></code> y perfil de <code></code> .  Deje que nuestro nuevo servicio funcione solo en el perfil <code></code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-meta"><span class="hljs-meta">@Profile</span></span>(ProfileConstants.) <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WhiteListBasedProphetService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProphetService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ProphetProperties prophetProperties; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willSurvive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prophetProperties.get().contains(name); } }</code> </pre> <br><p>  Y el antiguo servicio es en <code></code> . </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-meta"><span class="hljs-meta">@Profile</span></span>(ProfileConstants.) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NameBasedProphetService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProphetService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willSurvive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !name.contains(<span class="hljs-string"><span class="hljs-string">"Stark"</span></span>) &amp;&amp; ThreadLocalRandom.current().nextBoolean(); } }</code> </pre> <br><p>  Pero el invierno llega lentamente.  En los reinos al lado del muro roto, ya es invierno.  Pero en algún lugar del sur, todavía no.  Es decir  Las aplicaciones ubicadas en diferentes sucursales y zonas horarias deberían funcionar de manera diferente.  De acuerdo con las condiciones de nuestra tarea, no podemos borrar la implementación anterior donde ha llegado el invierno y usar la nueva clase.  Queremos que los empleados del banco no hagan nada en absoluto: les entregaremos una aplicación que funcionará en modo verano hasta que llegue el invierno.  Y cuando llega el invierno, simplemente lo reinician y eso es todo.  No tendrán que cambiar el código, borrar ninguna clase.  Por lo tanto, inicialmente tenemos dos perfiles: parte del contenedor se crea cuando el verano y parte del contenedor se crea cuando el invierno. </p><br><p>  Pero aparece otro problema: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fbd/7a6/882/fbd7a6882ff3180ccfc693ac3b41a852.png"><br></p><br><p>  Ahora no tenemos un solo bean, porque especificamos dos perfiles, y la aplicación se inicia en el perfil predeterminado. </p><br><p>  Entonces tenemos un nuevo requisito del cliente. </p><br><h2>  Iron Law 2. No se permite ningún perfil. </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/04a/0bb/57a/04a0bb57aa20425f959898ac3eecf8a5.png"><br></p><br><p>  No queremos elevar el contexto si el perfil no está activado, porque ya ha llegado el invierno, todo se ha vuelto muy malo.  Hay ciertas cosas que deberían suceder o no, dependiendo de si el <code></code> o el <code></code> .  Además, observe la excepción, cuyo texto se proporciona arriba.  No explica nada.  Un perfil no está definido, por lo tanto, no hay implementación de <code>ProphetService</code> .  Al mismo tiempo, nadie dijo que es necesario establecer un perfil. </p><br><p>  Por lo tanto, ahora queremos atornillar una pieza adicional en nuestro iniciador, que, al construir el contexto, verificará que se haya configurado algún perfil.  Si no está configurado, no subiremos y lanzaremos tal excepción (y no alguna excepción sobre la falta de un contenedor). </p><br><p>  ¿Podemos hacer esto con nuestra aplicación de escucha?  No  Y hay tres razones para esto: </p><br><ul><li>  El oyente de responsabilidad única es responsable de hacer volar al cuervo.  El oyente no debe verificar si se ha activado un perfil porque la activación de un perfil afecta no solo al oyente en sí, sino también mucho más. </li><li>  Cuando se construye un contexto, suceden cosas diferentes.  Y no queremos que comiencen a suceder si no se ha establecido un perfil. </li><li>  El oyente funciona al final cuando se resuelve el contexto.  Y el hecho de que no hay perfil, lo sabemos mucho antes.  ¿Por qué esperar estos cinco minutos condicionales hasta que el servicio casi se eleva y luego todo se cae? </li></ul><br><p>  Además, todavía no sé qué errores aparecerán debido al hecho de que comenzamos a aumentar sin un perfil (supongamos que no conozco la lógica comercial).  Por lo tanto, en ausencia de un perfil, es necesario reducir el contexto en una etapa muy temprana.  Por cierto, si usa Spring Cloud, esto se vuelve aún más relevante para usted, porque la aplicación hace muchas cosas en una etapa temprana. </p><br><p>  Para implementar el nuevo requisito, hay <code>ApplicationContextInitializer</code> .  Esta es otra interfaz que nos permite extender algún punto de Spring al especificarlo en spring.factories. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/889/f21/a3b/889f21a3bee67ede3394d3c52b02e96d.png"><br></p><br><p>  Implementamos esta interfaz y tenemos un Context Initializer, que tiene un <code>ConfigurableApplicationContext</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfileCheckAppInitializer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationContextInitializer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfigurableApplicationContext</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre> <br><p>  Con él, podemos obtener el medio ambiente, lo que SpringApplication nos preparó.  Toda la propiedad que le pasamos llegó allí.  Entre otras cosas, también contienen perfiles. </p><br><p>  Si no hay perfiles allí, entonces deberíamos lanzar una excepción diciendo que no puedes trabajar así. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfileCheckAppInitializer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationContextInitializer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfigurableApplicationContext</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> applicationContext.getEnvironment().getActiveProfiles().length == <span class="hljs-number"><span class="hljs-number">0</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"  !"</span></span>);   } } }</code> </pre> <br><p>  Ahora necesita registrar estas cosas en spring.factories. </p><br><pre> <code class="java hljs">org.springframework.boot.context.properties.EnableConfigurationProperties=com.ironbank.moneyraven.starter.IronConfiguration org.springframework.context.ApplicationContextInitializer=com.ironbank.moneyraven.starter.ProfileCheckAppInitializer</code> </pre> <br><p>  De lo anterior, puede adivinar que <code>ApplicationContextInitializer</code> es un punto de extensión.  <code>ApplicationContextInitializer</code> funciona cuando el contexto apenas comienza a construirse, todavía no hay contenedores. </p><br><p>  Surge la pregunta: si escribimos <code>ApplicationContextInitializer</code> , ¿por qué no, como oyente, debería escribirse en una configuración que se extienda de todos modos?  La respuesta es simple: porque debería funcionar mucho antes cuando no hay contexto ni configuraciones.  Es decir  No se puede inyectar todavía.  Por lo tanto, lo prescribimos como una pieza separada. </p><br><p>  Un intento de lanzamiento mostró que todo había caído lo suficientemente rápido e informó que estábamos comenzando sin un perfil.  Ahora intentemos especificar algún perfil, y todo funciona: se envía el cuervo. </p><br><p>  <code>ApplicationContextInitializer</code> : se cumple cuando el contexto ya se ha creado, pero no hay nada más que el entorno. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4ee/fb1/3e5/4eefb13e5b1e2f8f04c19e22f58062a8.png"><br></p><br><p>  ¿Quién crea el medio ambiente?  Carlson - <code>SpringBootApplication</code> .  Lo llena con varias metainformaciones, que luego se pueden sacar de contexto.  La mayoría de las cosas se pueden inyectar a través de <code>@value</code> , algo se puede obtener del entorno, ya que acabamos de obtener perfiles. </p><br><p>  Por ejemplo, diferentes propiedades vienen aquí: </p><br><ul><li>  que Spring Boot puede construir; </li><li>  que al inicio se transmiten a través de la línea de comando; </li><li>  sistémico </li><li>  enunciadas como variables de entorno; </li><li>  prescrito en las propiedades de aplicación; </li><li>  registrado en algunos otros archivos de propiedades. </li></ul><br><p>  Todo esto se recopila y establece en un objeto de entorno.  También contiene información sobre qué perfiles están activos.  El objeto de entorno es lo único que existe en el momento en que Spring Boot comienza a construir contexto. </p><br><p>  Me gustaría adivinar automáticamente cuál será el perfil si las personas se olvidaran de preguntarlo con sus manos (hacemos todo lo posible para que los empleados del banco que están lo suficientemente indefensos sin programadores puedan iniciar la aplicación para que todo funcione para ellos, pase lo que pase).  Para hacer esto, agregaremos a nuestro arranque algo que adivinará el perfil, <code></code> o no, dependiendo de la temperatura en la calle.  Y otra nueva interfaz mágica nos ayudará a todos con esto: <code>EnvironmentPostProcessor</code> , porque necesitamos hacer esto antes de que <code>ApplicationContextInitializer</code> funcione.  Y antes de <code>ApplicationContextInitializer</code> solo hay <code>EnvironmentPostProcessor</code> . </p><br><p>  Nuevamente estamos implementando una nueva interfaz.  Solo hay un método, que de la misma manera que <code>ConfigurableEnvironment</code> arroja en <code>SpringApplication</code> , porque todavía no tenemos <code>ConfigurableContext</code> (ya existe en <code>SpringInitializer</code> no está aquí; solo hay entorno). </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResolveProfileEnvironmentPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EnvironmentPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessEnvironment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurableEnvironment environment, SpringApplication application)</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre> <br><p>  En este entorno, podemos establecer el perfil.  Pero primero debe verificar que nadie lo haya instalado antes.  Por lo tanto, <code>getActiveProfiles</code> debemos verificar <code>getActiveProfiles</code> .  Si las personas saben lo que están haciendo y configuran un perfil, entonces no intentaremos adivinarlas.  Pero si no hay un perfil, trataremos de entender por el clima. </p><br><p>  Y el segundo: debemos entender si tenemos clima de invierno o verano ahora.  Devolveremos la temperatura de <code>-300</code> . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResolveProfileEnvironmentPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EnvironmentPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessEnvironment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurableEnvironment environment, SpringApplication application)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (environment.getActivePrifiles().length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; getTemperature() &lt; -<span class="hljs-number"><span class="hljs-number">272</span></span>) {   } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTemperature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">300</span></span>; } }</code> </pre> <br><p>  Bajo esta condición, tenemos invierno, y podemos establecer un nuevo perfil.  Recordamos que el perfil se llama <code></code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResolveProfileEnvironmentPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EnvironmentPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessEnvironment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurableEnvironment environment, SpringApplication application)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (environment.getActivePrifiles().length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; getTemperature() &lt; -<span class="hljs-number"><span class="hljs-number">272</span></span>) { environment.setActiveProfiles(<span class="hljs-string"><span class="hljs-string">""</span></span>);   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { environment.setActiveProfiles(<span class="hljs-string"><span class="hljs-string">""</span></span>);   } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTemperature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">300</span></span>; } }</code> </pre> <br><p>  Ahora necesitamos especificar el <code>EnvironmentPostProcessor</code> en spring.factories. </p><br><pre> <code class="java hljs">org.springframework.boot.context.properties.EnableConfigurationProperties=com.ironbank.moneyraven.starter.IronConfiguration org.springframework.context.ApplicationContextInitializer=com.ironbank.moneyraven.starter.ProfileCheckAppInitializer org.springframework.boot.env.EnvironmentPostProcessor=com.ironbank.moneyraven.starter.ResolveProfileEnvironmentPostProcessor</code> </pre> <br><p>  Como resultado, la aplicación comienza sin un perfil, decimos que es producción y verificamos en qué perfil comenzó con nosotros.  Mágicamente, nos dimos cuenta de que nuestro perfil es el <code></code> .  Y la aplicación no cayó, porque el <code>ApplicationContextInitializer</code> , que verifica si hay un perfil, viene a continuación. <br>  El resultado: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResolveProfileEnvironmentPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EnvironmentPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessEnvironment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurableEnvironment environment, SpringApplication application)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getTemperature() &lt; -<span class="hljs-number"><span class="hljs-number">272</span></span>) {     environment.setActiveProfiles(<span class="hljs-string"><span class="hljs-string">""</span></span>);   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {     environment.setActiveProfiles(<span class="hljs-string"><span class="hljs-string">""</span></span>);   } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTemperature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">300</span></span>; } }</code> </pre> <br><p>  Hablamos sobre <code>EnvironmentPostProcessor</code> , que se ejecuta antes de <code>ApplicationContextInitializer</code> .  ¿Pero quién lo dirige? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fd0/20e/e9e/fd020ee9edd65a1e41e62e0ebe689658.png"><br></p><br><p>  Este fenómeno lo inicia, que, aparentemente, es el hijo ilegítimo de <code>ApplicationListener</code> y <code>EnvironmentPostProcessor</code> , porque se hereda de <code>ApplicationListener</code> y <code>EnvironmentPostProcessor</code> .  Se llama <code>ConfigFileApplicationListener</code> (por qué "ConfigFile" - nadie lo sabe). </p><br><p>  Él es nuestro Carlson, es decir.  Spring Application proporciona un entorno preparado para escuchar dos eventos: <code>ApplicationPreparedEvent</code> y <code>ApplicationEnvironmentPreparedEvent</code> .  No analizaremos ahora quién lanza estos eventos.  Hay otra capa (en mi opinión ya es completamente superflua, al menos en esta etapa del desarrollo de Spring), que arroja un evento de que el entorno está comenzando a construirse (Application.yml, propiedades, variables de entorno se analizan, etc. ) <br>  Después de recibir <code>ApplicationEnvironmentPreparedEvent</code> , el oyente comprende que necesita configurar el entorno: busque todos los <code>EnvironmentPostProcessor</code> y déjelos trabajar. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cd3/8c4/3b8/cd38c43b8a10c9867cc9b3ebcb3ee1e9.png"><br></p><br><p>  Después de eso, le dice a <code>SpringFactoriesLoader</code> que entregue todo lo que ordenó, es decir, todo el <code>EnvironmentPostProcessor</code> , a spring.factories.  Luego rellena todo el <code>EnvironmentPostProcessor</code> en una Lista. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9b0/e39/f0f/9b0e39f0fe2514c22cfdc03af4b3f464.png"><br></p><br><p>  y entiende que él también es un <code>EnvironmentPostProcessor</code> (concurrentemente), por lo tanto, se empuja allí, <br><img src="https://habrastorage.org/getpro/habr/post_images/0f9/bf0/d30/0f9bf0d30e0065e707c813101aa173d9.png"><br>  al mismo tiempo, los clasifica, los acompaña y llama al <code>postProcessEnvironment</code> cada método. </p><br><p>  De esta manera, todos los <code>postProcessEnvironment</code> se inician en una etapa temprana antes de <code>SpringApplicationInitializer</code> .  En este caso, también se inicia un <code>EnvironmentPostProcessor</code> incomprensible <code>EnvironmentPostProcessor</code> llamado <code>ConfigFileApplicationListener</code> . </p><br><p>  Cuando se configura el entorno, todo vuelve a Carlson nuevamente. </p><br><p>  Si el entorno está listo, puede crear un contexto.  Y Carlson comienza a construir contexto con el <code>ApplicationInitializer</code> .  Aquí tenemos nuestra propia pieza, que comprueba que en el contexto hay un entorno en el que hay perfiles activos.  Si no, estamos cayendo, porque de lo contrario tendremos problemas más tarde.  Entonces los arrancadores funcionan, con todas las configuraciones habituales ya. </p><br><p>  La imagen de arriba refleja que a Spring tampoco le está yendo bien.  Dichos extraterrestres se reúnen periódicamente allí, no se respeta la responsabilidad individual y debe escalar con cuidado. </p><br><p>  Ahora queremos hablar un poco sobre el otro lado de esta extraña criatura, que es oyente por un lado y <code>EnvironmentPostProcessor</code> por el otro. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ffc/200/bf0/ffc200bf085fd822e7fd1fdf6d9e8fec.png"><br></p><br><p>  Al igual que <code>EnvironmentPostProcessor</code> puede cargar application.yml, propiedades de la aplicación, todo tipo de variables de entorno, argumentos de comando, etc.  Y como oyente, puede escuchar dos eventos: </p><br><ul><li> <code>ApplicationPreparedEvent</code> </li> <li> <code>ApplicationEnvironmentPreparedEvent</code> </li> </ul><br><p>  La pregunta es: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/452/851/6fc/4528516fcdf7fa9038e8ae80d2a8ac9a.png"><br></p><br><p>  Todos estos eventos fueron en la vieja primavera.  Y los que mencionamos anteriormente son eventos de Spring Boot (eventos especiales que agregó para su ciclo de vida).  Y hay un montón de ellos.  Estos son los principales: </p><br><ul><li> <code>ApplicationStartingEvent</code> </li> <li> <code>ApplicationEnvironmentPreparedEvent</code> </li> <li> <code>ApplicationPreparedEvent</code> </li> <li> <code>ContextRefreshedEvent</code> </li> <li> <code>EmbeddedServletContainerInitializedEvent</code> </li> <li> <code>ApplicationReadyEvent</code> </li> <li> <code>ApplicationFailedEvent</code> </li> </ul><br><p>  Esta lista está lejos de todo.  Pero es importante que algunos de ellos se relacionen con Spring Boot, y parte de Spring (buen viejo <code>ContextRefreshedEvent</code> , etc.). </p><br><p>  La advertencia es que no todos estos eventos podemos obtener en la aplicación (los simples mortales, diferentes abuelas, no pueden simplemente escuchar los eventos complejos que lanza Spring Boot).  Pero si conoce los mecanismos secretos de spring.factories y define su Application Listener en el nivel de spring.factories, estos eventos desde la etapa más temprana de inicio de la aplicación le llegarán. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/54f/14e/bca/54f14ebca5de6e029b3b47dc50f8c7e2.png"><br></p><br><p>  Como resultado, puede influir en el inicio de su aplicación en una etapa bastante temprana.  El chiste, sin embargo, es que parte de este trabajo se lleva a cabo en otras entidades, como <code>EnvironmentPostProcessor</code> y <code>ApplicationContextInitializer</code> . </p><br><p>  Podrías hacer todo en los oyentes, pero sería inconveniente y feo.  Si desea escuchar todos los eventos que lanza Spring, y no solo <code>ContextRefreshedEvent</code> y <code>ContextStartedEvent</code> , no necesita configurar el oyente, como un bean, de la forma habitual (de lo contrario, se crea demasiado tarde).  También debe registrarse a través de spring.factories, luego se creará mucho antes. </p><br><p>  Por cierto, cuando miramos esta lista, no nos quedó claro cuándo se <code>ContextStartedEvent</code> y <code>ContextStoppedEvent</code> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/796/e78/7ca/796e787ca88d7271898b4072c03d3691.png"><br></p><br><p>  Resultó que estos eventos nunca funcionan en absoluto.  Durante mucho tiempo nos preguntamos qué eventos deberían detectarse para comprender que la aplicación realmente comenzó.  Y resultó que los eventos de los que estábamos hablando ahora aparecen cuando extrae con fuerza los métodos del contexto: </p><br><ul><li> <code>ctx.start();</code>  -&gt; <code>ContextStartedEvent</code> </li><li> <code>ctx.stop();</code>  -&gt; <code>ContextStoppedEvent</code> </li></ul><br><p>  Es decir  <code>SpringApplication.run</code> solo vendrán si ejecutamos <code>SpringApplication.run</code> , obtenemos el contexto, <code>ctx.start();</code> de él <code>ctx.start();</code>  o <code>ctx.stop();</code>  .  No está muy claro por qué esto es necesario.  Pero, nuevamente, te dieron un punto de extensión. </p><br><p>  ¿Spring tiene algo que ver con esto?  Si es así, en algún lugar debería haber una excepción: </p><br><ul><li> <code>ctx.stop();</code>  (1) </li><li> <code>ctx.start();</code>  (2) </li><li> <code>ctx.close();</code>  (3) </li><li> <code>ctx.start();</code>  (4) </li></ul><br><p>  De hecho, estará en la última línea, porque después de <code>ctx.close();</code>  nada se puede hacer con el contexto.  Pero llame a <code>ctx.stop();</code>  antes de <code>ctx.start();</code>  - puedes (Spring simplemente ignora estos eventos, son solo para ti). </p><br><p>  Escriba a sus oyentes, escúchese a usted mismo, <code>ctx.stop();</code> sus leyes, qué hacer en <code>ctx.stop();</code>  y qué hacer en <code>ctx.start();</code>  . </p><br><p>  En total, el diagrama de interacción y ciclo de vida de la aplicación se parece a esto: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f05/25b/6b5/f0525b6b5742a9a7969a17465b174a4f.png"><br></p><br><p>  Los colores aquí muestran diferentes períodos de la vida. </p><br><ul><li>  Azul es Spring Boot, la aplicación ya ha comenzado.  Esto significa que las solicitudes de servicio de Tomcat que llegan de los clientes se procesan, todo el contexto se plantea definitivamente, todos los beans funcionan, las bases de datos están conectadas, etc. </li><li>  Verde: un evento <code>ContextRefreshedEvent</code> llegado y se construye el contexto.  A partir de este momento, por ejemplo, los escuchas de aplicaciones comienzan a funcionar, lo que implementa ya sea configurando la anotación ApplicationListener o mediante la interfaz homónima con un genérico que escucha ciertos eventos.  Si desea recibir más eventos, debe escribir el mismo ApplicationListener en spring.factories (el Spring habitual funciona aquí).  Una barra indica dónde comienza el informe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Spring Ripper</a> . </li><li>  En una etapa anterior, SpringApplication funciona, lo que prepara el contexto para nosotros.  Este es el trabajo de preparar la aplicación que hicimos cuando éramos desarrolladores regulares de Spring.  Por ejemplo, WebXML configurado. </li><li>  Pero incluso hay etapas más tempranas.  Muestra quién, dónde y para quién trabaja. </li><li>  Todavía hay una etapa gris en la que es imposible acuñar de ninguna manera.  Esta es la etapa en la que SpringApplication se ejecuta fuera de la caja (solo ingrese al código). </li></ul><br><p>  Si se dio cuenta, durante el informe de dos partes, fuimos de derecha a izquierda: comenzamos desde el final, atornillamos la configuración que voló desde el arranque, luego agregamos lo siguiente, etc.  Ahora hablemos rápidamente toda la cadena en la dirección opuesta. <br>  Usted escribe en su <code>SpringApplication.run</code> principal.  Encuentra diferentes oyentes, les lanza un evento que comenzó a construir.  Después de eso, los oyentes encuentran <code>EnvironmentPostProcessor</code> , les permiten configurar el entorno.  Una vez que se configura el entorno, comenzamos a construir contexto (entra Carlson).  Carlson crea el contexto y permite que todos los inicializadores de aplicaciones hagan algo con este contexto.  Tenemos un punto de extensión.  Después de esto, el contexto ya está configurado y luego comienza a suceder lo mismo que en la aplicación Spring habitual, cuando se construye el contexto: <code>BeanFactoryPostProcessor</code> , <code>BeanPostProcessor</code> , se configuran los beans.  Esto es lo que hace Spring ordinaria. </p><br><h2>  Como correr </h2><br><p>  Hemos terminado de discutir el proceso de redacción de una solicitud. </p><br><p>  Pero teníamos una cosa más que a los desarrolladores no les gusta.  No les gusta pensar cómo, al final, comenzará su aplicación.  ¿El administrador lo ejecutará en Tomcat, JBoss o en WebLogic?  Solo tiene que funcionar.  Si no funciona, en el peor de los casos, el desarrollador tendrá que configurar algo nuevamente </p><br><p>  ¿Cuáles son nuestros métodos de lanzamiento? </p><br><ul><li>  guerra de tomcat; </li><li>  idea </li><li>  <code>java -jar/war</code> . </li></ul><br><p>  Tomcat no es una tendencia masiva, no hablaremos de ello en detalle. </p><br><p>  La idea tampoco es, en principio, muy interesante.  Es un poco más complicado de lo que diré a continuación.  Pero en Idea, en principio, no debería haber problemas.  Ella ve qué tipo de dependencias traerá el motor de arranque. <br>  Si hacemos <code>java -jar</code> , el problema principal es construir un classpath antes de iniciar la aplicación. </p><br><p>  ¿Qué hizo la gente en 2001?  Escribieron <code>java -jar</code> qué jar debería ejecutarse, luego un espacio, <code>classpath=...</code> y los scripts se indicaron allí.  En nuestro caso, hay 150 MB de varias dependencias que los iniciadores agregaron.  Y todo esto debería hacerse manualmente.  Naturalmente, nadie hace eso.  Simplemente escribimos: <code>java -jar</code> , qué jar debe ejecutarse y eso es todo.  De alguna manera, el classpath todavía se está construyendo.  Hablaremos de esto ahora. </p><br><p>  Comencemos con la preparación del archivo jar para que incluso se pueda iniciar sin Tomcat.  Antes de hacer <code>java -jar</code> , necesitas construir un jar.  Este frasco obviamente debería ser inusual, algún tipo de análogo de guerra, donde todo estará dentro, incluido Tomcat incrustado. </p><br><pre> <code class="java hljs">&lt;build&gt; &lt;plugins&gt;    &lt;plugin&gt;       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;       &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;    &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;</code> </pre> <br><p>  Cuando descargamos el proyecto, alguien ya registró un complemento en nuestro POM.  Aquí, por cierto, puede lanzar configuraciones, pero más sobre eso más adelante.     jar,   Maven  Gradle  ,   jar .      : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/877/aad/b8e/877aadb8e0edbfbe6df10853b8c3f0c9.png"><br></p><br><p>     : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5ea/499/a35/5ea499a35d217fca525c27d7c8d2cfd3.png"><br></p><br><p>     war-. </p><br><p> ,     . </p><br><p>     ,    jar.    <code>java -jar</code> ,   ,    , , <code>org.springframework.boot</code> .      .     org.springframework.boot package.         <code>META-INF</code> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5a0/6c7/31e/5a06c731e6b958d02f683de73b2c5a9c.png"><br></p><br><p> Spring Boot   MANIFEST (    Maven  Gradle),     main class,    jar-. </p><br><p>  ,  jar-    :     -,    main-.     <code>java -jar</code>   -jar,   ,   main-class-. </p><br><p>  ,   ,        MANIFEST,  main-class   ,    main (    Idea).     ,     .     class path?    <code>java -jar</code>  ,  main,   , —    main,     .    MANIFEST      JarLauncher. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/496/8b5/f76/4968b5f76b6ece2fc7431dbc6195d14e.png"><br></p><br><p>  Es decir     ,     ,    JarLauncher.    ,    main,     class path. <br>    ,    main?   property — <code>Start-class</code> . </p><br><p>  Es decir       .     class path  jar. ,    — <code>org.springframework.boot</code> —   class path.      <code>org.springframework.boot.loader.JarLauncher</code>  main-class.   , main-class  .   class path,    <code>BOOT-INF</code> (   lib     class  ,      ). </p><br><p>    RavenApplication, properties   class  <code>BOOT-INF</code> ,   ,  Tomcat  ,   <code>BOOT-INF/lib/</code> .  JarLauncher  classpath,     —  ,    <code>start-class</code> .     Spring, <code>ContextSpringApplication</code> —   flow,     . </p><br><p>   ,   start-class-?    ,     .      ,  . </p><br><p> ,     .     property,   <code>mainClass</code> ,   MANIFEST   <code>Start-Class</code> ,  <code>mainClass</code> —   JarLauncher. </p><br><p>      ,   mainClass,   ?     . Spring boot plugin   –  mainClass: </p><br><ul><li>     –    .     —     main class; </li><li>    – ,   mainClass   <code>@SpringBootApplication</code>   , , ,  ; </li><li>    —  exception   ,    main class,  ,     jar-  .  Es decir    ,  ,   . ,   ,     main class. </li><li>  @SpringBootApplication  —   . </li></ul><br><p> JarLauncher   .   Tomcat     WarLauncher,      war-  ,  jar-. </p><br><p>    ,     <code>java -jar</code> .   ?  Usted puede   . </p><br><pre> <code class="java hljs">&lt;build&gt; &lt;plugins&gt;    &lt;plugin&gt;       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;       &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;       &lt;configuration&gt;          &lt;executable&gt;<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>&lt;/executable&gt;       &lt;/configuration&gt;    &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;</code> </pre> <br><p>     <code>&lt;configuration&gt;</code>    <code>&lt;executable&gt;true&lt;/executable&gt;</code>    Gradle  ,  : </p><br><pre> <code class="java hljs">springBoot { executable = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> }</code> </pre> <br><p>      jar   executable jar.       . </p><br><p>  ,    .   Windows ,     exe-,   .       Spring Boot, ..   jar,    .      ,    . <br>   ? </p><br><p>      (jar —  zip-,     ): </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/355/f0a/08d/355f0a08d8a971a533cd824c84939827.png"><br></p><br><p> Spring Boot  - . </p><br><p>  -,   jar-.   ,      ,     — <code>#!/bin/bash</code> .     . </p><br><p>       .   <code>exit 0</code>   -  —      zip-. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/365/674/922/365674922651752dc5a5896f48764d8e.png"><br></p><br><p>   ,   zip-    — <code>0xf4ra</code> .     ,  ,    . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/60e/915/263/60e915263d6af6d19a5f0a7df977ee82.png"><br></p><br><p>       (,   ..). </p><br><p>  jar    : </p><br><ul><li>     —     ; </li><li>  ,    "   bash" ( <code>#!/bin/bash</code> ); </li><li> bash   ; </li><li>      <code>exit 0</code> ; </li><li>    <code>java -jar</code>   —     jar-,   ; </li><li>  <code>java -jar</code>  zip-   jar-,  ,    ,       . </li></ul><br><h2>  Conclusiones </h2><br><p>         ,  Spring Boot —   ,     ,     . </p><br><p> -,  .  ,    Spring,   Spring —      Spring Boot.    ,         ,        — , ,   ,     . ,  ,     Spring, Spring Boot  . </p><br><p> -,    <code>@SpringBootApplication</code> ,     best practice,     Spring-. </p><br><p>   —   ,     ,   .    property  environment variable,    var arg   ,       ,    JSON.            <code>@value</code>       ,    .  configuration properties ,     ,     ,       .  ,  Spring     .   ,     ,      . </p><br><p>  .      ,    .          Spring,  Spring Boot    .    - ,   ,  ,           . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dc9/832/498/dc983249828e3fd26a257f871e46409e.png"><br></p><br><blockquote>  Minuto de publicidad. 19-20    Joker 2018,            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">«          [Joker Edition]»</a> ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">«Micronaut vs Spring Boot,     ?»</a>  .  ,  Joker       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425333/">https://habr.com/ru/post/es425333/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425323/index.html">"Madriguera de conejo". Diseñador UX en el equipo de producto.</a></li>
<li><a href="../es425325/index.html">Intérpretes de bytecode de bricolaje</a></li>
<li><a href="../es425327/index.html">Programación funcional: mida siete veces, corte una vez</a></li>
<li><a href="../es425329/index.html">Algunos consejos para los millennials de los "viejos". Cómo triunfar en nuestro mundo digital</a></li>
<li><a href="../es425331/index.html">Alice ayudará a los desarrolladores a encontrar objetos en las solicitudes de los usuarios. NER en diálogos</a></li>
<li><a href="../es425335/index.html">Invicto Armada Garmin</a></li>
<li><a href="../es425337/index.html">Cómo escalar Scrum: algunas palabras sobre el marco de desarrollo ágil de Nexus</a></li>
<li><a href="../es425339/index.html">Arquitectura de la información de Internet Parte 2</a></li>
<li><a href="../es425341/index.html">Descripción general de "Top 3D Expo. Educación digital 2018 »</a></li>
<li><a href="../es425343/index.html">25 herramientas útiles de Kubernetes: implementación y administración</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>