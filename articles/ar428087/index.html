<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸🏻 🧠 🙇🏿 "هذا هو السؤال" بدون قفل أو بدون قفل ، "أو" النوم الصحي أسوأ من الفجل المرير " 🐖 👌🏿 👩🏽‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ألهمتني التعليقات على مقالة " كيف تنام بشكل صحيح وخاطئ" كتابة هذه المقالة. 


 ستركز هذه المقالة على تطوير تطبيقات متعددة الخيوط ، وقابلية تطبيق القفل...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"هذا هو السؤال" بدون قفل أو بدون قفل ، "أو" النوم الصحي أسوأ من الفجل المرير "</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428087/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  ألهمتني التعليقات على مقالة " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">كيف تنام بشكل صحيح</a> وخاطئ" كتابة هذه المقالة. </p><br><p style=";text-align:right;direction:rtl">  ستركز هذه المقالة على تطوير تطبيقات متعددة الخيوط ، وقابلية تطبيق القفل بدون قفل على بعض الحالات التي نشأت أثناء العمل على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">LAppS</a> ، على وظيفة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">النوم النانوي</a> والعنف في برنامج جدولة المهام. </p><br><pre style=";text-align:right;direction:rtl"><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">NB</span></span>:      <span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span>++  <span class="hljs-selector-tag"><span class="hljs-selector-tag">Linux</span></span>,       <span class="hljs-selector-tag"><span class="hljs-selector-tag">POSIX</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1-2008</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> (    ).</code> </pre> <br><p style=";text-align:right;direction:rtl">  بشكل عام ، كل شيء فوضوي جدًا ، آمل أن يكون قطار الفكر في العرض التقديمي واضحًا.  إذا كنت مهتمًا ، فأنا أطلب قطة. </p><a name="habracut"></a><br><p style=";text-align:right;direction:rtl">  البرامج الموجهة للأحداث تنتظر دائمًا شيئًا ما.  سواء كانت واجهة المستخدم الرسومية أو خادم الشبكة ، فإنهم ينتظرون أي أحداث: إدخال لوحة المفاتيح ، أحداث الماوس ، حزمة البيانات التي تصل عبر الشبكة.  لكن كل البرامج تنتظر بشكل مختلف.  لا يجب أن تنتظر الأنظمة الخالية من القفل على الإطلاق.  على الأقل يجب أن يحدث استخدام خوارزميات بدون قفل حيث لا تحتاج إلى الانتظار ، وحتى ضار.  لكننا نتحدث عن أنظمة تنافسية (متعددة الخيوط) ، ومن الغريب أن الخوارزميات الخالية من القفل تنتظر أيضًا.  نعم ، إنهم لا يمنعون تنفيذ الخيوط المتوازية ، لكنهم هم أنفسهم ينتظرون الفرصة للقيام بشيء ما دون الحجب. </p><br><p style=";text-align:right;direction:rtl">  يستخدم LAppS كائنات المزاج و الإشارات بنشاط كبير.  في الوقت نفسه ، لا توجد إشارات في معيار C ++.  الآلية مهمة للغاية ومريحة ، ولكن يجب أن تعمل C ++ على الأنظمة التي لا تحتوي على دعم إشارة ، وبالتالي لا يتم تضمين الإشارات في المعيار.  علاوة على ذلك ، إذا كنت أستخدم الإشارات لأنها مريحة ، فعندئذٍ يجب تغيير المزامنة لأنني مضطر إلى ذلك. </p><br><p style=";text-align:right;direction:rtl">  يؤدي سلوك كائن المزامنة في حالة القفل التنافسي () ، مثل sem_wait () في Linux ، إلى وضع مؤشر الترابط المنتظر في نهاية قائمة انتظار جدولة المهام ، وعندما يكون في الأعلى ، يتكرر التحقق دون العودة إلى منطقة المستخدم ، يتم إعادة سلسلة الرسائل إلى قائمة الانتظار إذا الحدث المتوقع لم يحدث بعد.  هذه نقطة مهمة جدا </p><br><p style=";text-align:right;direction:rtl">  وقررت أن أتحقق مما إذا كان يمكنني رفض إشارات std :: mutex و POSIX ، ومضاهاة std :: atomic ، ونقل الحمل في الغالب إلى userland.  فشل في الواقع ، ولكن أول الأشياء أولاً. </p><br><p style=";text-align:right;direction:rtl">  أولاً ، لدي عدة أقسام يمكن أن تكون فيها هذه التجارب مفيدة: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  أقفال في LibreSSL (الحالة 1) ؛ </li><li style=";text-align:right;direction:rtl">  الحجب عند نقل الحزم المستلمة إلى تطبيقات Lua (الحالة 2) ؛ </li><li style=";text-align:right;direction:rtl">  في انتظار أحداث الحمولة جاهزة لتتم معالجتها بواسطة تطبيقات Lua (الحالة 3). </li></ul><br><p style=";text-align:right;direction:rtl">  لنبدأ مع أقفال غير مانعة للحظر.  دعنا نكتب كائن المزامنة لدينا باستخدام atomics ، كما هو موضح في بعض الخطب التي كتبها H. Sutter (لا يوجد رمز أصلي ، وبالتالي ، من الذاكرة وبالتالي لا يتزامن الرمز مع 100 ٪ الأصلي ، وفي Satter كان هذا الرمز مرتبطًا بتقدم C ++ 20 ، لذلك هناك اختلافات).  وعلى الرغم من بساطة هذا الرمز ، إلا أن هناك عيوبًا فيه. </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs kotlin">#include &lt;atomic&gt; #include &lt;pthread.h&gt; namespace test { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutex</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: std::atomic&lt;pthread_t&gt; mLock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: explicit mutex():mLock{<span class="hljs-number"><span class="hljs-number">0</span></span>} { } mutex(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mutex&amp;)=delete; mutex(mutex&amp;)=delete; void lock() { pthread_t locked_by=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  C++20     , .. compare_exchange_strong          while(!mLock.compare_exchange_strong(locked_by,pthread_self())) { locked_by=0; //      } } void unlock() { pthread_t current=pthread_self(); if(!mLock.compare_exchange_strong(current,0)) { throw std::system_error(EACCES, std::system_category(), "An attempt to unlock the mutex owned by other thread"); } } const bool try_lock() { pthread_t unused=0; return mLock.compare_exchange_strong(unused,pthread_self()); } }; }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  على عكس std :: mutex :: unlock () ، فإن سلوك test :: mutex: unlock () عند محاولة إلغاء القفل من مؤشر ترابط آخر هو أمر حتمي.  سيتم طرح استثناء.  هذا أمر جيد ، على الرغم من أنه لا يتفق مع السلوك القياسي.  وما هو السيئ في هذه الفئة؟  الخبر السيئ هو أن أسلوب test :: mutex: lock () سيستهلك بلا خجل موارد وحدة المعالجة المركزية في الحصص الزمنية المخصصة لمؤشر الترابط ، في محاولات للسيطرة على كائن المزامنة الذي يمتلكه مؤشر ترابط آخر بالفعل.  على سبيل المثال  حلقة في الاختبار :: mutex: lock () ستكون مضيعة لموارد وحدة المعالجة المركزية.  ما هي خياراتنا للتغلب على هذا الوضع؟ </p><br><p style=";text-align:right;direction:rtl">  يمكننا استخدام Schedule_yield () (كما هو مقترح في أحد التعليقات على المقالة أعلاه).  هل هو بهذه البساطة؟  أولاً ، من أجل استخدام الجدولة الزمنية () ، من الضروري أن تستخدم سلاسل التنفيذ سياسات SCHED_RR ، SCHED_FIFO لتحديد أولوياتها في برنامج جدولة المهام.  وإلا ، فإن استدعاء Schedule_yield () سيكون مضيعة لموارد وحدة المعالجة المركزية.  ثانيًا ، ستؤدي المكالمة المتكررة جدًا إلى Schedule_yield () إلى زيادة استهلاك وحدة المعالجة المركزية.  علاوة على ذلك ، فإن استخدام سياسات الوقت الفعلي في تطبيقك ، وشريطة عدم وجود تطبيقات أخرى في الوقت الفعلي في النظام ، سيحد من قائمة انتظار المجدول مع السياسة المحددة لموضوعاتك فقط.  يبدو أن هذا أمر جيد!  لا ، ليس جيدًا.  النظام بأكمله سيصبح أقل استجابة ، لأنه  مشغول بالمهمة ذات الأولوية.  سوف يكون CFQ في القلم.  ولكن هناك مؤشرات ترابط أخرى في التطبيق ، وغالبًا ما ينشأ موقف عندما يتم وضع مؤشر الترابط الذي استحوذ على كائن المزامنة في نهاية قائمة الانتظار (انتهت صلاحية الحصة) ، والموضوع الذي ينتظر تحرير كائن المزامنة أمامه مباشرة.  في تجربتي (الحالة 2) ، أعطت هذه الطريقة نفس النتائج (3.8٪ أسوأ) من std :: mutex ، لكن النظام أقل استجابة وزاد استهلاك وحدة المعالجة المركزية بنسبة 5٪ -7٪. </p><br><p style=";text-align:right;direction:rtl">  يمكنك تجربة تغيير الاختبار :: mutex :: lock () مثل هذا (سيئ أيضًا): </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> locked_by=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!mLock.compare_exchange_strong(locked_by,pthread_self())) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">thread_local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pause</span></span></span><span class="hljs-class">{</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// -      nanosleep(&amp;pause,nullptr); locked_by=0; } }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  هنا يمكنك تجربة مدة النوم بالنانو ثانية ، وكان 4 ns من التأخير هو الأمثل لوحدة المعالجة المركزية الخاصة بي وكان انخفاض الأداء نسبة إلى std :: mutex في نفس الحالة 2 كان 1.2٪.  ليس حقيقة أن النوم نانو 4ns.  في الواقع ، أو أكثر (في الحالة العامة) أو أقل (إذا تمت مقاطعته).  كان السقوط (!) في استهلاك وحدة المعالجة المركزية 12٪ -20٪.  على سبيل المثال  كان هذا حلم صحي. </p><br><p style=";text-align:right;direction:rtl">  لدى OpenSSL و LibreSSL وظيفتان تقومان بإعداد الاسترجاعات لحظرها عند استخدام هذه المكتبات في بيئة متعددة الخيوط.  يبدو هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">//  callback <span class="hljs-type"><span class="hljs-type">void</span></span> openssl_crypt_locking_function_callback(<span class="hljs-type"><span class="hljs-type">int</span></span> mode, <span class="hljs-type"><span class="hljs-type">int</span></span> n, const <span class="hljs-type"><span class="hljs-type">char</span></span>* file, const <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-type"><span class="hljs-type">line</span></span>) { static std::vector&lt;std::mutex&gt; locks(CRYPTO_num_locks()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n&gt;=static_cast&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;(locks.size())) { <span class="hljs-keyword"><span class="hljs-keyword">abort</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mode &amp; CRYPTO_LOCK) locks[n].<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> locks[n].unlock(); } //  callback-a CRYPTO_set_locking_callback(openssl_crypt_locking_function_callback); //  id CRYPTO_set_id_callback(pthread_self);</code> </pre> <br><p style=";text-align:right;direction:rtl">  والآن أسوأ شيء هو أن استخدام الاختبار أعلاه: mutex mutex في LibreSSL يقلل من أداء LAppS مرتين تقريبًا.  علاوة على ذلك ، بغض النظر عن الخيار (حلقة انتظار فارغة ، Sched_yield () ، nanosleep ()). </p><br><p style=";text-align:right;direction:rtl">  بشكل عام ، نحذف الحالة 2 والحالة 1 ، ونبقى مع std :: mutex. </p><br><p style=";text-align:right;direction:rtl">  دعنا ننتقل إلى الإشارات.  هناك العديد من الأمثلة على كيفية تنفيذ الإشارات باستخدام std :: condition_variable.  جميعهم يستخدمون std :: mutex أيضًا.  ومحاكاة الإشارة هذه أبطأ (وفقًا لاختباراتي) من أجهزة إشارة نظام POSIX. </p><br><p style=";text-align:right;direction:rtl">  لذلك ، سنقوم بعمل إشارة على الذرات: </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs java"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">semaphore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: std::atomic&lt;bool&gt; mayRun; mutable std::atomic&lt;int64_t&gt; counter; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">explicit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">semaphore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> : mayRun</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>},counter{<span class="hljs-number"><span class="hljs-number">0</span></span>} { } semaphore(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> semaphore&amp;)=delete; semaphore(semaphore&amp;)=delete; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ++counter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mayRun.load(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mayRun.load()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(counter.fetch_sub(<span class="hljs-number"><span class="hljs-number">1</span></span>)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++counter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::system_error(ENOENT,std::system_category(),<span class="hljs-string"><span class="hljs-string">"Semaphore is destroyed"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!try_wait()) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> thread_local <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> struct timespec pause{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}; nanosleep(&amp;pause,nullptr); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mayRun.store(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> int64_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrimentOn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size_t value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mayRun.load()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter.fetch_sub(value); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::system_error(ENOENT,std::system_category(),<span class="hljs-string"><span class="hljs-string">"Semaphore is destroyed"</span></span>); } } ~semaphore() { destroy(); } };</code> </pre> <br><p style=";text-align:right;direction:rtl">  أوه ، هذا إشارة أسرع عدة مرات من إشارة النظام.  نتيجة اختبار منفصل لهذه الإشارة مع موفر واحد و 20 كونسيرمار: </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs bash">OS semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Started 20 threads waiting on a semaphore Thread(OS): wakes: 500321 Thread(OS): wakes: 500473 Thread(OS): wakes: 501504 Thread(OS): wakes: 502337 Thread(OS): wakes: 498324 Thread(OS): wakes: 502755 Thread(OS): wakes: 500212 Thread(OS): wakes: 498579 Thread(OS): wakes: 499504 Thread(OS): wakes: 500228 Thread(OS): wakes: 499696 Thread(OS): wakes: 501978 Thread(OS): wakes: 498617 Thread(OS): wakes: 502238 Thread(OS): wakes: 497797 Thread(OS): wakes: 498089 Thread(OS): wakes: 499292 Thread(OS): wakes: 498011 Thread(OS): wakes: 498749 Thread(OS): wakes: 501296 OS semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. 10000000 of posts <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> 20 waiting threads have taken 9924 milliseconds OS semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Post latency: 0.9924ns ======================================= AtomicEmu semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Started 20 threads waiting on a semaphore Thread(EmuAtomic) wakes: 492748 Thread(EmuAtomic) wakes: 546860 Thread(EmuAtomic) wakes: 479375 Thread(EmuAtomic) wakes: 534676 Thread(EmuAtomic) wakes: 501014 Thread(EmuAtomic) wakes: 528220 Thread(EmuAtomic) wakes: 496783 Thread(EmuAtomic) wakes: 467563 Thread(EmuAtomic) wakes: 608086 Thread(EmuAtomic) wakes: 489825 Thread(EmuAtomic) wakes: 479799 Thread(EmuAtomic) wakes: 539634 Thread(EmuAtomic) wakes: 479559 Thread(EmuAtomic) wakes: 495377 Thread(EmuAtomic) wakes: 454759 Thread(EmuAtomic) wakes: 482375 Thread(EmuAtomic) wakes: 512442 Thread(EmuAtomic) wakes: 453303 Thread(EmuAtomic) wakes: 480227 Thread(EmuAtomic) wakes: 477375 AtomicEmu semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. 10000000 of posts <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> 20 waiting threads have taken 341 milliseconds AtomicEmu semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Post latency: 0.0341ns</code> </pre><br><p style=";text-align:right;direction:rtl">  هذه الإشارة مع وظيفة مجانية تقريبًا () ، وهي أسرع 29 مرة من النظام ، وهي أيضًا سريعة جدًا في إيقاظ الخيوط التي تنتظرها: 29325 تنبيهًا لكل مللي ثانية ، مقابل 1007 تنبيهًا لكل مللي ثانية من النظام.  لديها سلوك قطعي مع إشارة تدمّر أو إشارة تدميرية.  وبطبيعة الحال ، سيجفولت عند محاولة استخدام واحد مدمر بالفعل. </p><br><p style=";text-align:right;direction:rtl">  (¹) في الواقع ، مرات عديدة في مللي ثانية لا يمكن تأجيل الدفق وإيقاظه من قبل المجدول.  لأن  post () لا يمنع ، في هذا الاختبار الاصطناعي ، انتظر () غالبًا ما يجد نفسه في موقف لا تحتاج فيه إلى النوم.  في الوقت نفسه ، تقرأ 7 خيوط على الأقل بالتوازي قيمة الإشارة. </p><br><p style=";text-align:right;direction:rtl">  ولكن استخدامه في حالة 3 في LAppS يؤدي إلى خسائر في الأداء بغض النظر عن وقت النوم.  يستيقظ في كثير من الأحيان للتحقق ، وتصل الأحداث في LAppS بشكل أبطأ بكثير (كمون الشبكة ، الكمون من جانب العميل الذي يولد الحمل ، إلخ).  والتحقق أقل من ذلك يعني أيضًا فقد الأداء. </p><br><p style=";text-align:right;direction:rtl">  علاوة على ذلك ، فإن استخدام النوم في مثل هذه الحالات وبطريقة مماثلة ضار تمامًا ، لأنه  على جهاز آخر ، قد يتبين أن النتائج مختلفة تمامًا (كما في حالة توقف تعليمات المجمّع مؤقتًا) ، ولكل طراز CPU ، يجب عليك أيضًا تحديد وقت التأخير. </p><br><p style=";text-align:right;direction:rtl">  تكمن ميزة كائنات المزامنة ونظام الإشارة في أن مؤشر ترابط التنفيذ لا يستيقظ حتى يحدث حدث (فتح كائن المزامنة أو زيادة الإشارة).  لا تضيع دورات CPU إضافية - الربح. </p><br><p style=";text-align:right;direction:rtl">  بشكل عام ، كل شيء من هذا الشرير ، تعطيل iptables على نظامي يعطي من 12 ٪ (مع TLS) إلى 30 ٪ (بدون TLS) مكاسب أداء ... </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar428087/">https://habr.com/ru/post/ar428087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar428077/index.html">React.js: دليل المبتدئين</a></li>
<li><a href="../ar428079/index.html">تطبيق مبادئ SOLID لتفاعل تطوير التطبيقات</a></li>
<li><a href="../ar428081/index.html">استخدام RxJS في تطوير التفاعل لإدارة حالة التطبيق</a></li>
<li><a href="../ar428083/index.html">تحليلات الويب تؤثر على المصفوفة - النظام الاستراتيجي Avinash Koshik</a></li>
<li><a href="../ar428085/index.html">ضربات الواجهة الأمامية: أعلى 10 (؟) تقارير HolyJS 2018 Piter</a></li>
<li><a href="../ar428089/index.html">"تقويم الفاحص" لشهر أكتوبر. ملاحظات: كيف يحدث ذلك</a></li>
<li><a href="../ar428091/index.html">كيف أنشأ طالب متدرب لعبة الفيديو الأكثر شعبية في العالم ، أو سجل ألعاب Windows</a></li>
<li><a href="../ar428095/index.html">أبحاث السوق لاستوديوهات الويب والوكالات الرقمية</a></li>
<li><a href="../ar428097/index.html">التوجيه العودي في MikroTik من خلال البوابات المعينة من قبل DHCP</a></li>
<li><a href="../ar428099/index.html">ما هو الشيء المشترك بين الفساتين العادية وعصر الجيل الخامس القادم؟</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>