<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì≠ ü§æüèæ üí∏ Wir machen ein maschinelles Lernprojekt in Python. Teil 1 üëàüèº üê∫ üê§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√úbersetzung eines vollst√§ndigen maschinellen Lernprojekts in Python: Teil 1 . 

 Wenn Sie ein Buch lesen oder eine Schulung zur Datenanalyse anh√∂ren, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir machen ein maschinelles Lernprojekt in Python. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/425253/"><img src="https://habrastorage.org/getpro/habr/post_images/5de/fed/62e/5defed62ea348f6e02365e283415b2fb.png"><br><br>  <i>√úbersetzung eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vollst√§ndigen maschinellen Lernprojekts in Python: Teil 1</a> .</i> <br><br>  Wenn Sie ein Buch lesen oder eine Schulung zur Datenanalyse anh√∂ren, haben Sie h√§ufig das Gef√ºhl, dass Sie mit einigen separaten Teilen eines Bildes konfrontiert sind, die nicht zusammengesetzt werden k√∂nnen.  Sie haben vielleicht Angst vor der Aussicht, den n√§chsten Schritt zu tun und ein Problem mithilfe des maschinellen Lernens vollst√§ndig zu l√∂sen, aber mithilfe dieser Artikelserie gewinnen Sie Vertrauen in die F√§higkeit, jedes Problem auf dem Gebiet der Datenwissenschaft zu l√∂sen. <br><br>  Damit Sie endlich ein vollst√§ndiges Bild im Kopf haben, schlagen wir vor, das Projekt der Verwendung von maschinellem Lernen unter Verwendung realer Daten von Anfang bis Ende zu analysieren. <br><a name="habracut"></a><br>  Gehen Sie nacheinander die folgenden Schritte durch: <br><br><ol><li>  Daten bereinigen und formatieren. </li><li>  Explorative Datenanalyse. </li><li>  Design und Auswahl der Funktionen. </li><li>  Vergleich der Metriken mehrerer Modelle f√ºr maschinelles Lernen. </li><li>  Hyperparametrische Abstimmung des besten Modells. </li><li>  Bewertung des besten Modells anhand eines Testdatensatzes. </li><li>  Interpretation der Ergebnisse des Modells. </li><li>  Schlussfolgerungen und Arbeit mit Dokumenten. </li></ol><br>  Sie erfahren, wie die Schritte ineinander √ºbergehen und wie Sie sie in Python implementieren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das ganze Projekt</a> ist auf GitHub verf√ºgbar, der erste Teil liegt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier.</a>  In diesem Artikel werden wir die ersten drei Stufen betrachten. <br><br><h2>  Aufgabenbeschreibung </h2><br>  Bevor Sie Code schreiben, m√ºssen Sie das zu l√∂sende Problem und die verf√ºgbaren Daten verstehen.  In diesem Projekt werden wir mit √∂ffentlich verf√ºgbaren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Energieeffizienzdaten f√ºr Geb√§ude</a> in New York arbeiten. <br><br>  Unser Ziel: Aus den verf√ºgbaren Daten ein Modell zu erstellen, das die Anzahl der Energy Star-Punkte f√ºr ein bestimmtes Geb√§ude vorhersagt, und die Ergebnisse zu interpretieren, um Faktoren zu finden, die den endg√ºltigen Wert beeinflussen. <br><br>  Die Daten enthalten bereits den zugewiesenen Energy Star Score. Unsere Aufgabe ist also maschinelles Lernen mit kontrollierter Regression: <br><br><ul><li>  Betreut: Wir kennen die Zeichen und den Zweck und haben die Aufgabe, ein Modell zu trainieren, das das erste mit dem zweiten vergleichen kann. </li><li>  Regression: Der Energy Star Score ist eine kontinuierliche Variable. </li></ul><br>  Unser Modell muss genau sein - damit es den Wert des Energy Star Score nahezu wahr und interpretierbar vorhersagen kann, damit wir seine Vorhersagen verstehen k√∂nnen.  Wenn wir die Zieldaten kennen, k√∂nnen wir sie verwenden, um Entscheidungen zu treffen, wenn wir tiefer in die Daten eintauchen und das Modell erstellen. <br><br><h2>  Datenbereinigung </h2><br>  Nicht jeder Datensatz ist ein perfekt aufeinander abgestimmter Beobachtungssatz ohne Anomalien und fehlende Werte (ein Hinweis auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MTCAR-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iris-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datens√§tze</a> ).  In realen Daten gibt es wenig Ordnung. Bevor Sie mit der Analyse beginnen, m√ºssen Sie sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">l√∂schen und</a> in ein akzeptables Format bringen.  Die Datenbereinigung ist ein unangenehmes, aber obligatorisches Verfahren zur L√∂sung der meisten Datenanalyseaufgaben. <br><br>  Zun√§chst k√∂nnen Sie die Daten in Form eines Pandas-Datenrahmens laden und untersuchen: <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np # <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> a dataframe data = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'data/Energy_and_Water_Data_Disclosure_for_Local_Law_84_2017__Data_for_Calendar_Year_2016_.csv'</span></span>) # Display top <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> dataframe data.head()</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/4ac/637/b86/4ac637b8682b2fcacddd155004681a0d.png"><br>  <i>So sehen echte Daten aus.</i> <br><br>  Dies ist ein Fragment einer Tabelle mit 60 Spalten.  Auch hier sind einige Probleme sichtbar: Wir m√ºssen den <code>Energy Star Score</code> vorhersagen, wissen aber nicht, was all diese Spalten bedeuten.  Dies ist zwar nicht unbedingt ein Problem, da Sie h√§ufig ein genaues Modell erstellen k√∂nnen, ohne etwas √ºber Variablen zu wissen.  Die Interpretierbarkeit ist uns jedoch wichtig, daher m√ºssen wir die Bedeutung von mindestens einigen Spalten herausfinden. <br><br>  Als wir diese Daten erhielten, fragten wir nicht nach den Werten, sondern sahen uns den Dateinamen an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a86/c00/ab2/a86c00ab2d64629e644e7186c78724f7.png"><br><br>  und beschlossen, nach "Local Law 84" zu suchen.  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Seite gefunden</a> , auf der steht, dass es sich um das in New York geltende Gesetz handelt, wonach die Eigent√ºmer aller Geb√§ude einer bestimmten Gr√∂√üe √ºber den Energieverbrauch berichten sollten.  Eine weitere Suche half dabei, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">alle Spaltenwerte zu finden</a> .  Vernachl√§ssigen Sie also nicht die Dateinamen, sie k√∂nnen ein guter Ausgangspunkt sein.  Dar√ºber hinaus ist dies eine Erinnerung daran, dass Sie nicht eilen und etwas Wichtiges nicht verpassen! <br><br>  Wir werden nicht alle Spalten studieren, aber wir werden uns definitiv mit dem Energy Star Score befassen, der wie folgt beschrieben wird: <br><br><blockquote>  Das Perzentil-Ranking liegt zwischen 1 und 100 und wird auf der Grundlage von Jahresberichten √ºber den Energieverbrauch der Bauherren selbst berechnet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Energy Star Score</a> ist ein relatives Ma√ü f√ºr den Vergleich der Energieeffizienz von Geb√§uden. </blockquote><br>  Das erste Problem wurde gel√∂st, das zweite blieb jedoch bestehen - fehlende Werte, markiert als "Nicht verf√ºgbar".  Dies ist ein Zeichenfolgenwert in Python. Dies bedeutet, dass auch Zeichenfolgen mit Zahlen als <code>object</code> gespeichert werden. Wenn die Spalte eine Zeichenfolge enth√§lt, konvertiert Pandas diese in eine Spalte, die vollst√§ndig aus einer Zeichenfolge besteht.  Die <code>dataframe.info()</code> k√∂nnen mit der Methode <code>dataframe.info()</code> ermittelt werden: <br><br><pre> <code class="hljs pgsql"># See the <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> non-missing <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> data.<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>()</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/db3/b4d/013/db3b4d013ca25d7e5ac483f0c24fa1e4.png"><br><br>  Sicherlich werden einige Spalten, die explizit Zahlen enthalten (wie z. B. ft¬≤), als Objekte gespeichert.  Wir k√∂nnen keine numerische Analyse auf Zeichenfolgenwerte anwenden, daher konvertieren wir sie in numerische Datentypen (insbesondere <code>float</code> )! <br><br>  Dieser Code ersetzt zun√§chst alle "Nicht verf√ºgbar" durch <i>keine Zahl</i> ( <code>np.nan</code> ), die als Zahlen interpretiert werden kann, und konvertiert dann den Inhalt bestimmter Spalten in einen <code>float</code> Typ: <br><br><pre> <code class="hljs pgsql"># Replace <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> occurrences <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Not</span></span> Available <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> a number data = data.replace({<span class="hljs-string"><span class="hljs-string">'Not Available'</span></span>: np.<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>}) # Iterate through the <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list(data.<span class="hljs-keyword"><span class="hljs-keyword">columns</span></span>): # <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> that should be <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">'ft¬≤'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'kBtu'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'Metric Tons CO2e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'kWh'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'therms'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'gal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'Score'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col): # Convert the data <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> data[col] = data[col].astype(<span class="hljs-type"><span class="hljs-type">float</span></span>)</code> </pre> <br>  Wenn die Werte in den entsprechenden Spalten bei uns zu Zahlen werden, k√∂nnen wir beginnen, die Daten zu untersuchen. <br><br><h4>  Fehlende und abnormale Daten </h4><br>  Neben falschen Datentypen ist das Fehlen von Werten eines der h√§ufigsten Probleme.  Sie k√∂nnen aus verschiedenen Gr√ºnden fehlen, und vor dem Training des Modells m√ºssen diese Werte entweder ausgef√ºllt oder gel√∂scht werden.  Lassen Sie uns zun√§chst herausfinden, wie viele Werte wir in jeder Spalte haben ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code ist hier</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b0/5da/a40/0b05daa40ba77acca25ed859856759f2.png"><br>  <i>Zum Erstellen einer Tabelle wurde eine Funktion aus einem Zweig in <u>StackOverflow verwendet</u> .</i> <br><br>  Informationen sollten immer mit Vorsicht entfernt werden. Wenn die Spalte viele Werte enth√§lt, wird dies unserem Modell wahrscheinlich nicht zugute kommen.  Der Schwellenwert, nach dem es besser ist, die Spalten wegzuwerfen, h√§ngt von Ihrer Aufgabe ab ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier eine Diskussion</a> ). In unserem Projekt werden Spalten gel√∂scht, die mehr als halb leer sind. <br><br>  Auch in diesem Stadium ist es besser, die abnormalen Werte zu entfernen.  Sie k√∂nnen aufgrund von Tippfehlern bei der Dateneingabe oder aufgrund von Fehlern in den Ma√üeinheiten auftreten oder sie k√∂nnen korrekte, aber extreme Werte sein.  In diesem Fall werden wir die "zus√§tzlichen" Werte entfernen, die sich an der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Definition extremer Anomalien orientieren</a> : <br><br><ul><li>  Unterhalb des ersten Quartils befindet sich ein 3 ‚àó Interquartilbereich. </li><li>  Oberhalb des dritten Quartils + 3 ‚àó Interquartilbereich. </li></ul><br>  Der Code, der Spalten und Anomalien entfernt, wird im Editor auf Github aufgelistet.  Nach Abschluss des Datenbereinigungsprozesses und der Beseitigung von Anomalien verf√ºgen wir √ºber mehr als 11.000 Geb√§ude und 49 Schilder. <br><br><h2>  Explorative Datenanalyse </h2><br>  Die langweilige, aber notwendige Phase der Datenbereinigung ist abgeschlossen, Sie k√∂nnen zur Studie gehen!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die explorative Datenanalyse</a> (RAD) ist ein unbegrenzter Zeitprozess, in dem wir Statistiken berechnen und nach Trends, Anomalien, Mustern oder Beziehungen in den Daten suchen. <br><br>  Kurz gesagt, RAD ist ein Versuch herauszufinden, welche Daten uns sagen k√∂nnen.  Normalerweise beginnt die Analyse mit einer oberfl√§chlichen √úberpr√ºfung, dann finden wir interessante Fragmente und analysieren sie genauer.  Die Ergebnisse k√∂nnen f√ºr sich genommen interessant sein oder zur Auswahl des Modells beitragen und bei der Entscheidung helfen, welche Funktionen wir verwenden werden. <br><br><h4>  Diagramme mit einer Variablen </h4><br>  Unser Ziel ist es, den Wert des Energy Star-Scores (in unseren Daten in unseren Score umbenannt) vorherzusagen. Daher ist es sinnvoll, zun√§chst die Verteilung dieser Variablen zu untersuchen.  Ein Histogramm ist eine einfache, aber effektive Methode zur Visualisierung der Verteilung einer einzelnen Variablen und kann mithilfe von <code>matplotlib</code> einfach <code>matplotlib</code> . <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt # Histogram <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the Energy Star Score plt.style.use(<span class="hljs-string"><span class="hljs-string">'fivethirtyeight'</span></span>) plt.hist(data[<span class="hljs-string"><span class="hljs-string">'score'</span></span>].dropna(), bins = <span class="hljs-number"><span class="hljs-number">100</span></span>, edgecolor = <span class="hljs-string"><span class="hljs-string">'k'</span></span>); plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Score'</span></span>); plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Number of Buildings'</span></span>); plt.title(<span class="hljs-string"><span class="hljs-string">'Energy Star Score Distribution'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/f82/bf3/84a/f82bf384af1bd0c407f1e680d0b47263.png"><br><br>  Sieht verd√§chtig aus!  Der Energy Star Score ist ein Perzentil, daher sollten Sie eine gleichm√§√üige Verteilung erwarten, wenn jeder Punkt der gleichen Anzahl von Geb√§uden zugewiesen wird.  Eine unverh√§ltnism√§√üig gro√üe Anzahl von Geb√§uden erzielte jedoch die h√∂chsten und niedrigsten Ergebnisse (f√ºr den Energy Star Score gilt: Je gr√∂√üer, desto besser). <br><br>  Wenn wir uns die Definition dieser Punktzahl noch einmal ansehen, werden wir sehen, dass sie auf der Grundlage von ‚ÄûBerichten, die von den Bauherren unabh√§ngig ausgef√ºllt wurden‚Äú berechnet wird, was den √úberschuss an sehr gro√üen Werten erkl√§ren kann.  Das Auffordern von Bauherren, ihren Energieverbrauch zu melden, ist wie das Auffordern von Sch√ºlern, ihre Noten in Pr√ºfungen anzugeben.  Dies ist vielleicht nicht das objektivste Kriterium f√ºr die Beurteilung der Energieeffizienz von Immobilien. <br><br>  Wenn wir unbegrenzt Zeit h√§tten, k√∂nnten wir herausfinden, warum so viele Geb√§ude sehr hohe und sehr niedrige Punkte haben.  Dazu m√ºssten wir die geeigneten Geb√§ude ausw√§hlen und sorgf√§ltig analysieren.  Wir m√ºssen jedoch nur lernen, wie man Punktzahlen vorhersagt, und keine genauere Bewertungsmethode entwickeln.  Sie k√∂nnen sich selbst markieren, dass die Punkte eine verd√§chtige Verteilung haben, aber wir werden uns auf die Prognose konzentrieren. <br><br><h4>  Beziehungssuche </h4><br>  Der Hauptteil der AHFR ist die Suche nach der Beziehung zwischen Zeichen und unserem Ziel.  Mit ihm korrelierende Variablen sind f√ºr die Verwendung im Modell n√ºtzlich, da sie f√ºr Prognosen verwendet werden k√∂nnen.  Eine M√∂glichkeit, die Auswirkung einer kategorialen Variablen (die nur einen begrenzten Satz von Werten annimmt) auf das Ziel zu untersuchen, besteht darin, die Dichte mithilfe der Seaborn-Bibliothek zu zeichnen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Dichtediagramm kann als gegl√§ttetes Histogramm betrachtet werden,</a> da es die Verteilung einer einzelnen Variablen zeigt.  Sie k√∂nnen einzelne Klassen im Diagramm einf√§rben, um zu sehen, wie eine kategoriale Variable die Verteilung √§ndert.  Dieser Code zeigt das Energy Star Score-Dichtediagramm, das nach Geb√§udetyp gef√§rbt ist (f√ºr eine Liste von Geb√§uden mit mehr als 100 Dimensionen): <br><br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> a list <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> buildings <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> more than <span class="hljs-number"><span class="hljs-number">100</span></span> measurements <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = data.dropna(subset=[<span class="hljs-string"><span class="hljs-string">'score'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>[<span class="hljs-string"><span class="hljs-string">'Largest Property Use Type'</span></span>].value_counts() <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = list(<span class="hljs-keyword"><span class="hljs-keyword">types</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">types</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">values</span></span> &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) # Plot <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> distribution <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> scores <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> building categories figsize(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) # Plot <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> building <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> b_type <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>: # <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> the building <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> subset = data[data[<span class="hljs-string"><span class="hljs-string">'Largest Property Use Type'</span></span>] == b_type] # Density plot <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Energy Star Scores sns.kdeplot(subset[<span class="hljs-string"><span class="hljs-string">'score'</span></span>].dropna(), label = b_type, shade = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, alpha = <span class="hljs-number"><span class="hljs-number">0.8</span></span>); # label the plot plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Energy Star Score'</span></span>, size = <span class="hljs-number"><span class="hljs-number">20</span></span>); plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Density'</span></span>, size = <span class="hljs-number"><span class="hljs-number">20</span></span>); plt.title(<span class="hljs-string"><span class="hljs-string">'Density Plot of Energy Star Scores by Building Type'</span></span>, size = <span class="hljs-number"><span class="hljs-number">28</span></span>);</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/23a/718/fd3/23a718fd3139123b609e2521ffe46e3c.png"><br><br>  Wie Sie sehen k√∂nnen, wirkt sich die Art des Geb√§udes stark auf die Anzahl der Punkte aus.  B√ºrogeb√§ude haben normalerweise eine h√∂here Punktzahl und Hotels eine niedrigere.  Sie m√ºssen also den Geb√§udetyp in das Modell aufnehmen, da dieses Zeichen unser Ziel beeinflusst.  Als kategoriale Variable m√ºssen wir eine One-Hot-Codierung des Geb√§udetyps durchf√ºhren. <br><br>  Ein √§hnliches Diagramm kann verwendet werden, um den Energy Star Score nach Stadtbezirken zu sch√§tzen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/224/c69/820/224c69820a5c0362f804e37ae7d5de55.png"><br><br>  Der Bereich beeinflusst die Punktzahl nicht so sehr wie die Art des Geb√§udes.  Trotzdem werden wir es in das Modell aufnehmen, da es einen kleinen Unterschied zwischen den Regionen gibt. <br><br>  Um die Beziehung zwischen den Variablen zu berechnen, k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Pearson-Korrelationskoeffizienten verwenden</a> .  Dies ist ein Ma√ü f√ºr die Intensit√§t und Richtung einer linearen Beziehung zwischen zwei Variablen.  Ein Wert von +1 bedeutet eine perfekt lineare positive Beziehung und -1 bedeutet eine perfekt lineare negative Beziehung.  Hier einige Beispiele f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pearson-Korrelationskoeffizientenwerte</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b3/455/654/0b34556548ab206112024fb0e8f69c01.png"><br><br>  Obwohl dieser Koeffizient nichtlineare Abh√§ngigkeiten nicht widerspiegeln kann, ist es m√∂glich, damit zu beginnen, um die Beziehungen von Variablen zu bewerten.  In Pandas k√∂nnen Sie auf einfache Weise Korrelationen zwischen beliebigen Spalten in einem Datenrahmen berechnen: <br><br><pre> <code class="hljs pgsql"># Find <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> correlations <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the score <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> sort correlations_data = data.corr()[<span class="hljs-string"><span class="hljs-string">'score'</span></span>].sort_values()</code> </pre> <br>  Die negativsten Korrelationen mit dem Ziel: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b62/181/178/b62181178669962fccf7caa472d9e2e8.png"><br><br>  und das positivste: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/598/47f/14a/59847f14a4d8afe1ce8ff237c5d3fa36.png"><br><br>  Es gibt mehrere starke negative Korrelationen zwischen den Attributen und dem Ziel, von denen die gr√∂√üten verschiedenen EUI-Kategorien angeh√∂ren (die Methoden zur Berechnung dieser Indikatoren unterscheiden sich geringf√ºgig).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EUI (Energy Use Intensity</a> ) ist die Menge an Energie, die von einem Geb√§ude verbraucht wird, geteilt durch einen Quadratfu√ü Fl√§che.  Dieser spezifische Wert wird zur Bewertung der Energieeffizienz verwendet. Je kleiner er ist, desto besser.  Die Logik legt nahe, dass diese Korrelationen gerechtfertigt sind: Wenn der EUI steigt, sollte der Energy Star Score sinken. <br><br><h4>  Diagramme mit zwei Variablen </h4><br>  Wir verwenden Streudiagramme, um die Beziehungen zwischen zwei kontinuierlichen Variablen zu visualisieren.  Sie k√∂nnen den Farben der Punkte zus√§tzliche Informationen hinzuf√ºgen, z. B. eine kategoriale Variable.  Die Beziehung zwischen dem Energy Star Score und dem EUI ist unten dargestellt. Die Farben zeigen verschiedene Geb√§udetypen an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/974/204/7de/9742047ded29c74a9a8e6df9bf6396d1.png"><br><br>  In diesem Diagramm k√∂nnen Sie einen Korrelationskoeffizienten von -0,7 visualisieren.  Wenn der EUI abnimmt, steigt der Energy Star Score. Diese Beziehung wird bei verschiedenen Geb√§udetypen beobachtet. <br><br>  Unsere neueste Forschungskarte hei√üt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pairs Plot</a> .  Dies ist ein gro√üartiges Werkzeug, um die Beziehungen zwischen verschiedenen Variablenpaaren und die Verteilung einzelner Variablen zu sehen.  Wir werden die Seaborn-Bibliothek und die PairGrid-Funktion verwenden, um ein Paardiagramm mit einem Streudiagramm im oberen Dreieck, einem diagonalen Histogramm, einem zweidimensionalen Kerndichtediagramm und Korrelationskoeffizienten im unteren Dreieck zu erstellen. <br><br><pre> <code class="hljs pgsql"># Extract the <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> plot plot_data = features[[<span class="hljs-string"><span class="hljs-string">'score'</span></span>, <span class="hljs-string"><span class="hljs-string">'Site EUI (kBtu/ft¬≤)'</span></span>, <span class="hljs-string"><span class="hljs-string">'Weather Normalized Source EUI (kBtu/ft¬≤)'</span></span>, <span class="hljs-string"><span class="hljs-string">'log_Total GHG Emissions (Metric Tons CO2e)'</span></span>]] # Replace the inf <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nan</span></span> plot_data = plot_data.replace({np.inf: np.<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>, -np.inf: np.<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>}) # <span class="hljs-keyword"><span class="hljs-keyword">Rename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> plot_data = plot_data.<span class="hljs-keyword"><span class="hljs-keyword">rename</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> = {<span class="hljs-string"><span class="hljs-string">'Site EUI (kBtu/ft¬≤)'</span></span>: <span class="hljs-string"><span class="hljs-string">'Site EUI'</span></span>, <span class="hljs-string"><span class="hljs-string">'Weather Normalized Source EUI (kBtu/ft¬≤)'</span></span>: <span class="hljs-string"><span class="hljs-string">'Weather Norm EUI'</span></span>, <span class="hljs-string"><span class="hljs-string">'log_Total GHG Emissions (Metric Tons CO2e)'</span></span>: <span class="hljs-string"><span class="hljs-string">'log GHG Emissions'</span></span>}) # <span class="hljs-keyword"><span class="hljs-keyword">Drop</span></span> na <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> plot_data = plot_data.dropna() # <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> calculate correlation coefficient <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> two <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> def corr_func(x, y, **kwargs): r = np.corrcoef(x, y)[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] ax = plt.gca() ax.annotate("r = {:.2f}".format(r), xy=(<span class="hljs-number"><span class="hljs-number">.2</span></span>, <span class="hljs-number"><span class="hljs-number">.8</span></span>), xycoords=ax.transAxes, size = <span class="hljs-number"><span class="hljs-number">20</span></span>) # <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> the pairgrid <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> grid = sns.PairGrid(data = plot_data, size = <span class="hljs-number"><span class="hljs-number">3</span></span>) # Upper <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a scatter plot grid.map_upper(plt.scatter, color = <span class="hljs-string"><span class="hljs-string">'red'</span></span>, alpha = <span class="hljs-number"><span class="hljs-number">0.6</span></span>) # Diagonal <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a histogram grid.map_diag(plt.hist, color = <span class="hljs-string"><span class="hljs-string">'red'</span></span>, edgecolor = <span class="hljs-string"><span class="hljs-string">'black'</span></span>) # Bottom <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> correlation <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> density plot grid.map_lower(corr_func); grid.map_lower(sns.kdeplot, cmap = plt.cm.Reds) # Title <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> entire plot plt.suptitle(<span class="hljs-string"><span class="hljs-string">'Pairs Plot of Energy Data'</span></span>, size = <span class="hljs-number"><span class="hljs-number">36</span></span>, y = <span class="hljs-number"><span class="hljs-number">1.02</span></span>);</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/5fa/4cc/94f/5fa4cc94f9b91df5ad4fda37aa3ae1f0.png"><br><br>  Suchen Sie nach dem Schnittpunkt von Zeilen und Spalten, um die Beziehung zwischen Variablen anzuzeigen.  Angenommen, Sie m√∂chten die Korrelation zwischen <code>Weather Norm EUI</code> und <code>score</code> , dann suchen wir nach der <code>Weather Norm EUI</code> Reihe und der <code>score</code> Spalte, an deren Schnittpunkt ein Korrelationskoeffizient von -0,67 liegt.  Diese Grafiken sehen nicht nur cool aus, sondern helfen auch bei der Auswahl von Variablen f√ºr das Modell. <br><br><h2>  Design und Auswahl der Funktionen </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Entwerfen und Ausw√§hlen von Funktionen</a> bringt h√§ufig die gr√∂√üte Rendite in Bezug auf die Zeit, die f√ºr maschinelles Lernen aufgewendet wird.  Zuerst geben wir die Definitionen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merkmalskonstruktion: Der</a> Prozess des Extrahierens oder Erstellens neuer Merkmale aus Rohdaten.  Um Variablen im Modell zu verwenden, m√ºssen Sie sie m√∂glicherweise transformieren, z. B. den nat√ºrlichen Logarithmus verwenden oder die Quadratwurzel extrahieren oder eine einmalige Codierung kategorialer Variablen anwenden.  Beim charakteristischen Design k√∂nnen zus√§tzliche Features aus Rohdaten erstellt werden. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merkmalsauswahl: Der</a> Prozess der Auswahl der relevantesten Merkmale aus Daten, bei dem einige Merkmale entfernt werden, damit das Modell neue Daten besser verallgemeinern kann, um ein besser interpretierbares Modell zu erhalten.  Die Wahl der Zeichen kann als Entfernung von ‚Äû√ºberfl√ºssig‚Äú betrachtet werden, so dass nur das Wichtigste √ºbrig bleibt. </li></ul><br>  Das Modell des maschinellen Lernens kann nur aus den von uns bereitgestellten Daten lernen. Daher ist es √§u√üerst wichtig sicherzustellen, dass wir alle f√ºr unsere Aufgabe relevanten Informationen enthalten.  Wenn Sie dem Modell nicht die richtigen Daten zur Verf√ºgung stellen, kann es nicht lernen und liefert keine genauen Vorhersagen! <br><br>  Wir werden Folgendes tun: <br><br><ul><li>  Anwendbar auf kategoriale Variablen (Quartal und Art des Eigentums) One-Hot-Codierung. </li><li>  Addieren Sie den nat√ºrlichen Logarithmus aller numerischen Variablen. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">One-Hot-Codierung ist</a> erforderlich, um kategoriale Variablen in das Modell aufzunehmen.  Der Algorithmus f√ºr maschinelles Lernen kann die Art des "B√ºros" nicht verstehen. Wenn es sich bei dem Geb√§ude also um ein B√ºro handelt, weisen wir ihm das Zeichen 1 zu, und wenn kein B√ºro, dann 0. <br><br>  Durch Hinzuf√ºgen transformierter Features kann das Modell nichtlineare Beziehungen innerhalb der Daten kennenlernen.  Bei der Analyse von Daten ist es √ºblich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, Quadratwurzeln zu extrahieren, nat√ºrliche Logarithmen zu verwenden oder die Zeichen irgendwie zu transformieren.</a> Dies h√§ngt von der spezifischen Aufgabe oder Ihrem Wissen √ºber die besten Techniken ab.  In diesem Fall addieren wir den nat√ºrlichen Logarithmus aller numerischen Zeichen. <br><br>  Dieser Code w√§hlt numerische Zeichen aus, berechnet ihre Logarithmen, w√§hlt zwei kategoriale Zeichen aus, wendet eine Hot-Codierung auf sie an und kombiniert beide S√§tze zu einem.  Nach der Beschreibung zu urteilen, bleibt noch viel zu tun, aber in Pandas ist alles ziemlich einfach! <br><br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">Copy</span></span> the original data features = data.<span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>() # <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> the <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> numeric_subset = data.select_dtypes(<span class="hljs-string"><span class="hljs-string">'number'</span></span>) # <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">log</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numeric_subset.<span class="hljs-keyword"><span class="hljs-keyword">columns</span></span>: # Skip the Energy Star Score <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> col == <span class="hljs-string"><span class="hljs-string">'score'</span></span>: next <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: numeric_subset[<span class="hljs-string"><span class="hljs-string">'log_'</span></span> + col] = np.log(numeric_subset[col]) # <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> the categorical <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> categorical_subset = data[[<span class="hljs-string"><span class="hljs-string">'Borough'</span></span>, <span class="hljs-string"><span class="hljs-string">'Largest Property Use Type'</span></span>]] # One hot encode categorical_subset = pd.get_dummies(categorical_subset) # <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> the two dataframes <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> concat # Make sure <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> use axis = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">perform</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> bind features = pd.concat([numeric_subset, categorical_subset], axis = <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Jetzt haben wir mehr als 11.000 Beobachtungen (Geb√§ude) mit 110 Spalten (Tags).  Nicht alle Zeichen sind n√ºtzlich, um den Energy Star Score vorherzusagen. Daher werden wir die Auswahl der Zeichen √ºbernehmen und einige der Variablen entfernen. <br><br><h4>  Funktionsauswahl </h4><br>  Viele der 110 verf√ºgbaren Zeichen sind redundant, da sie stark miteinander korrelieren.  Hier ist beispielsweise ein Diagramm des EUI und des wetternormalisierten Standorts EUI mit einem Korrelationskoeffizienten von 0,997. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ab/c4f/ad8/4abc4fad887ef202d8d40961a8b02c34.png"><br><br>  Zeichen, die stark miteinander korrelieren, werden als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kollinear bezeichnet</a> .  Das Entfernen einer Variablen in solchen Attributpaaren hilft dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modell</a> h√§ufig, sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu verallgemeinern und besser interpretierbar zu sein</a> .  Bitte beachten Sie, dass es sich um die Korrelation einiger Zeichen mit anderen handelt und nicht um die Korrelation mit dem Ziel, was unserem Modell nur helfen w√ºrde! <br><br>  Es gibt eine Reihe von Methoden zur Berechnung der Kollinearit√§t von Merkmalen, und eine der beliebtesten ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Varianzinflationsfaktor</a> .  Wir werden den Korrelationskoeffizienten verwenden, um kollineare Merkmale zu suchen und zu entfernen.  Wir verwerfen ein Zeichenpaar, wenn der Korrelationskoeffizient zwischen ihnen mehr als 0,6 betr√§gt.  Der Code befindet sich im Editor (und als Reaktion auf den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stapel√ºberlauf</a> ). <br><br>  Dieser Wert sieht willk√ºrlich aus, aber tats√§chlich habe ich verschiedene Schwellenwerte ausprobiert, und oben konnte ich das beste Modell erstellen.  Maschinelles Lernen ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">empirisch</a> und muss oft experimentieren, um die beste L√∂sung zu finden.  Nach der Auswahl haben wir 64 Attribute und ein Ziel. <br><br><pre> <code class="hljs pgsql"># Remove <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> na <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> features = features.dropna(axis=<span class="hljs-number"><span class="hljs-number">1</span></span>, how = <span class="hljs-string"><span class="hljs-string">'all'</span></span>) print(features.shape) (<span class="hljs-number"><span class="hljs-number">11319</span></span>, <span class="hljs-number"><span class="hljs-number">65</span></span>)</code> </pre> <br><h2>  W√§hlen Sie eine Basisebene </h2><br>  Wir haben die Daten gel√∂scht, eine explorative Analyse durchgef√ºhrt und die Schilder konstruiert.  Bevor Sie mit der Erstellung des Modells fortfahren, m√ºssen Sie die anf√§ngliche Basisstufe (naive Basislinie) ausw√§hlen - eine Art Annahme, mit der wir die Ergebnisse der Modelle vergleichen.  Wenn sie unter das Grundniveau fallen, gehen wir davon aus, dass maschinelles Lernen f√ºr diese Aufgabe nicht anwendbar ist oder dass ein anderer Ansatz versucht werden sollte. <br><br>  F√ºr Regressionsaufgaben ist es als Basisstufe sinnvoll, den Medianwert des Ziels im Trainingssatz f√ºr alle Beispiele im Testsatz zu erraten.  Diese Kits stellen eine Barriere dar, die f√ºr jedes Modell relativ niedrig ist. <br><br>  Als Metrik nehmen wir den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">durchschnittlichen absoluten Fehler (mae)</a> in den Prognosen.  Es gibt viele andere Metriken f√ºr Regressionen, aber ich mag den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rat</a> , eine Metrik auszuw√§hlen und sie zur Bewertung von Modellen zu verwenden.  Und der durchschnittliche absolute Fehler ist leicht zu berechnen und zu interpretieren. <br><br>  Bevor Sie das Basisniveau berechnen, m√ºssen Sie die Daten in Trainings- und Tests√§tze aufteilen: <br><br><ol><li>  Ein Trainingssatz von Attributen ist das, was wir unserem Modell zusammen mit den Antworten w√§hrend des Trainings zur Verf√ºgung stellen.  Das Modell muss lernen, die Eigenschaften des Ziels zu erf√ºllen. </li><li>  Ein Testfeature-Set wird verwendet, um das trainierte Modell zu bewerten.  Wenn sie die Testsuite verarbeitet, sieht sie nicht die richtigen Antworten und muss diese nur anhand der verf√ºgbaren Funktionen vorhersagen.  Wir kennen die Antworten f√ºr die Testdaten und k√∂nnen die Prognoseergebnisse mit ihnen vergleichen. </li></ol><br>  F√ºr Schulungen verwenden wir 70% der Daten und f√ºr Tests - 30%: <br><br><pre> <code class="hljs pgsql"># Split <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span>% training <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span>% testing <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> X, X_test, y, y_test = train_test_split(features, targets, test_size = <span class="hljs-number"><span class="hljs-number">0.3</span></span>, random_state = <span class="hljs-number"><span class="hljs-number">42</span></span>)</code> </pre> <br>  Nun berechnen wir den Indikator f√ºr das anf√§ngliche Basisniveau: <br><br><pre> <code class="hljs vhdl"># <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> calculate mean absolute <span class="hljs-literal"><span class="hljs-literal">error</span></span> def mae(y_true, y_pred): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.mean(<span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>(y_true - y_pred)) baseline_guess = np.median(y) print(<span class="hljs-symbol"><span class="hljs-symbol">'The</span></span> baseline guess <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a score <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> %<span class="hljs-number"><span class="hljs-number">0.2</span></span>f' % baseline_guess) print(<span class="hljs-string"><span class="hljs-string">"Baseline Performance on the test set: MAE = %0.4f"</span></span> % mae(y_test, baseline_guess))</code> </pre> <br>  <b>Die Grundsch√§tzung ist eine Punktzahl von 66,00</b> <b><br></b>  <b>Basisleistung auf dem Testsatz: MAE = 24.5164</b> <br><br>  Der durchschnittliche absolute Fehler am Testsatz betrug etwa 25 Punkte.  Da wir im Bereich von 1 bis 100 auswerten, betr√§gt der Fehler 25% - eine eher niedrige Barriere f√ºr das Modell! <br><br><h2>  Fazit </h2><br>  In diesem Artikel haben wir die ersten drei Phasen der Probleml√∂sung mithilfe von maschinellem Lernen durchlaufen.  Nach dem Einstellen der Aufgabe haben wir: <br><br><ol><li>  Gel√∂schte und formatierte Rohdaten. </li><li>  Durchf√ºhrung einer explorativen Analyse zur Untersuchung der verf√ºgbaren Daten. </li><li>  Wir haben eine Reihe von Funktionen entwickelt, die wir f√ºr unsere Modelle verwenden werden. </li></ol><br> ,    ,       . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scikit-Learn</a>    ,        . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425253/">https://habr.com/ru/post/de425253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425243/index.html">Das John Willis Handbuch</a></li>
<li><a href="../de425245/index.html">Ank√ºndigung von RamblerFront & # 6</a></li>
<li><a href="../de425247/index.html">Crowdsourcing beim Testen</a></li>
<li><a href="../de425249/index.html">Wie ist die Bekanntschaft mit LLP an der ITMO University: der Kurs "Low-Level Programming"</a></li>
<li><a href="../de425251/index.html">LoJax: Das erste bekannte UEFI-Rootkit, das in einer b√∂swilligen Kampagne verwendet wird</a></li>
<li><a href="../de425255/index.html">Broo verlustfreier Komprimierungsalgorithmus und Delta-Codierung, Vergleich mit Xdelta3. Home Projektentwicklung</a></li>
<li><a href="../de425259/index.html">Sichern Sie Ihre Site mit git und Makefile</a></li>
<li><a href="../de425261/index.html">EV-Zertifikate sind tot</a></li>
<li><a href="../de425263/index.html">Das Festival iFEST findet in Nischni Nowgorod statt</a></li>
<li><a href="../de425265/index.html">Entwicklungsregeln bei Yandex.Health</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>