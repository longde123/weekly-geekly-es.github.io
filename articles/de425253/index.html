<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📭 🤾🏾 💸 Wir machen ein maschinelles Lernprojekt in Python. Teil 1 👈🏼 🐺 🐤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Übersetzung eines vollständigen maschinellen Lernprojekts in Python: Teil 1 . 

 Wenn Sie ein Buch lesen oder eine Schulung zur Datenanalyse anhören, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir machen ein maschinelles Lernprojekt in Python. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/425253/"><img src="https://habrastorage.org/getpro/habr/post_images/5de/fed/62e/5defed62ea348f6e02365e283415b2fb.png"><br><br>  <i>Übersetzung eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vollständigen maschinellen Lernprojekts in Python: Teil 1</a> .</i> <br><br>  Wenn Sie ein Buch lesen oder eine Schulung zur Datenanalyse anhören, haben Sie häufig das Gefühl, dass Sie mit einigen separaten Teilen eines Bildes konfrontiert sind, die nicht zusammengesetzt werden können.  Sie haben vielleicht Angst vor der Aussicht, den nächsten Schritt zu tun und ein Problem mithilfe des maschinellen Lernens vollständig zu lösen, aber mithilfe dieser Artikelserie gewinnen Sie Vertrauen in die Fähigkeit, jedes Problem auf dem Gebiet der Datenwissenschaft zu lösen. <br><br>  Damit Sie endlich ein vollständiges Bild im Kopf haben, schlagen wir vor, das Projekt der Verwendung von maschinellem Lernen unter Verwendung realer Daten von Anfang bis Ende zu analysieren. <br><a name="habracut"></a><br>  Gehen Sie nacheinander die folgenden Schritte durch: <br><br><ol><li>  Daten bereinigen und formatieren. </li><li>  Explorative Datenanalyse. </li><li>  Design und Auswahl der Funktionen. </li><li>  Vergleich der Metriken mehrerer Modelle für maschinelles Lernen. </li><li>  Hyperparametrische Abstimmung des besten Modells. </li><li>  Bewertung des besten Modells anhand eines Testdatensatzes. </li><li>  Interpretation der Ergebnisse des Modells. </li><li>  Schlussfolgerungen und Arbeit mit Dokumenten. </li></ol><br>  Sie erfahren, wie die Schritte ineinander übergehen und wie Sie sie in Python implementieren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das ganze Projekt</a> ist auf GitHub verfügbar, der erste Teil liegt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier.</a>  In diesem Artikel werden wir die ersten drei Stufen betrachten. <br><br><h2>  Aufgabenbeschreibung </h2><br>  Bevor Sie Code schreiben, müssen Sie das zu lösende Problem und die verfügbaren Daten verstehen.  In diesem Projekt werden wir mit öffentlich verfügbaren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Energieeffizienzdaten für Gebäude</a> in New York arbeiten. <br><br>  Unser Ziel: Aus den verfügbaren Daten ein Modell zu erstellen, das die Anzahl der Energy Star-Punkte für ein bestimmtes Gebäude vorhersagt, und die Ergebnisse zu interpretieren, um Faktoren zu finden, die den endgültigen Wert beeinflussen. <br><br>  Die Daten enthalten bereits den zugewiesenen Energy Star Score. Unsere Aufgabe ist also maschinelles Lernen mit kontrollierter Regression: <br><br><ul><li>  Betreut: Wir kennen die Zeichen und den Zweck und haben die Aufgabe, ein Modell zu trainieren, das das erste mit dem zweiten vergleichen kann. </li><li>  Regression: Der Energy Star Score ist eine kontinuierliche Variable. </li></ul><br>  Unser Modell muss genau sein - damit es den Wert des Energy Star Score nahezu wahr und interpretierbar vorhersagen kann, damit wir seine Vorhersagen verstehen können.  Wenn wir die Zieldaten kennen, können wir sie verwenden, um Entscheidungen zu treffen, wenn wir tiefer in die Daten eintauchen und das Modell erstellen. <br><br><h2>  Datenbereinigung </h2><br>  Nicht jeder Datensatz ist ein perfekt aufeinander abgestimmter Beobachtungssatz ohne Anomalien und fehlende Werte (ein Hinweis auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MTCAR-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iris-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datensätze</a> ).  In realen Daten gibt es wenig Ordnung. Bevor Sie mit der Analyse beginnen, müssen Sie sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">löschen und</a> in ein akzeptables Format bringen.  Die Datenbereinigung ist ein unangenehmes, aber obligatorisches Verfahren zur Lösung der meisten Datenanalyseaufgaben. <br><br>  Zunächst können Sie die Daten in Form eines Pandas-Datenrahmens laden und untersuchen: <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np # <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> a dataframe data = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'data/Energy_and_Water_Data_Disclosure_for_Local_Law_84_2017__Data_for_Calendar_Year_2016_.csv'</span></span>) # Display top <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> dataframe data.head()</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/4ac/637/b86/4ac637b8682b2fcacddd155004681a0d.png"><br>  <i>So sehen echte Daten aus.</i> <br><br>  Dies ist ein Fragment einer Tabelle mit 60 Spalten.  Auch hier sind einige Probleme sichtbar: Wir müssen den <code>Energy Star Score</code> vorhersagen, wissen aber nicht, was all diese Spalten bedeuten.  Dies ist zwar nicht unbedingt ein Problem, da Sie häufig ein genaues Modell erstellen können, ohne etwas über Variablen zu wissen.  Die Interpretierbarkeit ist uns jedoch wichtig, daher müssen wir die Bedeutung von mindestens einigen Spalten herausfinden. <br><br>  Als wir diese Daten erhielten, fragten wir nicht nach den Werten, sondern sahen uns den Dateinamen an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a86/c00/ab2/a86c00ab2d64629e644e7186c78724f7.png"><br><br>  und beschlossen, nach "Local Law 84" zu suchen.  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Seite gefunden</a> , auf der steht, dass es sich um das in New York geltende Gesetz handelt, wonach die Eigentümer aller Gebäude einer bestimmten Größe über den Energieverbrauch berichten sollten.  Eine weitere Suche half dabei, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">alle Spaltenwerte zu finden</a> .  Vernachlässigen Sie also nicht die Dateinamen, sie können ein guter Ausgangspunkt sein.  Darüber hinaus ist dies eine Erinnerung daran, dass Sie nicht eilen und etwas Wichtiges nicht verpassen! <br><br>  Wir werden nicht alle Spalten studieren, aber wir werden uns definitiv mit dem Energy Star Score befassen, der wie folgt beschrieben wird: <br><br><blockquote>  Das Perzentil-Ranking liegt zwischen 1 und 100 und wird auf der Grundlage von Jahresberichten über den Energieverbrauch der Bauherren selbst berechnet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Energy Star Score</a> ist ein relatives Maß für den Vergleich der Energieeffizienz von Gebäuden. </blockquote><br>  Das erste Problem wurde gelöst, das zweite blieb jedoch bestehen - fehlende Werte, markiert als "Nicht verfügbar".  Dies ist ein Zeichenfolgenwert in Python. Dies bedeutet, dass auch Zeichenfolgen mit Zahlen als <code>object</code> gespeichert werden. Wenn die Spalte eine Zeichenfolge enthält, konvertiert Pandas diese in eine Spalte, die vollständig aus einer Zeichenfolge besteht.  Die <code>dataframe.info()</code> können mit der Methode <code>dataframe.info()</code> ermittelt werden: <br><br><pre> <code class="hljs pgsql"># See the <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> non-missing <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> data.<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>()</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/db3/b4d/013/db3b4d013ca25d7e5ac483f0c24fa1e4.png"><br><br>  Sicherlich werden einige Spalten, die explizit Zahlen enthalten (wie z. B. ft²), als Objekte gespeichert.  Wir können keine numerische Analyse auf Zeichenfolgenwerte anwenden, daher konvertieren wir sie in numerische Datentypen (insbesondere <code>float</code> )! <br><br>  Dieser Code ersetzt zunächst alle "Nicht verfügbar" durch <i>keine Zahl</i> ( <code>np.nan</code> ), die als Zahlen interpretiert werden kann, und konvertiert dann den Inhalt bestimmter Spalten in einen <code>float</code> Typ: <br><br><pre> <code class="hljs pgsql"># Replace <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> occurrences <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Not</span></span> Available <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> a number data = data.replace({<span class="hljs-string"><span class="hljs-string">'Not Available'</span></span>: np.<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>}) # Iterate through the <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list(data.<span class="hljs-keyword"><span class="hljs-keyword">columns</span></span>): # <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> that should be <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">'ft²'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'kBtu'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'Metric Tons CO2e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'kWh'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'therms'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'gal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'Score'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col): # Convert the data <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> data[col] = data[col].astype(<span class="hljs-type"><span class="hljs-type">float</span></span>)</code> </pre> <br>  Wenn die Werte in den entsprechenden Spalten bei uns zu Zahlen werden, können wir beginnen, die Daten zu untersuchen. <br><br><h4>  Fehlende und abnormale Daten </h4><br>  Neben falschen Datentypen ist das Fehlen von Werten eines der häufigsten Probleme.  Sie können aus verschiedenen Gründen fehlen, und vor dem Training des Modells müssen diese Werte entweder ausgefüllt oder gelöscht werden.  Lassen Sie uns zunächst herausfinden, wie viele Werte wir in jeder Spalte haben ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code ist hier</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b0/5da/a40/0b05daa40ba77acca25ed859856759f2.png"><br>  <i>Zum Erstellen einer Tabelle wurde eine Funktion aus einem Zweig in <u>StackOverflow verwendet</u> .</i> <br><br>  Informationen sollten immer mit Vorsicht entfernt werden. Wenn die Spalte viele Werte enthält, wird dies unserem Modell wahrscheinlich nicht zugute kommen.  Der Schwellenwert, nach dem es besser ist, die Spalten wegzuwerfen, hängt von Ihrer Aufgabe ab ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier eine Diskussion</a> ). In unserem Projekt werden Spalten gelöscht, die mehr als halb leer sind. <br><br>  Auch in diesem Stadium ist es besser, die abnormalen Werte zu entfernen.  Sie können aufgrund von Tippfehlern bei der Dateneingabe oder aufgrund von Fehlern in den Maßeinheiten auftreten oder sie können korrekte, aber extreme Werte sein.  In diesem Fall werden wir die "zusätzlichen" Werte entfernen, die sich an der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Definition extremer Anomalien orientieren</a> : <br><br><ul><li>  Unterhalb des ersten Quartils befindet sich ein 3 ∗ Interquartilbereich. </li><li>  Oberhalb des dritten Quartils + 3 ∗ Interquartilbereich. </li></ul><br>  Der Code, der Spalten und Anomalien entfernt, wird im Editor auf Github aufgelistet.  Nach Abschluss des Datenbereinigungsprozesses und der Beseitigung von Anomalien verfügen wir über mehr als 11.000 Gebäude und 49 Schilder. <br><br><h2>  Explorative Datenanalyse </h2><br>  Die langweilige, aber notwendige Phase der Datenbereinigung ist abgeschlossen, Sie können zur Studie gehen!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die explorative Datenanalyse</a> (RAD) ist ein unbegrenzter Zeitprozess, in dem wir Statistiken berechnen und nach Trends, Anomalien, Mustern oder Beziehungen in den Daten suchen. <br><br>  Kurz gesagt, RAD ist ein Versuch herauszufinden, welche Daten uns sagen können.  Normalerweise beginnt die Analyse mit einer oberflächlichen Überprüfung, dann finden wir interessante Fragmente und analysieren sie genauer.  Die Ergebnisse können für sich genommen interessant sein oder zur Auswahl des Modells beitragen und bei der Entscheidung helfen, welche Funktionen wir verwenden werden. <br><br><h4>  Diagramme mit einer Variablen </h4><br>  Unser Ziel ist es, den Wert des Energy Star-Scores (in unseren Daten in unseren Score umbenannt) vorherzusagen. Daher ist es sinnvoll, zunächst die Verteilung dieser Variablen zu untersuchen.  Ein Histogramm ist eine einfache, aber effektive Methode zur Visualisierung der Verteilung einer einzelnen Variablen und kann mithilfe von <code>matplotlib</code> einfach <code>matplotlib</code> . <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt # Histogram <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the Energy Star Score plt.style.use(<span class="hljs-string"><span class="hljs-string">'fivethirtyeight'</span></span>) plt.hist(data[<span class="hljs-string"><span class="hljs-string">'score'</span></span>].dropna(), bins = <span class="hljs-number"><span class="hljs-number">100</span></span>, edgecolor = <span class="hljs-string"><span class="hljs-string">'k'</span></span>); plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Score'</span></span>); plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Number of Buildings'</span></span>); plt.title(<span class="hljs-string"><span class="hljs-string">'Energy Star Score Distribution'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/f82/bf3/84a/f82bf384af1bd0c407f1e680d0b47263.png"><br><br>  Sieht verdächtig aus!  Der Energy Star Score ist ein Perzentil, daher sollten Sie eine gleichmäßige Verteilung erwarten, wenn jeder Punkt der gleichen Anzahl von Gebäuden zugewiesen wird.  Eine unverhältnismäßig große Anzahl von Gebäuden erzielte jedoch die höchsten und niedrigsten Ergebnisse (für den Energy Star Score gilt: Je größer, desto besser). <br><br>  Wenn wir uns die Definition dieser Punktzahl noch einmal ansehen, werden wir sehen, dass sie auf der Grundlage von „Berichten, die von den Bauherren unabhängig ausgefüllt wurden“ berechnet wird, was den Überschuss an sehr großen Werten erklären kann.  Das Auffordern von Bauherren, ihren Energieverbrauch zu melden, ist wie das Auffordern von Schülern, ihre Noten in Prüfungen anzugeben.  Dies ist vielleicht nicht das objektivste Kriterium für die Beurteilung der Energieeffizienz von Immobilien. <br><br>  Wenn wir unbegrenzt Zeit hätten, könnten wir herausfinden, warum so viele Gebäude sehr hohe und sehr niedrige Punkte haben.  Dazu müssten wir die geeigneten Gebäude auswählen und sorgfältig analysieren.  Wir müssen jedoch nur lernen, wie man Punktzahlen vorhersagt, und keine genauere Bewertungsmethode entwickeln.  Sie können sich selbst markieren, dass die Punkte eine verdächtige Verteilung haben, aber wir werden uns auf die Prognose konzentrieren. <br><br><h4>  Beziehungssuche </h4><br>  Der Hauptteil der AHFR ist die Suche nach der Beziehung zwischen Zeichen und unserem Ziel.  Mit ihm korrelierende Variablen sind für die Verwendung im Modell nützlich, da sie für Prognosen verwendet werden können.  Eine Möglichkeit, die Auswirkung einer kategorialen Variablen (die nur einen begrenzten Satz von Werten annimmt) auf das Ziel zu untersuchen, besteht darin, die Dichte mithilfe der Seaborn-Bibliothek zu zeichnen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Dichtediagramm kann als geglättetes Histogramm betrachtet werden,</a> da es die Verteilung einer einzelnen Variablen zeigt.  Sie können einzelne Klassen im Diagramm einfärben, um zu sehen, wie eine kategoriale Variable die Verteilung ändert.  Dieser Code zeigt das Energy Star Score-Dichtediagramm, das nach Gebäudetyp gefärbt ist (für eine Liste von Gebäuden mit mehr als 100 Dimensionen): <br><br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> a list <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> buildings <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> more than <span class="hljs-number"><span class="hljs-number">100</span></span> measurements <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = data.dropna(subset=[<span class="hljs-string"><span class="hljs-string">'score'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>[<span class="hljs-string"><span class="hljs-string">'Largest Property Use Type'</span></span>].value_counts() <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = list(<span class="hljs-keyword"><span class="hljs-keyword">types</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">types</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">values</span></span> &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) # Plot <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> distribution <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> scores <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> building categories figsize(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) # Plot <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> building <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> b_type <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>: # <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> the building <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> subset = data[data[<span class="hljs-string"><span class="hljs-string">'Largest Property Use Type'</span></span>] == b_type] # Density plot <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Energy Star Scores sns.kdeplot(subset[<span class="hljs-string"><span class="hljs-string">'score'</span></span>].dropna(), label = b_type, shade = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, alpha = <span class="hljs-number"><span class="hljs-number">0.8</span></span>); # label the plot plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Energy Star Score'</span></span>, size = <span class="hljs-number"><span class="hljs-number">20</span></span>); plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Density'</span></span>, size = <span class="hljs-number"><span class="hljs-number">20</span></span>); plt.title(<span class="hljs-string"><span class="hljs-string">'Density Plot of Energy Star Scores by Building Type'</span></span>, size = <span class="hljs-number"><span class="hljs-number">28</span></span>);</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/23a/718/fd3/23a718fd3139123b609e2521ffe46e3c.png"><br><br>  Wie Sie sehen können, wirkt sich die Art des Gebäudes stark auf die Anzahl der Punkte aus.  Bürogebäude haben normalerweise eine höhere Punktzahl und Hotels eine niedrigere.  Sie müssen also den Gebäudetyp in das Modell aufnehmen, da dieses Zeichen unser Ziel beeinflusst.  Als kategoriale Variable müssen wir eine One-Hot-Codierung des Gebäudetyps durchführen. <br><br>  Ein ähnliches Diagramm kann verwendet werden, um den Energy Star Score nach Stadtbezirken zu schätzen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/224/c69/820/224c69820a5c0362f804e37ae7d5de55.png"><br><br>  Der Bereich beeinflusst die Punktzahl nicht so sehr wie die Art des Gebäudes.  Trotzdem werden wir es in das Modell aufnehmen, da es einen kleinen Unterschied zwischen den Regionen gibt. <br><br>  Um die Beziehung zwischen den Variablen zu berechnen, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Pearson-Korrelationskoeffizienten verwenden</a> .  Dies ist ein Maß für die Intensität und Richtung einer linearen Beziehung zwischen zwei Variablen.  Ein Wert von +1 bedeutet eine perfekt lineare positive Beziehung und -1 bedeutet eine perfekt lineare negative Beziehung.  Hier einige Beispiele für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pearson-Korrelationskoeffizientenwerte</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b3/455/654/0b34556548ab206112024fb0e8f69c01.png"><br><br>  Obwohl dieser Koeffizient nichtlineare Abhängigkeiten nicht widerspiegeln kann, ist es möglich, damit zu beginnen, um die Beziehungen von Variablen zu bewerten.  In Pandas können Sie auf einfache Weise Korrelationen zwischen beliebigen Spalten in einem Datenrahmen berechnen: <br><br><pre> <code class="hljs pgsql"># Find <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> correlations <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the score <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> sort correlations_data = data.corr()[<span class="hljs-string"><span class="hljs-string">'score'</span></span>].sort_values()</code> </pre> <br>  Die negativsten Korrelationen mit dem Ziel: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b62/181/178/b62181178669962fccf7caa472d9e2e8.png"><br><br>  und das positivste: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/598/47f/14a/59847f14a4d8afe1ce8ff237c5d3fa36.png"><br><br>  Es gibt mehrere starke negative Korrelationen zwischen den Attributen und dem Ziel, von denen die größten verschiedenen EUI-Kategorien angehören (die Methoden zur Berechnung dieser Indikatoren unterscheiden sich geringfügig).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EUI (Energy Use Intensity</a> ) ist die Menge an Energie, die von einem Gebäude verbraucht wird, geteilt durch einen Quadratfuß Fläche.  Dieser spezifische Wert wird zur Bewertung der Energieeffizienz verwendet. Je kleiner er ist, desto besser.  Die Logik legt nahe, dass diese Korrelationen gerechtfertigt sind: Wenn der EUI steigt, sollte der Energy Star Score sinken. <br><br><h4>  Diagramme mit zwei Variablen </h4><br>  Wir verwenden Streudiagramme, um die Beziehungen zwischen zwei kontinuierlichen Variablen zu visualisieren.  Sie können den Farben der Punkte zusätzliche Informationen hinzufügen, z. B. eine kategoriale Variable.  Die Beziehung zwischen dem Energy Star Score und dem EUI ist unten dargestellt. Die Farben zeigen verschiedene Gebäudetypen an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/974/204/7de/9742047ded29c74a9a8e6df9bf6396d1.png"><br><br>  In diesem Diagramm können Sie einen Korrelationskoeffizienten von -0,7 visualisieren.  Wenn der EUI abnimmt, steigt der Energy Star Score. Diese Beziehung wird bei verschiedenen Gebäudetypen beobachtet. <br><br>  Unsere neueste Forschungskarte heißt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pairs Plot</a> .  Dies ist ein großartiges Werkzeug, um die Beziehungen zwischen verschiedenen Variablenpaaren und die Verteilung einzelner Variablen zu sehen.  Wir werden die Seaborn-Bibliothek und die PairGrid-Funktion verwenden, um ein Paardiagramm mit einem Streudiagramm im oberen Dreieck, einem diagonalen Histogramm, einem zweidimensionalen Kerndichtediagramm und Korrelationskoeffizienten im unteren Dreieck zu erstellen. <br><br><pre> <code class="hljs pgsql"># Extract the <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> plot plot_data = features[[<span class="hljs-string"><span class="hljs-string">'score'</span></span>, <span class="hljs-string"><span class="hljs-string">'Site EUI (kBtu/ft²)'</span></span>, <span class="hljs-string"><span class="hljs-string">'Weather Normalized Source EUI (kBtu/ft²)'</span></span>, <span class="hljs-string"><span class="hljs-string">'log_Total GHG Emissions (Metric Tons CO2e)'</span></span>]] # Replace the inf <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nan</span></span> plot_data = plot_data.replace({np.inf: np.<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>, -np.inf: np.<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>}) # <span class="hljs-keyword"><span class="hljs-keyword">Rename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> plot_data = plot_data.<span class="hljs-keyword"><span class="hljs-keyword">rename</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> = {<span class="hljs-string"><span class="hljs-string">'Site EUI (kBtu/ft²)'</span></span>: <span class="hljs-string"><span class="hljs-string">'Site EUI'</span></span>, <span class="hljs-string"><span class="hljs-string">'Weather Normalized Source EUI (kBtu/ft²)'</span></span>: <span class="hljs-string"><span class="hljs-string">'Weather Norm EUI'</span></span>, <span class="hljs-string"><span class="hljs-string">'log_Total GHG Emissions (Metric Tons CO2e)'</span></span>: <span class="hljs-string"><span class="hljs-string">'log GHG Emissions'</span></span>}) # <span class="hljs-keyword"><span class="hljs-keyword">Drop</span></span> na <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> plot_data = plot_data.dropna() # <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> calculate correlation coefficient <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> two <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> def corr_func(x, y, **kwargs): r = np.corrcoef(x, y)[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] ax = plt.gca() ax.annotate("r = {:.2f}".format(r), xy=(<span class="hljs-number"><span class="hljs-number">.2</span></span>, <span class="hljs-number"><span class="hljs-number">.8</span></span>), xycoords=ax.transAxes, size = <span class="hljs-number"><span class="hljs-number">20</span></span>) # <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> the pairgrid <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> grid = sns.PairGrid(data = plot_data, size = <span class="hljs-number"><span class="hljs-number">3</span></span>) # Upper <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a scatter plot grid.map_upper(plt.scatter, color = <span class="hljs-string"><span class="hljs-string">'red'</span></span>, alpha = <span class="hljs-number"><span class="hljs-number">0.6</span></span>) # Diagonal <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a histogram grid.map_diag(plt.hist, color = <span class="hljs-string"><span class="hljs-string">'red'</span></span>, edgecolor = <span class="hljs-string"><span class="hljs-string">'black'</span></span>) # Bottom <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> correlation <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> density plot grid.map_lower(corr_func); grid.map_lower(sns.kdeplot, cmap = plt.cm.Reds) # Title <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> entire plot plt.suptitle(<span class="hljs-string"><span class="hljs-string">'Pairs Plot of Energy Data'</span></span>, size = <span class="hljs-number"><span class="hljs-number">36</span></span>, y = <span class="hljs-number"><span class="hljs-number">1.02</span></span>);</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/5fa/4cc/94f/5fa4cc94f9b91df5ad4fda37aa3ae1f0.png"><br><br>  Suchen Sie nach dem Schnittpunkt von Zeilen und Spalten, um die Beziehung zwischen Variablen anzuzeigen.  Angenommen, Sie möchten die Korrelation zwischen <code>Weather Norm EUI</code> und <code>score</code> , dann suchen wir nach der <code>Weather Norm EUI</code> Reihe und der <code>score</code> Spalte, an deren Schnittpunkt ein Korrelationskoeffizient von -0,67 liegt.  Diese Grafiken sehen nicht nur cool aus, sondern helfen auch bei der Auswahl von Variablen für das Modell. <br><br><h2>  Design und Auswahl der Funktionen </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Entwerfen und Auswählen von Funktionen</a> bringt häufig die größte Rendite in Bezug auf die Zeit, die für maschinelles Lernen aufgewendet wird.  Zuerst geben wir die Definitionen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merkmalskonstruktion: Der</a> Prozess des Extrahierens oder Erstellens neuer Merkmale aus Rohdaten.  Um Variablen im Modell zu verwenden, müssen Sie sie möglicherweise transformieren, z. B. den natürlichen Logarithmus verwenden oder die Quadratwurzel extrahieren oder eine einmalige Codierung kategorialer Variablen anwenden.  Beim charakteristischen Design können zusätzliche Features aus Rohdaten erstellt werden. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merkmalsauswahl: Der</a> Prozess der Auswahl der relevantesten Merkmale aus Daten, bei dem einige Merkmale entfernt werden, damit das Modell neue Daten besser verallgemeinern kann, um ein besser interpretierbares Modell zu erhalten.  Die Wahl der Zeichen kann als Entfernung von „überflüssig“ betrachtet werden, so dass nur das Wichtigste übrig bleibt. </li></ul><br>  Das Modell des maschinellen Lernens kann nur aus den von uns bereitgestellten Daten lernen. Daher ist es äußerst wichtig sicherzustellen, dass wir alle für unsere Aufgabe relevanten Informationen enthalten.  Wenn Sie dem Modell nicht die richtigen Daten zur Verfügung stellen, kann es nicht lernen und liefert keine genauen Vorhersagen! <br><br>  Wir werden Folgendes tun: <br><br><ul><li>  Anwendbar auf kategoriale Variablen (Quartal und Art des Eigentums) One-Hot-Codierung. </li><li>  Addieren Sie den natürlichen Logarithmus aller numerischen Variablen. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">One-Hot-Codierung ist</a> erforderlich, um kategoriale Variablen in das Modell aufzunehmen.  Der Algorithmus für maschinelles Lernen kann die Art des "Büros" nicht verstehen. Wenn es sich bei dem Gebäude also um ein Büro handelt, weisen wir ihm das Zeichen 1 zu, und wenn kein Büro, dann 0. <br><br>  Durch Hinzufügen transformierter Features kann das Modell nichtlineare Beziehungen innerhalb der Daten kennenlernen.  Bei der Analyse von Daten ist es üblich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, Quadratwurzeln zu extrahieren, natürliche Logarithmen zu verwenden oder die Zeichen irgendwie zu transformieren.</a> Dies hängt von der spezifischen Aufgabe oder Ihrem Wissen über die besten Techniken ab.  In diesem Fall addieren wir den natürlichen Logarithmus aller numerischen Zeichen. <br><br>  Dieser Code wählt numerische Zeichen aus, berechnet ihre Logarithmen, wählt zwei kategoriale Zeichen aus, wendet eine Hot-Codierung auf sie an und kombiniert beide Sätze zu einem.  Nach der Beschreibung zu urteilen, bleibt noch viel zu tun, aber in Pandas ist alles ziemlich einfach! <br><br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">Copy</span></span> the original data features = data.<span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>() # <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> the <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> numeric_subset = data.select_dtypes(<span class="hljs-string"><span class="hljs-string">'number'</span></span>) # <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">log</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numeric_subset.<span class="hljs-keyword"><span class="hljs-keyword">columns</span></span>: # Skip the Energy Star Score <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> col == <span class="hljs-string"><span class="hljs-string">'score'</span></span>: next <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: numeric_subset[<span class="hljs-string"><span class="hljs-string">'log_'</span></span> + col] = np.log(numeric_subset[col]) # <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> the categorical <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> categorical_subset = data[[<span class="hljs-string"><span class="hljs-string">'Borough'</span></span>, <span class="hljs-string"><span class="hljs-string">'Largest Property Use Type'</span></span>]] # One hot encode categorical_subset = pd.get_dummies(categorical_subset) # <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> the two dataframes <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> concat # Make sure <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> use axis = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">perform</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> bind features = pd.concat([numeric_subset, categorical_subset], axis = <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Jetzt haben wir mehr als 11.000 Beobachtungen (Gebäude) mit 110 Spalten (Tags).  Nicht alle Zeichen sind nützlich, um den Energy Star Score vorherzusagen. Daher werden wir die Auswahl der Zeichen übernehmen und einige der Variablen entfernen. <br><br><h4>  Funktionsauswahl </h4><br>  Viele der 110 verfügbaren Zeichen sind redundant, da sie stark miteinander korrelieren.  Hier ist beispielsweise ein Diagramm des EUI und des wetternormalisierten Standorts EUI mit einem Korrelationskoeffizienten von 0,997. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ab/c4f/ad8/4abc4fad887ef202d8d40961a8b02c34.png"><br><br>  Zeichen, die stark miteinander korrelieren, werden als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kollinear bezeichnet</a> .  Das Entfernen einer Variablen in solchen Attributpaaren hilft dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modell</a> häufig, sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu verallgemeinern und besser interpretierbar zu sein</a> .  Bitte beachten Sie, dass es sich um die Korrelation einiger Zeichen mit anderen handelt und nicht um die Korrelation mit dem Ziel, was unserem Modell nur helfen würde! <br><br>  Es gibt eine Reihe von Methoden zur Berechnung der Kollinearität von Merkmalen, und eine der beliebtesten ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Varianzinflationsfaktor</a> .  Wir werden den Korrelationskoeffizienten verwenden, um kollineare Merkmale zu suchen und zu entfernen.  Wir verwerfen ein Zeichenpaar, wenn der Korrelationskoeffizient zwischen ihnen mehr als 0,6 beträgt.  Der Code befindet sich im Editor (und als Reaktion auf den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stapelüberlauf</a> ). <br><br>  Dieser Wert sieht willkürlich aus, aber tatsächlich habe ich verschiedene Schwellenwerte ausprobiert, und oben konnte ich das beste Modell erstellen.  Maschinelles Lernen ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">empirisch</a> und muss oft experimentieren, um die beste Lösung zu finden.  Nach der Auswahl haben wir 64 Attribute und ein Ziel. <br><br><pre> <code class="hljs pgsql"># Remove <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> na <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> features = features.dropna(axis=<span class="hljs-number"><span class="hljs-number">1</span></span>, how = <span class="hljs-string"><span class="hljs-string">'all'</span></span>) print(features.shape) (<span class="hljs-number"><span class="hljs-number">11319</span></span>, <span class="hljs-number"><span class="hljs-number">65</span></span>)</code> </pre> <br><h2>  Wählen Sie eine Basisebene </h2><br>  Wir haben die Daten gelöscht, eine explorative Analyse durchgeführt und die Schilder konstruiert.  Bevor Sie mit der Erstellung des Modells fortfahren, müssen Sie die anfängliche Basisstufe (naive Basislinie) auswählen - eine Art Annahme, mit der wir die Ergebnisse der Modelle vergleichen.  Wenn sie unter das Grundniveau fallen, gehen wir davon aus, dass maschinelles Lernen für diese Aufgabe nicht anwendbar ist oder dass ein anderer Ansatz versucht werden sollte. <br><br>  Für Regressionsaufgaben ist es als Basisstufe sinnvoll, den Medianwert des Ziels im Trainingssatz für alle Beispiele im Testsatz zu erraten.  Diese Kits stellen eine Barriere dar, die für jedes Modell relativ niedrig ist. <br><br>  Als Metrik nehmen wir den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">durchschnittlichen absoluten Fehler (mae)</a> in den Prognosen.  Es gibt viele andere Metriken für Regressionen, aber ich mag den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rat</a> , eine Metrik auszuwählen und sie zur Bewertung von Modellen zu verwenden.  Und der durchschnittliche absolute Fehler ist leicht zu berechnen und zu interpretieren. <br><br>  Bevor Sie das Basisniveau berechnen, müssen Sie die Daten in Trainings- und Testsätze aufteilen: <br><br><ol><li>  Ein Trainingssatz von Attributen ist das, was wir unserem Modell zusammen mit den Antworten während des Trainings zur Verfügung stellen.  Das Modell muss lernen, die Eigenschaften des Ziels zu erfüllen. </li><li>  Ein Testfeature-Set wird verwendet, um das trainierte Modell zu bewerten.  Wenn sie die Testsuite verarbeitet, sieht sie nicht die richtigen Antworten und muss diese nur anhand der verfügbaren Funktionen vorhersagen.  Wir kennen die Antworten für die Testdaten und können die Prognoseergebnisse mit ihnen vergleichen. </li></ol><br>  Für Schulungen verwenden wir 70% der Daten und für Tests - 30%: <br><br><pre> <code class="hljs pgsql"># Split <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span>% training <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span>% testing <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> X, X_test, y, y_test = train_test_split(features, targets, test_size = <span class="hljs-number"><span class="hljs-number">0.3</span></span>, random_state = <span class="hljs-number"><span class="hljs-number">42</span></span>)</code> </pre> <br>  Nun berechnen wir den Indikator für das anfängliche Basisniveau: <br><br><pre> <code class="hljs vhdl"># <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> calculate mean absolute <span class="hljs-literal"><span class="hljs-literal">error</span></span> def mae(y_true, y_pred): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.mean(<span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>(y_true - y_pred)) baseline_guess = np.median(y) print(<span class="hljs-symbol"><span class="hljs-symbol">'The</span></span> baseline guess <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a score <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> %<span class="hljs-number"><span class="hljs-number">0.2</span></span>f' % baseline_guess) print(<span class="hljs-string"><span class="hljs-string">"Baseline Performance on the test set: MAE = %0.4f"</span></span> % mae(y_test, baseline_guess))</code> </pre> <br>  <b>Die Grundschätzung ist eine Punktzahl von 66,00</b> <b><br></b>  <b>Basisleistung auf dem Testsatz: MAE = 24.5164</b> <br><br>  Der durchschnittliche absolute Fehler am Testsatz betrug etwa 25 Punkte.  Da wir im Bereich von 1 bis 100 auswerten, beträgt der Fehler 25% - eine eher niedrige Barriere für das Modell! <br><br><h2>  Fazit </h2><br>  In diesem Artikel haben wir die ersten drei Phasen der Problemlösung mithilfe von maschinellem Lernen durchlaufen.  Nach dem Einstellen der Aufgabe haben wir: <br><br><ol><li>  Gelöschte und formatierte Rohdaten. </li><li>  Durchführung einer explorativen Analyse zur Untersuchung der verfügbaren Daten. </li><li>  Wir haben eine Reihe von Funktionen entwickelt, die wir für unsere Modelle verwenden werden. </li></ol><br> ,    ,       . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scikit-Learn</a>    ,        . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425253/">https://habr.com/ru/post/de425253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425243/index.html">Das John Willis Handbuch</a></li>
<li><a href="../de425245/index.html">Ankündigung von RamblerFront & # 6</a></li>
<li><a href="../de425247/index.html">Crowdsourcing beim Testen</a></li>
<li><a href="../de425249/index.html">Wie ist die Bekanntschaft mit LLP an der ITMO University: der Kurs "Low-Level Programming"</a></li>
<li><a href="../de425251/index.html">LoJax: Das erste bekannte UEFI-Rootkit, das in einer böswilligen Kampagne verwendet wird</a></li>
<li><a href="../de425255/index.html">Broo verlustfreier Komprimierungsalgorithmus und Delta-Codierung, Vergleich mit Xdelta3. Home Projektentwicklung</a></li>
<li><a href="../de425259/index.html">Sichern Sie Ihre Site mit git und Makefile</a></li>
<li><a href="../de425261/index.html">EV-Zertifikate sind tot</a></li>
<li><a href="../de425263/index.html">Das Festival iFEST findet in Nischni Nowgorod statt</a></li>
<li><a href="../de425265/index.html">Entwicklungsregeln bei Yandex.Health</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>