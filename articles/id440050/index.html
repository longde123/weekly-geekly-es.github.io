<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗝️ ☝🏻 🍞 Lakukan sendiri DNS proksi di Node.JS 👨‍🚒 👩🏽‍✈️ ♻️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Paket di atas gundukan di hutan jauh untuk DNS ... 
 L. Kaganov "Dusun di bagian bawah" 

 Saat mengembangkan aplikasi jaringan, terkadang menjadi per...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lakukan sendiri DNS proksi di Node.JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440050/"><blockquote> Paket di atas gundukan di hutan jauh untuk DNS ... <br>  <em>L. Kaganov "Dusun di bagian bawah"</em> </blockquote><p>  Saat mengembangkan aplikasi jaringan, terkadang menjadi perlu untuk menjalankannya secara lokal, tetapi mengaksesnya menggunakan nama domain asli.  Solusi standar terbukti adalah mendaftarkan domain di file host.  The minus dari pendekatan adalah bahwa host memerlukan korespondensi yang jelas dari nama domain, yaitu  tidak mendukung bintang.  Yaitu  jika ada domain formulir: </p><br><pre><code class="plaintext hljs">dom1.example.com, dom2.example.com, dom3.example.com, ................ domN.example.com,</code> </pre> <br><p>  maka pada host Anda harus mendaftarkan semuanya.  Dalam beberapa kasus, domain level ketiga tidak diketahui sebelumnya.  Ada keinginan (saya menulis untuk diri sendiri, seseorang mungkin mengatakan bahwa itu normal) untuk bertahan dengan garis seperti ini: </p><br><pre> <code class="plaintext hljs">*.example.com</code> </pre> <br><p>  Solusi untuk masalah ini mungkin menggunakan server DNS Anda sendiri, yang akan memproses permintaan sesuai dengan logika yang ditentukan.  Ada beberapa server, baik yang benar-benar gratis dan dengan antarmuka grafis yang nyaman, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CoreDNS</a> .  Anda juga dapat mengubah catatan DNS di router.  Akhirnya, gunakan layanan seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">xip.io</a> , ini bukan server DNS lengkap, tetapi sangat cocok untuk beberapa tugas.  Singkatnya, ada solusi siap pakai, Anda dapat menggunakan dan tidak repot. </p><br><p>  Tetapi artikel ini menjelaskan cara lain - menulis sepeda Anda sendiri, titik awal untuk membuat alat seperti yang tercantum di atas.  Kami akan menulis proksi DNS kami, yang akan mendengarkan permintaan DNS yang masuk, dan jika nama domain yang diminta ada dalam daftar, itu akan mengembalikan IP yang ditentukan, dan jika tidak, ia akan meminta server DNS yang lebih tinggi dan meneruskan tanggapan yang diterima tanpa perubahan pada program yang meminta. </p><a name="habracut"></a><br><p>  Pada saat yang sama, Anda dapat mencatat permintaan dan tanggapan yang diterima.  Karena DNS diperlukan oleh semua orang - browser, messenger, dan antivirus, dan layanan sistem operasi, dll., Itu bisa sangat informatif. </p><br><p>  Prinsipnya sederhana.  Dalam pengaturan koneksi jaringan untuk protokol IPv4, kami mengubah alamat server DNS ke alamat mesin dengan menjalankan proksi DNS yang ditulis sendiri (127.0.0.1, jika kami bekerja di luar jaringan), dan dalam pengaturannya kami menentukan alamat server DNS yang lebih tinggi.  Dan, sepertinya, itu saja! </p><br><p>  Kami tidak akan menggunakan fungsi standar untuk menyelesaikan <em>nslookup</em> dan <em>nsresolve</em> nama domain, sehingga pengaturan sistem DNS dan konten <em>file host</em> tidak akan mempengaruhi operasi program.  Bergantung pada situasinya, mungkin bermanfaat atau tidak, Anda hanya perlu mengingatnya.  Untuk kesederhanaan, kami membatasi diri pada implementasi fungsi dasar itu sendiri: </p><br><ul><li>  IP spoofing hanya untuk catatan tipe A (alamat host) dan kelas IN (Internet) </li><li>  alamat IP palsu hanya versi 4 </li><li>  koneksi untuk permintaan masuk lokal melalui UDP saja </li><li>  koneksi ke server DNS hulu melalui UDP atau TLS </li><li>  jika ada beberapa antarmuka jaringan, permintaan lokal yang masuk akan diterima pada salah satu dari mereka </li><li>  tidak ada dukungan EDNS </li></ul><br><div class="spoiler">  <b class="spoiler_title">Bicara soal tes</b> <div class="spoiler_text"><p>  Ada beberapa tes Unit dalam proyek ini.  Benar, mereka bekerja sesuai dengan prinsip: Saya meluncurkannya, dan jika sesuatu yang waras ditampilkan di konsol, maka semuanya baik-baik saja, tetapi jika ada pengecualian, maka ada masalah.  Tetapi bahkan pendekatan kikuk seperti itu memungkinkan Anda untuk berhasil melokalisasi masalah, begitu Unit. </p></div></div><br><h2 id="nachalo--server-na-53-m-portu">  Mulai - server pada port 53 </h2><br><p>  Mari kita mulai.  Pertama-tama, Anda perlu mengajarkan aplikasi untuk menerima permintaan DNS yang masuk.  Kami sedang menulis server TCP sederhana yang hanya mendengarkan port 53 dan mencatat koneksi masuk.  Di properti koneksi jaringan, tentukan alamat server DNS 127.0.0.1, buka aplikasi, buka browser untuk beberapa halaman - dan ... diam di konsol, browser menampilkan halaman secara normal.  Yah, kita ubah TCP ke UDP, kita mulai, kita pakai browser - di browser ada kesalahan koneksi, beberapa data biner dituangkan di konsol.  Jadi, sistem mengirimkan permintaan melalui UDP, dan kami akan mendengarkan koneksi yang masuk melalui UDP pada port 53.  Setengah jam kerja, di mana 15 menit google cara menaikkan server TCP dan UDP di NodeJS - dan kami telah menyelesaikan tugas landasan proyek, yang menentukan struktur aplikasi masa depan.  Kode tersebut adalah sebagai berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dgram = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dgram'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = dgram.createSocket(<span class="hljs-string"><span class="hljs-string">'udp4'</span></span>); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">function</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">server</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">on</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'error'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, (err</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`server error:\n</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${err.stack}</span></span></span><span class="hljs-string">`</span></span>); server.close(); }); server.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (localReq, linfo) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(localReq); <span class="hljs-comment"><span class="hljs-comment">//            }); server.on('listening', () =&gt; { const address = server.address(); console.log(`server listening ${address.address}:${address.port}`); }); const localListenPort = 53; const localListenAddress = 'localhost'; server.bind(localListenPort, localListenAddress); // server listening 0.0.0.0:53 }());</span></span></code> </pre> <br><p>  <em>Daftar 1. Kode minimum yang diperlukan untuk menerima permintaan DNS lokal</em> </p><br><p>  Poin berikutnya adalah membaca pesan untuk memahami apakah perlu mengembalikan IP kami sebagai tanggapan terhadapnya, atau hanya meneruskannya. </p><br><h2 id="dns-soobschenie">  Pesan DNS </h2><br><p>  Struktur pesan DNS dijelaskan dalam RFC-1035.  Baik permintaan dan tanggapan mengikuti struktur ini dan, pada prinsipnya, berbeda dalam satu bendera bit (bidang QR) di header pesan.  Pesan itu meliputi lima bagian: </p><br><pre> <code class="plaintext hljs">+---------------------+ | Header | +---------------------+ | Question | the question for the name server +---------------------+ | Answer | RRs answering the question +---------------------+ | Authority | RRs pointing toward an authority +---------------------+ | Additional | RRs holding additional information +---------------------+</code> </pre> <br><p>  <em>Struktur Pesan DNS Umum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1</a></em> </p><br><p>  Pesan DNS dimulai dengan header panjang tetap (ini yang disebut bagian <em>Header</em> ), yang berisi bidang dari 1 bit hingga dua byte panjang (dengan demikian, satu byte di header bisa berisi beberapa bidang).  Header dimulai dengan bidang ID - ini adalah pengidentifikasi permintaan 16-bit, responsnya harus memiliki ID yang sama.  Berikutnya adalah bidang yang menggambarkan jenis permintaan, hasil eksekusi dan jumlah catatan di setiap bagian pesan berikutnya.  Jelaskan semuanya untuk waktu yang lama, jadi siapa yang peduli - baik di RFC: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1.1</a> .  Bagian <em>Header</em> selalu ada dalam pesan DNS. </p><br><pre> <code class="plaintext hljs"> 1 1 1 1 1 1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ID | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |QR| Opcode |AA|TC|RD|RA| Z | RCODE | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QDCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ANCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | NSCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ARCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code> </pre> <br><p>  <em>Struktur header pesan DNS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1.1</a></em> </p><br><h3 id="sekciya-question">  Bagian pertanyaan </h3><br><p>  Bagian <em>Pertanyaan</em> berisi entri yang memberi tahu server secara tepat informasi apa yang dibutuhkan darinya.  Secara teoritis, di bagian catatan tersebut mungkin ada satu atau beberapa, jumlahnya ditunjukkan di bidang QDCOUNT di header pesan, dan bisa 0, 1 atau lebih.  Namun dalam praktiknya, bagian Pertanyaan hanya dapat berisi satu entri.  Jika bagian <em>Pertanyaan</em> berisi beberapa catatan, dan salah satunya akan menyebabkan kesalahan saat memproses permintaan di server, situasi yang tidak ditentukan akan muncul.  Meskipun server akan mengembalikan kode kesalahan di bidang RCODE dalam pesan respons, itu tidak akan dapat menunjukkan saat memproses yang merekam masalah terjadi, spesifikasi tidak menjelaskan ini.  Catatan juga tidak memiliki bidang yang berisi indikasi kesalahan dan jenisnya.  Oleh karena itu, ada perjanjian (tidak berdokumen), di mana bagian <em>Pertanyaan</em> hanya dapat berisi satu catatan, dan bidang QDCOUNT memiliki nilai 1. Juga tidak sepenuhnya jelas bagaimana memproses permintaan di sisi server, jika masih berisi beberapa catatan dalam <em>Pertanyaan</em> .  Seseorang menyarankan untuk mengembalikan pesan dengan kesalahan permintaan.  Dan, misalnya, Google DNS hanya memproses catatan pertama di bagian <em>Pertanyaan</em> , itu hanya mengabaikan sisanya.  Rupanya, ini tetap pada kebijaksanaan pengembang layanan DNS. </p><br><p>  Dalam respons DNS-message dari server, bagian <em>Pertanyaan</em> juga ada dan harus benar-benar menyalin <em>Pertanyaan</em> permintaan (untuk menghindari konflik, jika satu bidang ID tidak cukup). </p><br><p>  Satu-satunya entri di bagian <em>Pertanyaan</em> berisi bidang: QNAME (nama domain), QTYPE (tipe), QCLASS (kelas).  QTYPE dan QCLASS adalah angka bita ganda yang menunjukkan jenis dan kelas permintaan.  Jenis dan kelas yang mungkin dijelaskan dalam RFC-1035 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc1035#section-3.2</a> , semuanya jelas di sana.  Tetapi pada metode pencatatan nama domain kita akan membahas lebih detail di bagian "Format untuk merekam nama domain". </p><br><p>  Dalam hal permintaan, pesan DNS paling sering diakhiri dengan bagian <em>Pertanyaan</em> , kadang-kadang bagian <em>Tambahan</em> dapat mengikutinya. </p><br><p>  Jika kesalahan terjadi saat memproses permintaan di server (misalnya, permintaan masuk dibuat salah), pesan respons juga akan berakhir dengan bagian <em>Pertanyaan</em> atau <em>Tambahan</em> , dan bidang RCODE pada header pesan tanggapan akan berisi kode kesalahan. </p><br><h3 id="sekcii-answer-authority-i-additional">  <em>Bagian Jawab</em> , <em>Wewenang,</em> dan <em>Tambahan</em> </h3><br><p>  Bagian berikut ini adalah <em>Jawab</em> , <em>Otoritas</em> dan <em>Tambahan</em> ( <em>Jawab</em> dan <em>Otoritas</em> hanya terkandung dalam pesan DNS respons, <em>tambahan</em> dapat muncul dalam permintaan dan dalam respons).  Mereka adalah opsional, mis.  salah satu dari mereka mungkin ada atau tidak, tergantung pada permintaan.  Bagian-bagian ini memiliki struktur yang sama dan berisi informasi dalam format yang disebut "catatan sumber daya" (catatan sumber <em>daya</em> , atau RR).  Secara kiasan, masing-masing bagian ini adalah array dari catatan sumber daya, dan catatan adalah objek dengan bidang.  Setiap bagian dapat berisi satu atau lebih catatan, jumlahnya ditunjukkan dalam bidang yang sesuai di header pesan (masing-masing ANCOUNT, NSCOUNT, ARCOUNT).  Misalnya, permintaan IP untuk domain "google.com" akan mengembalikan beberapa alamat IP, jadi juga akan ada beberapa entri di bagian <em>Jawab</em> , satu untuk setiap alamat.  Jika bagian tidak ada, maka bidang header yang sesuai berisi 0. </p><br><p>  Setiap <em>catatan sumber daya</em> (RR) dimulai dengan bidang NAME yang berisi nama domain.  Format bidang ini sama dengan bidang QNAME pada bagian <em>Pertanyaan</em> . <br>  Di sebelah NAME adalah bidang TYPE (tipe catatan), dan CLASS (kelasnya), kedua bidang adalah angka 16-bit, menunjukkan jenis dan kelas catatan.  Ini juga menyerupai bagian <em>Pertanyaan</em> , dengan perbedaan bahwa QTYPE dan QCLASS-nya dapat memiliki semua nilai yang sama seperti TYPE dan CLASS, dan beberapa lagi milik mereka yang unik bagi mereka.  Artinya, dalam bahasa ilmiah kering, himpunan nilai QTYPE dan QCLASS adalah superset dari nilai TYPE dan CLASS.  Baca lebih lanjut tentang perbedaan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc1035#section-3.2.2</a> . <br>  Kolom yang tersisa adalah: </p><br><ul><li>  TTL adalah angka 32-bit yang menunjukkan waktu rekaman terakhir (dalam detik). </li><li>  RDLENGTH adalah angka 16-bit yang menunjukkan panjang bidang RDATA berikutnya dalam byte. </li><li>  RDATA sebenarnya adalah muatan, formatnya tergantung pada jenis catatan.  Misalnya, untuk catatan tipe A (alamat host) dan kelas IN (Internet) ini adalah 4 byte yang mewakili alamat IPv4. </li></ul><br><h2 id="format-zapisi-domennyh-imyon">  Format Catatan Nama Domain </h2><br><p>  Format untuk merekam nama domain adalah sama untuk bidang QNAME dan NAME, serta untuk bidang RDATA, jika itu adalah CNAME, MX, NS atau catatan kelas lainnya yang mengasumsikan nama domain sebagai hasilnya. </p><br><p>  Nama domain adalah urutan label (bagian dari nama, subdomain - ini adalah <strong>label</strong> dalam aslinya, saya tidak menemukan terjemahan yang lebih baik).  Label adalah satu byte panjang yang berisi angka - panjang isi label dalam byte, diikuti oleh urutan byte dari panjang yang ditentukan.  Label mengikuti satu demi satu hingga satu byte panjang yang mengandung 0. ditemui. Label pertama dapat langsung dari nol panjang, ini menunjukkan domain root (Root Domain) dengan nama domain kosong (kadang-kadang ditulis sebagai ""). </p><br><p>  Dalam versi DNS sebelumnya, byte dalam label bisa memiliki nilai mulai dari (0 hingga 255).  Ada aturan yang bersifat rekomendasi mendesak: bahwa label dimulai dengan huruf, diakhiri dengan huruf atau angka, dan hanya berisi huruf, angka atau tanda hubung dalam 7-bit ASCII encoding, dengan bit nol paling signifikan.  Spesifikasi EDNS saat ini sudah mensyaratkan kepatuhan dengan aturan-aturan ini dengan jelas, tanpa penyimpangan. </p><br><p>  Dua bit paling signifikan dari byte panjang digunakan sebagai atribut tipe tag.  Jika mereka nol ( <em>0b00xxxxxx</em> ), maka ini adalah label normal, dan bit yang tersisa dari byte panjangnya menunjukkan jumlah byte data yang termasuk dalam komposisinya.  Panjang label maksimum adalah 63 karakter.  63 dalam pengkodean biner hanya <em>0b00111111</em> . </p><br><p>  Jika dua bit paling signifikan adalah 0 dan 1 ( <em>0b01xxxxxx</em> ), <em>masing-masing</em> , maka ini adalah label tipe diperpanjang dari standar EDNS ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc2671#section-3.1</a> ), yang datang kepada kami mulai 1 Februari 2019.  Enam bit yang lebih rendah akan berisi nilai label.  Kami tidak membahas EDNS dalam artikel ini, tetapi perlu diketahui bahwa ini juga terjadi. </p><br><p>  Kombinasi dua bit paling signifikan, sama dengan 1 dan 0 ( <em>0b10xxxxxx</em> ), dicadangkan untuk penggunaan di masa mendatang. </p><br><p>  Jika kedua bit tinggi sama dengan 1 ( <em>0b11xxxxxx</em> ), ini berarti bahwa nama domain dikompresi ( <em>kompresi</em> ), dan kami akan membahasnya lebih terinci. </p><br><h3 id="szhatie-domennyh-imyon">  Kompresi Nama Domain </h3><br><p>  Jadi, jika panjang byte memiliki dua bit tinggi sama dengan 1 ( <em>0b11xxxxxx</em> ), ini adalah tanda kompresi nama domain.  Kompresi digunakan untuk membuat pesan lebih pendek dan lebih ringkas.  Ini terutama benar ketika bekerja pada UDP, ketika panjang total pesan DNS dibatasi hingga 512 byte (meskipun ini adalah standar lama, lihat <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc1035#section-2.3.4</a> Batas ukuran</em> , EDNS baru memungkinkan pengiriman pesan UPD dan lebih lama).  Inti dari proses ini adalah bahwa jika pesan DNS berisi nama domain dengan subdomain tingkat atas yang sama (misalnya, <em>mail.yandex.ru</em> dan <em>yandex.ru</em> ), maka alih-alih menentukan kembali seluruh nama domain, nomor byte dalam pesan DNS dari mana Lanjutkan membaca nama domain.  Ini bisa berupa byte dari pesan DNS, tidak hanya di catatan atau bagian saat ini, tetapi dengan ketentuan bahwa itu adalah byte dari panjang label domain.  Anda tidak dapat merujuk ke tengah tanda.  Misalkan ada domain <em>mail.yandex.ru</em> dalam pesan tersebut, maka dengan bantuan kompresi dimungkinkan untuk juga menunjuk domain "" <em>yandex.ru</em> , <em>ru</em> dan root (tentu saja, root lebih mudah untuk ditulis tanpa kompresi, tetapi secara teknis dimungkinkan untuk melakukan ini dengan kompresi), dan di sini untuk membuat <em>ndex.ru</em> tidak akan berfungsi.  Juga, semua nama domain turunan akan berakhir di domain root, yaitu, tulis, katakanlah, <em>mail.yandex</em> juga akan gagal. </p><br><p>  Nama domain dapat: </p><br><ul><li>  direkam sepenuhnya tanpa kompresi, </li><li>  mulai dari tempat yang menggunakan kompresi </li><li>  mulai dengan satu atau lebih label tanpa kompresi, dan kemudian beralih ke kompresi, </li><li>  kosong (untuk domain root). </li></ul><br><p>  Misalnya, kami sedang mengkompilasi pesan DNS, dan kami sudah menemukan nama "dom3.example.com" di dalamnya, sekarang kita perlu menentukan "dom4.dom3.example.com".  Dalam hal ini, Anda dapat merekam bagian "dom4" tanpa kompresi, dan kemudian beralih ke kompresi, yaitu menambahkan tautan ke "dom3.example.com".  Atau sebaliknya, jika nama "dom4.dom3.example.com" sebelumnya ditemukan, maka untuk menunjukkan "dom3.example.com" Anda dapat segera menggunakan kompresi dengan merujuk pada label "dom3" di dalamnya.  Apa yang tidak dapat kita lakukan adalah, seperti yang telah dikatakan, untuk menunjukkan bagian 'dom4.dom3' melalui kompresi, karena nama harus diakhiri dengan bagian tingkat atas.  Jika Anda tiba-tiba perlu menentukan segmen dari tengah, maka mereka hanya ditunjukkan tanpa kompresi. </p><br><p>  Untuk kesederhanaan, program kami tidak tahu cara menulis nama domain dengan kompresi, hanya bisa membaca.  Standar memungkinkan ini, membaca harus dilaksanakan tentu saja, menulis adalah opsional.  Secara teknis, pembacaan diimplementasikan seperti ini: jika dua bit paling signifikan dari satu byte panjang berisi 1, maka kita membaca byte yang mengikutinya, dan memperlakukan dua byte ini sebagai integer 16-bit unsigned integer, dengan urutan bit Big Endian.  Kami membuang dua bit paling signifikan (berisi 1), membaca angka 14-bit yang dihasilkan, dan melanjutkan membaca nama domain dari byte dalam pesan DNS di bawah angka yang sesuai dengan nomor ini. </p><br><p>  Kode untuk fungsi membaca nama domain adalah sebagai berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readDomainName</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf, startOffset, objReturnValue = {}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentByteIndex = startOffset; <span class="hljs-comment"><span class="hljs-comment">//    ,  DNS- ,      let initOctet = buf.readUInt8(currentByteIndex); let domain = ''; //      , ..       0, //  ,      // "the root domain name has no labels." (c) RFC-1035, p. 4.1.4. Message compression objReturnValue['endOffset'] = currentByteIndex; let lengthOctet = initOctet; while (lengthOctet &gt; 0) { //     var label; if (lengthOctet &gt;= 192) { //   :  0b1100 0000   const pointer = buf.readUInt16BE(currentByteIndex) - 49152; // 49152 === 0b1100 0000 0000 0000 === 192 * 256 const returnValue = {} label = readDomainName(buf, pointer, returnValue); domain += ('.' + label); objReturnValue['endOffset'] = currentByteIndex + 1; //      ,      break; } else { currentByteIndex++; label = buf.toString('ascii', currentByteIndex, currentByteIndex + lengthOctet); domain += ('.' + label); currentByteIndex += lengthOctet; lengthOctet = buf.readUInt8(currentByteIndex); objReturnValue['endOffset'] = currentByteIndex; } } return domain.substring(1); //    —  "." }</span></span></code> </pre> <br><p>  <em>Daftar 2. Membaca nama domain dari permintaan DNS</em> </p><br><p>  Kode lengkap untuk fungsi membaca catatan DNS dari buffer biner: </p><br><div class="spoiler">  <b class="spoiler_title">Daftar 3. Membaca catatan DNS dari buffer biner</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseDnsMessageBytes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> msgFields = {}; <span class="hljs-comment"><span class="hljs-comment">// (c) RFC 1035 p. 4.1.1. Header section format msgFields['ID'] = buf.readUInt16BE(0); const byte_2 = buf.readUInt8(2); //  #2 (starting from 0) const mask_QR = 0b10000000; msgFields['QR'] = !!(byte_2 &amp; mask_QR); //  : 0 "false" =&gt; , 1 "true" =&gt;  const mask_Opcode = 0b01111000; const opcode = (byte_2 &amp; mask_Opcode) &gt;&gt;&gt; 3; //   (): 0, 1, 2,   msgFields['Opcode'] = opcode; const mask_AA = 0b00000100; msgFields['AA'] = !!(byte_2 &amp; mask_AA); const mask_TC = 0b00000010; msgFields['TC'] = !!(byte_2 &amp; mask_TC); const mask_RD = 0b00000001; msgFields['RD'] = !!(byte_2 &amp; mask_RD); const byte_3 = buf.readUInt8(3); //  #3 const mask_RA = 0b10000000; msgFields['RA'] = !!(byte_3 &amp; mask_RA); const mask_Z = 0b01110000; msgFields['Z'] = (byte_3 &amp; mask_Z) &gt;&gt;&gt; 4; //  0,  const mask_RCODE = 0b00001111; msgFields['RCODE'] = (byte_3 &amp; mask_RCODE); // 0 =&gt; no error; (dec) 1, 2, 3, 4, 5 - errors, see RFC msgFields['QDCOUNT'] = buf.readUInt16BE(4); //     Question,   0  1 msgFields['ANCOUNT'] = buf.readUInt16BE(6); //     Answer msgFields['NSCOUNT'] = buf.readUInt16BE(8); //     Authority msgFields['ARCOUNT'] = buf.readUInt16BE(10); //     Additional //    Question let currentByteIndex = 12; //  Question   12-  DNS- (c) RFC 1035 p. 4.1.2. Question section format msgFields['questions'] = []; for (let qdcount = 0; qdcount &lt; msgFields['QDCOUNT']; qdcount++) { const question = {}; const resultByteIndexObj = { endOffset: undefined }; const domain = readDomainName(buf, currentByteIndex, resultByteIndexObj); currentByteIndex = resultByteIndexObj.endOffset + 1; question['domainName'] = domain; question['qtype'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "A" record currentByteIndex += 2; question['qclass'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "IN" Internet currentByteIndex += 2; msgFields['questions'].push(question); } // (c) RFC 1035 p. 4.1.3. Resource record format //    (Resourse Records, RR)  Answer, Authority, Additional ['answer', 'authority', 'additional'].forEach(function(section, i, arr) { let msgFieldsName, countFieldName; switch(section) { case 'answer': msgFieldsName = 'answers'; countFieldName = 'ANCOUNT'; break; case 'authority': msgFieldsName = 'authorities'; countFieldName = 'NSCOUNT'; break; case 'additional': msgFieldsName = 'additionals'; countFieldName = 'ARCOUNT'; break; } msgFields[msgFieldsName] = []; for (let recordsCount = 0; recordsCount &lt; msgFields[countFieldName]; recordsCount++) { let record = {}; const objReturnValue = {}; const domain = readDomainName(buf, currentByteIndex, objReturnValue); currentByteIndex = objReturnValue['endOffset'] + 1; record['domainName'] = domain; record['type'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "A" record currentByteIndex += 2; record['class'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "IN" Internet currentByteIndex += 2; // TTL  4  record['ttl'] = buf.readUIntBE(currentByteIndex, 4); currentByteIndex += 4; record['rdlength'] = buf.readUInt16BE(currentByteIndex); currentByteIndex += 2; const rdataBinTempBuf = buf.slice(currentByteIndex, currentByteIndex + record['rdlength']); record['rdata_bin'] = Buffer.alloc(record['rdlength'], rdataBinTempBuf); if (record['type'] === 1 &amp;&amp; record['class'] === 1) { //      IPv4,      let ipStr = ''; for (ipv4ByteIndex = 0; ipv4ByteIndex &lt; 4; ipv4ByteIndex++) { ipStr += '.' + buf.readUInt8(currentByteIndex).toString(); currentByteIndex++; } record['IPv4'] = ipStr.substring(1); //    '.' } else { //    ,   currentByteIndex += record['rdlength']; } msgFields[msgFieldsName].push(record); } }); return msgFields; }</span></span></code> </pre> <br><p> <em> 3.  DNS-   </em> </p></div></div><br><p> ,       . ,     ,   ,    .   ,     DNS-,     ,   .  ,       . </p><br><p>  ,        - <code>server.on("message", () =&gt; {})</code>   1.   : </p><br><div class="spoiler"> <b class="spoiler_title"> 4.    DNS-</b> <div class="spoiler_text"><pre> <code class="javascript hljs">server.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (localReq, linfo) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dnsRequest = functions.parseDnsMessageBytes(localReq); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> question = dnsRequest.questions[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// currently, only one question per query is supported by DNS implementations let forgingHostParams = undefined; // ,         IP for (let i = 0; i &lt; config.requestsToForge.length; i++) { const requestToForge = config.requestsToForge[i]; const targetDomainName = requestToForge.hostName; if (functions.domainNameMatchesTemplate(question.domainName, targetDomainName) &amp;&amp; question.qclass === 1 &amp;&amp; question.qtype === 1) { forgingHostParams = requestToForge; break; } } //  ,    DNS-      if (!!forgingHostParams) { const forgeIp = forgingHostParams.ip; const answers = []; answers.push({ domainName: question.domainName, type: question.qtype, class: question.qclass, ttl: forgedRequestsTTL, rdlength: 4, rdata_bin: functions.ip4StringToBuffer(forgeIp), IPv4: forgeIp }); const localDnsResponse = { ID: dnsRequest.ID, QR: dnsRequest.QR, Opcode: dnsRequest.Opcode, AA: dnsRequest.AA, TC: false, // dnsRequest.TC, RD: dnsRequest.RD, RA: true, Z: dnsRequest.Z, RCODE: 0, // dnsRequest.RCODE, 0 - no errors, look in RFC-1035 for other error conditions QDCOUNT: dnsRequest.QDCOUNT, ANCOUNT: answers.length, NSCOUNT: dnsRequest.NSCOUNT, ARCOUNT: dnsRequest.ARCOUNT, questions: dnsRequest.questions, answers: answers } //     DNS-    const responseBuf = functions.composeDnsMessageBin(localDnsResponse); console.log('response composed for: ', localDnsResponse.questions[0]); server.send(responseBuf, linfo.port, linfo.address, (err, bytes) =&gt; {}); } // ,     DNS-,         else { //     DNS-  UDP,     const responseBuf = await functions.getRemoteDnsResponseBin(localReq, upstreamDnsIP, upstreamDnsPort); //        server.send(responseBuf, linfo.port, linfo.address, (err, bytes) =&gt; {}); //     DNS-  TLS,   , .  9 } });</span></span></code> </pre> <br><p> <em> 4.    DNS-</em> </p></div></div><br><h2 id="dobavlyaem-podderzhku-tls">   TLS </h2><br><p>        DNS-.    ,      DNS-   TLS (HTTPS    ).  DNS-  TLS     TCP,    ,   TLS    .          TCP,   RFC-7766 DNS Transport over TCP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc7766</a> ).    ,  :      TLS,   TCP   ( ,       DNS  TCP,      TLS-  TCP-,     ). </p><br><h3 id="ustanovka-tls-soedineniya">  TLS- </h3><br><p>  TLS-           ,       ,   .  ,         TLS-,       .  RFC-7858 -        : </p><br><pre> <code class="plaintext hljs">In order to amortize TCP and TLS connection setup costs, clients and servers SHOULD NOT immediately close a connection after each response. Instead, clients and servers SHOULD reuse existing connections for subsequent queries as long as they have sufficient resources. In some cases, this means that clients and servers may need to keep idle connections open for some amount of time. () https://tools.ietf.org/html/rfc7858#section-3.4</code> </pre> <br><p>       ,   TLS-,   ,     ,   ,   ,       .   ,        30 ,   ,      ,        DNS-.  30  ~  ~   ,   15  60 ,         .        ,         .   - . </p><br><p> TLS-     NodeJS.    ,    TLS-     : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tls = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'tls'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TLS_SOCKET_IDLE_TIMEOUT = <span class="hljs-number"><span class="hljs-number">30000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     TLS- function Module(connectionOptions, funcOnData, funcOnError, funcOnClose, funcOnEnd) { let socket; function connect() { socket = tls.connect(connectionOptions, () =&gt; { console.log('client connection established:', socket.authorized ? 'authorized' : 'unauthorized'); }); socket.on('data', funcOnData); // connection.on('end', () =&gt; {}); socket.on('close', (hasTransmissionError) =&gt; { //   ,     . //   ,     console.log('connection closed; transmission error:', hasTransmissionError); }); socket.on('end', () =&gt; { console.log('remote TLS server connection closed.') }); socket.on('error', (err) =&gt; { console.log('connection error:', err); console.log('\tmessage:', err.message); console.log('\tstack:', err.stack); }) socket.setTimeout(TLS_SOCKET_IDLE_TIMEOUT); socket.on('timeout', () =&gt; { console.log('socket idle timeout, disconnected.'); socket.end(); }); } this.write = function (dataBuf) { if (socket &amp;&amp; socket.writable) { //  ,     } else { connect(); } socket.write(dataBuf); } return this; } module.exports = Module;</span></span></code> </pre> <br><p> <em> 5. ,   TLS-</em> </p><br><p>       DNS-over-TLS ,   Google DNS.        ,               <code>socket = tls.connect(connectionOptions, () =&gt; {})</code> .     NodeJS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://nodejs.org/api/tls.html#tls_tls_connect_options_callback</a> ,       . </p><br><p>  TLS-   : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">port</span></span>: config.upstreamDnsTlsPort, <span class="hljs-comment"><span class="hljs-comment">//        host: config.upstreamDnsTlsHost } const onData = (data) =&gt; { //     , .       7 }; remoteTlsClient = new TlsClient(options, onData);</span></span></code> </pre> <br><p> <em> 6.  TLS-</em> </p><br><p>     ,        TCP-.   TCP/TLS-      DNS-,     ,    ,     ,   .    TCP (  TLS),  DNS-   512 ,    UDP (,  EDNS    UDP  ).  ,  DNS-    UDP,             .       <strong>onData()</strong>   6. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    DNS-,       TLS-   //    ,     2 ,       let dataCurrentPos = 0; try { while (dataCurrentPos &lt; data.length) { const respLen = data.readUInt16BE(dataCurrentPos); respBuf = data.slice(dataCurrentPos + 2, dataCurrentPos + 2 + respLen); const respData = functions.parseDnsMessageBytes(respBuf); const requestKey = functions.getRequestIdentifier(respData); const localResponseParams = localRequestsAwaiting.get(requestKey); localRequestsAwaiting.delete(requestKey); server.send(respBuf, localResponseParams.port, localResponseParams.address, (err, bytesNum) =&gt; {}); dataCurrentPos += 2 + respLen; } } catch (err) { console.error(err); //   ,     throw err; } };</span></span></code> </pre> <br><p> <em> 7.   TLS-   DNS-   6</em> </p><br><h3 id="poryadok-otvetov-ot-udalyonnogo-dns-servera">     DNS- </h3><br><p>  ,            ,     .   ,         ID     QNAME, QTYPE  QCLASS  <em>Question</em> : </p><br><pre> <code class="plaintext hljs">Since pipelined responses can arrive out of order, clients MUST match responses to outstanding queries on the same TLS connection using the Message ID. If the response contains a Question Section, the client MUST match the QNAME, QCLASS, and QTYPE fields. () https://tools.ietf.org/html/rfc7858#section-3.3</code> </pre> <br><p>     ,  ,    ,   ID   <em>Question</em> (   ,      ). </p><br><p>        UDP (.  4),    ,         -,    ,   UDP-     .        ,       DNS-,       .          ,       -.  ,         ,      UDP-         -.  ,  ,    . </p><br><p>      TLS,               .         (IP  ),    ,       . </p><br><p>        IP      "-".   ,    ,   ,     DNS-.   ,    ,         IP  ,     .        7: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const requestKey = functions.getRequestIdentifier(respData); //    IP    ,   const localResponseParams = localRequestsAwaiting.get(requestKey); localRequestsAwaiting.delete(requestKey); //      IP   server.send(respBuf, localResponseParams.port, localResponseParams.address, (err, bytesNum) =&gt; {});</span></span></code> </pre> <br><p> <em> 8.        7</em> </p><br><p>      TLS-: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     const localReqParams = { address: linfo.address, port: linfo.port }; //        const requestKey = functions.getRequestIdentifier(dnsRequest); //       localRequestsAwaiting.set(requestKey, localReqParams); //       ,      const lenBuf = Buffer.alloc(2); lenBuf.writeUInt16BE(localReq.length); const prepReqBuf = Buffer.concat([lenBuf, localReq], 2 + localReq.length); remoteTlsClient.write(prepReqBuf); //  RFC-7766 p.8, 2               </span></span></code> </pre> <br><p> <em> 9.    DNS-  TLS- (  .  4)</em> </p><br><h2 id="chtenie-konfiguracii-iz-fayla-i-eyo-obnovlenie">        </h2><br><p>   ,   ,      .     JSON,    ,   NodeJS   JSON-      .  JSON —      ,      .  ,    JSON-  "comment" (  )       . ,  ,  ,    ,  .  ,        ,     .      ,   -  ,    ,            NodeJS.    ,   ,     .  ,         ,       ;   ,   .           ,     - . </p><br><div class="spoiler"> <b class="spoiler_title"> 10.     </b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CONFIG_FILE_PATH = path.resolve(<span class="hljs-string"><span class="hljs-string">'./config.json'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Module</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// config  -,       . //    config        , //         . ,    : // const conf = config; //   conf     ,    : // const requestsToForge = config.requestsToForge; //    , requestsToForge   . const config = {}; Object.defineProperty(this, 'config', { get() { return config; }, enumerable: true }) this.initConfig = async function() { const fileContents = await readConfigFile(CONFIG_FILE_PATH); console.log('initConfig:'); console.log(fileContents); console.log('fileContents logged ^^'); const parsedConfigData = parseConfig(fileContents); Object.assign(config, parsedConfigData); }; async function readConfigFile(configPath) { const promise = new Promise((resolve, reject) =&gt; { fs.readFile(configPath, { encoding: 'utf8', flag: 'r' }, (err, data) =&gt; { if (err) { console.log('readConfigFile err to throw'); throw err; } resolve(data); }); }) .then( fileContents =&gt; { return fileContents; } ) .catch(err =&gt; { console.log('readConfigFile error: ', err); }); return promise; } function parseConfig(fileContents) { const configData = JSON.parse(fileContents); return configData; } //   ,       . //  Windows,    fs.watch     , //      ,   configReadInProgress let configReadInProgress = false; fs.watch(CONFIG_FILE_PATH, async () =&gt; { if(!configReadInProgress) { configReadInProgress = true; console.log('===== config changed, run initConfig() ====='); try { await this.initConfig(); } catch (err) { console.log('===== error initConfig(), skip =====,', err); configReadInProgress = false; } configReadInProgress = false; } else { console.log('===== config changed, initConfig() already running, skip ====='); } }); } let instance; async function getInstance() { if(!instance) { instance = new Module(); await instance.initConfig(); } return instance; } module.exports = getInstance;</span></span></code> </pre> <br><p> <em> 10.     </em> </p></div></div><br><h2 id="itogo">  Total </h2><br><p>    DNS-  NodeJS,     <em>npm</em>   .    ,        ,   ,  ,         . </p><br><p> <strong><a href="">   GitHub</a></strong> </p><br><h3 id="istochniki"> : </h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC-1035</a> DOMAIN NAMES — IMPLEMENTATION AND SPECIFICATION </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC-7858</a> Specification for DNS over Transport Layer Security (TLS) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC-7766</a> DNS Transport over TCP — Implementation Requirements </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://stackoverflow.com/questions/4082081/requesting-a-and-aaaa-records-in-single-dns-query/4083071#4083071</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440050/">https://habr.com/ru/post/id440050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440036/index.html">Sentuhan mengetik</a></li>
<li><a href="../id440040/index.html">Dalam pengembangan - masing-masing untuk dirinya sendiri. Tapi terkadang itu mengarah ke jalan buntu.</a></li>
<li><a href="../id440044/index.html">Riwayat Lengkap Qualcomm</a></li>
<li><a href="../id440046/index.html">Buka pelajaran "Membuat Klien REST di Musim Semi"</a></li>
<li><a href="../id440048/index.html">Metrik favorit: 5 indikator yang harus diikuti oleh setiap tim penjualan</a></li>
<li><a href="../id440052/index.html">Analisis BIOS / UEFI Statis atau Cara Mendapatkan Grafik Ketergantungan</a></li>
<li><a href="../id440054/index.html">Transfer layanan web ke Yandex.Cloud dengan AWS</a></li>
<li><a href="../id440058/index.html">Laporan Masalah & Ketersediaan Internet 2018–2019</a></li>
<li><a href="../id440060/index.html">TensorFlow di Apache Ignite</a></li>
<li><a href="../id440062/index.html">Merencanakan dengan senang hati. Bagaimana kami mengatur proses tanpa manajer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>