<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐴 🐨 🧖🏿 Introdução à linguagem de consulta Cypher 🥅 👩🏻‍🌾 ⛵️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A linguagem de consulta Cypher foi originalmente desenvolvida especificamente para o DBMS gráfico Neo4j . O objetivo do Cypher é fornecer uma linguage...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introdução à linguagem de consulta Cypher</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482418/"><p>  A linguagem de consulta <em>Cypher</em> foi originalmente desenvolvida especificamente para o DBMS <a href="https://neo4j.com/" rel="nofollow">gráfico Neo4j</a> .  O objetivo do Cypher é fornecer uma linguagem de consulta de banco de dados SQL legível por humanos para bancos de dados de gráficos.  Hoje, o Cypher é suportado por vários DBMSs de gráficos.  <a href="http://www.opencypher.org/" rel="nofollow">O OpenCypher</a> foi criado para padronizar o Cypher. </p><br><p>  As noções básicas de trabalho com o DBMS do Neo4j são descritas no artigo <a href="https://habr.com/ru/post/470541/">Noções básicas de trabalho com o Neo4j em um navegador</a> . </p><br><p>  Para se familiarizar com Cypher, considere um exemplo de uma árvore genealógica emprestada do clássico livro de Prolog de I. Bratko.  Este exemplo mostra como adicionar nós e links a um gráfico, como atribuir rótulos e atributos a eles e como fazer perguntas. </p><br><p><img src="https://habrastorage.org/webt/ix/__/op/ix__op6ei5llgpwdtzrnpcv5xd4.png" alt="Árvore genealógica no Neo4j, vista editada"></p><a name="habracut"></a><br><p>  Então, vamos ter uma árvore genealógica mostrada na figura abaixo. </p><br><p><img src="https://habrastorage.org/webt/zy/zf/v4/zyzfv4aasw-sokctup7s3vq4csi.png" alt="Árvore genealógica"></p><br><p>  Vamos ver como formar o gráfico correspondente no Cypher: </p><br><pre><code class="plaintext hljs">CREATE (pam:Person {name: "Pam"}), (tom:Person {name: "Tom"}), (kate:Person {name: "Kate"}), (mary:Person {name: "Mary"}), (bob:Person {name: "Bob"}), (liz:Person {name: "Liz"}), (dick:Person {name: "Dick"}), (ann:Person {name: "Ann"}), (pat:Person {name: "Pat"}), (jack:Person {name: "Jack"}), (jim:Person {name: "Jim"}), (joli:Person {name: "Joli"}), (pam)-[:PARENT]-&gt;(bob), (tom)-[:PARENT]-&gt;(bob), (tom)-[:PARENT]-&gt;(liz), (kate)-[:PARENT]-&gt;(liz), (mary)-[:PARENT]-&gt;(ann), (bob)-[:PARENT]-&gt;(ann), (bob)-[:PARENT]-&gt;(pat), (dick)-[:PARENT]-&gt;(jim), (ann)-[:PARENT]-&gt;(jim), (pat)-[:PARENT]-&gt;(joli), (jack)-[:PARENT]-&gt;(joli)</code> </pre> <br><p>  Uma solicitação CREATE para adicionar dados a um DBMS gráfico consiste em duas partes: adicionando nós e adicionando links entre eles.  Cada nó a ser adicionado recebe um nome na estrutura desta solicitação, que é usada para criar links.  Nós e comunicações podem armazenar documentos.  No nosso caso, os nós contêm documentos com os campos de nome e os links do documento não.  Também nós e links podem ser rotulados.  No nosso caso, os nós recebem o rótulo Pessoa e os links são PAI.  O rótulo nas solicitações é destacado por dois pontos antes do nome. </p><br><p>  Portanto, o Neo4j nos disse que: <code>Added 12 labels, created 12 nodes, set 12 properties, created 11 relationships, completed after 9 ms.</code> </p><br><p>  Vamos ver o que temos: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) RETURN p</code> </pre> <br><p><img src="https://habrastorage.org/webt/ch/gc/ya/chgcyawfcxryshb6p1xdjtf7fp8.png" alt="Árvore genealógica em Neo4j"></p><br><p>  Ninguém nos proíbe de editar a aparência do gráfico resultante: </p><br><p><img src="https://habrastorage.org/webt/ix/__/op/ix__op6ei5llgpwdtzrnpcv5xd4.png" alt="Árvore genealógica no Neo4j, vista editada"></p><br><p>  O que pode ser feito com isso?  Você pode verificar se, por exemplo, Pam é <br>  Pai de Bob: </p><br><pre> <code class="plaintext hljs">MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Bob"}) RETURN ans</code> </pre> <br><p>  Obtemos o subgráfico correspondente: </p><br><p><img src="https://habrastorage.org/webt/dj/jq/o_/djjqo_tukevpbd1viu8smouuume.png" alt="Pam é mãe de Bob"></p><br><p>  No entanto, isso não é exatamente o que precisamos.  Altere a solicitação: </p><br><pre> <code class="plaintext hljs">MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Bob"}) RETURN ans IS NOT NULL</code> </pre> <br><p>  Agora, em resposta, nos tornamos <code>true</code> .  E se perguntarmos: </p><br><pre> <code class="plaintext hljs">MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Liz"}) RETURN ans IS NOT NULL</code> </pre> <br><p>  Não receberemos nada ... Aqui você precisa adicionar a palavra <code>OPTIONAL</code> , se <br>  o resultado estará vazio e <code>false</code> será retornado: </p><br><pre> <code class="plaintext hljs">OPTIONAL MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Liz"}) RETURN ans IS NOT NULL</code> </pre> <br><p>  Agora temos a resposta esperada <code>false</code> . </p><br><p>  Em seguida, você pode ver quem é o pai de quem: </p><br><pre> <code class="plaintext hljs">MATCH (p1:Person)-[:PARENT]-&gt;(p2:Person) RETURN p1, p2</code> </pre> <br><p>  Abra a guia de resultados com <code>Text</code> e veja uma tabela com duas colunas: </p><br><pre> <code class="plaintext hljs">╒═══════════════╤═══════════════╕ │"p1" │"p2" │ ╞═══════════════╪═══════════════╡ │{"name":"Pam"} │{"name":"Bob"} │ ├───────────────┼───────────────┤ │{"name":"Tom"} │{"name":"Bob"} │ ├───────────────┼───────────────┤ │{"name":"Tom"} │{"name":"Liz"} │ ├───────────────┼───────────────┤ │{"name":"Kate"}│{"name":"Liz"} │ ├───────────────┼───────────────┤ │{"name":"Mary"}│{"name":"Ann"} │ ├───────────────┼───────────────┤ │{"name":"Bob"} │{"name":"Ann"} │ ├───────────────┼───────────────┤ │{"name":"Bob"} │{"name":"Pat"} │ ├───────────────┼───────────────┤ │{"name":"Dick"}│{"name":"Jim"} │ ├───────────────┼───────────────┤ │{"name":"Ann"} │{"name":"Jim"} │ ├───────────────┼───────────────┤ │{"name":"Pat"} │{"name":"Joli"}│ ├───────────────┼───────────────┤ │{"name":"Jack"}│{"name":"Joli"}│ └───────────────┴───────────────┘</code> </pre> <br><p>  O que mais podemos aprender?  Por exemplo, quem é o pai de um membro específico do gênero, por exemplo, para Bob: </p><br><pre> <code class="plaintext hljs">MATCH (parent:Person)-[:PARENT]-&gt;(:Person {name: "Bob"}) RETURN parent.name</code> </pre> <br><pre> <code class="plaintext hljs">╒═════════════╕ │"parent.name"│ ╞═════════════╡ │"Tom" │ ├─────────────┤ │"Pam" │ └─────────────┘</code> </pre> <br><p>  Aqui, como resposta, não solicitamos o nó inteiro, mas apenas seu atributo específico. </p><br><p>  Também podemos descobrir quem são os filhos de Bob: </p><br><pre> <code class="plaintext hljs">MATCH (:Person {name: "Bob"})-[:PARENT]-&gt;(child:Person) RETURN child.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════════╕ │"child.name"│ ╞════════════╡ │"Ann" │ ├────────────┤ │"Pat" │ └────────────┘</code> </pre> <br><p>  Também podemos perguntar quem tem filhos: </p><br><pre> <code class="plaintext hljs">MATCH (parent:Person)-[:PARENT]-&gt;(:Person) RETURN parent.name</code> </pre> <br><pre> <code class="plaintext hljs">╒═════════════╕ │"parent.name"│ ╞═════════════╡ │"Pam" │ ├─────────────┤ │"Tom" │ ├─────────────┤ │"Tom" │ ├─────────────┤ │"Kate" │ ├─────────────┤ │"Mary" │ ├─────────────┤ │"Bob" │ ├─────────────┤ │"Bob" │ ├─────────────┤ │"Dick" │ ├─────────────┤ │"Ann" │ ├─────────────┤ │"Pat" │ ├─────────────┤ │"Jack" │ └─────────────┘</code> </pre> <br><p>  Hmm, Tom e Bob se conheceram duas vezes, conserte: </p><br><pre> <code class="plaintext hljs">MATCH (parent:Person)-[:PARENT]-&gt;(:Person) RETURN DISTINCT parent.name</code> </pre> <br><p>  Adicionamos a palavra <code>DISTINCT</code> ao resultado de retorno da consulta, o que significa <br>  semelhante ao do SQL. </p><br><pre> <code class="plaintext hljs">╒═════════════╕ │"parent.name"│ ╞═════════════╡ │"Pam" │ ├─────────────┤ │"Tom" │ ├─────────────┤ │"Kate" │ ├─────────────┤ │"Mary" │ ├─────────────┤ │"Bob" │ ├─────────────┤ │"Dick" │ ├─────────────┤ │"Ann" │ ├─────────────┤ │"Pat" │ ├─────────────┤ │"Jack" │ └─────────────┘</code> </pre> <br><p>  Você também pode perceber que o Neo4j nos devolve os pais na ordem em que foram inseridos na solicitação <code>CREATE</code> . </p><br><p>  Vamos agora perguntar quem é avô ou avó: </p><br><pre> <code class="plaintext hljs">MATCH (grandparent:Person)-[:PARENT]-&gt;()-[:PARENT]-&gt;(:Person) RETURN DISTINCT grandparent.name</code> </pre> <br><p>  Ótimo, é isso: </p><br><pre> <code class="plaintext hljs">╒══════════════════╕ │"grandparent.name"│ ╞══════════════════╡ │"Tom" │ ├──────────────────┤ │"Pam" │ ├──────────────────┤ │"Bob" │ ├──────────────────┤ │"Mary" │ └──────────────────┘</code> </pre> <br><p>  No modelo de consulta, usamos um nó sem nome intermediário <code>()</code> e duas relações do tipo <code>PARENT</code> . </p><br><p>  Agora descobrimos quem é o pai.  O pai é um homem que tem um filho.  Assim, nos faltam dados sobre quem é o homem.  Assim, para determinar quem é mãe, você precisa saber quem é mulher.  Adicione as informações relevantes ao nosso banco de dados.  Para isso, atribuiremos os rótulos <code>Male</code> e <code>Female</code> aos nós existentes. </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p.name IN ["Tom", "Dick", "Bob", "Jim", "Jack"] SET p:Male</code> </pre> <br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p.name IN ["Pam", "Kate", "Mary", "Liz", "Ann", "Pat", "Joli"] SET p:Female</code> </pre> <br><p>  Vamos explicar o que fizemos aqui: selecionamos todos os nós rotulados como <code>Person</code> , verificamos eles <br>  a propriedade <code>name</code> acordo com a lista especificada entre colchetes e atribuiu aos nós correspondentes o rótulo <code>Male</code> ou <code>Female</code> respectivamente. </p><br><p>  Verifique: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p:Male RETURN p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Tom" │ ├────────┤ │"Bob" │ ├────────┤ │"Dick" │ ├────────┤ │"Jack" │ ├────────┤ │"Jim" │ └────────┘</code> </pre> <br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p:Female RETURN p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Pam" │ ├────────┤ │"Kate" │ ├────────┤ │"Mary" │ ├────────┤ │"Liz" │ ├────────┤ │"Ann" │ ├────────┤ │"Pat" │ ├────────┤ │"Joli" │ └────────┘</code> </pre> <br><p>  Solicitamos todos os nós rotulados <code>Person</code> , que também possuem um rótulo <code>Male</code> ou <code>Female</code> , respectivamente.  Mas poderíamos tornar nossos pedidos um pouco diferentes: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person:Male) RETURN p.name MATCH (p:Person:Female) RETURN p.name</code> </pre> <br><p>  Vamos dar uma olhada no nosso gráfico novamente: </p><br><p><img src="https://habrastorage.org/webt/zc/nn/pj/zcnnpj6ynprgddwmbdhoh3ubjp8.png" alt="Árvore genealógica com tags Masculino e Feminino"></p><br><p>  O Neo4j Browser pintou os nós em duas cores diferentes, de acordo com as marcas Masculino e <br>  Feminino </p><br><p>  Ok, agora podemos consultar todos os pais do banco de dados: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person:Male)-[:PARENT]-&gt;(:Person) RETURN DISTINCT p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Tom" │ ├────────┤ │"Bob" │ ├────────┤ │"Dick" │ ├────────┤ │"Jack" │ └────────┘</code> </pre> <br><p>  E mães: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person:Female)-[:PARENT]-&gt;(:Person) RETURN DISTINCT p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Pam" │ ├────────┤ │"Kate" │ ├────────┤ │"Mary" │ ├────────┤ │"Ann" │ ├────────┤ │"Pat" │ └────────┘</code> </pre> <br><p>  Vamos agora formular um relacionamento de irmão e irmã.  X é irmão de Y, <br>  se ele é homem, e para X e Y há pelo menos um pai em comum.  Da mesma forma para <br>  irmã de relacionamento. </p><br><p>  Atitude do irmão em Cypher: </p><br><pre> <code class="plaintext hljs">MATCH (brother:Person:Male)&lt;-[:PARENT]-()-[:PARENT]-&gt;(p:Person) RETURN brother.name, p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒══════════════╤════════╕ │"brother.name"│"p.name"│ ╞══════════════╪════════╡ │"Bob" │"Liz" │ └──────────────┴────────┘</code> </pre> <br><p>  Atitude de irmã em Cypher: </p><br><pre> <code class="plaintext hljs">MATCH (sister:Person:Female)&lt;-[:PARENT]-()-[:PARENT]-&gt;(p:Person) RETURN sister.name, p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒═════════════╤════════╕ │"sister.name"│"p.name"│ ╞═════════════╪════════╡ │"Liz" │"Bob" │ ├─────────────┼────────┤ │"Ann" │"Pat" │ ├─────────────┼────────┤ │"Pat" │"Ann" │ └─────────────┴────────┘</code> </pre> <br><p>  Assim, podemos descobrir quem é o pai e quem é o avô ou a avó.  Mas e os ancestrais mais distantes?  Com os bisavôs, os bisavós ou assim por diante?  Não escreveremos uma regra correspondente para cada um desses casos, e será sempre mais problemática.  De fato, tudo é simples: X é um ancestral para Y se for um ancestral para um pai Y. Cypher fornece um padrão <code>*</code> que permite exigir uma sequência de relações de qualquer tamanho: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person)-[*]-&gt;(s:Person) RETURN DISTINCT p.name, s.name</code> </pre> <br><p>  Existe realmente um problema nisso: serão quaisquer conexões.  Adicione uma referência ao link <code>PARENT</code> : </p><br><pre> <code class="plaintext hljs">MATCH (p:Person)-[:PARENT*]-&gt;(s:Person) RETURN DISTINCT p.name, s.name</code> </pre> <br><p>  Para não aumentar o comprimento do artigo, encontramos todos os ancestrais de <code>Joli</code> : </p><br><pre> <code class="plaintext hljs">MATCH (p:Person)-[:PARENT*]-&gt;(:Person {name: "Joli"}) RETURN DISTINCT p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Jack" │ ├────────┤ │"Pat" │ ├────────┤ │"Bob" │ ├────────┤ │"Pam" │ ├────────┤ │"Tom" │ └────────┘</code> </pre> <br><p>  Considere uma regra mais complexa para descobrir quem está relacionado a quem. <br>  Primeiro, parentes são ancestrais e descendentes, por exemplo, filho e mãe, avó e neto.  Em segundo lugar, parentes são irmãos e irmãs, incluindo primos, primos em segundo grau e assim por diante, o que em termos de antepassados ​​significa que eles têm um ancestral em comum.  E em terceiro lugar, parentes que têm descendentes em comum, por exemplo, marido e mulher, são considerados parentes. </p><br><p>  No Cypher, você precisa usar o <code>UNION</code> para muitos padrões: </p><br><pre> <code class="plaintext hljs">MATCH (r1:Person)-[:PARENT*]-(r2:Person) RETURN DISTINCT r1.name, r2.name UNION MATCH (r1:Person)&lt;-[:PARENT*]-(:Person)-[:PARENT*]-&gt;(r2:Person) RETURN DISTINCT r1.name, r2.name UNION MATCH (r1:Person)-[:PARENT*]-&gt;(:Person)&lt;-[:PARENT*]-(r2:Person) RETURN DISTINCT r1.name, r2.name</code> </pre> <br><p>  Aqui, na primeira regra, as conexões são usadas, cuja direção não importa para nós.  Essa conexão é indicada sem uma seta, apenas um traço <code>-</code> .  A segunda e terceira regra são escritas de uma maneira óbvia e familiar. </p><br><p>  Não apresentaremos o resultado da consulta total aqui, apenas dizeremos que os pares de parentes encontrados são 132, o que é consistente com o valor calculado como o número de pares ordenados de 12. Também podemos especificar essa consulta substituindo a ocorrência da variável <code>r1</code> ou <code>r2</code> por <code>(:Person {name: "Liz"})</code> por exemplo, no entanto, no nosso caso, isso não faz muito sentido, pois todas as pessoas em nosso banco de dados são obviamente parentes. </p><br><p>  Isso conclui nossa discussão sobre a identificação de relacionamentos entre pessoas em nosso banco de dados. </p><br><p>  Por fim, considere como remover nós e links. </p><br><p>  Para excluir todas as nossas pessoas, você pode executar a solicitação: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) DELETE p</code> </pre> <br><p>  No entanto, o Neo4j nos dirá que você não pode excluir nós que possuem links. <br>  Portanto, primeiro excluímos os links e depois repetimos a remoção dos nós: </p><br><pre> <code class="plaintext hljs">MATCH (p1:Person)-[r]-&gt;(p2:Person) DELETE r</code> </pre> <br><p>  O que fizemos agora: comparou duas pessoas entre as quais há uma conexão, nomeou essa conexão como <code>r</code> depois a excluiu. </p><br><h2 id="zaklyuchenie">  Conclusão </h2><br><p>  O artigo mostra como usar os recursos da linguagem de consulta Cypher usando um exemplo simples de um gráfico social.  Em particular, examinamos como adicionar nós e links com uma consulta, como procurar dados relacionados, inclusive com links indiretos, e como atribuir rótulos aos nós.  Mais informações sobre o Cypher podem ser encontradas nos links abaixo.  Um bom ponto de partida é o "Neo4j Cypher Refcard". </p><br><p>  O Neo4j está longe de ser o único gráfico DBMS.  Entre os outros mais populares estão <a href="https://www.cayley.io/" rel="nofollow">Cayley</a> , <a href="https://dgraph.io/" rel="nofollow">Dgraph</a> com linguagem de consulta GraphQL, multi-modelo <a href="https://www.arangodb.com/" rel="nofollow">ArangoDB</a> e <a href="http://orientdb.com/" rel="nofollow">OrientDB</a> .  De particular interesse pode ser o <a href="https://www.blazegraph.com/" rel="nofollow">Blazegraph,</a> com suporte para RDF e SPARQL. </p><br><h2 id="ssylki">  Referências </h2><br><ul><li>  <a href="https://neo4j.com/developer/cypher-query-language/" rel="nofollow">Neo4j: Uma Introdução ao Cypher</a> </li><li>  <a href="https://neo4j.com/docs/cypher-refcard/current/" rel="nofollow">Cartão Cypher Neo4j</a> </li><li>  <a href="http://www.opencypher.org/" rel="nofollow">openCypher</a> </li></ul><br><h2 id="bibliografiya">  Bibliografia </h2><br><ul><li>  Robinson Jan, Weber Jim, Eifrem Emil.  Bases de dados de gráficos.  Novos recursos <br>  por trabalhar com dados relacionados / Por.  do inglês  - 2ª ed.  - M.: DMK-Press, <br>  2016 - 256 s. </li><li>  Bratko I. Programação em linguagem Prolog para inteligência artificial: <br>  trans.  do inglês  - M .: Mir, 1990 - 560 p .: doente. </li></ul><br><h2 id="posleslovie">  Posfácio </h2><br><p>  O autor do artigo conhece apenas duas empresas (ambas de São Petersburgo) que usam DBMSs gráficos para seus produtos.  Mas eu gostaria de saber quantas empresas de leitores deste artigo as utilizam em seu desenvolvimento.  Portanto, proponho participar da pesquisa.  Escreva também sobre sua experiência nos comentários, será muito interessante saber. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt482418/">https://habr.com/ru/post/pt482418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt482400/index.html">Uma seleção de fatos estatísticos divertidos # 2</a></li>
<li><a href="../pt482402/index.html">Padrão de fábrica. Exemplo de aplicação no Unity</a></li>
<li><a href="../pt482404/index.html">Mnemônicos: explorando métodos para aumentar a memória cerebral</a></li>
<li><a href="../pt482406/index.html">Principais livros do DLC para a série de ficção científica moderna</a></li>
<li><a href="../pt482410/index.html">Contemplação da grande semelhança fractal</a></li>
<li><a href="../pt482420/index.html">JavaFX - ainda não está morto</a></li>
<li><a href="../pt482426/index.html">Väterchen Frost ou seis dígitos para Habr</a></li>
<li><a href="../pt482428/index.html">Dotnetru. 2019. Resultados</a></li>
<li><a href="../pt482430/index.html">Estudar não é uma loteria, as métricas estão mentindo</a></li>
<li><a href="../pt482432/index.html">TI no sistema escolar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>