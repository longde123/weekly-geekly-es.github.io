<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💵 🥞 🔞 Mockito et comment le faire cuire 🈴 🎅🏾 👨🏿‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="À propos de l'article 


 Voici un autre guide de Mockito. Dans ce document, d'une part, j'ai essayé de décrire les fonctionnalités de cette bibliothè...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mockito et comment le faire cuire</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444982/"><h2 id="o-state">  À propos de l'article </h2><br><p>  Voici un autre guide de Mockito.  Dans ce document, d'une part, j'ai essayé de décrire les fonctionnalités de cette bibliothèque afin qu'un lecteur qui ne la connaissait pas a immédiatement la possibilité de l'utiliser pleinement, et pas seulement une idée générale de celle-ci.  D'un autre côté, je voulais le rendre suffisamment compact et structuré pour que je puisse le lire rapidement dans son intégralité et y trouver rapidement quelque chose une fois lu, mais oublié.  En général, cet article, qui me serait utile moi-même, lorsque je suis tombé sur cette bibliothèque et que je ne comprenais pas vraiment comment cela fonctionne. </p><br><p>  Je suppose que cela peut être utile pour moi maintenant - parfois j'oublie une partie de cela, et il est plus commode de rappeler le matériel non pas selon la documentation officielle ou les articles d'autres personnes, mais selon mon propre, disons, synopsis.  En même temps, j'ai essayé de construire le texte de manière à ce qu'il soit pratique principalement pour explorer Mockito à partir de zéro, et à certains endroits, j'analyse en détail des choses apparemment évidentes - qui n'étaient pas toutes évidentes pour moi dès le début. </p><a name="habracut"></a><br><h2 id="soderzhanie">  Contenu: </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mockito: qu'est-ce que c'est et pourquoi est-il nécessaire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Environnement, versions et animal expérimental</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moquer et espionner</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gestion des comportements</a> <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Définition des conditions d'appel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Définition des résultats des appels</a> </li></ol></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Suivi des appels de méthode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mock objets en tant que valeurs de champ et annotations Mockito</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comportement de restauration aux sessions par défaut et Mockito</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quoi d'autre?</a> </li></ol><br><h2 id="mockito-chto-eto-takoe-i-zachem-nuzhno">  Mockito: qu'est-ce que c'est et pourquoi est-il nécessaire </h2><br><p>  En bref, Mockito est un framework stub. </p><br><p>  Comme vous le savez, lors du test de code (principalement des tests unitaires, mais pas seulement), l'élément testé doit souvent fournir des instances de classes qu'il doit utiliser lors de son fonctionnement.  Cependant, ils ne doivent souvent pas être pleinement fonctionnels - au contraire, ils doivent se comporter de manière strictement définie, de sorte que leur comportement soit simple et complètement prévisible.  Ils sont appelés talons.  Pour les obtenir, vous pouvez créer des implémentations de test alternatives d'interfaces, hériter des classes nécessaires avec redéfinition des fonctionnalités, etc., mais tout cela est assez gênant, redondant et semé d'erreurs.  Une solution plus pratique dans tous les sens est des cadres spécialisés pour créer des talons.  L'un d'entre eux (et peut-être le plus célèbre pour Java) est Mockito. </p><br><p> Mockito vous permet de créer avec une seule ligne de code le soi-disant faux (quelque chose comme la base du talon souhaité) de n'importe quelle classe.  Pour une telle maquette, immédiatement après sa création, un certain comportement par défaut est caractéristique (toutes les méthodes renvoient des valeurs précédemment connues - généralement c'est <code>null</code> ou <code>0</code> ).  Vous pouvez redéfinir ce comportement comme vous le souhaitez, le contrôler avec le bon degré de détail, etc.  En conséquence, la maquette devient un talon avec les propriétés requises.  Ci-dessous, je vais discuter en détail de la façon de procéder. </p><br><p>  Je note que la simulation peut également être créée pour ces classes, dont la nouvelle instance ne peut pas simplement créer, en particulier, des classes avec des constructeurs exclusivement privés tels que les classes singleton et utilitaires, et avec une configuration minimale du cadre et des énumérations. </p><br><h2 id="okruzhenie-versii-i-podopytnoe-zhivotnoe">  Environnement, versions et animal expérimental </h2><br><p>  Lors de la rédaction de cet article, j'ai utilisé: </p><br><ul><li>  Mockito: 'org.mockito: mockito-core: 2.24.0' (dernière version stable au moment de la rédaction) </li><li>  TestNG: 'org.testng: testng: 6.14.3' comme cadre de test </li><li>  AssertJ: 'org.assertj: assertj-core: 3.11.1' comme outil de validation </li><li>  Lombok: 'org.projectlombok: lombok: 1.18.6' (juste pour plus de commodité) </li><li>  Java 8 </li></ul><br><p>  Pour mes expériences inhumaines, j'ai écrit cette interface d'un service qui donne accès à certaines données. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; dataToSave)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String id, Supplier&lt;String&gt; calculateIfAbsent)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataListByIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; idList)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataByRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DataSearchRequest request)</span></span></span></span>; }</code> </pre> <br><p>  Et ce code (que ce soit pour des raisons d'ordre) de la classe de demande est passé à la dernière des méthodes d'interface. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSearchRequest</span></span></span><span class="hljs-class"> </span></span>{ String id; Date updatedBefore; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length; }</code> </pre> <br><p>  Les unités de données sont identifiées par ID et ont quelques caractéristiques supplémentaires, mais directement sous la forme dans laquelle elles sont retournées par le service, ce sont des chaînes et non des objets plus complexes.  Je ne manque rien d'important, et les exemples sont plus simples et plus clairs. </p><br><p>  Je vais le noter tout de suite: dans les exemples ci-dessous, j'appelle directement les méthodes redéfinies de mes faux objets pour plus de clarté, mais avec de vrais tests, l'idée n'est pas du tout!  Dans ce test, je ferais systématiquement ce qui suit: </p><br><ul><li>  configuré la maquette de mon service au besoin; </li><li>  passé (très probablement, par le constructeur) à une instance d'une autre classe l'utilisant (supposons qu'il contient une sorte de logique métier utilisant les données fournies par le <code>DataService</code> ), que je testerais en fait; </li><li>  activé la fonctionnalité de la classe testée et contrôlé les résultats; </li><li>  si nécessaire, je contrôlerais le nombre et l'ordre des appels aux méthodes de ma maquette, qui auraient dû être appelées par la classe testée à la suite de l'action précédente. </li></ul><br><h2 id="mock-i-spy">  moquer et espionner </h2><br><p>  La classe centrale de Mockito, à travers laquelle il est censé accéder à la plupart des fonctionnalités, est, en fait, une classe appelée <code>Mockito</code> (il y a aussi la classe <code>BDDMockito</code> qui offre à peu près les mêmes possibilités sous une forme plus adaptée au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BDD</a> , mais ici je ne m'y attarderai pas) .  L'accès à la fonctionnalité est implémenté via ses méthodes statiques. </p><br><p>  Pour créer une maquette de la classe <code>DataService</code> , je dois juste faire ce qui suit: </p><br><pre> <code class="java hljs">DataService dataServiceMock = Mockito.mock(DataService.class);</code> </pre> <br><p>  Terminé - J'ai obtenu une instance de la classe dont j'ai besoin.  Il sera accepté par n'importe quelle méthode ou constructeur qui nécessite un paramètre de ce type (par exemple, le constructeur de la classe que je veux tester).  Même si un contrôle de dépendance l'attend plus tard, il le transmettra: non seulement <code>instanceof DataService</code> renverra <code>true</code> , mais aussi <code>dataServiceMock.getClass()</code> - à savoir <code>DataService.class</code> .  D'une manière formelle, distinguer par programmation un objet simulé d'un objet ordinaire se révèle être une tâche plutôt difficile, ce qui est logique: après tout, le premier est destiné à être indiscernable du second.  Cependant, Mockito a un outil pour cela - la méthode <code>Mockito.mockingDetails</code> .  En lui passant un objet arbitraire, j'obtiens un objet de la classe <code>MockingDetails</code> .  Il contient des informations sur ce que cet objet représente du point de vue de Mockito: qu'il s'agisse de maquette, d'espion (voir ci-dessous), comment il a été utilisé, comment il a été créé, etc. </p><br><p>  Il convient de noter en particulier la situation lorsque j'essaie de créer un mock pour la classe finale ou une instance fictive d'énumération ou de remplacer le comportement de la méthode finale.  Dans ce cas, avec le comportement par défaut de Mockito, le code ci-dessus refuse de fonctionner, citant précisément cette circonstance.  Cependant, cela peut être changé - il suffit de créer dans le projet (avec le périphérique standard de l'arborescence du répertoire du projet) le fichier <code>test/resources/mockito-extensions/org.mockito.plugins.MockMaker</code> et entrez la ligne dedans: </p><br><pre> <code class="plaintext hljs">mock-maker-inline</code> </pre> <br><p>  Après cela, vous pouvez imiter les classes et énumérations finales de la manière habituelle, ainsi que remplacer les méthodes finales. </p><br><p>  La maquette que j'ai eue en action est aussi impropre que possible: pas une seule méthode n'aura d'effet sur quoi que ce soit, et la valeur retournée sera <code>null</code> pour les types d'objets et <code>0</code> pour les types primitifs.  Remarque: si la méthode retourne une collection, la maquette par défaut ne renverra pas les <code>null</code> , mais les instances de collection vides.  Par exemple, pour <code>List</code> cela se révélera être une <code>LinkedList</code> vide <code>LinkedList</code> indépendamment de ce que la vraie méthode aurait dû retourner.  Mais comme les valeurs des tableaux, primitifs ou objet, j'obtiens <code>null</code> .  Le comportement par défaut (et pas seulement) peut être modifié à l'aide des fonctionnalités de la classe <code>MockSettings</code> , mais cela est rarement nécessaire. </p><br><p>  D'une manière ou d'une autre, dans la plupart des cas, je n'aurai pas besoin du comportement par défaut, et dans la section suivante, j'analyserai en détail comment définir ce qui est requis à la place. </p><br><p>  Cependant, que se passe-t-il si je souhaite utiliser un objet de classe réel avec les fonctionnalités disponibles en tant que stub, redéfinissant le fonctionnement d'une partie seulement de ses méthodes?  Si nous parlons de tests unitaires, un tel besoin indique généralement (mais pas toujours) que le projet ne convient pas à la conception et, en principe, ce n'est pas recommandé.  Cependant, il existe des situations où cela, pour une raison quelconque, ne peut être évité.  Pour ce cas, Mockito a le soi-disant espion, "espions".  Contrairement aux maquettes, ils peuvent être créés en fonction de la classe et de l'objet fini: </p><br><pre> <code class="java hljs">DataService dataServiceSpy = Mockito.spy(DataService.class); <span class="hljs-comment"><span class="hljs-comment">// or DataService dataService = new DataService(); dataServiceSpy = Mockito.spy(dataService);</span></span></code> </pre> <br><p>  Lors de la création d'un espion basé sur une classe, si son type est une interface, un objet maquette normal sera créé, et si le type est une classe, alors Mockito essaiera de créer une instance en utilisant le constructeur par défaut (sans paramètres).  Et seulement s'il n'y a pas un tel constructeur, une erreur se produira et le test ne fonctionnera pas. </p><br><p>  Le comportement des objets espions par défaut est identique au comportement d'une instance de classe régulière, mais ils me donnent les mêmes possibilités que les objets fictifs: ils me permettent de redéfinir leur comportement et de surveiller leur utilisation (voir les sections suivantes).  Un point important: spy n'est pas un wrapper autour de l'instance sur laquelle il a été créé!  Par conséquent, l'appel de la méthode spy n'affectera pas l'état de l'instance d'origine. </p><br><h2 id="upravlenie-povedeniem">  Gestion des comportements </h2><br><p>  Donc, sur la façon de se moquer ou d'espionner pour faire ce dont j'ai besoin.  De plus, j'écrirai toujours simplement «simulacre» partout - cela signifiera «simulacre ou espion», sauf indication contraire expresse. </p><br><p>  En général, le contrôle du comportement d'un objet simulé se résume à un concept évident: quand une maquette a été traitée de cette manière (c'est-à-dire qu'une méthode avec tel ou tel argument a été appelée), elle devrait répondre de telle ou telle manière.  Ce concept a deux implémentations au sein de la classe Mockito - la principale, recommandée par les développeurs pour une utilisation dans la mesure du possible, et l'autre, utilisée lorsque la principale ne convient pas. </p><br><p>  L'implémentation principale est basée sur la méthode <code>Mockito.when</code> .  Cette méthode prend comme «paramètre» un appel à la méthode redéfinie de l'objet maquette (de cette façon l'action détectée est fixée) et retourne un objet de type <code>OngoingStubbing</code> , qui permet d'appeler l'une des méthodes de la famille <code>Mockito.then...</code> (c'est ainsi que la réaction à cet effet est définie).  Dans l'ensemble, dans le cas le plus simple, cela ressemble à ceci: </p><br><pre> <code class="java hljs">List&lt;String&gt; data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); data.add(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>); Mockito.when(dataService.getAllData()).thenReturn(data);</code> </pre> <br><p>  Après cette opération, en appelant la méthode <code>getAllData()</code> sur l'objet <code>getAllData()</code> , j'obtiens l'objet spécifié dans la première ligne de la liste. </p><br><p>  Ici, l'intuition familière "orientée objet" peut donner une sorte de dysfonctionnement, donc cela mérite d'être approfondi.  Du point de vue de la syntaxe Java, la valeur transmise à la méthode <code>when</code> tant que paramètre est, bien sûr, la valeur renvoyée par la méthode substituée.  Pour mock, c'est une valeur vide; pour spy, c'est la valeur retournée par la méthode de l'objet réel.  Mais grâce à l'action magique «sous le capot» de Mockito, la méthode <code>when</code> ne fonctionnera normalement (et ne plantera pas lorsqu'elle sera lancée avec une erreur) que si l'appel de la méthode mock-object est entre crochets après <code>when</code> . </p><br><p>  Une idéologie similaire fonctionne souvent lors de la définition du comportement d'un mockito dans un Mockito: en appelant une méthode (d'un objet <code>Mockito</code> ou d'une classe du <code>Mockito</code> ), j'essaie de ne pas obtenir la valeur retournée par celui-ci, mais en quelque sorte d'influencer l'appel possible de la méthode de l'objet <code>Mockito</code> je travaille: spécifier ses limites, fixer le résultat, établir l'observation de ses défis, etc.  Cela semble un peu brumeux, je l'avoue, et à la première collision, cela semble étrange, mais, après l'avoir compris, vous commencez bientôt à ressentir cette approche comme tout à fait naturelle dans le contexte du travail avec des talons. </p><br><p>  Une autre implémentation de la liaison de la condition et du résultat de l'appel est les méthodes de la famille <code>Mockito.do...</code>  Ces méthodes vous permettent de définir le comportement en commençant par le résultat de l'appel et de renvoyer un objet de la classe <code>Stubber</code> , avec lequel vous pouvez déjà définir la condition.  La même liaison que ci-dessus effectuée de cette manière ressemble à ceci: </p><br><pre> <code class="java hljs">List&lt;String&gt; data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); data.add(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>); Mockito.doReturn(data).when(dataService).getData()</code> </pre> <br><p>  Quelle est la différence, pourquoi la liaison via <code>Mockito.when</code> est considérée comme préférable et quand vous devez encore utiliser les méthodes de <code>Mockito.do...</code> ?  Remarque: dans la première implémentation, lors de la définition du comportement de la méthode (dans ce cas, <code>getAllData()</code> ), l'appel à la version qui n'a pas encore été redéfinie est effectué en premier, puis seulement, dans les entrailles de Mockito, un remplacement se produit.  Dans le second cas, un tel appel ne se produit pas - la méthode <code>Stubber.when</code> passée directement à la méthode <code>Stubber.when</code> , et un objet du même type, mais de nature différente, est renvoyé à partir de la méthode renvoyée par cette méthode.  Cette différence détermine tout.  La liaison via <code>Mockito.do...</code> ne contrôle pas au moment de la compilation quelle méthode redéfinissable j'appellerai et si elle est compatible avec le type avec la valeur de retour donnée.  Par conséquent, généralement <code>Mockito.when</code> préférable - il ne peut y avoir aucune erreur avec cela.  Mais il peut y avoir des cas où je veux éviter d'appeler une méthode redéfinie - pour une maquette nouvellement créée, un tel appel est tout à fait acceptable, mais si j'ai déjà redéfini cette méthode ou traité avec un espion, cela peut être indésirable, et lever une exception ne permettra pas du tout la redéfinition nécessaire .  Et ici, la liaison via <code>Mockito.do...</code> vient à la <code>Mockito.do...</code> </p><br><p>  Une autre situation où vous ne pouvez pas vous passer des méthodes <code>Mockito.do...</code> est la <code>Mockito.do...</code> la méthode renvoyant <code>void</code> : le paramètre <code>Mockito.when</code> attente ne peut pas fonctionner avec une telle méthode.  <code>Mockito.doReturn</code> , bien sûr, sans travail, mais il y a <code>Mockito.doThrow</code> , <code>Mockito.doAnswer</code> et rarement assez <code>Mockito.doNothing</code> . </p><br><p>  Ensuite, je considérerai un peu plus en détail comment définir les conditions et les résultats des appels.  Je ne considérerai que la liaison via <code>Mockito.when</code> - une autre méthode est presque complètement similaire dans la manipulation. </p><br><h3 id="zadanie-usloviy-vyzova">  Définition des conditions d'appel </h3><br><p>  L'exemple ci-dessus concerne une méthode sans paramètres, et la condition d'appel associée est possible une chose - le fait de l'appel.  Dès que les paramètres apparaissent, la situation devient plus compliquée.  Au minimum, pour appeler une méthode dont je définis le comportement, je dois lui passer quelque chose.  Mais une autre chose est plus importante: il peut s'avérer que je ne veux pas toujours obtenir la réaction donnée, mais seulement lorsque je l'appelle avec des paramètres qui répondent à certaines exigences.  <code>DataService</code> a cette méthode: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataItemById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code... }</span></span></code> </pre> <br><p>  Si je dois définir une réponse à tout appel à cette méthode, quels que soient les arguments, je dois utiliser la méthode <code>Mockito.any</code> : </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataItemById(any())) .thenReturn(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>);</code> </pre> <br><p>  Si je veux que mock ne réponde qu'à une certaine valeur de l'argument, vous pouvez utiliser cette valeur directement ou les méthodes de <code>Mockito.eq</code> (si nous parlons d'équivalence) ou <code>Mockito.same</code> (si une comparaison de liens est requise): </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataItemById(<span class="hljs-string"><span class="hljs-string">"idValue"</span></span>)) .thenReturn(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// or Mockito.when(dataService.getDataItemById(Mockito.eq("idValue"))) .thenReturn("dataItem");</span></span></code> </pre> <br><p>  Et si je veux que l'argument réponde à certaines exigences, il existe un certain nombre de méthodes statiques spécialisées pratiques de la même classe <code>Mockito</code> (par exemple, les chaînes peuvent être vérifiées pour le contenu au début ou à la fin d'une certaine séquence de caractères, la correspondance de modèle, etc.).  Il existe également une méthode générale Mockito.argThat (et ses analogues pour les types primitifs) qui accepte l'implémentation de l'interface fonctionnelle ArgumentMatcher: </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataById( Mockito.argThat(arg -&gt; arg == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || arg.length() &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>))) .thenReturn(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>);</code> </pre> <br><p>  Les classes <code>ArgumentMatchers</code> et <code>AdditionalMatchers</code> vous permettent de travailler avec certaines implémentations prêtes à l'emploi de cette interface.  Par exemple, <code>AdditionalMatchers.or</code> et <code>AdditionalMatchers.and</code> vous permettent de combiner d'autres matchers (remarque: les méthodes statiques de ces classes ne renvoient pas d'instances de matchers, mais y accèdent uniquement!) </p><br><p>  Pour la même méthode, vous pouvez définir le comportement plusieurs fois avec des exigences différentes pour les arguments, et tous les modèles de comportement définis de cette manière agiront simultanément.  Bien sûr, dans certains cas, ils peuvent se croiser - disons, je demanderai de retourner un résultat lorsque la valeur <code>int</code> du paramètre est inférieure à 5 et l'autre lorsque la valeur paire est reçue.  Dans ce cas, le comportement spécifié ultérieurement a priorité.  Par conséquent, lors de la définition de modèles de comportement complexes, vous devez commencer par les exigences les plus faibles (dans la limite - <code>any()</code> ) et ensuite passer à des exigences plus spécifiques. </p><br><p>  Lorsque vous travaillez avec des méthodes avec plusieurs arguments, les exigences spécifiées sont combinées conformément au ET logique, c'est-à-dire que pour obtenir le résultat spécifié, CHAQUE des arguments doit répondre à l'exigence indiquée.  Je n'ai pas trouvé de moyen de définir une manière arbitraire de les combiner, bien qu'il existe peut-être. </p><br><p>  De plus, lors de la spécification du comportement d'une telle méthode, on ne peut pas combiner les méthodes statiques de <code>Mockito</code> et le transfert direct de valeurs.  Utilisez <code>Mockito.eq</code> ou <code>Mockito.same</code> . </p><br><h3 id="zadanie-rezultatov-vyzova">  Définition des résultats des appels </h3><br><p>  Après l'appel de la méthode de l'objet factice, l'objet doit répondre à l'appel.  Les principales conséquences possibles sont le retour du résultat et la levée d'une exception, et c'est précisément sur ces options que la boîte à outils Mockito est principalement conçue. </p><br><p>  Dans le cas le plus simple déjà montré ci-dessus, la réponse à l'appel est de renvoyer une valeur.  Je vais redonner son code: </p><br><pre> <code class="java hljs">List&lt;String&gt; data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); data.add(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>); Mockito.when(dataService.getAllData()).thenReturn(data);</code> </pre> <br><p>  Remarque: vous ne pouvez renvoyer qu'un objet; il n'y a pas de méthodes distinctes pour les primitives.  Par conséquent, si la méthode renvoie une valeur primitive, dans une telle situation, un / boxing se produira.  Dans la plupart des cas, cela n'interfère pas, mais si le compilateur pense le contraire, vous devrez en quelque sorte être d'accord avec lui ... ou accepter ses avertissements. </p><br><p>  Lancer des exceptions n'est pas plus difficile: </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"invalidId"</span></span>)) .thenThrow(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException());</code> </pre> <br><p>  Il existe un autre moyen: vous pouvez créer un objet d'exception et le lancer directement, ou vous pouvez fournir à Mockito uniquement une classe d'exception afin qu'il soit créé automatiquement: </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"invalidId"</span></span>)) .thenThrow(IllegalArgumentException.class);</code> </pre> <br><p>  Dans les deux cas, la syntaxe vous permet d'utiliser et de vérifier les exceptions, cependant, Mockito ne vous permettra pas d'exécuter un tel test si le type d'exception ne correspond pas à la méthode que je souhaite forcer à lever cette exception. </p><br><p>  Lorsque vous utilisez une classe comme paramètre, les constructeurs (même sans paramètres), ainsi que l'initialisation directe des champs, sont ignorés - l'objet est créé en les contournant (après tout, c'est Mockito!), De sorte que tous les champs de l'exception levée seront <code>null</code> .  Par conséquent, si le contenu de l'exception vous intéresse (par exemple, un champ de <code>type</code> qui a une valeur par défaut), vous devrez abandonner cette méthode et créer des exceptions manuellement. </p><br><p>  Ces options de réaction conviennent si, en réponse à un appel avec des conditions données, vous devez toujours renvoyer une certaine valeur, toujours la même valeur du résultat ou toujours lever la même exception, et dans la plupart des cas, ces capacités sont tout à fait suffisantes.  Mais que se passe-t-il si davantage de flexibilité est requise?  Supposons que ma méthode accepte une collection de valeurs et renvoie une autre collection de valeurs associée à la première à une (par exemple, obtenir une collection d'objets de données par l'ensemble de leurs ID), et que je souhaite utiliser cet objet simulé à plusieurs reprises avec différents ensembles d'entrée dans le test données, obtenant à chaque fois le résultat correspondant.  Vous pouvez, bien sûr, décrire séparément la réaction à chaque ensemble spécifique de paramètres, mais il existe une solution plus pratique - la méthode <code>Mockito.thenAnswer</code> , alias <code>Mockito.then</code> .  Il accepte une implémentation de l'interface fonctionnelle <code>Answer</code> , dont la seule méthode est de recevoir un objet de la classe <code>InvocationOnMock</code> .  À partir de ce dernier, je peux demander les paramètres de l'appel de méthode (un par un ou tous à la fois sous forme de tableau) et agir avec eux, à ma guise.  Par exemple, vous pouvez obtenir une valeur qui lui correspond pour chacun des éléments de ma collection, en former une nouvelle collection et la renvoyer (remarque: le résultat souhaité est simplement renvoyé, mais pas écrit dans un champ de l'objet paramètre, comme vous pouvez vous y attendre): </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataByIds(Mockito.any())) .thenAnswer(invocation -&gt; invocation .&lt;List&lt;String&gt;&gt;getArgument(<span class="hljs-number"><span class="hljs-number">0</span></span>).stream() .map(id -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (id) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"a"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"dataItemA"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"b"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"dataItemB"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }) .collect(Collectors.toList()));</code> </pre> <br><p>  Idéologiquement, cela revient à écrire un modèle de méthode réelle: obtenir des paramètres, traiter, retourner un résultat.          -  ,    - ,      ,     ,    mock-    . </p><br><p>     <code>Answer</code> ,     , — , <code>AnswersWithDelay</code> , <code>ReturnsElementsOf</code>  . . </p><br><p>  :  <code>InvocationOnMock</code>   —       <code>Object[]</code> ,  generic-. </p><br><p>        — <code>thenCallRealMethod</code> .    .     mock-,    spy-.   mock   ,      ,  -   <code>null</code> .  spy   <code>thenCallRealMethod</code>     spy  ;    ,     -      . </p><br><p>        <code>thenAnswer</code> :  <code>InvocationOnMock</code>   <code>callRealMethod()</code> —   ,   ""    -  . </p><br><p>    <code>OngoingStubbing</code>    <code>OngoingStubbing</code> ,  ,   ,     .            ,   .  <code>thenReturn</code>  <code>thenThrow</code>   ,  varargs.       . </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)) .thenReturn(<span class="hljs-string"><span class="hljs-string">"valueA1"</span></span>, <span class="hljs-string"><span class="hljs-string">"valueA2"</span></span>) .thenThrow(IllegalArgumentException.class);</code> </pre> <br><p>         <code>"valueA1</code> ,  — <code>"valueA2</code> ( ),   (  )    <code>IllegalArgumentException</code> . </p><br><h2 id="slezhenie-za-vyzovami-metodov">     </h2><br><p>        :          (mock'    ),     .   ,     :   ,          ,       .      <code>verify</code> . </p><br><p>  ,           ,  : </p><br><pre> <code class="java hljs">Mockito.verify(dataService).getDataById(Mockito.any());</code> </pre> <br><p>      ,            <code>getDataById</code> ,  ,           . ,             Mockito,      <code>when</code> ,   ,  ,         mock-. , ,  ,      <code>when</code>  , —      mock',       (. ). </p><br><p>           : </p><br><pre> <code class="plaintext hljs">Mockito.verify(dataService, Mockito.times(1)) .getDataById(Mockito.any());</code> </pre> <br><p>           <code>Mockito.times</code> ;       <code>Mockito.never</code> .    <code>Mockito.atLeast</code> (  <code>Mockito.atLeastOnce</code>   1)  <code>Mockito.atMost</code> ,       ,    <code>Mockito.only</code> , ,         mock-  (. .     ). </p><br><p>  ,         <code>Mockito</code> ,     <code>VerificationAfterDelay</code>  <code>VerificationWithTimeout</code> ,    <code>Mockito.after</code>  <code>Mockito.timeout</code> .  Par exemple: </p><br><pre> <code class="plaintext hljs">Mockito.verify(dataService, Mockito.after(1000).times(1)) .getDataById(Mockito.any());</code> </pre> <br><p>    ,    mock   ,      ,              ,       .        .   <code>after</code>  <code>timeout</code>  ,          ,    ,    —   ,     .  ,   <code>timeout</code>         —       .   <code>VerificationWithTimeout</code>   <code>never</code>  <code>atMost</code> :         . </p><br><p>  ,             <code>Mockito.any()</code> .          ,   ,     —    Mockito       ,    ,     . Mock-     ,        ,   , , : </p><br><pre> <code class="java hljs">dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"b"</span></span>); Mockito.verify(dataService, Mockito.times(<span class="hljs-number"><span class="hljs-number">2</span></span>)).getDataById(Mockito.any()); Mockito.verify(dataService, Mockito.times(<span class="hljs-number"><span class="hljs-number">1</span></span>)).getDataById(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); Mockito.verify(dataService, Mockito.never()).getDataById(<span class="hljs-string"><span class="hljs-string">"c"</span></span>); dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"c"</span></span>); Mockito.verify(dataService, Mockito.times(<span class="hljs-number"><span class="hljs-number">1</span></span>)).getDataById(<span class="hljs-string"><span class="hljs-string">"c"</span></span>); Mockito.verifyNoMoreInteractions(dataService);</code> </pre> <br><p>      <code>verifyNoMoreInteractions</code> (  <code>verifyZeroInteractions</code> ) —    -  (            <code>verify</code> )    mock- —    .  :   varargs,     ,     ,         <strong> </strong> ! </p><br><p>       ,   ,      ,     .   ,    <code>InOrder</code> : </p><br><pre> <code class="java hljs">InOrder inOrder = Mockito.inOrder(dataService);</code> </pre> <br><p>     varargs;     —    mock-   ,    <code>InOrder</code>                .     <code>verify</code>    ,   <code>Mockito.verify</code> : </p><br><pre> <code class="java hljs">inOrder.verify(dataService, times(<span class="hljs-number"><span class="hljs-number">2</span></span>)).saveData(any()); inOrder.verify(dataService).getData();</code> </pre> <br><p>       ,         <code>saveData</code> , <strong> </strong>  — <code>getData</code> .  ,   <code>InOrder</code>    ,      —     . </p><br><p>       ,   ,       — , .      -      ,    ,      —  ,     ,    .     <code>ArgumentCaptor</code>    <code>capture()</code> .  Par exemple: </p><br><pre> <code class="java hljs">DataSearchRequest request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataSearchRequest(<span class="hljs-string"><span class="hljs-string">"idValue"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(System.currentTimeMillis()), <span class="hljs-number"><span class="hljs-number">50</span></span>); dataService.getDataByRequest(request); ArgumentCaptor&lt;DataSearchRequest&gt; requestCaptor = ArgumentCaptor.forClass(DataSearchRequest.class); Mockito.verify(dataService, times(<span class="hljs-number"><span class="hljs-number">1</span></span>)).getDataByRequest(requestCaptor.capture()); assertThat(requestCaptor.getAllValues()).hasSize(<span class="hljs-number"><span class="hljs-number">1</span></span>); DataSearchRequest capturedArgument = requestCaptor.getValue(); assertThat(capturedArgument.getId()).isNotNull(); assertThat(capturedArgument.getId()).isEqualTo(<span class="hljs-string"><span class="hljs-string">"idValue"</span></span>); assertThat(capturedArgument.getUpdatedBefore()).isAfterYear(<span class="hljs-number"><span class="hljs-number">1970</span></span>); assertThat(capturedArgument.getLength()).isBetween(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br><p> <code>ArgumentCaptor</code>       ,      <strong> </strong> ,   <code>ArgumentCaptor</code>  . <code>getValue()</code>    , <code>getAllValues()</code> —     .   ,         ,   . </p><br><h2 id="mock-obekty-kak-znacheniya-poley-i-annotacii-mockito"> Mock-      Mockito </h2><br><p>      ,     mock-   ,      —     <code>@Mock</code>   -       : </p><br><pre> <code class="java hljs">MockitoAnnotations.initMocks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);</code> </pre> <br><p> (  ,       mock',       ) </p><br><p>  spy   <code>@Spy</code> —     <code>@Mock</code> …   spy   ,      , ?          ,      —  spy     . </p><br><p>   <code>@Captor</code>    <code>ArgumentCaptor</code> —   , ,    . </p><br><p>   <code>@InjectMocks</code> .       -  Mockito,          .       mock-   ,   .        ,    .  -     ,     <code>null</code> ,   -     .         (      )  dependency injection. </p><br><h2 id="otkat-povedeniya-k-defoltnomu-i-sessii-mockito">       Mockito </h2><br><p>         ,  :   mock (spy, argument captor...),   ,    , .    ,  mock' —    ,    . JUnit           ,      ,    TestNG   —       . , ,   mock'    ,     ,   ,         . .  ,  ,  —  ,          . </p><br><p>   ,             mock-    .  TestNG     <code>@BeforeMethod</code> ( <code>@AfterMethod</code>  ).           mock'   ,        ,           (    JUnit —      <code>@Before</code> ). </p><br><p>   ,     , —   <code>Mockito.reset</code>  <code>Mockito.clearInvocations</code> .   varargs,      mock'.      ,    .     :     (,              )  ,   /   mock'    , —       .     ,    mock'       . .      , ,             . </p><br><p>       (,  ) —     <code>MockitoAnnotations.initMocks(this);</code>  .    ""  ,   Mockito. </p><br><p>    —     Mockito.    .     mock- ,          ( mock'      ).          ,      <code>MockitoSession</code> ,           .     TestNG: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> DataService dataService; MockitoSession session; <span class="hljs-meta"><span class="hljs-meta">@BeforeMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ session = Mockito.mockitoSession() .initMocks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .startMocking(); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code using the dataService field } @AfterMethod public void afterMethod() { session.finishMocking(); }</span></span></code> </pre> <br><p>  ,        —  ,  "" (,     )  ,   . </p><br><h2 id="chto-eschyo">  ? </h2><br><p>      Mockito:  mock  spy-,        .      ,       .  ,  , : </p><br><ul><li>  Mockito   mock-   <code>MockSettings</code> (      — ,   mock'    -  ); </li><li>     mock-,   <code>MockingDetails</code> ; </li><li>   <code>BDDMockito</code>   <code>Mockito</code> ; </li><li>     (    JUnit       Mockito,     ). </li></ul><br><p>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  Mockito</a> .           javadoc'  <code>Mockito</code> . </p><br><p> , ,  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444982/">https://habr.com/ru/post/fr444982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444972/index.html">Architecture GPU Intel Gen11 et carte graphique discrète d'Intel</a></li>
<li><a href="../fr444974/index.html">Cryptographie en Java. Classe MessageDigest</a></li>
<li><a href="../fr444976/index.html">Quester - Plate-forme pour créer et terminer des quêtes (Beta)</a></li>
<li><a href="../fr444978/index.html">Les autorités de l'UE ont infligé une amende de 1,7 milliard de dollars à Google pour avoir bloqué les publicités de ses concurrents</a></li>
<li><a href="../fr444980/index.html">Analyse d'une erreur critique dans l'algorithme de chiffrement KIB SEARCHINFORM</a></li>
<li><a href="../fr444984/index.html">D'où viennent les photos pour tester les systèmes de reconnaissance faciale?</a></li>
<li><a href="../fr444986/index.html">IETF approuve ACME - Il s'agit de la norme pour travailler avec des certificats SSL</a></li>
<li><a href="../fr444992/index.html">Erreurs intégrées au système: leur rôle dans les statistiques</a></li>
<li><a href="../fr444994/index.html">À propos des lecteurs et de leur utilisation sur les ordinateurs modernes</a></li>
<li><a href="../fr444996/index.html">Redis Streams en tant que structure de données propre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>