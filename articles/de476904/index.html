<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏾 👂🏾 🤳🏾 Eine weitere Scheinbibliothek 🆗 🌯 🎷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag. Ich beschäftige mich mit Testautomatisierung. Wie alle Automatisierungstechniker habe ich eine Reihe von Bibliotheken und Tools, die ich no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine weitere Scheinbibliothek</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476904/"><p> Guten Tag.  Ich beschäftige mich mit Testautomatisierung.  Wie alle Automatisierungstechniker habe ich eine Reihe von Bibliotheken und Tools, die ich normalerweise zum Schreiben von Tests auswähle.  Es gibt jedoch Situationen, in denen keine der bekannten Bibliotheken das Problem mit dem Risiko lösen kann, dass Autotests instabil oder zerbrechlich werden.  In diesem Artikel möchte ich Ihnen sagen, wie die scheinbar übliche Aufgabe, mock'ov zu verwenden, mich veranlasste, mein Modul zu schreiben.  Ich möchte auch meine Entscheidung teilen und Feedback hören. </p><a name="habracut"></a><br><h1>  App </h1><br><p>  Einer der notwendigen Sektoren im Finanzsektor ist die Prüfung.  Die Daten müssen regelmäßig überprüft werden (Abgleich).  In diesem Zusammenhang ist die von mir getestete Anwendung erschienen.  Um nicht über etwas Abstraktes zu sprechen, stellen wir uns vor, dass unser Team eine Anwendung für die Verarbeitung von Anwendungen aus Instant Messenger entwickelt.  Für jede Anwendung muss in elasticsearch ein entsprechendes Ereignis angelegt werden.  Die Verifizierungsanwendung wird unsere Überwachung sein, dass Anwendungen nicht übersprungen werden. </p><br><p>  Stellen Sie sich vor, wir haben ein System mit folgenden Komponenten: </p><br><ol><li>  Konfigurationsserver.  Für den Benutzer ist dies ein einziger Einstiegspunkt, an dem er nicht nur die Anwendung zur Überprüfung, sondern auch andere Komponenten des Systems konfiguriert. </li><li>  Verifizierungsantrag. </li><li>  Daten aus der Bewerbung verarbeiten Bewerbungen, die in elasticsearch gespeichert sind. </li><li>  Referenzdaten.  Das Datenformat hängt von dem Messenger ab, in den die Anwendung integriert ist. </li></ol><br><h1>  Herausforderung </h1><br><p>  Das Testen der Automatisierung sieht in diesem Fall ganz einfach aus: </p><br><ol><li>  Umgebungsvorbereitung: <br><ul><li>  Elasticsearch wird mit minimaler Konfiguration installiert (unter Verwendung von msi und der Befehlszeile). </li><li>  Eine Verifizierungsanwendung ist installiert. </li></ul></li><li>  Testausführung: <br><ul><li>  Eine Bestätigungsanwendung ist konfiguriert. </li><li>  Elasticsearch wird mit Testdaten für den entsprechenden Test gefüllt (wie viele Bewerbungen wurden bearbeitet). </li><li>  Die Anwendung empfängt "Referenz" -Daten vom Messenger (wie viele Anwendungen waren angeblich tatsächlich). </li><li>  Das Urteil des Antrags wird überprüft: Anzahl der erfolgreich verifizierten Anträge, Anzahl der fehlenden Anträge usw. </li></ul></li><li>  Die Umwelt reinigen. </li></ol><br><p>  Das Problem ist, dass wir die Überwachung testen. Zum Konfigurieren benötigen wir jedoch Daten vom Konfigurationsserver.  Erstens ist das Installieren und Konfigurieren eines Servers für jeden Lauf zeitaufwändig (es hat beispielsweise eine eigene Basis).  Zweitens möchte ich Anwendungen isolieren, um die Lokalisierung von Problemen beim Auffinden eines Fehlers zu vereinfachen.  Am Ende entschied man sich für die Verwendung von Mock. </p><br><p>  Dies kann die Frage aufwerfen: "Wenn wir den Server immer noch verspotten, können wir möglicherweise keine Zeit damit verbringen, Elasticsearch zu installieren und zu füllen, sondern die Verspottung zu ersetzen?"  Sie müssen sich jedoch immer daran erinnern, dass die Verwendung von Mock Flexibilität bietet, aber eine Verpflichtung hinzufügt, die Relevanz des Mock-Verhaltens zu überwachen.  Deshalb habe ich mich geweigert, elasticsearch zu ersetzen: es ist einfach zu installieren und zu füllen. </p><br><h1>  Erster Spott </h1><br><p> Der Server sendet die Konfiguration auf verschiedene Arten an GET-Anforderungen in / configuration.  Wir sind in zweierlei Hinsicht interessiert.  Das erste ist <code>/configuration/data_cluster</code> mit Cluster-Konfiguration </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"host"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"port"</span></span>: <span class="hljs-number"><span class="hljs-number">443</span></span>, <span class="hljs-attr"><span class="hljs-attr">"credentials"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span> } }</code> </pre> <br><p>  Die zweite ist <code>/configuration/reconciliation</code> mit der Konfiguration der Bohranwendung </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"reconciliation_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">3600</span></span>, <span class="hljs-attr"><span class="hljs-attr">"configuration_update_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">"file:///c:/path"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"credentials"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span> } } }</code> </pre> <br><p>  Die Schwierigkeit besteht darin, dass Sie in der Lage sein müssen, die Serverantwort während des Tests oder zwischen Tests zu ändern, um zu testen, wie die Anwendung auf Konfigurationsänderungen, falsche Kennwörter usw. reagiert. </p><br><p>  Statische Mocks und Tools für Mocks in Komponententests (Mock, Monkeypatch von Pytest usw.) funktionieren bei uns nicht.  Ich fand eine großartige <code>pretenders</code> Bibliothek, die ich für richtig hielt.  <a href="https://pretenders.readthedocs.io/en/latest/" title="Lesen Sie die Pretenders-Dokumentation">Pretenders</a> bietet die Möglichkeit, einen HTTP-Server mit Regeln zu erstellen, die festlegen, wie der Server auf Anforderungen reagiert.  Regeln werden in Voreinstellungen gespeichert, die das Isolieren von Mocks für verschiedene Testsuiten ermöglichen.  Voreinstellungen können gelöscht und neu gefüllt werden, sodass Sie die Antworten nach Bedarf aktualisieren können.  Es reicht aus, den Server selbst einmal während der Vorbereitung der Umgebung hochzufahren: </p><br><pre> <code class="bash hljs">python -m pretenders.server.server --host 127.0.0.1 --port 8000</code> </pre> <br><p>  Und in den Tests müssen wir die Verwendung des Clients hinzufügen.  Im einfachsten Fall kann es so aussehen, wenn die Antworten in den Tests vollständig fest codiert sind: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pretenders.client.http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> HTTPMock <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pretenders.common.constants <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FOREVER @pytest.fixture <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configuration_server_mock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> mock = HTTPMock(host=<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, port=<span class="hljs-number"><span class="hljs-number">8000</span></span>, name=<span class="hljs-string"><span class="hljs-string">"server"</span></span>) request.addfinalizer(mock.reset) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mock <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_something</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(configuration_server_mock)</span></span></span><span class="hljs-function">:</span></span> configuration_server_mock.when(<span class="hljs-string"><span class="hljs-string">"GET /configuration/data_cluster"</span></span>).reply( headers={<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>}, body=json.dumps({ <span class="hljs-string"><span class="hljs-string">"host"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-string"><span class="hljs-string">"port"</span></span>: <span class="hljs-number"><span class="hljs-number">443</span></span>, <span class="hljs-string"><span class="hljs-string">"credentials"</span></span>: { <span class="hljs-string"><span class="hljs-string">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span>, }, }), status=<span class="hljs-number"><span class="hljs-number">200</span></span>, times=FOREVER, ) configuration_server_mock.when(<span class="hljs-string"><span class="hljs-string">"GET /configuration/reconciliation"</span></span>).reply( headers={<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>}, body=json.dumps({ <span class="hljs-string"><span class="hljs-string">"reconciliation_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">3600</span></span>, <span class="hljs-string"><span class="hljs-string">"configuration_update_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-string"><span class="hljs-string">"source"</span></span>: { <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">"file:///c:/path"</span></span>, <span class="hljs-string"><span class="hljs-string">"credentials"</span></span>: { <span class="hljs-string"><span class="hljs-string">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span>, }, }, }), status=<span class="hljs-number"><span class="hljs-number">200</span></span>, times=FOREVER, ) <span class="hljs-comment"><span class="hljs-comment"># test application</span></span></code> </pre> <br><p>  Das ist aber noch nicht alles.  Bei der Flexibilität von <code>pretenders</code> gibt es zwei Einschränkungen, die beachtet und in unserem Fall berücksichtigt werden müssen: </p><br><ol><li>  Regeln können nicht einzeln gelöscht werden.  Um die Antwort zu ändern, müssen Sie die gesamte Voreinstellung löschen und alle Regeln erneut erstellen. </li><li>  Alle in den Regeln verwendeten Pfade sind relativ.  Voreinstellungen haben einen eindeutigen Pfad in der Form / mockhttp / &lt;Name_der_Voreinstellung&gt;. Dieser Pfad ist ein gemeinsames Präfix für alle in den Regeln erstellten Pfade.  Die getestete Anwendung erhält nur den Hostnamen und kann das Präfix nicht kennen. </li></ol><br><p>  Die erste Einschränkung ist sehr unangenehm, kann jedoch gelöst werden, indem ein Modul geschrieben wird, das die Arbeit mit der Konfiguration zusammenfasst.  Zum Beispiel so </p><br><pre> <code class="python hljs">configuration.data_cluster.port = <span class="hljs-number"><span class="hljs-number">443</span></span></code> </pre> <br><p>  oder (um Aktualisierungsanforderungen seltener zu stellen) </p><br><pre> <code class="python hljs">data_cluster_config = get_default_data_cluster_config() data_cluster_config.port = <span class="hljs-number"><span class="hljs-number">443</span></span> configuration.update_data_cluster(data_cluster_config)</code> </pre> <br><p>  Eine solche Kapselung ermöglicht es uns, alle Pfade nahezu schmerzlos zu aktualisieren.  Sie können auch eine individuelle Voreinstellung für jeden einzelnen Endpunkt und eine allgemeine (Haupt-) Voreinstellung erstellen, die (bis 307 oder 308) auf einzelne umleitet.  Dann können Sie nur eine Voreinstellung löschen, um die Regel zu aktualisieren. </p><br><p>  Um Präfixe loszuwerden, können Sie die <a href="https://mitmproxy.org/" title="Gehen Sie zur mitmproxy-Website">mitmproxy-</a> Bibliothek verwenden.  Dies ist ein leistungsstarkes Tool, mit dem unter anderem Anforderungen umgeleitet werden können.  Wir werden die Präfixe wie folgt entfernen: </p><br><pre> <code class="bash hljs">mitmdump --mode reverse:http://127.0.0.1:8000 --replacements :~http:^/:/mockhttp/server/ --listen-host 127.0.01 --listen-port 80</code> </pre> <br><p>  Die Parameter dieses Befehls bewirken Folgendes: </p><br><ol><li>  <code>--listen-host 127.0.0.1</code> und <code>--listen-port 80</code> Hand.  Mitmproxy erhöht seinen Server und mit diesen Parametern bestimmen wir die Schnittstelle und den Port, die dieser Server überwacht. </li><li>  <code>--mode reverse:http://127.0.0.1:8000</code> bedeutet, dass Anforderungen an den Mitproxyserver an <code>http://127.0.0.1:8000</code> umgeleitet werden.  Lesen Sie <a href="https://docs.mitmproxy.org/stable/concepts-modes/" title="Dokumentation verschiedener Modi">hier</a> mehr. </li><li>  <code>--replacements :~http:^/:/mockhttp/server/</code> definiert eine Vorlage, durch die Anforderungen geändert werden.  Es besteht aus drei Teilen: einem Anforderungsfilter ( <code>~http</code> für HTTP-Anforderungen), einer Vorlage zum Ändern ( <code>^/</code> zum Ersetzen des <code>/mockhttp/server</code> ) und zum tatsächlichen Ersetzen ( <code>/mockhttp/server</code> ).  Lesen Sie <a href="https://docs.mitmproxy.org/stable/overview-features/" title="Funktionsdokumentation">hier</a> mehr. </li></ol><br><p>  In unserem Fall fügen wir allen HTTP-Anforderungen <code>mockhttp/server</code> und leiten sie zu <code>http://127.0.0.1:8000</code> , d. H.  an unsere Server-Pretender.  Als Ergebnis haben wir erreicht, dass die Konfiguration jetzt mit einer GET-Anforderung an <code>http://127.0.0.1/configuration/data_cluster</code> abgerufen werden kann. </p><br><p>  Im Allgemeinen war ich mit dem Design mit <code>pretenders</code> und <code>mitmproxy</code> .  Bei der offensichtlichen Komplexität - immerhin 2 Server statt eines echten - besteht die Vorbereitung darin, 2 Pakete zu installieren und 2 Befehle in der Befehlszeile auszuführen, um sie zu starten.  Nicht alles ist so einfach in der Verwaltung eines Mocks, aber die gesamte Komplexität liegt an nur einem Ort (Verwaltung von Presets) und wird ganz einfach und zuverlässig gelöst.  Es traten jedoch neue Umstände in dem Problem auf, die mich über eine neue Lösung nachdenken ließen. </p><br><h1>  Zweiter Schein </h1><br><p>  Bis zu diesem Moment habe ich fast nicht gesagt, woher die Referenzdaten stammen.  Ein aufmerksamer Leser kann feststellen, dass im obigen Beispiel der Pfad zum Dateisystem als Adresse der Datenquelle verwendet wird.  Und es funktioniert wirklich so etwas, aber nur für einen der Anbieter.  Ein anderer Anbieter stellt eine API zum Empfangen von Anwendungen bereit, und bei ihm trat ein Problem auf.  Da es schwierig ist, die Hersteller-API während der Tests zu erhöhen, wollte ich sie nach demselben Schema wie zuvor durch eine Schein-API ersetzen.  Aber um Bewerbungen zu erhalten, eine Anfrage des Formulars </p><br><pre> <code class="plaintext hljs">GET /application-history?page=2&amp;size=5&amp;start=1569148012&amp;end=1569148446</code> </pre> <br><p>  Hier gibt es 2 Punkte.  Erstens ein paar Möglichkeiten.  Tatsache ist, dass Parameter in beliebiger Reihenfolge angegeben werden können, was den regulären Ausdruck für die <code>pretenders</code> Regel erheblich verkompliziert.  Es muss auch beachtet werden, dass die Parameter optional sind, dies ist jedoch kein Problem wie die zufällige Reihenfolge.  Zweitens geben die letzten Parameter (Anfang und Ende) das Zeitintervall zum Filtern der Reihenfolge an.  Und das Problem in diesem Fall ist, dass wir nicht im Voraus vorhersagen können, welches Intervall (nicht die Größe, sondern die Startzeit) von der Anwendung zur Bildung der Scheinantwort verwendet wird.  Einfach ausgedrückt müssen wir die Parameterwerte kennen und verwenden, um eine „vernünftige“ Antwort zu bilden.  "Reasonability" ist in diesem Fall beispielsweise wichtig, damit wir testen können, ob die Anwendung alle Seiten der Paginierung durchläuft. Wenn wir alle Anfragen auf die gleiche Weise beantworten, können wir keine Fehler finden, da nur eine von fünf Seiten angefordert wird . </p><br><p>  Ich habe versucht, nach alternativen Lösungen zu suchen, aber am Ende habe ich mich entschlossen, meine eigenen zu schreiben.  Es gab also einen <a href="https://github.com/KillAChicken/loose-server" title="Gehen Sie zum Repository und zur Dokumentation">losen Server</a> .  Dies ist eine <a href="https://palletsprojects.com/p/flask/" title="Gehen Sie zur Projektseite">Flask-</a> Anwendung, in der Pfade und Antworten nach dem Start konfiguriert werden können.  Er kann sofort mit Regeln für die Art der Anforderung (GET, POST usw.) und für den Pfad arbeiten.  Auf diese Weise können Sie <code>pretenders</code> und <code>mitmproxy</code> in der ursprünglichen Aufgabe ersetzen.  Ich werde auch zeigen, wie damit ein Mock für die Vendor-API erstellt werden kann. </p><br><p>  Eine Anwendung benötigt 2 Hauptpfade: </p><br><ol><li>  Basisendpunkt.  Dies ist das gleiche Präfix, das für alle konfigurierten Regeln verwendet wird. </li><li>  Konfigurationsendpunkt.  Dies ist das Präfix der Anfragen, mit denen Sie den Mock-Server selbst konfigurieren können. </li></ol><br><pre> <code class="bash hljs">python -m looseserver.default.server.run --host 127.0.0.1 --port 80 --base-endpoint / --configuration-endpoint /_mock_configuration/</code> </pre> <br><p>  Im Allgemeinen ist es am besten, den Basisendpunkt und den Konfigurationsendpunkt nicht so zu konfigurieren, dass einer der Eltern des anderen ist.  Andernfalls besteht die Gefahr, dass die Pfade zur Konfiguration und zum Testen in Konflikt geraten.  Der Konfigurationsendpunkt hat Vorrang, da Kolbenregeln für die Konfiguration früher als für dynamische Pfade hinzugefügt werden.  In unserem Fall könnten wir <code>--base-endpoint /configuration/</code> wenn wir die Hersteller-API nicht in dieses Modell aufnehmen würden. </p><br><p>  Die einfachste Version der Tests ändert nicht viel </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.client.http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> HTTPClient <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.client.rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PathRule <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.client.response <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FixedResponse @pytest.fixture <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configuration_server_mock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockFactory</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._client = HTTPClient(configuration_url=<span class="hljs-string"><span class="hljs-string">"http://127.0.0.1/_mock_configuration/"</span></span>) self._rule_ids = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_rule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, json_response)</span></span></span><span class="hljs-function">:</span></span> rule = self._client.create_rule(PathRule(path=path)) self._rule_ids.append(rule.rule_id) response = FixedResponse( headers={<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>}, status=<span class="hljs-number"><span class="hljs-number">200</span></span>, body=json.dumps(json_response), ) self._client.set_response(rule_id=rule.rule_id, response=response) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_delete_rules</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rule_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self._rule_ids: self._client.remove_rule(rule_id=rule_id) mock = MockFactory() request.addfinalizer(mock._delete_rules) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mock <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_something</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(configuration_server_mock)</span></span></span><span class="hljs-function">:</span></span> configuration_server_mock.create_rule( path=<span class="hljs-string"><span class="hljs-string">"configuration/data_cluster"</span></span>, json_response={ <span class="hljs-string"><span class="hljs-string">"host"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-string"><span class="hljs-string">"port"</span></span>: <span class="hljs-number"><span class="hljs-number">443</span></span>, <span class="hljs-string"><span class="hljs-string">"credentials"</span></span>: { <span class="hljs-string"><span class="hljs-string">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span>, }, } ) configuration_server_mock.create_rule( path=<span class="hljs-string"><span class="hljs-string">"configuration/reconciliation"</span></span>, json_response={ <span class="hljs-string"><span class="hljs-string">"reconciliation_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">3600</span></span>, <span class="hljs-string"><span class="hljs-string">"configuration_update_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-string"><span class="hljs-string">"source"</span></span>: { <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">"file:///applications"</span></span>, <span class="hljs-string"><span class="hljs-string">"credentials"</span></span>: { <span class="hljs-string"><span class="hljs-string">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span>, }, }, } )</code> </pre> <br><p>  Fixture ist schwieriger geworden, aber die Regeln können jetzt einzeln gelöscht werden, was die Arbeit mit ihnen vereinfacht.  Die Verwendung von <code>mitmproxy</code> nicht mehr erforderlich. </p><br><p>  Kehren wir zur Hersteller-API zurück.  Wir werden einen neuen Regeltyp für einen losen Server erstellen, der je nach Parameterwert unterschiedliche Antworten liefert.  Als nächstes werden wir diese Regel für den Seitenparameter verwenden. </p><br><p>  Neue Regeln und Antworten müssen sowohl für den Server als auch für den Client erstellt werden.  Beginnen wir mit dem Server: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.server.rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ServerRule <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerParameterRule</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ServerRule)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parameter_name, parameter_value=None, rule_type=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"PARAMETER"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> super(ServerParameterRule, self).__init__(rule_type=rule_type) self._parameter_name = parameter_name self._parameter_value = parameter_value <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_match_found</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._parameter_value <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._parameter_name <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> request.args <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.args.get(self._parameter_name) == self._parameter_value</code> </pre> <br><p>  Jede Regel muss eine <code>is_match_found</code> Methode definieren, die festlegt, ob sie für eine bestimmte Anforderung funktionieren soll oder nicht.  Der Eingabeparameter dafür ist das Anforderungsobjekt.  Nachdem die neue Regel erstellt wurde, muss der Server "angelernt" werden, um sie vom Client zu akzeptieren.  Verwenden Sie dazu <code>RuleFactory</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.server.rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> create_rule_factory <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.server.application <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> configure_application <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_create_application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base_endpoint, configuration_endpoint)</span></span></span><span class="hljs-function">:</span></span> server_rule_factory = create_rule_factory(base_endpoint) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_parse_param_rule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rule_type, parameters)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ServerParameterRule( rule_type=rule_type, parameter_name=parameters[<span class="hljs-string"><span class="hljs-string">"parameter_name"</span></span>], parameter_value=parameters[<span class="hljs-string"><span class="hljs-string">"parameter_value"</span></span>], ) server_rule_factory.register_rule( rule_type=<span class="hljs-string"><span class="hljs-string">"PARAMETER"</span></span>, parser=_parse_param_rule, serializer=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> rule_type, rule: <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> configure_application( rule_factory=server_rule_factory, base_endpoint=base_endpoint, configuration_endpoint=configuration_endpoint, ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: application = _create_application(base_endpoint=<span class="hljs-string"><span class="hljs-string">"/"</span></span>, configuration_endpoint=<span class="hljs-string"><span class="hljs-string">"/_mock_configuration"</span></span>) application.run(host=<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, port=<span class="hljs-number"><span class="hljs-number">80</span></span>)</code> </pre> <br><p>  Hier erstellen wir standardmäßig eine Factory für die Regeln, sodass sie die zuvor verwendeten Regeln enthält, und registrieren einen neuen Typ.  In diesem Fall benötigt der Client die Regelinformationen nicht, sodass der <code>serializer</code> tatsächlich nichts unternimmt.  Weiterhin wird diese Fabrik in die Anwendung übertragen.  Und es kann bereits wie eine normale Flask-Anwendung ausgeführt werden. </p><br><p>  Die Situation beim Kunden ist ähnlich: Wir erstellen eine Regel und eine Fabrik.  Für den Client ist es jedoch nicht erforderlich, erstens die Methode <code>is_match_found</code> zu definieren, und zweitens ist in diesem Fall der Serializer erforderlich, um die Regel an den Server zu senden. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.client.rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ClientRule <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.client.rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> create_rule_factory <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClientParameterRule</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ClientRule)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parameter_name, parameter_value=None, rule_type=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"PARAMETER"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, rule_id=None)</span></span></span><span class="hljs-function">:</span></span> super(ClientParameterRule, self).__init__(rule_type=rule_type, rule_id=rule_id) self.parameter_name = parameter_name self.parameter_value = parameter_value <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_create_client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(configuration_url)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_serialize_param_rule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rule)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">"parameter_name"</span></span>: rule.parameter_name, <span class="hljs-string"><span class="hljs-string">"parameter_value"</span></span>: rule.parameter_value, } client_rule_factory = create_rule_factory() client_rule_factory.register_rule( rule_type=<span class="hljs-string"><span class="hljs-string">"PARAMETER"</span></span>, parser=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> rule_type, parameters: ClientParameterRule(rule_type=rule_type, parameter_name=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>), serializer=_serialize_param_rule, ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HTTPClient(configuration_url=configuration_url, rule_factory=client_rule_factory)</code> </pre> <br><p>  Es bleibt <code>_create_client</code> zu verwenden, um den Client zu erstellen, und die Regeln können in Tests verwendet werden.  Im folgenden Beispiel habe ich die Verwendung einer anderen Standardregel hinzugefügt: <code>CompositeRule</code> .  Sie können mehrere Regeln zu einer kombinieren, sodass sie nur funktionieren, wenn jede von ihnen beim Aufruf von <code>is_match_found</code> True <code>is_match_found</code> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@pytest.fixture def configuration_server_mock(request): class MockFactory: def __init__(self): self._client = _create_client("http://127.0.0.1/_mock_configuration/") self._rule_ids = [] def create_paged_rule(self, path, page, json_response): rule_prototype = CompositeRule( children=[ PathRule(path=path), ClientParameterRule(parameter_name="page", parameter_value=page), ] ) rule = self._client.create_rule(rule_prototype) self._rule_ids.append(rule.rule_id) response = FixedResponse( headers={"Content-Type": "application/json"}, status=200, body=json.dumps(json_response), ) self._client.set_response(rule_id=rule.rule_id, response=response) ... mock = MockFactory() request.addfinalizer(mock._delete_rules) return mock def test_something(configuration_server_mock): ... configuration_server_mock.create_paged_rule( path="application-history", page=None, json_response=["1", "2", "3"], ) configuration_server_mock.create_paged_rule( path="application-history", page="1", json_response=["1", "2", "3"], ) configuration_server_mock.create_paged_rule( path="application-history", page="2", json_response=["4", "5"], )</span></span></code> </pre> <br><h1>  Fazit </h1><br><p>  Eine <code>mitmproxy</code> <code>pretenders</code> und <code>mitmproxy</code> bietet ein leistungsstarkes und ausreichend flexibles Werkzeug zum Erstellen von Mocks.  Ihre Vorteile: </p><br><ol><li>  Einfaches Setup. </li><li>  Möglichkeit, Abfragesätze mithilfe von Vorgaben zu isolieren. </li><li>  Löscht einen gesamten isolierten Satz auf einmal. </li></ol><br><p>  Durch die Nachteile gehören: </p><br><ol><li>  Die Notwendigkeit, reguläre Ausdrücke für Regeln zu erstellen. </li><li>  Die Unfähigkeit, die Regeln individuell zu ändern. </li><li>  Das Vorhandensein eines Präfixes für alle erstellten Pfade oder die Verwendung der Umleitung mithilfe von <code>mitmproxy</code> . </li></ol><br><p>  Dokumentationslinks: <br>  <a href="https://pretenders.readthedocs.io/en/latest/">Prätendenten</a> <br>  <a href="https://docs.mitmproxy.org/stable/">Mitmproxy</a> <br>  <a href="https://github.com/KillAChicken/loose-server/wiki">Lose Server</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476904/">https://habr.com/ru/post/de476904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476880/index.html">Sicherheitskrippen: CSRF</a></li>
<li><a href="../de476888/index.html">Welche UX-Designtrends folgen 2020?</a></li>
<li><a href="../de476890/index.html">Für diejenigen, die bei Houdini arbeiten. Über Nature of Vex und Bites of Python Kurse</a></li>
<li><a href="../de476900/index.html">Autonomes Gerät auf Arduino, das einen Temperaturanstieg (-abfall) signalisiert</a></li>
<li><a href="../de476902/index.html">Barrymore, wie ist das Treiben um Voximplant? Implementiert Web-Sockets, Sir</a></li>
<li><a href="../de476906/index.html">Was ist neu in SOLIDWORKS 2020?</a></li>
<li><a href="../de476908/index.html">Ist Hadoop tot? Teil 2</a></li>
<li><a href="../de476910/index.html">Antiquitäten: Eine schwierige Auswahl an Soundkarten für DOS-Spiele</a></li>
<li><a href="../de476912/index.html">Buchungskreisrechte für Programmierer</a></li>
<li><a href="../de476914/index.html">Installieren Sie das Powershell-Modul aus dem Github-Repository</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>