<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∂üèΩ üë≥ üèáüèø Regrettant l'absence en C ++ d'une statique √† part enti√®re si ou ... üåü ü§ô ü•ò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... comment remplir une classe de mod√®le avec un contenu diff√©rent en fonction des valeurs des param√®tres du mod√®le? 


 Il √©tait une fois, pendant un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Regrettant l'absence en C ++ d'une statique √† part enti√®re si ou ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449122/"><p>  <strong>... comment remplir une classe de mod√®le avec un contenu diff√©rent en fonction des valeurs des param√®tres du mod√®le?</strong> </p><br><p> Il √©tait une fois, pendant un certain temps, le langage D a commenc√© √† √™tre fait comme "le bon C ++", en tenant compte de l'exp√©rience acquise en C ++.  Au fil du temps, D est devenu un langage non moins complexe et plus expressif que C ++.  Et d√©j√† C ++ a commenc√© √† espionner D. Par exemple, est apparu en C ++ 17 <code>if constexpr</code> , √† mon avis, est un emprunt direct √† D, dont le prototype √©tait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">si statique D-shny</a> . </p><br><p>  Malheureusement, <code>if constexpr</code> en C ++ n'a pas la m√™me puissance que <code>static if</code> en D. Il y a des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">raisons √† cela</a> , mais il y a encore des cas o√π vous ne pouvez que regretter que <code>if constexpr</code> en C ++ ne vous permette pas de contr√¥ler le contenu de C + + classe.  Je voudrais parler d'un de ces cas. </p><br><p>  Nous parlerons de la fa√ßon de cr√©er une classe de mod√®le, dont le contenu (c'est-√†-dire la composition des m√©thodes et la logique de certaines m√©thodes) changerait en fonction des param√®tres transmis √† cette classe de mod√®le.  Un exemple est tir√© de la vie r√©elle, de l'exp√©rience de d√©veloppement d'une <a href="">nouvelle version de SObjectizer</a> . </p><br><h1 id="zadacha-kotoruyu-trebuetsya-reshit">  La t√¢che √† r√©soudre </h1><br><p>  Il est n√©cessaire de cr√©er une version astucieuse du pointeur intelligent pour stocker les objets de message.  Pour que vous puissiez √©crire quelque chose comme: </p><a name="habracut"></a><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;my_message&gt; msg{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_message{...} }; send(target, msg); send(another_target, msg);</code> </pre> <br><p>  L'astuce de cette classe <code>message_holder_t</code> est qu'il y a trois facteurs importants √† consid√©rer. </p><br><h2 id="ot-chego-otnasledovan-tip-soobscheniya">  De quel type de message h√©rite-t-on? </h2><br><p>  Les types de messages qui param√®trent <code>message_holder_t</code> sont divis√©s en deux groupes.  Le premier groupe est constitu√© des messages qui h√©ritent du type de base sp√©cial <code>message_t</code> .  Par exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so5_message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds c_; so5_message(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds c) : a_{a}, b_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b)}, c_{c} {} };</code> </pre> <br><p>  Dans ce cas, message_holder_t √† l'int√©rieur de lui-m√™me ne doit contenir qu'un pointeur vers un objet de ce type.  Le m√™me pointeur doit √™tre renvoy√© dans les m√©thodes getter.  Autrement dit, pour le cas de l'h√©ritier de <code>message_t</code> devrait <code>message_t</code> avoir quelque chose comme: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message_holder_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt;M&gt; m_msg; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> M * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_msg.get(); } };</code> </pre> <br><p>  Le deuxi√®me groupe est constitu√© des messages de types d'utilisateurs arbitraires qui ne sont pas h√©rit√©s de <code>message_t</code> .  Par exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds c_; user_message(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds c) : a_{a}, b_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b)}, c_{c} {} };</code> </pre> <br><p>  Les instances de ces types dans SObjectizer ne sont pas envoy√©es par elles-m√™mes, mais sont enferm√©es dans un wrapper sp√©cial, <code>user_type_message_t&lt;M&gt;</code> , qui est d√©j√† h√©rit√© de <code>message_t</code> .  Par cons√©quent, pour ces types, <code>message_holder_t</code> doit contenir un pointeur vers <code>user_type_message_t&lt;M&gt;</code> int√©rieur, et les m√©thodes getter doivent renvoyer un pointeur sur M: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message_holder_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">user_type_message_t</span></span>&lt;M&gt;&gt; m_msg; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> M * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::addressof(m_msg-&gt;m_payload); } };</code> </pre> <br><h2 id="immutabelnost-ili-mutabelnost-soobscheniy">  Immunit√© ou mutabilit√© des messages </h2><br><p>  Le deuxi√®me facteur est la division des messages en immuables et mutables.  Si le message est immuable (et par d√©faut, il est immuable), les m√©thodes getter doivent renvoyer un pointeur constant vers le message.  Et s'ils sont mutables, les getters doivent renvoyer un pointeur non constant.  C'est-√†-dire  devrait √™tre quelque chose comme: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;so5_message&gt; msg1{...}; <span class="hljs-comment"><span class="hljs-comment">//  . const int a = msg1-&gt;a_; // OK. msg1-&gt;a_ = 0; //     ! message_holder_t&lt;mutable_msg&lt;user_message&gt;&gt; msg2{...}; //  . const int a = msg2-&gt;a_; // OK. msg2-&gt;a_ = 0; // OK.</span></span></code> </pre> <br><h2 id="shared_ptr-vs-unique_ptr">  shared_ptr vs unique_ptr </h2><br><p>  Le troisi√®me facteur est la logique du comportement de <code>message_holder_t</code> tant que pointeur intelligent.  Une fois qu'il devrait se comporter comme <code>std::shared_ptr</code> , c'est-√†-dire  Vous pouvez avoir plusieurs d√©tenteurs de message faisant r√©f√©rence √† la m√™me instance de message.  Et une fois qu'il devrait se comporter comme <code>std::unique_ptr</code> , c'est-√†-dire  une seule instance de message_holder peut faire r√©f√©rence √† une instance de message. </p><br><p>  Par d√©faut, le comportement de <code>message_holder_t</code> doit d√©pendre de la mutabilit√© / immuabilit√© du message.  C'est-√†-dire  avec des messages immuables, <code>message_holder_t</code> devrait se comporter comme <code>std::shared_ptr</code> , et avec des <code>std::unique_ptr</code> modifiables comme <code>std::unique_ptr</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;so5_message&gt; msg1{...}; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;so5_message&gt; msg2 = msg; <span class="hljs-comment"><span class="hljs-comment">// OK. message_holder_t&lt;mutable_msg&lt;user_message&gt;&gt; msg3{...}; message_holder_t&lt;mutable_msg&lt;user_message&gt;&gt; msg4 = msg3; // !  ! message_holder_t&lt;mutable_msg&lt;user_message&gt;&gt; msg5 = std::move(msg3); // OK.</span></span></code> </pre> <br><p>  Mais la vie est une chose compliqu√©e, vous devez donc √©galement pouvoir d√©finir manuellement le comportement de <code>message_holder_t</code> .  Pour que vous puissiez cr√©er message_holder pour un message immuable qui se comporte comme unique_ptr.  Et pour que vous puissiez cr√©er message_holder pour un message modifiable qui se comporte comme shared_ptr: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> unique_so5_message = so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt; so5_message, so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::unique&gt;; unique_so5_message msg1{...}; unique_so5_message msg2 = msg1; <span class="hljs-comment"><span class="hljs-comment">// !  ! unique_so5_message msg3 = std::move(msg); // OK,   msg3. using shared_user_messsage = so_5::message_holder_t&lt; so_5::mutable_msg&lt;user_message&gt;, so_5::message_ownership_t::shared&gt;; shared_user_message msg4{...}; shared_user_message msg5 = msg4; // OK.</span></span></code> </pre> <br><p>  Par cons√©quent, lorsque <code>message_holder_t</code> fonctionne comme shared_ptr, il doit avoir l'ensemble habituel de constructeurs et d'op√©rateurs d'affectation: √† la fois copier et d√©placer.  De plus, il doit y avoir une m√©thode constante <code>make_reference</code> , qui retourne une copie du pointeur stock√© dans <code>message_holder_t</code> . </p><br><p>  Mais lorsque <code>message_holder_t</code> fonctionne comme unique_ptr, le constructeur et l'op√©rateur de copie doivent √™tre interdits pour cela.  Et la m√©thode <code>make_reference</code> doit <em>prendre le</em> pointeur de l'objet <code>message_holder_t</code> : apr√®s avoir appel√© <code>make_reference</code> <code>message_holder_t</code> origine doit rester vide. </p><br><h2 id="chut-bolee-formalno">  Un peu plus formel </h2><br><p>  Vous devez donc cr√©er une classe de mod√®le: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership = <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected&gt; class <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> {...};</code> </pre> <br><p>  qui: </p><br><ul><li>  l'int√©rieur doit √™tre stock√© <code>intrusive_ptr_t&lt;M&gt;</code> ou <code>intrusive_ptr&lt;user_type_message_t&lt;M&gt;&gt;</code> selon que M est h√©rit√© de <code>message_t</code> ; </li><li>  les m√©thodes getter doivent retourner soit <code>const M*</code> soit <code>M*</code> selon la mutabilit√© / immuabilit√© du message; </li><li>  il doit y avoir soit un ensemble complet de constructeurs et d'op√©rateurs de copie / d√©placement, soit uniquement un constructeur et un op√©rateur de d√©placement; </li><li>  La m√©thode <code>make_reference()</code> doit soit renvoyer une copie de l'intrusive_ptr stock√©e, soit prendre la valeur de intrusive_ptr et laisser le <code>message_holder_t</code> origine vide.  Dans le premier cas, <code>make_reference()</code> doit √™tre constant, dans le second - m√©thode non constante. </li></ul><br><p>  Les deux derniers √©l√©ments de la liste sont d√©termin√©s par le param√®tre Propri√©t√© (ainsi que par la mutabilit√© du message si la <code>autodetected</code> utilis√©e pour la propri√©t√©). </p><br><h1 id="kak-eto-bylo-resheno">  Comment cela a √©t√© d√©cid√© </h1><br><p>  Dans cette section, nous consid√©rerons tous les composants qui composent la solution finale.  Eh bien, la solution r√©sultante elle-m√™me.  Les fragments de code effac√©s de tous les d√©tails g√™nants seront affich√©s.  Si quelqu'un s'int√©resse au vrai code, vous pouvez le voir <a href="">ici</a> . </p><br><h2 id="disclaimer">  Clause de non-responsabilit√© </h2><br><p>  La solution pr√©sent√©e ci-dessous ne pr√©tend pas √™tre belle, id√©ale ou un mod√®le.  Il a √©t√© trouv√©, mis en ≈ìuvre, test√© et document√© en peu de temps, sous la pression des d√©lais.  Peut-√™tre que s'il y avait plus de temps, et si plus √©tait engag√© dans la recherche d'une solution <del>  jeune </del>  sensible et comp√©tent en d√©veloppeur C ++ moderne, il se r√©v√©lerait plus compact, plus simple et plus compr√©hensible.  Mais, il s'est av√©r√© que c'est arriv√© ... "Ne tirez pas sur le pianiste", en g√©n√©ral. </p><br><h2 id="posledovatelnost-shagov-i-uzhe-gotovaya-shablonnaya-magiya">  S√©quence d'√©tapes et magie de mod√®le pr√™te √† l'emploi </h2><br><p>  Donc, nous devons avoir une classe avec plusieurs ensembles de m√©thodes.  Le contenu de ces kits doit provenir de quelque part.  D'o√π? </p><br><p>  En D, nous pourrions utiliser <code>static if</code> et d√©finir diff√©rentes parties de la classe en fonction de diff√©rentes conditions.  Dans certains Ruby, nous pourrions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">m√©langer des m√©thodes dans notre classe en utilisant la m√©thode include</a> .  Mais nous sommes en C ++, o√π jusqu'√† pr√©sent nos possibilit√©s sont tr√®s limit√©es: nous pouvons soit d√©finir une m√©thode / attribut directement √† l'int√©rieur de la classe, soit h√©riter de la m√©thode / attribut d'une classe de base. </p><br><p>  Nous ne pouvons pas d√©finir diff√©rentes m√©thodes / attributs √† l'int√©rieur de la classe en fonction de certaines conditions, car  C ++ <code>if constexpr</code> n'est pas un D <code>static if</code> .  Par cons√©quent, seul l'h√©ritage demeure. </p><br><blockquote>  <strong>Upd.</strong>  Comme sugg√©r√© dans les commentaires, je devrais parler plus attentivement ici.  Puisque C ++ a SFINAE, nous pouvons activer / d√©sactiver la visibilit√© des m√©thodes individuelles dans la classe via SFINAE (c'est-√†-dire, obtenir un effet similaire √† <code>static if</code> ).  Mais cette approche pr√©sente √† mon avis deux lacunes graves.  Premi√®rement, si ces m√©thodes ne sont pas 1-2-3, mais 4-5 ou plus, il est fastidieux de formater chacune d'elles √† l'aide de SFINAE, ce qui affecte la lisibilit√© du code.  Deuxi√®mement, SFINAE ne nous aide pas √† ajouter / supprimer des attributs de classe (champs). </blockquote><p>  En C ++, nous pouvons d√©finir plusieurs classes de base dont nous h√©riterons ensuite <code>message_holder_t</code> .  Et le choix de l'une ou l'autre classe de base se fera d√©j√† en fonction des valeurs des param√®tres du template, en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: conditional</a> . </p><br><p>  Mais l'astuce est que nous avons besoin non seulement d'un ensemble de classes de base, mais d'une petite cha√Æne d'h√©ritage.  Au d√©but, il y aura une classe qui d√©terminera la fonctionnalit√© g√©n√©rale qui sera requise dans tous les cas.  Viennent ensuite les classes de base qui d√©termineront la logique du comportement du "pointeur intelligent".  Et puis il y aura une classe qui d√©terminera les getters n√©cessaires.  Dans cet ordre, nous consid√©rerons les classes impl√©ment√©es. </p><br><p>  Notre t√¢che est simplifi√©e par le fait que SObjectizer poss√®de d√©j√† une magie de mod√®le pr√™te √† l'emploi <a href="">qui d√©termine si un message est h√©rit√© de message_t</a> , ainsi que des <a href="">moyens pour v√©rifier la mutabilit√© des messages</a> .  Par cons√©quent, dans la mise en ≈ìuvre, nous utiliserons simplement cette magie toute faite et ne plongerons pas dans les d√©tails de son travail. </p><br><h2 id="obschaya-baza-dlya-hraneniya-ukazatelya">  Base de stockage de pointeur commun </h2><br><p>  Commen√ßons par un type de base commun qui stocke le intrusive_ptr correspondant, et fournit √©galement un ensemble commun de m√©thodes dont toute impl√©mentation <code>message_holder_t</code> besoin: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Payload, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Envelope &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">basic_message_holder_impl_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; Envelope &gt; m_msg; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> payload_type = Payload; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> envelope_type = Envelope; <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; Envelope &gt; msg ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : m_msg{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(msg) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ m_msg.reset(); } [[nodiscard]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;( m_msg ); } [[nodiscard]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;empty(); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;empty(); } };</code> </pre> <br><p>  Cette classe de mod√®le a deux param√®tres.  Le premier, Payload, d√©finit le type que les m√©thodes getter doivent utiliser.  Alors que la seconde, Envelope, d√©finit le type de intrusive_ptr.  Dans le cas o√π le type de message est h√©rit√© de <code>message_t</code> ces deux param√®tres auront la m√™me valeur.  Mais si le message n'est pas h√©rit√© de <code>message_t</code> , le type de message sera utilis√© comme charge utile et <code>user_type_message_t&lt;Payload&gt;</code> sera <code>user_type_message_t&lt;Payload&gt;</code> comme enveloppe. </p><br><p>  Je pense que fondamentalement le contenu de cette classe ne pose pas de question.  Mais deux choses doivent √™tre not√©es s√©par√©ment. </p><br><p>  Tout d'abord, le pointeur lui-m√™me, c'est-√†-dire  l'attribut m_msg est d√©fini dans la section prot√©g√©e afin que les h√©ritiers des classes y aient acc√®s. </p><br><p>  Deuxi√®mement, pour cette classe, le compilateur g√©n√®re lui-m√™me tous les constructeurs et op√©rateurs de copie / d√©placement n√©cessaires.  Et au niveau de cette classe, nous n'interdisons encore rien. </p><br><h2 id="otdelnye-bazy-dlya-shared_ptr--i-unique_ptr-povedeniya">  Bases distinctes pour le comportement shared_ptr et unique_ptr </h2><br><p>  Nous avons donc une classe qui stocke un pointeur sur un message.  Nous pouvons maintenant d√©finir ses h√©ritiers, qui se comporteront soit en shared_ptr soit en unique_ptr. </p><br><p>  Commen√ßons par le cas du comportement shared_ptr, car  voici le moins de code: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Payload, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Envelope &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_message_holder_impl_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>&lt;Payload, Envelope&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> direct_base_type = <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>&lt;Payload, Envelope&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> direct_base_type::direct_base_type; [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; Envelope &gt; make_reference() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_msg; } };</code> </pre> <br><p>  Rien de compliqu√©: <code>basic_message_holder_impl_t</code> de <code>basic_message_holder_impl_t</code> , <code>basic_message_holder_impl_t</code> tous ses constructeurs et d√©finissez une impl√©mentation simple et non destructive de <code>make_reference()</code> . </p><br><p>  Dans le cas du comportement unique_ptr, le code est plus volumineux, bien qu'il n'y ait rien de compliqu√©: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Payload, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Envelope &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unique_message_holder_impl_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>&lt;Payload, Envelope&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> direct_base_type = <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>&lt;Payload, Envelope&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> direct_base_type::direct_base_type; <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp;&amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp;&amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; Envelope &gt; make_reference() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_msg) }; } };</code> </pre> <br><p>  Encore une fois, nous <code>basic_message_holder_impl_t</code> de <code>basic_message_holder_impl_t</code> et <code>basic_message_holder_impl_t</code> des constructeurs dont nous avons besoin (c'est le constructeur par d√©faut et le constructeur d'initialisation).  Mais en m√™me temps, nous d√©finissons les constructeurs et les op√©rateurs de copie / d√©placement conform√©ment √† la logique unique_ptr: nous interdisons la copie, nous impl√©mentons le d√©placement. </p><br><p>  Nous avons √©galement une <code>make_reference()</code> destructrice <code>make_reference()</code> . </p><br><p>  C'est tout, en fait.  Il ne reste plus qu'√† r√©aliser le choix entre ces deux classes de base ... </p><br><h3 id="vybor-mezhdu-shared_ptr--i-unique_ptr-povedeniem">  Choix entre le comportement shared_ptr et unique_ptr </h3><br><p>  Pour choisir entre le comportement shared_ptr et unique_ptr, vous avez besoin de la m√©tafonction suivante (m√©tafonction car elle "fonctionne" avec les types au moment de la compilation): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">impl_selector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( !is_signal&lt;Msg&gt;::value, <span class="hljs-string"><span class="hljs-string">"Signals can't be used with message_holder"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> P = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> message_payload_type&lt; Msg &gt;::payload_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> E = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> message_payload_type&lt; Msg &gt;::envelope_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected == Ownership, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span>::immutable_message == message_mutability_traits&lt;Msg&gt;::mutability, <span class="hljs-keyword"><span class="hljs-keyword">shared_message_holder_impl_t</span></span>&lt;P, E&gt;, <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span>&lt;P, E&gt; &gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::shared == Ownership, <span class="hljs-keyword"><span class="hljs-keyword">shared_message_holder_impl_t</span></span>&lt;P, E&gt;, <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span>&lt;P, E&gt; &gt; &gt;; };</code> </pre> <br><p>  Cette m√©tafonction accepte les deux param√®tres de la liste des param√®tres <code>message_holder_t</code> et, par cons√©quent (c'est-√†-dire la d√©finition d'un <code>type</code> imbriqu√©), "renvoie" le type dont elle doit √™tre h√©rit√©e.  C'est-√†-dire  soit <code>shared_message_holder_impl_t</code> ou <code>unique_message_holder_impl_t</code> . </p><br><p>  √Ä l'int√©rieur de la d√©finition de <code>impl_selector</code> vous pouvez voir des traces de la magie mentionn√©e ci-dessus, et dans lesquelles nous ne sommes pas all√©s: <code>message_payload_type&lt;Msg&gt;::payload_type</code> , <code>message_payload_type&lt;Msg&gt;::envelope_type</code> et <code>message_mutability_traits&lt;Msg&gt;::mutability</code> . </p><br><p>  Et afin d'utiliser la <code>impl_selector</code> √©tait plus facile, alors nous allons lui d√©finir un nom plus court: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl_selector_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> impl_selector&lt;Msg, Ownership&gt;::type;</code> </pre> <br><h2 id="baza-dlya-getter-ov">  Base pour getters </h2><br><p>  Ainsi, nous avons d√©j√† la possibilit√© de s√©lectionner une base qui contient un pointeur et d√©finit le comportement d'un "pointeur intelligent".  Maintenant, nous devons fournir √† cette base des m√©thodes getter.  Pourquoi avons-nous besoin d'une classe simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Return_Type &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg_accessors_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Base { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Base::Base; [[nodiscard]] <span class="hljs-function"><span class="hljs-function">Return_Type * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_ptr( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_msg ); } [[nodiscard]] Return_Type &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *get(); } [[nodiscard]] Return_Type * <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(); } };</code> </pre> <br><p>  Il s'agit d'une classe de mod√®le qui d√©pend de deux param√®tres, mais leur signification est compl√®tement diff√©rente.  Le param√®tre Base sera le r√©sultat de la <code>impl_selector</code> impl_selector illustr√©e ci-dessus.  C'est-√†-dire  en tant que param√®tre Base, la classe de base est d√©finie √† partir de laquelle h√©riter. </p><br><p>  Il est important de noter que si l'h√©ritage provient de <code>unique_message_holder_impl_t</code> , pour lequel le constructeur et l'op√©rateur de copie sont interdits, le compilateur ne pourra pas g√©n√©rer le constructeur et l'op√©rateur de copie pour <code>msg_accessors_t</code> .  C'est ce dont nous avons besoin. </p><br><p>  Le type du message, le pointeur / lien vers lequel seront renvoy√©s par les getters, agira comme param√®tre Return_Type.  L'astuce est que pour un message immuable de type <code>Msg</code> le param√®tre Return_Type sera d√©fini sur <code>const Msg</code> .  Alors que pour un message mutable de type <code>Msg</code> param√®tre Return_Type aura la valeur <code>Msg</code> .  Ainsi, la m√©thode <code>get()</code> renverra <code>const Msg*</code> pour les messages immuables et juste <code>Msg*</code> pour les messages mutables. </p><br><p>  En utilisant la fonction gratuite <code>get_ptr()</code> r√©solvons le probl√®me de travailler avec des messages qui ne sont pas h√©rit√©s de <code>message_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-function"><span class="hljs-function">M * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">intrusive_ptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; &amp; msg )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> msg.get(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-function"><span class="hljs-function">M * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">intrusive_ptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">user_type_message_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; &gt; &amp; msg )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::addressof(msg-&gt;m_payload); }</code> </pre> <br><p>  C'est-√†-dire  si le message n'est pas h√©rit√© de <code>message_t</code> et stock√© en tant que <code>user_type_message_t&lt;Msg&gt;</code> , alors la deuxi√®me surcharge est appel√©e.  Et s'il est h√©rit√©, alors la premi√®re surcharge. </p><br><h3 id="vybor-konkretnoy-bazy-dlya-getter-ov">  Choisir une base sp√©cifique pour les getters </h3><br><p>  Ainsi, le mod√®le <code>msg_accessors_t</code> n√©cessite deux param√®tres.  La premi√®re est calcul√©e par la <code>impl_selector</code> impl_selector.  Mais afin de former un type de base sp√©cifique √† partir de <code>msg_accessors_t</code> , nous devons d√©terminer la valeur du deuxi√®me param√®tre.  Une autre m√©tafonction est pr√©vue √† cet effet: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span> Mutability, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">accessor_selector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span>::immutable_message == Mutability, <span class="hljs-keyword"><span class="hljs-keyword">msg_accessors_t</span></span>&lt;Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base::payload_type <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">msg_accessors_t</span></span>&lt;Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base::payload_type&gt; &gt;; };</code> </pre> <br><p>  Vous ne pouvez faire attention qu'au calcul du param√®tre Return_Type.  Un de ces rares cas o√π l'est const est utile;) </p><br><p>  Eh bien, pour augmenter la lisibilit√© du code suivant, une option plus compacte pour travailler avec lui: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span> Mutability, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">accessor_selector_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> accessor_selector&lt;Mutability, Base&gt;::type;</code> </pre> <br><h2 id="itogovyy-naslednik-message_holder_t">  Successeur final message_holder_t </h2><br><p>  Vous pouvez maintenant regarder ce qu'est <code>message_holder_t</code> , pour l'impl√©mentation dont toutes ces classes de base et m√©tafonctions √©taient n√©cessaires (une partie des m√©thodes de construction d'une instance du message stock√© dans message_holder sont supprim√©es de l'impl√©mentation): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership = <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected &gt; class <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">accessor_selector_t</span></span>&lt; details::message_mutability_traits&lt;Msg&gt;::mutability, details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">impl_selector_t</span></span>&lt;Msg, Ownership&gt; &gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> base_type = details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">accessor_selector_t</span></span>&lt; details::message_mutability_traits&lt;Msg&gt;::mutability, details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">impl_selector_t</span></span>&lt;Msg, Ownership&gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> payload_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> base_type::payload_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> envelope_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> base_type::envelope_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> base_type::base_type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; b )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap( a.message_reference(), b.message_reference() ); } };</code> </pre> <br><p>  En fait, tout ce que nous avons analys√© ci-dessus √©tait n√©cessaire pour enregistrer cet ¬´appel¬ª de deux m√©tafonctions: </p><br><pre> <code class="cpp hljs">details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">accessor_selector_t</span></span>&lt; details::message_mutability_traits&lt;Msg&gt;::mutability, details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">impl_selector_t</span></span>&lt;Msg, Ownership&gt; &gt;</code> </pre> <br><p>  Parce que  ce n'est pas la premi√®re option, mais le r√©sultat de la simplification et de la r√©duction du code, je peux dire que les formes compactes de m√©tafonctions r√©duisent consid√©rablement la quantit√© de code et augmentent sa compr√©hensibilit√© (s'il est g√©n√©ralement appropri√© de parler ici de compr√©hensibilit√©). </p><br><h1 id="a-chto-bylo-by-esli-by">  Et que se passerait-il si ... </h1><br><p>  Mais si en C ++ <code>if constexpr</code> √©tait aussi puissant que <code>static if</code> en D, alors vous pourriez √©crire quelque chose comme: </p><br><div class="spoiler">  <b class="spoiler_title">Version hypoth√©tique avec plus avanc√© si constexpr</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership = <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected &gt; class <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span> Mutability = details::message_mutability_traits&lt;Msg&gt;::mutability; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Actual_Ownership = (<span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::unique == Ownership || (<span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span>::mutable_msg == Mutability &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected == Ownership)) ? <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::unique : <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::shared; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> payload_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> message_payload_type&lt; Msg &gt;::payload_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> envelope_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> message_payload_type&lt; Msg &gt;::envelope_type; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> getter_return_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span>::immutable_msg == Mutability, payload_type <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, payload_type &gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; envelope_type &gt; mf ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : m_msg{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mf) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_ownership_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">::unique == Actual_Ownership )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp;&amp; ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp;&amp; ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; b )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap( a.m_msg, b.m_msg ); } [[nodiscard]] <span class="hljs-function"><span class="hljs-function">getter_return_type * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_const_ptr( m_msg ); } [[nodiscard]] getter_return_type &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *get(); } [[nodiscard]] getter_return_type * <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_ownership_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">::shared == Actual_Ownership)</span></span></span><span class="hljs-function"> </span></span>{ [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; envelope_type &gt; make_reference() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_msg; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; envelope_type &gt; make_reference() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m_msg) }; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; envelope_type &gt; m_msg; };</code> </pre> </div></div><br><p>   ,     .       C++ :( <br> (  C++      ""   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ). </p><br><p>  ,       ,             ++.   ,  ,  ,           .   ,        <code>message_holder_t</code> .         ,             ,      <code>if constexpr</code> . </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>   ,         C++. ,     .  ,    ,          . </p><br><p>                ,           . </p><br><p>   ,   ,   ++   ,   .      ,    . , ,            .  ,    .   C++98/03        ,     C++11       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr449122/">https://habr.com/ru/post/fr449122/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr449110/index.html">Correction d'un bug li√© √† l'impossibilit√© d'utiliser l'alphabet cyrillique dans les noms des dossiers IMAP</a></li>
<li><a href="../fr449112/index.html">Nous avons pris notre retraite - nous discutons de gadgets audio autrefois populaires qui sont d√©j√† "obsol√®tes"</a></li>
<li><a href="../fr449114/index.html">R√©agissez sur Œªambda</a></li>
<li><a href="../fr449118/index.html">Pilule d√©moniaque du Kremlin</a></li>
<li><a href="../fr449120/index.html">Avec une barbe, des lunettes noires et de profil: situations difficiles pour la vision par ordinateur</a></li>
<li><a href="../fr449124/index.html">Si difficile √† trouver, facile √† manquer et impossible √† √©mettre</a></li>
<li><a href="../fr449128/index.html">Les meilleures entreprises de d√©veloppement de jeux dans le monde</a></li>
<li><a href="../fr449132/index.html">Top 17 des plugins pour Android Studio</a></li>
<li><a href="../fr449134/index.html">Zoo afl</a></li>
<li><a href="../fr449138/index.html">5 raisons pour crypto-hat Pourquoi les informaticiens n'aiment pas le bitcoin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>