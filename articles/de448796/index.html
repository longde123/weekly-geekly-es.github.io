<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèæ ü•Ä üêú Python-Test mit Pytest. Konfiguration, KAPITEL 6 üå≠ üå∞ üßëüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zur√ºck Weiter 


 In diesem Kapitel werden wir uns die Konfigurationsdateien ansehen, die sich auf pytest auswirken, diskutieren, wie pytest sein Verh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python-Test mit Pytest. Konfiguration, KAPITEL 6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448796/"><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zur√ºck</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weiter</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p><br><p>  <em>In diesem Kapitel werden wir uns die Konfigurationsdateien ansehen, die sich auf pytest auswirken, diskutieren, wie pytest sein Verhalten basierend auf ihnen √§ndert, und einige √Ñnderungen an den Konfigurationsdateien des Aufgabenprojekts vornehmen.</em> </p><br><p><img src="https://habrastorage.org/webt/hd/--/9w/hd--9w134j0rxhmxftrflbbdopy.png"></p><a name="habracut"></a><br><p>  Die Beispiele in diesem Buch wurden mit Python 3.6 und pytest 3.2 geschrieben.  pytest 3.2 unterst√ºtzt Python 2.6, 2.7 und Python 3.3+. </p><br><blockquote> Der Quellcode f√ºr das Aufgabenprojekt sowie f√ºr alle in diesem Buch gezeigten Tests ist unter dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="https://pragprog.com/titles/bopytest/source_code">Link</a> auf der Webseite des Buches unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="https://pragprog.com/titles/bopytest">pragprog.com verf√ºgbar</a> .  Sie m√ºssen den Quellcode nicht herunterladen, um den Testcode zu verstehen.  Der Testcode wird in den Beispielen in einer praktischen Form dargestellt.  Um jedoch die Aufgaben des Projekts zu verfolgen oder Testbeispiele anzupassen, um Ihr eigenes Projekt zu testen (Ihre H√§nde sind losgebunden!), M√ºssen Sie auf die Webseite des Buches gehen und die Arbeit herunterladen.  Dort, auf der Webseite des Buches, gibt es einen Link f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="https://pragprog.com/titles/bopytest/errata">Errata-</a> Nachrichten und ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="https://forums.pragprog.com/forums/438">Diskussionsforum</a> . </blockquote><p>  Unter dem Spoiler befindet sich eine Liste der Artikel dieser Reihe. </p><br><div class="spoiler">  <b class="spoiler_title">Inhaltsverzeichnis</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Einf√ºhrung</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 1: Erste Schritte mit Pytest</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 2: Schreiben von Testfunktionen</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 3: Pytest-Vorrichtungen</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 4: Eingebaute Vorrichtungen</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 5: Plugins</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 6: Konfiguration</strong></a> (Dieser Artikel) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 7: Verwenden von pytest mit anderen Tools</strong></a> </li></ul></div></div><br><h2 id="konfiguraciya">  Konfiguration </h2><br><p>  Bisher habe ich in diesem Buch √ºber verschiedene Nicht-Test-Dateien gesprochen, die sich haupts√§chlich nebenbei auf pytest auswirken, mit Ausnahme von conftest.py, auf das ich in Kapitel 5, Plugins, auf Seite 95 ausf√ºhrlich eingegangen bin. In diesem Kapitel werden wir uns die Konfigurationsdateien ansehen. Dies wirkt sich auf pytest aus. Besprechen Sie, wie pytest sein Verhalten basierend darauf √§ndert, und nehmen Sie einige √Ñnderungen an den Konfigurationsdateien des Aufgabenprojekts vor. </p><br><h2 id="ponimanie-faylov-konfiguracii-pytest">  Grundlegendes zu Pytest-Konfigurationsdateien </h2><br><p>  Bevor ich Ihnen erkl√§re, wie Sie das Standardverhalten in pytest √§ndern k√∂nnen, gehen wir alle Nicht-Testdateien in pytest durch und insbesondere, wer sich um sie k√ºmmern sollte. </p><br><p>  Sie sollten Folgendes wissen: </p><br><ul><li> <em>pytest.ini</em> : Dies ist die Hauptkonfigurationsdatei von Pytest, mit der Sie das Standardverhalten √§ndern k√∂nnen.  Da Sie einige Konfigurations√§nderungen vornehmen k√∂nnen, ist der gr√∂√üte Teil dieses Kapitels den Einstellungen gewidmet, die Sie in <code>pytest.ini</code> . </li><li>  <em>conftest.py</em> : Dies ist ein lokales Plugin, mit dem Hook-Funktionen und Fixtures mit dem Verzeichnis verbunden werden k√∂nnen, in dem die Datei <code>conftest.py</code> sowie mit allen Unterverzeichnissen.  Die Datei <code>conftest.py</code> in Kapitel 5 ‚ÄûPlugins‚Äú auf Seite 95 beschrieben. </li><li>  <em><code>__init__.py</code></em> : Wenn diese Datei in jedes Test-Unterverzeichnis gestellt wird, k√∂nnen Sie identische Testdateinamen in mehreren <em><code>__init__.py</code></em> haben.  Ein Beispiel daf√ºr, was ohne <code>__init__.py</code> Dateien in <code>__init__.py</code> schief gehen w√ºrde, finden <code>__init__.py</code> im Artikel ‚ÄûVermeiden von Dateinamenkollisionen‚Äú auf Seite 120. </li></ul><br><p>  Wenn Sie Tox verwenden, interessieren Sie sich f√ºr: </p><br><ul><li>  <em>tox.ini</em> : Diese Datei √§hnelt <code>pytest.ini</code> , ist jedoch f√ºr <code>tox</code> .  Sie k√∂nnen hier jedoch Ihre <code>pytest</code> Konfiguration <code>pytest</code> anstatt sowohl die <code>tox.ini</code> Datei als auch die <code>pytest.ini</code> Datei zu haben, wodurch Sie eine Konfigurationsdatei speichern.  Tox wird in Kapitel 7, ‚ÄûVerwenden von Pytest mit anderen Tools‚Äú, auf Seite 125 erl√§utert. </li></ul><br><p>  Wenn Sie ein Python-Paket (z. B. Aufgaben) verteilen m√∂chten, ist diese Datei von Interesse: </p><br><ul><li>  <em>setup.cfg</em> : Dies ist auch eine INI-Datei, die das Verhalten von <code>setup.py</code> .  Sie k√∂nnen <code>setup.py</code> einige Zeilen <code>setup.py</code> , um <code>python setup.py test</code> und alle Ihre pytest-Tests auszuf√ºhren.  Wenn Sie das Paket verteilen, verf√ºgen Sie m√∂glicherweise bereits √ºber die Datei <code>setup.cfg</code> und k√∂nnen diese Datei zum Speichern der Pytest-Konfiguration verwenden.  Wie das geht, erfahren Sie in Anhang 4, ‚ÄûPacken und Verteilen von Python-Projekten‚Äú, auf Seite 175. </li></ul><br><p>  Unabh√§ngig davon, in welche Datei Sie die Pytest-Konfiguration einf√ºgen, ist das Format im Wesentlichen dasselbe. </p><br><p>  F√ºr <code>pytest.ini</code> : </p><br><blockquote>  <strong>ch6 / format / pytest.ini</strong> </blockquote><br><pre> <code class="plaintext hljs">[pytest] addopts = -rsxX -l --tb=short --strict xfail_strict = true ... more options ...</code> </pre> <br><p>  F√ºr <code>tox.ini</code> : </p><br><blockquote>  <strong>ch6 / format / tox.ini</strong> </blockquote><br><pre> <code class="plaintext hljs">... tox specific stuff ... [pytest] addopts = -rsxX -l --tb=short --strict xfail_strict = true ... more options ...</code> </pre> <br><p>  F√ºr <code>setup.cfg</code> : </p><br><blockquote>  <strong>ch6 / format / setup.cfg</strong> </blockquote><br><pre> <code class="plaintext hljs">... packaging specific stuff ... [tool:pytest] addopts = -rsxX -l --tb=short --strict xfail_strict = true ... more options ...</code> </pre> <br><p>  Der einzige Unterschied besteht darin, dass der Abschnittskopf f√ºr setup.cfg <code>[tool:pytest]</code> anstelle von <code>[pytest]</code> . </p><br><h3 id="list-the-valid-ini-file-options-with-pytest-help">  Listen Sie die g√ºltigen INI-Datei-Optionen mit pytest ‚Äìhelp auf </h3><br><p>  Eine Liste aller g√ºltigen Parameter f√ºr <code>pytest.ini</code> von <code>pytest --help</code> : </p><br><pre> <code class="plaintext hljs">$ pytest --help ... [pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg file found: markers (linelist) markers for test functions empty_parameter_set_mark (string) default marker for empty parametersets norecursedirs (args) directory patterns to avoid for recursion testpaths (args) directories to search for tests when no files or directories are given in the command line. console_output_style (string) console output: classic or with additional progress information (classic|progress). usefixtures (args) list of default fixtures to be used with this project python_files (args) glob-style file patterns for Python test module discovery python_classes (args) prefixes or glob names for Python test class discovery python_functions (args) prefixes or glob names for Python test function and method discovery xfail_strict (bool) default for the strict parameter of xfail markers when not given explicitly (default: False) junit_suite_name (string) Test suite name for JUnit report junit_logging (string) Write captured log messages to JUnit report: one of no|system-out|system-err doctest_optionflags (args) option flags for doctests doctest_encoding (string) encoding used for doctest files cache_dir (string) cache directory path. filterwarnings (linelist) Each line specifies a pattern for warnings.filterwarnings. Processed after -W and --pythonwarnings. log_print (bool) default value for --no-print-logs log_level (string) default value for --log-level log_format (string) default value for --log-format log_date_format (string) default value for --log-date-format log_cli (bool) enable log display during test run (also known as "live logging"). log_cli_level (string) default value for --log-cli-level log_cli_format (string) default value for --log-cli-format log_cli_date_format (string) default value for --log-cli-date-format log_file (string) default value for --log-file log_file_level (string) default value for --log-file-level log_file_format (string) default value for --log-file-format log_file_date_format (string) default value for --log-file-date-format addopts (args) extra command line options minversion (string) minimally required pytest version xvfb_width (string) Width of the Xvfb display xvfb_height (string) Height of the Xvfb display xvfb_colordepth (string) Color depth of the Xvfb display xvfb_args (args) Additional arguments for Xvfb xvfb_xauth (bool) Generate an Xauthority token for Xvfb. Needs xauth. ...</code> </pre> <br><p>  Alle diese Einstellungen werden in diesem Kapitel <code>doctest_optionflags</code> , mit Ausnahme der <code>doctest_optionflags</code> , die in Kapitel 7, ‚ÄûVerwenden von pytest mit anderen Tools‚Äú, auf Seite 125 erl√§utert werden. </p><br><h3 id="plaginy-mogut-dobavlyat-opcii-ini-faylov">  Plugins k√∂nnen INI-Dateioptionen hinzuf√ºgen </h3><br><p>  Die vorherige Liste der Einstellungen ist keine Konstante.  F√ºr Plugins (und conftest.py-Dateien) k√∂nnen INI-Dateioptionen hinzugef√ºgt werden.  Hinzugef√ºgte Optionen werden auch zur Ausgabe des Befehls pytest --help hinzugef√ºgt. <br>  Schauen wir uns nun einige Konfigurations√§nderungen an, die wir mithilfe der integrierten Einstellungen der INI-Datei vornehmen k√∂nnen, die in Core Pytest verf√ºgbar sind. </p><br><h3 id="izmenenie-parametrov-komandnoy-stroki-po-umolchaniyu">  √Ñndern Sie die Standardbefehlszeilenoptionen </h3><br><p>  Sie haben bereits einige Befehlszeilenoptionen f√ºr <em>pytest verwendet</em> , z. B. <code>-v/--verbose</code> f√ºr die ausf√ºhrliche Ausgabe <code>-l/--showlocals</code> , um lokale Variablen mit einem Stack-Trace f√ºr fehlgeschlagene Tests <code>-l/--showlocals</code> .  M√∂glicherweise verwenden Sie einige dieser <code>options‚Äîor</code> bevorzugen <code>them‚Äîfor a project</code> .  Wenn Sie in <code>pytest.ini</code> f√ºr die ben√∂tigten Parameter installieren, m√ºssen Sie diese nicht mehr eingeben.  Hier ist ein Set, das mir gef√§llt: </p><br><pre> <code class="plaintext hljs">[pytest] addopts = -rsxX -l --tb=short --strict</code> </pre> <br><p>  Mit <code>-rsxX</code> kann pytest die Gr√ºnde f√ºr alle <code>skipped</code> , <code>xfailed</code> oder nicht <code>xpassed</code> Tests <code>xpassed</code> .  Mit dem Schalter <code>-l</code> kann pytest bei jedem Fehler eine Stapelverfolgung f√ºr lokale Variablen anzeigen.  <code>--tb=short</code> entfernt den gr√∂√üten Teil der Stapelverfolgung.  Die Datei und die Zeilennummer bleiben jedoch erhalten.  Die <code>--strict</code> verbietet die Verwendung von Token, wenn diese nicht in der Konfigurationsdatei registriert sind.  Wie das geht, erfahren Sie im n√§chsten Abschnitt. </p><br><h3 id="registraciya-markerov-chtoby-izbezhat-opechatok-markera">  Markerregistrierung, um Tippfehler zu vermeiden </h3><br><p>  Benutzerdefinierte Markierungen, wie unter ‚ÄûBeschriften von Testfunktionen‚Äú auf Seite 31 beschrieben, eignen sich hervorragend, um eine Teilmenge von Tests zu markieren, die mit einer bestimmten Markierung ausgef√ºhrt werden sollen.  Es ist jedoch zu einfach, einen Fehler in der Markierung zu machen, und letztendlich sind einige Tests mit <code>@pytest.mark.smoke</code> und einige mit <code>@pytest.mark.somke</code> .  Standardm√§√üig ist dies kein Fehler.  pytest glaubt nur, dass Sie zwei Marker erstellt haben.  Dies kann jedoch behoben werden, indem Token in pytest.ini registriert werden, beispielsweise wie folgt: </p><br><pre> <code class="plaintext hljs">[pytest] ... markers = smoke: Run the smoke test test functions get: Run the test functions that test tasks.get() ...</code> </pre> <br><p>  Wenn Sie diese Marker registrieren, k√∂nnen Sie sie jetzt auch mit <code>pytest --markers</code> mit ihren Beschreibungen <code>pytest --markers</code> : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/b/tasks_proj/tests $ pytest --markers @pytest.mark.smoke: Run the smoke test test functions @pytest.mark.get: Run the test functions that test tasks.get() @pytest.mark.skip(reason=None): skip the ... ...</code> </pre> <br><p>  Wenn Marker nicht registriert sind, werden sie nicht in der Liste <code>--markers</code> .  Wenn sie registriert sind, werden sie in der Liste angezeigt. Wenn Sie <code>--strict</code> , werden alle fehlerhaften oder nicht registrierten Token als Fehler angezeigt.  Der einzige Unterschied zwischen <code>ch6/a/tasks_proj</code> und <code>ch6/b/tasks_proj</code> ist der Inhalt der Datei pytest.ini.  In <code>ch6/a</code> leer.  Versuchen wir, die Tests auszuf√ºhren, ohne Marker zu registrieren: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/a/tasks_proj/tests $ pytest --strict --tb=line ============================= test session starts ============================= collected 45 items / 2 errors =================================== ERRORS ==================================== ______________________ ERROR collecting func/test_add.py ______________________ 'smoke' not a registered marker ________________ ERROR collecting func/test_api_exceptions.py _________________ 'smoke' not a registered marker !!!!!!!!!!!!!!!!!!! Interrupted: 2 errors during collection !!!!!!!!!!!!!!!!!!! =========================== 2 error in 1.10 seconds ===========================</code> </pre> <br><p>  Wenn Sie Marker in <code>pytest.ini</code> , um Ihre Marker zu registrieren, k√∂nnen Sie Ihren <code>addopts</code> auch <code>--strict</code> <code>addopts</code> w√§hrend Sie gerade dabei sind.  Du wirst mir sp√§ter danken.  Lassen Sie uns fortfahren und dem Aufgabenprojekt eine pytest.ini-Datei hinzuf√ºgen: </p><br><p>  Wenn Sie Marker in <code>pytest.ini</code> , um Ihre Marker zu registrieren, k√∂nnen <code>--strict</code> Ihren <code>addopts</code> auch <code>--strict</code> <code>addopts</code> .  Du wirst mir sp√§ter danken.  Fahren wir fort und f√ºgen die Datei pytest.ini zum Aufgabenprojekt hinzu: </p><br><p>  Wenn Sie Token in <code>pytest.ini</code> , um Token zu registrieren, k√∂nnen Sie auch <code>--strict</code> zu vorhandenen Token mit <code>addopts</code> .  Cool ?!  <code>pytest.ini</code> Sie den Dank <code>pytest.ini</code> und f√ºgen Sie die Datei <code>pytest.ini</code> zum <code>tasks</code> : </p><br><blockquote>  ch6 / b / task_proj / tests / pytest.ini </blockquote><br><pre> <code class="plaintext hljs">[pytest] addopts = -rsxX -l --tb=short --strict markers = smoke: Run the smoke test test functions get: Run the test functions that test tasks.get()</code> </pre> <br><p>  Hier ist die standardm√§√üig bevorzugte Kombination von Flags: </p><br><ul><li>  <code>-rsxX</code> um <code>-rsxX</code> welche Tests √ºbersprungen, fehlgeschlagen oder bestanden wurden. </li><li>  <code>--tb = short</code> f√ºr eine k√ºrzere Ablaufverfolgung bei Fehlern, </li><li>  <code>--strict</code> , um nur deklarierte Token zuzulassen. <br>  Und eine Liste von Markern f√ºr das Projekt. </li></ul><br><p>  Dies sollte es uns erm√∂glichen, Tests durchzuf√ºhren, einschlie√ülich Rauchtests: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/b/tasks_proj/tests $ pytest --strict -m smoke ===================== test session starts ====================== collected 57 items func/test_add.py . func/test_api_exceptions.py .. ===================== 54 tests deselected ====================== =========== 3 passed, 54 deselected in 0.06 seconds ============</code> </pre> <br><h3 id="trebovanie-minimalnoy-versii-pytest">  Mindestanforderung an Pytest </h3><br><p>  Mit <code>minversion</code> Parameter <code>minversion</code> k√∂nnen <code>minversion</code> die minimale Pytest-Version angeben, die f√ºr Tests erwartet wird.  Zum Beispiel wollte ich beim Testen von Gleitkommazahlen <code>approx()</code> verwenden, um die ‚Äûziemlich enge‚Äú Gleichheit in Tests zu bestimmen.  Diese Funktion wurde jedoch erst in Version 3.0 in pytest eingef√ºhrt.  Um Verwirrung zu vermeiden, f√ºge ich Projekten, die <code>approx()</code> Folgendes hinzu: </p><br><pre> <code class="plaintext hljs">[pytest] minversion = 3.0</code> </pre> <br><p>  Wenn also jemand versucht, Tests mit einer √§lteren Version von pytest auszuf√ºhren, wird eine Fehlermeldung angezeigt. </p><br><h3 id="ostanovka-pytest-ot-poiska-v-nepravilnyh-mestah">  Verhindern Sie, dass Pytest an den falschen Stellen sucht </h3><br><p>  Wussten Sie, dass eine der Definitionen von ‚ÄûRekurs‚Äú darin besteht, zweimal in Ihrem eigenen Code zu schw√∂ren?  Nun, nein.  In der Tat bedeutet dies die Ber√ºcksichtigung von Unterverzeichnissen.  pytest erm√∂glicht die Testerkennung durch rekursives Untersuchen einer Reihe von Verzeichnissen.  Es gibt jedoch einige Verzeichnisse, die Sie vom Anzeigen von pytest ausschlie√üen m√∂chten. </p><br><p>  Der Standardwert f√ºr <code>norecurse</code> ist <code>'. * Build dist CVS _darcs {arch} and *.egg. Having '.*'</code> <code>'. * Build dist CVS _darcs {arch} and *.egg. Having '.*'</code>  <code>'. * Build dist CVS _darcs {arch} and *.egg. Having '.*'</code> Ist ein guter Grund, Ihre virtuelle Umgebung '.venv' zu nennen, da nicht alle Verzeichnisse, die mit einem Punkt beginnen, sichtbar sind. </p><br><p>  Im Fall des Tasks-Projekts schadet es nicht, <code>src</code> anzugeben, da das Suchen in Testdateien mit pytest Zeitverschwendung ist. </p><br><pre> <code class="plaintext hljs">[pytest] norecursedirs = .* venv src *.egg dist build</code> </pre> <br><p>  Wenn Sie einen Parameter √ºberschreiben, der bereits einen n√ºtzlichen Wert hat, wie z. B. diesen Parameter, ist es hilfreich, die Standardwerte zu kennen und die ben√∂tigten Werte zur√ºckzugeben, wie ich es im vorherigen Code mit <code>*.egg dist build</code> . <br>  <code>norecursedirs</code> ist eine Art Konsequenz f√ºr <code>norecursedirs</code> wir uns das sp√§ter an. </p><br><h3 id="specifikaciya-dereva-testovogo-kataloga">  Testverzeichnisbaumspezifikation </h3><br><p>  W√§hrend <code>norecursedirs</code> sagt, wo sie suchen sollen, <code>testpaths</code> Testpfade Pytest, wo sie suchen sollen.  <code>testspaths</code> ist eine Liste von Verzeichnissen relativ zum Stammverzeichnis zum Suchen von Tests.  Es wird nur verwendet, wenn das Verzeichnis, die Datei oder die <code>nodeid</code> nicht als Argument angegeben ist. </p><br><p>  Angenommen, f√ºr ein <code>Tasks</code> Projekt legen wir <code>tasks_proj</code> anstelle von tests im Verzeichnis <code>tasks_proj</code> : </p><br><pre> <code class="plaintext hljs">\code\tasks_proj&gt;tree/f . ‚îÇ pytest.ini ‚îÇ ‚îú‚îÄ‚îÄ‚îÄsrc ‚îÇ ‚îî‚îÄ‚îÄ‚îÄtasks ‚îÇ api.py ‚îÇ ... ‚îÇ ‚îî‚îÄ‚îÄ‚îÄtests ‚îÇ conftest.py ‚îÇ pytest.ini ‚îÇ ‚îú‚îÄ‚îÄ‚îÄfunc ‚îÇ test_add.py ‚îÇ ... ‚îÇ ‚îú‚îÄ‚îÄ‚îÄunit ‚îÇ test_task.py ‚îÇ __init__.py ‚îÇ ...</code> </pre> <br><p>  Dann k√∂nnte es sinnvoll sein, die Tests in <code>testpaths</code> : </p><br><pre> <code class="plaintext hljs">[pytest] testpaths = tests</code> </pre> <br><p>  Wenn Sie jetzt pytest aus dem Verzeichnis task_proj <code>tasks_proj</code> , sucht pytest nur in <code>tasks_proj/tests</code> .  Das Problem hierbei ist, dass ich w√§hrend der Entwicklung und des Debuggens von Tests h√§ufig √ºber das Testverzeichnis iteriere, sodass ich ein Unterverzeichnis oder eine Datei problemlos testen kann, ohne den gesamten Pfad anzugeben.  Daher hilft mir diese Option beim interaktiven Testen ein wenig. </p><br><p>  Es eignet sich jedoch hervorragend f√ºr Tests, die von einem Continuous Integration Server oder Tox ausgef√ºhrt werden.  In diesen F√§llen wissen Sie, dass das Stammverzeichnis repariert wird, und Sie k√∂nnen die Verzeichnisse relativ zu diesem festen Stammverzeichnis auflisten.  Dies sind auch die F√§lle, in denen Sie die Testzeit wirklich verk√ºrzen m√∂chten. Daher ist es gro√üartig, die Suche nach Tests loszuwerden. </p><br><p>  Auf den ersten Blick mag es albern erscheinen, sowohl <code>norecursedirs</code> als auch <code>norecursedirs</code> gleichzeitig zu verwenden.  Wie Sie bereits gesehen haben, helfen Testpfade beim interaktiven Testen aus verschiedenen Teilen des Dateisystems nur wenig.  In diesen F√§llen k√∂nnen <code>norecursedirs</code> helfen.  Wenn Sie <code>norecursedirs</code> haben, die keine Tests enthalten, k√∂nnen Sie au√üerdem <code>norecursedirs</code> , um diese zu vermeiden.  Aber was bringt es eigentlich, zus√§tzliche Verzeichnisse in Tests einzuf√ºgen, die keine Tests haben? </p><br><h2 id="izmenenie-pravil-obnaruzheniya-testov">  √Ñndern der Testerkennungsregeln </h2><br><p>  pytest findet Tests, die basierend auf bestimmten Testerkennungsregeln ausgef√ºhrt werden sollen.  Standardregeln f√ºr die Testerkennung: </p><br><p>  ‚Ä¢ Beginnen Sie mit einem oder mehreren Verzeichnissen.  Sie k√∂nnen die Namen von Dateien oder Verzeichnissen in der Befehlszeile angeben.  Wenn Sie nichts angegeben haben, wird das aktuelle Verzeichnis verwendet. <br>  ‚Ä¢ Durchsuchen Sie den Katalog und alle seine Unterverzeichnisse nach Testmodulen. <br>  ‚Ä¢ Ein Testmodul ist eine Datei mit einem √§hnlichen Namen wie <code>test_*.py</code> oder <code>*_test.py</code> . <br>  ‚Ä¢ Suchen Sie in den Testmodulen nach Funktionen, die mit dem Test beginnen <em>.</em> <em><br></em>  <em>‚Ä¢ Suchen Sie nach Klassen, die mit Test beginnen.</em>  <em>Suchen Sie nach Methoden in Klassen, die mit `test beginnen</em> <code>,    </code> <strong>init`</strong> <code>,    </code> . </p><br><p>  Dies sind Standarderkennungsregeln.  Sie k√∂nnen sie jedoch √§ndern. </p><br><h3 id="python_classes">  python_classes </h3><br><p>  Die √ºbliche Regel f√ºr das Finden von Tests f√ºr Pytest und Klassen besteht darin, eine Klasse als potenzielle Testklasse zu betrachten, wenn sie mit <code>Test*</code> beginnt.  Die Klasse kann auch nicht die Methode <code>__init__()</code> .  Aber was ist, wenn wir unsere Testklassen als <code>&lt;something&gt;Test</code> oder <code>&lt;something&gt;Suite</code> m√∂chten?  Hier kommt <code>python_classes</code> ins <code>python_classes</code> : </p><br><pre> <code class="plaintext hljs">[pytest] python_classes = *Test Test* *Suite</code> </pre> <br><p>  Dies erm√∂glicht es uns, die Klassen wie folgt zu benennen: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeleteSuite</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_delete_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_delete_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... ....</code> </pre> <br><h3 id="python_files">  python_files </h3><br><p>  Wie <code>pytest_classes</code> √§ndert <code>python_files</code> die Standard- <code>python_files</code> , die darin besteht, Dateien zu finden, die mit <code>test_*</code> beginnen oder am Ende <code>*_test</code> haben. <br>  Angenommen, Sie haben ein benutzerdefiniertes <code>check_&lt;something&gt;.py</code> in dem Sie alle Ihre Testdateien <code>check_&lt;something&gt;.py</code> .  Scheint vern√ºnftig.  Anstatt alle Ihre Dateien <code>pytest.ini</code> , f√ºgen Sie <code>pytest.ini</code> wie folgt eine Zeile <code>pytest.ini</code> : </p><br><pre> <code class="plaintext hljs">[pytest] python_files = test_* *_test check_*</code> </pre> <br><p>  Sehr einfach.  Jetzt k√∂nnen Sie die Namenskonvention nach und nach √ºbertragen, wenn Sie m√∂chten, oder sie einfach als <code>check_*</code> . </p><br><h3 id="python_functions">  python_functions </h3><br><p>  <code>python_functions</code> wie die beiden vorherigen Einstellungen, jedoch f√ºr Testfunktionen und Methodennamen.  Der Standardwert ist <code>test_*</code> .  Und um <code>check_*</code> hinzuzuf√ºgen - Sie haben es erraten - tun Sie <code>check_*</code> : </p><br><pre> <code class="plaintext hljs">[pytest] python_functions = test_* check_*</code> </pre> <br><p>  Die <code>pytest</code> Namenskonventionen scheinen nicht so restriktiv zu sein, oder?  Wenn Ihnen die Standardbenennungskonvention nicht gef√§llt, √§ndern Sie sie einfach.  Ich fordere Sie jedoch dringend auf, einen zwingenderen Grund f√ºr solche Entscheidungen zu haben.  Die Migration von Hunderten von Testdateien ist definitiv ein guter Grund. </p><br><h2 id="zapret-xpass">  XPASS-Verbot </h2><br><p>  Das Setzen von <code>xfail_strict = true</code> bedeutet, dass die mit <code>@pytest.mark.xfail</code> gekennzeichneten Tests nicht als <code>@pytest.mark.xfail</code> erkannt werden.  Ich denke, diese Einstellung sollte immer sein.  Weitere Informationen zum <code>xfail</code> Token <code>xfail</code> Sie unter ‚ÄûMarkieren von Tests, die auf einen Fehler warten‚Äú auf Seite 37. </p><br><h2 id="predotvraschenie-konfliktov-imen-faylov">  Verhindern Sie Konflikte mit Dateinamen </h2><br><p>  Die N√ºtzlichkeit, die Datei <code>__init__.py</code> in jedem Test-Unterverzeichnis des Projekts zu haben, hat mich lange verwirrt.  Der Unterschied, ob man sie hat oder nicht, ist jedoch einfach.  Wenn Sie in all Ihren Test-Unterverzeichnissen <code>__init__.py</code> Dateien haben, k√∂nnen Sie denselben Testdateinamen in mehreren Verzeichnissen haben.  Und wenn nicht, dann wird dies nicht funktionieren. </p><br><p>  Hier ist ein Beispiel.  Verzeichnis <code>a</code> und <code>b</code> beide die Datei <code>test_foo.py</code> .  Es spielt keine Rolle, was diese Dateien enthalten, aber f√ºr dieses Beispiel sehen sie folgenderma√üen aus: </p><br><blockquote>  <strong>ch6 / dups / a / test_foo.py</strong> <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><br>  <strong>ch6 / dups / b / test_foo.py</strong> <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_b</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br></blockquote><p>  Mit dieser Verzeichnisstruktur: </p><br><pre> <code class="plaintext hljs">dups ‚îú‚îÄ‚îÄ a ‚îÇ ‚îî‚îÄ‚îÄ test_foo.py ‚îî‚îÄ‚îÄ b ‚îî‚îÄ‚îÄ test_foo.py</code> </pre> <br><p>  Diese Dateien haben nicht einmal den gleichen Inhalt, aber die Tests sind besch√§digt.  Sie k√∂nnen sie separat ausf√ºhren, es gibt jedoch keine M√∂glichkeit, <code>pytest</code> √ºber das Verzeichnis <code>pytest</code> <code>dups</code> : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/dups $ pytest a ============================= test session starts ============================= collected 1 item a\test_foo.py . ========================== 1 passed in 0.05 seconds =========================== $ pytest b ============================= test session starts ============================= collected 1 item b\test_foo.py . ========================== 1 passed in 0.05 seconds =========================== $ pytest ============================= test session starts ============================= collected 1 item / 1 errors =================================== ERRORS ==================================== _______________________ ERROR collecting b/test_foo.py ________________________ import file mismatch: imported module 'test_foo' has this __file__ attribute: /path/to/code/ch6/dups/a/test_foo.py which is not the same as the test file we want to collect: /path/to/code/ch6/dups/b/test_foo.py HINT: remove __pycache__ / .pyc files and/or use a unique basename for your test file modules !!!!!!!!!!!!!!!!!!! Interrupted: 1 errors during collection !!!!!!!!!!!!!!!!!!! =========================== 1 error in 0.34 seconds ===========================</code> </pre> <br><p>  Nichts ist klar! <br>  Diese Fehlermeldung zeigt nicht an, was schief gelaufen ist. </p><br><p>  Um diesen Test zu beheben, f√ºgen Sie einfach die leere Datei <code>__init__.py</code> zu den Unterverzeichnissen hinzu.  Hier ist ein Beispiel f√ºr das Verzeichnis <code>dups_fixed</code> mit denselben doppelten Dateinamen, jedoch mit <code>__init__.py</code> Dateien <code>__init__.py</code> : </p><br><pre> <code class="plaintext hljs">dups_fixed/ ‚îú‚îÄ‚îÄ a ‚îÇ ‚îú‚îÄ‚îÄ __init__.py ‚îÇ ‚îî‚îÄ‚îÄ test_foo.py ‚îî‚îÄ‚îÄ b ‚îú‚îÄ‚îÄ __init__.py ‚îî‚îÄ‚îÄ test_foo.py</code> </pre> <br><p>  Versuchen wir es jetzt noch einmal von der obersten Ebene in <code>dups_fixed</code> : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/ch6/dups_fixed/ $ pytest ============================= test session starts ============================= collected 2 items a\test_foo.py . b\test_foo.py . ========================== 2 passed in 0.15 seconds ===========================</code> </pre> <br><p>  Also wird es besser sein. </p><br><p>  Nat√ºrlich k√∂nnen Sie sich selbst davon √ºberzeugen, dass Sie niemals doppelte Dateinamen haben werden, also spielt das keine Rolle.  Alles ist normal.  Aber Projekte wachsen und Testkataloge wachsen, und Sie m√∂chten auf jeden Fall warten, bis Ihnen dies passiert, bevor Sie sich darum k√ºmmern?  Ich sage, legen Sie diese Dateien einfach dort ab.  Machen Sie es sich zur Gewohnheit und machen Sie sich keine Sorgen mehr. </p><br><h2 id="uprazhneniya">  √úbungen </h2><br><p>  In Kapitel 5, Plugins, auf Seite 95 haben Sie ein Plugin namens pytest-nice erstellt, das eine Befehlszeilenoption --nice enth√§lt.  Erweitern wir das um eine pytest.ini-Option namens nice. </p><br><p>  In Kapitel 5, ‚ÄûPlugins‚Äú auf Seite 95, haben Sie ein Plugin namens <code>pytest-nice</code> , das die <code>--nice</code> <code>pytest-nice</code> enth√§lt.  Erweitern wir dies um die Option <code>pytest.ini</code> Namen <code>nice</code> . </p><br><ol><li>  F√ºgen Sie der Hook-Funktion <code>pytest_addoption</code> <code>pytest_nice.py</code> die folgende Zeile <code>pytest_addoption</code> : <code>parser.addini('nice', type='bool', help='Turn failures into opportunities.')</code> </li><li>  Stellen im Plugin, die <code>getoption()</code> m√ºssen auch <code>getini('nice')</code> aufrufen.  Nehmen Sie diese √Ñnderungen vor. </li><li>  √úberpr√ºfen Sie dies manuell, indem Sie der Datei <code>pytest.ini</code> <code>nice</code> <code>pytest.ini</code> . </li><li>  Plugin-Tests nicht vergessen.  F√ºgen Sie einen Test hinzu, um zu √ºberpr√ºfen, ob der <code>nice</code> Parameter aus <code>pytest.ini</code> ordnungsgem√§√ü funktioniert. </li><li>  F√ºgen Sie dem Plugin-Verzeichnis Tests hinzu.  Sie m√ºssen einige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zus√§tzliche Pytester-Funktionen finden</a> . </li></ol><br><h2 id="chto-dalshe">  Was weiter </h2><br><p>  W√§hrend pytest an sich extrem leistungsf√§hig ist - insbesondere mit Plugins - l√§sst es sich auch gut in andere Softwareentwicklungs- und Softwaretest-Tools integrieren.  Im n√§chsten Kapitel werden wir die Verwendung von Pytest in Verbindung mit anderen leistungsstarken Testwerkzeugen untersuchen. </p><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zur√ºck</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weiter</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448796/">https://habr.com/ru/post/de448796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448784/index.html">Neue Funktionen f√ºr Erweiterungsautoren in Visual Studio 2019 Version 16.1</a></li>
<li><a href="../de448786/index.html">Python-Test mit Pytest. KAPITEL 3 Pytest-Vorrichtungen</a></li>
<li><a href="../de448788/index.html">Python-Test mit Pytest. Kapitel 2, Schreiben von Testfunktionen</a></li>
<li><a href="../de448790/index.html">SpaceVIL - plattform√ºbergreifendes GUI-Framework f√ºr die Entwicklung auf .Net Core, .Net Standard und JVM</a></li>
<li><a href="../de448794/index.html">Python-Test mit Pytest. Plugins KAPITEL 5</a></li>
<li><a href="../de448798/index.html">Python-Test mit Pytest. Verwenden von pytest mit anderen Tools, KAPITEL 7</a></li>
<li><a href="../de448800/index.html">Konfigurieren Sie Visual Studio in Ihrer Organisation mit .vsconfig</a></li>
<li><a href="../de448802/index.html">Mit Portalen denken: Portale in Unreal Engine 4 erstellen</a></li>
<li><a href="../de448804/index.html">Vorbereitungen f√ºr die geh√§rtete Laufzeit und den Notar von macOS</a></li>
<li><a href="../de448806/index.html">Erstellen eines Erweiterungssystems in der Qt-Bibliothek</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>