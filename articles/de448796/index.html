<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏾 🥀 🐜 Python-Test mit Pytest. Konfiguration, KAPITEL 6 🌭 🌰 🧑🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zurück Weiter 


 In diesem Kapitel werden wir uns die Konfigurationsdateien ansehen, die sich auf pytest auswirken, diskutieren, wie pytest sein Verh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python-Test mit Pytest. Konfiguration, KAPITEL 6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448796/"><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zurück</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weiter</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p><br><p>  <em>In diesem Kapitel werden wir uns die Konfigurationsdateien ansehen, die sich auf pytest auswirken, diskutieren, wie pytest sein Verhalten basierend auf ihnen ändert, und einige Änderungen an den Konfigurationsdateien des Aufgabenprojekts vornehmen.</em> </p><br><p><img src="https://habrastorage.org/webt/hd/--/9w/hd--9w134j0rxhmxftrflbbdopy.png"></p><a name="habracut"></a><br><p>  Die Beispiele in diesem Buch wurden mit Python 3.6 und pytest 3.2 geschrieben.  pytest 3.2 unterstützt Python 2.6, 2.7 und Python 3.3+. </p><br><blockquote> Der Quellcode für das Aufgabenprojekt sowie für alle in diesem Buch gezeigten Tests ist unter dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="https://pragprog.com/titles/bopytest/source_code">Link</a> auf der Webseite des Buches unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="https://pragprog.com/titles/bopytest">pragprog.com verfügbar</a> .  Sie müssen den Quellcode nicht herunterladen, um den Testcode zu verstehen.  Der Testcode wird in den Beispielen in einer praktischen Form dargestellt.  Um jedoch die Aufgaben des Projekts zu verfolgen oder Testbeispiele anzupassen, um Ihr eigenes Projekt zu testen (Ihre Hände sind losgebunden!), Müssen Sie auf die Webseite des Buches gehen und die Arbeit herunterladen.  Dort, auf der Webseite des Buches, gibt es einen Link für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="https://pragprog.com/titles/bopytest/errata">Errata-</a> Nachrichten und ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="https://forums.pragprog.com/forums/438">Diskussionsforum</a> . </blockquote><p>  Unter dem Spoiler befindet sich eine Liste der Artikel dieser Reihe. </p><br><div class="spoiler">  <b class="spoiler_title">Inhaltsverzeichnis</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Einführung</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 1: Erste Schritte mit Pytest</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 2: Schreiben von Testfunktionen</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 3: Pytest-Vorrichtungen</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 4: Eingebaute Vorrichtungen</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 5: Plugins</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 6: Konfiguration</strong></a> (Dieser Artikel) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 7: Verwenden von pytest mit anderen Tools</strong></a> </li></ul></div></div><br><h2 id="konfiguraciya">  Konfiguration </h2><br><p>  Bisher habe ich in diesem Buch über verschiedene Nicht-Test-Dateien gesprochen, die sich hauptsächlich nebenbei auf pytest auswirken, mit Ausnahme von conftest.py, auf das ich in Kapitel 5, Plugins, auf Seite 95 ausführlich eingegangen bin. In diesem Kapitel werden wir uns die Konfigurationsdateien ansehen. Dies wirkt sich auf pytest aus. Besprechen Sie, wie pytest sein Verhalten basierend darauf ändert, und nehmen Sie einige Änderungen an den Konfigurationsdateien des Aufgabenprojekts vor. </p><br><h2 id="ponimanie-faylov-konfiguracii-pytest">  Grundlegendes zu Pytest-Konfigurationsdateien </h2><br><p>  Bevor ich Ihnen erkläre, wie Sie das Standardverhalten in pytest ändern können, gehen wir alle Nicht-Testdateien in pytest durch und insbesondere, wer sich um sie kümmern sollte. </p><br><p>  Sie sollten Folgendes wissen: </p><br><ul><li> <em>pytest.ini</em> : Dies ist die Hauptkonfigurationsdatei von Pytest, mit der Sie das Standardverhalten ändern können.  Da Sie einige Konfigurationsänderungen vornehmen können, ist der größte Teil dieses Kapitels den Einstellungen gewidmet, die Sie in <code>pytest.ini</code> . </li><li>  <em>conftest.py</em> : Dies ist ein lokales Plugin, mit dem Hook-Funktionen und Fixtures mit dem Verzeichnis verbunden werden können, in dem die Datei <code>conftest.py</code> sowie mit allen Unterverzeichnissen.  Die Datei <code>conftest.py</code> in Kapitel 5 „Plugins“ auf Seite 95 beschrieben. </li><li>  <em><code>__init__.py</code></em> : Wenn diese Datei in jedes Test-Unterverzeichnis gestellt wird, können Sie identische Testdateinamen in mehreren <em><code>__init__.py</code></em> haben.  Ein Beispiel dafür, was ohne <code>__init__.py</code> Dateien in <code>__init__.py</code> schief gehen würde, finden <code>__init__.py</code> im Artikel „Vermeiden von Dateinamenkollisionen“ auf Seite 120. </li></ul><br><p>  Wenn Sie Tox verwenden, interessieren Sie sich für: </p><br><ul><li>  <em>tox.ini</em> : Diese Datei ähnelt <code>pytest.ini</code> , ist jedoch für <code>tox</code> .  Sie können hier jedoch Ihre <code>pytest</code> Konfiguration <code>pytest</code> anstatt sowohl die <code>tox.ini</code> Datei als auch die <code>pytest.ini</code> Datei zu haben, wodurch Sie eine Konfigurationsdatei speichern.  Tox wird in Kapitel 7, „Verwenden von Pytest mit anderen Tools“, auf Seite 125 erläutert. </li></ul><br><p>  Wenn Sie ein Python-Paket (z. B. Aufgaben) verteilen möchten, ist diese Datei von Interesse: </p><br><ul><li>  <em>setup.cfg</em> : Dies ist auch eine INI-Datei, die das Verhalten von <code>setup.py</code> .  Sie können <code>setup.py</code> einige Zeilen <code>setup.py</code> , um <code>python setup.py test</code> und alle Ihre pytest-Tests auszuführen.  Wenn Sie das Paket verteilen, verfügen Sie möglicherweise bereits über die Datei <code>setup.cfg</code> und können diese Datei zum Speichern der Pytest-Konfiguration verwenden.  Wie das geht, erfahren Sie in Anhang 4, „Packen und Verteilen von Python-Projekten“, auf Seite 175. </li></ul><br><p>  Unabhängig davon, in welche Datei Sie die Pytest-Konfiguration einfügen, ist das Format im Wesentlichen dasselbe. </p><br><p>  Für <code>pytest.ini</code> : </p><br><blockquote>  <strong>ch6 / format / pytest.ini</strong> </blockquote><br><pre> <code class="plaintext hljs">[pytest] addopts = -rsxX -l --tb=short --strict xfail_strict = true ... more options ...</code> </pre> <br><p>  Für <code>tox.ini</code> : </p><br><blockquote>  <strong>ch6 / format / tox.ini</strong> </blockquote><br><pre> <code class="plaintext hljs">... tox specific stuff ... [pytest] addopts = -rsxX -l --tb=short --strict xfail_strict = true ... more options ...</code> </pre> <br><p>  Für <code>setup.cfg</code> : </p><br><blockquote>  <strong>ch6 / format / setup.cfg</strong> </blockquote><br><pre> <code class="plaintext hljs">... packaging specific stuff ... [tool:pytest] addopts = -rsxX -l --tb=short --strict xfail_strict = true ... more options ...</code> </pre> <br><p>  Der einzige Unterschied besteht darin, dass der Abschnittskopf für setup.cfg <code>[tool:pytest]</code> anstelle von <code>[pytest]</code> . </p><br><h3 id="list-the-valid-ini-file-options-with-pytest-help">  Listen Sie die gültigen INI-Datei-Optionen mit pytest –help auf </h3><br><p>  Eine Liste aller gültigen Parameter für <code>pytest.ini</code> von <code>pytest --help</code> : </p><br><pre> <code class="plaintext hljs">$ pytest --help ... [pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg file found: markers (linelist) markers for test functions empty_parameter_set_mark (string) default marker for empty parametersets norecursedirs (args) directory patterns to avoid for recursion testpaths (args) directories to search for tests when no files or directories are given in the command line. console_output_style (string) console output: classic or with additional progress information (classic|progress). usefixtures (args) list of default fixtures to be used with this project python_files (args) glob-style file patterns for Python test module discovery python_classes (args) prefixes or glob names for Python test class discovery python_functions (args) prefixes or glob names for Python test function and method discovery xfail_strict (bool) default for the strict parameter of xfail markers when not given explicitly (default: False) junit_suite_name (string) Test suite name for JUnit report junit_logging (string) Write captured log messages to JUnit report: one of no|system-out|system-err doctest_optionflags (args) option flags for doctests doctest_encoding (string) encoding used for doctest files cache_dir (string) cache directory path. filterwarnings (linelist) Each line specifies a pattern for warnings.filterwarnings. Processed after -W and --pythonwarnings. log_print (bool) default value for --no-print-logs log_level (string) default value for --log-level log_format (string) default value for --log-format log_date_format (string) default value for --log-date-format log_cli (bool) enable log display during test run (also known as "live logging"). log_cli_level (string) default value for --log-cli-level log_cli_format (string) default value for --log-cli-format log_cli_date_format (string) default value for --log-cli-date-format log_file (string) default value for --log-file log_file_level (string) default value for --log-file-level log_file_format (string) default value for --log-file-format log_file_date_format (string) default value for --log-file-date-format addopts (args) extra command line options minversion (string) minimally required pytest version xvfb_width (string) Width of the Xvfb display xvfb_height (string) Height of the Xvfb display xvfb_colordepth (string) Color depth of the Xvfb display xvfb_args (args) Additional arguments for Xvfb xvfb_xauth (bool) Generate an Xauthority token for Xvfb. Needs xauth. ...</code> </pre> <br><p>  Alle diese Einstellungen werden in diesem Kapitel <code>doctest_optionflags</code> , mit Ausnahme der <code>doctest_optionflags</code> , die in Kapitel 7, „Verwenden von pytest mit anderen Tools“, auf Seite 125 erläutert werden. </p><br><h3 id="plaginy-mogut-dobavlyat-opcii-ini-faylov">  Plugins können INI-Dateioptionen hinzufügen </h3><br><p>  Die vorherige Liste der Einstellungen ist keine Konstante.  Für Plugins (und conftest.py-Dateien) können INI-Dateioptionen hinzugefügt werden.  Hinzugefügte Optionen werden auch zur Ausgabe des Befehls pytest --help hinzugefügt. <br>  Schauen wir uns nun einige Konfigurationsänderungen an, die wir mithilfe der integrierten Einstellungen der INI-Datei vornehmen können, die in Core Pytest verfügbar sind. </p><br><h3 id="izmenenie-parametrov-komandnoy-stroki-po-umolchaniyu">  Ändern Sie die Standardbefehlszeilenoptionen </h3><br><p>  Sie haben bereits einige Befehlszeilenoptionen für <em>pytest verwendet</em> , z. B. <code>-v/--verbose</code> für die ausführliche Ausgabe <code>-l/--showlocals</code> , um lokale Variablen mit einem Stack-Trace für fehlgeschlagene Tests <code>-l/--showlocals</code> .  Möglicherweise verwenden Sie einige dieser <code>options—or</code> bevorzugen <code>them—for a project</code> .  Wenn Sie in <code>pytest.ini</code> für die benötigten Parameter installieren, müssen Sie diese nicht mehr eingeben.  Hier ist ein Set, das mir gefällt: </p><br><pre> <code class="plaintext hljs">[pytest] addopts = -rsxX -l --tb=short --strict</code> </pre> <br><p>  Mit <code>-rsxX</code> kann pytest die Gründe für alle <code>skipped</code> , <code>xfailed</code> oder nicht <code>xpassed</code> Tests <code>xpassed</code> .  Mit dem Schalter <code>-l</code> kann pytest bei jedem Fehler eine Stapelverfolgung für lokale Variablen anzeigen.  <code>--tb=short</code> entfernt den größten Teil der Stapelverfolgung.  Die Datei und die Zeilennummer bleiben jedoch erhalten.  Die <code>--strict</code> verbietet die Verwendung von Token, wenn diese nicht in der Konfigurationsdatei registriert sind.  Wie das geht, erfahren Sie im nächsten Abschnitt. </p><br><h3 id="registraciya-markerov-chtoby-izbezhat-opechatok-markera">  Markerregistrierung, um Tippfehler zu vermeiden </h3><br><p>  Benutzerdefinierte Markierungen, wie unter „Beschriften von Testfunktionen“ auf Seite 31 beschrieben, eignen sich hervorragend, um eine Teilmenge von Tests zu markieren, die mit einer bestimmten Markierung ausgeführt werden sollen.  Es ist jedoch zu einfach, einen Fehler in der Markierung zu machen, und letztendlich sind einige Tests mit <code>@pytest.mark.smoke</code> und einige mit <code>@pytest.mark.somke</code> .  Standardmäßig ist dies kein Fehler.  pytest glaubt nur, dass Sie zwei Marker erstellt haben.  Dies kann jedoch behoben werden, indem Token in pytest.ini registriert werden, beispielsweise wie folgt: </p><br><pre> <code class="plaintext hljs">[pytest] ... markers = smoke: Run the smoke test test functions get: Run the test functions that test tasks.get() ...</code> </pre> <br><p>  Wenn Sie diese Marker registrieren, können Sie sie jetzt auch mit <code>pytest --markers</code> mit ihren Beschreibungen <code>pytest --markers</code> : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/b/tasks_proj/tests $ pytest --markers @pytest.mark.smoke: Run the smoke test test functions @pytest.mark.get: Run the test functions that test tasks.get() @pytest.mark.skip(reason=None): skip the ... ...</code> </pre> <br><p>  Wenn Marker nicht registriert sind, werden sie nicht in der Liste <code>--markers</code> .  Wenn sie registriert sind, werden sie in der Liste angezeigt. Wenn Sie <code>--strict</code> , werden alle fehlerhaften oder nicht registrierten Token als Fehler angezeigt.  Der einzige Unterschied zwischen <code>ch6/a/tasks_proj</code> und <code>ch6/b/tasks_proj</code> ist der Inhalt der Datei pytest.ini.  In <code>ch6/a</code> leer.  Versuchen wir, die Tests auszuführen, ohne Marker zu registrieren: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/a/tasks_proj/tests $ pytest --strict --tb=line ============================= test session starts ============================= collected 45 items / 2 errors =================================== ERRORS ==================================== ______________________ ERROR collecting func/test_add.py ______________________ 'smoke' not a registered marker ________________ ERROR collecting func/test_api_exceptions.py _________________ 'smoke' not a registered marker !!!!!!!!!!!!!!!!!!! Interrupted: 2 errors during collection !!!!!!!!!!!!!!!!!!! =========================== 2 error in 1.10 seconds ===========================</code> </pre> <br><p>  Wenn Sie Marker in <code>pytest.ini</code> , um Ihre Marker zu registrieren, können Sie Ihren <code>addopts</code> auch <code>--strict</code> <code>addopts</code> während Sie gerade dabei sind.  Du wirst mir später danken.  Lassen Sie uns fortfahren und dem Aufgabenprojekt eine pytest.ini-Datei hinzufügen: </p><br><p>  Wenn Sie Marker in <code>pytest.ini</code> , um Ihre Marker zu registrieren, können <code>--strict</code> Ihren <code>addopts</code> auch <code>--strict</code> <code>addopts</code> .  Du wirst mir später danken.  Fahren wir fort und fügen die Datei pytest.ini zum Aufgabenprojekt hinzu: </p><br><p>  Wenn Sie Token in <code>pytest.ini</code> , um Token zu registrieren, können Sie auch <code>--strict</code> zu vorhandenen Token mit <code>addopts</code> .  Cool ?!  <code>pytest.ini</code> Sie den Dank <code>pytest.ini</code> und fügen Sie die Datei <code>pytest.ini</code> zum <code>tasks</code> : </p><br><blockquote>  ch6 / b / task_proj / tests / pytest.ini </blockquote><br><pre> <code class="plaintext hljs">[pytest] addopts = -rsxX -l --tb=short --strict markers = smoke: Run the smoke test test functions get: Run the test functions that test tasks.get()</code> </pre> <br><p>  Hier ist die standardmäßig bevorzugte Kombination von Flags: </p><br><ul><li>  <code>-rsxX</code> um <code>-rsxX</code> welche Tests übersprungen, fehlgeschlagen oder bestanden wurden. </li><li>  <code>--tb = short</code> für eine kürzere Ablaufverfolgung bei Fehlern, </li><li>  <code>--strict</code> , um nur deklarierte Token zuzulassen. <br>  Und eine Liste von Markern für das Projekt. </li></ul><br><p>  Dies sollte es uns ermöglichen, Tests durchzuführen, einschließlich Rauchtests: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/b/tasks_proj/tests $ pytest --strict -m smoke ===================== test session starts ====================== collected 57 items func/test_add.py . func/test_api_exceptions.py .. ===================== 54 tests deselected ====================== =========== 3 passed, 54 deselected in 0.06 seconds ============</code> </pre> <br><h3 id="trebovanie-minimalnoy-versii-pytest">  Mindestanforderung an Pytest </h3><br><p>  Mit <code>minversion</code> Parameter <code>minversion</code> können <code>minversion</code> die minimale Pytest-Version angeben, die für Tests erwartet wird.  Zum Beispiel wollte ich beim Testen von Gleitkommazahlen <code>approx()</code> verwenden, um die „ziemlich enge“ Gleichheit in Tests zu bestimmen.  Diese Funktion wurde jedoch erst in Version 3.0 in pytest eingeführt.  Um Verwirrung zu vermeiden, füge ich Projekten, die <code>approx()</code> Folgendes hinzu: </p><br><pre> <code class="plaintext hljs">[pytest] minversion = 3.0</code> </pre> <br><p>  Wenn also jemand versucht, Tests mit einer älteren Version von pytest auszuführen, wird eine Fehlermeldung angezeigt. </p><br><h3 id="ostanovka-pytest-ot-poiska-v-nepravilnyh-mestah">  Verhindern Sie, dass Pytest an den falschen Stellen sucht </h3><br><p>  Wussten Sie, dass eine der Definitionen von „Rekurs“ darin besteht, zweimal in Ihrem eigenen Code zu schwören?  Nun, nein.  In der Tat bedeutet dies die Berücksichtigung von Unterverzeichnissen.  pytest ermöglicht die Testerkennung durch rekursives Untersuchen einer Reihe von Verzeichnissen.  Es gibt jedoch einige Verzeichnisse, die Sie vom Anzeigen von pytest ausschließen möchten. </p><br><p>  Der Standardwert für <code>norecurse</code> ist <code>'. * Build dist CVS _darcs {arch} and *.egg. Having '.*'</code> <code>'. * Build dist CVS _darcs {arch} and *.egg. Having '.*'</code>  <code>'. * Build dist CVS _darcs {arch} and *.egg. Having '.*'</code> Ist ein guter Grund, Ihre virtuelle Umgebung '.venv' zu nennen, da nicht alle Verzeichnisse, die mit einem Punkt beginnen, sichtbar sind. </p><br><p>  Im Fall des Tasks-Projekts schadet es nicht, <code>src</code> anzugeben, da das Suchen in Testdateien mit pytest Zeitverschwendung ist. </p><br><pre> <code class="plaintext hljs">[pytest] norecursedirs = .* venv src *.egg dist build</code> </pre> <br><p>  Wenn Sie einen Parameter überschreiben, der bereits einen nützlichen Wert hat, wie z. B. diesen Parameter, ist es hilfreich, die Standardwerte zu kennen und die benötigten Werte zurückzugeben, wie ich es im vorherigen Code mit <code>*.egg dist build</code> . <br>  <code>norecursedirs</code> ist eine Art Konsequenz für <code>norecursedirs</code> wir uns das später an. </p><br><h3 id="specifikaciya-dereva-testovogo-kataloga">  Testverzeichnisbaumspezifikation </h3><br><p>  Während <code>norecursedirs</code> sagt, wo sie suchen sollen, <code>testpaths</code> Testpfade Pytest, wo sie suchen sollen.  <code>testspaths</code> ist eine Liste von Verzeichnissen relativ zum Stammverzeichnis zum Suchen von Tests.  Es wird nur verwendet, wenn das Verzeichnis, die Datei oder die <code>nodeid</code> nicht als Argument angegeben ist. </p><br><p>  Angenommen, für ein <code>Tasks</code> Projekt legen wir <code>tasks_proj</code> anstelle von tests im Verzeichnis <code>tasks_proj</code> : </p><br><pre> <code class="plaintext hljs">\code\tasks_proj&gt;tree/f . │ pytest.ini │ ├───src │ └───tasks │ api.py │ ... │ └───tests │ conftest.py │ pytest.ini │ ├───func │ test_add.py │ ... │ ├───unit │ test_task.py │ __init__.py │ ...</code> </pre> <br><p>  Dann könnte es sinnvoll sein, die Tests in <code>testpaths</code> : </p><br><pre> <code class="plaintext hljs">[pytest] testpaths = tests</code> </pre> <br><p>  Wenn Sie jetzt pytest aus dem Verzeichnis task_proj <code>tasks_proj</code> , sucht pytest nur in <code>tasks_proj/tests</code> .  Das Problem hierbei ist, dass ich während der Entwicklung und des Debuggens von Tests häufig über das Testverzeichnis iteriere, sodass ich ein Unterverzeichnis oder eine Datei problemlos testen kann, ohne den gesamten Pfad anzugeben.  Daher hilft mir diese Option beim interaktiven Testen ein wenig. </p><br><p>  Es eignet sich jedoch hervorragend für Tests, die von einem Continuous Integration Server oder Tox ausgeführt werden.  In diesen Fällen wissen Sie, dass das Stammverzeichnis repariert wird, und Sie können die Verzeichnisse relativ zu diesem festen Stammverzeichnis auflisten.  Dies sind auch die Fälle, in denen Sie die Testzeit wirklich verkürzen möchten. Daher ist es großartig, die Suche nach Tests loszuwerden. </p><br><p>  Auf den ersten Blick mag es albern erscheinen, sowohl <code>norecursedirs</code> als auch <code>norecursedirs</code> gleichzeitig zu verwenden.  Wie Sie bereits gesehen haben, helfen Testpfade beim interaktiven Testen aus verschiedenen Teilen des Dateisystems nur wenig.  In diesen Fällen können <code>norecursedirs</code> helfen.  Wenn Sie <code>norecursedirs</code> haben, die keine Tests enthalten, können Sie außerdem <code>norecursedirs</code> , um diese zu vermeiden.  Aber was bringt es eigentlich, zusätzliche Verzeichnisse in Tests einzufügen, die keine Tests haben? </p><br><h2 id="izmenenie-pravil-obnaruzheniya-testov">  Ändern der Testerkennungsregeln </h2><br><p>  pytest findet Tests, die basierend auf bestimmten Testerkennungsregeln ausgeführt werden sollen.  Standardregeln für die Testerkennung: </p><br><p>  • Beginnen Sie mit einem oder mehreren Verzeichnissen.  Sie können die Namen von Dateien oder Verzeichnissen in der Befehlszeile angeben.  Wenn Sie nichts angegeben haben, wird das aktuelle Verzeichnis verwendet. <br>  • Durchsuchen Sie den Katalog und alle seine Unterverzeichnisse nach Testmodulen. <br>  • Ein Testmodul ist eine Datei mit einem ähnlichen Namen wie <code>test_*.py</code> oder <code>*_test.py</code> . <br>  • Suchen Sie in den Testmodulen nach Funktionen, die mit dem Test beginnen <em>.</em> <em><br></em>  <em>• Suchen Sie nach Klassen, die mit Test beginnen.</em>  <em>Suchen Sie nach Methoden in Klassen, die mit `test beginnen</em> <code>,    </code> <strong>init`</strong> <code>,    </code> . </p><br><p>  Dies sind Standarderkennungsregeln.  Sie können sie jedoch ändern. </p><br><h3 id="python_classes">  python_classes </h3><br><p>  Die übliche Regel für das Finden von Tests für Pytest und Klassen besteht darin, eine Klasse als potenzielle Testklasse zu betrachten, wenn sie mit <code>Test*</code> beginnt.  Die Klasse kann auch nicht die Methode <code>__init__()</code> .  Aber was ist, wenn wir unsere Testklassen als <code>&lt;something&gt;Test</code> oder <code>&lt;something&gt;Suite</code> möchten?  Hier kommt <code>python_classes</code> ins <code>python_classes</code> : </p><br><pre> <code class="plaintext hljs">[pytest] python_classes = *Test Test* *Suite</code> </pre> <br><p>  Dies ermöglicht es uns, die Klassen wie folgt zu benennen: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeleteSuite</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_delete_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_delete_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... ....</code> </pre> <br><h3 id="python_files">  python_files </h3><br><p>  Wie <code>pytest_classes</code> ändert <code>python_files</code> die Standard- <code>python_files</code> , die darin besteht, Dateien zu finden, die mit <code>test_*</code> beginnen oder am Ende <code>*_test</code> haben. <br>  Angenommen, Sie haben ein benutzerdefiniertes <code>check_&lt;something&gt;.py</code> in dem Sie alle Ihre Testdateien <code>check_&lt;something&gt;.py</code> .  Scheint vernünftig.  Anstatt alle Ihre Dateien <code>pytest.ini</code> , fügen Sie <code>pytest.ini</code> wie folgt eine Zeile <code>pytest.ini</code> : </p><br><pre> <code class="plaintext hljs">[pytest] python_files = test_* *_test check_*</code> </pre> <br><p>  Sehr einfach.  Jetzt können Sie die Namenskonvention nach und nach übertragen, wenn Sie möchten, oder sie einfach als <code>check_*</code> . </p><br><h3 id="python_functions">  python_functions </h3><br><p>  <code>python_functions</code> wie die beiden vorherigen Einstellungen, jedoch für Testfunktionen und Methodennamen.  Der Standardwert ist <code>test_*</code> .  Und um <code>check_*</code> hinzuzufügen - Sie haben es erraten - tun Sie <code>check_*</code> : </p><br><pre> <code class="plaintext hljs">[pytest] python_functions = test_* check_*</code> </pre> <br><p>  Die <code>pytest</code> Namenskonventionen scheinen nicht so restriktiv zu sein, oder?  Wenn Ihnen die Standardbenennungskonvention nicht gefällt, ändern Sie sie einfach.  Ich fordere Sie jedoch dringend auf, einen zwingenderen Grund für solche Entscheidungen zu haben.  Die Migration von Hunderten von Testdateien ist definitiv ein guter Grund. </p><br><h2 id="zapret-xpass">  XPASS-Verbot </h2><br><p>  Das Setzen von <code>xfail_strict = true</code> bedeutet, dass die mit <code>@pytest.mark.xfail</code> gekennzeichneten Tests nicht als <code>@pytest.mark.xfail</code> erkannt werden.  Ich denke, diese Einstellung sollte immer sein.  Weitere Informationen zum <code>xfail</code> Token <code>xfail</code> Sie unter „Markieren von Tests, die auf einen Fehler warten“ auf Seite 37. </p><br><h2 id="predotvraschenie-konfliktov-imen-faylov">  Verhindern Sie Konflikte mit Dateinamen </h2><br><p>  Die Nützlichkeit, die Datei <code>__init__.py</code> in jedem Test-Unterverzeichnis des Projekts zu haben, hat mich lange verwirrt.  Der Unterschied, ob man sie hat oder nicht, ist jedoch einfach.  Wenn Sie in all Ihren Test-Unterverzeichnissen <code>__init__.py</code> Dateien haben, können Sie denselben Testdateinamen in mehreren Verzeichnissen haben.  Und wenn nicht, dann wird dies nicht funktionieren. </p><br><p>  Hier ist ein Beispiel.  Verzeichnis <code>a</code> und <code>b</code> beide die Datei <code>test_foo.py</code> .  Es spielt keine Rolle, was diese Dateien enthalten, aber für dieses Beispiel sehen sie folgendermaßen aus: </p><br><blockquote>  <strong>ch6 / dups / a / test_foo.py</strong> <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><br>  <strong>ch6 / dups / b / test_foo.py</strong> <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_b</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br></blockquote><p>  Mit dieser Verzeichnisstruktur: </p><br><pre> <code class="plaintext hljs">dups ├── a │ └── test_foo.py └── b └── test_foo.py</code> </pre> <br><p>  Diese Dateien haben nicht einmal den gleichen Inhalt, aber die Tests sind beschädigt.  Sie können sie separat ausführen, es gibt jedoch keine Möglichkeit, <code>pytest</code> über das Verzeichnis <code>pytest</code> <code>dups</code> : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/dups $ pytest a ============================= test session starts ============================= collected 1 item a\test_foo.py . ========================== 1 passed in 0.05 seconds =========================== $ pytest b ============================= test session starts ============================= collected 1 item b\test_foo.py . ========================== 1 passed in 0.05 seconds =========================== $ pytest ============================= test session starts ============================= collected 1 item / 1 errors =================================== ERRORS ==================================== _______________________ ERROR collecting b/test_foo.py ________________________ import file mismatch: imported module 'test_foo' has this __file__ attribute: /path/to/code/ch6/dups/a/test_foo.py which is not the same as the test file we want to collect: /path/to/code/ch6/dups/b/test_foo.py HINT: remove __pycache__ / .pyc files and/or use a unique basename for your test file modules !!!!!!!!!!!!!!!!!!! Interrupted: 1 errors during collection !!!!!!!!!!!!!!!!!!! =========================== 1 error in 0.34 seconds ===========================</code> </pre> <br><p>  Nichts ist klar! <br>  Diese Fehlermeldung zeigt nicht an, was schief gelaufen ist. </p><br><p>  Um diesen Test zu beheben, fügen Sie einfach die leere Datei <code>__init__.py</code> zu den Unterverzeichnissen hinzu.  Hier ist ein Beispiel für das Verzeichnis <code>dups_fixed</code> mit denselben doppelten Dateinamen, jedoch mit <code>__init__.py</code> Dateien <code>__init__.py</code> : </p><br><pre> <code class="plaintext hljs">dups_fixed/ ├── a │ ├── __init__.py │ └── test_foo.py └── b ├── __init__.py └── test_foo.py</code> </pre> <br><p>  Versuchen wir es jetzt noch einmal von der obersten Ebene in <code>dups_fixed</code> : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/ch6/dups_fixed/ $ pytest ============================= test session starts ============================= collected 2 items a\test_foo.py . b\test_foo.py . ========================== 2 passed in 0.15 seconds ===========================</code> </pre> <br><p>  Also wird es besser sein. </p><br><p>  Natürlich können Sie sich selbst davon überzeugen, dass Sie niemals doppelte Dateinamen haben werden, also spielt das keine Rolle.  Alles ist normal.  Aber Projekte wachsen und Testkataloge wachsen, und Sie möchten auf jeden Fall warten, bis Ihnen dies passiert, bevor Sie sich darum kümmern?  Ich sage, legen Sie diese Dateien einfach dort ab.  Machen Sie es sich zur Gewohnheit und machen Sie sich keine Sorgen mehr. </p><br><h2 id="uprazhneniya">  Übungen </h2><br><p>  In Kapitel 5, Plugins, auf Seite 95 haben Sie ein Plugin namens pytest-nice erstellt, das eine Befehlszeilenoption --nice enthält.  Erweitern wir das um eine pytest.ini-Option namens nice. </p><br><p>  In Kapitel 5, „Plugins“ auf Seite 95, haben Sie ein Plugin namens <code>pytest-nice</code> , das die <code>--nice</code> <code>pytest-nice</code> enthält.  Erweitern wir dies um die Option <code>pytest.ini</code> Namen <code>nice</code> . </p><br><ol><li>  Fügen Sie der Hook-Funktion <code>pytest_addoption</code> <code>pytest_nice.py</code> die folgende Zeile <code>pytest_addoption</code> : <code>parser.addini('nice', type='bool', help='Turn failures into opportunities.')</code> </li><li>  Stellen im Plugin, die <code>getoption()</code> müssen auch <code>getini('nice')</code> aufrufen.  Nehmen Sie diese Änderungen vor. </li><li>  Überprüfen Sie dies manuell, indem Sie der Datei <code>pytest.ini</code> <code>nice</code> <code>pytest.ini</code> . </li><li>  Plugin-Tests nicht vergessen.  Fügen Sie einen Test hinzu, um zu überprüfen, ob der <code>nice</code> Parameter aus <code>pytest.ini</code> ordnungsgemäß funktioniert. </li><li>  Fügen Sie dem Plugin-Verzeichnis Tests hinzu.  Sie müssen einige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zusätzliche Pytester-Funktionen finden</a> . </li></ol><br><h2 id="chto-dalshe">  Was weiter </h2><br><p>  Während pytest an sich extrem leistungsfähig ist - insbesondere mit Plugins - lässt es sich auch gut in andere Softwareentwicklungs- und Softwaretest-Tools integrieren.  Im nächsten Kapitel werden wir die Verwendung von Pytest in Verbindung mit anderen leistungsstarken Testwerkzeugen untersuchen. </p><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zurück</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weiter</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448796/">https://habr.com/ru/post/de448796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448784/index.html">Neue Funktionen für Erweiterungsautoren in Visual Studio 2019 Version 16.1</a></li>
<li><a href="../de448786/index.html">Python-Test mit Pytest. KAPITEL 3 Pytest-Vorrichtungen</a></li>
<li><a href="../de448788/index.html">Python-Test mit Pytest. Kapitel 2, Schreiben von Testfunktionen</a></li>
<li><a href="../de448790/index.html">SpaceVIL - plattformübergreifendes GUI-Framework für die Entwicklung auf .Net Core, .Net Standard und JVM</a></li>
<li><a href="../de448794/index.html">Python-Test mit Pytest. Plugins KAPITEL 5</a></li>
<li><a href="../de448798/index.html">Python-Test mit Pytest. Verwenden von pytest mit anderen Tools, KAPITEL 7</a></li>
<li><a href="../de448800/index.html">Konfigurieren Sie Visual Studio in Ihrer Organisation mit .vsconfig</a></li>
<li><a href="../de448802/index.html">Mit Portalen denken: Portale in Unreal Engine 4 erstellen</a></li>
<li><a href="../de448804/index.html">Vorbereitungen für die gehärtete Laufzeit und den Notar von macOS</a></li>
<li><a href="../de448806/index.html">Erstellen eines Erweiterungssystems in der Qt-Bibliothek</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>