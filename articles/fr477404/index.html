<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë®üèæ üßù ü§≤üèΩ Le probl√®me de la cr√©ation et de la suppression fr√©quentes d'objets en C ++ üë¨ üî° ü§¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'entreprise pour laquelle je travaille √©crit son propre syst√®me de filtrage du trafic et prot√®ge l'entreprise avec elle contre les attaques DDoS, les...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le probl√®me de la cr√©ation et de la suppression fr√©quentes d'objets en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477404/"><img src="https://habrastorage.org/webt/fb/bt/53/fbbt53apqltc7isyigy39vkizmk.jpeg" alt="image"><br><br>  L'entreprise pour laquelle je travaille √©crit son propre syst√®me de filtrage du trafic et prot√®ge l'entreprise avec elle contre les attaques DDoS, les bots, les analyseurs et bien plus encore.  Le produit est bas√© sur un processus tel que le <a href="https://en.wikipedia.org/wiki/Reverse_proxy" rel="nofollow">proxy inverse</a> , √† l'aide duquel nous analysons de gros volumes de trafic en temps r√©el et, au final, n'autorisons que les demandes l√©gitimes des utilisateurs, en filtrant toutes les malveillantes. <br><br>  La principale caract√©ristique est que nos services fonctionnent avec un trafic entrant illimit√©, il est donc tr√®s important d'utiliser toutes les ressources des postes de travail aussi efficacement que possible.  Une grande exp√©rience du d√©veloppement en C ++ moderne nous aide √† cela, y compris les derni√®res normes et un ensemble de biblioth√®ques appel√© Boost. <br><a name="habracut"></a><br><h3>  Proxy inverse </h3><br>  Revenons au proxy inverse et voyons comment l'impl√©menter en C ++ et boost.asio.  Tout d'abord, nous avons besoin de deux objets appel√©s sessions serveur et client.  La session serveur √©tablit et maintient une connexion avec le navigateur; la session client √©tablit et maintient une connexion avec le service.  Vous aurez √©galement besoin d'un tampon de flux qui encapsule le travail avec de la m√©moire √† l'int√©rieur, dans lequel la session serveur lit √† partir du socket et √† partir de laquelle la session client √©crit dans le socket.  Des exemples de sessions serveur et client peuvent √™tre trouv√©s dans la documentation de boost.asio.  Vous trouverez ici comment travailler avec le tampon de flux. <br><br>  Apr√®s avoir collect√© le prototype de proxy inverse √† partir des exemples, il deviendra clair qu'une telle application ne servira probablement pas de trafic entrant illimit√©.  Ensuite, nous commencerons √† augmenter la complexit√© du code.  Pensons au multithreading, aux wokers et aux pools pour les contextes io, et bien plus encore.  En particulier, sur les optimisations pr√©matur√©es li√©es √† la copie de m√©moire entre les sessions serveur et client. <br><br>  De quel type de copie de m√©moire parlons-nous?  Le fait est que lors du filtrage, le trafic n'est pas toujours transmis inchang√©.  Regardez l'exemple ci-dessous: nous y supprimons un en-t√™te et en ajoutons deux √† la place.  Le nombre de requ√™tes utilisateur sur lesquelles des actions similaires sont effectu√©es augmente avec la complexit√© de la logique √† l'int√©rieur du service.  Vous ne pouvez en aucun cas copier des donn√©es sans r√©fl√©chir dans de tels cas!  Si seulement 1% de la demande totale change et que 99% restent inchang√©s, vous devez allouer de la nouvelle m√©moire uniquement pour ce 1%.  Il vous aidera avec ces boost :: asio :: const_buffer et boost :: asio :: mutable_buffer, √† l'aide desquels vous pouvez repr√©senter plusieurs blocs de m√©moire continus avec une seule entit√©. <br><br>  Demande de l'utilisateur: <br><br><pre><code class="plaintext hljs">Browser -&gt; Proxy: &gt; POST / HTTP/1.1 &gt; User-Agent: curl/7.29.0 &gt; Host: 127.0.0.1:50080 &gt; Accept: */* &gt; Content-Length: 5888903 &gt; Content-Type: application/x-www-form-urlencoded &gt; ... Proxy -&gt; Service: &gt; POST / HTTP/1.1 &gt; User-Agent: curl/7.29.0 &gt; Host: 127.0.0.1:50080 &gt; Accept: */* &gt; Transfer-Encoding: chunked &gt; Content-Type: application/x-www-form-urlencoded &gt; Expect: 100-continue &gt; ... Service -&gt; Proxy: &lt; HTTP/1.1 200 OK Proxy -&gt; Browser &lt; HTTP/1.1 200 OK</code> </pre> <br><h3>  Le probl√®me </h3><br>  En cons√©quence, nous avons obtenu une application pr√™te √† l'emploi qui peut bien √©voluer et est dot√©e de toutes sortes d'optimisations.  En le lan√ßant en production, nous √©tions tr√®s satisfaits de la dur√©e de son fonctionnement, stable et de qualit√©. <br><br>  Au fil du temps, nous avons commenc√© √† avoir de plus en plus de clients, avec l'av√®nement du trafic qui a √©galement augment√©.  √Ä un moment donn√©, nous avons √©t√© confront√©s au probl√®me du manque de performances tout en repoussant les grandes attaques.  Apr√®s avoir analys√© le service √† l'aide de l'utilitaire <a href="https://perf.wiki.kernel.org/index.php/Tutorial" rel="nofollow">perf</a> , nous avons remarqu√© que toutes les op√©rations avec le tas sous charge sont en haut.  Ensuite, nous avons recr√©√© une situation similaire sur le circuit de test en utilisant <a href="https://github.com/yandex/yandex-tank" rel="nofollow">des r√©servoirs yandex</a> et des cartouches g√©n√©r√©s en fonction du trafic r√©el.  Accrochant un service via un <a href="https://software.intel.com/en-us/vtune" rel="nofollow">amplificateur,</a> nous avons vu l'image suivante ... <br><br>  Capture d'√©cran de l'amplificateur (woslab): <br><br><img src="https://habrastorage.org/webt/tz/ks/d9/tzksd9oddf-rhcfphtkxkun-pdg.png"><br><br>  Dans la capture d'√©cran, l'op√©rateur nouveau a travaill√© 67 secondes et l'op√©rateur supprime encore plus - 97 secondes. <br><br>  Cette situation nous a boulevers√©s.  Comment r√©duire le temps de s√©jour de l'application dans l'op√©rateur nouveau et supprimer l'op√©rateur?  Il est logique que cela soit possible en abandonnant les allocations constantes d'objets fr√©quemment cr√©√©s et supprim√©s sur le tas.  Nous avons opt√© pour trois approches.  Deux d'entre eux sont standard: <a href="https://en.wikipedia.org/wiki/Object_pool_pattern" rel="nofollow">pool d'objets</a> et <a href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation" rel="nofollow">allocation de pile</a> .  Les sessions client organis√©es en pool au d√©marrage de l'application sont bien plac√©es sur la premi√®re approche.  La seconde approche est utilis√©e partout o√π une demande d'utilisateur est trait√©e du d√©but √† la fin dans la m√™me pile, en d'autres termes, dans le m√™me gestionnaire de contexte io.  Nous n'y reviendrons pas plus en d√©tail.  Nous ferions mieux de parler de la troisi√®me approche, la plus complexe et la plus int√©ressante.  Il s'agit de l' <a href="https://en.wikipedia.org/wiki/Slab_allocation" rel="nofollow">allocation</a> ou de la distribution des dalles. <br><br>  L'id√©e de la distribution des dalles n'est pas nouvelle.  Il a √©t√© invent√© et impl√©ment√© dans Solaris, puis migr√© vers le noyau Linux, et consiste dans le fait que les objets souvent utilis√©s du m√™me type sont plus faciles √† stocker dans le pool.  Nous prenons simplement l'objet de la piscine lorsque nous en avons besoin, et une fois le travail termin√©, nous le restituons.  Aucun appel √† l'op√©rateur nouveau et supprimer l'op√©rateur!  De plus, un minimum d'initialisation.  Dans le noyau de la dalle, la distribution est utilis√©e pour les s√©maphores, les descripteurs de fichiers, les processus et les threads.  Dans notre cas, cela tombait parfaitement sur les sessions serveur et client, ainsi que tout ce qui s'y trouve. <br><br>  Graphique (distribution des dalles): <br><br><img src="https://habrastorage.org/webt/zb/k2/u8/zbk2u8m0jexhso3nmkttzxkvrw0.png"><br><br>  En plus du fait que les allocateurs de dalles sont dans le noyau, leurs impl√©mentations existent √©galement dans l'espace utilisateur.  Ils sont peu nombreux et ceux qui se d√©veloppent activement sont g√©n√©ralement peu nombreux.  Nous nous sommes install√©s sur une biblioth√®que appel√©e <a href="https://github.com/tarantool/small" rel="nofollow">libsmall</a> , qui fait partie de <a href="https://github.com/tarantool/tarantool" rel="nofollow">tarantool</a> .  Il a tout ce dont vous avez besoin. <br><br><ul><li>  petit :: allocateur </li><li>  small :: slab_cache (thread local) </li><li>  petit :: dalle </li><li>  petit :: ar√®ne </li><li>  petit :: quota </li></ul><br>  La structure small :: slab est un pool avec un type d'objet sp√©cifique.  La structure small :: slab_cache est un cache qui contient diverses listes de pools avec un type sp√©cifique d'objets.  La structure small :: allocator est un code qui s√©lectionne le cache n√©cessaire, y recherche un pool appropri√©, dans lequel l'objet demand√© est distribu√©.  Ce que font les petits objets :: arena et petits :: quota ressortira clairement des exemples ci-dessous. <br><br><h3>  Envelopper </h3><br>  La biblioth√®que libsmall est √©crite en C, pas en C ++, nous avons donc d√ª d√©velopper plusieurs wrappers pour une int√©gration transparente dans la biblioth√®que C ++ standard. <br><br><ul><li>  variti :: slab_allocator </li><li>  variti :: dalle </li><li>  variti :: thread_local_slab </li><li>  variti :: slab_allocate_shared </li></ul><br>  La classe variti :: slab_allocator impl√©mente les exigences minimales d√©finies par la norme lors de l'√©criture de son propre allocateur.  Dans les classes variti :: slab, tout le travail avec la biblioth√®que libsmall est encapsul√©.  Pourquoi variti :: thread_local_slab est-il n√©cessaire?  Le fait est que les caches de dalles de distribution sont des objets locaux de thread.  Cela signifie que chaque thread a son propre ensemble de caches.  Ceci est fait afin de r√©duire √† z√©ro le nombre d'op√©rations bloqu√©es lors de la distribution d'un nouvel objet.  Par cons√©quent, dans la m√©moire de chaque thread, nous pla√ßons notre instance de la classe variti :: slab, et l'acc√®s √† celle-ci est r√©glement√© √† l'aide du wrapper variti :: thread_local_slab.  Je vous parlerai plus tard de la fonction de mod√®le variti :: slab_allocate_shared. <br><br>  Dans la classe variti :: slab_allocator, tout est assez simple.  Il a la capacit√© de se relier d'un type √† un autre, par exemple, du vide au caract√®re.  Fait int√©ressant, vous pouvez faire attention √† la pr√©valence de nullptr √† l'exception std :: bad_alloc dans le cas o√π la m√©moire s'√©puise de la dalle de distribution.  Le reste transf√®re des appels √† l'int√©rieur du wrapper variti :: thread_local_slab. <br><br>  Extrait (slab_allocator.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slab_allocator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = T; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> pointer = value_type*; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_pointer = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value_type*; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> reference = value_type&amp;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_reference = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value_type&amp;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rebind</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> other = slab_allocator&lt;U&gt;; }; slab_allocator() {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; slab_allocator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> slab_allocator&lt;U&gt;&amp; other) {} <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(thread_local_slab::allocate(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) * n)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p &amp;&amp; n) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_alloc(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deallocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ thread_local_slab::deallocate(p, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) * n); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slab_allocator</span></span></span><span class="hljs-class">&lt;void&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> pointer = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_pointer = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rebind</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> slab_allocator&lt;U&gt; other; }; };</code> </pre> <br>  Voyons comment le constructeur et le destructeur variti :: slab sont impl√©ment√©s.  Dans le constructeur, nous allouons un total de pas plus de 1 Gio de m√©moire pour tous les objets.  La taille de chaque piscine dans notre cas ne d√©passe pas 1 Mio.  L'objet minimum que nous pouvons distribuer est de 2 octets (en fait, libsmall l'augmentera au minimum requis - 8 octets).  Les objets restants disponibles via notre distribution de dalles seront un multiple de deux (d√©fini par la constante 2.f).  Au total, vous pouvez distribuer des objets de taille 8, 16, 32, etc.  Si la taille de l'objet demand√© est de 24 octets, une surcharge se produira de la m√©moire.  La distribution vous renverra cet objet, mais il sera plac√© dans un pool qui correspond √† un objet de 32 octets.  Les 8 octets restants seront inactifs. <br><br>  Extrait (slab.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_to_virt_p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(p) + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_to_virt_n</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n - <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">virt_to_phys_p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(p) - <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">virt_to_phys_n</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::<span class="hljs-function"><span class="hljs-function">id&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_thread_id</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id*&gt;(p); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slab</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> noncopyable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: slab() { small::quota_init(&amp; quota_, <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); small::slab_arena_create(&amp;arena_, &amp; quota_, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>, MAP_PRIVATE); small::slab_cache_create(&amp;cache_, &amp;arena_); small::allocator_create(&amp;allocator_, &amp;cache_, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>); } ~slab() { small::allocator_destroy(&amp;allocator_); small::slab_cache_destroy(&amp;cache_); small::slab_arena_destroy(&amp;arena_); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_n = virt_to_phys_n(n); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_p = small::<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(&amp;allocator_, phys_n); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!phys_p) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; phys_thread_id(phys_p) = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> phys_to_virt_p(phys_p); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deallocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_p = virt_to_phys_p(<span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(p)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_n = virt_to_phys_n(n); assert(phys_thread_id(phys_p) == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id()); small::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(&amp;allocator_, phys_p, phys_n); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: small::quota quota_; small::slab_arena arena_; small::slab_cache cache_; small::allocator allocator_; };</code> </pre> <br>  Toutes ces restrictions s'appliquent √† une instance particuli√®re de la classe variti :: slab.  √âtant donn√© que chaque thread a le sien (pensez au thread local), la limite totale du processus ne sera pas de 1 Gio, mais sera directement proportionnelle au nombre de threads qui utilisent la distribution de dalles. <br><br>  Graphique (std :: thread :: id): <br><br><img src="https://habrastorage.org/webt/_8/65/jy/_865jyoyp0qqoz7-tgsgmjsc9b0.png"><br><br>  D'une part, l'utilisation de thread local permet d'acc√©l√©rer le travail de distribution de dalles dans une application multi-thread, d'autre part, elle impose de s√©rieuses restrictions sur l'architecture de l'application asynchrone.  Vous devez demander et renvoyer un objet dans le m√™me flux.  Faire cela dans le cadre de boost.asio est parfois tr√®s probl√©matique.  Pour suivre des situations manifestement erron√©es, au d√©but de chaque objet, nous pla√ßons l'identifiant du flux dans lequel la m√©thode d'allocation est appel√©e.  Cet identifiant est ensuite v√©rifi√© dans la m√©thode de d√©sallocation.  Les assistants phys_to_virt_p et virt_to_phys_p aident √† cela. <br><br>  Extrait (thread_local_slab.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_local_slab</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> noncopyable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finalize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deallocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; };</code> </pre> <br>  Extrait (thread_local_slab.cpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">thread_local</span></span> slab* slab_; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_local_slab::initialize() { slab_ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> slab(slab_cfg_); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_local_slab::finalize() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> slab_; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* thread_local_slab::<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> slab_-&gt;<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(n); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_local_slab::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* p, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n) { slab_-&gt;<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(p, n); }</code> </pre> <br>  Lorsque le contr√¥le du flux est perdu (lors du transfert d'un objet entre diff√©rents contextes io), un pointeur intelligent permet la lib√©ration correcte de l'objet.  Tout ce qu'il fait est de distribuer l'objet, en se souvenant de son contexte io, puis de l'envelopper dans std :: shared_ptr avec un diviseur personnalis√© qui ne renvoie pas imm√©diatement l'objet √† la distribution, mais le fait dans le contexte io enregistr√© pr√©c√©demment.  Cela fonctionne bien lorsque chaque contexte io s'ex√©cute sur un seul thread.  Sinon, malheureusement, cette approche n'est pas applicable. <br><br>  Extrait (slab_helper.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Allocator, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; slab_allocate_shared(Allocator allocator, Args... args) { T* p = allocator.allocate(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)p) T(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; ptr(p, [allocator](T* p) { p-&gt;~T(); allocator.deallocate(p); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Allocator, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; slab_allocate_shared(Allocator allocator, boost::asio::io_service* io, Args... args) { T* p = allocator.allocate(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)p) T(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; ptr(p, [allocator, io](T* p) { io-&gt;post([allocator, p]() { p-&gt;~T(); allocator.deallocate(p); }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; };</code> </pre> <br><h3>  Solution </h3><br>  Une fois le travail de cr√©ation de libsmall termin√©, nous avons d'abord d√©plac√© les allocateurs de blocs √† l'int√©rieur du tampon de flux vers la dalle.  C'√©tait assez facile √† faire.  Apr√®s avoir obtenu un r√©sultat positif, nous sommes all√©s de l'avant et avons appliqu√© les allocateurs de dalles d'abord au tampon de flux lui-m√™me, puis √† tous les objets √† l'int√©rieur des sessions serveur et client. <br><br><ul><li>  variti :: morceau </li><li>  variti :: streambuf </li><li>  variti :: server_session </li><li>  variti :: client_session </li></ul><br>  Dans le m√™me temps, il √©tait n√©cessaire de r√©soudre des probl√®mes suppl√©mentaires, √† savoir: transf√©rer des objets simples, des objets composites et des collections vers des allocateurs de dalles.  Et s'il n'y avait pas de difficult√©s s√©rieuses avec les deux premi√®res classes d'objets (les objets composites sont r√©duits √† des objets simples), alors lors de la traduction des collections, nous avons rencontr√© de s√©rieuses difficult√©s. <br><br><ul><li>  std :: list </li><li>  std :: deque </li><li>  std :: vecteur </li><li>  std :: string </li><li>  std :: map </li><li>  std :: unordered_map </li></ul><br>  L'une des principales limitations lors de l'utilisation de la distribution de dalles est que le nombre d'objets de types diff√©rents ne doit pas √™tre trop grand (plus il est petit, mieux c'est).  Dans ce contexte, certaines collections peuvent bien tomber sur le concept d'allocateurs de dalles, tandis que d'autres ne le peuvent pas. <br><br>  Pour la dalle std :: list, les allocateurs fonctionnent tr√®s bien.  Cette collection est impl√©ment√©e en interne √† l'aide d'une liste cha√Æn√©e, dont chaque √©l√©ment a une taille fixe.  Ainsi, avec l'ajout de nouvelles donn√©es √† la liste std :: dans la distribution de dalles, de nouveaux types d'objets n'apparaissent pas.  La condition indiqu√©e ci-dessus est satisfaite!  Le std :: map est organis√© de la m√™me mani√®re.  La seule diff√©rence est qu'√† l'int√©rieur, ce n'est pas une liste cha√Æn√©e, mais un arbre. <br><br>  Dans le cas de std :: deque, les choses sont plus compliqu√©es.  Cette collection est impl√©ment√©e via un bloc de m√©moire contigu contenant des pointeurs vers des blocs.  Bien que les morceaux soient assez pr√©cis, std :: deque se comporte de la m√™me mani√®re que std :: list, mais lorsqu'ils se terminent, ce m√™me bloc de m√©moire est redistribu√©.  Du point de vue des allocateurs de dalles, chaque redistribution de m√©moire est un objet avec un nouveau type.  Le nombre d'objets ajout√©s √† la collection d√©pend directement de l'utilisateur et peut cro√Ætre de mani√®re incontr√¥lable.  Cette situation n'est pas acceptable, nous avons donc soit limit√© au pr√©alable la taille de std :: deque l√† o√π c'√©tait possible, soit pr√©f√©r√© std :: list. <br><br>  Si nous prenons std :: vector et std :: string, alors ils sont encore plus compliqu√©s.  L'impl√©mentation de ces collections est quelque peu similaire √† std :: deque, sauf que leur bloc de m√©moire continue cro√Æt beaucoup plus rapidement.  Nous avons remplac√© std :: vector et std :: string par std :: deque, et dans le pire des cas par std :: list.  Oui, nous avons perdu en fonctionnalit√©s et quelque part m√™me en performances, mais cela a beaucoup moins affect√© l'image finale que les optimisations pour lesquelles tout a √©t√© con√ßu. <br><br>  Nous avons fait exactement la m√™me chose avec std :: unordered_map, en l'abandonnant au profit du variti :: flat_map auto-√©crit impl√©ment√© via std :: deque.  Dans le m√™me temps, nous avons simplement mis en cache les cl√©s fr√©quemment utilis√©es dans des variables distinctes, par exemple, comme cela se fait avec les en-t√™tes de requ√™te http dans nginx. <br><br><h3>  Conclusion </h3><br>  Apr√®s avoir termin√© le transfert complet des sessions serveur et client vers les allocateurs de dalles, nous avons r√©duit le temps pass√© √† travailler avec un groupe de plus d'une fois et demie. <br><br>  Capture d'√©cran de l'amplificateur (coldslab): <br><br><img src="https://habrastorage.org/webt/ls/yx/l_/lsyxl_b6xngl5xap-t5erwn4now.png"><br><br>  Dans la capture d'√©cran, l'op√©rateur new a travaill√© 32 secondes et l'op√©rateur delete - 24 secondes.  √Ä ce moment, d'autres fonctions pour travailler avec le tas ont √©t√© ajout√©es: smalloc - 21 secondes, mslab_alloc - 37 secondes, smfree - 8 secondes, mslab_free - 21 secondes.  Total, 143 secondes contre 161 secondes. <br><br>  Mais ces mesures ont √©t√© effectu√©es imm√©diatement apr√®s le d√©marrage du service sans initialiser les caches dans la distribution de la dalle.  Apr√®s des tirs r√©p√©t√©s √† partir d'un char Yandex, l'image globale s'est am√©lior√©e. <br><br>  Capture d'√©cran de l'amplificateur (hotslab): <br><br><img src="https://habrastorage.org/webt/gc/zj/kt/gczjkt5r8yedhniu5afswdjqk2y.png"><br><br>  Dans la capture d'√©cran, l'op√©rateur new fonctionnait 20 secondes, smalloc - 16 secondes, mslab_alloc - 27 secondes, operator delete - 16 secondes, smfree - 7 secondes, mslab_free - 17 secondes.  Total 103 secondes contre 161 secondes. <br><br>  Tableau de mesure: <br><br><pre> <code class="plaintext hljs"> woslab coldslab hotslab operator new 67s 32s 20s smalloc - 21s 16s mslab_alloc - 37s 27s operator delete 94s 24s 16s smfree - 8s 7s mslab_free - 21s 17s summary 161s 143s 103s</code> </pre><br>  Dans la vie r√©elle, le r√©sultat devrait √™tre encore meilleur, car les allocateurs de dalles r√©solvent non seulement le probl√®me de l'allocation de m√©moire longue et de la lib√©ration, mais r√©duisent √©galement la fragmentation.  Sans dalle, au fil du temps, le fonctionnement de l'op√©rateur new et de l'op√©rateur delete ne devrait que ralentir.  Avec la dalle - elle restera toujours au m√™me niveau. <br><br>  Comme nous pouvons le voir, les allocateurs de dalles r√©solvent avec succ√®s le probl√®me d'allocation de m√©moire des objets fr√©quemment utilis√©s.  Faites attention √† eux si la question de la cr√©ation et de la suppression fr√©quentes d'objets vous int√©resse.  Mais n'oubliez pas les limitations qu'elles imposent √† l'architecture de votre application!  Tous les objets complexes ne peuvent pas simplement √™tre plac√©s dans la distribution de dalle.  Il faut parfois abandonner beaucoup!  Eh bien, plus l'architecture de votre application est complexe, plus vous devrez souvent vous occuper de remettre l'objet dans le cache correct en termes de multithreading.  Cela peut √™tre simple lorsque vous avez imm√©diatement √©labor√© l'architecture de l'application, en tenant compte de l'utilisation d'allocateurs de dalles, mais cela posera certainement des probl√®mes lorsque vous d√©ciderez de les int√©grer √† un stade avanc√©. <br><br><h3>  App </h3><br>  D√©couvrez le code source <a href="https://github.com/sonntex/slab-allocator" rel="nofollow">ici</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477404/">https://habr.com/ru/post/fr477404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477390/index.html">D√©bogage des retards r√©seau dans Kubernetes</a></li>
<li><a href="../fr477392/index.html">Microphone ouvert: backend. Nous invitons des conf√©renciers</a></li>
<li><a href="../fr477396/index.html">Comment s'inscrire √† un cours et ... aller jusqu'au bout</a></li>
<li><a href="../fr477400/index.html">A propos du m√©tier de chef de produit: comment atteindre l'id√©al?</a></li>
<li><a href="../fr477402/index.html">D√©ploiement du mod√®le Keras Deep Learning en tant qu'application Web Python</a></li>
<li><a href="../fr477406/index.html">Support technique et support. Grande recherche sur le march√© du travail et les salaires. Qu'est-ce qui a chang√© en 2 ans?</a></li>
<li><a href="../fr477408/index.html">Tutoriel JavaFX: dispositions avanc√©es</a></li>
<li><a href="../fr477414/index.html">Ing√©nieur de donn√©es - La profession la plus sexy du 21e si√®cle</a></li>
<li><a href="../fr477416/index.html">Quand est-il dangereux de hacher</a></li>
<li><a href="../fr477418/index.html">R√©fraction tridimensionnelle en trois √©tapes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>