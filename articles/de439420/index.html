<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👨🏼 🙇🏾 🌗 Erstellen eines Transportpakets ohne Installation von MODX 👨🏼‍🏫 👩🏻‍⚖️ 📓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Schreiben Ihrer Pakete für MODX ist für Anfänger nicht einfach, und ein erfahrener Entwickler hat manchmal eine süße Zeit. Aber der Anfänger hat A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines Transportpakets ohne Installation von MODX</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439420/"><img src="https://habrastorage.org/webt/jv/hq/2n/jvhq2nbsj0ti2v8v_ucoyk_bwam.jpeg"><br><br>  Das Schreiben Ihrer Pakete für MODX ist für Anfänger nicht einfach, und ein erfahrener Entwickler hat manchmal eine süße Zeit.  Aber der Anfänger hat Angst und der Erfahrene versteht :). <br><br>  In diesem Beitrag wird erläutert, wie Sie ein Komponentenpaket für MODX schreiben und erstellen können, ohne MODX selbst zu installieren und zu konfigurieren.  Das Niveau ist überdurchschnittlich, so dass Sie in einigen Fällen Ihr Gehirn zerbrechen müssen, aber es lohnt sich. <br><br>  Ich frage nach Details unter Katze. <br><a name="habracut"></a><br>  Als MODX Revolution gerade erschien, war es in der frühen Beta-Version, und die Entwickler wussten immer noch nicht, wie sie damit arbeiten und wie sie Plugins dafür schreiben sollten.  Nun, bis auf das Team, das über das CMS nachgedacht hat.  Und ich muss sagen, das Team hat es teilweise geschafft und dafür gesorgt, dass das System selbst bequem Pakete sammelt, die dann über das Repository installiert werden können, was logisch erscheint.  Aber seitdem sind viele Jahre vergangen und die Anforderungen an Pakete und deren Montage haben sich ein wenig geändert. <br><br><h2>  Copy-Paste ist böse, wenn auch nicht immer </h2><br>  In den letzten Monaten wurde ich von dem Gedanken verfolgt, warum Sie zum Erstellen eines Pakets für MODX es installieren, eine Datenbank erstellen, einen Administrator erstellen usw. müssen.  So viele zusätzliche Aktionen.  Nein, daran ist nichts auszusetzen, wenn Sie es einmal einrichten und dann verwenden.  Viele tun dies.  Aber was ist, wenn Sie die Versammlung dem Drehbuch anvertrauen und selbst einen Kaffee trinken möchten? <br><br>  Es kam vor, dass die Entwickler von MODX daran gewöhnt waren, mit MODX selbst zu arbeiten, und dem Paket Klassen direkt zum Kernel hinzufügten.  Sie schrieben auch die ersten Komponenten, die ersten Build-Skripte, die dann von anderen Entwicklern als Beispiele verwendet wurden, die die Lösung einfach kopierten und sich nicht immer mit der Essenz des Geschehens befassten.  Und ich habe es geschafft. <br><br>  Die Aufgabe besteht jedoch darin, die Zusammenstellung des Pakets, vorzugsweise auf dem Server, immer mit einem Minimum an erforderlicher Software, mit minimalen Ressourcen und daher mit höherer Geschwindigkeit zu automatisieren.  Die Aufgabe wurde festgelegt und nach dem Studium der Quelle fand Jason, der im Chat bremste, eine Lösung. <br><br><h2>  Und welches? </h2><br>  Das erste, was ich herausgefunden habe, ist, dass der Code, der für die Erstellung des Pakets verantwortlich ist, direkt in der xPDO-Bibliothek liegt. In MODX gibt es nur Wrapper-Klassen, die eine bequemere API bieten und mit denen etwas einfacher zu arbeiten ist, aber nur, wenn MODX installiert ist.  Daher kann wahrscheinlich nur xPDO irgendwie verwendet werden, aber im Code muss der Konstruktor des xPDO-Objekts Daten für die Datenbankverbindung angeben. <br><br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( $dsn, $username = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $password = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $options = [], $driverOptions= null )</span></span></span></span>;</code> </pre> <br>  Nach der Befragung von Jason wurde klar, dass, obwohl Parameter festgelegt werden müssen, die tatsächliche physische Verbindung zur Datenbank genau zu dem Zeitpunkt erfolgt, zu dem dies erforderlich ist.  Faule Ladung in all ihrer Pracht.  Das zweite Problem wurde behoben. <br><br>  Das dritte Problem war das Problem der Verbindung von xPDO mit dem Projekt.  Composer kam sofort in den Sinn, aber die 2.x-Version, auf der der aktuelle MODX ausgeführt wird, unterstützt Composer nicht, und der 3.x-Zweig verwendet Namespaces, und Klassennamen werden anders geschrieben als in 2.x, was zu Konflikten und Fehlern führt.  Im Allgemeinen nicht kompatibel.  Dann musste ich Git-Tools verwenden und xPDO als Submodul verbinden. <br><blockquote><h4>  Verwendung von Submodulen </h4><br><br>  Lesen Sie zuerst die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> dazu. <br><br>  Wenn dies ein neues Projekt ist, müssen Sie ein Submodul hinzufügen: <br><br><pre> <code class="plaintext hljs">$ git submodule add https://github.com/username/reponame</code> </pre> <br>  Dieser Befehl klont und installiert ein Submodul in Ihrem Projekt.  Anschließend müssen Sie den Submodulordner mit dem Befehl git add zu Ihrem Repository hinzufügen.  Es wird nicht der gesamte Ordner mit dem Submodul hinzugefügt, sondern nur ein Link zum letzten Commit des Submoduls zu git hinzugefügt. <br><br>  Damit ein anderer Entwickler das Projekt mit allen Abhängigkeiten klonen kann, müssen Sie eine .gitmodules-Konfiguration für Submodule erstellen.  Im Slackify-Projekt sieht es so aus: <br><br><pre> <code class="plaintext hljs">[submodule "_build/xpdo"] path = _build/xpdo url = https://github.com/modxcms/xpdo.git branch = 2.x</code> </pre><br>  Geben Sie danach beim Klonen einfach das rekursive Flag an, und git lädt alle abhängigen Repositorys herunter. </blockquote>  Als Ergebnis haben wir xPDO, xPDO kann verwendet werden, ohne eine Verbindung zur Datenbank herzustellen. Wenn dies nicht erforderlich ist, kann xPDO als externe Abhängigkeit (Git-Submodul) mit dem Komponentencode verbunden werden.  Nun die Implementierung des Build-Skripts. <br><br><h2>  Lass uns verstehen </h2><br>  Ich werde das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Build-Skript des</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slackify-</a> Add- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ons</a> beschreiben, das kürzlich von mir veröffentlicht wurde.  Diese Komponente ist kostenlos und auf GitHub öffentlich verfügbar, was das Selbststudium erleichtert. <br><br><h3>  Verbinden Sie xPDO </h3><br>  Wir lassen die Aufgabe von Konstanten mit dem Paketnamen und anderen notwendigen Aufrufen weg und verbinden xPDO. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">'xpdo/xpdo/xpdo.class.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">'xpdo/xpdo/transport/xpdotransport.class.php'</span></span>; $xpdo = xPDO::getInstance(<span class="hljs-string"><span class="hljs-string">'db'</span></span>, [ xPDO::OPT_CACHE_PATH =&gt; <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">'/../cache/'</span></span>, xPDO::OPT_HYDRATE_FIELDS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDO::OPT_HYDRATE_RELATED_OBJECTS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDO::OPT_HYDRATE_ADHOC_FIELDS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDO::OPT_CONNECTIONS =&gt; [ [ <span class="hljs-string"><span class="hljs-string">'dsn'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'mysql:host=localhost;dbname=xpdotest;charset=utf8'</span></span>, <span class="hljs-string"><span class="hljs-string">'username'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'test'</span></span>, <span class="hljs-string"><span class="hljs-string">'password'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'test'</span></span>, <span class="hljs-string"><span class="hljs-string">'options'</span></span> =&gt; [xPDO::OPT_CONN_MUTABLE =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>], <span class="hljs-string"><span class="hljs-string">'driverOptions'</span></span> =&gt; [], ] ] ]);</code> </pre> <br>  Ich habe das xPDO-Submodul zum _build-Ordner hinzugefügt, das wir nur in der Phase der Entwicklung und Montage des Pakets benötigen und das nicht in das Hauptarchiv der Komponente gelangt.  Die zweite Kopie von xPDO auf der Site mit Live-MODX benötigen wir nicht. <br><br>  In den xPDO-Verbindungseinstellungen habe ich den Datenbanknamen in <code>dsn</code> , aber er spielt keine Rolle.  Es ist wichtig, dass der Cache-Ordner in xPDO beschreibbar ist.  Das war's, xPDO wird initialisiert. <br><br><h3>  Machen Sie einen kniffligen Hack mit Klassen </h3><br>  Wenn Sie beim Erstellen des Pakets den installierten MODX verwenden, ist alles einfach. Wir nehmen und erstellen ein Objekt der Klasse, die wir benötigen.  MODX findet tatsächlich die erforderliche Klasse, findet die erforderliche Implementierung für diese Klasse (die Klasse mit dem Postfix _mysql), die von der Datenbank abhängt, und erstellt dann das gewünschte Objekt (aufgrund dieser Funktion können beim Erstellen des Pakets Fehler auftreten, die die Klasse * _mysql nicht gefunden, das ist nicht beängstigend).  Wir haben jedoch weder eine Basis noch eine Implementierung.  Wir müssen irgendwie die gewünschte Klasse ersetzen, was wir tun. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">modNamespace</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xPDOObject</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">modSystemSetting</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xPDOObject</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br>  Wir erstellen eine Dummy-Klasse (Stub), die zum Erstellen des gewünschten Objekts benötigt wird.  Dies wäre nicht erforderlich, wenn xPDO nicht speziell prüfen würde, zu welcher Klasse das Objekt gehört.  Aber er prüft. <br><br>  Es gibt jedoch Sonderfälle, in denen Sie etwas mehr tun müssen, als nur eine Klasse zu definieren.  Dies sind Fälle von Abhängigkeiten zwischen Klassen.  Zum Beispiel müssen wir der Kategorie ein Plugin hinzufügen.  Im Code nur <code>$category-&gt;addOne($plugin);</code>  aber in unserem Fall wird dies nicht funktionieren. <br><br>  Wenn Sie sich jemals <a href="">das MODX-Datenbankschema angesehen haben</a> , haben Sie wahrscheinlich Elemente wie Aggregat und Composite gesehen.  Es wird in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation darüber geschrieben</a> , aber wenn auf einfache Weise, beschreiben sie die Beziehung zwischen Klassen. <br><br>  In unserem Fall kann eine Kategorie mehrere Plugins enthalten, für die das Aggregatelement für die Klasse <code>modCategory</code> verantwortlich ist.  Da wir eine Klasse ohne konkrete Implementierung haben, müssen wir diesen Zusammenhang daher von Hand angeben.  Dies ist einfacher, wenn Sie die Methode <code>getFKDefinition</code> überschreiben: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">modCategory</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xPDOObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFKDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($alias)</span></span></span><span class="hljs-function"> </span></span>{ $aggregates = [ <span class="hljs-string"><span class="hljs-string">'Plugins'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'class'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modPlugin'</span></span>, <span class="hljs-string"><span class="hljs-string">'local'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-string"><span class="hljs-string">'foreign'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'category'</span></span>, <span class="hljs-string"><span class="hljs-string">'cardinality'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'many'</span></span>, <span class="hljs-string"><span class="hljs-string">'owner'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'local'</span></span>, ] ]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>($aggregates[$alias]) ? $aggregates[$alias] : []; } }</code> </pre> <br>  In unserer Komponente werden nur Plugins verwendet, daher fügen wir nur für sie Links hinzu.  Danach kann die addMany-Methode der modCategory-Klasse die erforderlichen Plugins einfach zur Kategorie und dann zum Paket hinzufügen. <br><br><h3>  Erstellen Sie ein Paket </h3><br><pre> <code class="php hljs">$package = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> xPDOTransport($xpdo, $signature, $directory);</code> </pre> <br>  Wie Sie sehen können, ist alles sehr, sehr einfach.  Hier mussten wir den Parameter <code>$xpdo</code> , den wir ganz am Anfang initialisiert haben.  Ohne diesen Moment gäbe es kein Problem 2.  <code>$signature</code> - der Name des Pakets, einschließlich der Version, <code>$directory</code> - der Ort, an dem das Paket sorgfältig platziert wird.  Woher diese Variablen kommen, sehen Sie selbst in der Quelle. <br><br><h3>  Erstellen Sie einen Namespace und fügen Sie ihn dem Paket hinzu </h3><br>  Wir benötigen einen Namespace, um Lexika und Systemeinstellungen daran zu binden.  In unserem Fall werden andere nur aus diesem Grund noch nicht berücksichtigt. <br><br><pre> <code class="php hljs">$namespace = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> modNamespace($xpdo); $namespace-&gt;fromArray([ <span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; PKG_NAME_LOWER, <span class="hljs-string"><span class="hljs-string">'name'</span></span> =&gt; PKG_NAME_LOWER, <span class="hljs-string"><span class="hljs-string">'path'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'{core_path}components/'</span></span> . PKG_NAME_LOWER . <span class="hljs-string"><span class="hljs-string">'/'</span></span>, ]); $package-&gt;put($namespace, [ xPDOTransport::UNIQUE_KEY =&gt; <span class="hljs-string"><span class="hljs-string">'name'</span></span>, xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::RESOLVE_FILES =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::RESOLVE_PHP =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::NATIVE_KEY =&gt; PKG_NAME_LOWER, <span class="hljs-string"><span class="hljs-string">'namespace'</span></span> =&gt; PKG_NAME_LOWER, <span class="hljs-string"><span class="hljs-string">'package'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modx'</span></span>, <span class="hljs-string"><span class="hljs-string">'resolve'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">'validate'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ]);</code> </pre> <br>  Der erste Teil ist jedem klar, der jemals Code für MODX geschrieben hat.  Die zweite mit der Ergänzung des Pakets ist etwas komplizierter.  Die <code>put</code> Methode verwendet zwei Parameter: das Objekt selbst und ein Array von Parametern, die dieses Objekt und sein mögliches Verhalten zum Zeitpunkt der Installation des Pakets beschreiben.  Beispielsweise bedeutet <code>xPDOTransport::UNIQUE_KEY =&gt; 'name'</code> , dass das <code>xPDOTransport::UNIQUE_KEY =&gt; 'name'</code> mit dem Namen des Namespace selbst als Wert für den Namespace als eindeutiger Schlüssel in der Datenbank verwendet wird.  Sie können mehr über die Parameter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der xPDO-Dokumentation</a> lesen und besser den Quellcode studieren. <br><br>  Auf die gleiche Weise können Sie andere Objekte hinzufügen, z. B. Systemeinstellungen. <br><br><pre> <code class="php hljs">$package-&gt;put($setting, [ xPDOTransport::UNIQUE_KEY =&gt; <span class="hljs-string"><span class="hljs-string">'key'</span></span>, xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">'class'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modSystemSetting'</span></span>, <span class="hljs-string"><span class="hljs-string">'resolve'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">'validate'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">'package'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modx'</span></span>, ]);</code> </pre> <br><h3>  Erstellen Sie eine Kategorie </h3><br>  Mit der Hinzufügung einer Kategorie hatte ich den größten Knebel, als ich alles herausfand.  Elemente, die im xPDO-Modell in eine Kategorie eingefügt werden, müssen beide zu dieser Kategorie gehören, d. H.  darin verschachtelt sein, und erst dann muss die Kategorie selbst im Paket verschachtelt sein.  Gleichzeitig müssen Sie die Beziehungen zwischen den Klassen berücksichtigen, die ich oben bereits beschrieben habe.  Es hat ziemlich lange gedauert, es zu verstehen, zu realisieren und richtig anzuwenden. <br><br><pre> <code class="php hljs">$package-&gt;put($category, [ xPDOTransport::UNIQUE_KEY =&gt; <span class="hljs-string"><span class="hljs-string">'category'</span></span>, xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::ABORT_INSTALL_ON_VEHICLE_FAIL =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::RELATED_OBJECTS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; [ <span class="hljs-string"><span class="hljs-string">'Plugins'</span></span> =&gt; [ xPDOTransport::UNIQUE_KEY =&gt; <span class="hljs-string"><span class="hljs-string">'name'</span></span>, xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, xPDOTransport::RELATED_OBJECTS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ], <span class="hljs-string"><span class="hljs-string">'PluginEvents'</span></span> =&gt; [ xPDOTransport::UNIQUE_KEY =&gt; [<span class="hljs-string"><span class="hljs-string">'pluginid'</span></span>, <span class="hljs-string"><span class="hljs-string">'event'</span></span>], xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, xPDOTransport::RELATED_OBJECTS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ] ], xPDOTransport::NATIVE_KEY =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">'package'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modx'</span></span>, <span class="hljs-string"><span class="hljs-string">'validate'</span></span> =&gt; $validators, <span class="hljs-string"><span class="hljs-string">'resolve'</span></span> =&gt; $resolvers ]);</code> </pre> <br>  Es sieht monströs aus, aber nicht so gesehen.  Ein wichtiger Parameter ist <code>xPDOTransport::RELATED_OBJECTS =&gt; true</code> gibt an, dass die Kategorie verschachtelte Elemente enthält, die ebenfalls <code>xPDOTransport::RELATED_OBJECTS =&gt; true</code> und dann installiert werden müssen. <br><br>  Da die meisten Module verschiedene Elemente enthalten (Chunks, Snippets, Plugins), ist die Kategorie mit Elementen das wichtigste Element des Transportpakets.  Daher werden hier Validatoren und Resolver angegeben, die während der Installation des Pakets ausgeführt werden. <br><blockquote>  Validatoren werden vor der Installation durchgeführt, Resolver - danach. </blockquote><br>  Ich hätte fast vergessen, bevor wir die Kategorie packen, müssen wir unsere Elemente hinzufügen.  So: <br><br><pre> <code class="php hljs">$plugins = <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $sources[<span class="hljs-string"><span class="hljs-string">'data'</span></span>] . <span class="hljs-string"><span class="hljs-string">'transport.plugins.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_array($plugins)) { $category-&gt;addMany($plugins, <span class="hljs-string"><span class="hljs-string">'Plugins'</span></span>); }</code> </pre> <br><h3>  Fügen Sie dem Paket weitere Daten hinzu. </h3><br>  Im Paket müssen Sie eine weitere Datei mit einer Lizenz, eine Datei mit einem Änderungsprotokoll und eine Datei mit einer Beschreibung der Komponente hinzufügen.  Bei Bedarf können Sie über das Attribut <code>setup-options</code> weiteres spezielles Skript hinzufügen, das das Fenster vor der Installation des Pakets anzeigt.  Dies ist, wenn anstelle von "Installieren" die Schaltfläche "Installationsoptionen".  Ab der Version von MODX 2.4 konnten Abhängigkeiten zwischen Paketen mithilfe des Attributs require angegeben werden. Darin können Sie auch die Version von PHP und MODX angeben. <br><br><pre> <code class="php hljs">$package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'changelog'</span></span>, file_get_contents($sources[<span class="hljs-string"><span class="hljs-string">'docs'</span></span>] . <span class="hljs-string"><span class="hljs-string">'changelog.txt'</span></span>)); $package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'license'</span></span>, file_get_contents($sources[<span class="hljs-string"><span class="hljs-string">'docs'</span></span>] . <span class="hljs-string"><span class="hljs-string">'license.txt'</span></span>)); $package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'readme'</span></span>, file_get_contents($sources[<span class="hljs-string"><span class="hljs-string">'docs'</span></span>] . <span class="hljs-string"><span class="hljs-string">'readme.txt'</span></span>)); $package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'requires'</span></span>, [<span class="hljs-string"><span class="hljs-string">'php'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'&gt;=5.4'</span></span>]); $package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'setup-options'</span></span>, [<span class="hljs-string"><span class="hljs-string">'source'</span></span> =&gt; $sources[<span class="hljs-string"><span class="hljs-string">'build'</span></span>] . <span class="hljs-string"><span class="hljs-string">'setup.options.php'</span></span>]);</code> </pre> <br><h3>  Wir packen </h3><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($package-&gt;pack()) { $xpdo-&gt;log(xPDO::LOG_LEVEL_INFO, <span class="hljs-string"><span class="hljs-string">"Package built"</span></span>); }</code> </pre> <br>  Das war's, holen Sie das fertige Paket in <code>_packages</code> , oder von dort, wo Sie die Assembly konfiguriert haben. <br><br><h2>  Was ist das Ergebnis? </h2><br>  Das Ergebnis hat meine Erwartungen übertroffen, da dieser Ansatz zwar einige Einschränkungen mit sich bringt und an einigen Stellen einige Unannehmlichkeiten mit sich bringt, aber hinsichtlich der Anwendungsmöglichkeiten gewinnt. <br><br>  Um das Paket zu erstellen, führen Sie einfach zwei Befehle aus: <br><br><pre> <code class="plaintext hljs">git clone --recursive git@github.com:Alroniks/modx-slackify.git cd modx-slackify/_build &amp;&amp; php build.transport.php</code> </pre> <br>  Das erste ist das Klonen des Repositorys und seiner Submodule.  Ein wichtiger Parameter ist <code>--recursive</code> , dank dessen git zusätzlich zum Komponentencode selbst alle als Submodule beschriebenen Abhängigkeiten herunterlädt und installiert. <br><br>  Der zweite ist das direkte Erstellen des Pakets.  Danach können Sie das fertige <code>package-1.0.0-pl.transport.zip</code> aus dem Ordner <code>package-1.0.0-pl.transport.zip</code> <code>_packages</code> und beispielsweise in das Repository laden. <br><br>  Die Aussichten sind groß.  Sie können beispielsweise einen Hook in GitHub konfigurieren, der nach dem Festschreiben in einem Zweig ein Skript auf Ihrem Server ausführt, das das Paket sammelt und auf allen vorhandenen Websites ablegt.  Oder laden Sie die neue Version in ein Repository hoch, und zu diesem Zeitpunkt kochen Sie sich Kaffee, wie ich zu Beginn sagte.  Oder Sie können Tests für das Modul erstellen und schreiben und den Testlauf ausführen und über Jenkins oder Travis erstellen.  Ja, eine Reihe von Szenarien, die Sie sich vorstellen können.  Mit diesem Ansatz ist dies jetzt viel einfacher. <br><br>  Fragen stellen, versuchen zu beantworten. <br><br>  PS Gehen Sie nicht vorbei, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">setzen Sie</a> bitte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Slackify-Stern auf GitHub</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439420/">https://habr.com/ru/post/de439420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439408/index.html">Pseudo Lens Flare</a></li>
<li><a href="../de439410/index.html">Jeff Hawkins ist endlich bereit, seine Gehirnforschung zu erklären</a></li>
<li><a href="../de439414/index.html">Client für "Push Message Server"</a></li>
<li><a href="../de439416/index.html">A-Frame Review Artikel</a></li>
<li><a href="../de439418/index.html">Pentaho Data Integration (PDI), Python und Deep Learning</a></li>
<li><a href="../de439422/index.html">Was braucht ein Programmierer, um Spiele zu entwickeln, und wer ist ein Spieleentwickler von einem Programmierer?</a></li>
<li><a href="../de439424/index.html">Wie ich mit kostenlosem Hosting und Composer zu kämpfen hatte</a></li>
<li><a href="../de439426/index.html">Situation: Eine neue Angriffswelle mit dem Abfangen von DNS-Abfragen - wir analysieren die grundlegenden Schutzmethoden</a></li>
<li><a href="../de439428/index.html">Wie können gezielte Cyber-Angriffe verhindert werden? 10 besten Netzwerksandboxen</a></li>
<li><a href="../de439430/index.html">Glaub mir, wenn du kannst. Wasserzähler. Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>