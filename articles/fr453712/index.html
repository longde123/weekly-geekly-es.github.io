<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÄ üí• ‚úäüèº Comment eBay a fait un scanner de codes-barres sur WebAssembly üìñ üòô üåÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Depuis son annonce, la technologie WebAssembly a imm√©diatement attir√© l'attention des d√©veloppeurs front-end. La communaut√© Web a accept√© avec enthous...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment eBay a fait un scanner de codes-barres sur WebAssembly</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453712/"> Depuis son annonce, la technologie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebAssembly</a> a imm√©diatement attir√© l'attention des d√©veloppeurs front-end.  La communaut√© Web a accept√© avec enthousiasme l'id√©e d'ex√©cuter du code dans un navigateur √©crit dans des langues autres que JavaScript.  L'essentiel est que WebAssembly garantit une vitesse beaucoup plus √©lev√©e que JavaScript. <br><br>  Nos ing√©nieurs ont suivi de pr√®s l'√©volution de la norme.  D√®s que le support de WebAssembly 1.0 a √©t√© impl√©ment√© dans tous les principaux navigateurs, les d√©veloppeurs ont imm√©diatement voulu l'essayer. <br><br>  Mais il y avait un probl√®me.  Bien que de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nombreuses applications</a> b√©n√©ficient de WebAssembly, la port√©e de la technologie dans le commerce √©lectronique est encore primitive.  Nous n'avons pas pu trouver imm√©diatement la version correcte de son utilisation.  Il y avait quelques suggestions, mais JavaScript √©tait meilleur dans toutes les variantes.  Lorsque nous √©valuons les nouvelles technologies sur eBay, la premi√®re question est: "Quels sont les avantages potentiels pour nos clients?"  S'il n'y a pas de clart√© ici, nous ne passerons pas √† l'√©tape suivante.  Il est tr√®s facile de se laisser emporter par les nouvelles technologies √† la mode, m√™me si cela n'a pas d'importance pour les clients et ne fait que compliquer le flux de travail existant.  L'exp√©rience utilisateur est toujours plus importante que l'exp√©rience d√©veloppeur.  Mais avec WebAssembly diff√©remment.  Cette technologie a un √©norme potentiel, nous n'avons tout simplement pas pu trouver le bon cas d'utilisation.  Cependant, √† la fin, ils l'ont toujours trouv√©. <br><a name="habracut"></a><br><h2>  Scanner de codes √† barres </h2><br>  Dans les applications natives eBay sur iOS et Android, il existe une fonction de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lecture de</a> codes-barres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UPC</a> pour entrer automatiquement dans le formulaire.  Il ne fonctionne que dans les applications et n√©cessite un traitement intensif des images sur l'appareil afin de reconna√Ætre les chiffres du code-barres dans le flux d'images de la cam√©ra.  Le code r√©sultant est ensuite envoy√© au service serveur qui, √† son tour, remplit le formulaire.  Cela signifie que la logique de traitement d'image sur l'appareil doit √™tre tr√®s efficace.  Pour les applications natives, nous avons compil√© notre propre biblioth√®que C ++ en code natif pour iOS et Android.  Il reconna√Æt exceptionnellement bien les codes-barres.  Nous passons progressivement aux API natives dans iOS et Android, mais notre biblioth√®que C ++ est toujours fiable. <br><br>  Le scanner de codes √† barres est une fonction intuitive pour les vendeurs, il simplifie consid√©rablement le remplissage du formulaire.  Malheureusement, cette fonction n'a pas fonctionn√© sur la version mobile du site, et les vendeurs ont d√ª saisir manuellement l'UPC, ce qui n'est pas pratique. <br><br><h2>  Scanner de codes √† barres Web </h2><br>  Nous cherchions une option pour scanner les codes-barres sur le Web.  Il y a deux ans, ils ont m√™me sorti un prototype bas√© sur la biblioth√®que JavaScript open source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BarcodeReader</a> .  Le probl√®me √©tait que cela ne fonctionnait bien que dans 20% des cas.  Les 80% restants, le scanner fonctionnait extr√™mement lentement ou ne fonctionnait pas du tout.  Dans la plupart des cas, c'√©tait un d√©lai d'attente.  C'est tout √† fait normal: JavaScript ne peut √™tre compar√© en vitesse avec du code natif que s'il est ¬´√† chaud¬ª, c'est-√†-dire qu'il est hautement optimis√© par les compilateurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JIT</a> .  L'astuce est que les moteurs JavaScript utilisent de nombreuses heuristiques pour d√©terminer si un chemin est "chaud" sans garantir un r√©sultat.  Cette divergence a √©videmment conduit √† la frustration des utilisateurs, et nous avons d√ª d√©sactiver cette fonctionnalit√©.  Mais maintenant, tout est diff√©rent.  Avec le d√©veloppement rapide de la plate-forme Web, la question s'est pos√©e: ¬´Est-il possible de mettre en place un scanner de codes-barres fiable sur le Web?¬ª <br><br>  Une option consiste √† attendre la fin de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API Shape Detection</a> avec ses fonctionnalit√©s int√©gr√©es de d√©tection d'image, y compris les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">codes-barres</a> .  Mais ces interfaces sont encore √† un stade tr√®s pr√©coce de d√©veloppement et sont loin d'√™tre compatibles avec plusieurs navigateurs.  Et m√™me dans ce cas, le travail sur toutes les plateformes n'est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pas garanti</a> .  Par cons√©quent, vous devez consid√©rer d'autres options. <br><br>  C'est l√† que WebAssembly entre en jeu.  Si un scanner de codes-barres est impl√©ment√© sur WebAssembly, il est garanti qu'il fonctionne.  La forte structure de typage et de bytecode de WebAssembly vous permet de toujours garder le "hot path" de l'ex√©cution.  De plus, nous avons d√©j√† une biblioth√®que C ++ pour les applications natives.  Les biblioth√®ques C ++ sont des candidats id√©aux pour la compilation dans WebAssembly.  Nous pensions que le probl√®me √©tait r√©solu.  Il s'est av√©r√©, pas vraiment. <br><br><h2>  L'architecture </h2><br>  L'architecture du prototype de travail pour le scanner de codes √† barres sur WebAssembly √©tait assez simple. <br><br><ul><li>  Compilez la biblioth√®que C ++ avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Emscripten</a> .  Il produira le middleware et le fichier .wasm. <br></li><li>  S√©lectionnez un thread de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">travail</a> dans le thread principal.  Le code JavaScript du travailleur importe le code de liaison JavaScript g√©n√©r√©, qui cr√©e √† son tour le fichier .wasm. <br></li><li>  Le flux principal envoie un instantan√© du flux de la cam√©ra au flux du travailleur, et il appellera l'API WASM correspondante via le code de connexion.  La r√©ponse de l'API est transmise au thread principal.  La r√©ponse peut √™tre une cha√Æne UPC (qui est transmise au backend) ou une cha√Æne vide si aucun code-barres n'est d√©tect√©. <br></li><li>  Pour une r√©ponse vierge, l'√©tape ci-dessus est r√©p√©t√©e jusqu'√† ce qu'un code-barres soit d√©tect√©.  Ce cycle s'ex√©cute pendant l'intervalle de temps sp√©cifi√© en secondes.  Une fois le seuil atteint, nous afficherons un message d'avertissement <i>¬´Code produit invalide.</i>  <i>Essayez un code √† barres ou une recherche de texte diff√©rent</i> . <i>"</i>  Soit l'utilisateur n'a pas focalis√© l'appareil photo sur un vrai code-barres, soit le scanner n'est pas suffisamment efficace.  Nous suivons les statistiques sur les d√©lais d'attente comme indicateur de la qualit√© du scanner. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/08c/b99/50e08cb9985f38e32a51caefe0a0356d.png"></div><br>  <i><font color="gray">Flux de travail WebAssembly</font></i> <br><br><h4>  Compilation </h4><br>  La premi√®re √©tape de tout projet WebAssembly consiste √† d√©finir un pipeline de compilation clair.  Emscripten est devenu la norme de facto pour la compilation de WebAssembly, mais il est important d'avoir un environnement coh√©rent qui produit un r√©sultat d√©terministe.  Notre frontend est bas√© sur Node.js, nous devons donc trouver une solution compatible avec le workflow npm.  Heureusement, √† cette √©poque, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Surma Das a</a> publi√© un article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intitul√© ¬´Emscripten and npm¬ª</a> .  L'approche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Docker</a> pour la compilation de WebAssembly est logique car elle √©limine une tonne de surcharge.  Comme recommand√© dans l'article, nous avons pris l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">image</a> docker <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'Emscripten</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trzeci</a> .  Pour activer la compilation dans WebAssembly, la biblioth√®que native C ++ a d√ª √™tre l√©g√®rement modifi√©e.  Fondamentalement, nous avons agi au hasard, par essais et erreurs.  √Ä la fin, j'ai r√©ussi √† le compiler et √† mettre en place un workflow WebAssembly soign√© dans le pipeline d'assemblage existant. <br><br><h4>  √áa marche vite, mais ... </h4><br>  Les performances du scanner sont mesur√©es par le nombre d'images trait√©es par l'API Wasm par seconde.  L'API Wasm prend une image du flux vid√©o de la cam√©ra, effectue des calculs et renvoie une r√©ponse.  Cela se fait sur une base continue jusqu'√† ce qu'un code-barres soit d√©tect√©.  Les performances sont mesur√©es en FPS. <br><br>  Notre impl√©mentation de test de WebAssembly a montr√© une vitesse incroyable de 50 FPS.  Cependant, cela n'a fonctionn√© que dans 60% des cas, et dans le reste, il s'est √©cras√© par le timeout.  M√™me avec un FPS aussi √©lev√©, ils ne pouvaient pas d√©tecter rapidement le code-barres pour les 40% de scans restants, donnant un message d'avertissement √† la fin.  En comparaison, l'impl√©mentation JavaScript pr√©c√©dente fonctionnait g√©n√©ralement √† 1 FPS.  Oui, WebAssembly est beaucoup plus rapide (50 fois), mais pour une raison quelconque, il ne fonctionne pas dans presque la moiti√© des cas.  Il convient √©galement de noter que dans certaines situations, JavaScript a tr√®s bien fonctionn√© et a imm√©diatement trouv√© le code-barres.  L'une des options √©videntes √©tait d'augmenter le d√©lai d'attente, mais cela ne fera qu'augmenter la frustration des utilisateurs, et donc nous ne r√©solvons pas le vrai probl√®me.  Par cons√©quent, nous avons abandonn√© cette id√©e. <br><br>  Au d√©but, nous ne pouvions pas comprendre pourquoi la biblioth√®que native C ++, qui fonctionnait parfaitement dans les applications natives, ne montrait pas le m√™me r√©sultat sur le Web.  Apr√®s de longs tests et d√©bogages, nous avons constat√© que la vitesse de reconnaissance d√©pend de l'angle de mise au point de l'objet et de l'ombre d'arri√®re-plan.  Mais comment alors tout fonctionne dans les applications natives?  Le fait est que dans les applications natives, nous utilisons les API int√©gr√©es pour la mise au point automatique et offrons √† l'utilisateur la possibilit√© de se concentrer manuellement en pointant un doigt sur le code-barres.  Par cons√©quent, les applications natives fournissent toujours √† la biblioth√®que des images claires de haute qualit√©. <br><br>  R√©alisant l'essentiel de ce qui se passe, nous avons d√©cid√© d'essayer une autre biblioth√®que native: un scanner de code √† barres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ZBar</a> open source assez populaire et stable.  Plus important encore, cela fonctionne bien avec des images floues et granuleuses.  Pourquoi ne pas essayer?  Comme nous avions d√©j√† le workflow WebAssembly, la compilation et le d√©ploiement de ZBar dans WebAssembly se sont bien d√©roul√©s.  Les performances se sont av√©r√©es d√©centes, environ 15 FPS, bien que pas aussi bonnes que celles de notre propre biblioth√®que C ++.  Mais le taux de r√©ussite √©tait proche de 80% pour le m√™me timeout.  Une nette am√©lioration par rapport √† notre biblioth√®que C ++, mais toujours pas √† 100%. <br><br>  Le r√©sultat ne nous a pas encore satisfaits, mais nous avons remarqu√© quelque chose d'inattendu.  L√† o√π Zbar s'est √©cras√©, notre propre biblioth√®que C ++ a fait le travail tr√®s rapidement.  Ce fut une agr√©able surprise.  Il semble que les biblioth√®ques aient trait√© les images de diff√©rentes qualit√©s de diff√©rentes mani√®res.  Cela nous a conduit √† l'id√©e. <br><br><h4>  Multithreading et course de vitesse </h4><br>  Vous avez probablement d√©j√† compris.  Pourquoi ne pas cr√©er deux threads de travail: un pour Zbar et un pour notre biblioth√®que C ++, et ne pas les ex√©cuter en parall√®le.  Celui qui a gagn√© (celui qui envoie d'abord un code-barres valide) envoie le r√©sultat au flux principal, et les deux travailleurs s'arr√™tent.  Nous avons mis en ≈ìuvre un tel sc√©nario et avons commenc√© √† nous tester, en essayant de simuler autant de sc√©narios que possible.  Ce param√®tre a montr√© 95% des analyses r√©ussies.  Beaucoup mieux que les r√©sultats pr√©c√©dents, mais toujours pas √† 100%. <br><br>  L'une des suggestions √©tranges √©tait d'ajouter la biblioth√®que JavaScipt originale √† la comp√©tition.  Ce sera trois volets.  Honn√™tement, nous ne pensions pas que cela changerait quoi que ce soit.  Mais un tel test n'a n√©cessit√© aucun effort, car nous avons standardis√© l'interface de travail.  √Ä notre grande surprise, avec trois volets, le taux de r√©ussite s'est vraiment approch√© de 100%.  C'√©tait encore une fois compl√®tement inattendu.  Comme mentionn√© pr√©c√©demment, JavaScript a tr√®s bien fonctionn√© dans certaines situations.  Apparemment, il a combl√© l'√©cart.  Ainsi, la sagesse populaire de la loi est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´JavaScript gagne toujours¬ª</a> .  Si sans blagues, l'illustration suivante donne un aper√ßu de l'architecture finale que nous avons impl√©ment√©e. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/422/f91/050/422f9105014e7571197453c7d2c9f6ec.png"></div><br>  <i><font color="gray">Scanner de codes-barres d'architecture Web</font></i> <br><br>  La figure suivante montre un diagramme fonctionnel de haut niveau: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/a74/005/4a6a740059f1599e759d9641a3251233.png"></div><br>  <i><font color="gray">Diagramme fonctionnel d'un lecteur de codes-barres</font></i> <br><br><h4>  Remarque sur le chargement des ressources </h4><br>  Les ressources n√©cessaires au fonctionnement du scanner sont pr√©charg√©es apr√®s le rendu de la page principale.  De cette fa√ßon, la page de destination se charge rapidement et est pr√™te √† interagir.  Les ressources WebAssembly (fichiers wasm et scripts middleware) et la biblioth√®que du scanner JavaScript sont pr√©charg√©es et mises en cache √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">XMLHttpRequest</a> apr√®s le chargement de la page principale.  Il est important ici qu'ils ne soient pas ex√©cut√©s imm√©diatement afin de laisser le thread principal libre pour l'interaction de l'utilisateur avec la page.  L'ex√©cution ne se produit que lorsque l'utilisateur clique sur l'ic√¥ne du code-barres.  Si l'utilisateur a cliqu√© sur l'ic√¥ne avant de charger les ressources, elles seront charg√©es √† la demande et imm√©diatement ex√©cut√©es.  Le gestionnaire d'√©v√©nements du lecteur de codes-barres et le contr√¥leur de travail sont charg√©s avec la page, mais ils sont tr√®s petits. <br><br><h2>  R√©sultats </h2><br>  Apr√®s des tests rigoureux et une utilisation interne par les employ√©s, nous avons lanc√© des tests A / B sur les utilisateurs.  L'ic√¥ne du scanner (capture d'√©cran ci-dessous) a √©t√© montr√©e au groupe de test, mais pas au groupe de contr√¥le. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb5/a30/074/bb5a300749c27008137e8f45c9bdced9.png"></div><br>  <i><font color="gray">Produit final</font></i> <br><br>  Pour mesurer le succ√®s, nous avons introduit la mesure du taux d'ach√®vement provisoire.  C'est le temps entre le d√©but de la modification d'un brouillon et la soumission d'un formulaire.  La m√©trique doit montrer comment un lecteur de codes-barres aide les gens √† remplir des formulaires.  Le test a dur√© plusieurs semaines et les r√©sultats ont √©t√© tr√®s agr√©ables.  Ils sont parfaitement coh√©rents avec notre hypoth√®se d'origine.  <b>Le temps de r√©alisation du brouillon a diminu√© de 30% pour un flux avec un lecteur de code-barres</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7f/f62/177/c7ff62177f92bc9f19059c569f2531ed.png"></div><br>  <i><font color="gray">R√©sultats du test A / B</font></i> <br><br>  Nous avons √©galement ajout√© un profilage pour √©valuer l'efficacit√© de tous les types de scanners.  Comme pr√©vu, la plus grande contribution a √©t√© apport√©e par Zbar (53% des scans r√©ussis), puis notre biblioth√®que C ++ (34%) et, enfin, la biblioth√®que JavaScript avec 13%. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/359/c5c/a31359c5c4211bf10548d8162370da89.png"></div><br><br><h2>  Conclusion </h2><br>  L'exp√©rience de la mise en ≈ìuvre de WebAssembly est devenue tr√®s informative pour nous.  Les ing√©nieurs sont tr√®s heureux de l'√©mergence de nouvelles technologies et souhaitent imm√©diatement les exp√©rimenter.  Si la technologie est √©galement utile pour les clients, c'est une double joie.  Reprenons la pens√©e exprim√©e au d√©but de l'article.  La technologie √©volue √† un rythme tr√®s rapide.  Chaque jour, quelque chose de nouveau appara√Æt.  Mais seules quelques technologies comptent pour les clients, et WebAssembly en fait partie.  Notre plus grande conclusion de cet exercice est de dire ¬´non¬ª dans 99 situations et ¬´oui¬ª dans le seul cas o√π c'est vraiment important pour les clients. <br><br>  √Ä l'avenir, nous pr√©voyons d'√©tendre l'utilisation d'un lecteur de codes-barres et de l'introduire du c√¥t√© des acheteurs, afin qu'ils puissent num√©riser les codes de produits hors ligne pour les rechercher et les acheter sur eBay.  Nous envisagerons √©galement d'√©tendre la fonction √† l'aide de l'API de d√©tection de forme et d'autres fonctions du navigateur.  Mais nous sommes heureux d'avoir trouv√© le bon cas d'utilisation pour WebAssembly sur eBay et d'avoir appliqu√© avec succ√®s la technologie dans le commerce √©lectronique. <br><br>  Un merci sp√©cial √† Surma Das et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lin Clark</a> pour leurs nombreux articles sur WebAssembly.  Ils nous ont vraiment aid√©s √† sortir de l'impasse plusieurs fois. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453712/">https://habr.com/ru/post/fr453712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453698/index.html">L'information quantique dans la conscience quantique</a></li>
<li><a href="../fr453700/index.html">Le√ßons sur SDL 2: Le√ßon 1 - Bonjour, SDL 2</a></li>
<li><a href="../fr453706/index.html">Comment j'ai r√©ussi l'examen de certification Google Cloud Professional Data Engineer</a></li>
<li><a href="../fr453708/index.html">Syst√®me d'exploitation en temps r√©el AQUA RTOS pour MK AVR dans l'environnement BASCOM AVR</a></li>
<li><a href="../fr453710/index.html">Pratique de d√©veloppement dans les grands projets: mitap SberPractice iOS # 1</a></li>
<li><a href="../fr453714/index.html">Client de test TON (Telegram Open Network) et le nouveau langage Fift pour les contrats intelligents</a></li>
<li><a href="../fr453716/index.html">Coworking √† la campagne pour les informaticiens familiaux - y a-t-il quelqu'un?</a></li>
<li><a href="../fr453720/index.html">Subtilit√©s d'expressions lambda en C #</a></li>
<li><a href="../fr453722/index.html">√Ä propos de la recherche de processus non stationnaires</a></li>
<li><a href="../fr453728/index.html">Bataille des hyperstars</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>