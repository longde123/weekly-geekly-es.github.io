<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš¶ğŸ» ğŸ¤® ğŸ‘¨ğŸ¿â€ğŸ“ å¯ä»¥ä¸å›¾å—å¡ä¸€èµ·ä½¿ç”¨çš„è¿‡ç¨‹æ¨¡å¼ ğŸ‘¦ğŸ½ ğŸ›¶ â°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ç¨‹åºç”Ÿæˆç”¨äºå¢åŠ æ¸¸æˆçš„å¯å˜æ€§ã€‚ è‘—åçš„é¡¹ç›®åŒ…æ‹¬Minecraft ï¼Œ Enter the Gungeonå’ŒDescenders ã€‚ åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘å°†è§£é‡Šä¸Tilemapç³»ç»Ÿä¸€èµ·ä½¿ç”¨æ—¶å¯ä»¥ä½¿ç”¨çš„ä¸€äº›ç®—æ³•ï¼Œè¯¥ç®—æ³•åœ¨Unity 2017.2å’ŒRuleTileä¸­ä»¥2Då‡½æ•°çš„å½¢å¼å‡ºç°ã€‚ 

 éšç€åœ°å›¾çš„ç¨‹åºåˆ›å»º...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>å¯ä»¥ä¸å›¾å—å¡ä¸€èµ·ä½¿ç”¨çš„è¿‡ç¨‹æ¨¡å¼</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471084/"> ç¨‹åºç”Ÿæˆç”¨äºå¢åŠ æ¸¸æˆçš„å¯å˜æ€§ã€‚  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">è‘—åçš„</a>é¡¹ç›®åŒ…æ‹¬<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Minecraft</a> ï¼Œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Enter the Gungeon</a>å’Œ<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Descenders</a> ã€‚ åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘å°†è§£é‡Šä¸<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tilemap</a>ç³»ç»Ÿä¸€èµ·ä½¿ç”¨æ—¶å¯ä»¥ä½¿ç”¨çš„ä¸€äº›ç®—æ³•ï¼Œè¯¥ç®—æ³•åœ¨Unity 2017.2å’Œ<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RuleTileä¸­</a>ä»¥2Då‡½æ•°çš„å½¢å¼å‡ºç°ã€‚ <br><br> éšç€åœ°å›¾çš„ç¨‹åºåˆ›å»ºï¼Œæ¯ä¸ªä¼ é€’çš„æ¸¸æˆå°†æ˜¯å”¯ä¸€çš„ã€‚ æ‚¨ç”šè‡³å¯ä»¥åœ¨ç»„è£…æ¸¸æˆåï¼Œä½¿ç”¨å„ç§è¾“å…¥æ•°æ®ï¼ˆä¾‹å¦‚ï¼Œæ—¶é—´æˆ–ç©å®¶çš„å½“å‰çº§åˆ«ï¼‰æ¥åŠ¨æ€æ›´æ”¹å†…å®¹ã€‚ <br><br><h2> è¿™ä¸ªå¸–å­æ˜¯å…³äºä»€ä¹ˆçš„ï¼Ÿ </h2><br> æˆ‘ä»¬å°†ä»‹ç»ä¸€äº›åˆ›å»ºè¿‡ç¨‹ä¸–ç•Œçš„æœ€å¸¸è§æ–¹æ³•ï¼Œä»¥åŠæˆ‘åˆ›å»ºçš„å‡ ç§å˜ä½“ã€‚ è¿™æ˜¯é˜…è¯»æœ¬æ–‡åå¯ä»¥åˆ›å»ºçš„ç¤ºä¾‹ã€‚ ä¸‰ç§ç®—æ³•å…±åŒä½¿ç”¨<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tilemap</a>å’Œ<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RuleTile</a>åˆ›å»ºåœ°å›¾ï¼š <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/44e/154/34944e154f324b508701b42877494500.gif"></div><br> åœ¨ä½¿ç”¨ä»»ä½•ç®—æ³•ç”Ÿæˆåœ°å›¾çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éƒ½ä¼šè·å¾—ä¸€ä¸ªåŒ…å«æ‰€æœ‰æ–°æ•°æ®çš„<code>int</code>æ•°ç»„ã€‚ æ‚¨å¯ä»¥ç»§ç»­ä¿®æ”¹æ­¤æ•°æ®æˆ–å°†å…¶æ¸²æŸ“åˆ°å›¾å—åœ°å›¾ã€‚ <br><a name="habracut"></a><br> åœ¨è¿›ä¸€æ­¥é˜…è¯»ä¹‹å‰ï¼Œå¾ˆé«˜å…´äº†è§£ä»¥ä¸‹å†…å®¹ï¼š <br><br><ol><li> æˆ‘ä»¬åŒºåˆ†ä»€ä¹ˆæ˜¯å›¾å—ï¼Œå“ªäº›ä¸ä½¿ç”¨äºŒè¿›åˆ¶å€¼ã€‚  1æ˜¯å›¾å—ï¼Œ0æ˜¯ä¸å­˜åœ¨ã€‚ </li><li> æˆ‘ä»¬å°†æ‰€æœ‰å¡å­˜å‚¨åœ¨æ¯ä¸ªå‡½æ•°æœ«å°¾è¿”å›ç»™ç”¨æˆ·çš„äºŒç»´æ•´æ•°æ•°ç»„ä¸­ï¼ˆæ‰§è¡Œæ¸²æŸ“çš„å‡½æ•°é™¤å¤–ï¼‰ã€‚ </li><li> æˆ‘å°†ä½¿ç”¨<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GetUpperBoundï¼ˆï¼‰</a>æ•°ç»„å‡½æ•°è·å–æ¯ä¸ªåœ°å›¾çš„é«˜åº¦å’Œå®½åº¦ï¼Œä»¥ä¾¿è¯¥å‡½æ•°æ¥æ”¶è¾ƒå°‘çš„å˜é‡ï¼Œå¹¶ä¸”ä»£ç æ›´<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ç®€æ´</a> ã€‚ </li><li> æˆ‘ç»å¸¸ä½¿ç”¨<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mathf.FloorToIntï¼ˆï¼‰</a> ï¼Œå› ä¸ºTilemapåæ ‡ç³»ä»å·¦ä¸‹è§’å¼€å§‹ï¼Œè€ŒMathf.FloorToIntï¼ˆï¼‰å…è®¸æ‚¨å°†æ•°å­—å››èˆäº”å…¥ä¸ºæ•´æ•°ã€‚ </li><li> è¿™ç¯‡æ–‡ç« ä¸­çš„æ‰€æœ‰ä»£ç éƒ½æ˜¯ç”¨Cï¼ƒç¼–å†™çš„ã€‚ </li></ol><br><h2> æ•°ç»„ç”Ÿæˆ </h2><br>  GenerateArrayåˆ›å»ºç»™å®šå¤§å°çš„æ–°<code>int</code>æ•°ç»„ã€‚ æˆ‘ä»¬è¿˜å¯ä»¥æŒ‡ç¤ºè¯¥æ•°ç»„æ˜¯åº”å¡«å……è¿˜æ˜¯ä¸ºç©ºï¼ˆ1æˆ–0ï¼‰ã€‚ è¿™æ˜¯ä»£ç ï¼š <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] GenerateArray(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> empty) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[width, height]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (empty) { map[x, y] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { map[x, y] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map; }</code> </pre> <br><h2> åœ°å›¾æ¸²æŸ“ </h2><br> æ­¤åŠŸèƒ½ç”¨äºåœ¨å¹³é“ºåœ°å›¾ä¸Šæ¸²æŸ“åœ°å›¾ã€‚ æˆ‘ä»¬å›´ç»•åœ°å›¾çš„å®½åº¦å’Œé«˜åº¦å¾ªç¯ï¼Œä»…åœ¨æµ‹è¯•ç‚¹å¤„çš„æ•°ç»„çš„å€¼ä¸º1æ—¶æ‰æ”¾ç½®å›¾å—ã€‚ <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] map, Tilemap tilemap, TileBase tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Clear the map (ensures we dont overlap) tilemap.ClearAllTiles(); //Loop through the width of the map for (int x = 0; x &lt; map.GetUpperBound(0) ; x++) { //Loop through the height of the map for (int y = 0; y &lt; map.GetUpperBound(1); y++) { // 1 = tile, 0 = no tile if (map[x, y] == 1) { tilemap.SetTile(new Vector3Int(x, y, 0), tile); } } } }</span></span></code> </pre> <br><h2> åœ°å›¾æ›´æ–° </h2><br> æ­¤åŠŸèƒ½ä»…ç”¨äºæ›´æ–°åœ°å›¾ï¼Œè€Œä¸ç”¨äºé‡æ–°æ¸²æŸ“ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ›´å°‘çš„èµ„æºï¼Œè€Œæ— éœ€é‡æ–°ç»˜åˆ¶æ¯ä¸ªå›¾å—åŠå…¶å›¾å—æ•°æ®ã€‚ <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] map, Tilemap tilemap</span></span></span><span class="hljs-function">) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//Takes in our map and tilemap, setting null tiles where needed { for (int x = 0; x &lt; map.GetUpperBound(0); x++) { for (int y = 0; y &lt; map.GetUpperBound(1); y++) { //We are only going to update the map, rather than rendering again //This is because it uses less resources to update tiles to null //As opposed to re-drawing every single tile (and collision data) if (map[x, y] == 0) { tilemap.SetTile(new Vector3Int(x, y, 0), null); } } } }</span></span></span></span></code> </pre> <br><h2> å™ªéŸ³ç€æ— </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ä½©æ—å™ªå£°</a>å¯ç”¨äºå„ç§ç›®çš„ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®ƒæ¥åˆ›å»ºåœ°å›¾çš„é¡¶å±‚ã€‚ ä¸ºæ­¤ï¼Œåªéœ€ä½¿ç”¨å½“å‰ä½ç½®xå’Œç§å­è·å¾—ä¸€ä¸ªæ–°ç‚¹ã€‚ <br><br><h3> ç®€å•çš„è§£å†³æ–¹æ¡ˆ </h3><br> è¿™ç§ç”Ÿæˆæ–¹æ³•ä½¿ç”¨äº†ç”µå¹³ç”Ÿæˆä¸­æœ€ç®€å•çš„å®ç°Perlinå™ªå£°çš„å½¢å¼ã€‚ æˆ‘ä»¬å¯ä»¥å°†Unityå‡½æ•°ç”¨äºæ¶ˆé™¤Perlinå™ªå£°ï¼Œå› æ­¤æˆ‘ä»¬ä¸å¿…è‡ªå·±ç¼–å†™ä»£ç ã€‚ ä½¿ç”¨<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mathf.FloorToIntï¼ˆï¼‰</a>å‡½æ•°ï¼Œæˆ‘ä»¬è¿˜å°†ä»…ä½¿ç”¨æ•´æ•°ä½œä¸ºå›¾å—æ˜ å°„ã€‚ <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] PerlinNoise(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newPoint; <span class="hljs-comment"><span class="hljs-comment">//Used to reduced the position of the Perlin point float reduction = 0.5f; //Create the Perlin for (int x = 0; x &lt; map.GetUpperBound(0); x++) { newPoint = Mathf.FloorToInt((Mathf.PerlinNoise(x, seed) - reduction) * map.GetUpperBound(1)); //Make sure the noise starts near the halfway point of the height newPoint += (map.GetUpperBound(1) / 2); for (int y = newPoint; y &gt;= 0; y--) { map[x, y] = 1; } } return map; }</span></span></code> </pre> <br> å‘ˆç°ä¸ºå›¾å—åœ°å›¾åçš„å¤–è§‚å¦‚ä¸‹ï¼š <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/ab8/4e1/d18ab84e1e13fa2f8480424cfecc3de5.gif"></div><br><h3> å¹³æ»‘å¤„ç† </h3><br> æ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨æ­¤åŠŸèƒ½å¹¶ä½¿å…¶å¹³æ»‘ã€‚ è®¾ç½®å›ºå®šPerliné«˜åº¦çš„æ—¶é—´é—´éš”ï¼Œç„¶ååœ¨è¿™äº›ç‚¹ä¹‹é—´æ‰§è¡Œå¹³æ»‘å¤„ç†ã€‚ äº‹å®è¯æ˜ï¼Œæ­¤å‡½æ•°ä¼šç¨å¾®å¤æ‚ä¸€ç‚¹ï¼Œå› ä¸ºå¯¹äºé—´éš”ï¼Œæ‚¨éœ€è¦è€ƒè™‘æ•´æ•°å€¼åˆ—è¡¨ã€‚ <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] PerlinNoiseSmooth(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interval) { <span class="hljs-comment"><span class="hljs-comment">//Smooth the noise and store it in the int array if (interval &gt; 1) { int newPoint, points; //Used to reduced the position of the Perlin point float reduction = 0.5f; //Used in the smoothing process Vector2Int currentPos, lastPos; //The corresponding points of the smoothing. One list for x and one for y List&lt;int&gt; noiseX = new List&lt;int&gt;(); List&lt;int&gt; noiseY = new List&lt;int&gt;(); //Generate the noise for (int x = 0; x &lt; map.GetUpperBound(0); x += interval) { newPoint = Mathf.FloorToInt((Mathf.PerlinNoise(x, (seed * reduction))) * map.GetUpperBound(1)); noiseY.Add(newPoint); noiseX.Add(x); } points = noiseY.Count;</span></span></code> </pre> <br> åœ¨æ­¤åŠŸèƒ½çš„ç¬¬ä¸€éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆæ£€æŸ¥é—´éš”æ˜¯å¦å¤§äºä¸€ä¸ªã€‚ å¦‚æœæ˜¯è¿™æ ·ï¼Œåˆ™äº§ç”Ÿå™ªéŸ³ã€‚ ç”Ÿæˆé—´éš”æ‰§è¡Œï¼Œä»¥ä¾¿å¯ä»¥åº”ç”¨å¹³æ»‘ã€‚ å‡½æ•°çš„ä¸‹ä¸€éƒ¨åˆ†æ˜¯å¹³æ»‘ç‚¹ã€‚ <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Start at 1 so we have a previous position already for (int i = 1; i &lt; points; i++) { //Get the current position currentPos = new Vector2Int(noiseX[i], noiseY[i]); //Also get the last position lastPos = new Vector2Int(noiseX[i - 1], noiseY[i - 1]); //Find the difference between the two Vector2 diff = currentPos - lastPos; //Set up what the height change value will be float heightChange = diff.y / interval; //Determine the current height float currHeight = lastPos.y; //Work our way through from the last x to the current x for (int x = lastPos.x; x &lt; currentPos.x; x++) { for (int y = Mathf.FloorToInt(currHeight); y &gt; 0; y--) { map[x, y] = 1; } currHeight += heightChange; } } }</span></span></code> </pre> <br> å¹³æ»‘æ‰§è¡Œå¦‚ä¸‹ï¼š <br><br><ol><li> æˆ‘ä»¬å¾—åˆ°å½“å‰å’Œæœ€åçš„ä½ç½® </li><li> æˆ‘ä»¬å¾—åˆ°ä¸¤ç‚¹ä¹‹é—´çš„å·®ï¼Œæˆ‘ä»¬éœ€è¦çš„æœ€é‡è¦çš„ä¿¡æ¯æ˜¯æ²¿yè½´çš„å·® </li><li> ç„¶åï¼Œæˆ‘ä»¬ç¡®å®šéœ€è¦å¤šå°‘å˜åŒ–æ‰èƒ½è¾¾åˆ°ç›®æ ‡ï¼Œè¿™æ˜¯é€šè¿‡å°†yçš„å·®é™¤ä»¥åŒºé—´å˜é‡æ¥å®Œæˆçš„ã€‚ </li><li> æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å¼€å§‹è®¾ç½®ä½ç½®ï¼Œä¸€ç›´åˆ°é›¶ </li><li> å½“æˆ‘ä»¬åœ¨yè½´ä¸Šè¾¾åˆ°0æ—¶ï¼Œå°†é«˜åº¦å˜åŒ–æ·»åŠ åˆ°å½“å‰é«˜åº¦ï¼Œç„¶åå¯¹ä¸‹ä¸€ä¸ªxä½ç½®é‡å¤è¯¥è¿‡ç¨‹ </li><li> åœ¨æœ€åä½ç½®å’Œå½“å‰ä½ç½®ä¹‹é—´çš„æ¯ä¸ªä½ç½®ç»“æŸæ—¶ï¼Œæˆ‘ä»¬ç§»è‡³ä¸‹ä¸€ä¸ªç‚¹ </li></ol><br> å¦‚æœé—´éš”å°äºä¸€ä¸ªï¼Œé‚£ä¹ˆæˆ‘ä»¬ä»…ä½¿ç”¨å‰ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒå°†ä¸ºæˆ‘ä»¬å®Œæˆæ‰€æœ‰å·¥ä½œã€‚ <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Defaults to a normal Perlin gen map = PerlinNoise(map, seed); } return map;</span></span></code> </pre> <br> è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹æ¸²æŸ“ï¼š <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91d/e8f/112/91de8f112bb1aa4bbd139245a1c8c215.gif"></div><br><h2> éšæœºæ¼«æ­¥ </h2><br><h3> éšæœºæ­¥è¡Œä¸Šè¡£ </h3><br> è¯¥ç®—æ³•æ‰§è¡Œç¡¬å¸ç¿»è½¬ã€‚ æˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸¤ä¸ªç»“æœä¹‹ä¸€ã€‚ å¦‚æœç»“æœæ˜¯â€œ eagleâ€ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†å—å‘ä¸Šç§»åŠ¨ï¼›å¦‚æœç»“æœæ˜¯â€œ tailsâ€ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†å—å‘ä¸‹ç§»åŠ¨ã€‚ é€šè¿‡ä¸æ–­å‘ä¸Šæˆ–å‘ä¸‹ç§»åŠ¨æ¥åˆ›å»ºé«˜åº¦ã€‚ è¿™ç§ç®—æ³•çš„å”¯ä¸€ç¼ºç‚¹æ˜¯å…¶éå¸¸æ˜æ˜¾çš„å—çŠ¶æ€§ã€‚ è®©æˆ‘ä»¬çœ‹çœ‹å®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚ <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] RandomWalkTop(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed) { <span class="hljs-comment"><span class="hljs-comment">//Seed our random System.Random rand = new System.Random(seed.GetHashCode()); //Set our starting height int lastHeight = Random.Range(0, map.GetUpperBound(1)); //Cycle through our width for (int x = 0; x &lt; map.GetUpperBound(0); x++) { //Flip a coin int nextMove = rand.Next(2); //If heads, and we aren't near the bottom, minus some height if (nextMove == 0 &amp;&amp; lastHeight &gt; 2) { lastHeight--; } //If tails, and we aren't near the top, add some height else if (nextMove == 1 &amp;&amp; lastHeight &lt; map.GetUpperBound(1) - 2) { lastHeight++; } //Circle through from the lastheight to the bottom for (int y = lastHeight; y &gt;= 0; y--) { map[x, y] = 1; } } //Return the map return map; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/791/cd4/57b791cd49bb1c967e994638406371a8.gif"></div><br>  <i>å¸¦æœ‰æŠ—é”¯é½¿çš„éšæœºæ­¥è¡Œä¸Šè¡£</i> <br><br> ä¸Perlinå™ªå£°ç”Ÿæˆç›¸æ¯”ï¼Œè¿™ç§ç”Ÿæˆä½¿æˆ‘ä»¬çš„é«˜åº¦æ›´å¹³æ»‘ã€‚ <br><br> ä¸ä»¥å‰çš„ç‰ˆæœ¬ç›¸æ¯”ï¼ŒRandom Walkçš„è¿™ç§å˜åŒ–æä¾›äº†æ›´åŠ å¹³æ»‘çš„ç»“æœã€‚ æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨å‡½æ•°ä¸­å†æ·»åŠ ä¸¤ä¸ªå˜é‡æ¥å®ç°å®ƒï¼š <br><br><ul><li> ç¬¬ä¸€ä¸ªå˜é‡ç”¨äºç¡®å®šç»´æŒå½“å‰é«˜åº¦éœ€è¦å¤šé•¿æ—¶é—´ã€‚ å®ƒæ˜¯æ•´æ•°ï¼Œå¹¶åœ¨é«˜åº¦å˜åŒ–æ—¶é‡ç½® </li><li> ç¬¬äºŒä¸ªå˜é‡è¾“å…¥åˆ°å‡½æ•°ä¸­ï¼Œå¹¶ç”¨ä½œé«˜åº¦çš„æœ€å°æˆªé¢å®½åº¦ã€‚ å½“æˆ‘ä»¬çœ‹åŠŸèƒ½æ—¶ï¼Œå®ƒå°†å˜å¾—æ›´åŠ æ¸…æ™°ã€‚ </li></ul><br> ç°åœ¨æˆ‘ä»¬çŸ¥é“è¦æ·»åŠ ä»€ä¹ˆã€‚ è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹å‡½æ•°ï¼š <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] RandomWalkTopSmoothed(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minSectionWidth) { <span class="hljs-comment"><span class="hljs-comment">//Seed our random System.Random rand = new System.Random(seed.GetHashCode()); //Determine the start position int lastHeight = Random.Range(0, map.GetUpperBound(1)); //Used to determine which direction to go int nextMove = 0; //Used to keep track of the current sections width int sectionWidth = 0; //Work through the array width for (int x = 0; x &lt;= map.GetUpperBound(0); x++) { //Determine the next move nextMove = rand.Next(2); //Only change the height if we have used the current height more than the minimum required section width if (nextMove == 0 &amp;&amp; lastHeight &gt; 0 &amp;&amp; sectionWidth &gt; minSectionWidth) { lastHeight--; sectionWidth = 0; } else if (nextMove == 1 &amp;&amp; lastHeight &lt; map.GetUpperBound(1) &amp;&amp; sectionWidth &gt; minSectionWidth) { lastHeight++; sectionWidth = 0; } //Increment the section width sectionWidth++; //Work our way from the height down to 0 for (int y = lastHeight; y &gt;= 0; y--) { map[x, y] = 1; } } //Return the modified map return map; }</span></span></code> </pre> <br> å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œé€šè¿‡å¹³æ»‘éšæœºæ¸¸èµ°ç®—æ³•ï¼Œæ‚¨å¯ä»¥åœ¨è¯¥æ°´å¹³ä¸Šè·å¾—æ¼‚äº®çš„å¹³å¦æ®µã€‚ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c1/baf/b53/7c1bafb53bda68f46d617fa4ee2f5c11.gif"></div><br><h2> ç»“è®º </h2><br> æˆ‘å¸Œæœ›æœ¬æ–‡èƒ½æ¿€å‘æ‚¨åœ¨é¡¹ç›®ä¸­ä½¿ç”¨è¿‡ç¨‹ç”Ÿæˆã€‚ å¦‚æœæ‚¨æƒ³äº†è§£æœ‰å…³è¿‡ç¨‹ç”Ÿæˆåœ°å›¾çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·æµè§ˆ<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">è¿‡ç¨‹ç”ŸæˆWiki</a>æˆ–<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Roguebasin.com</a>çš„ä¼˜ç§€èµ„æºã€‚ <br><br> åœ¨æœ¬æ–‡çš„ç¬¬äºŒéƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨è¿‡ç¨‹ç”Ÿæˆæ¥åˆ›å»ºæ´ç©´ç³»ç»Ÿã€‚ <br><br><h2> ç¬¬äºŒéƒ¨åˆ† </h2><br> æˆ‘ä»¬åœ¨æœ¬éƒ¨åˆ†ä¸­è®¨è®ºçš„æ‰€æœ‰å†…å®¹éƒ½å¯ä»¥åœ¨<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">è¯¥é¡¹ç›®ä¸­</a>æ‰¾åˆ°ã€‚ æ‚¨å¯ä»¥ä¸‹è½½èµ„äº§å¹¶å°è¯•è‡ªå·±çš„è¿‡ç¨‹ç®—æ³•ã€‚ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/44e/154/34944e154f324b508701b42877494500.gif"></div><br><h1> å™ªéŸ³ç€æ— </h1><br> åœ¨ä¸Šä¸€éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬ç ”ç©¶äº†åº”ç”¨<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Perlinå™ªå£°</a>åˆ›å»ºé¡¶å±‚çš„æ–¹æ³•ã€‚ å¹¸è¿çš„æ˜¯ï¼ŒPerlinçš„å™ªéŸ³ä¹Ÿå¯ä»¥ç”¨æ¥åˆ›å»ºæ´ç©´ã€‚ è¿™æ˜¯é€šè¿‡è®¡ç®—æ–°çš„Perlinå™ªå£°å€¼æ¥å®ç°çš„ï¼Œè¯¥å€¼æ¥æ”¶å½“å‰ä½ç½®çš„å‚æ•°ä¹˜ä»¥ä¿®é¥°ç¬¦ã€‚ ä¿®æ”¹å™¨çš„å€¼ä»‹äº0åˆ°1ä¹‹é—´ã€‚ä¿®æ”¹å™¨å€¼è¶Šé«˜ï¼ŒPerlinç”Ÿæˆè¶Šæ··ä¹±ã€‚ ç„¶åï¼Œæˆ‘ä»¬å°†æ­¤å€¼èˆå…¥ä¸ºæ•´æ•°ï¼ˆ0æˆ–1ï¼‰ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨mapæ•°ç»„ä¸­ã€‚ æŸ¥çœ‹å¦‚ä½•å®ç°ï¼š <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] PerlinNoiseCave(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> modifier, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> edgesAreWalls) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newPoint; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgesAreWalls &amp;&amp; (x == <span class="hljs-number"><span class="hljs-number">0</span></span> || y == <span class="hljs-number"><span class="hljs-number">0</span></span> || x == map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span> || y == map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { map[x, y] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Keep the edges as walls } else { //Generate a new point using Perlin noise, then round it to a value of either 0 or 1 newPoint = Mathf.RoundToInt(Mathf.PerlinNoise(x * modifier, y * modifier)); map[x, y] = newPoint; } } } return map; }</span></span></code> </pre> <br> æˆ‘ä»¬ä½¿ç”¨ä¿®é¥°ç¬¦è€Œä¸æ˜¯ç§å­ï¼Œå› ä¸ºå½“ä¹˜ä»¥0åˆ°0.5çš„æ•°å­—æ—¶ï¼ŒPerlinç”Ÿæˆçš„ç»“æœçœ‹èµ·æ¥æ›´å¥½ã€‚ å€¼è¶Šä½ï¼Œç»“æœå°†è¶Šå—çŠ¶ã€‚ çœ‹ä¸€ä¸‹æ ·æœ¬ç»“æœã€‚  Gifä»¥0.01çš„ä¿®æ”¹å™¨å€¼å¼€å§‹ï¼Œå¹¶é€æ¸è¾¾åˆ°0.25çš„å€¼ã€‚ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/abb/891/760abb891c7f225803aecc64c24af5ed.gif"></div><br> ä»æ­¤gifå¯ä»¥çœ‹å‡ºï¼Œæ¯æ¬¡å¢åŠ çš„Perlinç”Ÿæˆåªä¼šå¢åŠ æ¨¡å¼ã€‚ <br><br><h1> éšæœºæ¼«æ­¥ </h1><br> åœ¨ä¸Šä¸€éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°æ‚¨å¯ä»¥ä½¿ç”¨æŠ›ç¡¬å¸æ¥ç¡®å®šå¹³å°å°†åœ¨å“ªä¸ªä½ç½®å‘ä¸Šæˆ–å‘ä¸‹ç§»åŠ¨ã€‚ åœ¨è¿™ä¸€éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ç›¸åŒçš„æƒ³æ³•ï¼Œä½†æ˜¯ <br> å·¦ç§»å’Œå³ç§»ä¸¤ä¸ªé™„åŠ é€‰é¡¹ã€‚ éšæœºæ¸¸èµ°ç®—æ³•çš„è¿™ç§å˜åŒ–ä½¿æˆ‘ä»¬èƒ½å¤Ÿåˆ›å»ºæ´ç©´ã€‚ ä¸ºæ­¤ï¼Œæˆ‘ä»¬é€‰æ‹©ä¸€ä¸ªéšæœºæ–¹å‘ï¼Œç„¶åç§»åŠ¨æˆ‘ä»¬çš„ä½ç½®å¹¶åˆ é™¤å›¾å—ã€‚ æˆ‘ä»¬ç»§ç»­è¿›è¡Œæ­¤è¿‡ç¨‹ï¼Œç›´åˆ°è¾¾åˆ°éœ€è¦é”€æ¯çš„æ‰€éœ€ç“·ç –æ•°é‡ã€‚ åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä»…ä½¿ç”¨4ä¸ªæ–¹å‘ï¼šä¸Šï¼Œä¸‹ï¼Œå·¦ï¼Œå³ã€‚ <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] RandomWalkCave(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> requiredFloorPercent) { <span class="hljs-comment"><span class="hljs-comment">//Seed our random System.Random rand = new System.Random(seed.GetHashCode()); //Define our start x position int floorX = rand.Next(1, map.GetUpperBound(0) - 1); //Define our start y position int floorY = rand.Next(1, map.GetUpperBound(1) - 1); //Determine our required floorAmount int reqFloorAmount = ((map.GetUpperBound(1) * map.GetUpperBound(0)) * requiredFloorPercent) / 100; //Used for our while loop, when this reaches our reqFloorAmount we will stop tunneling int floorCount = 0; //Set our start position to not be a tile (0 = no tile, 1 = tile) map[floorX, floorY] = 0; //Increase our floor count floorCount++;</span></span></code> </pre> <br> è¯¥å‡½æ•°ä»ä»¥ä¸‹å†…å®¹å¼€å§‹ï¼š <br><br><ol><li> æ‰¾åˆ°èµ·å§‹ä½ç½® </li><li> è®¡ç®—è¦åˆ é™¤çš„åœ°ç –æ•°é‡ã€‚ </li><li> åœ¨èµ·å§‹ä½ç½®åˆ é™¤ç£è´´ </li><li> å°†å›¾å—æ•°åŠ ä¸€ã€‚ </li></ol><br> ç„¶åæˆ‘ä»¬è¿›å…¥<code>while</code> ã€‚ ä»–å°†åˆ›å»ºä¸€ä¸ªæ´ç©´ï¼š <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (floorCount &lt; reqFloorAmount) { <span class="hljs-comment"><span class="hljs-comment">//Determine our next direction int randDir = rand.Next(4); switch (randDir) { //Up case 0: //Ensure that the edges are still tiles if ((floorY + 1) &lt; map.GetUpperBound(1) - 1) { //Move the y up one floorY++; //Check if that piece is currently still a tile if (map[floorX, floorY] == 1) { //Change it to not a tile map[floorX, floorY] = 0; //Increase floor count floorCount++; } } break; //Down case 1: //Ensure that the edges are still tiles if ((floorY - 1) &gt; 1) { //Move the y down one floorY--; //Check if that piece is currently still a tile if (map[floorX, floorY] == 1) { //Change it to not a tile map[floorX, floorY] = 0; //Increase the floor count floorCount++; } } break; //Right case 2: //Ensure that the edges are still tiles if ((floorX + 1) &lt; map.GetUpperBound(0) - 1) { //Move the x to the right floorX++; //Check if that piece is currently still a tile if (map[floorX, floorY] == 1) { //Change it to not a tile map[floorX, floorY] = 0; //Increase the floor count floorCount++; } } break; //Left case 3: //Ensure that the edges are still tiles if ((floorX - 1) &gt; 1) { //Move the x to the left floorX--; //Check if that piece is currently still a tile if (map[floorX, floorY] == 1) { //Change it to not a tile map[floorX, floorY] = 0; //Increase the floor count floorCount++; } } break; } } //Return the updated map return map; }</span></span></code> </pre> <br><h3> æˆ‘ä»¬åœ¨è¿™é‡Œåšä»€ä¹ˆï¼Ÿ </h3><br> å¥½å§ï¼Œé¦–å…ˆï¼Œå€ŸåŠ©éšæœºæ•°ï¼Œæˆ‘ä»¬é€‰æ‹©è¦ç§»åŠ¨çš„æ–¹å‘ã€‚ ç„¶åï¼Œä½¿ç”¨<code>switch case</code>æ£€æŸ¥æ–°æ–¹å‘ã€‚ åœ¨æ­¤è¯­å¥ä¸­ï¼Œæˆ‘ä»¬æ£€æŸ¥ä½ç½®æ˜¯å¦ä¸ºå¢™ã€‚ å¦‚æœä¸æ˜¯ï¼Œåˆ™ä»æ•°ç»„ä¸­åˆ é™¤å¸¦æœ‰å›¾å—çš„å…ƒç´ ã€‚ æˆ‘ä»¬ä¼šç»§ç»­è¿™æ ·åšï¼Œç›´åˆ°è¾¾åˆ°æ‰€éœ€çš„åœ°æ¿é¢ç§¯ä¸ºæ­¢ã€‚ ç»“æœå¦‚ä¸‹æ‰€ç¤ºï¼š <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c6/fc1/86c/2c6fc186c67095e13c1dcbea4c95aff4.gif"></div><br> æˆ‘è¿˜åˆ›å»ºäº†è¯¥å‡½æ•°çš„è‡ªå·±çš„ç‰ˆæœ¬ï¼Œå…¶ä¸­è¿˜åŒ…æ‹¬å¯¹è§’çº¿æ–¹å‘ã€‚ è¯¥åŠŸèƒ½ä»£ç å¾ˆé•¿ï¼Œå› æ­¤ï¼Œå¦‚æœè¦æŸ¥çœ‹å®ƒï¼Œè¯·ä»æœ¬æ–‡æ­¤éƒ¨åˆ†å¼€å¤´çš„é“¾æ¥ä¸‹è½½è¯¥é¡¹ç›®ã€‚ <br><br><h1> å®šå‘éš§é“ </h1><br> å®šå‘éš§é“å§‹äºåœ°å›¾çš„ä¸€ä¸ªè¾¹ç¼˜ï¼Œç„¶ååˆ°è¾¾ç›¸å¯¹çš„è¾¹ç¼˜ã€‚ æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†éš§é“çš„æ›²ç‡å’Œç²—ç³™åº¦ä¼ é€’ç»™è¾“å…¥å‡½æ•°æ¥æ§åˆ¶å®ƒä»¬ã€‚ æˆ‘ä»¬è¿˜å¯ä»¥è®¾ç½®éš§é“å„éƒ¨åˆ†çš„æœ€å°å’Œæœ€å¤§é•¿åº¦ã€‚ è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹å®ç°ï¼š <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] DirectionalTunnel(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minPathWidth, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxPathWidth, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxPathChange, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roughness, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curvyness) { <span class="hljs-comment"><span class="hljs-comment">//This value goes from its minus counterpart to its positive value, in this case with a width value of 1, the width of the tunnel is 3 int tunnelWidth = 1; //Set the start X position to the center of the tunnel int x = map.GetUpperBound(0) / 2; //Set up our random with the seed System.Random rand = new System.Random(Time.time.GetHashCode()); //Create the first part of the tunnel for (int i = -tunnelWidth; i &lt;= tunnelWidth; i++) { map[x + i, 0] = 0; }</span></span></code> </pre> <br><h3> è¿™æ˜¯æ€ä¹ˆå›äº‹ï¼Ÿ </h3><br> é¦–å…ˆï¼Œæˆ‘ä»¬è®¾ç½®å®½åº¦å€¼ã€‚ å®½åº¦å€¼å°†ä»è´Ÿæ•°å˜ä¸ºæ­£æ•°ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬å°†è·å¾—æ‰€éœ€çš„å°ºå¯¸ã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä½¿ç”¨å€¼1ï¼Œè¿™å°†ä½¿æˆ‘ä»¬çš„æ€»å®½åº¦ä¸º3ï¼Œå› ä¸ºæˆ‘ä»¬ä½¿ç”¨å€¼-1ã€0ã€1ã€‚ <br><br> æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬åœ¨xä¸­è®¾ç½®åˆå§‹ä½ç½®ï¼Œä¸ºæ­¤ï¼Œæˆ‘ä»¬é‡‡ç”¨äº†åœ°å›¾å®½åº¦çš„ä¸­é—´ä½ç½®ã€‚ ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥åœ¨åœ°å›¾çš„ç¬¬ä¸€éƒ¨åˆ†ä¸­é“ºè®¾ä¸€æ¡éš§é“ã€‚ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/605/0a7/552/6050a75522b8d628722d5373ddee8c76.png"></div><br> ç°åœ¨ï¼Œè®©æˆ‘ä»¬è¿›å…¥åœ°å›¾çš„å…¶ä½™éƒ¨åˆ†ã€‚ <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//Cycle through the array for (int y = 1; y &lt; map.GetUpperBound(1); y++) { //Check if we can change the roughness if (rand.Next(0, 100) &gt; roughness) { //Get the amount we will change for the width int widthChange = Random.Range(-maxPathWidth, maxPathWidth); //Add it to our tunnel width value tunnelWidth += widthChange; //Check to see we arent making the path too small if (tunnelWidth &lt; minPathWidth) { tunnelWidth = minPathWidth; } //Check that the path width isnt over our maximum if (tunnelWidth &gt; maxPathWidth) { tunnelWidth = maxPathWidth; } } //Check if we can change the curve if (rand.Next(0, 100) &gt; curvyness) { //Get the amount we will change for the x position int xChange = Random.Range(-maxPathChange, maxPathChange); //Add it to our x value x += xChange; //Check we arent too close to the left side of the map if (x &lt; maxPathWidth) { x = maxPathWidth; } //Check we arent too close to the right side of the map if (x &gt; (map.GetUpperBound(0) - maxPathWidth)) { x = map.GetUpperBound(0) - maxPathWidth; } } //Work through the width of the tunnel for (int i = -tunnelWidth; i &lt;= tunnelWidth; i++) { map[x + i, y] = 0; } } return map; }</span></span></code> </pre> <br> æˆ‘ä»¬ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ä¸ç²—ç³™åº¦å€¼è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœç²—ç³™åº¦å€¼å¤§äºè¯¥å€¼ï¼Œåˆ™å¯ä»¥æ›´æ”¹è·¯å¾„å®½åº¦ã€‚ æˆ‘ä»¬è¿˜æ£€æŸ¥è¯¥å€¼ï¼Œä»¥å…å®½åº¦å¤ªå°ã€‚ åœ¨ä»£ç çš„ä¸‹ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†é€æ­¥æµè§ˆåœ°å›¾ã€‚ åœ¨æ¯ä¸ªé˜¶æ®µï¼Œå‘ç”Ÿä»¥ä¸‹æƒ…å†µï¼š <br><br><ol><li> ä¸æ›²ç‡å€¼ç›¸æ¯”ï¼Œæˆ‘ä»¬ç”Ÿæˆäº†ä¸€ä¸ªæ–°çš„éšæœºæ•°ã€‚ ä¸ä¹‹å‰çš„æµ‹è¯•ä¸€æ ·ï¼Œå¦‚æœè¯¥å€¼å¤§äºè¯¥å€¼ï¼Œåˆ™æˆ‘ä»¬æ›´æ”¹è·¯å¾„çš„ä¸­å¿ƒç‚¹ã€‚ æˆ‘ä»¬è¿˜ä¼šè¿›è¡Œæ£€æŸ¥ï¼Œä»¥å…è¶…å‡ºåœ°å›¾èŒƒå›´ã€‚ </li><li> æœ€åï¼Œæˆ‘ä»¬åœ¨æ–°åˆ›å»ºçš„é›¶ä»¶ä¸­é“ºè®¾äº†ä¸€æ¡éš§é“ã€‚ </li></ol><br> è¯¥å®ç°çš„ç»“æœå¦‚ä¸‹æ‰€ç¤ºï¼š <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d25/bd4/d34/d25bd4d348871f08fcb383c3508ab25f.gif"></div><br><h1> ç»†èƒè‡ªåŠ¨æœº </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">å…ƒèƒè‡ªåŠ¨æœº</a>ä½¿ç”¨ç›¸é‚»å•å…ƒæ ¼æ¥ç¡®å®šå½“å‰å•å…ƒæ ¼æ˜¯æ‰“å¼€ï¼ˆ1ï¼‰è¿˜æ˜¯å…³é—­ï¼ˆ0ï¼‰ã€‚ ç”¨äºç¡®å®šç›¸é‚»å°åŒºçš„åŸºç¡€æ˜¯åŸºäºéšæœºç”Ÿæˆçš„å°åŒºç½‘æ ¼åˆ›å»ºçš„ã€‚ æˆ‘ä»¬å°†ä½¿ç”¨Cï¼ƒ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Random.Next</a>å‡½æ•°ç”Ÿæˆæ­¤æºç½‘æ ¼ã€‚ <br><br> ç”±äºæˆ‘ä»¬æœ‰å‡ ç§ç»†èƒè‡ªåŠ¨æœºçš„ä¸åŒå®ç°ï¼Œå› æ­¤æˆ‘ç¼–å†™äº†ä¸€ä¸ªå•ç‹¬çš„å‡½æ•°æ¥ç”Ÿæˆæ­¤åŸºæœ¬ç½‘æ ¼ã€‚ è¯¥å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºï¼š <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] GenerateCellularAutomata(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fillPercent, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> edgesAreWalls) { <span class="hljs-comment"><span class="hljs-comment">//Seed our random number generator System.Random rand = new System.Random(seed.GetHashCode()); //Initialise the map int[,] map = new int[width, height]; for (int x = 0; x &lt; map.GetUpperBound(0); x++) { for (int y = 0; y &lt; map.GetUpperBound(1); y++) { //If we have the edges set to be walls, ensure the cell is set to on (1) if (edgesAreWalls &amp;&amp; (x == 0 || x == map.GetUpperBound(0) - 1 || y == 0 || y == map.GetUpperBound(1) - 1)) { map[x, y] = 1; } else { //Randomly generate the grid map[x, y] = (rand.Next(0, 100) &lt; fillPercent) ? 1 : 0; } } } return map; }</span></span></code> </pre> <br> åœ¨æ­¤åŠŸèƒ½ä¸­ï¼Œæ‚¨è¿˜å¯ä»¥è®¾ç½®æˆ‘ä»¬çš„ç½‘æ ¼æ˜¯å¦éœ€è¦å¢™ã€‚ åœ¨æ‰€æœ‰å…¶ä»–æ–¹é¢ï¼Œè¿™éå¸¸ç®€å•ã€‚ æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸ªå…·æœ‰ç™¾åˆ†æ¯”å¡«å……çš„éšæœºæ•°ï¼Œä»¥ç¡®å®šæ˜¯å¦å¯ç”¨äº†å½“å‰å•å…ƒæ ¼ã€‚ çœ‹ä¸€ä¸‹ç»“æœï¼š <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/585/bfa/9ec/585bfa9ec7953056e160af10b4efbc88.gif"></div><br><h2> æ‘©å°”é™„è¿‘ </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">æ‘©å°”é‚»åŸŸ</a>ç”¨äºå¹³æ»‘ç»†èƒè‡ªåŠ¨æœºçš„åˆå§‹ç”Ÿæˆã€‚ æ‘©å°”é™„è¿‘çœ‹èµ·æ¥åƒè¿™æ ·ï¼š <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30b/c02/328/30bc02328e772a2955aa071bfdbc2cc6.png"></div><br> ä»¥ä¸‹è§„åˆ™é€‚ç”¨äºé‚»å±…ï¼š <br><br><ul><li> æˆ‘ä»¬åœ¨æ¯ä¸ªæ–¹å‘ä¸Šæ£€æŸ¥é‚»å±…ã€‚ </li><li> å¦‚æœé‚»å±…æ˜¯æ´»åŠ¨å›¾å—ï¼Œåˆ™å°†å…¶æ·»åŠ åˆ°å‘¨å›´å›¾å—çš„æ•°é‡ä¸­ã€‚ </li><li> å¦‚æœé‚»å±…æ˜¯ä¸æ´»åŠ¨çš„å›¾å—ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä»€ä¹ˆä¹Ÿä¸åšã€‚ </li><li> å¦‚æœä¸€ä¸ªå•å…ƒå…·æœ‰4ä¸ªä»¥ä¸Šçš„å‘¨å›´å›¾å—ï¼Œåˆ™ä½¿è¯¥å•å…ƒå¤„äºæ´»åŠ¨çŠ¶æ€ã€‚ </li><li> å¦‚æœè¯¥å•å…ƒæ ¼æ°å¥½æœ‰4ä¸ªå‘¨å›´çš„å›¾å—ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†å¯¹å…¶ä¸æ‰§è¡Œä»»ä½•æ“ä½œã€‚ </li><li> é‡å¤è¿›è¡Œï¼Œç›´åˆ°æˆ‘ä»¬æ£€æŸ¥æ¯ä¸ªåœ°å›¾å›¾å—ã€‚ </li></ul><br> æ‘©å°”çš„é‚»åŸŸæ£€æŸ¥åŠŸèƒ½å¦‚ä¸‹ï¼š <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMooreSurroundingTiles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> edgesAreWalls</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Moore Neighbourhood looks like this ('T' is our tile, 'N' is our neighbours) * * NNN * NTN * NNN * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tileCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neighbourX = x - <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbourX &lt;= x + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbourX++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neighbourY = y - <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbourY &lt;= y + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbourY++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbourX &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; neighbourX &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; neighbourY &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; neighbourY &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//We don't want to count the tile we are checking the surroundings of if(neighbourX != x || neighbourY != y) { tileCount += map[neighbourX, neighbourY]; } } } } return tileCount; }</span></span></code> </pre> <br> æ£€æŸ¥å›¾å—åï¼Œæˆ‘ä»¬åœ¨å¹³æ»‘åŠŸèƒ½ä¸­ä½¿ç”¨æ­¤ä¿¡æ¯ã€‚ åœ¨è¿™é‡Œï¼Œå°±åƒç”Ÿæˆç»†èƒè‡ªåŠ¨æœºä¸€æ ·ï¼Œäººä»¬å¯ä»¥æŒ‡å‡ºåœ°å›¾çš„è¾¹ç¼˜æ˜¯å¦åº”è¯¥æ˜¯å¢™å£ã€‚ <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] SmoothMooreCellularAutomata(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> edgesAreWalls, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> smoothCount) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; smoothCount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> surroundingTiles = GetMooreSurroundingTiles(map, x, y, edgesAreWalls); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgesAreWalls &amp;&amp; (x == <span class="hljs-number"><span class="hljs-number">0</span></span> || x == (map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>) || y == <span class="hljs-number"><span class="hljs-number">0</span></span> || y == (map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>))) { <span class="hljs-comment"><span class="hljs-comment">//Set the edge to be a wall if we have edgesAreWalls to be true map[x, y] = 1; } //The default moore rule requires more than 4 neighbours else if (surroundingTiles &gt; 4) { map[x, y] = 1; } else if (surroundingTiles &lt; 4) { map[x, y] = 0; } } } } //Return the modified map return map; }</span></span></code> </pre> <br> åœ¨æ­¤å¿…é¡»æ³¨æ„ï¼Œè¯¥å‡½æ•°å…·æœ‰<code>for</code>å¾ªç¯ï¼Œè¯¥å¾ªç¯æ‰§è¡Œå¹³æ»‘æŒ‡å®šçš„æ¬¡æ•°ã€‚ å› æ­¤ï¼Œå¯ä»¥è·å¾—æ›´æ¼‚äº®çš„å¡ç‰‡ã€‚ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68f/082/25c/68f08225c0c31cb243969192744f7b16.gif"></div><br> ä¾‹å¦‚ï¼Œå¦‚æœå®ƒä»¬ä¹‹é—´åªæœ‰ä¸¤ä¸ªå—ï¼Œæˆ‘ä»¬æ€»æ˜¯å¯ä»¥é€šè¿‡è¿æ¥æˆ¿é—´æ¥ä¿®æ”¹æ­¤ç®—æ³•ã€‚ <br><br><h2> å†¯Â·è¯ºä¾æ›¼ç¤¾åŒº </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">å†¯Â·è¯ºä¼Šæ›¼é™„è¿‘</a>æ˜¯å®ç°ç»†èƒè‡ªåŠ¨æœºçš„å¦ä¸€ç§æµè¡Œæ–¹æ³•ã€‚ å¯¹äºè¿™æ ·çš„ä¸€ä»£ï¼Œæˆ‘ä»¬ä½¿ç”¨æ¯”æ‘©å°”ä¸€ä»£æ›´ç®€å•çš„é‚»åŸŸã€‚ é‚»å±…çœ‹èµ·æ¥åƒè¿™æ ·ï¼š <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/952/d30/66c/952d3066c638932947db9c9a95ee36bf.png"></div><br> ä»¥ä¸‹è§„åˆ™é€‚ç”¨äºé‚»å±…ï¼š <br><br><ul><li> æˆ‘ä»¬æ£€æŸ¥å›¾å—çš„ç›´æ¥é‚»å±…ï¼Œè€Œä¸è€ƒè™‘å¯¹è§’çº¿çš„é‚»å±…ã€‚ </li><li> å¦‚æœå•å…ƒæ ¼å¤„äºæ´»åŠ¨çŠ¶æ€ï¼Œåˆ™å°†æ•°é‡åŠ ä¸€ã€‚ </li><li> å¦‚æœè¯¥å•å…ƒå¤„äºéæ´»åŠ¨çŠ¶æ€ï¼Œåˆ™ä»€ä¹ˆä¹Ÿä¸åšã€‚ </li><li> å¦‚æœè¯¥å•å…ƒå…·æœ‰ä¸¤ä¸ªä»¥ä¸Šçš„é‚»å±…ï¼Œåˆ™æˆ‘ä»¬ä½¿å½“å‰å•å…ƒå¤„äºæ´»åŠ¨çŠ¶æ€ã€‚ </li><li> å¦‚æœè¯¥å•å…ƒå…·æœ‰å°‘äº2ä¸ªé‚»å±…ï¼Œåˆ™æˆ‘ä»¬ä½¿å½“å‰å•å…ƒå¤„äºéæ´»åŠ¨çŠ¶æ€ã€‚ </li><li> å¦‚æœæ°å¥½æœ‰2ä¸ªé‚»å±…ï¼Œåˆ™ä¸è¦æ›´æ”¹å½“å‰å•å…ƒæ ¼ã€‚ </li></ul><br> ç¬¬äºŒä¸ªç»“æœä½¿ç”¨ä¸ç¬¬ä¸€ä¸ªç›¸åŒçš„åŸç†ï¼Œä½†æ˜¯æ‰©å¤§äº†é‚»åŸŸçš„é¢ç§¯ã€‚ <br><br>       : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVNSurroundingTiles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> edgesAreWalls</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* von Neumann Neighbourhood looks like this ('T' is our Tile, 'N' is our Neighbour) * * N * NTN * N * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tileCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Keep the edges as walls if(edgesAreWalls &amp;&amp; (x - 1 == 0 || x + 1 == map.GetUpperBound(0) || y - 1 == 0 || y + 1 == map.GetUpperBound(1))) { tileCount++; } //Ensure we aren't touching the left side of the map if(x - 1 &gt; 0) { tileCount += map[x - 1, y]; } //Ensure we aren't touching the bottom of the map if(y - 1 &gt; 0) { tileCount += map[x, y - 1]; } //Ensure we aren't touching the right side of the map if(x + 1 &lt; map.GetUpperBound(0)) { tileCount += map[x + 1, y]; } //Ensure we aren't touching the top of the map if(y + 1 &lt; map.GetUpperBound(1)) { tileCount += map[x, y + 1]; } return tileCount; }</span></span></code> </pre> <br>   ,     .   ,    <code>for</code>        . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] SmoothVNCellularAutomata(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> edgesAreWalls, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> smoothCount) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; smoothCount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-comment"><span class="hljs-comment">//Get the surrounding tiles int surroundingTiles = GetVNSurroundingTiles(map, x, y, edgesAreWalls); if (edgesAreWalls &amp;&amp; (x == 0 || x == map.GetUpperBound(0) - 1 || y == 0 || y == map.GetUpperBound(1))) { //Keep our edges as walls map[x, y] = 1; } //von Neuemann Neighbourhood requires only 3 or more surrounding tiles to be changed to a tile else if (surroundingTiles &gt; 2) { map[x, y] = 1; } else if (surroundingTiles &lt; 2) { map[x, y] = 0; } } } } //Return the modified map return map; }</span></span></code> </pre> <br>   ,      ,    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c15/fcd/1bb/c15fcd1bb16d2451b47fb7d37aea1f9b.gif"></div><br> ,     ,          . <br><br><h1> ç»“è®º </h1><br> ,         -   .      ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN471084/">https://habr.com/ru/post/zh-CN471084/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN471072/index.html">ç”µæŠ¥ä¸­æœ‰å¤šå°‘å…‹ï¼Ÿ</a></li>
<li><a href="../zh-CN471074/index.html">Synet-åœ¨CPUä¸Šå¯åŠ¨é¢„è®­ç»ƒçš„ç¥ç»ç½‘ç»œçš„æ¡†æ¶</a></li>
<li><a href="../zh-CN471076/index.html">çŸ©é˜µå¦‚ä½•åˆ›å»ºé˜²å¼¹é—äº§</a></li>
<li><a href="../zh-CN471078/index.html">Chromeæµè§ˆå™¨å°†å®Œå…¨é˜»æ­¢æ··åˆå†…å®¹</a></li>
<li><a href="../zh-CN471080/index.html">è°è´Ÿè´£æµ‹è¯•åº”ç”¨ç¨‹åºçš„è´¨é‡ï¼Ÿ ç”Ÿäº§ä¸­å‡ºé”™çš„10ä¸ªåŸå› </a></li>
<li><a href="../zh-CN471086/index.html">Blenderä¸­çš„PythonéŸ³ä¹å°é¢ç”Ÿæˆå™¨</a></li>
<li><a href="../zh-CN471088/index.html">ç²¾ç–²åŠ›å°½çš„ITä¸“å®¶ï¼šç»ç†ï¼Œå¼€å‘äººå‘˜ï¼Œäº§å“å’Œç®¡ç†å‘˜çš„4ä¸ªæ•…äº‹ã€‚ è¿˜æœ‰å—æ¡¥çš„é£Ÿè°±</a></li>
<li><a href="../zh-CN471090/index.html">[è¯·å‹¿ä½¿ç”¨CDN</a></li>
<li><a href="../zh-CN471092/index.html">cpå‘½ä»¤ï¼šå°†æ–‡ä»¶å¤¹æ­£ç¡®å¤åˆ¶åˆ°* nix</a></li>
<li><a href="../zh-CN471094/index.html">Tutu.ruå’Œè«æ–¯ç§‘ç¨‹åºå‘˜ä¿±ä¹éƒ¨è¢«é‚€è¯·å‚åŠ 10æœˆ17æ—¥çš„åç«¯ä¼šè®®</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>