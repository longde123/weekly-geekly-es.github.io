<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèΩ üèµÔ∏è üîü Apa warna fungsi Anda? üë£ üì• ü•¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya tidak tahu tentang Anda, tetapi bagi saya tidak ada yang lebih baik untuk memulai hari daripada memikirkan pemrograman. Darah mendidih saat melih...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa warna fungsi Anda?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466337/"><p>  Saya tidak tahu tentang Anda, tetapi bagi saya tidak ada yang lebih baik untuk memulai hari daripada memikirkan pemrograman.  Darah mendidih saat melihat kritik yang sukses terhadap salah satu bahasa "berani" yang digunakan oleh orang-orang Plebeian, tersiksa dengan itu sepanjang hari kerja antara kunjungan yang pemalu ke StackOverflow. </p><br><p>  (Sementara itu, Anda dan saya hanya menggunakan bahasa yang paling tercerahkan dan alat-alat canggih yang dirancang untuk tangan-tangan ahli seperti kita). </p><br><p>  Tentu saja, sebagai penulis khotbah, saya mengambil risiko.  Anda mungkin menyukai bahasa yang saya hina!  Sebuah pamflet yang ceroboh mungkin secara tidak sengaja membawa ke blog saya gerombolan ponsel yang marah dengan garpu rumput dan obor. </p><br><p>  Untuk melindungi diri saya dari api yang benar dan tidak menyinggung perasaan Anda (mungkin halus), saya akan berbicara tentang bahasa ... </p><a name="habracut"></a><br><p>  ... yang baru saja datang.  Tentang patung jerami, yang perannya hanya membakar kritik di tiang pancang. </p><br><p>  Saya tahu ini kedengarannya konyol, tapi percayalah, pada akhirnya kita akan melihat wajah siapa (atau wajah) yang dilukis di atas kepala jerami. </p><br><h1 id="novyy-yazyk">  Bahasa baru </h1><br><p> Ini akan menjadi infleksi untuk mempelajari bahasa yang sama sekali baru (dan sial) hanya untuk artikel blog, jadi katakanlah itu sangat mirip dengan bahasa yang sudah kita ketahui.  Misalnya Javascript.  Kurung kurawal dan titik koma.  <code>if</code> , <code>while</code> , dll.  - <em>Lingua franca dari</em> kerumunan kita. </p><br><p>  Saya memilih JS bukan karena artikel ini tentang dia.  Ini hanya bahasa yang bisa dipahami oleh pembaca rata-rata.  Voila: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thisIsAFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span>; }</code> </pre> <br><p>  Karena boneka kami adalah bahasa yang <em>keren</em> (baca - buruk), ia memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi kelas satu</a> .  Jadi Anda dapat menulis sesuatu seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,     , //    function filter(collection, predicate) { var result = []; for (var i = 0; i &lt; collection.length; i++) { if (predicate(collection[i])){ result.push(collection[i]); } } return result; }</span></span></code> </pre> <br><p>  Ini adalah salah satu fitur <em>kelas satu</em> , dan seperti namanya, mereka keren dan sangat berguna.  Anda mungkin terbiasa mengubah koleksi data dengan bantuan mereka, tetapi begitu Anda memahami konsepnya, Anda mulai menggunakannya di mana-mana, sial. </p><br><p>  Mungkin dalam tes: </p><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ it(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ expect(<span class="hljs-string"><span class="hljs-string">""</span></span>).not.toBe(<span class="hljs-string"><span class="hljs-string">""</span></span>); }); };</code> </pre> <br><p>  Atau saat Anda perlu mengurai (parse) data: </p><br><pre> <code class="javascript hljs">tokens.match(Token.LEFT_BRACKET, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">token</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Parse a list literal... tokens.consume(Token.RIGHT_BRACKET); });</span></span></code> </pre> <br><p>  Kemudian, setelah berakselerasi, Anda menulis semua jenis pustaka yang dapat digunakan kembali dan aplikasi yang berputar di sekitar fungsi, pemanggilan fungsi, pengembalian fungsi dari fungsi - bilik fungsional. </p><br><blockquote>  penerjemah: dalam bahasa asli "Functapalooza".  Awalan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">-a-palooza</a> sangat keren sehingga Anda ingin membaginya dengan semua orang. </blockquote><br><h1 id="kakogo-cveta-vasha-funkciya">  Apa warna fungsi Anda? </h1><br><p>  Dan di sini keanehan dimulai.  Bahasa kami memiliki satu fitur khusus: </p><br><h3 id="1-kazhdaya-funkciya-imeet-cvet">  1. Setiap fungsi memiliki warna. </h3><br><p>  Setiap fungsi - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panggilan balik</a> anonim atau fungsi biasa dengan nama - berwarna merah atau biru.  Karena penyorotan kode di blog kami tidak menyoroti warna fungsi yang berbeda, mari kita sepakat bahwa sintaksnya adalah: </p><br><pre> <code class="javascript hljs">blue*<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomethingAzure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ... } red*function doSomethingCarnelian(){ //    ... }</span></span></code> </pre> <br><p>  Bahasa kami tidak memiliki fungsi tidak berwarna.  Ingin membuat fitur?  - harus memilih warna.  Ini peraturannya.  Dan ada beberapa aturan lagi yang harus Anda ikuti: </p><br><h3 id="2-cvet-vliyaet-na-sposob-vyzova-funkcii">  2. Warna mempengaruhi cara fungsi dipanggil </h3><br><p>  Bayangkan ada dua sintaks untuk fungsi memanggil - "biru" dan "merah".  Sesuatu seperti: </p><br><pre> <code class="javascript hljs">doSomethingAzure(...)*blue; doSomethingCarnelian()*red;</code> </pre> <br><p>  Saat Anda memanggil suatu fungsi, Anda harus menggunakan panggilan yang cocok dengan warnanya.  Jika Anda tidak menebak - mereka menyebut fungsi merah dengan <code>*blue</code> setelah tanda kurung (atau sebaliknya) - sesuatu yang sangat buruk akan terjadi.  Mimpi buruk masa kecil yang telah lama terlupakan, seperti badut dengan ular, bukannya tangan yang bersembunyi di bawah tempat tidur Anda.  Dia akan melompat keluar dari monitor dan menyedot mata Anda. </p><br><p>  Aturan bodoh, kan?  Oh, tetapi satu hal lagi: </p><br><h3 id="3-tolko-krasnaya-funkciya-mozhet-vyzvat-krasnuyu-funkciyu">  3. Hanya fungsi merah yang dapat menyebabkan fungsi merah. </h3><br><p>  Anda <em>dapat</em> memanggil fungsi biru dari merah.  Ini halal: </p><br><pre> <code class="javascript hljs">red*<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomethingCarnelian</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ doSomethingAzure()*blue; }</code> </pre> <br><p>  Tapi tidak sebaliknya.  Jika Anda mencoba: </p><br><pre> <code class="javascript hljs">blue*<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomethingAzure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ doSomethingCarnelian()*red; }</code> </pre> <br><p>  - Anda akan dikunjungi oleh Clown Spider Maw tua. </p><br><p>  Ini membuatnya lebih sulit untuk menulis fungsi yang lebih tinggi seperti <code>filter()</code> dari contoh.  Kita harus memilih warna untuk setiap fungsi baru dan ini mempengaruhi warna fungsi yang bisa kita lewati.  Solusi yang jelas adalah membuat <code>filter()</code> merah.  Maka kita bisa memanggil setidaknya fungsi merah, setidaknya biru.  Tapi kemudian kita terluka tentang duri berikutnya di mahkota duri, yang merupakan bahasa yang diberikan: </p><br><h3 id="4-krasnye-funkcii-bolnee-vyzyvat">  4. Fungsi merah menyebabkan rasa sakit </h3><br><p>  Kami tidak akan menunjukkan "rasa sakit" ini, bayangkan saja programmer harus melompat melalui lingkaran setiap kali ia memanggil fungsi merah.  Panggilan mungkin terlalu polisilabik atau Anda tidak dapat menjalankan fungsi di dalam beberapa ekspresi.  Atau Anda hanya dapat mengakses fungsi merah dari garis ganjil. </p><br><p>  Tidak masalah apa itu, tetapi jika Anda memutuskan untuk membuat fungsinya merah, semua orang yang menggunakan API Anda ingin meludahi kopi Anda atau melakukan sesuatu yang lebih buruk. </p><br><p>  Solusi yang jelas dalam hal ini adalah tidak pernah menggunakan fungsi merah.  Jadikan semuanya biru, dan Anda kembali ke dunia normal, di mana semua fungsi memiliki warna yang sama, yang sama dengan fakta bahwa mereka tidak memiliki warna dan bahasa kami tidak sepenuhnya bodoh. </p><br><p>  Sayangnya, para sadis yang mengembangkan bahasa ini (semua orang tahu bahwa penulis bahasa pemrograman sadis, kan?) Tempelkan duri terakhir dalam diri kita: </p><br><h3 id="5-nekotorye-funkcii-yadra-yazyka----krasnye">  5. Beberapa fungsi inti bahasa adalah merah. </h3><br><p>  Beberapa fungsi dibangun ke dalam platform, fungsi yang <em>perlu</em> kita gunakan yang tidak dapat ditulis sendiri, hanya tersedia dalam warna merah.  Pada titik ini, orang yang cerdas mungkin mulai curiga bahwa bahasa ini membenci kita. </p><br><h1 id="eto-vse-vina-funkcionalnyh-yazykov">  Ini semua kesalahan bahasa fungsional! </h1><br><p>  Anda mungkin berpikir bahwa masalahnya adalah kami mencoba menggunakan fungsi tingkat tinggi.  Jika kita berhenti bermain-main dengan semua omong kosong fungsional ini, dan mulai menulis fungsi <em>urutan pertama</em> biru normal (fungsi yang tidak beroperasi dengan fungsi lain - kira-kira Penerjemah), seperti yang direncanakan oleh Tuhan - kita akan menghilangkan semua rasa sakit ini. </p><br><p>  Jika kita hanya memanggil fungsi biru, kita membuat semua fungsi kita biru.  Kalau tidak, kita membuat merah.  Sampai kita membuat fungsi yang menerima fungsi, kita tidak perlu khawatir tentang "polimorfisme dengan warna fungsi" (polikromatik?) Atau omong kosong lainnya. </p><br><p>  Namun sayang, fungsi tingkat tinggi hanyalah satu contoh.  Masalah muncul setiap kali kita ingin memecah program kita menjadi fungsi untuk digunakan kembali. </p><br><p>  Sebagai contoh, kami memiliki sepotong kode kecil yang, yah, saya tidak tahu, mengimplementasikan algoritma Dijkstra pada grafik yang menunjukkan seberapa banyak koneksi sosial Anda menekan satu sama lain.  (Saya menghabiskan banyak waktu untuk memutuskan apa artinya hasilnya. Transitif tidak diinginkan?) </p><br><p>  Kemudian Anda perlu menggunakan algoritma ini di tempat lain.  Secara alami, Anda membungkus kode dalam fungsi terpisah.  Panggil dia dari tempat lama dan dari tempat baru.  Tapi apa warna fungsinya?  Anda mungkin akan mencoba membuatnya menjadi biru, tetapi bagaimana jika ia menggunakan salah satu dari fungsi "hanya merah" yang jahat ini dari pustaka kernel? </p><br><p>  Katakanlah tempat baru tempat Anda ingin memanggil fungsi berwarna biru?  Tetapi sekarang Anda perlu menulis ulang kode panggilan dengan warna merah.  Dan kemudian ulangi fungsi yang memanggil kode ini.  Fiuh  Anda harus selalu mengingat warnanya.  Ini akan menjadi pasir di celana renang Anda di pemrograman liburan pantai. </p><br><h1 id="cvetnaya-allegoriya">  Alegori warna </h1><br><p>  Sebenarnya, saya tidak berbicara tentang warna.  Ini adalah alegori, alat sastra.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Persetan</a> - ini bukan tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bintang</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bintang di perut</a> , ini tentang perlombaan.  Anda mungkin sudah curiga ... </p><br><h3 id="krasnye-funkcii---asinhronnye">  Fungsi Merah - Asinkron </h3><br><p>  Jika Anda memprogram dalam JavaScript atau Node.js, setiap kali Anda menentukan fungsi yang memanggil fungsi panggilan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">balik</a> (callback) untuk "mengembalikan" hasilnya, Anda menulis fungsi merah.  Lihatlah daftar aturan ini dan perhatikan bagaimana hal itu sesuai dengan metafora saya: </p><br><ol><li>  Fungsi sinkron mengembalikan hasil, fungsi asinkron tidak, sebaliknya, mereka memanggil panggilan balik. </li><li>  Fungsi sinkron mengembalikan hasilnya sebagai nilai balik, fungsi asinkron mengembalikannya, menyebabkan panggilan balik yang Anda berikan kepada mereka. </li><li>  Anda tidak dapat memanggil fungsi asinkron dari yang sinkron, karena Anda tidak dapat mengetahui hasilnya sampai fungsi asinkron dijalankan kemudian. </li><li>  Fungsi asinkron tidak dikompilasi ke dalam ekspresi karena panggilan balik, memerlukan kesalahan mereka untuk ditangani secara berbeda dan tidak dapat digunakan dalam blok <code>try/catch</code> atau dalam sejumlah ekspresi lain yang mengontrol program. </li><li>  semuanya tentang Node.js adalah bahwa pustaka kernel semuanya asinkron.  (Meskipun mereka menyumbang kembali dan mulai menambahkan versi <code>_Sync()</code> ke banyak hal.) </li></ol><br><p>  Ketika orang berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"panggilan balik neraka"</a> , mereka berbicara tentang betapa menjengkelkannya memiliki fungsi "merah" dalam bahasa mereka.  Ketika mereka membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4089 perpustakaan untuk pemrograman asinkron</a> (pada 2019 sudah 11217 - approx. Translator), mereka mencoba untuk mengatasi masalah di tingkat perpustakaan bahwa mereka telah terjebak dengan bahasa. </p><br><h1 id="i-promise-the-future-is-better">  Saya berjanji masa depan lebih baik </h1><br><blockquote>  dalam terjemahan: "Saya berjanji bahwa masa depan lebih baik" permainan kata-kata dari judul dan isi bagian tersebut hilang </blockquote><p>  Orang-orang di Node.js telah lama menyadari bahwa callback sakit, dan sedang mencari solusi.  Salah satu teknik yang telah menginspirasi banyak orang adalah <code>promises</code> , yang mungkin juga Anda kenal dengan nama panggilan <code>futures</code> . </p><br><blockquote>  dalam IT Rusia, alih-alih menerjemahkan "janji" sebagai "janji", menelusuri kertas dari bahasa Inggris - "janji" dibuat.  Kata "Futures" digunakan sebagaimana adanya, mungkin karena "futures" sudah ditempati oleh gaul keuangan. </blockquote><p>  Promis adalah pembungkus untuk penelepon balik dan penangan kesalahan.  Jika Anda berpikir untuk meneruskan panggilan balik untuk hasil dan panggilan balik lain untuk kesalahan, maka <code>future</code> adalah perwujudan dari ide ini.  Ini adalah objek dasar yang merupakan operasi asinkron. </p><br><p>  Saya baru saja mendapat banyak kata-kata indah dan mungkin terdengar seperti solusi yang bagus, tetapi kebanyakan itu adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">minyak ular</a> .  Janji benar-benar membuat penulisan kode asinkron sedikit lebih mudah.  Mereka lebih mudah untuk dikomposisi menjadi ekspresi, jadi aturan 4 sedikit kurang ketat. </p><br><p>  Tapi jujur ‚Äã‚Äãsaja, itu seperti perbedaan antara pukulan di perut atau pangkal paha.  Ya, itu tidak terlalu menyakitkan, tetapi tidak ada yang akan senang dengan pilihan seperti itu. </p><br><p>  Anda masih tidak dapat menggunakan janji dengan penanganan pengecualian atau lainnya <br>  mengelola operator.  Anda tidak dapat memanggil fungsi yang mengembalikan <code>future</code> dari kode sinkron.  (Anda <em>bisa</em> , tetapi kemudian pemelihara kode Anda berikutnya akan menciptakan mesin waktu, kembali pada saat Anda melakukannya, dan menempelkan pensil di wajah Anda karena alasan # 2.) </p><br><p>  Janji-janji masih membagi dunia Anda menjadi dua bagian yang tidak sinkron dan sinkron dengan semua penderitaan berikutnya.  Jadi, bahkan jika bahasa Anda mendukung <code>promises</code> atau <code>futures</code> , itu masih sangat mirip boneka saya. </p><br><p>  (Ya, ini bahkan termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dart</a> yang saya gunakan. Oleh karena itu, saya sangat senang bahwa bagian dari tim sedang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mencoba pendekatan lain untuk paralelisme</a> ) </p><br><blockquote>  tautan proyek secara resmi ditinggalkan </blockquote><br><h1 id="im-awaiting-a-solution">  Saya sedang menunggu solusi </h1><br><p>  Pemrogram C # mungkin merasa sombong (alasan mereka menjadi semakin banyak korban adalah karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halesberg</a> dan perusahaan menaburkan semuanya dan menaburkan bahasa dengan gula sintaksis).  Di C #, Anda dapat menggunakan kata kunci <code>await</code> untuk memanggil fungsi asinkron. </p><br><p>  Ini membuat panggilan asinkronik semudah sinkron, dengan penambahan kata kunci kecil yang lucu.  Anda dapat memasukkan panggilan <code>await</code> dalam ekspresi, menggunakannya dalam penanganan pengecualian, dalam aliran instruksi.  Anda bisa menjadi gila.  Biarkan hujan menunggu seperti uang untuk album rapper baru Anda. </p><br><p>  Async-waiting menunggu, jadi kami menambahkannya ke Dart.  Jauh lebih mudah <em>untuk menulis</em> kode asinkron dengannya.  Tapi, seperti biasa, ada satu "Tapi."  Ini dia.  <em>Tapi ...</em> Anda masih membagi dunia menjadi dua.  Fungsi asinkron sekarang lebih mudah untuk ditulis, tetapi <em>mereka tetap fungsi asinkron.</em> </p><br><p>  Anda masih memiliki dua warna.  Async-menunggu menunggu masalah yang mengganggu # 4 - mereka membuat memanggil fungsi merah tidak lebih sulit daripada memanggil yang biru.  Tetapi sisa peraturan masih ada di sini: </p><br><ol><li>  Fungsi sinkron mengembalikan nilai, fungsi asinkron mengembalikan pembungkus ( <code>Task&lt;T&gt;</code> dalam C # atau <code>Future&lt;T&gt;</code> di Dart) di sekitar nilai. </li><li>  Sinkron baru saja dipanggil, asinkron perlu <code>await</code> . </li><li>  Dengan memanggil fungsi asinkron, Anda mendapatkan objek wrapper ketika Anda benar-benar menginginkan suatu nilai.  Anda tidak dapat memperluas nilai sampai Anda membuat fungsi <em>Anda tidak</em> sinkron dan menyebutnya dengan <code>await</code> (tetapi lihat paragraf berikutnya). </li><li>  Selain sedikit menunggu hiasan, setidaknya kami menyelesaikan masalah ini. </li><li>  Pustaka inti C # lebih tua dari asinkron, jadi saya pikir mereka tidak pernah mengalami masalah ini. </li></ol><br><p>  <code>Async</code> <em>benar</em> <code>Async</code> <em>benar</em> lebih baik.  Saya lebih suka async-menunggu panggilan balik telanjang setiap hari dalam seminggu.  Tetapi kita membohongi diri kita sendiri jika kita berpikir bahwa semua masalah diselesaikan.  Segera setelah Anda mulai menulis fungsi tingkat tinggi, atau menggunakan kembali kode, Anda kembali menyadari bahwa warnanya masih ada, membanjiri semua kode sumber Anda. </p><br><h1 id="kakoy-yazyk-_ne_-cvetnoy">  Bahasa mana yang <em>bukan</em> warna? </h1><br><p>  Jadi JS, Dart, C # dan Python memiliki masalah ini.  CoffeeScript dan sebagian besar bahasa lain yang dikompilasi di JS juga (dan Dart diwarisi).  Saya pikir bahkan ClojureScript memiliki tangkapan ini, meskipun upaya aktif mereka dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">core.async</a> </p><br><p>  Ingin tahu yang mana yang tidak?  <em>Jawa</em>  Apakah saya benar  Seberapa sering Anda berkata, ‚ÄúYa, Jawa sendiri yang melakukannya dengan benar‚Äù?  Dan begitulah yang terjadi.  Dalam pembelaan mereka, mereka secara aktif berusaha memperbaiki pengawasan mereka dengan mempromosikan IO <code>futures</code> dan async.  Ini seperti balapan yang lebih buruk dari yang lebih buruk. </p><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">semuanya</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah ada</a> di Jawa </blockquote><p>  C #, pada kenyataannya, juga <em>bisa</em> mengatasi masalah ini.  Mereka <em>memilih</em> memiliki warna.  Sebelum mereka menambahkan async-waiting dan semua <code>Task&lt;T&gt;</code> ini <code>Task&lt;T&gt;</code> sampah, Anda bisa menggunakan panggilan API sinkron biasa.  Tiga bahasa lain yang tidak memiliki masalah "warna": Go, Lua, dan Ruby. </p><br><p>  Tebak kesamaan apa yang mereka miliki? </p><br><p>  <em>Streaming.</em>  Atau lebih tepatnya: banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tumpukan panggilan</a> independen yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat beralih</a> .  Ini belum tentu utas sistem operasi.  Coroutine in Go, coroutine in Lua, dan utas di Ruby semuanya memadai. </p><br><p>  (Itulah mengapa ada peringatan kecil untuk C # - Anda dapat menghindari rasa sakit yang tidak sinkron dalam C # dengan menggunakan utas.) </p><br><h1 id="pamyat-o-proshlyh-operaciyah">  Memori operasi sebelumnya </h1><br><p>  Masalah mendasarnya adalah "bagaimana melanjutkan dari tempat yang sama ketika operasi (asinkron) selesai"?  Anda terjun ke jurang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tumpukan panggilan</a> dan kemudian memanggil semacam operasi I / O.  Demi akselerasi, operasi ini menggunakan API asinkron yang mendasari OS Anda.  Anda <em>tidak bisa</em> menunggu sampai selesai.  Anda harus kembali ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">loop acara</a> bahasa Anda dan memberikan waktu OS untuk menyelesaikan operasi. </p><br><p>  Setelah ini terjadi, Anda perlu melanjutkan apa yang Anda lakukan.  Biasanya bahasa "mengingat tempatnya" melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tumpukan panggilan</a> .  Dia mengikuti semua fungsi yang telah dipanggil saat ini, dan melihat di mana counter perintah di masing-masing menunjukkan. </p><br><p>  Tetapi untuk melakukan I / O asinkron, Anda harus melepas, membuang seluruh tumpukan panggilan dalam C. Ketik Trick-22.  Anda memiliki I / O yang sangat cepat, tetapi Anda tidak dapat menggunakan hasilnya!  Semua bahasa dengan I / O asinkron di bawah tenda - atau, dalam kasus JS, loop acara browser - dipaksa untuk menangani hal ini. </p><br><p>  Node, dengan panggilan balik yang tepat untuk selamanya, memasukkan semua panggilan ini ke dalam penutupan.  Ketika Anda menulis: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSundae</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ scoopIceCream(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">iceCream</span></span></span><span class="hljs-function">) </span></span>{ warmUpCaramel(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">caramel</span></span></span><span class="hljs-function">) </span></span>{ callback(pourOnIceCream(iceCream, caramel)); }); }); }</code> </pre> <br><p>  Masing-masing ekspresi fungsional ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>menutup</em></a> seluruh konteks sekitarnya.  Ini mentransfer parameter, seperti <code>iceCream</code> dan <code>caramel</code> , dari tumpukan panggilan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tumpukan</a> .  Ketika fungsi eksternal mengembalikan hasil dan tumpukan panggilan dihancurkan, itu keren.  Data masih berada di suatu tempat di heap. </p><br><p>  Masalahnya adalah bahwa Anda harus menghidupkan kembali masing-masing panggilan sialan ini lagi.  Bahkan ada nama khusus untuk konversi ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gaya kelanjutan-kelanjutan</a> </p><br><blockquote>  tautkan fungsionalitas yang ganas </blockquote><p>  Ini ditemukan oleh peretas bahasa di tahun 70-an, sebagai representasi perantara untuk digunakan di bawah kap kompiler.  Ini adalah cara yang sangat aneh untuk memperkenalkan kode yang membuatnya lebih mudah untuk melakukan beberapa optimasi kompiler. </p><br><p>  Tidak ada yang pernah berpikir bahwa seorang programmer dapat <em>menulis kode seperti itu</em> .  Dan kemudian Node muncul, dan tiba-tiba kita semua berpura-pura menulis backend kompiler.  Di mana kita berbelok ke arah yang salah? </p><br><p>  Perhatikan bahwa janji dan <code>futures</code> tidak banyak membantu.  Jika Anda menggunakannya, Anda tahu bahwa Anda masih menumpuk lapisan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekspresi fungsional</a> raksasa.  Anda hanya meneruskannya ke <code>.then()</code> alih-alih fungsi asinkron itu sendiri. </p><br><h1 id="awaiting-a-generated-solution">  Menunggu solusi yang dihasilkan </h1><br><p>  Async-waiting <em>sangat</em> membantu.  Jika Anda melihat di bawah kap ke kompiler ketika bertemu <code>await</code> , Anda akan melihat bahwa itu benar-benar melakukan konversi CPS.  Itu <em>sebabnya</em> Anda perlu menggunakan <code>await</code> di C # - ini adalah petunjuk untuk kompiler - "hentikan fungsi di tengah sini."  Semuanya setelah <code>await</code> menjadi fungsi baru yang disatukan oleh kompiler atas nama Anda. </p><br><p>  Inilah sebabnya mengapa async-wait tidak membutuhkan dukungan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">runtime</a> di dalam .NET framework.  Kompiler mengkompilasi ini ke dalam sebuah rantai penutupan terkait, yang sudah diketahui bagaimana cara menangani.  (Menariknya, penutupan juga tidak memerlukan dukungan runtime. Mereka dikompilasi ke dalam kelas anonim. Dalam C #, penutupan hanyalah objek.) </p><br><p>  Anda mungkin bertanya-tanya ketika saya menyebutkan generator.  Apakah ada <code>yield</code> dalam bahasa Anda?  Lalu dia bisa melakukan sesuatu yang sangat mirip. </p><br><p>  (Saya percaya bahwa generator dan async-menunggu sebenarnya isomorfik. Di suatu tempat di celah-celah dan celah-celah hard drive saya terletak sepotong kode yang mengimplementasikan loop permainan pada generator hanya menggunakan async-tunggu). </p><br><p>  Jadi dimana saya?  Oh ya  Jadi dengan callback, janji, menunggu async dan generator, Anda akhirnya mengambil fungsi asinkron Anda dan memecahnya menjadi banyak penutupan yang hidup di heap. </p><br><p>  Fungsi Anda memanggil eksternal saat runtime.  Ketika loop acara atau operasi I / O selesai, fungsi Anda dipanggil dan berlanjut dari tempat sebelumnya.  Tetapi ini berarti semua yang ada di atas fungsi Anda <em>juga</em> harus kembali.  Anda masih perlu mengembalikan seluruh tumpukan. </p><br><p>  Di sinilah aturan berasal: "Anda dapat memanggil fungsi merah hanya dari fungsi merah".  Anda harus menyimpan seluruh tumpukan panggilan di closure ke <code>main()</code> atau event handler. </p><br><h1 id="realizaciya-steka-vyzovov">  Panggil implementasi stack </h1><br><p>    ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>   ),     .              <em>      </em> . </p><br><p>  Go,   ,    .       -, Go       ,    -. </p><br><p>     -    Golang,   .  ,       ,  .       ,   Javascript.  Go-  ,    IO .  Go       . </p><br><p>   Go ‚Äî   <em></em>    ,        .       ,   ,    . </p><br><p>     ,               API,   ,     .           . </p><br><hr><br><h1 id="ot-perevodchika">   </h1><br><p>  ,           ,          .       ,        . ,      50%          . </p><br><p> ,      ,      ,                 . </p><br><p>  Javascript   -,   , ,   JS   ,    JS   ,          .   ,    JS   . </p><br><p>      ,      (     )   ‚Äî  ,     ,   ,        <code>async</code>         .     <code>import threading</code>      (  ,          AsyncIO, Twisted  Tornado,    ). </p><br><p>     ,             ,     ,     ,        ,                  ,      . </p><br><p>       ,     Go,     Go . </p><br><p>  ,        ,  ,  ( -    )          ,          "async-await  ".      . </p><br><p>    ,       . </p><br><p> ,       ,     . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466337/">https://habr.com/ru/post/id466337/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466319/index.html">Kesepakatan: VMware membeli startup berbasis cloud</a></li>
<li><a href="../id466323/index.html">Kami membuat game platform portabel di mikrokontroler Cortex M0 +</a></li>
<li><a href="../id466329/index.html">Peta elektronik pembuatan anggur di Rusia. Desain dan konten</a></li>
<li><a href="../id466333/index.html">Bagaimana mengatur tempat kerja untuk Anda sendiri</a></li>
<li><a href="../id466335/index.html">Membuat Aplikasi Slack Menggunakan Fitur 8base</a></li>
<li><a href="../id466339/index.html">Bagaimana di Microsoft SQL Server untuk mendapatkan data dari Google Analytics menggunakan R</a></li>
<li><a href="../id466341/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 33. Persiapan untuk Ujian ICND1</a></li>
<li><a href="../id466345/index.html">Metode gelombang membangun skema warna</a></li>
<li><a href="../id466347/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 34. Konsep VLAN Lanjutan</a></li>
<li><a href="../id466349/index.html">Cara melakukan pengujian A / B di 15.000 toko offline</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>