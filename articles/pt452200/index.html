<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â˜ªï¸ ğŸ’…ğŸ¼ ğŸ“„ GOSTIM: P2P F2F E2EE IM em uma noite com criptografia GOST ğŸ‘©ğŸ¼â€âš–ï¸ ğŸ“ª ğŸ¤ŸğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como desenvolvedor da biblioteca PyGOST (primitivas criptogrÃ¡ficas GOST em Python puro), muitas vezes recebo perguntas sobre como implementar as mensa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GOSTIM: P2P F2F E2EE IM em uma noite com criptografia GOST</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452200/">  Como desenvolvedor da biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PyGOST</a> (primitivas criptogrÃ¡ficas GOST em Python puro), muitas vezes recebo perguntas sobre como implementar as mensagens seguras mais simples no meu joelho.  Muitos consideram a criptografia aplicada uma coisa bastante simples, e uma chamada .encrypt () para uma cifra de bloco serÃ¡ suficiente para enviar com seguranÃ§a por um canal de comunicaÃ§Ã£o.  Outros acreditam que a criptografia aplicada Ã© o destino de poucos, e Ã© aceitÃ¡vel que empresas ricas como o Telegram com olimpÃ­adas matemÃ¡ticas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nÃ£o possam implementar um</a> protocolo seguro. <br><br>  Tudo isso me levou a escrever este artigo para mostrar que a implementaÃ§Ã£o de protocolos criptogrÃ¡ficos e MI seguro nÃ£o Ã© uma tarefa tÃ£o difÃ­cil.  No entanto, inventar sua prÃ³pria autenticaÃ§Ã£o e protocolos de contrato de chave nÃ£o vale a pena. <br><br><div style="text-align:center;"><img alt="Heearing" src="https://habrastorage.org/getpro/habr/post_images/4e2/2bb/f04/4e22bbf0480a8181bcbb2054c6f95815.jpg"></div><br>  O artigo serÃ¡ escrito mensageiro instantÃ¢neo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criptografado</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ponto a ponto</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">amigo a amigo</a> , de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ponta a ponta</a> com autenticaÃ§Ã£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SIGMA-I</a> e protocolo de acordo de chave (com base no qual o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IPsec IKE</a> Ã© implementado) usando exclusivamente algoritmos criptogrÃ¡ficos GOST, bibliotecas PyGOST e CodificaÃ§Ã£o ASN.1 de mensagens com a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PyDERASN</a> (sobre a qual eu jÃ¡ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escrevi antes</a> ).  PrÃ©-requisito: deve ser tÃ£o simples que possa ser escrito do zero em uma noite (ou dia de trabalho); caso contrÃ¡rio, nÃ£o serÃ¡ mais um programa simples.  Provavelmente tem erros, dificuldades desnecessÃ¡rias, deficiÃªncias, e esse Ã© o meu primeiro programa usando a biblioteca assÃ­ncrona. <br><a name="habracut"></a><br><h2>  Design IM </h2><br>  Para comeÃ§ar, vocÃª precisa entender como serÃ¡ a nossa IM.  Por uma questÃ£o de simplicidade, seja uma rede ponto a ponto, sem nenhuma descoberta dos participantes.  Indicaremos pessoalmente para qual endereÃ§o: a porta a ser conectada para se comunicar com o interlocutor. <br><br>  Entendo que, no momento, a suposiÃ§Ã£o da disponibilidade de comunicaÃ§Ã£o direta entre dois computadores arbitrÃ¡rios Ã© uma limitaÃ§Ã£o significativa da aplicabilidade do IM na prÃ¡tica.  PorÃ©m, quanto mais desenvolvedores implementarem todos os tipos de muletas transversais Ã  NAT, mais permaneceremos na Internet IPv4, com a probabilidade deprimente de comunicaÃ§Ã£o entre computadores arbitrÃ¡rios.  Bem, quanto vocÃª pode suportar a falta de IPv6 em casa e no trabalho? <br><br>  Teremos uma rede amigo a amigo: todos os interlocutores possÃ­veis devem ser conhecidos com antecedÃªncia.  Em primeiro lugar, simplifica muito tudo: se apresentou, encontrou ou nÃ£o encontrou um nome / chave, desconectou ou continuou a trabalhar, conhecendo o interlocutor.  Em segundo lugar, no caso geral, Ã© seguro e exclui muitos ataques. <br><br>  A interface do IM estarÃ¡ prÃ³xima das soluÃ§Ãµes clÃ¡ssicas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projetos sem sucÃ§Ã£o</a> , que eu realmente gosto pelo minimalismo e pela filosofia do Unix-way.  Um programa de IM para cada interlocutor cria um diretÃ³rio com trÃªs soquetes de domÃ­nio Unix: <br><br><ul><li>  as mensagens enviadas para o interlocutor sÃ£o gravadas nele; </li><li>  mensagens de saÃ­da recebidas do interlocutor sÃ£o lidas a partir dele; </li><li>  estado - lendo, descobriremos se o interlocutor estÃ¡ conectado agora, o endereÃ§o / porta de conexÃ£o. </li></ul><br>  AlÃ©m disso, um soquete de conexÃ£o Ã© criado, gravando em qual porta do host, iniciamos uma conexÃ£o com um interlocutor remoto. <br><br><pre> | - alice
 |  | - em
 |  | - fora
 |  `- estado
 | - bob
 |  | - em
 |  | - fora
 |  `- estado
 `- conn
</pre><br>  Essa abordagem permite que vocÃª faÃ§a implementaÃ§Ãµes independentes do transporte de mensagens instantÃ¢neas e da interface do usuÃ¡rio, porque nÃ£o hÃ¡ amigo para o sabor e a cor, vocÃª nÃ£o agradarÃ¡ a todos.  Usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tmux</a> e / ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">multitail</a> , vocÃª pode obter uma interface de vÃ¡rias janelas com destaque de sintaxe.  E com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rlwrap,</a> vocÃª pode obter uma string compatÃ­vel com o GNU Readline para inserir mensagens. <br><br>  De fato, projetos sem sucÃ§Ã£o usam arquivos FIFO.  Pessoalmente, eu nÃ£o conseguia entender como trabalhar de forma assÃ­ncrona com arquivos de forma competitiva sem um substrato feito Ã  mÃ£o a partir de threads selecionados (eu uso a linguagem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Go</a> para essas coisas hÃ¡ muito tempo).  Portanto, decidi conviver com os soquetes de domÃ­nio Unix.  Infelizmente, isso torna impossÃ­vel fazer eco 2001: 470: dead :: babe 6666&gt; conn.  Resolvi esse problema usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">socat</a> : echo 2001: 470: dead :: babe 6666 |  socat - UNIX-CONNECT: conn, socat READLINE UNIX-CONNECT: alice / in. <br><br><h2>  Protocolo inseguro inicial </h2><br>  O TCP Ã© usado como transporte: garante a entrega e seu pedido.  O UDP nÃ£o garante nem um nem outro (o que seria Ãºtil quando a criptografia Ã© aplicada), e o suporte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SCTP</a> no Python estÃ¡ pronto para uso. <br><br>  Infelizmente, no TCP nÃ£o hÃ¡ conceito de mensagem, mas apenas um fluxo de bytes.  Portanto, Ã© necessÃ¡rio criar um formato para as mensagens para que elas possam ser compartilhadas entre si nesse fluxo.  Podemos concordar em usar o caractere de avanÃ§o de linha.  Para iniciantes, Ã© adequado, no entanto, quando comeÃ§amos a criptografar nossas mensagens, esse sÃ­mbolo pode aparecer em qualquer lugar no texto cifrado.  Portanto, os protocolos sÃ£o populares nas redes, enviando primeiro o tamanho da mensagem em bytes.  Por exemplo, no Python, fora da caixa, existe o xdrlib, que permite trabalhar com um formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">XDR</a> semelhante. <br><br>  NÃ£o trabalharemos corretamente e eficientemente com a leitura TCP - simplificamos o cÃ³digo.  Lemos os dados do soquete em um loop infinito atÃ© decodificar a mensagem completa.  VocÃª tambÃ©m pode usar JSON com XML como um formato para esta abordagem.  Mas quando a criptografia Ã© adicionada, os dados terÃ£o que ser assinados e autenticados - e isso exigirÃ¡ uma representaÃ§Ã£o idÃªntica de objetos, byte a byte, que o JSON / XML nÃ£o fornece (os dumps podem variar). <br><br>  O XDR Ã© adequado para essa tarefa, no entanto, escolho o ASN.1 com codificaÃ§Ã£o DER e a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PyDERASN</a> , pois teremos objetos de alto nÃ­vel Ã  mÃ£o, que geralmente sÃ£o mais agradÃ¡veis â€‹â€‹e convenientes de se trabalhar.  Diferentemente do cÃ³digo de esquema sem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esquema</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MessagePack</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CBOR</a> , o ASN.1 validarÃ¡ automaticamente os dados em um esquema codificado. <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Msg ::= CHOICE { # text MsgText, # handshake [0] EXPLICIT MsgHandshake } class Msg(Choice): schema = (( ("text", MsgText()), ("handshake", MsgHandshake(expl=tag_ctxc(0))), )) # MsgText ::= SEQUENCE { # text UTF8String (SIZE(1..MaxTextLen))} class MsgText(Sequence): schema = (( ("text", UTF8String(bounds=(1, MaxTextLen))), )) # MsgHandshake ::= SEQUENCE { # peerName UTF8String (SIZE(1..256)) } class MsgHandshake(Sequence): schema = (( ("peerName", UTF8String(bounds=(1, 256))), ))</span></span></code> </pre> <br>  A mensagem recebida serÃ¡ Msg: um texto MsgText (com um campo de texto atÃ© o momento) ou uma mensagem de handshake MsgHandshake (na qual o nome do interlocutor Ã© transmitido).  Agora parece complicado demais, mas Ã© um desafio para o futuro. <br><br><pre>      â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
      â”‚PeerAâ”‚ â”‚PeerBâ”‚
      â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
         â”‚MsgHandshake (IdA) â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ &gt;&gt; â”‚
         â”‚ â”‚
         SMsgHandshake (IdB) â”‚
         â”‚ &lt;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
         â”‚ â”‚
         â”‚ MsgText () â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ &gt;&gt; â”‚
         â”‚ â”‚
         â”‚ MsgText () â”‚
         â”‚ &lt;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
         â”‚ â”‚
</pre><br><br><h2>  IM sem criptografia </h2><br>  Como eu disse, para todas as operaÃ§Ãµes com soquetes, a biblioteca assÃ­ncrona serÃ¡ usada.  Declare o que esperamos no lanÃ§amento: <br><br><pre> <code class="python hljs">parser = argparse.ArgumentParser(description=<span class="hljs-string"><span class="hljs-string">"GOSTIM"</span></span>) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--our-name"</span></span>, required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Our peer name"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--their-names"</span></span>, required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Their peer names, comma-separated"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--bind"</span></span>, default=<span class="hljs-string"><span class="hljs-string">"::1"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Address to listen on"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--port"</span></span>, type=int, default=<span class="hljs-number"><span class="hljs-number">6666</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Port to listen on"</span></span>, ) args = parser.parse_args() OUR_NAME = UTF8String(args.our_name) THEIR_NAMES = set(args.their_names.split(<span class="hljs-string"><span class="hljs-string">","</span></span>))</code> </pre><br>  Defina seu prÃ³prio nome (--nome-alice).  Uma vÃ­rgula lista todos os interlocutores esperados (- seus nomes bob, vÃ©spera).  Para cada um dos interlocutores, Ã© criado um diretÃ³rio com soquetes Unix, bem como uma rotina para cada estado de entrada, saÃ­da: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> peer_name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> THEIR_NAMES: makedirs(peer_name, mode=<span class="hljs-number"><span class="hljs-number">0o700</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) out_queue = asyncio.Queue() OUT_QUEUES[peer_name] = out_queue asyncio.ensure_future(asyncio.start_unix_server( partial(unixsock_out_processor, out_queue=out_queue), path.join(peer_name, <span class="hljs-string"><span class="hljs-string">"out"</span></span>), )) in_queue = asyncio.Queue() IN_QUEUES[peer_name] = in_queue asyncio.ensure_future(asyncio.start_unix_server( partial(unixsock_in_processor, in_queue=in_queue), path.join(peer_name, <span class="hljs-string"><span class="hljs-string">"in"</span></span>), )) asyncio.ensure_future(asyncio.start_unix_server( partial(unixsock_state_processor, peer_name=peer_name), path.join(peer_name, <span class="hljs-string"><span class="hljs-string">"state"</span></span>), )) asyncio.ensure_future(asyncio.start_unix_server(unixsock_conn_processor, <span class="hljs-string"><span class="hljs-string">"conn"</span></span>))</code> </pre><br>  As mensagens do soquete de entrada do usuÃ¡rio sÃ£o enviadas para a fila IN_QUEUES: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unixsock_in_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader, writer, in_queue: asyncio.Queue)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> reader.read(MaxTextLen) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> text == <span class="hljs-string"><span class="hljs-string">b""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> in_queue.put(text.decode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>))</code> </pre><br>  As mensagens dos interlocutores sÃ£o enviadas para a fila OUT_QUEUES, a partir da qual os dados sÃ£o gravados no soquete de saÃ­da: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unixsock_out_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader, writer, out_queue: asyncio.Queue)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> out_queue.get() writer.write((<span class="hljs-string"><span class="hljs-string">"[%s] %s"</span></span> % (datetime.now(), text)).encode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> writer.drain()</code> </pre><br>  Ao ler do soquete de estado, o programa procura no dicionÃ¡rio PEER_ALIVE o endereÃ§o do interlocutor.  Se ainda nÃ£o houver conexÃ£o com o interlocutor, uma linha vazia serÃ¡ gravada. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unixsock_state_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader, writer, peer_name: str)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> peer_writer = PEER_ALIVES.get(peer_name) writer.write( <span class="hljs-string"><span class="hljs-string">b""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> peer_writer <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> (<span class="hljs-string"><span class="hljs-string">" "</span></span>.join([ str(i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> peer_writer.get_extra_info(<span class="hljs-string"><span class="hljs-string">"peername"</span></span>)[:<span class="hljs-number"><span class="hljs-number">2</span></span>] ]).encode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>) + <span class="hljs-string"><span class="hljs-string">b"\n"</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> writer.drain() writer.close()</code> </pre><br>  Quando um endereÃ§o Ã© gravado no soquete de conexÃ£o, a funÃ§Ã£o "iniciador" da conexÃ£o Ã© iniciada: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unixsock_conn_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader, writer)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> reader.read(<span class="hljs-number"><span class="hljs-number">256</span></span>) writer.close() host, port = data.decode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>).split(<span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> initiator(host=host, port=int(port))</code> </pre><br>  Considere o iniciador.  Primeiro, ele obviamente abre uma conexÃ£o com o host / porta especificado e envia uma mensagem de handshake com seu nome: <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">130</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initiator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(host, port)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">131</span></span> _id = repr((host, port)) <span class="hljs-number"><span class="hljs-number">132</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: dialing"</span></span>, _id) <span class="hljs-number"><span class="hljs-number">133</span></span> reader, writer = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.open_connection(host, port) <span class="hljs-number"><span class="hljs-number">134</span></span> <span class="hljs-comment"><span class="hljs-comment"># Handshake message {{{ 135 writer.write(Msg(("handshake", MsgHandshake(( 136 ("peerName", OUR_NAME), 137 )))).encode()) 138 # }}} 139 await writer.drain()</span></span></code> </pre><br>  Em seguida, aguarda uma resposta do lado remoto.  Tenta decodificar a resposta recebida de acordo com o esquema Msg ASN.1.  Assumimos que a mensagem inteira serÃ¡ enviada por um segmento TCP e a receberemos atomicamente quando .read () for chamado.  Verificamos que recebemos exatamente a mensagem de handshake. <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">141</span></span> <span class="hljs-comment"><span class="hljs-comment"># Wait for Handshake message {{{ 142 data = await reader.read(256) 143 if data == b"": 144 logging.warning("%s: no answer, disconnecting", _id) 145 writer.close() 146 return 147 try: 148 msg, _ = Msg().decode(data) 149 except ASN1Error: 150 logging.warning("%s: undecodable answer, disconnecting", _id) 151 writer.close() 152 return 153 logging.info("%s: got %s message", _id, msg.choice) 154 if msg.choice != "handshake": 155 logging.warning("%s: unexpected message, disconnecting", _id) 156 writer.close() 157 return 158 # }}}</span></span></code> </pre><br>  Verificamos que o nome da pessoa com quem estamos conversando Ã© conhecido por nÃ³s.  Caso contrÃ¡rio, interrompa a conexÃ£o.  Verificamos se jÃ¡ estabelecemos uma conexÃ£o com ele (o interlocutor novamente deu o comando para conectar-se a nÃ³s) e a fechamos.  SeqÃ¼Ãªncias de caracteres Python com texto de mensagem sÃ£o colocadas na fila IN_QUEUES, mas hÃ¡ um valor especial None, que sinaliza msg_sender Ã  corotina para parar de funcionar, para que ela esqueÃ§a seu escritor, que estÃ¡ conectado a uma conexÃ£o TCP desatualizada. <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">159</span></span> msg_handshake = msg.value <span class="hljs-number"><span class="hljs-number">160</span></span> peer_name = str(msg_handshake[<span class="hljs-string"><span class="hljs-string">"peerName"</span></span>]) <span class="hljs-number"><span class="hljs-number">161</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> peer_name <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> THEIR_NAMES: <span class="hljs-number"><span class="hljs-number">162</span></span> logging.warning(<span class="hljs-string"><span class="hljs-string">"unknown peer name: %s"</span></span>, peer_name) <span class="hljs-number"><span class="hljs-number">163</span></span> writer.close() <span class="hljs-number"><span class="hljs-number">164</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">165</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: session established: %s"</span></span>, _id, peer_name) <span class="hljs-number"><span class="hljs-number">166</span></span> <span class="hljs-comment"><span class="hljs-comment"># Run text message sender, initialize transport decoder {{{ 167 peer_alive = PEER_ALIVES.pop(peer_name, None) 168 if peer_alive is not None: 169 peer_alive.close() 170 await IN_QUEUES[peer_name].put(None) 171 PEER_ALIVES[peer_name] = writer 172 asyncio.ensure_future(msg_sender(peer_name, writer)) 173 # }}}</span></span></code> </pre><br>  O msg_sender aceita mensagens de saÃ­da (enfileiradas de um soquete de entrada), as serializa em uma mensagem MsgText e as envia por uma conexÃ£o TCP.  Pode interromper a qualquer momento - estamos claramente interceptando. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg_sender</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(peer_name: str, writer)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> in_queue = IN_QUEUES[peer_name] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> in_queue.get() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> text <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> writer.write(Msg((<span class="hljs-string"><span class="hljs-string">"text"</span></span>, MsgText(( (<span class="hljs-string"><span class="hljs-string">"text"</span></span>, UTF8String(text)), )))).encode()) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> writer.drain() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ConnectionResetError: <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> PEER_ALIVES[peer_name] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: sent %d characters message"</span></span>, peer_name, len(text))</code> </pre><br>  No final, o iniciador entra em um ciclo interminÃ¡vel de leitura de mensagens do soquete.  Verifica se esta Ã© uma mensagem de texto e coloca no OUT_QUEUES a fila da qual eles serÃ£o enviados para o soquete de saÃ­da do interlocutor correspondente.  Por que vocÃª nÃ£o pode simplesmente executar .read () e decodificar a mensagem?  Porque Ã© possÃ­vel que vÃ¡rias mensagens do usuÃ¡rio sejam agregadas no buffer do sistema operacional e enviadas por um segmento TCP.  Podemos decodificar o primeiro e, em seguida, parte do subsequente pode permanecer no buffer.  Em qualquer emergÃªncia, fechamos a conexÃ£o TCP e interrompemos a rotina msg_sender (enviando Nenhum para a fila OUT_QUEUES). <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">174</span></span> buf = <span class="hljs-string"><span class="hljs-string">b""</span></span> <span class="hljs-number"><span class="hljs-number">175</span></span> <span class="hljs-comment"><span class="hljs-comment"># Wait for test messages {{{ 176 while True: 177 data = await reader.read(MaxMsgLen) 178 if data == b"": 179 break 180 buf += data 181 if len(buf) &gt; MaxMsgLen: 182 logging.warning("%s: max buffer size exceeded", _id) 183 break 184 try: 185 msg, tail = Msg().decode(buf) 186 except ASN1Error: 187 continue 188 buf = tail 189 if msg.choice != "text": 190 logging.warning("%s: unexpected %s message", _id, msg.choice) 191 break 192 try: 193 await msg_receiver(msg.value, peer_name) 194 except ValueError as err: 195 logging.warning("%s: %s", err) 196 break 197 # }}} 198 logging.info("%s: disconnecting: %s", _id, peer_name) 199 IN_QUEUES[peer_name].put(None) 200 writer.close() 66 async def msg_receiver(msg_text: MsgText, peer_name: str) -&gt; None: 67 text = str(msg_text["text"]) 68 logging.info("%s: received %d characters message", peer_name, len(text)) 69 await OUT_QUEUES[peer_name].put(text)</span></span></code> </pre><br>  Vamos voltar ao cÃ³digo principal.  ApÃ³s criar todas as corotinas, no momento de iniciar o programa, iniciamos o servidor TCP.  Para cada conexÃ£o estabelecida, ele cria uma resposta de rotina. <br><br><pre> <code class="python hljs">logging.basicConfig( level=logging.INFO, format=<span class="hljs-string"><span class="hljs-string">"%(levelname)s %(asctime)s: %(funcName)s: %(message)s"</span></span>, ) loop = asyncio.get_event_loop() server = loop.run_until_complete(asyncio.start_server(responder, args.bind, args.port)) logging.info(<span class="hljs-string"><span class="hljs-string">"Listening on: %s"</span></span>, server.sockets[<span class="hljs-number"><span class="hljs-number">0</span></span>].getsockname()) loop.run_forever()</code> </pre><br>  O respondedor Ã© semelhante ao iniciador e reflete todas as mesmas aÃ§Ãµes, mas um loop infinito de leitura de mensagens comeÃ§a imediatamente, por simplicidade.  Agora, o protocolo de handshake envia uma mensagem de cada lado, mas, no futuro, haverÃ¡ duas do iniciador da conexÃ£o, apÃ³s as quais as mensagens de texto podem ser enviadas imediatamente. <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">72</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">responder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader, writer)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">73</span></span> _id = writer.get_extra_info(<span class="hljs-string"><span class="hljs-string">"peername"</span></span>) <span class="hljs-number"><span class="hljs-number">74</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: connected"</span></span>, _id) <span class="hljs-number"><span class="hljs-number">75</span></span> buf = <span class="hljs-string"><span class="hljs-string">b""</span></span> <span class="hljs-number"><span class="hljs-number">76</span></span> msg_expected = <span class="hljs-string"><span class="hljs-string">"handshake"</span></span> <span class="hljs-number"><span class="hljs-number">77</span></span> peer_name = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-number"><span class="hljs-number">78</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-number"><span class="hljs-number">79</span></span> <span class="hljs-comment"><span class="hljs-comment"># Read until we get Msg message {{{ 80 data = await reader.read(MaxMsgLen) 81 if data == b"": 82 logging.info("%s: closed connection", _id) 83 break 84 buf += data 85 if len(buf) &gt; MaxMsgLen: 86 logging.warning("%s: max buffer size exceeded", _id) 87 break 88 try: 89 msg, tail = Msg().decode(buf) 90 except ASN1Error: 91 continue 92 buf = tail 93 # }}} 94 if msg.choice != msg_expected: 95 logging.warning("%s: unexpected %s message", _id, msg.choice) 96 break 97 if msg_expected == "text": 98 try: 99 await msg_receiver(msg.value, peer_name) 100 except ValueError as err: 101 logging.warning("%s: %s", err) 102 break 103 # Process Handshake message {{{ 104 elif msg_expected == "handshake": 105 logging.info("%s: got %s message", _id, msg_expected) 106 msg_handshake = msg.value 107 peer_name = str(msg_handshake["peerName"]) 108 if peer_name not in THEIR_NAMES: 109 logging.warning("unknown peer name: %s", peer_name) 110 break 111 writer.write(Msg(("handshake", MsgHandshake(( 112 ("peerName", OUR_NAME), 113 )))).encode()) 114 await writer.drain() 115 logging.info("%s: session established: %s", _id, peer_name) 116 peer_alive = PEER_ALIVES.pop(peer_name, None) 117 if peer_alive is not None: 118 peer_alive.close() 119 await IN_QUEUES[peer_name].put(None) 120 PEER_ALIVES[peer_name] = writer 121 asyncio.ensure_future(msg_sender(peer_name, writer)) 122 msg_expected = "text" 123 # }}} 124 logging.info("%s: disconnecting", _id) 125 if msg_expected == "text": 126 IN_QUEUES[peer_name].put(None) 127 writer.close()</span></span></code> </pre><br><h2>  Protocolo seguro </h2><br>  Chegou a hora de proteger nossa comunicaÃ§Ã£o.  O que queremos dizer com seguranÃ§a e o que queremos: <br><br><ul><li>  confidencialidade das mensagens transmitidas; </li><li>  autenticidade e integridade das mensagens transmitidas - suas alteraÃ§Ãµes devem ser detectadas; </li><li>  proteÃ§Ã£o contra ataques de repetiÃ§Ã£o - o fato de que as mensagens foram perdidas ou tentadas novamente deve ser detectado (e decidimos desconectar); </li><li>  identificaÃ§Ã£o e autenticaÃ§Ã£o de interlocutores por chaves pÃºblicas prÃ©-orientadas - jÃ¡ decidimos anteriormente que estamos criando uma rede de amigo para amigo.  Somente apÃ³s a autenticaÃ§Ã£o entenderemos com quem estamos nos comunicando; </li><li>  a presenÃ§a de propriedades de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sigilo direto perfeito</a> (PFS) - o comprometimento de nossa chave de assinatura de longa duraÃ§Ã£o nÃ£o deve levar Ã  possibilidade de ler toda a correspondÃªncia anterior.  Gravar trÃ¡fego interceptado se torna inÃºtil; </li><li>  validade / validade de mensagens (transporte e handshakes) somente dentro da mesma sessÃ£o TCP.  A inserÃ§Ã£o de mensagens assinadas / autenticadas corretamente de outra sessÃ£o (mesmo com o mesmo interlocutor) nÃ£o deve ser possÃ­vel; </li><li>  o observador passivo nÃ£o deve ver identificadores de usuÃ¡rio, transmitir chaves pÃºblicas de longa duraÃ§Ã£o nem hashes a partir deles.  Algum tipo de anonimato de um observador passivo. </li></ul><br>  Surpreendentemente, quase todo mundo quer ter esse mÃ­nimo em qualquer protocolo de handshake, e muito poucas das opÃ§Ãµes acima sÃ£o realizadas para protocolos caseiros.  EntÃ£o agora nÃ£o vamos inventar coisas novas.  Definitivamente, eu recomendaria o uso da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estrutura Noise</a> para criar protocolos, mas vamos escolher algo mais simples. <br><br>  Os mais populares sÃ£o dois protocolos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O TLS</a> Ã© um protocolo complexo com uma longa histÃ³ria de bugs, escolas, vulnerabilidades, problemas de pensamento, complexidade e deficiÃªncias (no entanto, isso nÃ£o se aplica muito ao TLS 1.3).  Mas nÃ£o o consideramos por causa da complexidade. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IPsec</a> com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IKE</a> - nÃ£o possui sÃ©rios problemas criptogrÃ¡ficos, embora tambÃ©m nÃ£o sejam simples.  Se vocÃª ler sobre o IKEv1 e o IKEv2, a fonte deles Ã© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">STS</a> , ISO / IEC IS 9798-3 e SIGMA (SIGn-e-MAc) - simples o suficiente para implementar em uma noite. </li></ul><br>  Como o SIGMA, como o Ãºltimo elo no desenvolvimento de protocolos STS / ISO, Ã© bom?  Satisfaz todos os nossos requisitos (incluindo "ocultar" os identificadores dos interlocutores)), nÃ£o possui problemas criptogrÃ¡ficos conhecidos.  Ã‰ minimalista - remover pelo menos um elemento da mensagem do protocolo levarÃ¡ Ã  sua inseguranÃ§a. <br><br>  Vamos do protocolo caseiro mais simples para o SIGMA.  A operaÃ§Ã£o mais bÃ¡sica na qual estamos interessados â€‹â€‹Ã© a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">correspondÃªncia de teclas</a> : uma funÃ§Ã£o na qual ambos os participantes receberÃ£o o mesmo valor que pode ser usado como uma chave simÃ©trica.  Sem entrar em detalhes: cada uma das partes gera um par de chaves efÃªmero (usado apenas na mesma sessÃ£o) (chaves pÃºblicas e privadas), troca chaves pÃºblicas, chama a funÃ§Ã£o de correspondÃªncia, para a entrada da qual eles transmitem sua chave privada e a chave pÃºblica do interlocutor. <br><br><pre> â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
 â”‚PeerAâ”‚ â”‚PeerBâ”‚
 â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
    â”‚ IdA, PubA â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ &gt;&gt; â”‚ rPrvA, PubA = DHgen () â•‘
    â”‚ â”‚ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â”‚ IdB, PubB â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    &lt;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ vPrvB, PubB = DHgen () â•‘
    â”‚ â”‚ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â”€â”€â”€â”€â” â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        â•‘ â•‘ Tecla = DH (PrvA, PubB) â•‘
    &lt;â”€â”€â”€â”˜ â•šâ•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•
    â”‚ â”‚
    â”‚ â”‚
</pre><br><br>  Qualquer um pode intervir no meio e substituir as chaves pÃºblicas pelas suas - neste protocolo nÃ£o hÃ¡ autenticaÃ§Ã£o dos interlocutores.  Adicione uma assinatura com chaves de longa duraÃ§Ã£o. <br><br><pre> â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
 â”‚PeerAâ”‚ â”‚PeerBâ”‚
 â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
    DIdA, PubA, sinal (SignPrvA, (PubA)) â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    Ign â”€ â”€ â”€ â”€ ign ign ign ign ign ign ign ign ign ign ign ign ,,,,,,,, SignPubA = load () â•‘
    V â”‚ vPrvA, PubA = DHgen () â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â•
    DIdB, PubB, sinal (SignPrvB, (PubB)) â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    &lt;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â•‘SignPrvB, SignPubB = load () â•‘
    V â”‚ vPrvB, PubB = DHgen () â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â•
    â”€â”€â”€â”€â” â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”‚ â”‚
        Verificar (SignPubB, ...)
    &lt;â”€â”€â”€â”˜Key = DH (PrvA, PubB) â•‘ â”‚
    â”‚ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â”‚
    â”‚ â”‚
</pre><br><br>  Essa assinatura nÃ£o funcionarÃ¡, pois nÃ£o estÃ¡ vinculada a uma sessÃ£o especÃ­fica.  Essas mensagens tambÃ©m sÃ£o adequadas para sessÃµes com outros participantes.  Todo o contexto deve ser inscrito.  Isso tambÃ©m forÃ§a a adiÃ§Ã£o de outra mensagem de A. <br><br>  AlÃ©m disso, Ã© fundamental adicionar seu prÃ³prio identificador como uma assinatura, pois, caso contrÃ¡rio, podemos substituir o IdXXX e assinar novamente a mensagem com a chave de outro interlocutor conhecido.  Para evitar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ataques de reflexÃ£o</a> , Ã© necessÃ¡rio que os elementos sob a assinatura estejam em locais claramente definidos em seu significado: se A assina (PubA, PubB), entÃ£o B deve assinar (PubB, PubA).  Isso tambÃ©m indica a importÃ¢ncia de escolher a estrutura e o formato dos dados serializados.  Por exemplo, os conjuntos na codificaÃ§Ã£o ASN.1 DER sÃ£o classificados: SET OF (PubA, PubB) serÃ¡ idÃªntico a SET OF (PubB, PubA). <br><br><pre> â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
 â”‚PeerAâ”‚ â”‚PeerBâ”‚
 â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
    â”‚ IdA, PubA â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â”‚â”€ â”€ â”€ â”€ â”€ â”€ ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign SignPubA = load () â•‘
    V â”‚ vPrvA, PubA = DHgen () â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â•
    DIdB, PubB, sinal (SignPrvB, (IdB, PubA, PubB)) â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â”‚ &lt;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â•‘SignPrvB, SignPubB = load () â•‘
    V â”‚ vPrvB, PubB = DHgen () â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â•
    â”‚ sinal (SignPrvA, (IdA, PubB, PubA)) â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â”‚ â”€ â”€ â”€ â”€ â”€&gt; ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify SignPubB, ...) â•‘
    = â”‚ Tecla = DH (PrvA, PubB) â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â•
    â”‚ â”‚
</pre><br><br>  No entanto, ainda nÃ£o â€œprovamosâ€ que desenvolvemos a mesma chave comum para esta sessÃ£o.  Em princÃ­pio, vocÃª pode passar sem essa etapa - a primeira conexÃ£o de transporte serÃ¡ invÃ¡lida, mas queremos que, quando o aperto de mÃ£o for concluÃ­do, tenhamos certeza de que tudo estÃ¡ realmente de acordo.  No momento, temos em nossas mÃ£os o protocolo ISO / IEC IS 9798-3. <br><br>  PoderÃ­amos assinar a chave em si.  Isso Ã© perigoso, pois Ã© possÃ­vel que haja vazamentos no algoritmo de assinatura usado (deixe bits por assinatura, mas ainda vaze).  VocÃª pode assinar um hash da chave gerada, mas mesmo um vazamento de hash da chave gerada pode ter valor em um ataque de forÃ§a bruta Ã  funÃ§Ã£o de geraÃ§Ã£o.  O SIGMA usa uma funÃ§Ã£o MAC que autentica o ID do remetente. <br><br><pre> â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
 â”‚PeerAâ”‚ â”‚PeerBâ”‚
 â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
    â”‚ IdA, PubA â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â”‚ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”‚ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ &gt; â•‘ â•‘SignPrvA, SignPubA = load () â•‘
    V â”‚ vPrvA, PubA = DHgen () â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â•
    DIdB, PubB, sinal (SignPrvB, (PubA, PubB)), MAC (IdB) â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•
    â”‚ &lt;â”€â”€â”€ â”€ â”€ â”€ â”€ â”€ â”‚ â”‚ â”‚ â”‚ â”‚. â”€â”‚SignPrvB, SignPubB = load ()
    V â”‚ vPrvB, PubB = DHgen () â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â•
    â”‚ â”‚ â•”â•â• â• â• â•— â•— â•— â• â•— â•— â•—
    â”‚ sinal (SignPrvA, (PubB, PubA)), MAC (IdA) â”‚ eyChave = DH (PrvA, PubB) â•‘
    â”‚ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”‚ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ &gt; Verificar (Chave, IdB)
    Verificar (SignPubB, ...)
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â•
    â”‚ â”‚
</pre><br><br>  Como otimizaÃ§Ã£o, alguns podem querer reutilizar suas chaves efÃªmeras (o que, Ã© claro, Ã© deplorÃ¡vel para o PFS).  Por exemplo, geramos um par de chaves, tentamos conectar, mas o TCP nÃ£o estava disponÃ­vel ou interrompemos em algum lugar no meio do protocolo.  Ã‰ uma pena gastar os recursos de entropia e processador gastos em um novo par.  Portanto, apresentamos o chamado cookie - um valor pseudo-aleatÃ³rio que protegerÃ¡ contra possÃ­veis ataques acidentais de reproduÃ§Ã£o ao reutilizar chaves pÃºblicas efÃªmeras.  Devido Ã  ligaÃ§Ã£o entre o cookie e a chave pÃºblica efÃªmera, a chave pÃºblica da parte oposta pode ser removida da assinatura como desnecessÃ¡ria. <br><br><pre> â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
 â”‚PeerAâ”‚ â”‚PeerBâ”‚
 â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
    â”‚ IdA, PubA, CookieA â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â”‚ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”‚ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ &gt;&gt; &gt;&gt; SignPrvA, SignPubA = load () â•‘
    V â”‚ vPrvA, PubA = DHgen () â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â•
    DIdB, PubB, CookieB, sinal (SignPrvB, (CookieA, CookieB, PubB)), MAC (IdB) â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â•â•â•â•—
    â”‚ &lt;â”€â”€â”€ â”€ â”€ â”€ â”€ â”€ â”‚ â”‚ â”‚ â”‚ â”‚. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ â•‘SignPrvB, SignPubB = load () â•‘
    V â”‚ vPrvB, PubB = DHgen () â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â•
    â”‚ â”‚ â•”â•â• â• â• â•— â•— â•— â• â•— â•— â•—
    â”‚ sinal (SignPrvA, (CookieB, CookieA, PubA)), MAC (IdA) â”‚ â•‘Key = DH (PrvA, PubB) â•‘
    â”‚ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”‚ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ ify ify ify ify ify ify ify ify ify ify Verifique (Chave, IdB) â•‘
    Verificar (SignPubB, ...)
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â•
    â”‚ â”‚
</pre><br><br>  Finalmente, queremos obter a privacidade de nossos identificadores interlocutores de um observador passivo.  Para fazer isso, o SIGMA sugere primeiro trocar chaves efÃªmeras, elaborando uma chave comum na qual autenticar e autenticar mensagens.  O SIGMA descreve duas opÃ§Ãµes: <br><br><ul><li>  SIGMA-I - protege o iniciador de ataques ativos, o respondente de ataques passivos: o iniciador autentica o respondedor e, se algo nÃ£o se encaixa, nÃ£o fornece sua identificaÃ§Ã£o.  O rÃ©u dÃ¡ sua identificaÃ§Ã£o se vocÃª iniciar um protocolo ativo com ele.  O observador passivo nÃ£o saberÃ¡ nada; <br>  SIGMA-R - protege o respondente de ataques ativos, o iniciador de passivo.  Tudo Ã© exatamente o contrÃ¡rio, mas neste protocolo jÃ¡ sÃ£o transmitidas quatro mensagens de handshake. <br><br><br>  Escolhemos o SIGMA-I como mais semelhante ao que esperamos das coisas usuais de servidor-cliente: apenas um servidor autenticado reconhece o cliente e todo mundo conhece o servidor de qualquer maneira.  AlÃ©m disso, Ã© mais fÃ¡cil de implementar devido a menos mensagens de handshake.  Tudo o que adicionamos ao protocolo Ã© a criptografia da parte da mensagem e a transferÃªncia do identificador A para a parte criptografada da Ãºltima mensagem: <br><br><pre> â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
 â”‚PeerAâ”‚ â”‚PeerBâ”‚
 â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
    â”‚ PubA, CookieA â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â”‚ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”‚ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ ign ign ign ign ign ign ign ign ign ign ,,,,, SignPubA = load () â•‘
    V â”‚ vPrvA, PubA = DHgen () â•‘<font></font>
   â”‚ â”‚ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•<font></font>
   â”‚PubB, CookieB, Enc((IdB, sign(SignPrvB, (CookieA, CookieB, PubB)), MAC(IdB))) â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—<font></font>
   â”‚&lt;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ â•‘SignPrvB, SignPubB = load()â•‘<font></font>
   â”‚ â”‚ â•‘PrvB, PubB = DHgen() â•‘<font></font>
   â”‚ â”‚ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•<font></font>
   â”‚ â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—<font></font>
   â”‚ Enc((IdA, sign(SignPrvA, (CookieB, CookieA, PubA)), MAC(IdA))) â”‚ â•‘Key = DH(PrvA, PubB) â•‘<font></font>
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€&gt;â”‚ â•‘verify(Key, IdB) â•‘<font></font>
   â”‚ â”‚ â•‘verify(SignPubB, ...)â•‘<font></font>
   â”‚ â”‚ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•<font></font>
   â”‚ â”‚<font></font>
</pre><br><br><ul><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">34.10-2012</a>   256- . </li><li>      34.10-2012 VKO. </li><li>   MAC  CMAC.       ,     34.13-2015.        â€” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> (34.12-2015). </li><li>          .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">-256</a> (34.11-2012 256 ). </li></ul><br><br>        .         .         :   ,  ,  (MAC)   , .         ,    , .     , ,  ?          .   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">KDF</a> (key derivation function).  ,     - : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HKDF</a>  ,       .  ,    Python   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hkdf</a> . HKDF   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HMAC</a> , ,   ,  -.    Python   Wikipedia    .      34.10-2012,   -   -256.         ,      : <br><br><pre> <code class="python hljs">kdf = Hkdf(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, key_session, hash=GOST34112012256) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake1-mac-identity"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake1-enc"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake1-mac"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake2-mac-identity"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake2-enc"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake2-mac"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"transport-initiator-enc"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"transport-initiator-mac"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"transport-responder-enc"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"transport-responder-mac"</span></span>)</code> </pre><br><h2> / </h2><br>     ASN.1         : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Msg</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Choice)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"text"</span></span>, MsgText()), (<span class="hljs-string"><span class="hljs-string">"handshake0"</span></span>, MsgHandshake0(expl=tag_ctxc(<span class="hljs-number"><span class="hljs-number">0</span></span>))), (<span class="hljs-string"><span class="hljs-string">"handshake1"</span></span>, MsgHandshake1(expl=tag_ctxc(<span class="hljs-number"><span class="hljs-number">1</span></span>))), (<span class="hljs-string"><span class="hljs-string">"handshake2"</span></span>, MsgHandshake2(expl=tag_ctxc(<span class="hljs-number"><span class="hljs-number">2</span></span>))), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgText</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"payload"</span></span>, MsgTextPayload()), (<span class="hljs-string"><span class="hljs-string">"payloadMac"</span></span>, MAC()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgTextPayload</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"nonce"</span></span>, Integer(bounds=(<span class="hljs-number"><span class="hljs-number">0</span></span>, float(<span class="hljs-string"><span class="hljs-string">"+inf"</span></span>)))), (<span class="hljs-string"><span class="hljs-string">"ciphertext"</span></span>, OctetString(bounds=(<span class="hljs-number"><span class="hljs-number">1</span></span>, MaxTextLen))), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgHandshake0</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"cookieInitiator"</span></span>, Cookie()), (<span class="hljs-string"><span class="hljs-string">"pubKeyInitiator"</span></span>, PubKey()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgHandshake1</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"cookieResponder"</span></span>, Cookie()), (<span class="hljs-string"><span class="hljs-string">"pubKeyResponder"</span></span>, PubKey()), (<span class="hljs-string"><span class="hljs-string">"ukm"</span></span>, OctetString(bounds=(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>))), (<span class="hljs-string"><span class="hljs-string">"ciphertext"</span></span>, OctetString()), (<span class="hljs-string"><span class="hljs-string">"ciphertextMac"</span></span>, MAC()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgHandshake2</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"ciphertext"</span></span>, OctetString()), (<span class="hljs-string"><span class="hljs-string">"ciphertextMac"</span></span>, MAC()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandshakeTBE</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"identity"</span></span>, OctetString(bounds=(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>))), (<span class="hljs-string"><span class="hljs-string">"signature"</span></span>, OctetString(bounds=(<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>))), (<span class="hljs-string"><span class="hljs-string">"identityMac"</span></span>, MAC()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandshakeTBS</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"cookieTheir"</span></span>, Cookie()), (<span class="hljs-string"><span class="hljs-string">"cookieOur"</span></span>, Cookie()), (<span class="hljs-string"><span class="hljs-string">"pubKeyOur"</span></span>, PubKey()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cookie</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(OctetString)</span></span></span><span class="hljs-class">:</span></span> bounds = (<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PubKey</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(OctetString)</span></span></span><span class="hljs-class">:</span></span> bounds = (<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MAC</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(OctetString)</span></span></span><span class="hljs-class">:</span></span> bounds = (<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre><br> HandshakeTBS â€” ,    (to be signed). HandshakeTBE â€” ,    (to be encrypted).     ukm  MsgHandshake1. 34.10 VKO,      ,   UKM (user keying material) â€”   . <br><br><h2>     </h2><br>        ,      (  ,     ,       ). <br><br>           ,     -  .    JSON  : <br><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">"our"</span></span>: { <span class="hljs-string"><span class="hljs-string">"prv"</span></span>: <span class="hljs-string"><span class="hljs-string">"21254cf66c15e0226ef2669ceee46c87b575f37f9000272f408d0c9283355f98"</span></span>, <span class="hljs-string"><span class="hljs-string">"pub"</span></span>: <span class="hljs-string"><span class="hljs-string">"938c87da5c55b27b7f332d91b202dbef2540979d6ceaa4c35f1b5bfca6df47df0bdae0d3d82beac83cec3e353939489d9981b7eb7a3c58b71df2212d556312a1"</span></span> }, <span class="hljs-string"><span class="hljs-string">"their"</span></span>: { <span class="hljs-string"><span class="hljs-string">"alice"</span></span>: <span class="hljs-string"><span class="hljs-string">"d361a59c25d2ca5a05d21f31168609deeec100570ac98f540416778c93b2c7402fd92640731a707ec67b5410a0feae5b78aeec93c4a455a17570a84f2bc21fce"</span></span>, <span class="hljs-string"><span class="hljs-string">"bob"</span></span>: <span class="hljs-string"><span class="hljs-string">"aade1207dd85ecd283272e7b69c078d5fae75b6e141f7649ad21962042d643512c28a2dbdc12c7ba40eb704af920919511180c18f4d17e07d7f5acd49787224a"</span></span> } }</code> </pre><br> our â€”   ,     . their â€”      .        JSON : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pygost <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gost3410 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pygost.gost34112012256 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GOST34112012256 CURVE = gost3410.GOST3410Curve( *gost3410.CURVE_PARAMS[<span class="hljs-string"><span class="hljs-string">"GostR3410_2001_CryptoPro_A_ParamSet"</span></span>] ) parser = argparse.ArgumentParser(description=<span class="hljs-string"><span class="hljs-string">"GOSTIM"</span></span>) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--keys-gen"</span></span>, action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Generate JSON with our new keypair"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--keys"</span></span>, default=<span class="hljs-string"><span class="hljs-string">"keys.json"</span></span>, required=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, help=<span class="hljs-string"><span class="hljs-string">"JSON with our and their keys"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--bind"</span></span>, default=<span class="hljs-string"><span class="hljs-string">"::1"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Address to listen on"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--port"</span></span>, type=int, default=<span class="hljs-number"><span class="hljs-number">6666</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Port to listen on"</span></span>, ) args = parser.parse_args() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.keys_gen: prv_raw = urandom(<span class="hljs-number"><span class="hljs-number">32</span></span>) pub = gost3410.public_key(CURVE, gost3410.prv_unmarshal(prv_raw)) pub_raw = gost3410.pub_marshal(pub) print(json.dumps({ <span class="hljs-string"><span class="hljs-string">"our"</span></span>: {<span class="hljs-string"><span class="hljs-string">"prv"</span></span>: hexenc(prv_raw), <span class="hljs-string"><span class="hljs-string">"pub"</span></span>: hexenc(pub_raw)}, <span class="hljs-string"><span class="hljs-string">"their"</span></span>: {}, })) exit(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Parse and unmarshal our and their keys {{{ with open(args.keys, "rb") as fd: _keys = json.loads(fd.read().decode("utf-8")) KEY_OUR_SIGN_PRV = gost3410.prv_unmarshal(hexdec(_keys["our"]["prv"])) _pub = hexdec(_keys["our"]["pub"]) KEY_OUR_SIGN_PUB = gost3410.pub_unmarshal(_pub) KEY_OUR_SIGN_PUB_HASH = OctetString(GOST34112012256(_pub).digest()) for peer_name, pub_raw in _keys["their"].items(): _pub = hexdec(pub_raw) KEYS[GOST34112012256(_pub).digest()] = { "name": peer_name, "pub": gost3410.pub_unmarshal(_pub), } # }}}</span></span></code> </pre><br>   34.10  â€”  .  256-  256-  . PyGOST     ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ,     (urandom(32))    ,  gost3410.prv_unmarshal().      ,  gost3410.public_key().   34.10 â€”   ,            ,  gost3410.pub_marshal(). <br><br>   JSON ,  , ,   ,  gost3410.pub_unmarshal().             ,              . -256   gost34112012256.GOST34112012256(),   hashlib  -. <br><br>    ? ,    :  cookie (128-  ),    34.10,     VKO   . <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">395</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initiator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(host, port)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">396</span></span> _id = repr((host, port)) <span class="hljs-number"><span class="hljs-number">397</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: dialing"</span></span>, _id) <span class="hljs-number"><span class="hljs-number">398</span></span> reader, writer = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.open_connection(host, port) <span class="hljs-number"><span class="hljs-number">399</span></span> <span class="hljs-comment"><span class="hljs-comment"># Generate our ephemeral public key and cookie, send Handshake 0 message {{{ 400 cookie_our = Cookie(urandom(16)) 401 prv = gost3410.prv_unmarshal(urandom(32)) 402 pub_our = gost3410.public_key(CURVE, prv) 403 pub_our_raw = PubKey(gost3410.pub_marshal(pub_our)) 404 writer.write(Msg(("handshake0", MsgHandshake0(( 405 ("cookieInitiator", cookie_our), 406 ("pubKeyInitiator", pub_our_raw), 407 )))).encode()) 408 # }}} 409 await writer.drain()</span></span></code> </pre><br><ul><li>      Msg ; </li><li>    handshake1; </li><li>          ; </li><li>       TBE  . </li></ul><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">423</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: got %s message"</span></span>, _id, msg.choice) <span class="hljs-number"><span class="hljs-number">424</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msg.choice != <span class="hljs-string"><span class="hljs-string">"handshake1"</span></span>: <span class="hljs-number"><span class="hljs-number">425</span></span> logging.warning(<span class="hljs-string"><span class="hljs-string">"%s: unexpected message, disconnecting"</span></span>, _id) <span class="hljs-number"><span class="hljs-number">426</span></span> writer.close() <span class="hljs-number"><span class="hljs-number">427</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">428</span></span> <span class="hljs-comment"><span class="hljs-comment"># }}} 429 msg_handshake1 = msg.value 430 # Validate Handshake message {{{ 431 cookie_their = msg_handshake1["cookieResponder"] 432 pub_their_raw = msg_handshake1["pubKeyResponder"] 433 pub_their = gost3410.pub_unmarshal(bytes(pub_their_raw)) 434 ukm_raw = bytes(msg_handshake1["ukm"]) 435 ukm = ukm_unmarshal(ukm_raw) 436 key_session = kek_34102012256(CURVE, prv, pub_their, ukm, mode=2001) 437 kdf = Hkdf(None, key_session, hash=GOST34112012256) 438 key_handshake1_mac_identity = kdf.expand(b"handshake1-mac-identity") 439 key_handshake1_enc = kdf.expand(b"handshake1-enc") 440 key_handshake1_mac = kdf.expand(b"handshake1-mac")</span></span></code> </pre><br> UKM  64-  (urandom(8)),       ,  gost3410_vko.ukm_unmarshal(). VKO   34.10-2012 256-  gost3410_vko.kek_34102012256() (KEK â€” key encryption key). <br><br>      256-   .        HKDF .   GOST34112012256  hashlib ,        Hkdf .  (  Hkdf)   ,     -               . kdf.expand()       256-,     . <br><br>   TBE  TBS   : <br><br><ul><li>    MAC   ; </li><li>  ; </li><li>  TBE ; </li><li>            ; </li><li>    MAC   ; </li><li>    TBS ,    cookie        .      . </li></ul><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">441</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-number"><span class="hljs-number">442</span></span> peer_name = validate_tbe( <span class="hljs-number"><span class="hljs-number">443</span></span> msg_handshake1, <span class="hljs-number"><span class="hljs-number">444</span></span> key_handshake1_mac_identity, <span class="hljs-number"><span class="hljs-number">445</span></span> key_handshake1_enc, <span class="hljs-number"><span class="hljs-number">446</span></span> key_handshake1_mac, <span class="hljs-number"><span class="hljs-number">447</span></span> cookie_our, <span class="hljs-number"><span class="hljs-number">448</span></span> cookie_their, <span class="hljs-number"><span class="hljs-number">449</span></span> pub_their_raw, <span class="hljs-number"><span class="hljs-number">450</span></span> ) <span class="hljs-number"><span class="hljs-number">451</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> err: <span class="hljs-number"><span class="hljs-number">452</span></span> logging.warning(<span class="hljs-string"><span class="hljs-string">"%s: %s, disconnecting"</span></span>, _id, err) <span class="hljs-number"><span class="hljs-number">453</span></span> writer.close() <span class="hljs-number"><span class="hljs-number">454</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">455</span></span> <span class="hljs-comment"><span class="hljs-comment"># }}} 128 def validate_tbe( 129 msg_handshake: Union[MsgHandshake1, MsgHandshake2], 130 key_mac_identity: bytes, 131 key_enc: bytes, 132 key_mac: bytes, 133 cookie_their: Cookie, 134 cookie_our: Cookie, 135 pub_key_our: PubKey, 136 ) -&gt; str: 137 ciphertext = bytes(msg_handshake["ciphertext"]) 138 mac_tag = mac(GOST3412Kuznechik(key_mac).encrypt, KUZNECHIK_BLOCKSIZE, ciphertext) 139 if not compare_digest(mac_tag, bytes(msg_handshake["ciphertextMac"])): 140 raise ValueError("invalid MAC") 141 plaintext = ctr( 142 GOST3412Kuznechik(key_enc).encrypt, 143 KUZNECHIK_BLOCKSIZE, 144 ciphertext, 145 8 * b"\x00", 146 ) 147 try: 148 tbe, _ = HandshakeTBE().decode(plaintext) 149 except ASN1Error: 150 raise ValueError("can not decode TBE") 151 key_sign_pub_hash = bytes(tbe["identity"]) 152 peer = KEYS.get(key_sign_pub_hash) 153 if peer is None: 154 raise ValueError("unknown identity") 155 mac_tag = mac( 156 GOST3412Kuznechik(key_mac_identity).encrypt, 157 KUZNECHIK_BLOCKSIZE, 158 key_sign_pub_hash, 159 ) 160 if not compare_digest(mac_tag, bytes(tbe["identityMac"])): 161 raise ValueError("invalid identity MAC") 162 tbs = HandshakeTBS(( 163 ("cookieTheir", cookie_their), 164 ("cookieOur", cookie_our), 165 ("pubKeyOur", pub_key_our), 166 )) 167 if not gost3410.verify( 168 CURVE, 169 peer["pub"], 170 GOST34112012256(tbs.encode()).digest(), 171 bytes(tbe["signature"]), 172 ): 173 raise ValueError("invalid signature") 174 return peer["name"]</span></span></code> </pre><br>    , 34.13-2015   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a>  34.12-2015.      ,  MAC-.  PyGOST  gost3413.mac().       (     ),   , ,  .   hardcode-  ? 34.12-2015    128-  ,    64- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> â€”    28147-89,               . <br><br>   gost.3412.GOST3412Kuznechik(key)      .encrypt()/.decrypt() ,     34.13 . MAC   : gost3413.mac(GOST3412Kuznechik(key).encrypt, KUZNECHIK_BLOCKSIZE, ciphertext).      MAC-     (==)  ,        , ,   ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BEAST</a>   TLS.  Python   hmac.compare_digest   . <br><br>         .   ,      ,    .  34.13-2015  : ECB, CTR, OFB, CBC, CFB.        .   ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> ( CCM, OCB, GCM  ) â€”       MAC.   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> (CTR):       ,  ,    ,          (   CBC,      ). <br><br>   .mac(), .ctr()     : ciphertext = gost3413.ctr(GOST3412Kuznechik(key).encrypt, KUZNECHIK_BLOCKSIZE, plaintext, iv).    ,     .           (    ),      .   handshake        . <br><br>   gost3410.verify() :        (      GOSTIM ),    ( ,         ,    ), 34.11-2012     . <br><br> ,       handshake2  ,           ,  :      ,  .â€¦ <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">456</span></span> <span class="hljs-comment"><span class="hljs-comment"># Prepare and send Handshake 2 message {{{ 457 tbs = HandshakeTBS(( 458 ("cookieTheir", cookie_their), 459 ("cookieOur", cookie_our), 460 ("pubKeyOur", pub_our_raw), 461 )) 462 signature = gost3410.sign( 463 CURVE, 464 KEY_OUR_SIGN_PRV, 465 GOST34112012256(tbs.encode()).digest(), 466 ) 467 key_handshake2_mac_identity = kdf.expand(b"handshake2-mac-identity") 468 mac_tag = mac( 469 GOST3412Kuznechik(key_handshake2_mac_identity).encrypt, 470 KUZNECHIK_BLOCKSIZE, 471 bytes(KEY_OUR_SIGN_PUB_HASH), 472 ) 473 tbe = HandshakeTBE(( 474 ("identity", KEY_OUR_SIGN_PUB_HASH), 475 ("signature", OctetString(signature)), 476 ("identityMac", MAC(mac_tag)), 477 )) 478 tbe_raw = tbe.encode() 479 key_handshake2_enc = kdf.expand(b"handshake2-enc") 480 key_handshake2_mac = kdf.expand(b"handshake2-mac") 481 ciphertext = ctr( 482 GOST3412Kuznechik(key_handshake2_enc).encrypt, 483 KUZNECHIK_BLOCKSIZE, 484 tbe_raw, 485 8 * b"\x00", 486 ) 487 mac_tag = mac( 488 GOST3412Kuznechik(key_handshake2_mac).encrypt, 489 KUZNECHIK_BLOCKSIZE, 490 ciphertext, 491 ) 492 writer.write(Msg(("handshake2", MsgHandshake2(( 493 ("ciphertext", OctetString(ciphertext)), 494 ("ciphertextMac", MAC(mac_tag)), 495 )))).encode()) 496 # }}} 497 await writer.drain() 498 logging.info("%s: session established: %s", _id, peer_name)</span></span></code> </pre><br>   ,     (   ,  ,    ),       MAC-: <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">499</span></span> <span class="hljs-comment"><span class="hljs-comment"># Run text message sender, initialize transport decoder {{{ 500 key_initiator_enc = kdf.expand(b"transport-initiator-enc") 501 key_initiator_mac = kdf.expand(b"transport-initiator-mac") 502 key_responder_enc = kdf.expand(b"transport-responder-enc") 503 key_responder_mac = kdf.expand(b"transport-responder-mac") ... 509 asyncio.ensure_future(msg_sender( 510 peer_name, 511 key_initiator_enc, 512 key_initiator_mac, 513 writer, 514 )) 515 encrypter = GOST3412Kuznechik(key_responder_enc).encrypt 516 macer = GOST3412Kuznechik(key_responder_mac).encrypt 517 # }}} 519 nonce_expected = 0 520 # Wait for test messages {{{ 521 while True: 522 data = await reader.read(MaxMsgLen) ... 530 msg, tail = Msg().decode(buf) ... 537 try: 538 await msg_receiver( 539 msg.value, 540 nonce_expected, 541 macer, 542 encrypter, 543 peer_name, 544 ) 545 except ValueError as err: 546 logging.warning("%s: %s", err) 547 break 548 nonce_expected += 1 549 # }}}</span></span></code> </pre><br> msg_sender    ,    TCP-.      nonce,          .           . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg_sender</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(peer_name: str, key_enc: bytes, key_mac: bytes, writer)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> nonce = <span class="hljs-number"><span class="hljs-number">0</span></span> encrypter = GOST3412Kuznechik(key_enc).encrypt macer = GOST3412Kuznechik(key_mac).encrypt in_queue = IN_QUEUES[peer_name] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> in_queue.get() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> text <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> ciphertext = ctr( encrypter, KUZNECHIK_BLOCKSIZE, text.encode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>), long2bytes(nonce, <span class="hljs-number"><span class="hljs-number">8</span></span>), ) payload = MsgTextPayload(( (<span class="hljs-string"><span class="hljs-string">"nonce"</span></span>, Integer(nonce)), (<span class="hljs-string"><span class="hljs-string">"ciphertext"</span></span>, OctetString(ciphertext)), )) mac_tag = mac(macer, KUZNECHIK_BLOCKSIZE, payload.encode()) writer.write(Msg((<span class="hljs-string"><span class="hljs-string">"text"</span></span>, MsgText(( (<span class="hljs-string"><span class="hljs-string">"payload"</span></span>, payload), (<span class="hljs-string"><span class="hljs-string">"payloadMac"</span></span>, MAC(mac_tag)), )))).encode()) nonce += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>     msg_receiver,    : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg_receiver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( msg_text: MsgText, nonce_expected: int, macer, encrypter, peer_name: str, )</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> payload = msg_text[<span class="hljs-string"><span class="hljs-string">"payload"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> int(payload[<span class="hljs-string"><span class="hljs-string">"nonce"</span></span>]) != nonce_expected: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"unexpected nonce value"</span></span>) mac_tag = mac(macer, KUZNECHIK_BLOCKSIZE, payload.encode()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> compare_digest(mac_tag, bytes(msg_text[<span class="hljs-string"><span class="hljs-string">"payloadMac"</span></span>])): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"invalid MAC"</span></span>) plaintext = ctr( encrypter, KUZNECHIK_BLOCKSIZE, bytes(payload[<span class="hljs-string"><span class="hljs-string">"ciphertext"</span></span>]), long2bytes(nonce_expected, <span class="hljs-number"><span class="hljs-number">8</span></span>), ) text = plaintext.decode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> OUT_QUEUES[peer_name].put(text)</code> </pre><br><h2>  ConclusÃ£o </h2><br> GOSTIM       (    ,  )!      <a href=""></a> (-256 : 995bbd368c04e50a481d138c5fa2e43ec7c89bc77743ba8dbabee1fde45de120).     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GoGOST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PyDERASN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NNCP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GoVPN</a> , GOSTIM   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GPLv3+</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> , Python/Go-,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> Â« â€â€œ</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt452200/">https://habr.com/ru/post/pt452200/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt452186/index.html">As linguagens de programaÃ§Ã£o mais raras e caras</a></li>
<li><a href="../pt452188/index.html">Teste de unidade de serializaÃ§Ã£o Json no Spring Boot</a></li>
<li><a href="../pt452190/index.html">Usando o WebAssembly 20x Web Application Accelerated</a></li>
<li><a href="../pt452192/index.html">O que Ã© isso aqui? OperaÃ§Ã£o interna de objetos JavaScript</a></li>
<li><a href="../pt452198/index.html">O que todo engenheiro de controle de qualidade deve saber sobre o Selenium 4?</a></li>
<li><a href="../pt452202/index.html">RevisÃ£o da Sprint: Inferior - Inferior</a></li>
<li><a href="../pt452204/index.html">Como eu escrevi minha primeira IA</a></li>
<li><a href="../pt452206/index.html">E - ExperiÃªncia. Ou como a ciÃªncia ajuda a projetar interfaces</a></li>
<li><a href="../pt452210/index.html">Bot para VK em Python com MySQL em uma hora, parte 2</a></li>
<li><a href="../pt452212/index.html">Como se mudar para os EUA com a sua startup: 3 opÃ§Ãµes de vistos reais, seus recursos e estatÃ­sticas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>