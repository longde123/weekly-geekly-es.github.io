<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💢 🚴🏼 🏇 JPEG多次重新加载研究 📹 🏞️ 🐃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="VK有一个具有以下描述的组 ： 
 每天将同一张照片手动保存到计算机，然后再次上传，逐渐失去质量。 

 左侧是2012年6月7日上传的原始图片，右侧是现在的图片。 



 录影带 


 这种差异非常可疑。 让我们尝试弄清楚这7年中发生了什么。 熟识的人在美杜莎（Medusa）上有一篇关于该小组...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JPEG多次重新加载研究</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473544/"><p>  VK有一个具有以下描述的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">组</a> ： </p><br><blockquote> 每天将同一张照片手动保存到计算机，然后再次上传，逐渐失去质量。 </blockquote><p> 左侧是2012年6月7日上传的原始图片，右侧是现在的图片。 </p><br><p><img src="https://habrastorage.org/webt/k1/nd/gc/k1ndgcipxujc4rl7mplffliy3ae.jpeg" alt="KDPV"></p><br><div class="spoiler">  <b class="spoiler_title">录影带</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ymca5aWPurM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><p> 这种差异非常可疑。 让我们尝试弄清楚这7年中发生了什么。 熟识<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的人</a>在美杜莎（Medusa）上有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇</a>关于该小组<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的文章</a> ，但只有技术方面的人才会引起我们的兴趣。 </p><a name="habracut"></a><br><h1 id="pochemu-i-na-kakom-etape-jpeg-szhimaet-s-poteryami">  JPEG为何以及在什么阶段会损失压缩 </h1><br><p> 考虑高度简化的JPEG编码和解码方案。 仅显示那些说明JPEG算法基本原理的操作。 </p><br><p><img src="https://habrastorage.org/webt/bf/3l/mo/bf3lmo7c2boozc7d2id4pkqslka.png" alt="JPEG原理"></p><br><p> 因此，有4种操作： </p><br><ul><li>  DCT是离散余弦变换。 </li><li> 量化-将每个值四舍五入到量化步长的最接近倍数：y = [x / h] * h，其中h是步长。 </li><li>  IDCT是离散离散余弦逆变换。 </li><li> 舍入是正常的舍入。 由于这是显而易见的，因此无法在图中显示。 但随后将证明其重要性。 </li></ul><br><p> 保存所有信息的操作以绿色突出显示（使用浮点数时未考虑丢失），粉红色表示丢失。 即，损耗和伪像的出现不是因为余弦变换，而是因为简单的量化。 本文不会考虑一个重要的阶段-霍夫曼编码，因为它的执行没有损失。 </p><br><p> 更详细地考虑这些步骤。 </p><br><h3 id="dct">  DCT </h3><br><p> 由于DCT有多种变体，以防万一，我将澄清JPEG使用具有归一化功能的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二种DCT</a> 。 编码时，每个图像被分成8x8正方形（每个通道）。 每个这样的正方形可以表示为64维向量。 余弦变换是在另一个正交基础上找到此向量的坐标。 很难可视化64维空间，因此下面将给出2维类比。 您可以想象图片被分为2x1块。 在下面将显示的图形中，x轴对应于块的第一个像素的值，y轴对应于第二个像素的值。 </p><br><p> 继续使用特定示例进行类比，假设原始图像中两个像素的值分别为3和4。如下图所示，绘制矢量（3，4）。 原始基准以蓝色标记。 向量的坐标在某些新基础上为（4.8，1.4）。 </p><br><p><img src="https://habrastorage.org/webt/qx/dh/xk/qxdhxkiyfx4j5uyh98m1y4c1ava.png" alt="新的向量变换示例"></p><br><p> 在所考虑的示例中，随机选择了一个新的基础。  DCT提供了非常具体的64维固定基础。 为什么在JPEG中使用它的理由非常有趣，我在另<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇文章中</a>对此进行了描述。 我们将只涉及要点。 通常，所有像素的值均相等。 但是，如果我们使用DCT对其进行转换，则可以在新的基础上从所得的64个坐标（称为DCT变换系数）中安全地将它们中的一些零置零或粗略舍入，而损失最小。 这归功于可压缩图像的功能。 </p><br><h3 id="kvantovanie"> 量化 </h3><br><p> 小数值不能保存在文件中。 因此，根据量化步骤，值4.8、1.4将保存如下： </p><br><ul><li> 在第1步（最温和的选项）：5和1 </li><li> 在步骤2：4和2 </li><li> 在步骤3：6和0。 </li></ul><br><p> 通常，每个值的步长选择都不同。  JPEG文件具有至少一个称为量化表的数组，该数组存储64个量化步骤。 该表取决于在任何图形编辑器中设置的压缩质量。 </p><br><h3 id="idct">  IDCT </h3><br><p> 与DCT相同，但具有转置基准。 数学上，x = IDCT（DCT（x）），因此，如果没有量化，则可以无损失地恢复。 但是不会有压缩。 由于使用了量化，原始矢量不能总是准确地计算出来。 下图显示了两个示例，这些示例具有准确且不准确的恢复。 倾斜的网格对应于新的基础，直线对应于原始基础。 </p><br><p><img src="https://habrastorage.org/webt/cl/ne/1g/clne1geexpruaosbsgwypmla0_8.png" alt="2个具有准确和不准确的向量重构的示例"></p><br><p> 一个明显的问题出现了：转码序列是否可以导致与原始向量有很大不同的向量？ 也许吧 </p><br><p><img src="https://habrastorage.org/webt/df/hm/ww/dfhmwwv_bcn3ru6qcgq8lrupkac.png" alt="向量转码序列"></p><br><p> 对所有整数向量进行排序并查看它们的代码转换将导致什么会很有趣。 为了减少信息噪声，我们删除了初始网格，然后将各个段直接连接原始向量和重构向量（无中间步骤）。 首先，考虑所有坐标的量化步长等于1。 下图中的新基准旋转了45度，为此，我们得到了不准确回收率的17.1％。 段的颜色没有任何意义，但是对于防止它们的视觉合并很有用。 </p><br><p><img src="https://habrastorage.org/webt/qv/oc/xv/qvocxvslveuyrvh76oxhqa-4tjk.png" alt="枚举45度新的向量"></p><br><p> 这个基础是10.3度，而7.4％的不准确回收率： </p><br><p><img src="https://habrastorage.org/webt/bs/ig/3k/bsig3kc6xvaiympimbjemxmz6ci.png" alt="为10.3度的新基础枚举向量"></p><br><p> 附近： </p><br><p><img src="https://habrastorage.org/webt/zz/nx/lk/zznxlkpwk7zcgdjbzotimj5p6ho.png" alt="在附近的10.3度处枚举向量以获得新的基础"></p><br><p> 而这一比率是6.4％的10.4： </p><br><p><img src="https://habrastorage.org/webt/3j/uj/w_/3jujw_15jsspkq_gyi8ke-o-xje.png" alt="为10.4度的新基础枚举向量"></p><br><p>  19度（12.5％）： </p><br><p><img src="https://habrastorage.org/webt/4o/xb/cf/4oxbcfgakefxb4jwkcna18nv_04.png" alt="枚举19度新的向量"></p><br><p> 但是，如果将量化步长设置为大于1，则重构的矢量将开始明显集中在网格节点附近。 这是步骤5： </p><br><p><img src="https://habrastorage.org/webt/lc/2v/uh/lc2vuhd2pk0dyvk7c3e3malrrqw.png" alt="第5步"></p><br><p> 这是2： </p><br><p><img src="https://habrastorage.org/webt/0j/dj/wi/0jdjwier8s0zqh162fbq1k7evmw.png" alt="第二步"></p><br><p> 如果以相同的音调对图像进行几次编码，那么与单次编码相比几乎没有任何反应。 这些值似乎“卡”在网格的节点中，不能再从那里“跳转”到其他节点。 如果步长不同，则矢量将从一个网格节点“跳转”到另一个网格节点。 这可以带他去任何地方。 下图显示了具有步骤1、2、3、4的4个代码转换的结果。您可以看到具有步骤12的大网格。该值是1、2、3、4的最小公倍数。 </p><br><p><img src="https://habrastorage.org/webt/t7/ee/tx/t7eetx-d2upsghi2ayvlz1jh7ra.png" alt="使用步骤1、2、3、4进行4编码的结果"></p><br><p> 并在此过程中执行-从1到7的步骤。仅显示部分原始向量的可视化效果，以改善可视化效果。 </p><br><p><img src="https://habrastorage.org/webt/xj/mw/t2/xjmwt2uyzvtcpjuq64xsj5qerqg.png" alt="4个编码结果，以1至4为步长"></p><br><h3 id="okruglenie"> 四舍五入 </h3><br><p> 为什么在IDCT之后四舍五入值？ 毕竟，如果您摆脱了这一阶段，那么还原的图像将由小数值表示，并且在重新编码时我们不会丢失任何内容。 从数学的角度来看，我们将简单地从一个基础转到另一个基础，而不会造成损失。 这里有必要提及色彩空间的转换。 尽管JPEG不能调节颜色空间，并且可以直接保存到源RGB中，但是在大多数情况下，使用了初步转换为YCbCr的方法。 眼睛特征等等。 而且这种转换也会导致损失。 </p><br><p> 假设我们得到了一个压缩质量最高的JPEG文件，也就是说，所有系数的量化步长均为1。 我们不知道使用了哪个编解码器，但是通常在RGB-&gt; YCbCr转换之后，编解码器执行舍入。 由于质量是最高的，因此在IDCT之后，我们得到的分数是小数，但与YCbCr空间中的原始值非常接近。 如果我们四舍五入，那么大多数将被完全恢复。 </p><br><p> 但是，如果不进行四舍五入，则由于存在如此小的差异，YCbCr-&gt; RGB转换甚至可以将它们与原始值进一步拉开距离。 随着随后的代码转换，差距将越来越大。 为了以某种方式可视化此过程，我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">主成分方法</a>将64维向量投影到平面上。 然后，对于1000个转码，我们大约得到以下更改序列： </p><br><p><img src="https://habrastorage.org/webt/lk/et/ii/lketiizdbzs1n3ak2ou9pm39rem.png" alt="变化不四舍五入"></p><br><p> 此处的轴绝对值意义不大，但可以使用变形的相对重要性。 </p><br><h1 id="primery-mnogokratnogo-perekodirovaniya"> 多个转码示例 </h1><br><p> 源猫： </p><br><p><img src="https://habrastorage.org/webt/xf/n8/uh/xfn8uhltsnwghy5mdkgffzis0jc.jpeg" alt="源猫"></p><br><p> 重新保存质量为50后： </p><br><p><img src="https://habrastorage.org/webt/lz/fh/gb/lzfhgbgntfvhase6t7z-kisz_ja.jpeg" alt="重新保存后品质为50的原始猫"></p><br><p> 在具有相同质量的任何后续数量的转码之后，图像均不会改变。 现在，我们将把质量从90逐渐降低到50：1： </p><br><p><img src="https://habrastorage.org/webt/br/zj/px/brzjpxgha8w0sfl_wzwzg0uybwq.jpeg" alt="质量从1的90逐渐降低到50"></p><br><p> 下图大约发生了相同的事情： </p><br><p><img src="https://habrastorage.org/webt/xj/mw/t2/xjmwt2uyzvtcpjuq64xsj5qerqg.png" alt="4个编码结果，以1至4为步长"></p><br><p> 重新保存质量为20后： </p><br><p><img src="https://habrastorage.org/webt/zz/pq/lc/zzpqlcbvnfdv-af3zscizmk4eeg.jpeg" alt="重新保存一次质量为20后"></p><br><p> 从90到20无缝： </p><br><p><img src="https://habrastorage.org/webt/ve/3z/qo/ve3zqos_tivr6s6vw4cdgncizpw.jpeg" alt="质量从90逐渐下降到20"></p><br><p> 现在有1000次，随机质量从80到90： </p><br><p><img src="https://habrastorage.org/webt/iw/4u/zg/iw4uzgbnuyp5x8z40dhcd-qhxfg.jpeg" alt="1000次重新存储，随机质量从80到90"></p><br><p>  10,000次： </p><br><p><img src="https://habrastorage.org/webt/ve/eh/ww/veehwwqlhvfzy2rlk9hgjrqh2qu.jpeg" alt="10,000次重新存储，随机质量从80到90"></p><br><h1 id="analiz-kartinok-gruppy-vk">  VK集团图片分析 </h1><br><p> 让我们开始分析VK集团的2000多张图片。 首先，从最开始检查平均绝对偏差。  x轴是图片编号（或日期），y轴是偏差。 </p><br><p><img src="https://habrastorage.org/webt/ln/5v/4h/ln5v4hqh-48jdun5t95ruzo0gue.png" alt="与第一个平均绝对偏差"></p><br><p> 我们继续看显示附近图片的平均绝对偏差的微分图。 </p><br><p><img src="https://habrastorage.org/webt/hv/gg/i5/hvggi5lzyjh4bdyt3i2zelokkv4.png" alt="相邻图像的平均绝对偏差"></p><br><p> 一开始的小幅波动是正常现象。 直到232日，一切都进行顺利，图片完全相同。 第233个像素的每个像素突然之间平均相差1.23（从0到255）。 好多 也许量化表刚刚改变。 看看吧。 同时，它与接收到的文件大小相当。 </p><br><p><img src="https://habrastorage.org/webt/xb/cg/qo/xbcgqoo2ifxqgr8c2gtusw64kgm.png" alt="质量变化"></p><br><p> 是的，表格已更改。 但不要早于700年代。 然后，也许发生了低质量的中间隐藏转码。 让我们尝试重新编码232nd两次。 第一次，我们将经历不同的质量级别，第二次，我们将使用与从1到700s相同的量化表。 我们的目标是使图片尽可能地类似于233号。 在下图中，沿x轴是中间代码转换的质量，沿y是与第233位的平均绝对偏差。 </p><br><p><img src="https://habrastorage.org/webt/sg/6o/ax/sg6oaxjxeqk75kwsantwy2gncbu.png" alt="添加隐藏的转码"></p><br><p> 尽管图表上的质量为75％，大约等于1，但它与期望的零仍然相距甚远。 增加第二个中间阶段并更改子采样参数并没有改善这种情况。 </p><br><p> 对于其余图片，一切都差不多，加上量化表中的变化也被叠加了。 就是说，在某个时候，情况发生了巨大变化，然后在几天之内稳定下来，但是直到出现新的浪潮。 也许服务器上的映像本身发生了变化。 我不能完全排除组管理员的参与。 </p><br><p> 不幸的是，我没有发现图像真正发生了什么。 至少现在，我确信这不仅仅是重新保存。 但是，最重要的是，更好地表示编码和解码过程中正在进行的过程。 希望你也这样做。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">图片存档</a> ，供独立研究。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN473544/">https://habr.com/ru/post/zh-CN473544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN473516/index.html">编写微服务博客-API网关的第2部分</a></li>
<li><a href="../zh-CN473528/index.html">没有交通拥堵的城市</a></li>
<li><a href="../zh-CN473530/index.html">使用IDA FREE和其他免费工具进行开发和反向（不是从头开始）的简介</a></li>
<li><a href="../zh-CN473532/index.html">黑客对物联网设备进行攻击的危险是什么：真实故事</a></li>
<li><a href="../zh-CN473534/index.html">自动化OEM信息更改</a></li>
<li><a href="../zh-CN473546/index.html">在TSD上的应用以及通过HTTP服务与1C：Enterprise 8.3的通信。 第2部分（1C端的API实现）</a></li>
<li><a href="../zh-CN473548/index.html">PKI权力下放：提高安全性的建议方法</a></li>
<li><a href="../zh-CN473550/index.html">小丑2019：年度胜利</a></li>
<li><a href="../zh-CN473552/index.html">通过Clickjacking在2019中进行去匿名</a></li>
<li><a href="../zh-CN473560/index.html">使用Node.js和Oracle数据库创建REST API。 第4部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>