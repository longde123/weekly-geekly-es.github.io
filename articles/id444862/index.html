<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕸️ 💛 🚗 Swift 5.0. Apa yang baru? 🔟 🙊 👩‍❤️‍👩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Swift 5 - rilis yang ditunggu-tunggu, yang mencakup beberapa lusin perbaikan dan perbaikan. Tetapi tujuan utama dari rilis Swift 5.0 adalah untuk menc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift 5.0. Apa yang baru?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/444862/"><p>  Swift 5 - rilis yang ditunggu-tunggu, yang mencakup beberapa lusin perbaikan dan perbaikan.  Tetapi tujuan utama dari rilis Swift 5.0 adalah untuk mencapai stabilitas ABI.  Pada artikel ini, Anda akan mempelajari apa ABI itu dan apa ABI stabil akan memberi pengembang iOS / macOS.  Kami juga akan menganalisis beberapa fitur baru Swift 5. </p><br><p><img src="https://habrastorage.org/webt/-p/8s/zk/-p8szkb7m3mn49xjavc3_nvkjyk.png"></p><a name="habracut"></a><br><h1 id="abi-stability">  Stabilitas ABI </h1><br><p>  ABI adalah antarmuka aplikasi biner.  ABI dapat dianggap sebagai seperangkat aturan yang memungkinkan tautan untuk menggabungkan modul komponen yang dikompilasi. </p><br><p>  Dengan demikian, berikut ini dijelaskan dalam ABI. </p><br><ol><li>  Kode cara dipanggil dari modul yang berbeda, termasuk yang sistem. </li><li>  Format untuk meneruskan argumen dan mendapatkan nilai balik dari fungsi. </li><li>  Algoritma tata letak data RAM. </li><li>  Manajemen Memori, ARC. </li><li>  Ketik sistem, obat generik. </li></ol><br><p>  Swift 5, bersama dengan ABI yang stabil, menyediakan kompatibilitas biner untuk aplikasi.  Kompatibilitas biner untuk aplikasi iOS / macOS berarti aplikasi yang dikompilasi akan kompatibel dalam runtime dengan pustaka sistem yang dikompilasi oleh versi bahasa yang lebih awal atau lebih baru.  Misalnya, aplikasi yang dikompilasi dengan Swift 5.0 akan kompatibel dengan pustaka standar yang dikompilasi dengan Swift 5.1 atau Swift 6.0. </p><br><p>  Dimulai dengan iOS 12.2 dan macOS 10.14.4, sistem operasi Apple akan berisi semua yang Anda butuhkan untuk menjalankan aplikasi cepat.  Ini berarti bahwa aplikasi yang ditulis dalam Swift 5 dan yang lebih baru tidak akan berisi runtime dan perpustakaan bahasa standar.  Karena itu, aplikasi yang ditulis dalam Swift 5 akan memiliki berat sekitar 3-10 megabita lebih sedikit. </p><br><p>  Penting untuk dicatat bahwa selain stabilitas ABI, ada juga stabilitas Modul.  Jika stabilitas ABI memungkinkan menggabungkan versi berbeda dari runtime dalam runtime, maka stabilitas Modul bertanggung jawab untuk bagaimana kerangka biner yang ditulis dalam versi bahasa yang berbeda dikompilasi.  Stabilitas modul akan muncul di Swift 5.1.  Dan kemudian pengembang akan dapat mendistribusikan kerangka kerja mereka tidak hanya dengan kode sumber terbuka, tetapi juga dalam bentuk yang dikompilasi. </p><br><p>  <strong>Kelebihan stabilitas ABI.</strong> </p><br><ol><li>  Aplikasi akan lebih sedikit berbobot. </li><li>  Mempercepat kinerja startup dan aplikasi. </li><li>  Secara teori, Apple bisa menulis kerangka kerja baru sepenuhnya di Swift. </li></ol><br><p>  <strong>Kontra stabilitas ABI.</strong> </p><br><p> Pengembang harus mempertimbangkan kurangnya fungsionalitas baru di versi lama dari perpustakaan standar.  Misalnya, jika Swift 5.1 dibangun ke iOS 13 dengan beberapa kelas / fungsi baru di perpustakaan standar, maka dengan dukungan di iOS 12.2, pengembang tidak akan dapat menggunakannya.  (Anda harus memasukkan cek #available (...) dengan cara yang sama seperti yang kami lakukan sekarang untuk Foundation, UIKit, dan pustaka platform lainnya). </p><br><h1 id="tip-result-v-standartnoy-biblioteke">  Jenis hasil di perpustakaan standar </h1><br><p>  Cara standar untuk mengirim dan menangani kesalahan di API asinkron telah muncul di pustaka standar.  Anda juga dapat menggunakan jenis ini jika karena alasan tertentu penanganan kesalahan standar melalui coba / tangkap tidak cocok untuk kami. </p><br><p>  Jenis Hasil diimplementasikan melalui enum dengan dua kasus: sukses dan gagal: </p><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Success</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Failure</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Failure</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> success(<span class="hljs-type"><span class="hljs-type">Success</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> failure(<span class="hljs-type"><span class="hljs-type">Failure</span></span>) ... }</code> </pre> <br><p>  Sebenarnya, pendekatan ini bukan hal baru bagi pengembang Swift.  Sejak versi pertama Swift, banyak pengembang telah menggunakan pendekatan serupa.  Tetapi sekarang, ketika Hasil telah muncul di perpustakaan standar, ini akan menyederhanakan interaksi dengan kode dari perpustakaan eksternal. </p><br><p>  Contoh menggunakan layanan unduhan artikel: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Article</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArticleService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchArticle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: Int64, completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Result&lt;Article, Error&gt;)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    // ... completion(.success(Article(title: "Swift 5.0.  ?"))) } }</span></span></code> </pre> <br><p>  Dan ini adalah contoh dari pemrosesan hasilnya.  Karena Result hanya enum, kita dapat memproses semua statusnya dengan sakelar: </p><br><pre> <code class="swift hljs">articleService.fetchArticle(id: <span class="hljs-number"><span class="hljs-number">42</span></span>) { result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> result { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .success(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> article): <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Success: \(article)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .failure(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error): <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Failure: \(error)"</span></span>) } }</code> </pre> <br><h1 id="raw-strings">  String mentah </h1><br><p>  Dalam Swift 5, mereka menambahkan apa yang disebut string mentah, di mana tanda kutip dan garis miring terbalik ditafsirkan persis sebagai karakter, dan untuk menggunakannya dalam literal, Anda tidak perlu menggunakan karakter escape.  Untuk menulis literal untuk string semacam itu, Anda harus menambahkan karakter # ke tanda kutip ganda di tepinya. </p><br><p>  Contoh menggunakan kutipan: </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// swift 4.2 print("    \"\"   .") print("     ,    \\n") // swift 5 print(#" ""      "#) print(#"     ,    \n"#)</span></span></code> </pre> <br><p>  Fitur ini sangat berguna saat menulis ekspresi reguler: </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// swift 4.2 let regex = "^\\(*\\d{3}\\)*( |-)*\\d{3}( |-)*\\d{4}$" // swift 5 let regex = #"^\(*\d{3}\)*( |-)*\d{3}( |-)*\d{4}$"#</span></span></code> </pre> <br><p>  Untuk menginterpolasi garis setelah backslash, tambahkan karakter #: </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// swift 4.2 let string = "   \(variable)" // swift 5 let string = #"   \#(variable)"#</span></span></code> </pre> <br><p>  Anda dapat membaca lebih lanjut <a href="">dalam kalimat ini</a> . </p><br><h1 id="obnovlennaya-interpolyaciya-strok">  Interpolasi baris yang diperbarui </h1><br><p>  Menggunakan interpolasi string, kita bisa menambahkan nilai variabel atau hasil ekspresi ke string literal.  Dimulai dengan versi bahasa ke-5, menjadi mungkin untuk memperluas cara ekspresi kita ditambahkan ke baris terakhir. <br>  Secara umum, cukup tulis ekstensi ke struktur DefaultStringInterpolation dan tambahkan metode yang disebut appendInterpolation.  Misalnya, jika kami ingin menambahkan harga dalam bentuk yang diformat ke string: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultStringInterpolation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendInterpolation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(price: Decimal)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> formatter = <span class="hljs-type"><span class="hljs-type">NumberFormatter</span></span>() formatter.numberStyle = .currency <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> string = formatter.string(from: price <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">NSDecimalNumber</span></span>) { appendLiteral(string) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { appendLiteral(price.description) } } } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Price of item: \(price: 9.99)"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Price of item: $9.99</span></span></code> </pre> <br><p>  Penting untuk dicatat bahwa, pada kenyataannya, konstruksi (harga: 9,99) dalam string menggunakan kompiler diubah menjadi panggilan ke metode appendInterpolasi (harga: Desimal). <br>  Juga dalam metode appendInterpolation kita dapat menambahkan argumen dalam jumlah tidak terbatas, baik yang dinamai maupun yang tidak disebutkan namanya, dengan atau tanpa nilai default. </p><br><p>  Anda dapat membaca lebih lanjut <a href="">dalam kalimat ini</a> . </p><br><h1 id="proverka-kratnosti-chisel">  Memeriksa banyaknya angka </h1><br><p>  Metode pengecekan multiplicity isMultiple (of :) telah ditambahkan ke tipe numerik di pustaka standar.  Ya, kami masih dapat menggunakan operator untuk mengambil sisa pembagian%.  Tetapi tampaknya isMultiple (dari :) terlihat lebih visual. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> interger = <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interger.isMultiple(of: <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">" "</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) }</code> </pre> <br><h1 id="metod-compactmapvalues-v-dictionary">  Metode CompactMapValues ​​dalam Kamus </h1><br><p>  Metode compactMapValues ​​memungkinkan Anda untuk mengkonversi nilai kamus, serta memfilternya jika konversi itu sendiri mengembalikan nol. </p><br><p>  Misalnya, memetakan kunci string ke jenis URL: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dict = [ <span class="hljs-string"><span class="hljs-string">"site"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://www.site.ru/path/to/web/site/page"</span></span>, <span class="hljs-string"><span class="hljs-string">"other site"</span></span>: <span class="hljs-string"><span class="hljs-string">"invalid url"</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mappedDict: [<span class="hljs-type"><span class="hljs-type">String</span></span>: <span class="hljs-type"><span class="hljs-type">URL</span></span>] = dict.compactMapValues { <span class="hljs-type"><span class="hljs-type">URL</span></span>(string: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(mappedDict) <span class="hljs-comment"><span class="hljs-comment">// ["site": https://www.site.ru/path/to/web/site/page]</span></span></code> </pre> <br><p>  Pasangan kunci / nilai kedua dihapus setelah pemetaan, karena string bukan URL yang valid. </p><br><h1 id="izmenenie-povedeniya-try">  Coba ubah perilaku? </h1><br><p>  Di Swift 4.2 menggunakan coba coba?  Anda dapat dengan mudah mendapatkan jenis opsional dengan beberapa tingkat bersarang.  Dalam kebanyakan kasus, ini bukan yang diharapkan pengembang.  Untuk alasan ini, di Swift 5 coba?  mendapat perilaku yang mirip dengan c chaining opsional.  Artinya, dengan kombinasi try?  dengan rantai opsional atau casting opsional, hasil dari ekspresi akan menjadi opsional dengan satu tingkat sarang. </p><br><p>  Coba contohnya?  bersama dengan? </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Swift 4.2 let jsonDict = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] //  jsonDict - [String: Any]?? // Swift 5 let jsonDict = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] //  jsonDict - [String: Any]?</span></span></code> </pre> <br><p>  Coba contohnya?  bersama dengan metode objek opsional: </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Swift 4.2 let article = try? storage?.getArticle() //  article - Article?? //  if let first = article, let second = first { first //  Article? second //  Article } //   if case let value?? = article { value //  Article } // Swift 5 let article = try? storage?.getArticle() //  article - Article? //  if let value = article { value //  Article }</span></span></code> </pre> <br><p>  Anda dapat membaca lebih lanjut <a href="">dalam kalimat ini</a> . </p><br><h1 id="atribut-dynamiccallable">  Atribut @DynamicCallable </h1><br><p>  Atribut @dynamicCallable yang baru memungkinkan Anda untuk menandai tipe sebagai "callable".  Ini berarti bahwa kita dapat memanggil tipe itu sebagai metode normal. <br>  Jika kita menandai tipe sebagai @dynamicCallable, maka kita harus mengimplementasikan satu (atau keduanya) metode: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dynamicallyCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withArguments: &lt;#Arguments#&gt;)</span></span></span></span> -&gt; &lt;#<span class="hljs-type"><span class="hljs-type">R1</span></span>#&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dynamicallyCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withKeywordArguments: &lt;#KeywordArguments#&gt;)</span></span></span></span> -&gt; &lt;#<span class="hljs-type"><span class="hljs-type">R2</span></span>#&gt;</code> </pre> <br><p>  Tipe argumen harus mendukung protokol ExpressibleByArrayLiteral, tipe KeywordArguments harus mendukung protokol ExpressibleByDictionaryLiteral, dan R1 dan R2 dapat berupa tipe apa pun. </p><br><p>  Misalnya, struktur Sum.  Ketika Anda memanggilnya, Anda dapat mentransfer sejumlah nomor dan mendapatkan jumlah mereka: </p><br><pre> <code class="swift hljs">@dynamicCallable <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sum</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dynamicallyCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withArguments args: [Int])</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, +) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-type"><span class="hljs-type">Sum</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = sum(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) <span class="hljs-comment"><span class="hljs-comment">// 10</span></span></code> </pre> <br><p>  Bahkan, kompiler mengubah jumlah (1, 2, 3, 4) menjadi panggilan ke jumlah. Secara sinonim Panggilan (dengan Dokumen: [1, 2, 3, 4]).  Demikian pula untuk metode dynamicallyCall (withKeywordArguments :). </p><br><p>  Fitur ini memungkinkan Anda untuk menambahkan interaksi kode Swift dengan berbagai bahasa pemrograman dinamis, misalnya, Python atau JavaScript. </p><br><p>  Anda dapat membaca lebih lanjut <a href="">dalam kalimat ini</a> . </p><br><h1 id="podderzhka-operatora-menshe-v-direktivah-proverki-versii-kompilyatora-i-yazyka">  Kurangnya dukungan operator dalam versi compiler dan arahan pemeriksaan bahasa </h1><br><p>  Dimulai dengan versi 5 dari Swift, Anda dapat menggunakan operator “less” ketika memeriksa versi kompiler dalam kode: </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Swift 4.2 #if !swift(&gt;=5) //        4.2   #endif // Swift 5 #if swift(&lt;5) //        4.2   #endif</span></span></code> </pre> <br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Ini tidak semua fitur dan peningkatan yang muncul di Swift 5. Secara total, 28 proposal dari komunitas diterima, yang juga termasuk meningkatkan kinerja lini, meningkatkan Manajer Paket Swift, dan perpustakaan standar.  Daftar lengkap perubahan dan peningkatan dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di catatan rilis</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444862/">https://habr.com/ru/post/id444862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444850/index.html">Mekanika Kuantum: Akhir Perang Interpretasi</a></li>
<li><a href="../id444852/index.html">Smart Home - Memikirkan Kembali</a></li>
<li><a href="../id444854/index.html">Membuat Elemen Antarmuka Secara Programatis Menggunakan PureLayout (Bagian 1)</a></li>
<li><a href="../id444858/index.html">Mencari obat terbaik</a></li>
<li><a href="../id444860/index.html">OFFZONE 2.0</a></li>
<li><a href="../id444864/index.html">Mesin tik USB</a></li>
<li><a href="../id444866/index.html">Cara saya dari Python ke Go - berbagi kiat dan sumber daya</a></li>
<li><a href="../id444868/index.html">Cara membuat palet yang nyaman untuk semua orang</a></li>
<li><a href="../id444870/index.html">Struktur bisnis perusahaan 2019</a></li>
<li><a href="../id444872/index.html">Bagaimana pembukaan Zabbix di Rusia?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>