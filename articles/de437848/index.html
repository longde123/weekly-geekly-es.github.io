<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèª üóíÔ∏è üòø Wir machen den Prozess der Entwicklung schwerer Software f√ºr Mikrocontroller bequemer (nein) üóëÔ∏è ‚õèÔ∏è üöµüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jetzt kann niemand mehr von Mikrocontrollern mit einem nichtfl√ºchtigen (meistens Flash) Speicher von 512 Kilobyte oder mehr √ºberrascht werden. Ihre Ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir machen den Prozess der Entwicklung schwerer Software f√ºr Mikrocontroller bequemer (nein)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437848/"> Jetzt kann niemand mehr von Mikrocontrollern mit einem nichtfl√ºchtigen (meistens Flash) Speicher von 512 Kilobyte oder mehr √ºberrascht werden.  Ihre Kosten sinken allm√§hlich und die Zug√§nglichkeit nimmt im Gegenteil zu.  Das Vorhandensein eines solchen Volumens an nichtfl√ºchtigem Speicher erm√∂glicht es, Anwendungen zu schreiben, die im Hinblick auf den belegten Speicher "schwer" sind, und gleichzeitig die anschlie√üende Codepflege durch die Verwendung vorgefertigter L√∂sungen aus verschiedenen Standardbibliotheken zu erleichtern.  Dies f√ºhrt jedoch zu einer Erh√∂hung des Volumens der Firmware-Datei des Zielger√§ts, die jedes Mal bei der geringsten √Ñnderung des Codes vollst√§ndig in den nichtfl√ºchtigen Speicher des Mikrocontrollers neu geladen werden muss. <br><br>  Der Zweck des Artikels besteht darin, √ºber die Methode zum Erstellen eines Projekts in C und / oder C ++ zu sprechen, bei der im Falle einer √Ñnderung des am h√§ufigsten debuggten Codeabschnitts der gr√∂√üte Teil des Projekts nicht neu geschrieben werden musste.  Und zeigen Sie auch, warum diese Methode nicht immer eine effektive L√∂sung ist. <br><a name="habracut"></a><br><h2>  Leseranforderungen </h2><br>  Im Verlauf der Erz√§hlung gehe ich davon aus, dass der Leser: <br><br><ul><li>  Er spricht flie√üend C und C ++; </li><li>  Erfahrung in der Arbeit mit Mikrocontrollern auf Basis von Cortex-M3 / Cortex-M4-Kernen (z. B. der Serie stm32f4); </li><li>  wei√ü, wie man die endg√ºltige N√§hdatei (elf / bin) aus den Projektquellen erstellt; </li><li>  Stellen Sie sich vor, wof√ºr Linker-Skriptdateien gedacht sind. </li><li>  hat eine Vorstellung von Text, BSS, Daten und anderen Abschnitten; </li><li>  arbeitete mit einer der Linux-Distributionen; </li><li>  besitzt minimal Bash; </li><li>  hat Erfahrung mit gcc f√ºr die Architektur der Cortex-M3 / Cortex-M4-Prozessoren (Toolchain arm-none-eabi); </li><li>  hat anf√§ngliche F√§higkeiten mit cmake. </li></ul><br><h2>  Die Essenz der Methode </h2><br>  In einem ‚Äûklassischen‚Äú Projekt f√ºr Mikrocontroller befinden sich alle unver√§nderlichen Daten (Text, Rodata-Abschnitte, Anfangsdatenwerte usw.) normalerweise ‚Äûin einer Reihe‚Äú, beginnend mit der Startadresse des nichtfl√ºchtigen Speichers (im Fall eines Mikrocontrollers auf Basis des Cortex-M3 / Cortex-M4-Kerns - c Adresse 0x08000000).  In vereinfachter Form sieht die nichtfl√ºchtige Speichernutzungskarte eines Mikrocontroller-Programms, das auf dem Cortex-M3 / Cortex-M4-Kern basiert und mit C ++ geschrieben wurde, ungef√§hr so ‚Äã‚Äãaus: <br><br><img src="https://habrastorage.org/webt/hl/dw/jx/hldwjx8d-f6k7ogodnjthokeefc.png"><br><br>  Die mem.ld-Datei f√ºr ein solches Projekt sieht meistens ungef√§hr so ‚Äã‚Äãaus: <br><br><pre><code class="bash hljs">MEMORY { FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 768K RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 112K }</code> </pre> <br>  Hier ist der gesamte nichtfl√ºchtige Speicher eine einzelne Partition mit dem Namen "FLASH", und der gesamte RAM ist eine Partition mit dem Namen "RAM".  In dieser Form beginnt sich der Rest zu verschieben, wenn sich einer der Codeabschnitte √§ndert.  Um dies zu vermeiden, k√∂nnen Sie die Firmware-Datei in einige logische Bl√∂cke aufteilen.  Zum Beispiel wie folgt: <br><br><ul><li>  Tabelle der Interruptvektoren; </li><li>  eigene Bibliotheken; </li><li>  Bibliotheken von Drittanbietern (deren √Ñnderung nicht geplant ist); </li><li>  h√§ufig √§nderbarer Code. </li></ul><br>  In diesem Fall beim √Ñndern eines Codeabschnitts in der endg√ºltigen Bin-Datei nur der Abschnitt, in dem sich der Code ge√§ndert hat, und der Abschnitt, der irgendwie damit verbunden war (z. B. die Tabelle der Interrupt-Vektoren, wenn die Position des Handlers in einigen aus Abschnitten). <br><br>  Im Wesentlichen werden dem Projekt <b>statische Bibliotheken</b> hinzugef√ºgt. <br><br>  Nach dem Empfang des Fachs der Projektdatei kann diese in Abschnitte unterteilt werden und jeden Abschnitt einzeln flashen.  Somit werden nur ge√§nderte Bereiche zusammengef√ºgt.  Dies f√ºhrt auch dazu, dass vor dem Debuggen keine Firmware erforderlich ist, da davon ausgegangen wird, dass der Mikrocontroller sofort √ºber die neueste Firmware im Mikrocontroller verf√ºgt und Sie sofort mit dem Debuggen beginnen k√∂nnen. <br><br>  Als n√§chstes werde ich detailliert beschreiben, wie dies in einem realen Projekt implementiert werden kann.  Die Vor- und Nachteile einer solchen Entscheidung werden am Ende des Artikels angegeben. <br><br><h2>  Feld f√ºr Experimente </h2><br>  Bevor ich irgendeine Art von Innovation bei der Arbeit vorschlage, versuche ich dies bei meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heimprojekt</a> .  Da seine Gr√∂√üe in etwa der Gr√∂√üe von Routineprojekten bei der Arbeit entspricht, ist es m√∂glich zu verstehen, ob die Innovation rentabel ist oder nicht und welche Nuancen sie tr√§gt. <br><br><h2>  Projektbeschreibung </h2><br>  Das Projekt enth√§lt: <br><br><ul><li>  den Code des Hauptprojekts in C ++ 14 unter Verwendung virtueller Tabellen, new / delete (durch eine Reihe von FreeRTOS), shared_ptr (und andere intelligente Zeiger) und andere Freuden von Standard-C ++ 14-Bibliotheken; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FreeRTOS</a> verwendet ungef√§hr 6 Aufgaben zur Wartung der Hardware-Peripherie-Infrastruktur und ungef√§hr 10 f√ºr die Gesch√§ftslogik ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MakiseGUI-</a> Grafikbibliothek, Klickverarbeitung, Arbeiten mit Fett ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FatFS</a> ) usw.); </li><li>  16 Repositorys mit eigenen Bibliotheken f√ºr die Interaktion mit Hardware-Peripherieger√§ten auf der Karte, Stubs f√ºr Systemaufrufe und mehr; </li></ul><br>  Mit den Assembly-Parametern -O0 -g3 ben√∂tigt der Code in einer vollwertigen Implementierung mit Unterst√ºtzung f√ºr Unicode, Cyrillic und andere Dinge ungef√§hr 700 KB.  In der aktuellen Phase, in der die Hardware-Peripherieger√§te stabil sind und nur die Gesch√§ftslogik debuggt werden muss, betr√§gt die zu √§ndernde Codemenge ungef√§hr 20 KB.  Aus diesem Grund scheint der derzeitige Ansatz auf den ersten Blick eine ideale L√∂sung f√ºr das Problem zu sein (die Option mit Simulation auf einem Computer wird aus irgendeinem Grund nicht in Betracht gezogen). <br><br><h2>  Aktionsliste </h2><br>  Um die beschriebene Methode zu implementieren, ben√∂tigen Sie: <br><br><ul><li>  Assemblieren Sie alle Submodule als statische Bibliotheken (die Beschreibung dieses Elements ist nicht in der Liste der analysierten Elemente dieses Artikels enthalten). </li><li>  schreibe mem.ld um; </li><li>  rewrite section.ld; </li><li>  F√ºgen Sie dem Hauptprojekt ein Dienstprogramm hinzu, um Abschnitte aus der endg√ºltigen Bin-Datei zu extrahieren. </li><li>  F√ºgen Sie dem Projekt einen Aufruf des Skripts hinzu, um den nichtfl√ºchtigen Speicher des Mikrocontrollers beim Aktualisieren der Firmware-Datei zu aktualisieren. </li></ul><br><h2>  Mem.ld umschreiben </h2><br>  Der erste Schritt besteht darin, das ‚ÄûStandard‚Äú -Mem.ld f√ºr das aktuelle Konzept zu verfeinern.  Beim Finalisieren sollte ber√ºcksichtigt werden, dass nichtfl√ºchtiger Speicher von Sektoren bereinigt wird.  Weitere Informationen zur Strukturierung von Sektoren in einem bestimmten Mikrocontroller finden Sie in der Dokumentation (im Fall von stm32-Mikrocontrollern - im Referenzhandbuch).  Jeder Abschnitt kann mindestens einen Sektor belegen (mehr k√∂nnen sein), andernfalls √ºberschreibt ein Abschnitt den anderen. <br><br>  Es sollte auch ber√ºcksichtigt werden, dass Sie f√ºr diese Bibliothek in der Verkn√ºpfungsphase einen Platz im RAM reservieren m√ºssen, wenn eine Bibliothek globale Variablen verwendet.  Andernfalls k√∂nnen unangenehme Fehler auftreten, die √§u√üerst schwer zu erkennen sind.  Der Code der FatFS-Bibliothek befindet sich beispielsweise im Abschnitt ROM_EXTERNAL_LIBRARIES, erfordert jedoch in der Erstellungsphase 4 Byte RAM.  Sie m√ºssen also sicherstellen, dass im RAM ein Abschnitt f√ºr die Felder vorhanden ist, die der Code von ROM_EXTERNAL_LIBRARIES verwenden wird.  In diesem Beispiel ist es RAM_EXTERNAL_LIBRARIES. <br><br>  Der letzte Abschnitt im nichtfl√ºchtigen Speicher verdient besondere Aufmerksamkeit.  Alles, was laut section.ld (sp√§ter) nicht in die entsprechenden Abschnitte zerlegt wurde, wird darauf eingehen. <br><br><div class="spoiler">  <b class="spoiler_title">Im Kontext des aktuellen Projekts sieht mem.ld folgenderma√üen aus.</b> <div class="spoiler_text"><pre> <code class="bash hljs">/*    stm32f405rgt6   ChiptunePlayer-2.22-MainBoard-v2-Firmware. */ MEMORY { /*-----------------------------FLASH-------------------------------*/ /*  0-1  . */ ROM_BOOTLOADER (RX) : ORIGIN = 0x08000000, LENGTH = 32K /*  2     . */ ROM_SYSCFG_PAGE_1 (R) : ORIGIN = 0x08008000, LENGTH = 16K /*  3      . */ ROM_SYSCFG_PAGE_2 (R) : ORIGIN = 0x0800C000, LENGTH = 16K /*  4 . */ ROM_RESERVE (R) : ORIGIN = 0x08010000, LENGTH = 16K /*  5, 6, 7      (FATFS, FREERTOS...). */ ROM_EXTERNAL_LIBRARIES (RX) : ORIGIN = 0x08020000, LENGTH = 384K /*  8, 9      ( ,  ...). */ ROM_USER_LIBRARIES (RX) : ORIGIN = 0x08080000, LENGTH = 384K /*  5, 6      . */ ROM_MAIN_PROGRAMM (RX) : ORIGIN = 0x080E0000, LENGTH = 128K /*-----------------------------RAM---------------------------------*/ /*      RAM    . */ RAM_PAGE_1 (RW) : ORIGIN = 0x20000000, LENGTH = 112K RAM_PAGE_2 (RW) : ORIGIN = 0x2001C000, LENGTH = 16K /*           FATFS  FreeRTOS. */ RAM_EXTERNAL_LIBRARIES (RW) : ORIGIN = 0x20000000, LENGTH = 10K /*        . */ RAM_USER_LIBRARIES (RW) : ORIGIN = 0x20002800, LENGTH = 90K /*    RAM    . */ RAM_MAIN_PROGRAMM (RW) : ORIGIN = 0x20019000, LENGTH = 27K /*   RAM    .    FreeRTOS. */ RAM_MAIN_PROGRAMM_STACK (RW) : ORIGIN = 0x2001FC00, LENGTH = 1K }</code> </pre> </div></div><br><h2>  Rewrite section.ld </h2><br>  Nachdem die vorhandene Speicherkarte in Abschnitte unterteilt wurde, sollte beschrieben werden, welche Partition platziert wird.  Geben Sie f√ºr jede Bibliothek (wenn es einen entsprechenden Abschnitt in der Bibliothek gibt) an, wo sich die Abschnitte .text, .rodata, .data, .bss und andere befinden.  Die Liste der in der Bibliothek verf√ºgbaren Abschnitte kann mit objdump angezeigt werden.  F√ºr die Bibliothek libstdc ++ _ nano.a m√ºssen Sie beispielsweise angeben, wo der Text, ARM.attributes, rodata, data, bss, COMMON-Abschnitte platziert werden sollen. <br><br><div class="spoiler">  <b class="spoiler_title">Im Kontext des aktuellen Projekts sieht section.ld folgenderma√üen aus.</b> <div class="spoiler_text"><pre> <code class="bash hljs">/*             RAM. */ __estack = ORIGIN(RAM_MAIN_PROGRAMM_STACK) + LENGTH(RAM_MAIN_PROGRAMM_STACK); /*   . */ __stack_size = LENGTH(RAM_MAIN_PROGRAMM_STACK); /*     Reset_Handler. */ ENTRY(Reset_Handler) /*  . */ SECTIONS { /*---------------------ROM  ------------------------*/ .section_bootloader : ALIGN(4) { /*     .             .          .o ,     .*/ . = ALIGN(4); KEEP(*(.user_code_isr_vector .user_code_isr_vector*)) . = ALIGN(4); } &gt;ROM_BOOTLOADER /*----------------ROM    -----------------*/ /* . */ .section_external_libraries_text : ALIGN(4) { /*  . */ . = ALIGN(4); *libstdc++_nano.a:*(.text .text*); . = ALIGN(4); *libgcc.a:*(.text .text*); . = ALIGN(4); *libg_nano.a:*(.text .text*); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.text .text*); . = ALIGN(4); *libFATFS.a:*(.text .text*); . = ALIGN(4); *libFREERTOS.a:*(.text .text*); . = ALIGN(4); *libMAKISE_GUI.a:*(.text .text*); . = ALIGN(4); } &gt;ROM_EXTERNAL_LIBRARIES /* ,   */ .section_external_libraries_required_by_the_compiler : ALIGN(4) { /*  . */ . = ALIGN(4); *libgcc.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libstdc++_nano.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libg_nano.a:*(.ARM.attributes .ARM.attributes*); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libFATFS.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libFREERTOS.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMAKISE_GUI.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); } &gt;ROM_EXTERNAL_LIBRARIES /*    . */ .section_external_libraries_rodata : ALIGN(4) { /*  . */ . = ALIGN(4); *libgcc.a:*(.rodata .rodata*); . = ALIGN(4); *libstdc++_nano.a:*(.rodata .rodata*); . = ALIGN(4); *libg_nano.a:*(.rodata .rodata*); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.rodata .rodata*); . = ALIGN(4); *libFATFS.a:*(.rodata .rodata*); . = ALIGN(4); *libFREERTOS.a:*(.rodata .rodata*); . = ALIGN(4); *libMAKISE_GUI.a:*(.rodata .rodata*); . = ALIGN(4); } &gt;ROM_EXTERNAL_LIBRARIES /*----------------------- ---------------------*/ /* . */ .section_user_libraries_text : ALIGN(4) { . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.text .text*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.text .text*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.text .text*); . = ALIGN(4); *libMC_HARDWARE.a:*(.text .text*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.text .text*); . = ALIGN(4); *libUSER_STARTUP.a:*(.text .text*); . = ALIGN(4); *libBUTTONS.a:*(.text .text*); . = ALIGN(4); *libCHIPTUNE.a:*(.text .text*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.text .text*); . = ALIGN(4); *libLCD_DRIVER.a:*(.text .text*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.text .text*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.text .text*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.text .text*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.text .text*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.text .text*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.text .text*); . = ALIGN(4); } &gt;ROM_USER_LIBRARIES /* ,   */ .section_user_libraries_required_by_the_compiler : ALIGN(4) { . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMC_HARDWARE.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libUSER_STARTUP.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libUSER_CODE.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libBUTTONS.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libCHIPTUNE.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libLCD_DRIVER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); } &gt;ROM_EXTERNAL_LIBRARIES /*    . */ .section_user_libraries_rodata : ALIGN(4) { . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.rodata .rodata*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.rodata .rodata*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.rodata .rodata*); . = ALIGN(4); *libMC_HARDWARE.a:*(.rodata .rodata*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.rodata .rodata*); . = ALIGN(4); *libUSER_STARTUP.a:*(.rodata .rodata*); . = ALIGN(4); *libBUTTONS.a:*(.rodata .rodata*); . = ALIGN(4); *libCHIPTUNE.a:*(.rodata .rodata*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.rodata .rodata*); . = ALIGN(4); *libLCD_DRIVER.a:*(.rodata .rodata*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.rodata .rodata*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.rodata .rodata*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.rodata .rodata*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.rodata .rodata*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.rodata .rodata*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.rodata .rodata*); . = ALIGN(4); } &gt;ROM_USER_LIBRARIES /*------------------------- ------------------------*/ /* . */ .section_user_code_text : ALIGN(4) { . = ALIGN(4); *(.text .text.*) . = ALIGN(4); } &gt;ROM_MAIN_PROGRAMM /* ,   */ .sections_user_code_required_by_the_compiler : ALIGN(4) { . = ALIGN(4); *(.glue_7 .glue_7*) /*  -  ARMv7 */ . = ALIGN(4); *(.glue_7t .glue_7t*) . = ALIGN(4); *(.vfp11_veneer .vfp11_veneer*) /*   . */ . = ALIGN(4); *(.v4_bx .v4_bx*) . = ALIGN(4); *(.iplt .iplt*) . = ALIGN(4); *(.rel.dyn .rel.dyn*) . = ALIGN(4); KEEP(*(.eh_frame .eh_frame*)) /*     CPP. */ . = ALIGN(4); *(.eh_framehdr .eh_framehdr*) . = ALIGN(4); *(.ARM.attributes .ARM.attributes.*) /*    ,  . */ . = ALIGN(4); *(vtable) /* C++ virtual tables */ PROVIDE_HIDDEN (__preinit_array_start = .); /*  ,   . */ . = ALIGN(4); KEEP(*(.preinit_array_sysinit .preinit_array_sysinit*)) . = ALIGN(4); KEEP(*(.preinit_array_platform .preinit_array_platform.*)) . = ALIGN(4); KEEP(*(.preinit_array .preinit_array.*)) PROVIDE_HIDDEN (__preinit_array_end = .); PROVIDE_HIDDEN (__init_array_start = .); /*    . */ . = ALIGN(4); KEEP(*(SORT(.init_array.*))) . = ALIGN(4); KEEP(*(.init_array)) . = ALIGN(4); PROVIDE_HIDDEN (__init_array_end = .); PROVIDE_HIDDEN (__fini_array_start = .); /*    . */ . = ALIGN(4); KEEP(*(SORT(.fini_array.*))) . = ALIGN(4); KEEP(*(.fini_array)) . = ALIGN(4); PROVIDE_HIDDEN (__fini_array_end = .); . = ALIGN(4); KEEP(*(.cfmconfig)) . = ALIGN(4); *(.after_vectors .after_vectors.*) . = ALIGN(4); } &gt;ROM_MAIN_PROGRAMM /*    . */ .section_user_code_rodata : ALIGN(4) { . = ALIGN(4); *(.rodata .rodata.*) . = ALIGN(4); } &gt;ROM_MAIN_PROGRAMM /*  stack trace. */ .ARM.exidx : { . = ALIGN(4); *(.ARM.extab* .gnu.linkonce.armextab.*) . = ALIGN(4); *(.ARM.exidx* .gnu.linkonce.armexidx.*) . = ALIGN(4); } &gt; ROM_MAIN_PROGRAMM /*-------------------------------RAM-----------------------------*/ /*    . */ .section_external_libraries_data : ALIGN(4) { . = ALIGN(4); __external_lib_data_start = . ; /*  . */ . = ALIGN(4); *libgcc.a:*(.data .data*); . = ALIGN(4); *libstdc++_nano.a:*(.data .data*); . = ALIGN(4); *libg_nano.a:*(.data .data*); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.data .data*); . = ALIGN(4); *libFATFS.a:*(.data .data*); . = ALIGN(4); *libFREERTOS.a:*(.data .data*); . = ALIGN(4); *libMAKISE_GUI.a:*(.data .data*); . = ALIGN(4); __external_lib_data_end = . ; } &gt;RAM_EXTERNAL_LIBRARIES AT&gt; ROM_EXTERNAL_LIBRARIES /*       RAM */ .section_external_libraries_bss : ALIGN(4) { . = ALIGN(4); __external_lib_bss_start = .; /*  . */ . = ALIGN(4); *libgcc.a:*(.bss .bss*); . = ALIGN(4); *libstdc++_nano.a:*(.bss .bss*); . = ALIGN(4); *libg_nano.a:*(*COMMON); . = ALIGN(4); *libgcc.a:*(*COMMON); . = ALIGN(4); *libstdc++_nano.a:*(*COMMON); . = ALIGN(4); *libg_nano.a:*(*COMMON); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.bss .bss*); . = ALIGN(4); *libFATFS.a:*(.bss .bss*); . = ALIGN(4); *libFREERTOS.a:*(.bss .bss*); . = ALIGN(4); *libMAKISE_GUI.a:*(.bss .bss*); . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(*COMMON); . = ALIGN(4); *libFATFS.a:*(*COMMON); . = ALIGN(4); *libFREERTOS.a:*(*COMMON); . = ALIGN(4); *libMAKISE_GUI.a:*(*COMMON); . = ALIGN(4); __external_lib_bss_end = .; } &gt;RAM_EXTERNAL_LIBRARIES /*    . */ .section_user_libraries_data : ALIGN(4) { . = ALIGN(4); __user_lib_data_start = . ; . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.data .data*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.data .data*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.data .data*); . = ALIGN(4); *libMC_HARDWARE.a:*(.data .data*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.data .data*); . = ALIGN(4); *libUSER_STARTUP.a:*(.data .data*); . = ALIGN(4); *libBUTTONS.a:*(.data .data*); . = ALIGN(4); *libCHIPTUNE.a:*(.data .data*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.data .data*); . = ALIGN(4); *libLCD_DRIVER.a:*(.data .data*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.data .data*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.data .data*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.data .data*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.data .data*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.data .data*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.data .data*); . = ALIGN(4); __user_lib_data_end = . ; } &gt;RAM_USER_LIBRARIES AT&gt; ROM_USER_LIBRARIES .section_user_libraries_bss : ALIGN(4) { . = ALIGN(4); __user_lib_bss_start = .; . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.bss .bss*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.bss .bss*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.bss .bss*); . = ALIGN(4); *libMC_HARDWARE.a:*(.bss .bss*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.bss .bss*); . = ALIGN(4); *libUSER_CODE.a:*(.bss .bss*); . = ALIGN(4); *libBUTTONS.a:*(.bss .bss*); . = ALIGN(4); *libCHIPTUNE.a:*(.bss .bss*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.bss .bss*); . = ALIGN(4); *libLCD_DRIVER.a:*(.bss .bss*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.bss .bss*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.bss .bss*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.bss .bss*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.bss .bss*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.bss .bss*); . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.bss .bss*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.bss .bss*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(*COMMON); . = ALIGN(4); *libMC_INTERRUPT.a:*(*COMMON); . = ALIGN(4); *libMC_HARDWARE.a:*(*COMMON); . = ALIGN(4); *libPCB_HARDWARE.a:*(*COMMON); . = ALIGN(4); *libUSER_CODE.a:*(*COMMON); . = ALIGN(4); *libBUTTONS.a:*(*COMMON); . = ALIGN(4); *libCHIPTUNE.a:*(*COMMON); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(*COMMON); . = ALIGN(4); *libLCD_DRIVER.a:*(*COMMON); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(*COMMON); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(*COMMON); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(*COMMON); . = ALIGN(4); *libSHIFT_REGISTER.a:*(*COMMON); . = ALIGN(4); *libWAVE_GENERATORS.a:*(*COMMON); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.COMMON*); . = ALIGN(4); __user_lib_bss_end = .; } &gt;RAM_USER_LIBRARIES /*    . */ .section_user_code_data : ALIGN(4) { . = ALIGN(4); __user_code_data_start = . ; . = ALIGN(4); *(.data .data.*) . = ALIGN(4); __user_code_data_end = . ; } &gt;RAM_MAIN_PROGRAMM AT&gt; ROM_MAIN_PROGRAMM .section_user_code_bss : ALIGN(4) { . = ALIGN(4); __bss_start__ = .; __user_code_bss_start = .; *(.bss .bss.*) *(COMMON) . = ALIGN(4); __bss_end__ = .; __user_code_bss_end = .; } &gt;RAM_MAIN_PROGRAMM __external_lib_data_in_rom_start = LOADADDR(.section_external_libraries_data); __user_lib_data_in_rom_start = LOADADDR(.section_user_libraries_data); __user_code_data_in_rom_start = LOADADDR(.section_user_code_data); /*------------------------- -----------------*/ /* Stabs debugging sections. */ .stab 0 : { *(.stab) } .stabstr 0 : { *(.stabstr) } .stab.excl 0 : { *(.stab.excl) } .stab.exclstr 0 : { *(.stab.exclstr) } .stab.index 0 : { *(.stab.index) } .stab.indexstr 0 : { *(.stab.indexstr) } .comment 0 : { *(.comment) } /* * DWARF debug sections. * Symbols <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the DWARF debugging sections are relative to the beginning * of the section so we begin them at 0. */ /* DWARF 1 */ .debug 0 : { *(.debug) } .line 0 : { *(.line) } /* GNU DWARF 1 extensions */ .debug_srcinfo 0 : { *(.debug_srcinfo) } .debug_sfnames 0 : { *(.debug_sfnames) } /* DWARF 1.1 and DWARF 2 */ .debug_aranges 0 : { *(.debug_aranges) } .debug_pubnames 0 : { *(.debug_pubnames) } /* DWARF 2 */ .debug_info 0 : { *(.debug_info .gnu.linkonce.wi.*) } .debug_abbrev 0 : { *(.debug_abbrev) } .debug_line 0 : { *(.debug_line) } .debug_frame 0 : { *(.debug_frame) } .debug_str 0 : { *(.debug_str) } .debug_loc 0 : { *(.debug_loc) } .debug_macinfo 0 : { *(.debug_macinfo) } /* SGI/MIPS DWARF 2 extensions */ .debug_weaknames 0 : { *(.debug_weaknames) } .debug_funcnames 0 : { *(.debug_funcnames) } .debug_typenames 0 : { *(.debug_typenames) } .debug_varnames 0 : { *(.debug_varnames) } .debug_macro 0 : { *(.debug_macro) } .debug_ranges 0 : { *(.debug_ranges) } }</code> </pre> </div></div><br><h2>  F√ºgen Sie dem Hauptprojekt ein Dienstprogramm hinzu, um Abschnitte aus der endg√ºltigen Bin-Datei zu extrahieren </h2><br>  Leider war es weder in objcopy noch in objdump m√∂glich, Flags zum Extrahieren von Code zwischen bestimmten Adressen aus der Elf-Datei zu finden.  Es gibt ein Flag <b>--only-section</b> , das jedoch nicht die Tatsache ber√ºcksichtigt, dass Debugging-Informationen nach allen Entit√§ten des in section.ld aufgelisteten Abschnitts immer noch im nichtfl√ºchtigen Speicher abgelegt werden.  Ohne sie funktioniert die endg√ºltige Firmware, die aus Teilen zusammengesetzt ist, nicht (aus offensichtlichen Gr√ºnden).  Daher musste ich ein einfaches <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstprogramm</a> schreiben, das eine gemeinsame Bin-Datei verwendet und den erforderlichen Abschnitt in eine separate Datei f√ºr den angegebenen Adressbereich extrahiert.  Hier ergibt sich jedoch die folgende Nuance.  Standardm√§√üig f√ºllt objcopy den Raum zwischen Abschnitten mit 0s.  Der leere Speicherplatz im Flash-Speicher ist jedoch 0xFF.  Um dieses Problem zu l√∂sen, m√ºssen Sie die Ausgabe-Bin-Datei mit dem Flag <b>--gap-fill = 0xff erstellen</b> . <br><br><h2>  F√ºgen Sie dem Projekt einen Aufruf des Skripts zum Aktualisieren des nichtfl√ºchtigen Speichers des Mikrocontrollers beim Aktualisieren der Firmware-Datei hinzu </h2><br>  Um √Ñnderungen im Projekt zu verfolgen, m√ºssen Sie nach jeder Neuerstellung der Elf-Datei ein Validierungsskript aufrufen, das die endg√ºltige Bin-Datei aus der Elf-Datei extrahiert, den gew√ºnschten Abschnitt daraus vergleicht, ihn mit dem zuvor extrahierten vergleicht und bei Abweichungen den Abschnitt im Speicher des Mikrocontrollers aktualisiert. <br><br><div class="spoiler">  <b class="spoiler_title">Vergleichsskriptcode</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # # $1 -  .   ,    . # $2 -     elf . # $3 -      STM32. # echo "Old file name: $1" echo "New file name: $2" # ,     . flag_rewrite=0 #    ,         #  ,      (   #     ). #    ,   ,   -    #  ,     .  ,   . if [ -e $1 ] then #         . echo "Both files exist." #  md5   ,     . buf=$(md5sum $1 --binary) md5_old=${buf:0:32} #      md5   . #   32 . buf=$(md5sum $2 --binary) md5_new=${buf:0:32} echo "Started file comparison." if [ $md5_old == $md5_new ] then #     ,  . echo "The file has not been updated." echo "The new file will be deleted." rm $2 echo "Removed." else #   ,    . echo "The file has been modified." echo "Old will be replaced by new." mv $2 $1 echo "Replaced." flag_rewrite=1 #    . fi else #    . echo "Old file does not exist." echo "New will be renamed to old." mv $2 $1 #    . flag_rewrite=1 #    . echo "Renamed." fi #       ,     . if [ $flag_rewrite -eq 1 ] then echo "Started flashing." echo "CMD params: $3" $3 fi</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Im Projekt selbst k√∂nnen Sie die cmake-Funktion aufrufen, die alles Notwendige erledigt: </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cmake Update-Funktion</font></font></b> <div class="spoiler_text"><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(write_sector SECTOR ADDR_BASE ADDR_START ADDR_END) <span class="hljs-keyword"><span class="hljs-keyword">add_custom_command</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> <span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>.elf POST_BUILD <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${ARM_OBJCOPY}</span></span> --output-<span class="hljs-keyword"><span class="hljs-keyword">target</span></span>=binary --gap-fill=<span class="hljs-number"><span class="hljs-number">0</span></span>xff <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>.elf <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_all.bin COMMENT <span class="hljs-string"><span class="hljs-string">"Creating a binary file of the &lt;&lt;${SECTOR}&gt;&gt; sector"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${BIN_EXTRACTOR}</span></span> -p <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_all.bin -o <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_section_<span class="hljs-variable"><span class="hljs-variable">${SECTOR}</span></span>_new.bin -b <span class="hljs-variable"><span class="hljs-variable">${ADDR_BASE}</span></span> -s <span class="hljs-variable"><span class="hljs-variable">${ADDR_START}</span></span> -e <span class="hljs-variable"><span class="hljs-variable">${ADDR_END}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> cd <span class="hljs-variable"><span class="hljs-variable">${CMAKE_SOURCE_DIR}</span></span> &amp;&amp; ./cmp.sh <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_section_<span class="hljs-variable"><span class="hljs-variable">${SECTOR}</span></span>.bin <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_section_<span class="hljs-variable"><span class="hljs-variable">${SECTOR}</span></span>_new.bin <span class="hljs-string"><span class="hljs-string">"${STM32PROG} -c port=${STM32PROG_PORT} freq=${STM32PROG_FREQ} -w ${PROJECT_BINARY_DIR}/${PROJECT_NAME}_section_${SECTOR}.bin ${ADDR_START}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endfunction</span></span>(write_sector)</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Funktion verwendet stm32programmer zum Schreiben. </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel f√ºr die Verwendung einer Funktion aus dem Projektcode</font></font></b> <div class="spoiler_text"><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (STM32PROG_USE <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"ON"</span></span>) write_sector(<span class="hljs-string"><span class="hljs-string">"bootloader"</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_SYSCFG_PAGE_1_ADDRESS}</span></span>) write_sector(<span class="hljs-string"><span class="hljs-string">"external_libraries"</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_EXTERNAL_LIB_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_USER_LIBRARIES_ADDRESS}</span></span>) write_sector(<span class="hljs-string"><span class="hljs-string">"user_libraries"</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_USER_LIBRARIES_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_USER_CODE_ADDRESS}</span></span>) write_sector(<span class="hljs-string"><span class="hljs-string">"main_programm"</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_USER_CODE_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${ADDR_END_FLASH}</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span> ()</code> </pre> </div></div><br><br><h2>  Schlussfolgerungen </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Vorteile dieses Ansatzes: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In 95% der F√§lle wird das, was wirklich ben√∂tigt wird, aktualisiert. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachteile dieses Ansatzes: </font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt keinen Geschwindigkeitsgewinn, da vor jeder Firmware ein Bootloader in den Mikrocontroller geladen werden muss, um den nichtfl√ºchtigen Speicher zu flashen (dies wird automatisch vom stm32-Programmierer durchgef√ºhrt). </font><font style="vertical-align: inherit;">Im Gegenteil, wenn das Projekt vollst√§ndig wieder zusammengesetzt wird, m√ºssen Sie h√§ufig alle Abschnitte erneut n√§hen.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Gr√∂√üe von section.ld entmutigt jeden Wunsch, etwas hinzuzuf√ºgen oder zu √§ndern. </font><font style="vertical-align: inherit;">Wenn Sie diese Methode in einem realen Projekt anwenden m√ºssen, m√ºssen Sie eine praktische Benutzeroberfl√§che schreiben, um diese Datei zu bearbeiten.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn das Ger√§t seine eigene Stromversorgung steuert, bemerken Sie m√∂glicherweise nicht, dass eine der Partitionen nicht richtig verdrahtet war (z. B. mit einem Spannungsabfall), und debuggen Partitionen von verschiedenen Baugruppen f√ºr eine lange Zeit :). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen die Arbeitsversion der aktuellen Methode in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem Commit sehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Das Projekt kann in CLion zusammengestellt werden, nachdem zuvor ein Dienstprogramm zum Extrahieren des Abschnitts aus der Bin-Datei kompiliert wurde.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437848/">https://habr.com/ru/post/de437848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437836/index.html">Unter der Haube Screeps - Virtualisierung in der MMO-Sandbox f√ºr Programmierer</a></li>
<li><a href="../de437838/index.html">Technologien f√ºr maschinelles Lernen beschleunigen zeitweise den Prozess der Anpassung von Patienten an bionische Prothesen</a></li>
<li><a href="../de437842/index.html">Die geheime Geschichte von Donkey Kong: von Arcade-Automaten bis NES</a></li>
<li><a href="../de437844/index.html">Der immerw√§hrende Streit zwischen statischer und dynamischer Typisierung - TypeScript wird nicht helfen</a></li>
<li><a href="../de437846/index.html">bobaoskit - Zubeh√∂r, dnssd und WebSocket</a></li>
<li><a href="../de437850/index.html">Wer ist am effektivsten im Leiterplattenlayout?</a></li>
<li><a href="../de437852/index.html">Geschichte der Shipastik</a></li>
<li><a href="../de437858/index.html">Zus√§tzliche Vorlesungen des Kurses ‚ÄûEntwerfen hoch belasteter Systeme‚Äú (Herbst 2018) in Technopolis</a></li>
<li><a href="../de437864/index.html">Monitoring System f√ºr Windows-Server unter reinem SQL und wie ich es heimlich in die Produktion gezogen hatte</a></li>
<li><a href="../de437868/index.html">Sicherheitswoche 05: Drucker, Kameras, 7zip und Ethik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>