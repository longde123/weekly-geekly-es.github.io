<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼 🧝🏾 ❗️ HolyJS 2019: Pembekalan dari SEMrush (Bagian 2) ♌️ 🛌🏻 🚐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah bagian kedua dari analisis tugas dari stan kami di konferensi HolyJS , yang diadakan di St. Petersburg pada 24-25 Mei. Untuk konteks yang l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>HolyJS 2019: Pembekalan dari SEMrush (Bagian 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/453466/"><img src="https://habrastorage.org/webt/lu/af/0g/luaf0gd14raqav4knnokeboltkk.jpeg"><br><br>  Ini adalah bagian kedua dari analisis tugas dari stan kami di konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HolyJS</a> , yang diadakan di St. Petersburg pada 24-25 Mei.  Untuk konteks yang lebih besar, Anda disarankan untuk terlebih dahulu membaca bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama dari</a> materi ini.  Dan jika <i>Countdown Expression</i> telah selesai, selamat datang di langkah berikutnya. <br><a name="habracut"></a><br>  Tidak seperti obskurantisme dalam tugas pertama, dua berikutnya sudah memiliki beberapa petunjuk tentang penerapan aplikasi normal dalam kehidupan.  JavaScript masih berkembang cukup cepat dan solusi untuk masalah yang disarankan menyoroti beberapa fitur baru bahasa. <br><br><h2>  Tugas 2 ~ Dilakukan oleh Yang </h2><br>  Diasumsikan bahwa kode akan menjalankan dan mencetak jawaban ke konsol dalam menanggapi tiga permintaan, dan kemudian "selesai".  Tapi ada yang tidak beres ... Perbaiki situasinya. <br><br><pre><code class="javascript hljs">;(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetch(req); } } }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iter) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); })();</code> </pre> <br><h4>  Masalah penelitian </h4><br>  Apa yang kita punya di sini?  Ini adalah objek <i>iterable</i> <i>iter</i> yang memiliki simbol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>Symbol.iterator</i></a> <i>terkenal yang</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>didefinisikan</i></a> melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi generator</a> .  Array <i>fs</i> dideklarasikan di badan fungsi, elemen-elemen yang jatuh ke dalam fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>ambil</i></a> pada gilirannya untuk mengirim permintaan dan hasil dari setiap panggilan fungsi dikembalikan melalui <i>hasil</i> .  Permintaan apa yang dikirim fungsi <i>ambil</i> ?  Semua elemen array <i>fs</i> adalah jalur relatif ke sumber daya dengan angka 1, 2, dan 3, masing-masing.  Jadi URL lengkap akan diperoleh dengan menggabungkan <i>location.origin</i> dengan nomor berikutnya, misalnya: <br><br> <code>GET https://www.example.com/1 <br></code> <br>  Selanjutnya, kita ingin mengulangi objek <i>iter</i> melalui <i>for-of</i> , untuk mengeksekusi setiap permintaan secara bergantian dengan output dari hasilnya, setelah semua - cetak "selesai".  Tapi itu tidak berhasil!  Masalahnya adalah bahwa <i>mengambil</i> adalah hal yang tidak sinkron dan mengembalikan janji, bukan respons.  Karenanya, di konsol kita akan melihat sesuatu seperti ini: <br><br> <code>Promise {pending} <br> Promise {pending} <br> Promise {pending} <br> done <br></code> <br>  Sebenarnya, tugas turun untuk menyelesaikan janji-janji yang sama ini. <br><br><h4>  Kami memiliki async / menunggu </h4><br>  Pikiran pertama mungkin bermain dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>Promise.all</i></a> : berikan objek <i>iterable</i> kami, <i>maka</i> output ke konsol “selesai”.  Tetapi dia tidak akan memberi kami eksekusi permintaan yang berurutan (seperti yang dipersyaratkan oleh kondisi), tetapi cukup kirimkan semuanya dan tunggu jawaban terakhir sebelum resolusi umum. <br><br>  Solusi paling sederhana di sini akan <i>menunggu</i> di <i>-</i> tubuh untuk menunggu resolusi janji berikutnya sebelum output ke konsol: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iter) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> res); }</code> </pre><br>  Agar <i>menunggu untuk</i> bekerja dan "selesai" untuk ditampilkan di akhir, Anda perlu membuat fungsi utama asinkron melalui <i>async</i> : <br><br><pre> <code class="javascript hljs">;(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iter) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> res); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); })();</code> </pre><br>  Dalam hal ini, masalahnya sudah diselesaikan (hampir): <br><br> <code>GET 1st <br> Response 1st <br> GET 2nd <br> Response 2nd <br> GET 3rd <br> Response 3rd <br> done <br></code> <br><h4>  Asynchronous Iterator dan Generator </h4><br>  Kami akan meninggalkan fungsi utama asinkron, tetapi untuk <i>menunggu</i> ada tempat yang lebih elegan dalam tugas ini daripada di <i>for-of</i> body: ini adalah penggunaan iterasi sinkron melalui <a href=""><i>for-waiting-of</i></a> , yaitu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iter) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); }</code> </pre><br>  Semuanya akan berhasil!  Tetapi jika Anda beralih ke deskripsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>proposal</i> ini</a> tentang iterasi asinkron, maka inilah yang menarik: <br><br><blockquote>  Kami memperkenalkan variasi pernyataan iterasi for-of yang beriterasi pada objek iterable yang aser.  Pernyataan async hanya diperbolehkan dalam fungsi async dan fungsi generator async </blockquote><br>  Artinya, objek kita seharusnya bukan hanya dapat diubah, tetapi <i>"asyncIterable"</i> melalui simbol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>Symbol.asyncIterator</i></a> baru yang <i>terkenal</i> dan, dalam kasus kami, sudah menjadi fungsi generator asinkron: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.asyncIterator]: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(req); } } };</code> </pre><br>  Lalu bagaimana cara kerjanya pada iterator dan generator reguler?  Ya, secara tersirat, seperti lebih banyak dalam bahasa ini.  Ini <i>untuk menunggu</i> adalah rumit: jika objek hanya <i>iterable</i> , maka ketika iterating secara tidak sinkron, itu "mengubah" objek menjadi <i>asyncIterable</i> dengan membungkus elemen (jika perlu) dalam <i>Janji</i> dengan harapan resolusi.  Dia berbicara lebih detail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam sebuah artikel oleh</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Axel Rauschmayer</a> . <br><br>  Mungkin, melalui <i>Symbol.asyncIterator</i> masih akan lebih benar, karena kami secara eksplisit membuat objek <i>asyncIterable</i> untuk iterasi asinkron kami melalui <i>for-waiting-of</i> , sambil meninggalkan kesempatan untuk melengkapi objek dengan iterator reguler <i>untuk</i> , jika perlu.  Jika Anda ingin membaca sesuatu yang bermanfaat dan memadai dalam satu artikel tentang iterasi sinkron dalam JavaScript, maka ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dia</a> ! <br><br>  Asynchronous <i>for-of</i> masih sebagian dalam konsep, tetapi sudah didukung oleh browser modern (kecuali Edge) dan Node.js dari 10.x.  Jika ini mengganggu seseorang, Anda selalu dapat menulis polifile kecil Anda sendiri untuk rantai janji, misalnya, untuk objek yang dapat <i>diubah</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chain = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promises, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">it</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = it.next(); i.done ? resolve() : i.value.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> { callback(res); next(it); }); }(promises[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]()) ); ;(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = { <span class="hljs-comment"><span class="hljs-comment">/* iterable */</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> chain(iter, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); })();</code> </pre><br>  Dengan cara ini dan itu, kami menemukan mengirimkan permintaan dan memproses tanggapan pada gilirannya.  Namun dalam masalah ini ada satu lagi masalah kecil tapi menjengkelkan ... <br><br><h4>  Tes kesadaran </h4><br>  Kami begitu terbawa oleh semua asinkronisme ini sehingga, seperti yang sering terjadi, kami kehilangan satu detail kecil.  Apakah permintaan itu dikirim oleh skrip kami?  Mari kita lihat <i>jaringannya</i> : <br><br> <code>GET https://www.example.com/0 <br> GET https://www.example.com/1 <br> GET https://www.example.com/2 <br></code> <br>  Tetapi angka kami adalah 1, 2, 3. Seakan terjadi penurunan.  Kenapa begitu  Hanya dalam kode sumber tugas ada masalah lain dengan iterasi, di sini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetch(req); }</code> </pre><br>  Di sini <i>for-in digunakan</i> , yang alih-alih nilai array mem-bypass properti enumerasinya: dan ini adalah indeks elemen dari 0 hingga 2. Fungsi <i>fetch</i> masih mengarahkan mereka ke string dan, meskipun tidak ada garis miring sebelumnya (ini bukan lagi <i>jalur</i> ), ia menyelesaikan relatif URL halaman saat ini.  Untuk memperbaikinya jauh lebih mudah daripada memperhatikan.  Dua opsi: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetch(req); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetch(fs[req]); }</code> </pre><br>  Dalam yang pertama, kami menggunakan <i>for-of yang</i> sama <i>untuk</i> beralih pada nilai-nilai array, yang kedua - akses ke elemen array dengan indeks. <br><br><h4>  Motivasi </h4><br>  Kami mempertimbangkan 3 solusi: 1) melalui <i>penantian</i> dalam <i>for-of</i> body, 2) melalui <i>for-waiting-of,</i> dan 3) melalui polyfile kami (fungsi rekursif, <i>pipa</i> pipa, dll.).  Sangat mengherankan bahwa opsi-opsi ini membagi peserta konferensi kurang lebih sama dan tidak ada favorit yang jelas terungkap.  Dalam proyek-proyek besar, untuk tugas-tugas nyata seperti itu, perpustakaan reaktif (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RxJS</a> ) biasanya digunakan, tetapi perlu diingat tentang fitur asli bahasa modern dengan sifat asinkron. <br><br>  Sekitar setengah dari peserta tidak melihat kesalahan dalam pengulangan atas daftar sumber daya, yang juga merupakan pengamatan yang menarik.  Berfokus pada masalah yang tidak sepele tetapi jelas, kita dapat dengan mudah melewatkan hal yang tampaknya sepele ini, tetapi dengan konsekuensi serius yang potensial. <br><br><h2>  Soal 3 ~ Faktor 19 </h2><br>  Berapa kali dalam catatan angka 2019!  (faktorial dari 2019) apakah angka 19 terjadi?  Bersamaan dengan jawabannya, berikan solusi JavaScript. <br><br><h4>  Masalah penelitian </h4><br>  Masalahnya ada di permukaan: kita membutuhkan catatan dari jumlah yang sangat besar untuk menemukan di dalamnya jumlah semua kejadian dari substring "19".  Memecahkan masalah pada <i>angka</i> , kami sangat cepat mengalami <i>Infinity</i> (setelah 170) dan tidak mendapatkan apa pun.  Selain itu, format untuk mewakili angka <i>float64</i> menjamin keakuratan hanya 15-17 karakter, dan kita harus mendapatkan tidak hanya data yang lengkap, tetapi juga catatan yang akurat.  Karenanya, kesulitan utama adalah menentukan struktur untuk akumulasi jumlah besar ini. <br><br><h4>  Bilangan bulat besar </h4><br>  Jika Anda mengikuti inovasi bahasa, tugas diselesaikan dengan sederhana: alih-alih <i>nomor</i> jenis <i>,</i> Anda dapat menggunakan tipe baru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>BigInt</i> (tahap 3)</a> , yang memungkinkan Anda untuk bekerja dengan angka presisi acak.  Dengan fungsi rekursif klasik untuk menghitung faktorial dan menemukan kecocokan melalui <i>String.prototype.split,</i> solusi pertama terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fn = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>n ? n * fn(n - <span class="hljs-number"><span class="hljs-number">1</span></span>n) : <span class="hljs-number"><span class="hljs-number">1</span></span>n; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn(<span class="hljs-number"><span class="hljs-number">2019</span></span>n).toString().split(<span class="hljs-string"><span class="hljs-string">'19'</span></span>).length - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 50</span></span></code> </pre><br>  Namun, dua ribu panggilan fungsi pada stack sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bisa berbahaya</a> .  Bahkan jika Anda membawa solusi untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rekursi ekor</a> , maka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>optimasi panggilan Tail</i></a> masih hanya mendukung Safari.  Masalah faktorial di sini lebih menyenangkan untuk diselesaikan melalui siklus aritmatika atau <i>Array.prototype.reduce</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([...Array(<span class="hljs-number"><span class="hljs-number">2019</span></span>)].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p, _, i</span></span></span><span class="hljs-function">) =&gt;</span></span> p * BigInt(i + <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>n).toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/19/g</span></span>).length); <span class="hljs-comment"><span class="hljs-comment">// 50</span></span></code> </pre><br>  Ini mungkin tampak seperti prosedur yang sangat panjang.  Tapi kesan ini menipu.  Jika Anda memperkirakan, maka kami hanya perlu menghabiskan sedikit lebih dari dua ribu perkalian.  Pada i5-4590 3.30GHz di chrome, masalahnya diselesaikan rata-rata dalam 4-5ms (!). <br><br>  Pilihan lain untuk menemukan kecocokan dalam string dengan hasil perhitungan adalah <i>String.prototype.match</i> dengan ekspresi reguler dengan bendera pencarian global: <i>/ 19 / g</i> . <br><br><h4>  Aritmatika besar </h4><br>  Tetapi bagaimana jika kita belum memiliki <i>BigInt</i> ini (dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan</a> juga)?  Dalam hal ini, Anda bisa melakukan aritmatika panjang sendiri.  Untuk menyelesaikan masalah, cukup bagi kita untuk menerapkan hanya fungsi mengalikan besar dengan kecil (kita kalikan dengan angka dari 1 hingga 2019).  Kita dapat menyimpan jumlah besar dan hasil penggandaan, misalnya, di baris: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @param {string} big * @param {number} int * @returns {string} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mult = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">big, int</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = <span class="hljs-string"><span class="hljs-string">''</span></span>, carry = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = big.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i -= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prod = big[i] * int + carry; res = prod % <span class="hljs-number"><span class="hljs-number">10</span></span> + res; carry = prod / <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">carry || </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span></span><span class="hljs-function">) + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">; } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">console</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[...</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2019</span></span></span></span></span><span class="hljs-function">)].</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p, _, i</span></span></span><span class="hljs-function">) =&gt;</span></span> mult(p, i + <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">'1'</span></span>).match(<span class="hljs-regexp"><span class="hljs-regexp">/19/g</span></span>).length); <span class="hljs-comment"><span class="hljs-comment">// 50</span></span></code> </pre><br>  Di sini kita cukup mengalikan kolom dalam bit dari ujung garis ke awal, seperti yang diajarkan di sekolah.  Tetapi solusinya sudah membutuhkan sekitar 170ms. <br><br>  Kami dapat meningkatkan algoritme dengan memproses lebih dari satu digit dalam catatan angka setiap kali.  Untuk melakukan ini, kami memodifikasi fungsi dan pada saat yang sama pergi ke array, agar tidak dipusingkan dengan garis setiap kali: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @param {Array&lt;number&gt;} big * @param {number} int * @param {number} digits * @returns {Array&lt;number&gt;} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mult = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">big, int, digits = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = [], carry = <span class="hljs-number"><span class="hljs-number">0</span></span>, div = <span class="hljs-number"><span class="hljs-number">10</span></span> ** digits; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = big.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || carry; i -= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prod = (i &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : big[i] * int) + carry; res.push(prod % div); carry = prod / div | <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.reverse(); }</code> </pre><br>  Di sini, sejumlah besar diwakili oleh array, masing-masing elemen yang menyimpan informasi tentang <i>digit</i> digit dari catatan angka, menggunakan <i>nomor</i> .  Misalnya, angka 2016201720182019 dengan <i>angka</i> = 3 akan direpresentasikan sebagai: <br><br> <code>'2|016|201|720|182|019' =&gt; [2,16,201,720,182,19] <br></code> <br>  Saat mengonversi ke baris sebelum bergabung, Anda harus mengingat nol di depannya.  Fungsi <i>faktor</i> mengembalikan faktorial yang dihitung oleh string, menggunakan fungsi <i>mult</i> dengan jumlah digit yang diproses pada waktu tertentu dalam representasi "besar-besaran" angka ketika menghitung: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factor = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n, digits = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> [...Array(n)].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p, _, i</span></span></span><span class="hljs-function">) =&gt;</span></span> mult(p, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, digits), [<span class="hljs-number"><span class="hljs-number">1</span></span>]) .map(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'0'</span></span>.repeat(digits - el.length) + el) .join(<span class="hljs-string"><span class="hljs-string">''</span></span>) .replace(<span class="hljs-regexp"><span class="hljs-regexp">/^0+/</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(factor(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>).match(<span class="hljs-regexp"><span class="hljs-regexp">/19/g</span></span>).length); <span class="hljs-comment"><span class="hljs-comment">// 50</span></span></code> </pre><br>  Implementasi "knee-length" melalui array ternyata lebih cepat daripada melalui string, dan dengan <i>digit</i> = 1 itu menghitung jawaban sudah rata-rata dalam 90ms, <i>digit</i> = 3 dalam 35ms, <i>digit</i> = 6 hanya dalam 20ms.  Namun, ingatlah bahwa meningkatkan jumlah digit, kami mendekati situasi di mana mengalikan <i>angka</i> dengan <i>angka</i> "di bawah tenda" mungkin di luar brankas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>MAX_SAFE_INTEGER</i></a> .  Anda bisa bermain dengannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Berapa nilai <i>digit</i> maksimum yang kami mampu untuk tugas ini? <br><br>  Hasilnya sudah cukup indikatif, <i>BigInt</i> sangat cepat: <br><br><img src="https://habrastorage.org/webt/qq/wb/-j/qqwb-jhmypgogtk94bg-pqnrxhy.png"><br><br><h4>  Motivasi </h4><br>  Sangat menyenangkan bahwa 2/3 dari peserta konferensi menggunakan tipe <i>BigInt</i> baru dalam solusi (seseorang mengakui bahwa ini adalah pengalaman pertama).  Sepertiga sisanya dari solusi berisi implementasi aritmatika panjang mereka sendiri pada string atau array.  Sebagian besar fungsi yang diimplementasikan dikalikan angka besar dengan yang besar, ketika untuk solusi itu cukup untuk dikalikan dengan angka "kecil" dan menghabiskan sedikit waktu lebih sedikit.  Oke tugas, apakah Anda sudah <i>menggunakan BigInt</i> dalam proyek Anda? <br><br><h2>  Ucapan Terima Kasih </h2><br>  Dua hari konferensi ini sangat penuh dengan diskusi dan mempelajari sesuatu yang baru.  Saya ingin mengucapkan terima kasih kepada komite program untuk konferensi tak terlupakan berikutnya dan semua peserta atas jaringan yang unik dan suasana hati yang baik. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453466/">https://habr.com/ru/post/id453466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453454/index.html">Software Defined Radio - bagaimana cara kerjanya? Bagian 5</a></li>
<li><a href="../id453456/index.html">Cara kerja pelokalan di Netflix - terjemahan</a></li>
<li><a href="../id453458/index.html">Pemrograman reaktif nyata di Svelte 3.0</a></li>
<li><a href="../id453460/index.html">Ketika bosan dengan virtual</a></li>
<li><a href="../id453464/index.html">Quantum Future (lanjutan)</a></li>
<li><a href="../id453468/index.html">Evolusi aplikasi web Java</a></li>
<li><a href="../id453470/index.html">Monolith Anda yang terdistribusi sedang merencanakan di belakang Anda</a></li>
<li><a href="../id453472/index.html">Sepeda dari monitor energi PZEM004T dan ESP8266, dengan People's Monitoring</a></li>
<li><a href="../id453474/index.html">Kontrol komputer melalui remote control dari amplifier menggunakan Arduino dan Node.js</a></li>
<li><a href="../id453478/index.html">Kami mempelajari kesehatan satelit Starlink Ilona Mask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>