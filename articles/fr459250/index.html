<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐗 🏺 🧛 WAL dans PostgreSQL: 2. Journal de pré-enregistrement 🌄 ☎️ 😆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La dernière fois, nous avons rencontré l'appareil de l'un des objets importants de la mémoire partagée, le cache tampon. La possibilité de perdre des ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL dans PostgreSQL: 2. Journal de pré-enregistrement</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/459250/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La dernière fois,</a> nous avons rencontré l'appareil de l'un des objets importants de la mémoire partagée, le cache tampon.  La possibilité de perdre des informations de la RAM est la principale raison de la nécessité de récupérer après une panne.  Aujourd'hui, nous allons parler de ces outils. <br><br><h1>  Magazine </h1><br>  Hélas, les miracles ne se produisent pas: pour survivre à la perte d'informations dans la RAM, tout ce qui est nécessaire doit être écrit sur un disque (ou un autre appareil non volatile) en temps opportun. <br><br>  C'est donc ce qui a été fait.  Parallèlement aux modifications des données, un <em>journal de</em> ces modifications est également conservé.  Lorsque nous modifions quelque chose sur une page du cache de tampon, nous créons un enregistrement dans le journal de cette modification.  L'enregistrement contient les informations minimales suffisantes pour que, si nécessaire, la modification puisse être répétée. <br><br>  Pour que cela fonctionne, l'entrée de journal doit nécessairement aller sur le disque <em>avant que la</em> page modifiée n'y arrive.  D'où le nom: journal d'écriture anticipée. <br><br>  En cas d'échec, les données du disque sont dans un état incohérent: certaines pages ont été écrites plus tôt, d'autres plus tard.  Mais il reste un journal qui peut être lu et relancé par les opérations qui ont déjà été effectuées avant l'échec, mais dont le résultat n'a pas atteint le disque. <br><a name="habracut"></a><br><blockquote>  Pourquoi ne pas forcer l'écriture des pages de données elles-mêmes sur le disque, pourquoi effectuer des doubles travaux à la place?  Cela s'avère si efficace. <br>  Tout d'abord, un journal est un flux séquentiel de données à écrire.  Même les disques durs fonctionnent assez bien avec l'enregistrement séquentiel.  Mais l'enregistrement des données lui-même est aléatoire, car les pages sont dispersées sur le disque de manière plus ou moins aléatoire. <br>  Deuxièmement, une entrée de journal peut être beaucoup plus petite qu'une page. <br>  Troisièmement, lors de l'enregistrement, vous n'avez pas à vous soucier de garantir la cohérence des données sur le disque à tout moment arbitraire (cette exigence complique considérablement la vie). <br>  Et quatrièmement, comme nous le verrons plus loin, le journal (puisqu'il existe) peut être utilisé non seulement pour la restauration, mais aussi pour la sauvegarde et la réplication. <br></blockquote><br>  Vous devez enregistrer toutes les opérations, au cours desquelles il existe un risque d'incohérence sur le disque en cas de panne.  En particulier, les actions suivantes sont enregistrées: <br><br><ul><li>  changer les pages dans le cache de tampon (en règle générale, ce sont des tables et des pages d'index) - puisque la page modifiée ne va pas immédiatement sur le disque; </li><li>  validation et annulation de transactions - le changement d'état se produit dans les tampons XACT et n'atteint pas immédiatement le disque; </li><li>  opérations sur les fichiers (création et suppression de fichiers et de répertoires, par exemple, création de fichiers lors de la création d'une table) - car ces opérations doivent se produire simultanément avec les modifications des données. </li></ul><br>  Non connecté: <br><br><ul><li>  opérations avec des tables non journalisées (non enregistrées) - leur nom parle de lui-même; </li><li>  opérations avec des tables temporaires - cela n'a aucun sens, car la durée de vie de ces tables ne dépasse pas la durée de vie de la session qui les a créées. </li></ul><br>  Avant PostgreSQL 10, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les index de hachage n'étaient</a> pas enregistrés (ils ne servaient qu'à mapper les fonctions de hachage à différents types de données), mais maintenant cela a été corrigé. <br><br><h1>  Dispositif logique </h1><br><img src="https://habrastorage.org/webt/vx/vj/67/vxvj673dzyqmhumlxby7i8wt5q0.png"><br><br>  Logiquement, un journal peut être considéré comme une séquence d'enregistrements de différentes longueurs.  Chaque enregistrement contient des <em>données</em> sur une certaine opération, précédées d'un en- <em>tête</em> standard.  Le titre, entre autres, indique: <br><br><ul><li>  Numéro de transaction auquel appartient l'enregistrement. </li><li>  gestionnaire de ressources - le composant du système responsable de l'enregistrement; </li><li>  somme de contrôle (CRC) - vous permet de déterminer la corruption des données; </li><li>  longueur d'enregistrement et lien vers l'enregistrement précédent. </li></ul><br>  Les données elles-mêmes ont un format et une signification différents.  Par exemple, ils peuvent représenter un fragment d'une page qui doit être écrit sur son contenu avec un certain décalage.  Le gestionnaire de ressources spécifié «comprend» comment interpréter les données de son enregistrement.  Il existe des gestionnaires distincts pour les tables, pour chaque type d'index, pour l'état des transactions, etc. Une liste complète d'entre eux peut être obtenue si vous le souhaitez par la commande <br><br><pre><code class="plaintext hljs">pg_waldump -r list</code> </pre> <br><h1>  Appareil physique </h1><br>  Sur le disque, le journal est stocké sous forme de fichiers dans le répertoire $ PGDATA / pg_wal.  La valeur par défaut de chaque fichier est de 16 Mo.  La taille peut être augmentée pour éviter un grand nombre de fichiers dans un répertoire.  Avant PostgreSQL 11, cela ne pouvait être fait que lors de la compilation du code source, mais maintenant vous pouvez spécifier la taille lors de l'initialisation du cluster (la <code>--wal-segsize</code> ). <br><br>  Les entrées de journal tombent dans le fichier en cours d'utilisation;  quand il se termine, le suivant commence à être utilisé. <br><br>  Des tampons spéciaux sont alloués au journal dans la mémoire partagée du serveur.  La taille du cache de journal est définie par le paramètre <em>wal_buffers</em> (la valeur par défaut implique une configuration automatique: 1/32 du cache de tampon est alloué). <br><br>  Le cache du journal est organisé comme un cache tampon, mais il fonctionne principalement en mode tampon en anneau: les entrées sont ajoutées à la "tête" et écrites sur le disque à partir de la "queue". <br><br>  Les positions d'enregistrement («queue») et d'insertion («tête») montrent respectivement les fonctions pg_current_wal_lsn et pg_current_wal_insert lsn: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_lsn | pg_current_wal_insert_lsn --------------------+--------------------------- 0/331E4E64 | 0/331E4EA0 (1 row)</code> </pre><br>  Afin de faire référence à un enregistrement spécifique, le type de données pg_lsn (LSN = numéro de séquence de journal) est utilisé - il s'agit d'un nombre de 64 bits représentant le décalage d'octet avant l'enregistrement par rapport au début du journal.  LSN est émis sous forme de deux nombres de 32 bits en notation hexadécimale. <br><br>  Vous pouvez savoir dans quel fichier nous trouverons la position souhaitée, et avec quel décalage par rapport au début du fichier: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> file_name, upper(to_hex(file_offset)) file_offset <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_walfile_name_offset(<span class="hljs-string"><span class="hljs-string">'0/331E4E64'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> file_name | file_offset --------------------------+------------- 000000010000000000000033 | 1E4E64 \ /\ /  0/331E4E64 </code> </pre><br>  Le nom de fichier se compose de deux parties.  Les 8 chiffres hexadécimaux supérieurs indiquent le numéro de la branche horaire (il est utilisé lors de la restauration à partir de la sauvegarde), le reste correspond aux chiffres LSN les plus élevés (et les chiffres LSN inférieurs restants indiquent le décalage). <br><br>  Les fichiers journaux peuvent être consultés sur le système de fichiers dans le répertoire $ PGDATA / pg_wal /, mais à partir de PostgreSQL 10, ils peuvent également être vus avec une fonction spéciale: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_ls_waldir() <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'000000010000000000000033'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> name | size | modification --------------------------+----------+------------------------ 000000010000000000000033 | 16777216 | 2019-07-08 20:24:13+03 (1 row)</code> </pre><br><h1>  Écriture avant </h1><br>  Voyons comment se déroule la journalisation et comment un enregistrement proactif est fourni.  Créez une table: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wal(id <span class="hljs-type"><span class="hljs-type">integer</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> wal <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Nous allons regarder l'en-tête de la page du tableau.  Pour ce faire, nous avons besoin d'une extension déjà familière: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect;</code> </pre><br>  Commençons la transaction et rappelons la position d'insertion dans le journal: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F377C (1 row)</code> </pre><br>  Maintenant, faisons une opération, par exemple, mettons à jour la ligne: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> wal <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> id = id + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Cette modification a été enregistrée dans le journal, la position d'insertion a changé: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F37C4 (1 row)</code> </pre><br>  Pour garantir que la page de données modifiée n'est pas poussée sur le disque avant l'entrée de journal, le LSN de la dernière entrée de journal associée à cette page est stocké dans l'en-tête de page: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lsn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'wal'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lsn ------------ 0/331F37C4 (1 row)</code> </pre><br>  Gardez à l'esprit que le journal est commun à l'ensemble du cluster et que de nouvelles entrées y tombent tout le temps.  Par conséquent, le LSN sur la page peut être inférieur à la valeur que la fonction pg_current_wal_insert_lsn vient de renvoyer.  Mais rien ne se passe dans notre système, donc les chiffres sont les mêmes. <br><br>  Terminez maintenant la transaction. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  L'enregistrement de validation est également enregistré dans le journal et la position change à nouveau: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F37E8 (1 row)</code> </pre><br>  Commit change le statut d'une transaction dans une structure appelée XACT (nous en avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">déjà parlé</a> ).  Les statuts sont stockés dans des fichiers, mais ils utilisent également leur propre cache, qui occupe 128 pages en mémoire partagée.  Par conséquent, pour les pages XACT, le LSN de la dernière entrée de journal doit être suivi.  Mais ces informations ne sont pas stockées dans la page elle-même, mais dans la RAM. <br><br>  À un moment donné, les entrées de journal créées seront écrites sur le disque.  Dans lequel - nous parlerons une autre fois, mais dans notre cas, cela s'est déjà produit: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_lsn | pg_current_wal_insert_lsn --------------------+--------------------------- 0/331F37E8 | 0/331F37E8 (1 row)</code> </pre><br>  Après ce point, les données et les pages XACT peuvent être poussées hors du cache.  Mais s'il était nécessaire de les expulser plus tôt, il serait détecté et les entrées de journal seraient obligées d'être enregistrées en premier. <br><br>  Connaissant les deux positions LSN, vous pouvez obtenir la taille des entrées de journal entre elles (en octets) en soustrayant simplement une position de l'autre.  Vous avez juste besoin de convertir les positions en type pg_lsn: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'0/331F37E8'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/331F377C'</span></span>::pg_lsn;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 108 (1 row)</code> </pre><br>  Dans ce cas, la mise à jour et la validation de la ligne ont nécessité 108 octets dans le journal. <br><br>  De la même manière, vous pouvez estimer la quantité d'entrées de journal générées par le serveur par unité de temps à une certaine charge.  Ce sont des informations importantes qui seront nécessaires lors de la configuration (dont nous parlerons la prochaine fois). <br><br>  Nous allons maintenant utiliser l'utilitaire pg_waldump pour examiner les entrées de journal créées. <br><br>  L'utilitaire peut fonctionner avec la plage LSN (comme dans cet exemple) et sélectionner des enregistrements pour la transaction spécifiée.  Il doit être exécuté au nom de l'utilisateur du système d'exploitation postgres, car il a besoin d'accéder aux fichiers journaux sur le disque. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/331F377C -e 0/331F37E8 000000010000000000000033</code> </pre><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 69/ 69, tx: 101085, lsn: 0/331F377C, prev 0/331F3014, desc: HOT_UPDATE off 1 xmax 101085 ; new off 2 xmax 0, blkref #0: rel 1663/16386/33081 blk 0</code> </pre><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 34/ 34, tx: 101085, lsn: 0/331F37C4, prev 0/331F377C, desc: COMMIT 2019-07-08 20:24:13.945435 MSK</code> </pre><br>  Ici, nous voyons les en-têtes des deux entrées. <br><br>  La première est l'opération <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HOT_UPDATE</a> , liée au gestionnaire de ressources du tas.  Le nom de fichier et le numéro de page sont indiqués dans le champ blkref et correspondent à la page de table mise à jour: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'wal'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/16386/33081 (1 row)</code> </pre><br>  La deuxième entrée est COMMIT, liée au gestionnaire de ressources de transaction. <br><br>  Ce n'est pas le format le plus lisible, mais vous pouvez le découvrir si nécessaire. <br><br><h1>  Récupération </h1><br>  Lorsque nous démarrons le serveur, le processus postmaster démarre en premier et, à son tour, démarre le processus de démarrage, dont la tâche est d'assurer la récupération en cas de défaillance. <br><br>  Pour déterminer si la récupération est requise, le démarrage examine le fichier de contrôle spécial $ PGDATA / global / pg_control et examine l'état du cluster.  Nous pouvons vérifier le statut nous-mêmes en utilisant l'utilitaire pg_controldata: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: in production</code> </pre><br>  Un serveur correctement arrêté aura le statut «arrêté».  Si le serveur ne fonctionne pas et que le statut reste «en production», cela signifie que le SGBD est tombé et que la récupération sera automatiquement effectuée. <br><br>  Pour la récupération, le processus de démarrage lira séquentiellement le journal et appliquera des entrées aux pages, si nécessaire.  Vous pouvez vérifier le besoin en comparant le LSN de la page sur le disque avec le LSN de l'entrée de journal.  Si le LSN de la page est plus grand, l'enregistrement n'est pas nécessaire.  Mais en fait - ce n'est même pas possible, car les enregistrements sont conçus pour une application strictement cohérente. <br><br><blockquote>  Il y a des exceptions.  Certains enregistrements sont formés comme une image pleine page (FPI, image pleine page), et il est clair qu'une telle image peut être appliquée à une page dans n'importe quel état - elle effacera toujours tout ce qui s'y trouvait.  Une autre modification du statut de la transaction peut être appliquée à n'importe quelle version de la page XACT - par conséquent, à l'intérieur de ces pages, il n'est pas nécessaire de stocker LSN. <br></blockquote><br>  La modification des pages pendant la récupération se produit dans le cache de tampon, comme pendant le travail normal - pour ce maître de poste, démarre les processus d'arrière-plan nécessaires. <br><br>  De même, les entrées de journal s'appliquent aux fichiers: par exemple, si un enregistrement indique que le fichier doit exister, mais qu'il n'existe pas, le fichier est créé. <br><br>  Eh bien, à la toute fin du processus de récupération, toutes les tables non journalisées sont remplacées par des "nuls" de leurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">couches init</a> . <br><br>  Il s'agit d'une présentation très simplifiée de l'algorithme.  En particulier, nous n'avons rien dit par où commencer la lecture des écritures de journal (cette conversation devra être reportée jusqu'à ce que le point de contrôle soit considéré). <br><br>  Et la dernière précision.  Le processus de récupération "classique" comprend deux phases.  Dans la première phase (roll forward), les écritures de journal sont restaurées et le serveur répète tout le travail perdu lors de l'échec.  Dans la seconde (annulation), les transactions qui n'étaient pas validées au moment de l'échec sont annulées.  Mais PostgreSQL n'a pas besoin d'une deuxième phase.  Comme nous l'avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">considéré précédemment</a> , en raison des particularités de la mise en œuvre des transactions multi-versions, il n'est pas nécessaire de les annuler physiquement;  il suffit que le bit de correction ne soit pas défini dans XACT. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">À suivre</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459250/">https://habr.com/ru/post/fr459250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459240/index.html">10 ans en TI diagnostiqués avec schizophrénie, conseils de survie</a></li>
<li><a href="../fr459242/index.html">Suite à la conférence T + Conf 2019</a></li>
<li><a href="../fr459244/index.html">Gestionnaire de produits Notes: comportement des utilisateurs sur les pages de jeu de l'App Store. Combien de temps faut-il pour télécharger un jeu</a></li>
<li><a href="../fr459246/index.html">Pourquoi la conversion de sites diminue-t-elle? Exemples de 60 erreurs de conception et d'utilisation</a></li>
<li><a href="../fr459248/index.html">Événements numériques à Moscou du 09 juillet au 14 juillet</a></li>
<li><a href="../fr459252/index.html">Semaine de la sécurité 28: pirater une maison intelligente</a></li>
<li><a href="../fr459254/index.html">Encore mieux la bombe zip</a></li>
<li><a href="../fr459256/index.html">Comment nous avons optimisé notre hôpital thématique pour différentes plateformes</a></li>
<li><a href="../fr459258/index.html">14 000 milles non accrochés</a></li>
<li><a href="../fr459262/index.html">Retraité à 22 ans</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>