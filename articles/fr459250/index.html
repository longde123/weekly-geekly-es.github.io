<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêó üè∫ üßõ WAL dans PostgreSQL: 2. Journal de pr√©-enregistrement üåÑ ‚òéÔ∏è üòÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La derni√®re fois, nous avons rencontr√© l'appareil de l'un des objets importants de la m√©moire partag√©e, le cache tampon. La possibilit√© de perdre des ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL dans PostgreSQL: 2. Journal de pr√©-enregistrement</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/459250/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La derni√®re fois,</a> nous avons rencontr√© l'appareil de l'un des objets importants de la m√©moire partag√©e, le cache tampon.  La possibilit√© de perdre des informations de la RAM est la principale raison de la n√©cessit√© de r√©cup√©rer apr√®s une panne.  Aujourd'hui, nous allons parler de ces outils. <br><br><h1>  Magazine </h1><br>  H√©las, les miracles ne se produisent pas: pour survivre √† la perte d'informations dans la RAM, tout ce qui est n√©cessaire doit √™tre √©crit sur un disque (ou un autre appareil non volatile) en temps opportun. <br><br>  C'est donc ce qui a √©t√© fait.  Parall√®lement aux modifications des donn√©es, un <em>journal de</em> ces modifications est √©galement conserv√©.  Lorsque nous modifions quelque chose sur une page du cache de tampon, nous cr√©ons un enregistrement dans le journal de cette modification.  L'enregistrement contient les informations minimales suffisantes pour que, si n√©cessaire, la modification puisse √™tre r√©p√©t√©e. <br><br>  Pour que cela fonctionne, l'entr√©e de journal doit n√©cessairement aller sur le disque <em>avant que la</em> page modifi√©e n'y arrive.  D'o√π le nom: journal d'√©criture anticip√©e. <br><br>  En cas d'√©chec, les donn√©es du disque sont dans un √©tat incoh√©rent: certaines pages ont √©t√© √©crites plus t√¥t, d'autres plus tard.  Mais il reste un journal qui peut √™tre lu et relanc√© par les op√©rations qui ont d√©j√† √©t√© effectu√©es avant l'√©chec, mais dont le r√©sultat n'a pas atteint le disque. <br><a name="habracut"></a><br><blockquote>  Pourquoi ne pas forcer l'√©criture des pages de donn√©es elles-m√™mes sur le disque, pourquoi effectuer des doubles travaux √† la place?  Cela s'av√®re si efficace. <br>  Tout d'abord, un journal est un flux s√©quentiel de donn√©es √† √©crire.  M√™me les disques durs fonctionnent assez bien avec l'enregistrement s√©quentiel.  Mais l'enregistrement des donn√©es lui-m√™me est al√©atoire, car les pages sont dispers√©es sur le disque de mani√®re plus ou moins al√©atoire. <br>  Deuxi√®mement, une entr√©e de journal peut √™tre beaucoup plus petite qu'une page. <br>  Troisi√®mement, lors de l'enregistrement, vous n'avez pas √† vous soucier de garantir la coh√©rence des donn√©es sur le disque √† tout moment arbitraire (cette exigence complique consid√©rablement la vie). <br>  Et quatri√®mement, comme nous le verrons plus loin, le journal (puisqu'il existe) peut √™tre utilis√© non seulement pour la restauration, mais aussi pour la sauvegarde et la r√©plication. <br></blockquote><br>  Vous devez enregistrer toutes les op√©rations, au cours desquelles il existe un risque d'incoh√©rence sur le disque en cas de panne.  En particulier, les actions suivantes sont enregistr√©es: <br><br><ul><li>  changer les pages dans le cache de tampon (en r√®gle g√©n√©rale, ce sont des tables et des pages d'index) - puisque la page modifi√©e ne va pas imm√©diatement sur le disque; </li><li>  validation et annulation de transactions - le changement d'√©tat se produit dans les tampons XACT et n'atteint pas imm√©diatement le disque; </li><li>  op√©rations sur les fichiers (cr√©ation et suppression de fichiers et de r√©pertoires, par exemple, cr√©ation de fichiers lors de la cr√©ation d'une table) - car ces op√©rations doivent se produire simultan√©ment avec les modifications des donn√©es. </li></ul><br>  Non connect√©: <br><br><ul><li>  op√©rations avec des tables non journalis√©es (non enregistr√©es) - leur nom parle de lui-m√™me; </li><li>  op√©rations avec des tables temporaires - cela n'a aucun sens, car la dur√©e de vie de ces tables ne d√©passe pas la dur√©e de vie de la session qui les a cr√©√©es. </li></ul><br>  Avant PostgreSQL 10, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les index de hachage n'√©taient</a> pas enregistr√©s (ils ne servaient qu'√† mapper les fonctions de hachage √† diff√©rents types de donn√©es), mais maintenant cela a √©t√© corrig√©. <br><br><h1>  Dispositif logique </h1><br><img src="https://habrastorage.org/webt/vx/vj/67/vxvj673dzyqmhumlxby7i8wt5q0.png"><br><br>  Logiquement, un journal peut √™tre consid√©r√© comme une s√©quence d'enregistrements de diff√©rentes longueurs.  Chaque enregistrement contient des <em>donn√©es</em> sur une certaine op√©ration, pr√©c√©d√©es d'un en- <em>t√™te</em> standard.  Le titre, entre autres, indique: <br><br><ul><li>  Num√©ro de transaction auquel appartient l'enregistrement. </li><li>  gestionnaire de ressources - le composant du syst√®me responsable de l'enregistrement; </li><li>  somme de contr√¥le (CRC) - vous permet de d√©terminer la corruption des donn√©es; </li><li>  longueur d'enregistrement et lien vers l'enregistrement pr√©c√©dent. </li></ul><br>  Les donn√©es elles-m√™mes ont un format et une signification diff√©rents.  Par exemple, ils peuvent repr√©senter un fragment d'une page qui doit √™tre √©crit sur son contenu avec un certain d√©calage.  Le gestionnaire de ressources sp√©cifi√© ¬´comprend¬ª comment interpr√©ter les donn√©es de son enregistrement.  Il existe des gestionnaires distincts pour les tables, pour chaque type d'index, pour l'√©tat des transactions, etc. Une liste compl√®te d'entre eux peut √™tre obtenue si vous le souhaitez par la commande <br><br><pre><code class="plaintext hljs">pg_waldump -r list</code> </pre> <br><h1>  Appareil physique </h1><br>  Sur le disque, le journal est stock√© sous forme de fichiers dans le r√©pertoire $ PGDATA / pg_wal.  La valeur par d√©faut de chaque fichier est de 16 Mo.  La taille peut √™tre augment√©e pour √©viter un grand nombre de fichiers dans un r√©pertoire.  Avant PostgreSQL 11, cela ne pouvait √™tre fait que lors de la compilation du code source, mais maintenant vous pouvez sp√©cifier la taille lors de l'initialisation du cluster (la <code>--wal-segsize</code> ). <br><br>  Les entr√©es de journal tombent dans le fichier en cours d'utilisation;  quand il se termine, le suivant commence √† √™tre utilis√©. <br><br>  Des tampons sp√©ciaux sont allou√©s au journal dans la m√©moire partag√©e du serveur.  La taille du cache de journal est d√©finie par le param√®tre <em>wal_buffers</em> (la valeur par d√©faut implique une configuration automatique: 1/32 du cache de tampon est allou√©). <br><br>  Le cache du journal est organis√© comme un cache tampon, mais il fonctionne principalement en mode tampon en anneau: les entr√©es sont ajout√©es √† la "t√™te" et √©crites sur le disque √† partir de la "queue". <br><br>  Les positions d'enregistrement (¬´queue¬ª) et d'insertion (¬´t√™te¬ª) montrent respectivement les fonctions pg_current_wal_lsn et pg_current_wal_insert lsn: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_lsn | pg_current_wal_insert_lsn --------------------+--------------------------- 0/331E4E64 | 0/331E4EA0 (1 row)</code> </pre><br>  Afin de faire r√©f√©rence √† un enregistrement sp√©cifique, le type de donn√©es pg_lsn (LSN = num√©ro de s√©quence de journal) est utilis√© - il s'agit d'un nombre de 64 bits repr√©sentant le d√©calage d'octet avant l'enregistrement par rapport au d√©but du journal.  LSN est √©mis sous forme de deux nombres de 32 bits en notation hexad√©cimale. <br><br>  Vous pouvez savoir dans quel fichier nous trouverons la position souhait√©e, et avec quel d√©calage par rapport au d√©but du fichier: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> file_name, upper(to_hex(file_offset)) file_offset <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_walfile_name_offset(<span class="hljs-string"><span class="hljs-string">'0/331E4E64'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> file_name | file_offset --------------------------+------------- 000000010000000000000033 | 1E4E64 \ /\ /  0/331E4E64 </code> </pre><br>  Le nom de fichier se compose de deux parties.  Les 8 chiffres hexad√©cimaux sup√©rieurs indiquent le num√©ro de la branche horaire (il est utilis√© lors de la restauration √† partir de la sauvegarde), le reste correspond aux chiffres LSN les plus √©lev√©s (et les chiffres LSN inf√©rieurs restants indiquent le d√©calage). <br><br>  Les fichiers journaux peuvent √™tre consult√©s sur le syst√®me de fichiers dans le r√©pertoire $ PGDATA / pg_wal /, mais √† partir de PostgreSQL 10, ils peuvent √©galement √™tre vus avec une fonction sp√©ciale: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_ls_waldir() <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'000000010000000000000033'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> name | size | modification --------------------------+----------+------------------------ 000000010000000000000033 | 16777216 | 2019-07-08 20:24:13+03 (1 row)</code> </pre><br><h1>  √âcriture avant </h1><br>  Voyons comment se d√©roule la journalisation et comment un enregistrement proactif est fourni.  Cr√©ez une table: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wal(id <span class="hljs-type"><span class="hljs-type">integer</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> wal <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Nous allons regarder l'en-t√™te de la page du tableau.  Pour ce faire, nous avons besoin d'une extension d√©j√† famili√®re: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect;</code> </pre><br>  Commen√ßons la transaction et rappelons la position d'insertion dans le journal: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F377C (1 row)</code> </pre><br>  Maintenant, faisons une op√©ration, par exemple, mettons √† jour la ligne: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> wal <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> id = id + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Cette modification a √©t√© enregistr√©e dans le journal, la position d'insertion a chang√©: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F37C4 (1 row)</code> </pre><br>  Pour garantir que la page de donn√©es modifi√©e n'est pas pouss√©e sur le disque avant l'entr√©e de journal, le LSN de la derni√®re entr√©e de journal associ√©e √† cette page est stock√© dans l'en-t√™te de page: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lsn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'wal'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lsn ------------ 0/331F37C4 (1 row)</code> </pre><br>  Gardez √† l'esprit que le journal est commun √† l'ensemble du cluster et que de nouvelles entr√©es y tombent tout le temps.  Par cons√©quent, le LSN sur la page peut √™tre inf√©rieur √† la valeur que la fonction pg_current_wal_insert_lsn vient de renvoyer.  Mais rien ne se passe dans notre syst√®me, donc les chiffres sont les m√™mes. <br><br>  Terminez maintenant la transaction. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  L'enregistrement de validation est √©galement enregistr√© dans le journal et la position change √† nouveau: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F37E8 (1 row)</code> </pre><br>  Commit change le statut d'une transaction dans une structure appel√©e XACT (nous en avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©j√† parl√©</a> ).  Les statuts sont stock√©s dans des fichiers, mais ils utilisent √©galement leur propre cache, qui occupe 128 pages en m√©moire partag√©e.  Par cons√©quent, pour les pages XACT, le LSN de la derni√®re entr√©e de journal doit √™tre suivi.  Mais ces informations ne sont pas stock√©es dans la page elle-m√™me, mais dans la RAM. <br><br>  √Ä un moment donn√©, les entr√©es de journal cr√©√©es seront √©crites sur le disque.  Dans lequel - nous parlerons une autre fois, mais dans notre cas, cela s'est d√©j√† produit: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_lsn | pg_current_wal_insert_lsn --------------------+--------------------------- 0/331F37E8 | 0/331F37E8 (1 row)</code> </pre><br>  Apr√®s ce point, les donn√©es et les pages XACT peuvent √™tre pouss√©es hors du cache.  Mais s'il √©tait n√©cessaire de les expulser plus t√¥t, il serait d√©tect√© et les entr√©es de journal seraient oblig√©es d'√™tre enregistr√©es en premier. <br><br>  Connaissant les deux positions LSN, vous pouvez obtenir la taille des entr√©es de journal entre elles (en octets) en soustrayant simplement une position de l'autre.  Vous avez juste besoin de convertir les positions en type pg_lsn: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'0/331F37E8'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/331F377C'</span></span>::pg_lsn;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 108 (1 row)</code> </pre><br>  Dans ce cas, la mise √† jour et la validation de la ligne ont n√©cessit√© 108 octets dans le journal. <br><br>  De la m√™me mani√®re, vous pouvez estimer la quantit√© d'entr√©es de journal g√©n√©r√©es par le serveur par unit√© de temps √† une certaine charge.  Ce sont des informations importantes qui seront n√©cessaires lors de la configuration (dont nous parlerons la prochaine fois). <br><br>  Nous allons maintenant utiliser l'utilitaire pg_waldump pour examiner les entr√©es de journal cr√©√©es. <br><br>  L'utilitaire peut fonctionner avec la plage LSN (comme dans cet exemple) et s√©lectionner des enregistrements pour la transaction sp√©cifi√©e.  Il doit √™tre ex√©cut√© au nom de l'utilisateur du syst√®me d'exploitation postgres, car il a besoin d'acc√©der aux fichiers journaux sur le disque. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/331F377C -e 0/331F37E8 000000010000000000000033</code> </pre><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 69/ 69, tx: 101085, lsn: 0/331F377C, prev 0/331F3014, desc: HOT_UPDATE off 1 xmax 101085 ; new off 2 xmax 0, blkref #0: rel 1663/16386/33081 blk 0</code> </pre><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 34/ 34, tx: 101085, lsn: 0/331F37C4, prev 0/331F377C, desc: COMMIT 2019-07-08 20:24:13.945435 MSK</code> </pre><br>  Ici, nous voyons les en-t√™tes des deux entr√©es. <br><br>  La premi√®re est l'op√©ration <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HOT_UPDATE</a> , li√©e au gestionnaire de ressources du tas.  Le nom de fichier et le num√©ro de page sont indiqu√©s dans le champ blkref et correspondent √† la page de table mise √† jour: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'wal'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/16386/33081 (1 row)</code> </pre><br>  La deuxi√®me entr√©e est COMMIT, li√©e au gestionnaire de ressources de transaction. <br><br>  Ce n'est pas le format le plus lisible, mais vous pouvez le d√©couvrir si n√©cessaire. <br><br><h1>  R√©cup√©ration </h1><br>  Lorsque nous d√©marrons le serveur, le processus postmaster d√©marre en premier et, √† son tour, d√©marre le processus de d√©marrage, dont la t√¢che est d'assurer la r√©cup√©ration en cas de d√©faillance. <br><br>  Pour d√©terminer si la r√©cup√©ration est requise, le d√©marrage examine le fichier de contr√¥le sp√©cial $ PGDATA / global / pg_control et examine l'√©tat du cluster.  Nous pouvons v√©rifier le statut nous-m√™mes en utilisant l'utilitaire pg_controldata: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: in production</code> </pre><br>  Un serveur correctement arr√™t√© aura le statut ¬´arr√™t√©¬ª.  Si le serveur ne fonctionne pas et que le statut reste ¬´en production¬ª, cela signifie que le SGBD est tomb√© et que la r√©cup√©ration sera automatiquement effectu√©e. <br><br>  Pour la r√©cup√©ration, le processus de d√©marrage lira s√©quentiellement le journal et appliquera des entr√©es aux pages, si n√©cessaire.  Vous pouvez v√©rifier le besoin en comparant le LSN de la page sur le disque avec le LSN de l'entr√©e de journal.  Si le LSN de la page est plus grand, l'enregistrement n'est pas n√©cessaire.  Mais en fait - ce n'est m√™me pas possible, car les enregistrements sont con√ßus pour une application strictement coh√©rente. <br><br><blockquote>  Il y a des exceptions.  Certains enregistrements sont form√©s comme une image pleine page (FPI, image pleine page), et il est clair qu'une telle image peut √™tre appliqu√©e √† une page dans n'importe quel √©tat - elle effacera toujours tout ce qui s'y trouvait.  Une autre modification du statut de la transaction peut √™tre appliqu√©e √† n'importe quelle version de la page XACT - par cons√©quent, √† l'int√©rieur de ces pages, il n'est pas n√©cessaire de stocker LSN. <br></blockquote><br>  La modification des pages pendant la r√©cup√©ration se produit dans le cache de tampon, comme pendant le travail normal - pour ce ma√Ætre de poste, d√©marre les processus d'arri√®re-plan n√©cessaires. <br><br>  De m√™me, les entr√©es de journal s'appliquent aux fichiers: par exemple, si un enregistrement indique que le fichier doit exister, mais qu'il n'existe pas, le fichier est cr√©√©. <br><br>  Eh bien, √† la toute fin du processus de r√©cup√©ration, toutes les tables non journalis√©es sont remplac√©es par des "nuls" de leurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">couches init</a> . <br><br>  Il s'agit d'une pr√©sentation tr√®s simplifi√©e de l'algorithme.  En particulier, nous n'avons rien dit par o√π commencer la lecture des √©critures de journal (cette conversation devra √™tre report√©e jusqu'√† ce que le point de contr√¥le soit consid√©r√©). <br><br>  Et la derni√®re pr√©cision.  Le processus de r√©cup√©ration "classique" comprend deux phases.  Dans la premi√®re phase (roll forward), les √©critures de journal sont restaur√©es et le serveur r√©p√®te tout le travail perdu lors de l'√©chec.  Dans la seconde (annulation), les transactions qui n'√©taient pas valid√©es au moment de l'√©chec sont annul√©es.  Mais PostgreSQL n'a pas besoin d'une deuxi√®me phase.  Comme nous l'avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">consid√©r√© pr√©c√©demment</a> , en raison des particularit√©s de la mise en ≈ìuvre des transactions multi-versions, il n'est pas n√©cessaire de les annuler physiquement;  il suffit que le bit de correction ne soit pas d√©fini dans XACT. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459250/">https://habr.com/ru/post/fr459250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459240/index.html">10 ans en TI diagnostiqu√©s avec schizophr√©nie, conseils de survie</a></li>
<li><a href="../fr459242/index.html">Suite √† la conf√©rence T + Conf 2019</a></li>
<li><a href="../fr459244/index.html">Gestionnaire de produits Notes: comportement des utilisateurs sur les pages de jeu de l'App Store. Combien de temps faut-il pour t√©l√©charger un jeu</a></li>
<li><a href="../fr459246/index.html">Pourquoi la conversion de sites diminue-t-elle? Exemples de 60 erreurs de conception et d'utilisation</a></li>
<li><a href="../fr459248/index.html">√âv√©nements num√©riques √† Moscou du 09 juillet au 14 juillet</a></li>
<li><a href="../fr459252/index.html">Semaine de la s√©curit√© 28: pirater une maison intelligente</a></li>
<li><a href="../fr459254/index.html">Encore mieux la bombe zip</a></li>
<li><a href="../fr459256/index.html">Comment nous avons optimis√© notre h√¥pital th√©matique pour diff√©rentes plateformes</a></li>
<li><a href="../fr459258/index.html">14 000 milles non accroch√©s</a></li>
<li><a href="../fr459262/index.html">Retrait√© √† 22 ans</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>