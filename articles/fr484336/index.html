<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖊️ 🕺🏻 ☺️ Règles de travail avec les tableaux dynamiques et les classes de collection personnalisées 💅🏻 👨🏽 👰🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Règles de travail avec les tableaux dynamiques et les classes de collection personnalisées 
 Voici les règles auxquelles j'adhère lorsque je travaille...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Règles de travail avec les tableaux dynamiques et les classes de collection personnalisées</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/484336/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/qy/hx/3d/qyhx3dbaepmsxkx2azb_tmi9dee.jpeg"></div><br><br>  Règles de travail avec les tableaux dynamiques et les classes de collection personnalisées <br>  Voici les règles auxquelles j'adhère lorsque je travaille avec des tableaux dynamiques.  En fait, c'est un guide pour concevoir des tableaux, mais je ne voulais pas le mettre dans un guide pour concevoir des objets, car tous les langages orientés objet n'ont pas de tableaux dynamiques.  Les exemples sont écrits en PHP car il est similaire à Java (que vous connaissez peut-être déjà), mais avec des tableaux dynamiques au lieu des classes de collection et des interfaces intégrées. <br><a name="habracut"></a><br><h2>  Utilisation de tableaux comme liste </h2><br><h4>  Tous les articles doivent être du même type. </h4><br>  Si vous utilisez un tableau comme liste (une collection de valeurs dans un certain ordre), toutes les valeurs doivent être du même type: <br><br><pre><code class="php hljs">$goodList = [ <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> ]; $badList = [ <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ];</code> </pre> <br>  Le style d'annotation de type de liste courant est: <code>@var array&lt;TypeOfElment&gt;</code> .  Assurez-vous de ne pas ajouter de type d'index, il doit toujours être <code>int</code> . <br><br><h4>  Besoin d'ignorer l'index de chaque élément </h4><br>  PHP créera automatiquement un nouvel index pour chaque élément de la liste (0, 1, 2, etc.).  Cependant, vous ne devez ni compter sur ces index, ni les utiliser directement.  Les clients ne peuvent compter que sur <code>countable</code> <code>iterable</code> et <code>countable</code> . <br><br>  Vous pouvez donc utiliser librement <code>foreach</code> et <code>count()</code> , mais ne pas utiliser <code>for</code> pour parcourir les éléments de la liste: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// Good loop: foreach ($list as $element) { } // Bad loop (exposes the index of each element): foreach ($list as $index =&gt; $element) { } // Also bad loop (the index of each element should not be used): for ($i = 0; $i &lt; count($list); $i++) { }</span></span></code> </pre> <br>  En PHP, la boucle <code>for</code> peut ne pas fonctionner du tout s'il n'y a pas d'index dans la liste, ou s'il y a plus d'index que le nombre d'éléments. <br><br><h4>  Utilisez un filtre au lieu de supprimer des éléments </h4><br>  Vous pouvez supprimer des éléments par index ( <code>unset()</code> ), mais au lieu de les supprimer, il est préférable de créer une nouvelle liste sans éléments indésirables à l'aide de <code>array_filter()</code> . <br><br>  Encore une fois, il ne faut pas se fier aux indices des éléments.  Ainsi, lorsque vous utilisez <code>array_filter()</code> n'utilisez pas <a href="https://www.php.net/manual/en/function.array-filter.php">le paramètre flag</a> pour filtrer les éléments par index, ni même par élément et index. <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// Good filter: array_filter( $list, function (string $element): bool { return strlen($element) &gt; 2; } ); // Bad filter (uses the index to filter elements as well) array_filter( $list, function (int $index): bool { return $index &gt; 3; }, ARRAY_FILTER_USE_KEY ); // Bad filter (uses both the index and the element to filter elements) array_filter( $list, function (string $element, int $index): bool { return $index &gt; 3 || $element === 'Include'; }, ARRAY_FILTER_USE_BOTH );</span></span></code> </pre><br><h2>  Utilisation de tableaux en tant que tableaux associatifs </h2><br>  Si les clés sont pertinentes et non des index (0, 1, 2, etc.), utilisez librement des tableaux associatifs (une collection à partir de laquelle vous pouvez extraire des valeurs par leurs clés uniques). <br><br><h4>  Toutes les clés doivent être du même type. </h4><br>  Première règle d'utilisation des tableaux associatifs: toutes les clés doivent être du même type (le plus souvent c'est une <code>string</code> ). <br><br><pre> <code class="php hljs">$goodMap = [ <span class="hljs-string"><span class="hljs-string">'foo'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'baz'</span></span> ]; <span class="hljs-comment"><span class="hljs-comment">// Bad (uses different types of keys) $badMap = [ 'foo' =&gt; 'bar', 1 =&gt; 'baz' ];</span></span></code> </pre><br><h3>  Toutes les valeurs doivent être du même type. </h3><br>  Il en va de même pour les valeurs: elles doivent être du même type. <br><br><pre> <code class="php hljs">$goodMap = [ <span class="hljs-string"><span class="hljs-string">'foo'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'baz'</span></span> ]; <span class="hljs-comment"><span class="hljs-comment">// Bad (uses different types of values) $badMap = [ 'foo' =&gt; 'bar', 'bar' =&gt; 1 ];</span></span></code> </pre> <br>  Un style commun pour annoter un type est: <code>@var array&lt;TypeOfKy, TypeOfValue&gt;</code> . <br><br><h4>  Les tableaux associatifs doivent rester privés </h4><br>  Les listes, en raison de la simplicité de leurs caractéristiques, peuvent être transférées en toute sécurité d'un objet à l'autre.  Tout client peut parcourir les éléments ou les compter, même si la liste est vide.  La carte est plus difficile à utiliser, car les clients peuvent compter sur des clés qui ne correspondent à aucune valeur.  Cela signifie que les tableaux associatifs doivent généralement rester privés par rapport aux objets qui les gèrent.  Au lieu de laisser les clients accéder directement aux mappes internes, laissez les getters (et éventuellement les setters) récupérer les valeurs.  Lancez des exceptions s'il n'y a pas de valeur pour la clé demandée.  Cependant, si vous pouvez garder la carte et ses valeurs complètement privées, faites-le. <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// Exposing a list is fine /** * @return array&lt;User&gt; */ public function allUsers(): array { // ... } // Exposing a map may be troublesome /** * @return array&lt;string, User&gt; */ public function usersById(): array { // ... } // Instead, offer a method to retrieve a value by its key /** * @throws UserNotFound */ public function userById(string $id): User { // ... }</span></span></code> </pre><br><h2>  Utiliser des objets comme des tableaux associatifs avec des valeurs de plusieurs types </h2><br>  Si vous souhaitez utiliser un tableau associatif, mais y stocker des valeurs de différents types, utilisez des objets.  Définissez une classe, ajoutez des propriétés de type public ou ajoutez un constructeur et des getters.  Ces objets incluent des objets de configuration ou de commande: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SillyRegisterUserCommand</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> string $username; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> string $plainTextPassword; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool $wantsToReceiveSpam; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int $answerToIAmNotARobotQuestion; }</code> </pre><br><h4>  Exceptions à la règle </h4><br>  Les bibliothèques et les frameworks nécessitent parfois l'utilisation de tableaux de manière plus dynamique.  Il est alors impossible (et indésirable) de suivre les règles précédentes.  Les exemples incluent le <a href="https://matthiasnoback.nl/2018/03/ormless-a-memento-like-pattern-for-object-persistence/">tableau de données</a> stocké dans une table de base de données et <a href="https://symfony.com/doc/current/forms.html">la configuration de formulaire</a> dans Symfony. <br><br><h2>  Classes de collecte personnalisées </h2><br>  Les classes de collection personnalisées peuvent être un excellent outil pour travailler avec <code>Iterator</code> , <code>ArrayAccess</code> et d'autres entités, mais je trouve que le code devient souvent déroutant.  Quiconque regarde du code pour la première fois devra consulter le manuel PHP, même s'il est un développeur expérimenté.  De plus, vous devrez écrire plus de code à maintenir (test, débogage, etc.).  Donc, dans la plupart des cas, un simple tableau avec les annotations de type correct suffit. <br><br>  Qu'est-ce qui indique que vous devez encapsuler le tableau dans un objet de collection personnalisé? <br><br><ul><li>  Duplication de la logique liée à un tableau. <br></li><li>  Les clients doivent travailler avec trop de détails sur le contenu du tableau. <br></li></ul><br><h4>  Utilisez une classe de collection personnalisée pour éviter la logique en double. </h4><br>  Si plusieurs clients travaillant avec le même tableau effectuent la même tâche (par exemple, filtrer, comparer, réduire, compter), les doublons peuvent être supprimés à l'aide de la classe de collecte personnalisée.  Le transfert de la logique en double vers une méthode de classe de collection permet à n'importe quel client d'effectuer la même tâche simplement en appelant la méthode de collection: <br><br><pre> <code class="php hljs">$names = [<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// Found in several places: $shortNames = array_filter( $names, function (string $element): bool { return strlen($element) &lt; 5; } ); // Turned into a custom collection class: use Assert\Assert; final class Names { /** * @var array&lt;string&gt; */ private array $names; public function __construct(array $names) { Assert::that()-&gt;allIsString($names); $this-&gt;names = $names; } public function shortNames(): self { return new self( array_filter( $this-&gt;names, function (string $element): bool { return strlen($element) &lt; 5; } ) ); } } $names = new Names([/* ... */]); $shortNames = $names-&gt;shortNames();</span></span></code> </pre> <br>  L'avantage de transformer une collection à l'aide d'une méthode est que cette transformation est nommée.  Vous pouvez ajouter un nom court et informatif pour appeler <code>array_filter()</code> , qui autrement serait assez difficile à trouver. <br><br><h4>  Dissociez les clients avec une classe de collecte personnalisée </h4><br>  Si un client parcourt un tableau, prend une partie des données des éléments sélectionnés et fait quelque chose avec eux, ce client est étroitement lié à tous les types correspondants: tableau, éléments, valeurs récupérées, méthode de sélection, etc. qu'en raison d'une telle liaison profonde, il sera beaucoup plus difficile pour vous de modifier quoi que ce soit lié à ces types sans casser le client.  Dans ce cas, vous pouvez également envelopper le tableau dans une classe de collection personnalisée et donner la bonne réponse, en effectuant les calculs nécessaires à l'intérieur et en desserrant la liaison du client à la collection. <br><br><pre> <code class="php hljs">$lines = []; $sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($lines <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $line) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($line-&gt;isComment()) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } $sum += $line-&gt;quantity(); } <span class="hljs-comment"><span class="hljs-comment">// Turned into a custom collection class: final class Lines { public function totalQuantity(): int { $sum = 0; foreach ($lines as $line) { if ($line-&gt;isComment()) { continue; } $sum += $line-&gt;quantity(); } return $sum; } }</span></span></code> </pre><br><h2>  Quelques règles pour les classes de collection personnalisées </h2><br><h4>  Rendez-les immuables </h4><br>  Lors de l'exécution de telles transformations, les références existantes à l'instance de collection ne doivent pas être affectées.  Par conséquent, toute méthode qui effectue cette conversion doit renvoyer une nouvelle instance de la classe, comme nous l'avons vu dans l'exemple précédent: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Names</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> $names; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $names)</span></span></span><span class="hljs-function"> </span></span>{ Assert::that()-&gt;allIsString($names); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;names = $names; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shortNames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">self</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> ); } }</code> </pre> <br>  Bien sûr, si vous convertissez un tableau interne, vous pouvez convertir un autre type de collection ou un tableau simple.  Comme d'habitude, assurez-vous que le type correct est renvoyé. <br><br><h4>  Fournissez uniquement le comportement dont les clients ont vraiment besoin </h4><br>  Au lieu d'étendre une classe à partir d'une bibliothèque avec une collection universelle, ou d'implémenter un filtre ou une carte universel, ainsi que de réduire pour chaque classe de collection personnalisée, implémentez uniquement ce dont vous avez vraiment besoin.  Si à un moment donné vous arrêtez d'utiliser la méthode, supprimez-la. <br><br><h4>  Utilisez IteratorAggregate et ArrayIterator pour itérer </h4><br>  Si vous travaillez avec PHP, au lieu d'implémenter toutes les méthodes de l'interface <code>Iterator</code> (enregistrement de pointeurs internes, etc.), implémentez uniquement l'interface <code>IteratorAggregate</code> et laissez-la retourner une instance <code>ArrayIterator</code> basée sur le tableau interne: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Names</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorAggregate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> $names; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $names)</span></span></span><span class="hljs-function"> </span></span>{ Assert::that()-&gt;allIsString($names); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;names = $names; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterator</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayIterator(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;names); } } $names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Names([<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($names <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><h4>  Compromis </h4><br>  Puisque vous écrivez plus de code pour une classe de collection personnalisée, il devrait être plus facile pour les clients de travailler avec cette collection (et pas seulement avec un tableau).  Si le code client devient plus clair, si la collection fournit un comportement utile, cela justifie l'effort supplémentaire de maintenance d'une classe de collection personnalisée.  Mais comme travailler avec des tableaux dynamiques est si facile (principalement parce que vous n'avez pas besoin de spécifier les types utilisés), j'utilise rarement mes classes de collection.  Cependant, certains développeurs les utilisent activement, donc je continuerai certainement à rechercher des cas d'utilisation possibles. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484336/">https://habr.com/ru/post/fr484336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484320/index.html">Création d'un microservice sur Quarkus, Kotlin et Gradle</a></li>
<li><a href="../fr484326/index.html">Aller à Londres ou mon stage chez Jump Trading</a></li>
<li><a href="../fr484328/index.html">Paul Graham annonce un nouveau langage de programmation Bel</a></li>
<li><a href="../fr484330/index.html">[Nginx] Comment battre response_status = 0</a></li>
<li><a href="../fr484332/index.html">Concentrez-vous sur la gestion des tâches. Comment nous faisons notre système de gestion</a></li>
<li><a href="../fr484338/index.html">Projet Neon de Samsung: banquiers numériques, hôtes de télévision, compagnons</a></li>
<li><a href="../fr484340/index.html">Java Digest du 17 janvier. Les deux premières semaines de la nouvelle année</a></li>
<li><a href="../fr484342/index.html">Boîte à outils basée sur Eclipse et GTK +, pour «Toradex Colibri T20 (Linux)»</a></li>
<li><a href="../fr484344/index.html">Trois niveaux d'autoscaling dans Kubernetes: comment les utiliser efficacement</a></li>
<li><a href="../fr484356/index.html">Un projet intéressant dans une équipe sympathique, ou combien coûte le bon employé?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>