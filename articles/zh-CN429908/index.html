<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔭 🛴 👨🏽‍🔬 如何在食物中使用协程和夜间安眠 👬 ✴️ 👏🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="协程是异步代码执行的强大工具。 它们并行工作，彼此通信并且消耗很少的资源。 似乎不用担心，协程可以引入生产中。 但是有恐惧，他们在干涉。 

 弗拉基米尔·伊万诺夫 （ Vladimir Ivanov ）在AppsConf上的报告所讲述的事实是，魔鬼并不那么可怕，您今天可以使用协程： 



- 为...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何在食物中使用协程和夜间安眠</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/429908/"> 协程是异步代码执行的强大工具。 它们并行工作，彼此通信并且消耗很少的资源。 似乎不用担心，协程可以引入生产中。 但是有恐惧，他们在干涉。 <br><br>  <strong>弗拉基米尔·伊万诺夫</strong> （ <strong>Vladimir Ivanov</strong> ）在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AppsConf</a>上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告</a>所讲述的事实是，魔鬼并不那么可怕，您今天可以使用协程： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为什么协程，而不是RxJava</a> ； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">恐惧阻碍了开发人员</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何使用协程进行缓存</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何正确处理错误</a> 。 </li></ul><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1lEG1CPkRaw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>演讲者简介</strong> ：Vladimir Ivanov（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">dzigoro</a> ）是<strong>EPAM</strong>的领先Android开发人员，具有7年的经验，喜欢Solution Architecture，React Native和iOS开发，还拥有<strong>Google Cloud Architect</strong>证书。 <br><a name="habracut"></a><br><blockquote> 您阅读的所有内容都是经验和各种研究成果的产物，因此按原样进行，没有任何保证。 <br></blockquote><h2><a name="coroutine"></a> 协程，Kotlin和RxJava </h2><br> 有关信息：corutin的当前状态在发行版中（左侧Beta）。  <strong>Kotlin 1.3</strong>已发布，协程已宣布稳定，世界上有和平。 <br><br><img src="https://habrastorage.org/webt/it/jm/db/itjmdbtgjewt6v1kihv_5urqxie.png"><br><br> 我最近在Twitter上进行了一项调查，发现使用协程的人们： <br><br><ul><li> 食品中含有13％的协程。 一切都很好； </li><li>  25％的人在宠物项目中尝试过它们； </li><li>  24％-什么是Kotlin？ </li><li>  38％的RxJava随处可见。 </li></ul><br> 统计数据不令人满意。 我认为<strong>RxJava</strong>对于开发人员通常使用的任务而言<strong>过于复杂</strong> 。 协程更适合于控制异步操作​​。 <br><br> 在我以前的报告中，我谈到了如何从RxJava重构到Kotlin中的协程，因此，我不会在此进行详细介绍，而只是回顾要点。 <br><br><h3> 我们为什么要使用协程？ </h3><br> 因为如果我们使用RxJava，那么通常的实现示例如下所示： <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiClientRx</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: Authorization)</span></span></span><span class="hljs-function"> : Single&lt;GithubUser&gt; fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRepositories</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reposUrl: String, auth: Authorization)</span></span></span><span class="hljs-function"> : Single&lt;List&lt;GithubRepository&gt;&gt; } </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//RxJava 2 implementation</span></span></span></span></code> </pre> <br> 我们有一个接口，例如，我们编写一个GitHub客户端，并希望对其执行一些操作： <br><br><ol><li> 登录用户。 <br></li><li> 获取GitHub存储库列表。 <br></li></ol><br> 在这两种情况下，函数都将返回单个业务对象：GitHubUser或GitHubRepository列表。 <br><br> 该接口的实现代码如下： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLoginRx</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ showProgress(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) compositeDisposable.add(apiClient.login(auth) .flatMap { user -&gt; apiClient.getRepositories(user.repos_url, auth) } .map { list -&gt; list.map { it.full_name } } .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doFinally { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } .subscribe( { list -&gt; showRepositories(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list) }, { error -&gt; Log.e(<span class="hljs-string"><span class="hljs-string">"TAG"</span></span>, <span class="hljs-string"><span class="hljs-string">"Failed to show repos"</span></span>, error) } )) }</code> </pre><br>  -我们采用<strong>CompositeDisposable，</strong>以便没有内存泄漏。 <br>  -将调用添加到第一个方法。 <br>  -我们使用方便的运算符来获取用户，例如<strong>flatMap</strong> 。 <br>  -我们获得了其存储库列表。 <br>  -我们编写<strong>样板</strong> ，使其在正确的线程上<strong>运行</strong> 。 <br>  -一切准备就绪后，我们将显示已登录用户的存储库列表。 <br><br>  <strong>RxJava代码难点：</strong> <br><br><ul><li>  <strong>复杂性</strong> 我认为，对于两个网络调用并在<strong>UI</strong>上显示某些内容这样的简单任务，代码太复杂了。 </li><li>  <strong>未绑定的堆栈跟踪。</strong> 堆栈跟踪几乎与您编写的代码无关。 </li><li>  <strong>资源超支</strong> <strong>。</strong>  RxJava会生成大量对象，并且性能可能会下降。 </li></ul><br>  <strong>协程到0.26版之前的相同代码是什么？</strong> <br><br>  API更改为0.26，我们正在谈论生产。 尚无人在产品中应用0.26，但我们正在努力。 <br><br>  <strong>使用协程，我们的界面将发生很大变化</strong> 。 函数将停止返回任何Singles和其他帮助对象。 他们将立即返回业务对象：GitHubUser和GitHubRepository列表。  GitHubUser和GitHubRepository函数将具有<strong>暂停</strong>修饰符。 这很好，因为暂停几乎不会使我们有任何义务： <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: Authorization)</span></span></span><span class="hljs-function"> : GithubUser suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRepositories</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reposUrl: String, auth: Authorization)</span></span></span><span class="hljs-function"> : List&lt;GithubRepository&gt; } </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//Base interface</span></span></span></span></code> </pre><br> 如果您已经看过使用此接口的实现的代码，则与RxJava相比，它将发生重大变化： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLogin</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ launch(UI) { val auth = BasicAuthorization(login, pass) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) val userlnfo = async { apiClient.login(auth) }.await() val repoUrl = userlnfo.repos_url val list = async { apiClient.getRepositories(repoUrl, auth) }.await() showRepositories( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list.map { it -&gt; it.full_name } ) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: RuntimeException) { showToast(<span class="hljs-string"><span class="hljs-string">"Oops!"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } } }</code> </pre><br>  -主要动作发生在我们称为<strong>协</strong> <strong>程生成</strong> <strong>器异步</strong> ，等待响应并获取<strong>userlnfo的地方</strong> 。 <br>  -我们使用来自该对象的数据。 <br>  -拨打另一个<strong>异步</strong>电话，然后呼叫<strong>await</strong> 。 <br><br> 一切看起来好像没有异步工作在发生，我们只需在该列中编写命令并执行它们即可。 最后，我们要做在UI上需要做的事情。 <br><br>  <strong>为什么协程更好？</strong> <br><br><ul><li> 此代码更易于阅读。 它写得好像是一致的。 </li><li> 此代码的性能很可能比Rx​​Java更好。 </li><li> 编写测试非常简单，但是稍后我们将介绍它们。 </li></ul><br><h2> 侧面2步 <br></h2><br> 让我们离开题外话，还有几件事需要讨论。 <br><br><h3> 第1步。withContext与启动/异步 <br></h3><br> 除了<strong>协程构建器异步之外，</strong>还有<strong>协程构建器withContext</strong> 。 <br><br>  <strong>启动</strong>或<strong>异步</strong>创建新的<strong>Coroutine上下文</strong> ，这并非总是必要的。 如果您有要在整个应用程序中使用的Coroutine上下文，则无需重新创建它。 您可以简单地重用现有的。 为此，您需要一个带有上下文的协程生成器。 它只是简单地重用现有的协程上下文。 它将快2-3倍，但是现在这是一个没有原则的问题。 如果确切的数字很有趣，那么<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里是</a>有关带有基准和详细信息的<strong>stackoverflow</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">问题</a> 。 <br><br><blockquote>  <strong>一般规则：</strong>毫无疑问在语义上适合使用withContext。 但是，如果您需要并行加载，例如几张图片或几段数据，则可以选择异步/等待。 <br></blockquote><br><h3> 步骤2.重构 <br></h3><br> 如果您重构一个非常复杂的RxJava链怎么办？ 我在生产中遇到了这个问题： <br><br><pre> <code class="java hljs">observable1.getSubject().zipWith(observable2.getSubject(), (t1, t2) -&gt; { <span class="hljs-comment"><span class="hljs-comment">// side effects return true; }).doOnError { // handle errors } .zipWith(observable3.getSubject(), (t3, t4) -&gt; { // side effects return true; }).doOnComplete { // gather data } .subscribe()</span></span></code> </pre><br> 我遇到了一个带有<strong>公共主题</strong>的复杂链，每个<strong>拉链</strong>中都有<strong>拉链</strong>和<strong>副作用</strong> ，从而将其他内容发送到事件总线。 任务至少是摆脱事件总线。 我坐了一天，但无法重构代码来解决问题。  <strong>正确的决定原来是扔掉所有东西，并在4小时内用协程重写代码</strong> 。 <br><br> 下面的代码与我得到的非常相似： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { val firstChunkJob = async { call1 } val secondChunkJob = async { call2 } val thirdChunkJob = async { call3 } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result( firstChunkJob.await(), secondChunkJob.await(), thirdChunkJob.await()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { <span class="hljs-comment"><span class="hljs-comment">// handle errors }</span></span></code> </pre><br>  -我们对第二个任务和第三个任务执行异步操作。 <br>  -我们正在等待结果并将其全部放入一个对象中。 <br>  -做完！ <br><br> 如果您的链条复杂且有协程，则只需重构即可。 真的很快。 <br><br><h2><a name="fear"></a> 是什么阻止开发人员在产品中使用协程？ <br></h2><br> 我认为，作为开发人员，我们目前仅由于担心新事物而无法使用协程： <br><br><ul><li> 我们不知道该如何处理<strong>生命周期</strong> ， <strong>活动</strong>和碎片生命周期。 在这些情况下如何使用协程？ </li><li> 没有使用Corutin解决生产中日常复杂任务的经验。 </li><li> 工具不足。 已经为RxJava编写了许多库和函数。 例如<strong>RxFCM</strong> 。  RxJava本身有很多运算符，这很好，但是协程呢？ </li><li> 我们并不真正了解如何测试协程。 </li></ul><br><blockquote> 如果我们摆脱了这四种恐惧，我们可以在晚上安然入睡，并在生产中使用协程。 <br></blockquote><br> 让我们一点一点地讲。 <br><br><h3>  1.生命周期管理 <br></h3><br><ul><li> 协程可以作为<strong>一次性</strong>或<strong>AsyncTask</strong>泄漏。 此问题必须手动解决。 </li><li> 为避免随机的<strong>Null指针异常，</strong>必须停止协程。 </li></ul><br><h4> 停下 <br></h4><br> 您是否熟悉<strong>Thread.stop（）</strong> ？ 如果您使用过它，那么时间不会太长。 在<strong>JDK 1.1中，该</strong>方法立即被声明为过时的，因为不可能采取和停止某些代码，并且不能保证它将正确完成。 您很可能只会得到<strong>内存损坏</strong> 。 <br><br> 因此， <strong>Thread.stop（）不起作用</strong> 。 您需要取消进行协作，也就是说，另一边的代码才能知道您正在取消它。 <br><br> 我们如何使用RxJava应用止损： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val compositeDisposable = CompositeDisposable() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ compositeDisposable.add( apiClientRx.requestSomething() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(result -&gt; {}) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ compositeDisposable.dispose() }</code> </pre><br><br> 在RxJava中，我们<strong>使用CompositeDisposable</strong> 。 <br><br>  -将变量<strong>CompositeDisposable</strong>添加到片段或演示者（使用RxJava的演示者）中的活动中。 <br>  -在<strong>onDestro中，</strong>添加<strong>Dispose</strong> ，所有异常将自行消失。 <br><br> 协程的原理大致相同： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val job: Job? = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">null</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job = launch(UI) { val user = apiClient.requestSomething() … } } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job?.cancel() }</code> </pre><br> 考虑一个<strong>简单任务</strong>的例子。 <br><br> 通常， <strong>协程构建器会</strong>返回<strong>工作</strong> ，在某些情况下会<strong>延迟执行</strong> 。 <br><br>  -我们可以记住这项工作。 <br>  -发出命令<strong>“启动”</strong> <strong>协程生成器</strong> 。 该过程开始，发生了一些事情，执行的结果被记住了。 <br>  -如果我们没有传递其他任何内容，则“启动”将启动该功能，并向我们返回该工作的链接。 <br>  -工作被记住，在onDestroy中，我们说<strong>“取消”</strong> ，一切正常。 <br><br>  <strong>该方法有什么问题？</strong> 每个工作都需要一个字段。 您需要维护作业列表以将其全部取消。 该方法会导致代码重复，请不要这样做。 <br><br> 好消息是，我们有<strong>其他选择</strong> ： <strong>CompositeJob</strong>和<strong>Lifecycle-aware job</strong> 。 <br><br>  CompositeJob是CompositeDisposable的类似物。 看起来像这样<strong>：</strong> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val job: CompositeJob = CompositeJob() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job.add(launch(UI) { val user = apiClient.requestSomething() ... }) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job.cancel() }</code> </pre><br>  -对于一个片段，我们开始一项工作。 <br>  -我们将所有<strong>作业</strong>放到CompositeJob中，并输入命令： <strong>“ job.cancel（）for all！”</strong>  。 <br><br> 该方法很容易在4行中实现，无需计算类声明： <br><br><pre> <code class="java hljs">Class CompositeJob { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val map = hashMapOf&lt;String, Job&gt;() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(job: Job, key: String = job.hashCode()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">) </span></span>= map.put(key, job)?.cancel() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key: String)</span></span></span><span class="hljs-function"> </span></span>= map[key]?.cancel() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= map.forEach { _ ,u -&gt; u.cancel() } }</code> </pre><br><br> 您将需要： <br><br>  -使用字符串键进行<strong>映射</strong> ， <br>  - <strong>添加</strong>方法，您将在其中添加工作， <br>  -可选的<strong>关键</strong>参数。 <br><br> 如果您想对同一工作使用相同的密钥-请。 如果没有，那么<strong>hashCode</strong>将解决我们的问题。 将作业添加到我们通过的地图中，并使用相同的键取消上一个作业。 如果我们超额完成任务，那么先前的结果将使我们不感兴趣。 我们取消并再次驱动。 <br><br> 取消很简单：我们通过按键获取作业并取消。 整个地图的第二个取消会取消所有内容。 所有代码在半小时内分四行编写，并且可以正常工作。 如果您不想写，请参考上面的示例。 <br><br><h4> 生命周期意识的工作 </h4><br> 您是否使用过<strong>Android Lifecycle</strong> ， <strong>Lifecycle所有者</strong>或<strong>观察者</strong> ？ <br><img src="https://habrastorage.org/webt/ud/pi/eq/udpieqn_xba30yasl2buwbs2bay.png"><br><br> 我们的<strong>活动</strong>和<strong>片段</strong>具有某些状态。 要点： <strong>创建，</strong> <strong>开始</strong>和<strong>恢复</strong> 。 状态之间有不同的过渡。  <strong>LifecycleObserver</strong>允许您订阅这些转换，并在其中一个转换发生时执行某些操作。 <br><br> 看起来很简单： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObserver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_RESUME) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_PAUSE) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disconnectListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ … } }</code> </pre><br> 您在方法上使用某些参数挂接注释，并通过相应的转换对其进行调用。 只需对协程使用此方法： <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AndroidJob</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lifecycle</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class">(), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleObserver</span></span></span><span class="hljs-class"> </span></span>{ init { lifecycle.addObserver(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_DESTROY) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Log.d(<span class="hljs-string"><span class="hljs-string">"AndroidJob"</span></span>, <span class="hljs-string"><span class="hljs-string">"Cancelling a coroutine"</span></span>) cancel() } }</code> </pre><br>  -您可以编写基类<strong>AndroidJob</strong> 。 <br>  -我们会将<strong>生命周期</strong>转移<strong>到</strong>全班。 <br>  <strong>-LifecycleObserver</strong>接口将实现作业。 <br><br> 我们所需要的： <br><br>  -在构造函数中，以Observer身份添加到Lifecycle。 <br>  -订阅<strong>ON_DESTROY</strong>或我们感兴趣的其他内容。 <br>  -在ON_DESTROY中取消。 <br>  -在片段中<strong>获取</strong>一个<strong>parentJob</strong> 。 <br>  -调用构造函数<strong>Joy作业</strong>或活动片段的<strong>生命周期</strong> 。 没关系 <br>  -将此<strong>parentJob</strong>作为<strong>父级</strong>传递。 <br><br> 完成的代码如下所示： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parentJob = AndroidJob(lifecycle) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job = launch(UI, parent = parentJob) { <span class="hljs-comment"><span class="hljs-comment">// code } }</span></span></code> </pre><br> 当您取消父级时，所有子协程都将被取消，并且您不再需要在片段中编写任何内容。 一切都会自动发生，不再需要ON_DESTROY。 最重要<strong>的</strong>是不要忘记传递<strong>parent = parentJob</strong> 。 <br><br><blockquote> 如果使用的话，您可以编写一条简单的棉绒规则来突出显示您的名字：“哦，您忘记了父母！” <br></blockquote><br> 用 <strong>&nbsp;</strong> 生命周期管理得到解决。 我们有几个工具，可让您轻松而舒适地完成所有操作。 <br><br> 生产中复杂的场景和非平凡的任务呢？ <br><br><h3>  2.复杂的用例 <br></h3><br> 复杂的场景和不平凡的任务是： <br><br>  - <strong>运算</strong>符-RxJava中的复杂运算符：flatMap，反跳等 <br>  - <strong>错误处理-</strong>复杂的错误处理。 不只是<strong>try..catch</strong> ，而且例如嵌套。 <br>  - <strong>缓存</strong> <strong>是一项</strong>艰巨的任务。 在生产中，我们遇到了一个缓存，希望获得一种工具来轻松解决协程的缓存问题。 <br><br><h4> 重覆 </h4><br> 当我们考虑协程的运算符时，第一个选择是<strong>repeatWhen（）</strong> 。 <br><br> 如果出现问题，而Corutin无法访问内部的服务器，则我们想通过某种指数回退重试几次。 也许是由于连接不良，我们将通过重复几次操作来获得理想的结果。 <br><br> 使用协程，可以轻松实现此任务： <br><br><pre> <code class="java hljs">suspend fun &lt;T&gt; retryDeferredWithDelay( deferred: () -&gt; Deferred&lt;T&gt;, tries: Int = <span class="hljs-number"><span class="hljs-number">3</span></span>, timeDelay: Long = <span class="hljs-number"><span class="hljs-number">1000L</span></span> ): T { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i in <span class="hljs-number"><span class="hljs-number">1</span></span>..tries) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deferred().await() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; tries) delay(timeDelay) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> UnsupportedOperationException() }</code> </pre><br><br> 操作员实施： <br><br>  -他带了<strong>Deferred</strong> 。 <br>  -您将需要调用<strong>异步方法</strong>来获取此对象。 <br>  -除了传递<strong>Deferred之外，</strong>您还可以传递一个suspend块和任何一个<strong>suspend函数。</strong> <br>  -for循环-您正在等待协程的结果。 如果发生某种情况并且重复计数器没有用尽，请通过<strong>Delay</strong>再试一次。 如果没有，那就没有。 <br><br> 该函数可以轻松自定义：放置指数延迟或传递lambda函数，该函数将根据情况计算延迟。 <br><br> 使用它，就可以了！ <br><br><h4> 拉链 </h4><br> 我们也经常遇到他们。 同样，一切都很简单： <br><br><pre> <code class="java hljs">suspend fun &lt;T1, T2, R&gt; zip( source1: Deferred&lt;T1&gt;, source2: Deferred&lt;T2&gt;, zipper: BiFunction&lt;T1, T2, R&gt;): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zipper.apply(sourcel.await(), source2.await()) } suspend fun &lt;T1, T2, R&gt; Deferred&lt;T1&gt;.zipWith( other: Deferred&lt;T2&gt;, zipper: BiFunction&lt;T1, T2, R&gt;): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zip(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, other, zipper) }</code> </pre><br>  -使用<strong>拉链，</strong>并在您的Deferred上等待。 <br>  -可以使用withContext来使用suspend函数和协程生成器，而不是Deferred。 您将传达所需的上下文。 <br><br> 这再次起作用，我希望我消除了这种恐惧。 <br><br><a name="cache"></a><h3> 快取 </h3><br><br> 使用RxJava在生产中是否有缓存实现？ 我们使用RxCache。 <br><img src="https://habrastorage.org/webt/tz/ym/tn/tzymtn1tykponnxcmz0qqi_qjmi.png"><br><br> 在左侧的图中： <strong>View</strong>和<strong>ViewModel</strong> 。 右侧是数据源：网络调用和数据库。 <br><br> 如果我们要缓存某些内容，那么缓存将是另一个数据源。 <br><br> 缓存类型： <br><br><ul><li> 网络呼叫的<strong>网络源</strong> 。 </li><li>  <strong>内存缓存</strong> 。 </li><li> 具有到期时间的<strong>永久性高速缓存</strong>将存储在磁盘上，以便高速缓存在应用程序重新启动后得以幸免。 </li></ul><br> 让我们为第三种情况编写一个简单的原始<strong>缓存</strong> 。 协程生成器withContext再次救出。 <br><br><pre> <code class="java hljs">launch(UI) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = withContext(dispatcher) { persistence.getData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = withContext(dispatcher) { memory.getData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = withContext(dispatcher) { network.getData() } memory.cache(url, data) persistence.cache(url, data) } } }</code> </pre><br>  -使用withContext执行每个操作，然后查看是否有任何数据。 <br>  -如果<strong>持久性</strong>数据不<strong>存在</strong> ，则您正在尝试从<strong>memory.cache</strong>获取<strong>数据</strong> 。 <br>  -如果也没有memory.cache，请与<strong>网络来源</strong>联系并获取数据。 当然，不要忘记放入所有缓存。 <br><br> 这是一个非常原始的实现，有很多问题，但是如果您需要在一个地方缓存，则该方法有效。 对于生产任务，此缓存还不够。 需要更复杂的东西。 <br><br><h4>  Rx具有RxCache </h4><br> 对于仍然使用RxJava的用户，可以使用RxCache。 我们仍然使用它。  <strong>RxCache</strong>是一个特殊的库。 允许您缓存数据并管理其生命周期。 <br><br> 例如，您想说这些数据将在15分钟后过期：“请在这段时间之后，不要从缓存中发送数据，而向我发送新数据。” <br><br> 该库很棒，因为它以声明方式支持团队。 该声明与您对<strong>Retrofit</strong>所做的非常相似： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureConfigCacheProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ProviderKey</span></span>(<span class="hljs-string"><span class="hljs-string">"features"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@LifeCache</span></span>(duration = <span class="hljs-number"><span class="hljs-number">15</span></span>, timeUnit = TimeUnit.MINUTES) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( result: Observable&lt;Features&gt;, cacheName: DynamicKey )</span></span></span><span class="hljs-function">: Observable&lt;Reply&lt;Features&gt;&gt; }</span></span></code> </pre><br>  -您说您有一个<strong>CacheProvider</strong> 。 <br>  -启动一个方法，并说<strong>LifeCache</strong>生存期<strong>为</strong> 15分钟。 可用的密钥是<strong>Features</strong> 。 <br>  -返回<strong>Observable &lt;Reply</strong> ，其中<strong>Reply</strong>是用于处理缓存的辅助库对象。 <br><br> 使用非常简单： <br><br><pre> <code class="java hljs">val restObservable = configServiceRestApi.getFeatures() val features = featureConfigCacheProvider.getFeatures( restObservable, DynamicKey(CACHE_KEY) )</code> </pre><br>  -从Rx缓存中，访问<strong>RestApi</strong> 。 <br>  - <strong>转到CacheProvider</strong> 。 <br>  -喂他一个可观察的东西。 <br>  -库本身将弄清楚该怎么做：是否去缓存，如果时间用完了，转到<strong>Observable</strong>并执行另一项操作。 <br><br> 使用该库非常方便，我想为协程提供一个类似的库。 <br><br><h4> 开发中的协程缓存 </h4><br> 在EPAM内部，我们正在编写<strong>Coroutine Cache</strong>库，该库将执行RxCache的所有功能。 我们编写了第一个版本，并在公司内部运行。 第一个版本发布后，我将很乐意将其发布在我的Twitter上。 它看起来像这样： <br><br><pre> <code class="java hljs">val restFunction = configServiceRestApi.getFeatures() val features = withCache(CACHE_KEY) { restFunction() }</code> </pre><br> 我们将有一个暂停功能<strong>getFeatures</strong> 。 我们将把该函数作为一个块传递给带有<strong>Cache</strong>的特殊高阶函数，该函数将<strong>找出</strong>需要完成的工作。 <br><br> 也许我们将使用相同的接口来支持声明性功能。 <br><br><a name="err"></a><h3> 错误处理 <br></h3><br><img src="https://habrastorage.org/webt/sd/qq/uc/sdqqucxxckqchfozdoknxa3vi-k.png"><br><br> 开发人员经常发现简单的错误处理，并且通常很简单地解决。 如果您没有复杂的事物，那么在捕获中您会捕获<strong>异常</strong>并查看发生的情况，写日志或向用户显示错误。 在用户界面上，您可以轻松地做到这一点。 <br><br> 在简单的情况下，一切都应该是简单的-使用协程的错误处理是通过<strong>try-catch-finally完成的</strong> 。 <br><br> 在生产中，除了简单的案例外，还有： <br><br>  -嵌套的<strong>try-catch</strong> ， <br>  -许多不同种类的<strong>例外</strong> ， <br>  -网络或业务逻辑中的错误， <br>  -用户错误。 他再次做错了事，应为一切负责。 <br><br> 我们必须为此做好准备。 <br><br> 有2个解决方案： <strong>CoroutineExceptionHandler</strong>和带有<strong>Result类</strong>的方法。 <br><br><h3> 协程异常处理程序 <br></h3><br> 这是处理复杂错误案例的特殊类。  <strong>ExceptionHandler</strong>允许您将<strong>Exception</strong>作为错误的参数进行处理。 <br><br> 我们通常如何处理复杂的错误？ <br><br> 用户按下了某个按钮，该按钮不起作用。 他需要说出问题所在，然后将其定向到特定的操作：检查Internet，Wi-Fi，稍后再试或删除该应用程序，而不再使用它。 对用户说起来很简单： <br><br><pre> <code class="java hljs">val handler = CoroutineExceptionHandler(handler = { , error -&gt; hideProgressDialog() val defaultErrorMsg = <span class="hljs-string"><span class="hljs-string">"Something went wrong"</span></span> val errorMsg = when (error) { is ConnectionException -&gt; userFriendlyErrorMessage(error, defaultErrorMsg) is HttpResponseException -&gt; userFriendlyErrorMessage(Endpoint.EndpointType.ENDPOINT_SYNCPLICITY, error) is EncodingException -&gt; <span class="hljs-string"><span class="hljs-string">"Failed to decode data, please try again"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; defaultErrorMsg } Toast.makeText(context, errorMsg, Toast.LENGTH_SHORT).show() })</code> </pre><br>  -让我们获取默认消息：“出了点问题！” 并分析异常。 <br>  -如果这是<strong>ConnectionException，</strong>则我们从资源中获取本地化消息：“伙计，打开Wi-Fi，您的问题将消失。 我保证。” <br>  -如果<strong>服务器说错了</strong> ，那么您需要告诉客户端：“注销并再次登录”，或者“不要在莫斯科这样做，请在另一个国家这样做”，或者“对不起，同志。 我所能做的就是说出问题了。” <br>  -如果这是完全<strong>不同的错误</strong> ，例如<strong>内存不足</strong> ，我们说：“出了点问题，对不起。” <br>  -显示所有消息。 <br><br> 您写入<strong>CoroutineExceptionHandler的内容</strong>将在运行协程的同一<strong>Dispatcher</strong>上执行。 因此，如果您提供“启动” UI命令，则UI上将发生所有事情。 您不需要单独的<strong>调度，</strong>这非常方便。 <br><br> 使用很简单： <br><br><pre> <code class="java hljs">launch(uiDispatcher + handler) { ... }</code> </pre><br> 有一个<strong>加号</strong>运算符。 在Coroutine上下文中，添加一个<strong>处理程序</strong> ，一切正常，这非常方便。 我们使用了一段时间。 <br><br><h3> 结果类 <br></h3><br> 后来我们意识到可能会缺少CoroutineExceptionHandler。 由协程的工作形成的结果可以包含来自不同部分的多个数据或处理多种情况。 <br><br>  <strong>结果类</strong>方法有助于解决此问题： <br><br><pre> <code class="java hljs">sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">data class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Success</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val payload: String)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> data class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val exception: Exception)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> }</span></span></code> </pre><br>  -在业务逻辑中，启动<strong>Result类</strong> 。 <br>  -标记为已<strong>密封</strong> 。 <br>  -您从该类继承了另外两个数据类： <strong>Success</strong>和<strong>Error</strong> 。 <br> —  <strong>Success</strong>   ,     . <br> —  <strong>Error</strong>  exception. <br><br>     -  : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">override suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: Result </span></span>= withContext(CommonPool) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !isSessionValidForTask() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-meta"><span class="hljs-meta">@withContext</span></span> Result.Error(Exception()) } … <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Result.Success(restApi.call()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { Result.Error(e) } }</code> </pre><br>  Coroutine context — Coroutine builder withContex     . <br><br> ,  : <br><br> —   ,   error.     . <br> —   RestApi   -. <br> —   ,   <strong>Result.Success</strong> . <br> —   ,  <strong>Result.Error</strong> . <br><br>      - ,  ExceptionHandler   . <br><br> Result classes ,   .   Result classes,      ExceptionHandler  try-catch. <br><br><h3> 3.  <br></h3><br> ,       .    <strong>unit-</strong> ,   ,    .       unit-. <br><br> ,   .   ,   unit-,    2 : <br><br><ol><li> <strong>Replacing context</strong> .   ,    ; </li><li> <strong>Mocking coroutines</strong> .   . </li></ol><br><h4> Replacing context <br></h4><br>   presenter: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">val </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ launch(UI) { … } }</code> </pre><br> ,    <strong>login</strong>    ,     UI-.      ,        ,  <strong>         </strong> .    ,    ,   unit-. <br><br>   : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">val </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val coroutineContext = UI)</span></span></span><span class="hljs-function"> </span></span>{ launch(coroutineContext) { ... } }</code> </pre><br> —   login   coroutineContext. ,            .  Kotlin   ,     UI  . <br> —   Coroutine builder   Coroutine Contex,    . <br><br>  unit-   : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val presenter = LoginPresenter () presenter.login(Unconfined) }</code> </pre><br><br> —    <strong>LoginPresenter</strong>   login   - , ,  Unconfined. <br> — <strong>Unconfined</strong> ,      ,    .         . <br><br><h4> Mocking coroutines <br></h4><br>   —  .    <strong>Mockk</strong>  unit-.     unit-    Kotlin,      .  suspend-        <strong>coEvery</strong>        -. <br><br>   login     <strong>githubUser</strong> : <br><br><pre> <code class="java hljs">coEvery { apiClient.login(any()) } returns githubUser</code> </pre><br>    <strong>Mockito-kotlin</strong> ,     —    . ,    ,     : <br><br><pre> <code class="java hljs">given { runBlocking { apiClient.login(any()) } }.willReturn (githubUser)</code> </pre><br>    <strong>runBlocking</strong> .  <strong>given-</strong>    ,    . <br><br>        <strong>Presenter</strong> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val githubUser = GithubUser(<span class="hljs-string"><span class="hljs-string">'login'</span></span>) val presenter = LoginPresenter(mockApi) presenter.login (Unconfined) assertEquals(githubUser, presenter.user()) }</code> </pre><br> —   -, , <strong>GitHubUser</strong> . <br> —  LoginPresenter      API,     .      . <br> —   <strong>presenter.login</strong>  Unconfined   ,   Presenter    ,   . <br><br> 仅此而已！    . <br><br><h2>   <br></h2><br><br><ul><li> <strong> Rx-   .</strong>      .      ,  RxJava  RxJava.     -  —   ,   . </li><li> <strong>   .</strong>   ,       . Unit- —       ,  ,     ,    .  — welcome! </li><li> <strong>   .</strong>   ,  ,   ,   ,      .       . </li></ul><br><br><h3> 有用的链接 <br></h3><br><ul><li>      ,      Android GDE   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Android Coroutine Recipes</a> .     ,      : lifeCircle, coroutineContexts,   Coroutine builders   . </li><li> <a href="">  </a>  GitHub. </li><li>     Android  Kotlin,      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> <strong>Codelab</strong></a> . </li><li>           .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Twitter</a>       . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong> Medium</strong></a>     «»      Android,   async-   . </li></ul><br><blockquote>  <strong>最新消息</strong> <br><br> 30    Mail.ru   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>      .  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AppsConf</a>   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>   . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a> ,   ,       ,       . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">youtube-</a>       AppsConf 2018 —    :) <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN429908/">https://habr.com/ru/post/zh-CN429908/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN429892/index.html">xonsh-python作为shell的替代品</a></li>
<li><a href="../zh-CN429894/index.html">在具有ROS的Raspberry Pi 3上使用鱼眼-第2部分</a></li>
<li><a href="../zh-CN429898/index.html">DMS（经销商管理系统）-用于管理经销商网络的信息生态系统的实施</a></li>
<li><a href="../zh-CN429902/index.html">Web 2.0时代的页面排名-第1部分</a></li>
<li><a href="../zh-CN429904/index.html">关于计算机游戏开发的有趣和悲伤的故事</a></li>
<li><a href="../zh-CN429910/index.html">AppsConf上升</a></li>
<li><a href="../zh-CN429912/index.html">库开发：从API到公开发布</a></li>
<li><a href="../zh-CN429914/index.html">OpenSceneGraph：场景图和智能指针</a></li>
<li><a href="../zh-CN429916/index.html">如何建立和建立</a></li>
<li><a href="../zh-CN429918/index.html">虚拟世界英特尔。 第2部分：SMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>