<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí† üë©üèº‚Äçüè≠ üôåüèª Bewahren Sie Autorisierungstoken sicher auf ü•ô üë©‚Äçüëß‚Äçüëß ‚è¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo% Benutzername%. Unabh√§ngig vom Thema des Berichts wird mir auf den Konferenzen st√§ndig die gleiche Frage gestellt: "Wie k√∂nnen Token sicher auf ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bewahren Sie Autorisierungstoken sicher auf</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423753/">  Hallo% Benutzername%.  Unabh√§ngig vom Thema des Berichts wird mir auf den Konferenzen st√§ndig die gleiche Frage gestellt: "Wie k√∂nnen Token sicher auf dem Ger√§t des Benutzers gespeichert werden?".  Normalerweise versuche ich zu antworten, aber die Zeit erlaubt es nicht, das Thema vollst√§ndig zu enth√ºllen.  Mit diesem Artikel m√∂chte ich dieses Problem vollst√§ndig schlie√üen. <br><a name="habracut"></a><br>  Ich habe ein Dutzend Anwendungen analysiert, um zu sehen, wie sie mit Token funktionieren.  Alle von mir analysierten Anwendungen verarbeiteten kritische Daten und erm√∂glichten es mir, als zus√§tzlichen Schutz einen PIN-Code f√ºr die Eingabe festzulegen.  Schauen wir uns die h√§ufigsten Fehler an: <br><br><ul><li>  Senden eines PIN-Codes an die API zusammen mit RefreshToken, um die Authentifizierung zu best√§tigen und neue Token zu erhalten.  - Schlecht, das RefreshToken ist im lokalen Speicher unsicher. Mit physischem Zugriff auf das Ger√§t oder die Sicherung k√∂nnen Sie es extrahieren und die Malware kann es tun. </li><li> Speichern des PIN-Codes in der Nachricht mit RefreshToken, anschlie√üende lokale √úberpr√ºfung des PIN-Codes und Senden des RefreshToken an die API.  - RefreshToken ist ein Albtraum und zusammen mit dem Pin unsicher. Dadurch k√∂nnen sie extrahiert werden. Au√üerdem wird ein weiterer Vektor angezeigt, der darauf hindeutet, die lokale Authentifizierung zu umgehen. </li><li>  Schlechte RefreshToken-Verschl√ºsselung mit einem PIN-Code, mit dem Sie den PIN-Code und RefreshToken aus dem Chiffretext wiederherstellen k√∂nnen.  - Ein Sonderfall eines fr√ºheren Fehlers, etwas komplizierter ausgenutzt.  Beachten Sie jedoch, dass dies der richtige Weg ist. </li></ul><br>  Nachdem Sie sich die h√§ufigsten Fehler angesehen haben, k√∂nnen Sie die Logik der sicheren Speicherung von Token in Ihrer Anwendung durchdenken.  Es lohnt sich, mit den grundlegenden Ressourcen zu beginnen, die mit der Authentifizierung / Autorisierung w√§hrend des Betriebs der Anwendung verbunden sind, und einige Anforderungen an diese zu stellen: <br><br>  <b>Anmeldeinformationen</b> - (Benutzername + Passwort) - werden verwendet, um den Benutzer im System zu authentifizieren. <br>  + Das Passwort wird niemals auf dem Ger√§t gespeichert und sollte sofort nach dem Senden an die API aus dem RAM gel√∂scht werden <br>  + werden von der GET-Methode nicht in Abfrageparametern der HTTP-Anforderung √ºbertragen, stattdessen werden POST-Anforderungen verwendet <br>  + Der Tastaturcache ist f√ºr die Kennwortverarbeitung von Textfeldern deaktiviert <br>  + Zwischenablage ist f√ºr Textfelder deaktiviert, die ein Passwort enthalten <br>  + Passwort wird nicht √ºber die Benutzeroberfl√§che bekannt gegeben (sie verwenden Sternchen), auch das Passwort kommt nicht in Screenshots <br><br>  <b>AccessToken</b> - wird verwendet, um die Benutzerautorisierung zu best√§tigen. <br>  + nie im Langzeitspeicher und nur im RAM gespeichert <br>  + werden von der GET-Methode nicht in Abfrageparametern der HTTP-Anforderung √ºbertragen, stattdessen werden POST-Anforderungen verwendet <br><br>  <b>RefreshToken</b> - wird verwendet, um ein neues AccessToken + RefreshToken-Bundle abzurufen. <br>  + wird in keiner Form im RAM gespeichert und sollte sofort nach dem Empfang von der API und dem Speichern im Langzeitspeicher oder nach dem Empfang aus dem Langzeitspeicher und der Verwendung aus dem RAM entfernt werden <br>  + nur in verschl√ºsselter Form im Langzeitged√§chtnis gespeichert <br>  + mit einer PIN unter Verwendung von Magie und bestimmten Regeln verschl√ºsselt (die Regeln werden unten beschrieben). Wenn die PIN nicht festgelegt wurde, wird sie √ºberhaupt nicht gespeichert <br>  + werden von der GET-Methode nicht in Abfrageparametern der HTTP-Anforderung √ºbertragen, stattdessen werden POST-Anforderungen verwendet <br><br>  <b>PIN</b> - (normalerweise eine 4- oder 6-stellige Nummer) - wird zum Ver- / Entschl√ºsseln des RefreshToken verwendet. <br>  + Niemals irgendwo auf dem Ger√§t gespeichert und sollte nach Gebrauch sofort aus dem RAM gel√∂scht werden <br>  + verl√§sst nie die Anwendungsgrenzen, diese werden nirgendwo √ºbertragen <br>  + wird nur zur Ver- / Entschl√ºsselung von RefreshToken verwendet <br><br>  <b>OTP</b> ist ein einmaliger Code f√ºr 2FA. <br>  + OTP wird niemals auf dem Ger√§t gespeichert und sollte sofort nach dem Senden an die API aus dem RAM gel√∂scht werden <br>  + werden von der GET-Methode nicht in Abfrageparametern der HTTP-Anforderung √ºbertragen, stattdessen werden POST-Anforderungen verwendet <br>  + Tastatur-Cache f√ºr Textfelder, die OTP verarbeiten, deaktiviert <br>  + Zwischenablage f√ºr Textfelder, die OTP enthalten, deaktiviert <br>  + OTP kommt nicht in Screenshots <br>  + Die Anwendung entfernt OTP vom Bildschirm, wenn es in den Hintergrund geht <br><br>  Kommen wir nun zur <s>Magie der</s> Kryptographie.  Die Hauptanforderung besteht darin, dass Sie unter keinen Umst√§nden die Implementierung eines solchen RefreshToken-Verschl√ºsselungsmechanismus zulassen sollten, mit dem Sie das Entschl√ºsselungsergebnis lokal validieren k√∂nnen.  Das hei√üt, wenn ein Angreifer den Chiffretext in Besitz genommen hat, sollte er den Schl√ºssel nicht abholen k√∂nnen.  Der einzige Validator sollte die API sein.  Dies ist die einzige M√∂glichkeit, Schl√ºsselauswahlversuche einzuschr√§nken und Token im Falle eines Brute-Force-Angriffs ung√ºltig zu machen. <br><br>  Ich werde ein gutes Beispiel geben, sagen wir, wir wollen die UUID verschl√ºsseln <br><blockquote>  aec27f0f-b8a3-43cb-b076-e075a095abfe </blockquote>  mit diesem Satz von AES / CBC / PKCS5Padding unter Verwendung einer PIN als Schl√ºssel.  Es scheint, dass der Algorithmus gut ist, alles basiert auf Richtlinien, aber es gibt einen entscheidenden Punkt - der Schl√ºssel enth√§lt sehr wenig Entropie.  Mal sehen, wozu das f√ºhrt: <br><br><ol><li>  Auff√ºllen - Da unser Token 36 Bytes belegt und AES ein Blockverschl√ºsselungsmodus mit einem Block von 128 Bit ist, muss der Algorithmus das Token mit bis zu 48 Bytes (was ein Vielfaches von 128 Bit ist) beenden.  In unserer Version wird der Schwanz gem√§√ü dem PKCS5Padding-Standard hinzugef√ºgt, d. H.  Der Wert jedes hinzugef√ºgten Bytes entspricht der Anzahl der hinzugef√ºgten Bytes <br><blockquote>  01 <br>  02 02 <br>  03 03 03 <br>  04 04 04 04 <br>  05 05 05 05 05 <br>  06 06 06 06 06 06 <br>  usw. </blockquote>  Unser letzter Block wird ungef√§hr so ‚Äã‚Äãaussehen: <br><blockquote>  ... |  61 62 66 65 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C | </blockquote>  Und es gibt ein Problem, wenn wir uns diese Auff√ºllung ansehen, k√∂nnen wir die Daten (nach dem ung√ºltigen letzten Block) herausfiltern, die mit dem falschen Schl√ºssel entschl√ºsselt wurden, und dadurch das g√ºltige RefreshToken aus dem verdrehten Heap ermitteln. </li><li>  Vorhersagbares Format des Tokens - Selbst wenn wir unser Token auf ein Vielfaches von 128 Bit einstellen (z. B. Bindestriche entfernen), um das Hinzuf√ºgen von Auff√ºllungen zu vermeiden, werden wir auf das folgende Problem sto√üen.  Das Problem ist, dass wir alle denselben verdrehten Heap sammeln k√∂nnen, um festzustellen, welcher unter das UUID-Format f√§llt.  Die UUID in ihrer kanonischen Textform besteht aus 32 Ziffern im Hexadezimalformat, die durch einen Bindestrich in 5 Gruppen 8-4-4-4-12 getrennt sind <br>  xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx <br>  Dabei ist M die Version und N die Option.  All dies reicht aus, um mit dem falschen Schl√ºssel entschl√ºsselte Token herauszufiltern und ein geeignetes UUID RefreshToken-Format zu erhalten. </li></ol><br>  In Anbetracht all der oben genannten Punkte k√∂nnen Sie mit der Implementierung fortfahren. Ich habe eine einfache Option ausgew√§hlt, um 64 zuf√§llige Bytes zu generieren und sie in base64 zu verpacken: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createRefreshToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] refreshToken = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">64</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); secureRandom.nextBytes(refreshToken); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Base64.getUrlEncoder().withoutPadding() .encodeToString(refreshToken); }</code> </pre>  Hier ist ein Beispiel f√ºr ein solches Token: <br><blockquote>  YmI8rF9pwB1KjJAZKY9JzqsCu3kFz4xt4GkRCzXS9-FS_kbN3-CF9RGiRuuGqwqMo-VxFDhgQNmgjlQFD2GvbA </blockquote>  Nun wollen wir sehen, wie es algorithmisch aussieht (unter Android und iOS ist der Algorithmus der gleiche): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String ALGORITHM = <span class="hljs-string"><span class="hljs-string">"AES"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String CIPHER_SUITE = <span class="hljs-string"><span class="hljs-string">"AES/CBC/NoPadding"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> AES_KEY_SIZE = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> AES_BLOCK_SIZE = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encryptToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String token, String pin)</span></span></span><span class="hljs-function"> </span></span>{ decodedToken = decodeToken(token); <span class="hljs-comment"><span class="hljs-comment">//   rawPin = pin.getBytes(); byte[] iv = generate(AES_BLOCK_SIZE); //      CBC byte[] salt = generate(AES_KEY_SIZE); //       byte[] key = kdf.deriveKey(rawPin, salt, AES_KEY_SIZE); //  -    Cipher cipher = Cipher.getInstance(CIPHER_SUITE); //    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, ALGORITHM), new IvParameterSpec(iv)); return cipher.doFinal(token); } public byte[] decodeToken(String token) { byte[] rawToken = token.getBytes(); return Base64.getUrlDecoder().decode(rawToken); } public final byte[] generate(int size) { byte[] random = new byte[size]; (new SecureRandom()).nextBytes(random); return random; }</span></span></code> </pre><br>  Welche Zeilen sind es wert, beachtet zu werden: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String CIPHER_SUITE = <span class="hljs-string"><span class="hljs-string">"AES/CBC/NoPadding"</span></span>;</code> </pre><br>  Keine Polsterung, na ja, du erinnerst dich. <br><br><pre> <code class="java hljs">decodedToken = decodeToken(token); <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br>  Sie k√∂nnen ein Token in der base64-Darstellung nicht einfach nehmen und verschl√ºsseln, da diese Darstellung ein bestimmtes Format hat (Sie erinnern sich). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] key = kdf.deriveKey(rawPin, salt, AES_KEY_SIZE); <span class="hljs-comment"><span class="hljs-comment">//  -   </span></span></code> </pre><br>  Am Ausgang erhalten wir einen Schl√ºssel der Gr√∂√üe AES_KEY_SIZE, der f√ºr den AES-Algorithmus geeignet ist.  Jede von Argon2, SHA-3, Scrypt empfohlene Schl√ºsselableitungsfunktion kann im Falle eines schlechten Lebens als kdf verwendet werden (pbkdf2) (dies entspricht sehr gut den FPGAs). <br><br>  Das endg√ºltige verschl√ºsselte Token kann sicher auf dem Ger√§t gespeichert werden, ohne dass jemand es stehlen muss, sei es eine Malware oder eine Entit√§t, die nicht durch moralische Prinzipien belastet ist. <br><br>  Einige weitere Empfehlungen: <br><br><ul><li>  Token von Backups ausschlie√üen. </li><li>  Speichern Sie das Token unter iOS im Schl√ºsselbund mit dem Attribut kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly. </li><li>  Verteilen Sie die in diesem Artikel beschriebenen Elemente (Schl√ºssel, PIN, Kennwort usw.) nicht in der gesamten Anwendung. </li><li>  √úberschreiben Sie Assets, sobald sie unn√∂tig werden. Speichern Sie sie nicht l√§nger als n√∂tig in Ihrem Speicher. </li><li>  Verwenden Sie SecureRandom unter Android und SecRandomCopyBytes unter iOS, um zuf√§llige Bytes in einem kryptografischen Kontext zu generieren. </li></ul><br>  Wir haben beim Speichern von Token eine Reihe von Fallstricken untersucht, die meiner Meinung nach jeder Person bekannt sein sollten, die Anwendungen entwickelt, die mit kritischen Daten arbeiten.  Dieses Thema, in dem Sie bei jedem Schritt verwirrt werden k√∂nnen, wenn Sie Fragen haben, stellen Sie diese in den Kommentaren.  Kommentare zum Text sind ebenfalls willkommen. <br><br>  Referenzen: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-311: Fehlende Verschl√ºsselung sensibler Daten</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-327: Verwendung eines kaputten oder riskanten kryptografischen Algorithmus</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-327: CWE-338: Verwendung eines kryptografisch schwachen Pseudozufallszahlengenerators (PRNG)</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-598: Offenlegung von Informationen durch Abfragezeichenfolgen in der GET-Anforderung</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423753/">https://habr.com/ru/post/de423753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423743/index.html">Unter Kontrolle: VDS Server Disk Monitor Tool</a></li>
<li><a href="../de423745/index.html">Verwenden von Python zum Analysieren der erforderlichen Anforderungen an Entwickler</a></li>
<li><a href="../de423747/index.html">Neue Entwicklungstools mit LEGO Education - von Microsoft, MIT und mehr</a></li>
<li><a href="../de423749/index.html">8 einfache Schritte zum Scheitern eines unerfahrenen Entwicklungsmanagers</a></li>
<li><a href="../de423751/index.html">Java f√ºr Playstation 2 - ist das m√∂glich?</a></li>
<li><a href="../de423759/index.html">Fintech-Digest: Pers√∂nliche Daten von B√ºrgern der Russischen F√∂deration, Marktplatz der Zentralbank, ein neuer Dienst von CloudFlare</a></li>
<li><a href="../de423763/index.html">Was Uber Cash Innovatoren lehrt</a></li>
<li><a href="../de423765/index.html">Wir schreiben eine Anwendung zur Fernsteuerung des MPV-Players von RetroOrangePi</a></li>
<li><a href="../de423767/index.html">Hacker griffen British Airways an: 380.000 Kundenbankkarten gestohlen</a></li>
<li><a href="../de423769/index.html">OpenSSL mit Mono verbinden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>