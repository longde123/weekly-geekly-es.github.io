<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🌾 👩🏿‍🏭 🏎️ Membangun serverless Anda sendiri berdasarkan Fn 🚳 👩🏼‍🤝‍👨🏿 ✌🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Komputasi tanpa server adalah salah satu tren yang paling terlihat dalam komputasi awan. Prinsip dasar kerja adalah bahwa infrastruktur bukan urusan D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membangun serverless Anda sendiri berdasarkan Fn</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/475044/"><p><img src="https://habrastorage.org/webt/q4/8m/gj/q48mgjqsr4hbppglzpibvajf8xw.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komputasi tanpa server</a> adalah salah satu tren yang paling terlihat dalam komputasi awan.  Prinsip dasar kerja adalah bahwa infrastruktur bukan urusan DevOps, tetapi penyedia layanan.  Penskalaan sumber daya secara otomatis beradaptasi dengan beban dan memiliki tingkat perubahan yang tinggi. </p><br><p>  Fitur umum lainnya adalah kecenderungan untuk meminimalkan dan memfokuskan kode, sehingga komputasi tanpa server terkadang disebut "berfungsi sebagai layanan" (FaaS). </p><a name="habracut"></a><br><p>  Secara historis, penyedia layanan cloud pertama yang menawarkan FaaS dengan AWS Lambda adalah Amazon, dari mana asalnya.  Penyedia layanan cloud lainnya juga menawarkan analog: </p><br><ul><li>  Fungsi Google Cloud </li><li>  Fungsi Azure dari Microsoft </li></ul><br><p>  Semua perusahaan ini menyediakan komputasi tanpa server, penskalaan otomatis, dan membayar hanya untuk sumber daya yang benar-benar digunakan, tetapi pada saat yang sama mereka mengikat pelanggan ke produk eksklusif mereka.  Namun, ada alternatif open source gratis untuk komputasi tanpa server.  Perlu dicatat: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Platform Apache OpenWhisk</a> , yang dikembangkan oleh IBM di inkubator, </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spring Cloud Functions</a> , sebagai bagian dari ekosistem Spring Framework yang cukup kaya, yang juga dapat digunakan sebagai fasad AWS Lambda, Azure Functions, dan OpenWhisk, </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proyek Fn</a> didukung oleh Oracle. </li></ul><br><p>  Semuanya sepenuhnya independen dari awan, yaitu, mereka dipasang di cloud apa pun, termasuk milik Anda, publik atau pribadi, dan tentu saja di Exoscale. </p><br><h2 id="kak-proekt-fn-ustroen">  Bagaimana proyek Fn bekerja </h2><br><p>  Fn sepenuhnya berdasarkan pada Docker, terdiri dari dua komponen utama: </p><br><ul><li>  Program CLI dirancang untuk mengelola semua aspek infrastruktur Fn, dan berinteraksi dengan server Fn, </li><li>  Sebenarnya server Fn, aplikasi yang biasa dikemas dalam wadah untuk Docker. </li></ul><br><p>  Fungsi yang digunakan dalam Fn juga dilakukan dalam wadah terpisah, yang memungkinkan Anda untuk mendukung banyak bahasa pemrograman, misalnya ... Clojure! </p><br><p>  Argumen fungsi ditransfer ke input standar (STDIN), hasilnya ditulis ke output standar (STDOUT).  Jika argumen atau nilai kembali bukan nilai sederhana (misalnya, objek JSON), mereka dapat ditransformasikan menggunakan lapisan abstraksi yang disediakan oleh Fn sendiri sebagai kit pengembangan fungsi (FDK). </p><br><p>  Untuk kenyamanan, templat bawaan tersedia untuk memfasilitasi penyebaran FaaS dalam daftar lengkap berbagai bahasa dan versinya (Go, berbagai versi Java, Python, dll.). </p><br><p>  Membuat FaaS mudah dengan mengikuti pola ini: </p><br><ul><li>  Kami menyebarkan fungsi menggunakan CLI Fn: file konfigurasi aplikasi untuk Fn dibuat, berdasarkan pada templat yang dipilih. </li><li> Kami meluncurkan fungsi kami sendiri, lagi-lagi menggunakan CLI Fn: gambar kontainer ditempatkan di repositori tertentu, setelah itu server diberitahu tentang keberadaan dan penempatan gambar ini. </li></ul><br><p><img src="https://habrastorage.org/webt/_0/ds/if/_0dsifqshganceaz5pks7ixl9gs.jpeg"><br>  <em>Prinsip Pengiriman Fungsi di Fn</em> </p><br><h2 id="lokalnaya-ustanovka-i-testirovanie-besservernyh-funkciy">  Instalasi lokal dan pengujian fungsi tanpa server </h2><br><p>  Kami melanjutkan untuk menginstal Fn di mesin lokal.  Docker diinstal terlebih dahulu, seperti yang diminta oleh Fn.  Kita seharusnya menggunakan Debian / Ubuntu: </p><br><pre><code class="plaintext hljs">$ sudo apt-get update $ sudo apt-get install docker.io</code> </pre> <br><p>  Baik, atau gunakan paket manager / Docker build sesuai dengan sistem Anda.  Kemudian Anda dapat langsung menuju instalasi Fn CLI.  Misalnya, menggunakan ikal: </p><br><pre> <code class="plaintext hljs">$ curl -LSs https://raw.githubusercontent.com/fnproject/cli/master/install | sh</code> </pre> <br><p>  Jika Anda menjalankan OSX dengan Homebrew terinstal, Anda dapat memilih cara lain: </p><br><pre> <code class="plaintext hljs">$ brew install fn ==&gt; Downloading https://homebrew.bintray.com/bottles/fn-0.5.8.high_sierra.bottle.tar.gz ==&gt; Downloading from https://akamai.bintray.com/b1/b1767fb00e2e69fd9da73427d0926b1d1d0003622f7ddc0dd3a899b2894781ff?__gda__=exp=1538038849~hmac=c702c9335e7785fcbacad1f29afa61244d02f2eebb ######################################################################## 100.0% ==&gt; Pouring fn-0.5.8.high_sierra.bottle.tar.gz /usr/local/Cellar/fn/0.5.8: 5 files, 16.7MB</code> </pre> <br><p>  Sekarang semuanya siap untuk penyebaran awal fungsi kita menggunakan CLI.  Untuk kesederhanaan, kami akan menggunakan lingkungan bawaan untuk menjalankan, misalnya, Node: </p><br><pre> <code class="plaintext hljs">$ fn init --runtime node --trigger http hellonode Creating function at: /hellonode Function boilerplate generated. func.yaml created.</code> </pre> <br><p>  Direktori <code>hellonode</code> baru akan dibuat untuk lebih mengembangkan fungsi Fn kami dengan beberapa file konfigurasi dasar.  Di dalam direktori yang baru dibuat, Anda dapat membuat aplikasi yang mengikuti standar bahasa atau runtime yang Anda pilih: </p><br><pre> <code class="plaintext hljs">#   node  : hellonode ├── func.js ├── func.yaml └── package.json #   Java11 : hellojava11 ├── func.yaml ├── pom.xml └── src ├── main │ └── java │ └── com │ └── example │ └── fn │ └── HelloFunction.java └── test └── java └── com └── example └── fn └── HelloFunctionTest.java</code> </pre> <br><p>  Fn membuat struktur proyek awal, membuat file <code>func.yaml</code> berisi pengaturan yang diperlukan untuk Fn, dan menginstal templat untuk kode dalam bahasa yang Anda pilih. </p><br><p>  Dalam kasus runtime Node, ini berarti: </p><br><pre> <code class="plaintext hljs">$ cat hellonode/func.js const fdk=require('@fnproject/fdk'); fdk.handle(function(input){ let name = 'World'; if (input.name) { name = input.name; } return {'message': 'Hello ' + name} })</code> </pre> <br><p>  Sekarang kita akan cepat memeriksa fungsi kita secara lokal untuk melihat bagaimana semuanya bekerja </p><br><p>  Pertama, kita akan memulai server Fn.  Seperti yang telah disebutkan, server Fn adalah wadah Docker, oleh karena itu, setelah memulainya akan pergi dan mengambil gambar dari registri Docker. </p><br><pre> <code class="plaintext hljs">$ fn start -d #      Unable to find image 'fnproject/fnserver:latest' locally latest: Pulling from fnproject/fnserver ff3a5c916c92: Pull complete 1a649ea86bca: Pull complete ce35f4d5f86a: Pull complete ... Status: Downloaded newer image for fnproject/fnserver:latest 668ce9ac0ed8d7cd59da49228bda62464e01bff2c0c60079542d24ac6070f8e5</code> </pre> <br><p>  Untuk menjalankan fungsi kami, Anda harus menjalankannya.  Ini membutuhkan <code> </code> : di Fn, semua aplikasi harus didefinisikan sebagai ruang nama untuk fungsi terkait. </p><br><p>  Fn CLI akan mencari file <code>func.yaml</code> di direktori saat ini, yang akan digunakan untuk mengkonfigurasi fungsi.  Jadi pertama-tama Anda harus pergi ke direktori <code>hellonode</code> kami. </p><br><pre> <code class="plaintext hljs">$ cd hellonode $ fn deploy --app fnexo --local #   ,   - fnexo. #  local      , #    Deploying hellonode to app: fnexo Bumped to version 0.0.2 Building image nfrankel/hellonode:0.0.3 . Updating function hellonode using image nfrankel/hellonode:0.0.3... Successfully created app: fnexo Successfully created function: hellonode with nfrankel/hellonode:0.0.3 Successfully created trigger: hellonode-trigger</code> </pre> <br><p>  Seperti yang dapat Anda lihat dari output perintah, gambar kontainer baru untuk Docker dibuat yang berisi fungsi kami.  Fungsi siap dipanggil, dan kami memiliki dua cara untuk melakukan ini: </p><br><ul><li>  menggunakan perintah fn <code>invoke</code> </li><li>  menelepon langsung melalui <code>http</code> </li></ul><br><p>  Memanggil <code>invoke</code> melalui Fn hanya mengemulasi pekerjaan HTTP untuk tes, yang nyaman untuk verifikasi cepat: </p><br><pre> <code class="plaintext hljs">$ fn invoke fnexo hellonode #   hellonode  fnexo {"message":"Hello World"}</code> </pre> <br><p>  Untuk memanggil fungsi secara langsung, Anda perlu mengetahui URL lengkap: </p><br><pre> <code class="plaintext hljs">$ curl http://localhost:8080/t/fnexo/hellonode-trigger {"message":"Hello World"}</code> </pre> <br><p>  Server Fn menyediakan fungsinya melalui port 8080, dan tampaknya URL fungsi tersebut cocok dengan skema <code>t/app/function</code> , tetapi tidak sepenuhnya.  Melalui HTTP, fungsi tidak dipanggil secara langsung, tetapi melalui pemicu yang disebut, yang, sesuai namanya, "meluncurkan" panggilan fungsi.  Pemicu didefinisikan dalam proyek <code>`func.yml</code> : </p><br><pre> <code class="plaintext hljs">schema_version: 20180708 name: hellonode version: 0.0.3 runtime: node entrypoint: node func.js format: json triggers: - name: hellonode-trigger type: http source: /hellonode-trigger # URL </code> </pre> <br><p>  Kami dapat mengubah nama pemicu sehingga cocok dengan nama fungsi, ini akan menyederhanakan semuanya: </p><br><pre> <code class="plaintext hljs">triggers: - name: hellonode-trigger type: http source: /hellonode #    </code> </pre> <br><p>  Kemudian kami memulai pengiriman fungsi lagi dan menyebutnya dari pemicu baru: </p><br><pre> <code class="plaintext hljs">$ fn deploy --app fnexo hellonode --local $ curl http://localhost:8080/t/fnexo/hellonode {"message":"Hello World"}</code> </pre> <br><p>  Semuanya bekerja!  Sudah waktunya untuk pergi ke percobaan skala penuh dan menerbitkan FaaS kami di server! </p><br><h2 id="ustanovka-servisov-besservernyh-funkciy-na-sobstvennoy-infrastrukture">  Menginstal layanan fungsi tanpa server pada infrastruktur Anda sendiri </h2><br><p>  Mari kita cepat menginstal mesin virtual menggunakan CLI Exoscale.  Jika Anda belum mengaturnya, Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan kami untuk meluncurkannya dengan cepat</a> .  Ini adalah alat keren yang selanjutnya akan meningkatkan produktivitas Anda.  <strong>Jangan lupa bahwa Anda perlu mengonfigurasi aturan untuk membuka port 8080 di Grup Keamanan!</strong>  Perintah berikut akan meluncurkan mesin virtual bersih, siap untuk meng-host fitur kami: </p><br><pre> <code class="plaintext hljs">$ exo firewall create fn-securitygroup $ exo firewall add fn-securitygroup ssh --my-ip $ exo firewall add fn-securitygroup -p tcp -P 8080-8080 -c 0.0.0.0/0 $ exo vm create fn-server -s fn-securitygroup</code> </pre> <br><p>  Kemudian Anda dapat ssh ke mesin virtual dan menginstal server Fn jarak jauh: </p><br><pre> <code class="plaintext hljs">$ exo ssh fn-server The authenticity of host '185.19.30.175 (185.19.30.175)' can't be established. ECDSA key fingerprint is SHA256:uaCKRYeX4cvim+Gr8StdPvIQ7eQgPuOKdnj5WI3gI9Q. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '185.19.30.175' (ECDSA) to the list of known hosts. Welcome to Ubuntu 18.04 LTS (GNU/Linux 4.15.0-20-generic x86_64)</code> </pre> <br><p>  Kemudian instal Docker dan server Fn dengan cara yang sama seperti yang kami lakukan pada mesin lokal, mulai server: </p><br><pre> <code class="plaintext hljs">$ sudo apt-get update $ sudo apt-get install docker.io $ sudo systemctl start docker $ curl -LSs https://raw.githubusercontent.com/fnproject/cli/master/install | sh $ sudo fn start ... ______ / ____/___ / /_ / __ \ / __/ / / / / /_/ /_/ /_/ v0.3.643</code> </pre> <br><p>  Fn siap untuk fitur!  Untuk transfer fungsi yang ditargetkan ke server jarak jauh, kami akan menggunakan perintah <code>deploy</code> dari komputer lokal, menghilangkan flag <code>--local</code> . </p><br><p>  Selain itu, Fn mengharuskan Anda untuk menentukan lokasi server Fn dan registri Docker.  Parameter ini dapat diatur melalui variabel lingkungan <code>FN_API_URL</code> dan <code>FN_REGISTRY</code> masing-masing, tetapi ditawarkan cara yang lebih mudah untuk mengelola pembuatan dan pengelolaan konfigurasi untuk penempatan dengan mudah. </p><br><p>  Dalam hal Fn, konfigurasi untuk penyebaran disebut <code>context</code> .  Perintah berikut akan membuat konteks: </p><br><pre> <code class="plaintext hljs">$ fn create context exoscale --provider default --api-url http://185.19.30.175:8080 --registry nfrankel</code> </pre> <br><p>  Anda dapat melihat konteks yang tersedia seperti ini: </p><br><pre> <code class="plaintext hljs">$ fn list contexts CURRENT NAME PROVIDER API URL REGISTRY default default http://localhost:8080/ exoscale default http://185.19.30.175:8080 nfrankel</code> </pre><br><p>  Dan beralihlah ke konteks yang baru saja dibuat, seperti ini: </p><br><pre> <code class="plaintext hljs"> $ fn use context exoscale Now using context: exoscale</code> </pre> <br><p>  Mulai saat ini, memasok fungsi Fn akan mengunggah gambar Docker menggunakan akun yang dipilih di DockerHub (dalam kasus saya, <code>nfrankel</code> ), dan kemudian memberi tahu server jarak jauh (dalam contoh ini, <code>http://185.19.30.175:8080</code> ) tentang lokasi dan versi Gambar terakhir berisi fungsi Anda. </p><br><pre> <code class="plaintext hljs">$ fn deploy --app fnexo . #       hellonode Deploying function at: /. Deploying hellonode to app: fnexo Bumped to version 0.0.5 Building image nfrankel/hellonode:0.0.5 .</code> </pre> <br><p>  Akhirnya: </p><br><pre> <code class="plaintext hljs">$ curl http://185.19.30.175:8080/t/fnexo/hellonode {"message":"Hello World"}</code> </pre> <br><p><img src="https://habrastorage.org/webt/vl/8c/mt/vl8cmtjvwj7t9tazi7mlaaexoxi.jpeg"><br>  <em>Fungsi siklus hidup dalam komputasi tanpa server berdasarkan Fn</em> </p><br><h2 id="preimuschestva-besservernyh-vychisleniy-na-svoih-moschnostyah">  Keuntungan dari komputasi tanpa server di fasilitasnya </h2><br><p>  Komputasi tanpa server adalah solusi yang mudah untuk mengimplementasikan bagian aplikasi independen yang berinteraksi dengan aplikasi atau layanan mikro yang lebih kompleks. </p><br><p>  Seringkali ini disebabkan oleh biaya tersembunyi dari pengikatan ke pemasok yang dipilih, yang, tergantung pada kasus penggunaan dan volume tertentu, dapat menyebabkan biaya lebih tinggi dan mengurangi fleksibilitas di masa depan. </p><br><p>  Arsitektur multi-cloud dan hybrid cloud juga menderita dalam kasus ini, karena Anda dapat dengan mudah menemukan diri Anda dalam situasi di mana Anda ingin menggunakan komputasi tanpa server, tetapi karena kebijakan perusahaan ini tidak mungkin. </p><br><p>  Fn cukup sederhana untuk bekerja, ia dapat memberikan antarmuka FaaS yang hampir sama, dengan biaya rendah.  Ini menghilangkan ikatan apa pun kepada penyedia, Anda dapat menginstalnya secara lokal atau di penyedia solusi cloud yang nyaman pilihan Anda.  Ada juga kebebasan dalam memilih bahasa pemrograman. </p><br><p>  Hanya dasar-dasar Fn yang disajikan dalam artikel, tetapi membuat runtime Anda sendiri cukup sederhana, dan arsitektur umum dapat diperluas lebih luas menggunakan penyeimbang beban Fn, atau dengan menempatkan Fn di belakang proxy untuk perlindungan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475044/">https://habr.com/ru/post/id475044/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475028/index.html">Pengamatan tentang penerapan ML dalam bisnis pada saham ŽijemeIT</a></li>
<li><a href="../id475032/index.html">Gartner Hype Cycle 2019: tanya jawab</a></li>
<li><a href="../id475034/index.html">Grafik di browser untuk Arduino dan STM32</a></li>
<li><a href="../id475036/index.html">Migrasi Cassandra ke Kubernetes: fitur dan solusi</a></li>
<li><a href="../id475038/index.html">Set pertama "Matematika Terapan dan Ilmu Komputer" di St. Petersburg HSE: siapa mereka dan bagaimana cara bekerja dengannya?</a></li>
<li><a href="../id475046/index.html">Apakah akhirnya membenarkan cara? (!) SEO hitam dan abu-abu</a></li>
<li><a href="../id475048/index.html">Penjelasan uji hipotesis intuitif dan nilai-p</a></li>
<li><a href="../id475050/index.html">ESports - mainkan, mainkan</a></li>
<li><a href="../id475058/index.html">Kota tertidur, warga Habrovsk bangun</a></li>
<li><a href="../id475060/index.html">Membuat layanan pelacakan panggilan sederhana, bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>