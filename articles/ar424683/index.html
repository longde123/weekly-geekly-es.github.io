<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍡 ☝🏽 🕠 90 ميزات جديدة (وواجهات برمجة التطبيقات) في JDK 11 💄 👹 🍥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مرحبا يا هبر! أقدم لكم ترجمة المقال " 90 ميزات جديدة (وواجهات برمجة تطبيقات) في JDK 11 " بقلم سايمون ريتر. 





 بالنسبة للكثيرين ، تعني دورة إصدار J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>90 ميزات جديدة (وواجهات برمجة التطبيقات) في JDK 11</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424683/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  مرحبا يا هبر!  أقدم لكم ترجمة المقال " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">90 ميزات جديدة (وواجهات برمجة تطبيقات) في JDK 11</a> " بقلم سايمون ريتر. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/nz/8c/f_/nz8cf_erkk_q0xqhz_kptdl772s.jpeg"></p><br><p style=";text-align:right;direction:rtl">  بالنسبة للكثيرين ، تعني دورة إصدار JDK الجديدة التي مدتها ستة أشهر أن البعض لم يكتشف حتى الميزات الجديدة الموجودة في JDK 10 ، و JDK 11 على وشك. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">في إحدى المدونات المبكرة</a> ( <em>الإنجليزية</em> ) ، تم إدراج جميع الميزات الجديدة وواجهات برمجة التطبيقات الـ 109 التي تمكن من العثور عليها في JDK 10. لذلك ، بالنسبة لـ JDK 11 تقرر أن تفعل الشيء نفسه.  ومع ذلك ، تم اختيار تنسيق مختلف.  سيتم تقسيم هذه المشاركة إلى قسمين: الميزات الجديدة المتوفرة للمطورين (واجهة برمجة التطبيقات العامة) وكل شيء آخر.  وبالتالي ، إذا كنت مهتمًا فقط بما يؤثر بشكل مباشر على تطورك ، فيمكنك تخطي الجزء الثاني. </p><br><p style=";text-align:right;direction:rtl">  أصبح إجمالي عدد التغييرات التي يمكن حسابها 90 (هذا هو JEP بالإضافة إلى فئات وأساليب جديدة ، باستثناء الطرق المنفصلة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=http://openjdk.java.net/groups/net/">لعميل HTTP</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ومسجل Flight</a> ) ( <em>ملاحظة المترجم: Java Flight Recorder (JFR) كان أحد الإضافات المضمنة في Oracle في JDK ، ولكن بدءًا من Java 11 ، بفضل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 328</a> ، تم نقله إلى مصدر مفتوح)</em> .  على الرغم من أن JDK 11 تمكنت من العثور على أحد عشر تغييرًا أقل من JDK 10 ، أعتقد أنه من العدل القول أنه تمت إضافة المزيد من الوظائف إلى JDK 11 ، بالتأكيد على مستوى JVM. </p><a name="habracut"></a><br><h3 id="novye-zametnye-dlya-razrabotchika-fichi" style=";text-align:right;direction:rtl">  ميزات جديدة ملحوظة للمطور </h3><br><p style=";text-align:right;direction:rtl">  يحتوي JDK 11 على عدد قليل من التغييرات التي يمكن أن تؤثر على أسلوب التطوير.  هناك تغيير طفيف في البنية ، والعديد من واجهات برمجة التطبيقات الجديدة والقدرة على تشغيل التطبيقات في ملف واحد دون استخدام مترجم (مترجم <em>الملاحظة: ما يسمى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ملفات shebang</a></em> ).  بالإضافة إلى ذلك ، التغيير الكبير (والكسر) هو إزالة وحدة التجميع <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">java.se.ee</a></strong> ، والتي يمكن أن تؤثر على ترحيل تطبيق موجود إلى JDK 11. </p><br><p style=";text-align:right;direction:rtl">  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 323: تركيب متغير محلي لمعلمات لامدا</a></strong> </p><br><p style=";text-align:right;direction:rtl">  في JDK 10 ، تم إدخال الاستدلال المتغير المحلي (أو الاستدلال النوعي) ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 286</a> ).  يؤدي هذا إلى تبسيط الرمز لأنك لم تعد بحاجة إلى تحديد نوع المتغير المحلي بشكل صريح ، يمكنك استخدام <strong>var</strong> بدلاً من ذلك.  يوسع JEP 323 استخدام هذا النحو ، والذي ينطبق الآن أيضًا على معلمات تعبيرات لامدا.  مثال بسيط: </p><br><pre style=";text-align:right;direction:rtl"><code class="java hljs">list.stream() .map((<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s) -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p style=";text-align:right;direction:rtl">  قد يشير مبرمج Java اليقظ إلى أن تعبيرات lambda لها بالفعل نوع الاستدلال ، لذا فإن استخدام var سيكون (في هذه الحالة) زائدة عن الحاجة.  يمكننا بسهولة كتابة نفس الرمز كما يلي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> list.stream() .map(s -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p style=";text-align:right;direction:rtl">  لماذا تضيف دعم var؟  الجواب هو حالة خاصة واحدة - عندما تريد إضافة تعليق توضيحي إلى معلمة لامدا.  لا يمكن القيام بذلك دون أي نوع من المشاركة.  لتجنب استخدام نوع صريح ، يمكننا استخدام var لتبسيط الأشياء بهذه الطريقة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> list.stream() .map((<span class="hljs-meta"><span class="hljs-meta">@Notnull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s) -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p style=";text-align:right;direction:rtl">  يتطلب هذا التغيير إجراء تغييرات على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مواصفات لغة جافا (JLS)</a> ، على وجه الخصوص: </p><br><p style=";text-align:right;direction:rtl">  24 الصفحة: وصف معرف خاص var. <br>  627-630 الصفحة: معلمات لامدا <br>  636 الصفحة: تقييم وقت التشغيل لتعبيرات Lambda <br>  746 الصفحة: بناء الجملة لامدا </p><br><p style=";text-align:right;direction:rtl">  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 330: تشغيل برامج شفرة المصدر أحادية الملف</a></strong> </p><br><p style=";text-align:right;direction:rtl">  أحد الانتقادات لجافا هو تكرار بناء الجملة ، و "الحفل" المرتبط بإطلاق حتى تطبيق تافه يمكن أن يزيد بشكل خطير عتبة الدخول للمبتدئين.  لكتابة تطبيق يقوم ببساطة بطباعة "Hello World!" ، تحتاج إلى كتابة فئة باستخدام طريقة الفراغ الثابت العامة الرئيسية واستخدام الأسلوب System.out.println ().  بعد القيام بذلك ، يجب عليك تجميع الكود باستخدام جافا سكريبت.  أخيرًا ، يمكنك إطلاق تطبيق يرحب بالعالم.  يعد تشغيل نفس البرنامج النصي في معظم اللغات الحديثة أبسط وأسرع. </p><br><p style=";text-align:right;direction:rtl">  يلغي JEP 330 الحاجة إلى ترجمة تطبيق أحادي الملف.  أدخل الآن: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> java HelloWorld.java</code> </pre> <br><p style=";text-align:right;direction:rtl">  يحدد مشغل Java أن الملف يحتوي على كود مصدر Java ويجمع الكود في ملف * .class قبل تنفيذه. </p><br><p style=";text-align:right;direction:rtl">  الوسيطات الموضوعة بعد تمرير اسم الملف المصدر كوسيطات عند بدء تشغيل التطبيق.  الوسيطات الموضوعة قبل تمرير اسم الملف المصدر يتم تمريرها كوسيطات إلى مشغل جافا بعد تجميع الكود (هذا يسمح لك بتعيين أشياء مثل classpath على سطر الأوامر).  وسيجري أيضًا تمرير الحجج المتعلقة بالمترجم (مثل classpath) إلى جافا لتجميعها. </p><br><p style=";text-align:right;direction:rtl">  مثال: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> java -classpath /home/foo/java Hello.java Bonjour</code> </pre> <br><p style=";text-align:right;direction:rtl">  وستكون معادلة لما يلي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> javac -classpath /home/foo/java Hello.java java -classpath /home/foo/java Hello Bonjour</code> </pre> <br><p style=";text-align:right;direction:rtl">  يوفر JEP هذا أيضًا دعمًا لملفات shebang.  لتقليل الحاجة حتى إلى ذكر مشغل جافا في سطر الأوامر ، يمكنك تضمينه في السطر الأول من الملف المصدر.  على سبيل المثال: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> #!/usr/bin/java --source <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloWorld</span></span></span><span class="hljs-class"> </span></span>{ ...</code> </pre> <br><p style=";text-align:right;direction:rtl">  مطلوب علامة -source مع إصدار Java المستخدم. </p><br><p style=";text-align:right;direction:rtl">  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 321: عميل HTTP (قياسي)</a></strong> </p><br><p style=";text-align:right;direction:rtl">  قدم JDK 9 واجهة برمجة تطبيقات جديدة لدعم بروتوكول HTTP Client ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 110</a> ).  نظرًا لأن JDK 9 قدم نظام <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Java Platform Module System (JPMS)</a> ، فقد تم تضمين واجهة برمجة التطبيقات هذه كوحدة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">حاضنة</a> .  تم تصميم وحدات الحاضنة لتوفير واجهات برمجة تطبيقات جديدة ، ولكنها لا تحولها إلى معيار Java SE.  يمكن للمطورين تجربة واجهة برمجة التطبيقات من خلال تقديم التعليقات.  بعد إجراء التغييرات اللازمة (تم تحديث واجهة برمجة التطبيقات هذه في JDK 10) ، يمكن نقل واجهة برمجة التطبيقات إلى الوحدة الرئيسية لتصبح جزءًا من المعيار. </p><br><p style=";text-align:right;direction:rtl">  أصبحت واجهة برمجة تطبيقات عميل HTTP الآن جزءًا من معيار Java SE 11. وهذا يقدم وحدة وحزمة جديدة لـ JDK ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://download.java.net/java/early_access/jdk11/docs/api/java.net.">java.net.http</a> .  الفئات الرئيسية: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  Httpclient </li><li style=";text-align:right;direction:rtl">  Httprequest </li><li style=";text-align:right;direction:rtl">  HttpResponse </li><li style=";text-align:right;direction:rtl">  مأخذ الويب </li></ul><br><p style=";text-align:right;direction:rtl">  يمكن استخدام API بشكل متزامن أو غير متزامن.  في الوضع غير المتزامن ، يتم استخدام CompletionFutures و CompletionStages. </p><br><p style=";text-align:right;direction:rtl">  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 320: إزالة وحدات Java EE و CORBA</a></strong> </p><br><p style=";text-align:right;direction:rtl">  مع إدخال JPMS في JDK 9 ، كان من الممكن تقسيم ملف rt.jar المترابط إلى عدة وحدات.  تتمثل فائدة إضافية لـ JPMS في أنه يمكنك الآن إنشاء بيئة تشغيل Java تتضمن الوحدات النمطية اللازمة لتطبيقك فقط ، مما يقلل الحجم الإجمالي بشكل كبير.  بفضل الحدود المحددة بوضوح ، أصبح من السهل الآن إزالة الوحدات القديمة من Java API.  هذا ما يفعله هذا JEP.  تشتمل الوحدة الوصفية java.se.ee على ست وحدات لن تكون جزءًا من معيار Java SE 11 ولن يتم تضمينها في JDK. </p><br><p style=";text-align:right;direction:rtl">  الوحدات البعيدة: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  كوربا ( <em>ملاحظة المترجم:</em> <del>  <em>ارقد بسلام</em> </del>  <em>، يحترق في الجحيم</em> ) </li><li style=";text-align:right;direction:rtl">  الصفقة </li><li style=";text-align:right;direction:rtl">  التنشيط </li><li style=";text-align:right;direction:rtl">  xml.bind </li><li style=";text-align:right;direction:rtl">  xml.ws </li><li style=";text-align:right;direction:rtl">  xml.ws.nnotation </li></ul><br><p style=";text-align:right;direction:rtl">  تم وضع علامة على هذه الوحدات القديمة (Deprecated) منذ JDK 9 ولم يتم تضمينها بشكل افتراضي في الترجمة أو وقت التشغيل.  إذا حاولت ترجمة أو تشغيل تطبيق باستخدام واجهة برمجة التطبيقات من هذه الوحدات على JDK 9 أو JDK 10 ، فإنك ستفشل.  إذا كنت تستخدم واجهة برمجة التطبيقات من هذه الوحدات في التعليمات البرمجية ، فستحتاج إلى توفيرها كوحدة منفصلة أو مكتبة.  إذا حكمنا من خلال المراجعات ، فيبدو أن وحدات java.xml التي تعد جزءًا من دعم خدمات الويب JAX-WS و SOAP هي التي ستتسبب في معظم المشكلات. </p><br><h3 id="novyy-publichnyy-api" style=";text-align:right;direction:rtl">  واجهة برمجة تطبيقات عامة جديدة </h3><br><p style=";text-align:right;direction:rtl">  العديد من واجهات برمجة التطبيقات الجديدة في JDK 11 هي نتيجة حقيقة أن وحدة عميل HTTP هي الآن جزء من المعيار ، بالإضافة إلى تضمين Flight Recorder. </p><br><p style=";text-align:right;direction:rtl">  يمكن العثور على قائمة تخطيطية كاملة لتغييرات API ، بما في ذلك مقارنة الإصدارات المختلفة من JDK <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا.</a> </p><br><p style=";text-align:right;direction:rtl">  فيما يلي جميع الطرق الجديدة بخلاف تلك الموجودة في وحدتي java.net.http و jdk.jfr.  كما لم يتم سرد الطرق والفئات الجديدة في وحدات java.security ، وهي محددة تمامًا لتغييرات <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 324</a> و <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 329</a> (هناك ست فئات جديدة وثماني طرق جديدة). </p><br><h4 id="javaiobytearrayoutputstream" style=";text-align:right;direction:rtl">  java.io.ByteArrayOutputStream </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>void writeBytes (byte [])</strong> : يكتب كافة وحدات البايت من الوسيطة إلى OutputStream </li></ul><br><h4 id="javaiofilereader" style=";text-align:right;direction:rtl">  java.io.FileReader </h4><br><p style=";text-align:right;direction:rtl">  اثنين من الشركات الجديدة التي تتيح لك تحديد Charset. </p><br><h4 id="javaiofilewriter" style=";text-align:right;direction:rtl">  java.io.FileWriter </h4><br><p style=";text-align:right;direction:rtl">  أربعة منشئات جديدة تتيح لك تحديد Charset. </p><br><h4 id="javaioinputstream" style=";text-align:right;direction:rtl">  java.io.InputStream </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>io.InputStream nullInputStream ()</strong> : إرجاع InputStream الذي لا يقرأ وحدات البايت.  بالنظر إلى هذه الطريقة (والأخرى في OutputStream و Reader و Writer) ، يُطرح السؤال عن سبب كونها مفيدة.  يمكنك التفكير فيها على أنها <strong>/ dev / null</strong> - للتخلص من المخرجات التي لا تحتاجها ، أو لتقديم مدخلات ترجع دائمًا وحدات بايت فارغة. </li></ul><br><h4 id="javaiooutputstream" style=";text-align:right;direction:rtl">  java.io.OutputStream </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>io.OutputStream nullOutputStream ()</strong> </li></ul><br><h4 id="javaioreader" style=";text-align:right;direction:rtl">  java.io.Reader </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>io.Reader nullReader ()</strong> </li></ul><br><h4 id="javaiowriter" style=";text-align:right;direction:rtl">  java.io.Writer </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>io.Writer nullWriter ()</strong> </li></ul><br><h4 id="javalangcharacter" style=";text-align:right;direction:rtl">  java.lang.Character </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>String toString (int)</strong> : هذا هو شكل زائد من طريقة موجودة ، ولكن يتم استخدام int بدلاً من char.  Int هي نقطة رمز Unicode. </li></ul><br><h4 id="javalangcharsequence" style=";text-align:right;direction:rtl">  java.lang.CharSequence </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>int مقارنة (CharSequence ، CharSequence)</strong> : يقارن بين مثيلين من CharSequence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">معجميًا</a> .  إرجاع قيمة سالبة أو صفر أو قيمة موجبة إذا كان التسلسل الأول معجميًا أقل من المعجم أو مساوٍ له أو أكبر منه على التوالي. </li></ul><br><h4 id="javalangrefreference" style=";text-align:right;direction:rtl">  مرجع java.lang.ref </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>lang.Object clone ()</strong> : يجب أن أعترف أن هذا التغيير يسبب الارتباك.  لا تقوم الفئة المرجعية بتطبيق واجهة Cloneable ، وهذه الطريقة تطرح CloneNotSupportedException.  يجب أن يكون هناك سبب لإدراجه ، ربما لشيء ما في المستقبل.  ( <em>ملاحظة المترجم: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هناك مناقشة حول StackOverflow</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تذكرة في OpenJDK</a></em> ) </li></ul><br><h4 id="javalangruntime" style=";text-align:right;direction:rtl">  java.lang.Runtime </h4><br><h4 id="javalangsystem" style=";text-align:right;direction:rtl">  java.lang.System </h4><br><p style=";text-align:right;direction:rtl">  لا توجد طرق جديدة هنا ، ولكن تجدر الإشارة إلى أن طريقة <strong>runFinalizersOnExit ()</strong> تمت إزالتها الآن من كلا الفئتين (قد تكون هناك مشكلة عند الترحيل إلى JDK 11). </p><br><h4 id="javalangstring" style=";text-align:right;direction:rtl">  java.lang.String </h4><br><p style=";text-align:right;direction:rtl">  أعتقد أن هذا هو أحد أبرز واجهات برمجة التطبيقات الجديدة في JDK 11. هناك بعض الطرق الجديدة المفيدة هنا. </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>boolean isBlank ()</strong> : تُرجع true إذا كانت السلسلة فارغة أو تحتوي على مسافات فقط ، وإلا <strong>فستكون</strong> خاطئة. </li><li style=";text-align:right;direction:rtl">  <strong>خطوط الدفق ()</strong> : إرجاع الدفق من سلسلة ، المستخرجة من هذه السلسلة ، مفصولة بفواصل الأسطر. </li><li style=";text-align:right;direction:rtl">  <strong>Stringكرار (int)</strong> : ترجع سلسلة قيمتها سلسلة من هذه السلسلة ، مكررة عدة مرات. </li><li style=";text-align:right;direction:rtl">  <strong>String strip ()</strong> : إرجاع سلسلة قيمتها هذه السلسلة ، يزيل هذا كافة المسافات في بداية ونهاية السلسلة. </li><li style=";text-align:right;direction:rtl">  <strong>String stripLeading ()</strong> : تقوم بإرجاع سلسلة قيمتها هذه السلسلة ، مع إزالة كافة المسافات في بداية السطر. </li><li style=";text-align:right;direction:rtl">  <strong>String stripTrailing ()</strong> : إرجاع سلسلة قيمتها هذه السلسلة ، يؤدي هذا إلى إزالة كافة المسافات في نهاية السلسلة. </li></ul><br><p style=";text-align:right;direction:rtl">  على الأرجح ، أنظر إلى <strong>الشريط ()</strong> وتسأل: "كيف يختلف هذا عن طريقة <strong>القطع</strong> الحالية <strong>()</strong> ؟"  الجواب يكمن في الفرق في تحديد المساحات.  ( <em>ملاحظة المترجم: باختصار ، <strong>الشريط ()</strong> يفهم Unicode بشكل أفضل ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وتحليل مفصل على StackOverflow</a></em> ) </p><br><h4 id="javalangstringbuffer" style=";text-align:right;direction:rtl">  java.lang.StringBuffer </h4><br><h4 id="javalangstringbuilder" style=";text-align:right;direction:rtl">  java.lang.StringBuilder </h4><br><p style=";text-align:right;direction:rtl">  كل من هذه الفئات لديها أسلوب <strong>CompareTo ()</strong> جديد يأخذ StringBuffer / StringBuilder ويعيد int.  طريقة المقارنة المعجمية مشابهة لطريقة CompareTo <strong>()</strong> الجديدة في CharSequence. </p><br><h4 id="javalangthread" style=";text-align:right;direction:rtl">  جافا. لانج </h4><br><p style=";text-align:right;direction:rtl">  لا توجد طرق جديدة.  تمت إزالة <strong>طرق</strong> <strong>التدمير ()</strong> <strong>وإيقاف (الرمي)</strong> .  لا تزال طريقة <strong>stop ()</strong> ، التي لا تأخذ أي حجج ، موجودة.  قد يؤدي إلى مشكلة توافق. </p><br><h4 id="javaniobytebuffer" style=";text-align:right;direction:rtl">  java.nio.ByteBuffer </h4><br><h4 id="javaniocharbuffer" style=";text-align:right;direction:rtl">  java.nio.CharBuffer </h4><br><h4 id="javaniodoublebuffer" style=";text-align:right;direction:rtl">  java.nio.DoubleBuffer </h4><br><h4 id="javaniofloatbuffer" style=";text-align:right;direction:rtl">  java.nio.FloatBuffer </h4><br><h4 id="javaniolongbuffer" style=";text-align:right;direction:rtl">  java.nio.LongBuffer </h4><br><h4 id="javanioshortbuffer" style=";text-align:right;direction:rtl">  java.nio.ShortBuffer </h4><br><p style=";text-align:right;direction:rtl">  تحتوي جميع هذه الفئات الآن على طريقة <strong>عدم التطابق ()</strong> ، التي تبحث عن وترجع الفهرس النسبي لعدم التطابق الأول بين هذا المخزن المؤقت والمخزن المؤقت الذي تم تمريره. </p><br><h4 id="javaniochannelsselectionkey" style=";text-align:right;direction:rtl">  java.nio.channels.SelectionKey </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>int InterestOpsAnd (int)</strong> : تعين مصلحة هذا المفتاح (مصلحة المفتاح) تلقائيًا على تقاطع البتات ("و") لمجموعة المصالح الحالية والقيمة التي تم تمريرها. </li><li style=";text-align:right;direction:rtl">  <strong>int InterestOpsOr (int)</strong> : تحدد مصلحة هذا المفتاح (مصلحة المفتاح) تلقائيًا في اتحاد bitwise ("أو") لمجموعة المصالح الحالية والقيمة التي تم تمريرها. </li></ul><br><h4 id="javaniochannelsselector" style=";text-align:right;direction:rtl">  java.nio.channels.Selector </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>int select (java.util.function.Consumer، long)</strong> : تحديد وتنفيذ الإجراءات على المفاتيح التي تكون قنواتها المقابلة جاهزة لعمليات الإدخال / الإخراج.  حجة طويلة مهلة. </li><li style=";text-align:right;direction:rtl">  <strong>int select (java.util.function.Consumer)</strong> : نفس المذكور أعلاه ، ولكن بدون مهلة. </li><li style=";text-align:right;direction:rtl">  <strong>int selectNow (java.util.function.Consumer)</strong> : كما هو مذكور أعلاه ، فقط غير قابل للحظر. </li></ul><br><h4 id="javaniofilefiles" style=";text-align:right;direction:rtl">  java.nio.file.Files </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>String readString (المسار)</strong> : يقرأ كل المحتوى من ملف إلى سلسلة ، <strong>ويفك</strong> تشفير البايت من الأحرف إلى الأحرف باستخدام ترميز UTF-8. </li><li style=";text-align:right;direction:rtl">  <strong>String readString (Path، Charset)</strong> : كما هو موضح أعلاه ، مع الاختلاف في أن فك الترميز من البايت إلى الأحرف يحدث باستخدام Charset المحدد. </li><li style=";text-align:right;direction:rtl">  <strong>Path writeString (Path، CharSequence، java.nio.file.OpenOption [])</strong> : كتابة CharSequence إلى ملف.  يتم ترميز الأحرف بالبايت باستخدام ترميز UTF-8. </li><li style=";text-align:right;direction:rtl">  <strong>Path writeString (Path، CharSequence، java.nio.file.Charset، OpenOption [])</strong> : كما هو موضح أعلاه ، يتم ترميز الأحرف بالبايت باستخدام الترميز المحدد في Charset. </li></ul><br><h4 id="javaniofilepath" style=";text-align:right;direction:rtl">  java.nio.file.Path </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>مسار (سلسلة ، سلسلة [])</strong> : إرجاع المسار من وسيطة سلسلة المسار أو سلسلة من السلاسل التي ، عند دمجها ، تشكل سلسلة المسار. </li><li style=";text-align:right;direction:rtl">  <strong>مسار (net.URI)</strong> : إرجاع المسار من URI. </li></ul><br><h4 id="javautilcollection" style=";text-align:right;direction:rtl">  java.util.Collection </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>الكائن [] toArray (java.util.function.IntFunction)</strong> : إرجاع مصفوفة تحتوي على جميع العناصر في هذه المجموعة ، باستخدام وظيفة التوليد المقدمة لتخصيص الصفيف الذي تم إرجاعه. </li></ul><br><h4 id="javautilconcurrentpriorityblockingqueue" style=";text-align:right;direction:rtl">  java.util.concurrent.PriorityBlockingQueue </h4><br><h4 id="javautilpriorityqueue" style=";text-align:right;direction:rtl">  java.util.PriorityQueue </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>void forEach (java.util.function.Consumer)</strong> : ينفذ الإجراء الذي تم تمريره لكل عنصر متكرر حتى تتم معالجة جميع العناصر أو يطرح الإجراء استثناءً. </li><li style=";text-align:right;direction:rtl">  <strong>boolean removeAll (java.util.Collection)</strong> : يزيل جميع عناصر هذه المجموعة الموجودة أيضًا في المجموعة المحددة (عملية اختيارية). </li><li style=";text-align:right;direction:rtl">  <strong>إزالة منطقية (java.util.function.Predicate)</strong> : تزيل جميع العناصر من هذه المجموعة التي ترضي المسند المحدد. </li><li style=";text-align:right;direction:rtl">  <strong>boolean retainAll (java.util.Collection)</strong> : يحفظ فقط العناصر الموجودة في هذه المجموعة <strong>والموجودة</strong> في المجموعة المنقولة (عملية اختيارية). </li></ul><br><h4 id="javautilconcurrenttimeunit" style=";text-align:right;direction:rtl">  java.util.concurrent.TimeUnit </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>تحويل طويل (java.time.Duration)</strong> : تحويل المدة التي تم تمريرها إلى هذا النوع. </li></ul><br><h4 id="javautilfunctionpredicate" style=";text-align:right;direction:rtl">  وظيفة java.util. المسند </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>المسند لا (المسند)</strong> : إرجاع المسند ، وهو إنكار المسند المنقولة. </li></ul><br><p style=";text-align:right;direction:rtl">  هذه واحدة من واجهات برمجة التطبيقات الجديدة المفضلة لدي في JDK 11. كمثال ، يمكنك تحويل هذا الرمز: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> lines.stream() .filter(s -&gt; !s.isBlank())</code> </pre> <br><p style=";text-align:right;direction:rtl">  في </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> lines.stream() .filter(Predicate.not(String::isBlank))</code> </pre> <br><p style=";text-align:right;direction:rtl">  أو إذا استخدمنا الواردات الثابتة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> lines.stream() .filter(not(String::isBlank))</code> </pre> <br><p style=";text-align:right;direction:rtl">  أنا شخصياً أعتقد أن هذه النسخة مفهومة وأكثر إيجازاً. </p><br><h4 id="javautiloptional" style=";text-align:right;direction:rtl">  java.util. اختياري </h4><br><h4 id="javautiloptionalint" style=";text-align:right;direction:rtl">  java.util.OptionalInt </h4><br><h4 id="javautiloptionaldouble" style=";text-align:right;direction:rtl">  java.util.OptionalDouble </h4><br><h4 id="javautiloptionallong" style=";text-align:right;direction:rtl">  java.util.OptionalLong </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>boolean isEmpty ()</strong> : إذا لم تكن هناك قيمة ، ترجع صواب أو خطأ. </li></ul><br><h4 id="javautilregexpattern" style=";text-align:right;direction:rtl">  java.util.regex.Pattern </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>المسند asMatchPredicate ()</strong> : أعتقد أنه قد يكون جوهرة JDK 11. API الجديدة. يُنشئ المسند الذي يتحقق مما إذا كان هذا القالب يتطابق مع سلسلة الإدخال المعطاة. </li></ul><br><h4 id="javautilzipdeflater" style=";text-align:right;direction:rtl">  java.util.zip.Deflater </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  <strong>int deflate (ByteBuffer)</strong> : يضغط الإدخال ويملأ المخزن المؤقت المحدد به. </p><br></li><li style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  <strong>int deflate (ByteBuffer، int)</strong> : يضغط الإدخال ويملأ المخزن المؤقت المحدد به.  إرجاع الكمية الفعلية للبيانات المضغوطة. </p><br></li><li style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  <strong>void setDictionary (ByteBuffer)</strong> : تعيين القاموس المحدد للضغط على وحدات البايت في هذا المخزن المؤقت.  هذا هو شكل زائد من طريقة موجودة يمكن لـ ByteBuffer قبولها الآن ، بدلاً من صفيف بايت. </p><br></li><li style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  <strong>void setInput (ByteBuffer)</strong> : يضبط المدخلات المراد ضغطها.  أيضا شكل زائد من طريقة موجودة. </p><br></li></ul><br><h4 id="javautilzipinflater" style=";text-align:right;direction:rtl">  java.util.zip.Inflater </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>int inflate (ByteBuffer)</strong> : فك ضغط البايت في المخزن المؤقت المحدد.  إرجاع العدد الفعلي للبايتات غير المضغوطة. </li><li style=";text-align:right;direction:rtl">  <strong>void setDictionary (ByteBuffer)</strong> : لتعيين القاموس المحدد على وحدات البايت في هذا المخزن المؤقت.  الشكل الزائد لطريقة موجودة. </li><li style=";text-align:right;direction:rtl">  <strong>void setInput (ByteBuffer)</strong> : يضبط الإدخال <strong>لإلغاء</strong> الضغط.  الشكل الزائد لطريقة موجودة. </li></ul><br><h4 id="javaxprintattributestandarddialogowner" style=";text-align:right;direction:rtl">  javax.print.attribute.standard.DialogOwner </h4><br><p style=";text-align:right;direction:rtl">  هذه فئة جديدة في JDK 11. تستخدم لدعم طلب لمربع حوار الطباعة أو إعداد الصفحة.  يجب عرضها أعلى جميع النوافذ أو نافذة معينة. </p><br><h4 id="javaxswingdefaultcomboboxmodel" style=";text-align:right;direction:rtl">  javax.swing.DefaultComboBoxModel </h4><br><h4 id="javaxswingdefaultlistmodel" style=";text-align:right;direction:rtl">  javax.swing.DefaultListModel </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>vAll addAll (Collection)</strong> : يضيف جميع العناصر الموجودة في المجموعة. </li><li style=";text-align:right;direction:rtl">  <strong>void addAll (int، Collection)</strong> : يضيف جميع العناصر الموجودة في المجموعة ، بدءًا من الفهرس المحدد. </li></ul><br><h4 id="javaxswinglistselectionmodel" style=";text-align:right;direction:rtl">  javax.swing.ListSelectionModel </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>int [] getSelectedIndices ()</strong> : إرجاع مصفوفة لجميع المؤشرات المحددة في النموذج المحدد بترتيب تصاعدي. </li><li style=";text-align:right;direction:rtl">  <strong>int getSelectedItemsCount ()</strong> : إرجاع عدد العناصر المحددة. </li></ul><br><h4 id="jdkjshellevalexception" style=";text-align:right;direction:rtl">  jdk.jshell.EvalException </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>jshell.JShellException getCause ()</strong> : تقوم بإرجاع غلاف سبب <strong>قابل للرمي</strong> في عميل التنفيذ ممثلة بـ EvalException ، أو فارغة إذا كان السبب غير موجود أو غير معروف. </li></ul><br><h3 id="novye-fichi-ne-publichnyy-api" style=";text-align:right;direction:rtl">  ميزات جديدة (ليست واجهة برمجة تطبيقات عامة) </h3><br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 181: التحكم في الوصول القائم على عش</a> </p><br><p style=";text-align:right;direction:rtl">  تدعم Java (ولغات أخرى) الفئات المتداخلة من خلال الطبقات الداخلية.  للتشغيل الصحيح ، يجب على المترجم تنفيذ بعض الحيل.  على سبيل المثال: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerInt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printOuterInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Outer int = "</span></span> + outerInt); } } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  يقوم المترجم بتعديل هذا لإنشاء شيء مثل هذا قبل القيام بالتجميع: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerInt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> access$<span class="hljs-number"><span class="hljs-number">000</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outerInt; } }</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class">$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ Outer outer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printOuterInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Outer int = "</span></span> + outer.access$<span class="hljs-number"><span class="hljs-number">000</span></span>()); } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  على الرغم من أن الفئة الداخلية ، من الناحية المنطقية ، هي جزء من نفس التعليمات البرمجية للفئة الخارجية ، إلا أنها يتم تصنيفها على أنها فئة منفصلة.  لذلك ، يتطلب هذا طريقة اصطناعية ("جسر") ، والتي يجب إنشاؤها بواسطة المترجم لتوفير الوصول إلى الحقل الخاص للفئة الخارجية. </p><br><p style=";text-align:right;direction:rtl">  يمثل هذا JEP مفهوم "مأخذ التوصيل" ، حيث جيران اثنين من أعضاء نفس مأخذ التوصيل (الخارجي والداخل من مثالنا).  تمت إضافة سمتين جديدتين بتنسيق ملف * .class: NestHost و NestMembers.  هذه التغييرات مفيدة أيضًا للغات الأخرى التي تم تجميعها بواسطة رمز ثانوي والتي تدعم الفئات المتداخلة. </p><br><p style=";text-align:right;direction:rtl">  توفر هذه الميزة ثلاث طرق جديدة لـ java.lang.Class: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>فئة getNestHost ()</strong> </li><li style=";text-align:right;direction:rtl">  <strong>الفئة [] getNestMembers ()</strong> </li><li style=";text-align:right;direction:rtl">  <strong>منطقي هو NestmateOf (clazz)</strong> </li></ul><br><p style=";text-align:right;direction:rtl">  تتطلب هذه الميزة أيضًا تغييرات <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">في مواصفات Java Virtual Machine (JVMS)</a> ، خاصة في القسم 5.4.4 التحكم في الوصول. </p><br><p style=";text-align:right;direction:rtl">  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 309: ثوابت ملف الفئة الديناميكية</a></strong> </p><br><p style=";text-align:right;direction:rtl">  يصف هذا JEP امتداد تنسيق الملف * .class لدعم النموذج الجديد مع التجمع الثابت CONSTANT_Dynamic (يشار إليه غالبًا باسم condy في العروض التقديمية).  تبدو فكرة الثابت الديناميكي أنها تناقض ، ولكن ، في الواقع ، يمكنك التفكير فيها كقيمة نهائية في Java.  لا يتم تعيين قيمة التجمع الثابت في مرحلة التجميع (بخلاف الثوابت الأخرى) ، ولكن يتم استخدام طريقة التمهيد لتحديد القيمة في وقت التشغيل.  لذلك ، تكون القيمة ديناميكية ، ولكن نظرًا لأنه يتم تعيين قيمتها مرة واحدة فقط ، فهي ثابتة أيضًا. </p><br><p style=";text-align:right;direction:rtl">  ستكون هذه الميزة مفيدة في المقام الأول لأولئك الذين يقومون بتطوير لغات ومجمعين جدد.  من الذي سيقوم بإنشاء ملفات bytecode و * .class ليتم تشغيلها على JVM.  سيؤدي هذا إلى تبسيط بعض المهام. </p><br><p style=";text-align:right;direction:rtl">  توفر هذه الميزة java.lang.invoke.ConstantBootstraps فئة جديدة مع تسع طرق جديدة.  لن أدرجهم جميعًا هنا ؛  هذه هي طرق التمهيد للثوابت المحسوبة ديناميكيًا. </p><br><p style=";text-align:right;direction:rtl">  تتطلب هذه الميزة تغييرات في JVMS ، على وجه الخصوص ، في كيفية استخدام رمز البايت الخاص والقسم 4.4 من التجمع الثابت. </p><br><p style=";text-align:right;direction:rtl">  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 315: تحسين الجوهر الداخلي Aarch64</a></strong> </p><br><p style=";text-align:right;direction:rtl">  كان هذا هو JEP التي ساهمت بها Red Hat.  يمكن لـ JVM الآن استخدام تعليمات أكثر تخصصًا متوفرة في مجموعة أوامر Arm 64. على وجه الخصوص ، يؤدي هذا إلى تحسين عملية sin () ، cos () ، وأساليب log () لفئة java.lang.Math. </p><br><p style=";text-align:right;direction:rtl">  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JEP 318: جامع القمامة إبسيلون</a></strong> </p><br><p style=";text-align:right;direction:rtl">  ساهمت Red Hat أيضًا في هذا JEP.  جامع القمامة إبسيلون غير معتاد إلى حد ما لأنه لا يجمع القمامة!  ستخصص ذاكرة جديدة إذا لزم الأمر عند إنشاء كائنات جديدة ، ولكنها لا تحرر المساحة التي تشغلها الكائنات بدون روابط. </p><br><p style=";text-align:right;direction:rtl">  يبدو ، إذن ، ما هي الفائدة؟  هناك استخدامان على الأقل: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  بادئ ذي بدء ، تم تصميم هذا المجمع لضمان تقييم خوارزميات GC الجديدة من حيث تأثيرها على الأداء.  الفكرة هي تشغيل تطبيق مثال باستخدام Epsilon GC وإنشاء مقياس.  يتم تضمين خوارزمية GC جديدة ، ويتم تشغيل نفس الاختبارات ، ويتم مقارنة النتائج. </li><li style=";text-align:right;direction:rtl">  بالنسبة للمهام القصيرة جدًا أو القصيرة العمر (فكر في وظيفة بدون خادم في السحابة) ، حيث يمكنك التأكد من عدم تجاوز الذاكرة المخصصة لمساحة الذاكرة.  يمكن أن يؤدي ذلك إلى تحسين الأداء من خلال إزالة الحمل الزائد (بما في ذلك جمع الإحصائيات اللازمة لتحديد ما إذا كان سيتم تشغيل المجمّع) في رمز التطبيق. </li></ul><br><p style=";text-align:right;direction:rtl">  في حالة استنفاد مساحة الكومة ، يمكن تكوين عملية JVM اللاحقة بإحدى الطرق الثلاث: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يسمى OutOfMemoryError العادي. </li><li style=";text-align:right;direction:rtl">  إعادة تعيين كومة الذاكرة المؤقتة </li><li style=";text-align:right;direction:rtl">  من الصعب إيقاف JVM وربما تنفيذ مهمة خارجية (على سبيل المثال ، بدء تشغيل المصحح). </li></ul><br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><strong>JEP 324: اتفاقية رئيسية مع Curve25519 و Curve448</strong></a> </p><br><p style=";text-align:right;direction:rtl">  تتغير معايير التشفير وتتحسن باستمرار.  في هذه الحالة ، يتم استبدال مخطط Diffie-Hellman الحالي بمنحنى بيضاوي بـ Curve25519 و Curve448.  هذا هو مخطط اتفاق رئيسي محدد في RFC-7748. </p><br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><strong>JEP 327: يونيكود 10</strong></a> </p><br><p style=";text-align:right;direction:rtl">  يدعم نظام Java الأساسي Unicode لتمكين معالجة جميع مجموعات الأحرف.  منذ أن تم تحديث Unicode إلى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الإصدار 10</a> ، تم تحديث JDK أيضًا لدعم هذا الإصدار من المعيار. </p><br><p style=";text-align:right;direction:rtl">  أنا مفتون دائمًا لمعرفة ما يشتمل عليه مطورو Unicode في الإصدارات الجديدة.  يحتوي Unicode 10 على 8.518 حرفًا جديدًا.  يتضمن هذا رمز Bitcoin ، ومجموعة أحرف Nüshu (التي تستخدمها النساء الصينيات لكتابة القصائد) ، و Soyombo و Zanabazar Square (هي الأحرف المستخدمة في النصوص البوذية التاريخية لكتابة اللغات السنسكريتية والتبتية والمنغولية).  تمت إضافة العديد من الرموز التعبيرية الأخرى أيضًا ، بما في ذلك <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Colbert Emoji</a> الذي طال انتظاره (على ما يبدو). </p><br><p style=";text-align:right;direction:rtl">  تذكر أنه بدءًا من JDK 9 ، يمكنك استخدام UTF-8 في ملفات الخصائص (.properties).  هذا يعني أنه يمكن استخدام أي حرف Unicode في مثل هذه الملفات.  بما في ذلك الرموز التعبيرية.  أو نوشو. </p><br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><strong>JEP 328: مسجل الطيران</strong></a> </p><br><p style=";text-align:right;direction:rtl"> Flight Recorder —       JVM.  JDK 11        Oracle JDK. ,  Oracle     Oracle JDK  OpenJDK,      OpenJDK. </p><br><p style=";text-align:right;direction:rtl"> JEP    : </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  API        </li><li style=";text-align:right;direction:rtl">        </li><li style=";text-align:right;direction:rtl">      </li><li style=";text-align:right;direction:rtl">    , JVM HotSpot   JDK </li></ul><br><p style=";text-align:right;direction:rtl">      : jdk.jfr  jdk.management.jfr. </p><br><p style=";text-align:right;direction:rtl"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><strong>JEP 329: ChaCha20 and Poly1305 Cryptographic Algorithms</strong></a> </p><br><p style=";text-align:right;direction:rtl">  JEP 324,   ,  JDK.   ChaCha20  ChaCha20-Poly1305,    RFC 7539. ChaCha20 —     ,    ,    RC4. </p><br><p style=";text-align:right;direction:rtl"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><strong>JEP 331: Low-overhead Heap Profiling</strong></a> </p><br><p style=";text-align:right;direction:rtl">  ,   JEP,   Google.          Java  JVM. </p><br><p style=";text-align:right;direction:rtl">  : </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">    ,       </li><li style=";text-align:right;direction:rtl">       </li><li style=";text-align:right;direction:rtl">     </li><li style=";text-align:right;direction:rtl">        ( ,     GC   VM) </li><li style=";text-align:right;direction:rtl">         Java. </li></ul><br><p style=";text-align:right;direction:rtl"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><strong>JEP 332: Transport Layer Security (TLS) 1.3</strong></a> </p><br><p style=";text-align:right;direction:rtl"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">TLS 1.3 (RFC 8446)</a>  " "  TLS            . JDK   ,      Datagram Transport Layer Security (DTLS). </p><br><p style=";text-align:right;direction:rtl"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><strong>JEP 333: ZGC A Scalable, Low Latency Garbage Collector</strong></a> </p><br><p style=";text-align:right;direction:rtl">     ,     ,     ()    .      (  ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Weak Generational Hypothesis</a> )    (  )  GC   .     ""  ,            .           . </p><br><p style=";text-align:right;direction:rtl"> ZGC — region-based (  G1), NUMA aware  compacting  .      . </p><br><p style=";text-align:right;direction:rtl">     pauseless     ,      C4   Zing JVM. </p><br><p style=";text-align:right;direction:rtl"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><strong>JEP 335: Deprecate the Nashorn Scripting Engine</strong></a> </p><br><p style=";text-align:right;direction:rtl"> Nashorn    JDK 8     Rhino Javascript .    ,   Nashorn   API  jjs     Java.   ,   .     Graal VM   ,     ,  . </p><br><p style=";text-align:right;direction:rtl"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><strong>JEP 336: Deprecate the Pack200 Tools and APIs</strong></a> </p><br><p style=";text-align:right;direction:rtl"> Pack200 —     JAR-,     Java SE 5.0.   JPMS  JDK 9 Pack200       JDK.  pack200  unpack200  API Pack200  java.util.jar          JDK.   ,  . </p><br><h3 id="vyvody" style=";text-align:right;direction:rtl">  الاستنتاجات </h3><br><p style=";text-align:right;direction:rtl"> JDK 11 —   LTS JDK (       ).   ,  ,   ,   ,  JVM   ,        . </p><br><p style=";text-align:right;direction:rtl"> Zulu  JDK 11  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="> </a>   ! </p><br><p style=";text-align:right;direction:rtl">         JDK 11? </p><br><p style=";text-align:right;direction:rtl"> ( <em>. : ,         </em> ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar424683/">https://habr.com/ru/post/ar424683/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar424673/index.html">CLRium # 4: .NET Community Meeting</a></li>
<li><a href="../ar424675/index.html">ماذا يحدث في البيع بالتجزئة</a></li>
<li><a href="../ar424677/index.html">تاريخ موجز للوحة المفاتيح الرقمية</a></li>
<li><a href="../ar424679/index.html">إصلاح أساسيات ملحقات الكمبيوتر</a></li>
<li><a href="../ar424681/index.html">ملخص أحداث أكتوبر لتقنية المعلومات (الجزء الأول)</a></li>
<li><a href="../ar424685/index.html">رفعت لجنة الأوراق المالية والبورصات الأمريكية دعوى قضائية ضد رئيس تيسلا إيلون ماسك ، بما في ذلك بسبب الاحتيال</a></li>
<li><a href="../ar424687/index.html">هذه هي النحل الصحيح: التكيف الميكانيكي مع التأثيرات الديناميكية</a></li>
<li><a href="../ar424689/index.html">السيطرة على الموقف يجعلك سعيدا.</a></li>
<li><a href="../ar424691/index.html">ندعوك لحضور مؤتمر Azov Developers 2018 - 13 أكتوبر في تاغونروغ</a></li>
<li><a href="../ar424693/index.html">إضافة علامة مائية إلى جميع صور الموقع</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>