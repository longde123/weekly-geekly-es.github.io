<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚣🏾 🙋🏽 🈲 Cycle de développement complet du dispositif IoT pour le contrôle du chauffage de piscine sur l'ESP8266 dans un environnement Arduino 💉 🎵 🛢️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cette publication, je partagerai mon expérience sur la création d'un appareil IoT à partir de zéro: de l'émergence d'une idée et de sa mise en œu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cycle de développement complet du dispositif IoT pour le contrôle du chauffage de piscine sur l'ESP8266 dans un environnement Arduino</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413955/"><p>  Dans cette publication, je partagerai mon expérience sur la création d'un appareil IoT à partir de zéro: de l'émergence d'une idée et de sa mise en œuvre matérielle à la création de firmware pour un contrôleur et d'une interface web pour gérer un appareil créé via Internet. </p><br><p>  Avant de créer cet appareil, je: </p><br><ul><li>  Presque ne comprenait pas les circuits.  Seulement au niveau des principes de travail <br>  résistance / transistor ... Je n'avais aucune expérience dans la création de circuits compliqués. </li><li>  Cartes de circuits imprimés jamais conçues. </li><li>  Composant CMS jamais soudé.  Le niveau du fer à souder était au niveau des fils à souder et d'une sorte de relais. </li><li>  Je n'ai jamais écrit de programmes aussi complexes pour un microcontrôleur.  Toute l'expérience était au niveau «allumer la LED en Arduino», et j'ai rencontré pour la première fois le contrôleur ESP8266. </li><li>  J'ai écrit pas mal de C ++ pour le "grand frère", mais c'était il y a plus d'une douzaine d'années et tout a été oublié il y a longtemps. </li></ul><br><p>  Bien sûr, l'expérience de travailler en tant que programmeur (principalement Microsoft .NET) et la pensée systémique m'ont aidé à comprendre le sujet.  Je pense que le lecteur pourra.  Liens et articles utiles sur la mer Internet.  Le plus, à mon avis, intéressant et aidant à comprendre le sujet, j'apporte l'article. </p><a name="habracut"></a><br><h2>  Énoncé du problème </h2><br><p>  Je vis dans une maison privée près de Minsk, et ma propre piscine, bien que la plus simple, fait partie intégrante de l'ensemble des «avantages» que de nombreuses personnes vivant dans une maison de campagne obtiennent.  Dans notre climat instable, il s'est avéré que la baignade dans la piscine est inconfortable si elle est à l'extérieur: l'eau se refroidit la nuit et le temps venteux pendant la journée ne rend pas la natation confortable.  L'année dernière, de mes propres mains, j'ai construit un dôme géodésique d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">foulon</a> au-dessus de la piscine, mis une colline et accroché un élastique - les enfants sont heureux. </p><br><img src="https://habrastorage.org/webt/hh/ec/xp/hhecxpolfqsqevq41tmn-84npsg.jpeg"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Reportage photo de la</em> construction du dôme sur Flickr.</a> </p><br><p>  Cette année, je suis allé encore plus loin et j'ai décidé d'organiser un chauffe-piscine à partir d'une chaudière à gaz, <br>  qui sert au chauffage de la maison en hiver et au chauffage de l'eau chaude en été. </p><br><p>  En été, le circuit "chauffage" de la chaudière à l'aide de vannes passe en chauffage <br>  piscine.  L'eau de la piscine est chauffée à l'aide d'un échangeur de chaleur en titane, dont le circuit primaire fait passer le liquide de refroidissement (eau chaude sans impuretés) du circuit de chauffage, et le secondaire - l'eau de la piscine, pompée par une pompe de recirculation du système de filtration.  Puisque j'utilise la piscine avec un électrolyseur (beaucoup de sujets intéressants sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">décrits</a> sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ForumHouse</a> ), l'eau contient un peu de sel et un échangeur de chaleur en titane est nécessaire.  Vous ne pouvez pas simplement prendre et laisser l'eau directement à travers la chaudière - sinon vous corroderez tous les tuyaux avec du sel. </p><br><img src="https://habrastorage.org/webt/d6/_k/pz/d6_kpzjpyzyvy2-vzk9aukvstko.png"><br><p>  En passant à travers l'échangeur de chaleur, le caloporteur chauffé par la chaudière à une température d'environ 70-90 ° C dégage de la chaleur à l'eau de la piscine, la chauffant de quelques degrés.  Le liquide de refroidissement lui-même refroidit de quelques dizaines de degrés et retourne à la chaudière pour être à nouveau <br>  réchauffé.  Le rapport du refroidissement de l'eau de la chaudière au chauffage de l'eau de la piscine dépend de nombreux facteurs: la capacité de l'échangeur de chaleur et la vitesse de circulation de l'eau dans les circuits primaire et secondaire. </p><br><p>  Les tuyaux reliés de la piscine à l'échangeur de chaleur sont des tuyaux en polyéthylène ordinaires, ceux qui <br>  actuellement utilisé pour fournir de l'eau froide aux maisons privées.  Bon marché, la capacité de résister à une pression décente, l'absence de corrosion - ce sont les principaux avantages de ces tuyaux.  Pour tous, sans exception, les tuyaux en polyéthylène, la température de fonctionnement est limitée à 40 degrés Celsius.  En principe, c'est plus que suffisant pour la piscine. </p><br><p>  Cependant, il y a une forte probabilité d'urgence en cas de pompe <br>  la recirculation de l'eau de l'eau de la piscine s'arrêtera pour une raison quelconque, et la chaudière continuera à chauffer l'échangeur de chaleur: dans ce cas, l'eau dans le circuit secondaire de l'échangeur de chaleur augmentera rapidement à la température du circuit primaire, ce qui signifie que les sections de tuyaux en polyéthylène adjacentes à l'échangeur de chaleur fondront et l'eau de la piscine sera inondée tout l'espace autour. </p><br><p>  Il doit être possible de protéger la surchauffe de l'échangeur de chaleur. </p><br><h2>  Solution rapide </h2><br><p>  Pour résoudre ce problème, un capteur de débit fonctionnant sur le principe de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'effet hall a</a> été intégré au circuit du circuit de recirculation de l'eau de la piscine.  De plus, des capteurs de température situés sur le circuit secondaire <br>  échangeur de chaleur, fournir un deuxième niveau de défense, suivi de la surchauffe possible. </p><br><p>  Il est impossible de contrôler la surchauffe uniquement par des capteurs de température: le système a une grande inertie: après un arrêt brutal de l'eau dans le circuit de la piscine, à <br>  l'arrêt de la chaudière, la température continue d'augmenter pendant un certain temps, comme  la chaudière entraîne toujours l'eau chauffée le long du circuit par inertie, empêchant la surchauffe de «moi, mon bien-aimé». </p><br><p>  Par conséquent, il est important de répondre le plus tôt possible: à savoir, d'arrêter le débit d'eau dans le circuit <br>  piscine. </p><br><p>  Un capteur de débit a été utilisé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tel</a> .  Le boîtier en plastique et le manque de contact du capteur avec l'eau lui permettent d'être utilisé dans l'eau salée. </p><br><p>  Capteurs de température, il a été décidé d'utiliser le Dallas DS18B20, ils sont faciles à connecter plusieurs pièces à la fois sur un bus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1-Wire</a> . </p><br><img src="https://habrastorage.org/webt/nd/pj/d5/ndpjd5v3_0lbaklr-ogjnaxribi.jpeg"><br><p>  Il a été décidé de suspendre une paire de capteurs à l'entrée et à la sortie du secondaire et du primaire <br>  circuit: 4 capteurs au total.  Un avantage supplémentaire de cette approche est <br>  la possibilité de surveiller les paramètres du système: vous pouvez surveiller la quantité de liquide de refroidissement dans le circuit primaire et la quantité d'eau de la piscine qui est chauffée dans le circuit secondaire.  Donc - pour surveiller l'optimalité du chauffage et pour prédire le temps de chauffage. </p><br><div class="spoiler">  <b class="spoiler_title">Emplacements des capteurs sur l'échangeur de chaleur et les tuyaux d'entrée</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/en/vw/mi/envwmicj0l1hc76r23a_uvyjd3w.jpeg"></div></div><br><h2>  Paramètres de l'appareil </h2><br><p>  Le premier prototype de l'appareil a été construit sur la base d'Arduino Uno et lancé avec succès. </p><br><img src="https://habrastorage.org/webt/ol/xh/rg/olxhrgxw-w4qqnjpzxkuhj7mc7u.png"><br><p>  Mais il est devenu clair que j'aimerais plus.  Chauffé 16 mètres cubes d'eau, même juste <br>  quelques degrés n'est pas rapide.  Et je voudrais surveiller directement les paramètres de chauffage du travail, allumer / éteindre.  Mais en même temps, il serait intéressant de prendre des plans de chauffage, par exemple, par jour. </p><br><p>  Eh bien, puisque nous avons déjà un appareil IoT, alors pourquoi ne contrôlons-nous pas en même temps l'activation à distance du chlorateur de piscine et de la pompe pour cela? </p><br><h2>  Mandat </h2><br><p>  Il a donc été décidé de développer un appareil - un contrôleur de piscine multifonctionnel.  Il doit pouvoir: </p><br><ul><li>  Pour contrôler le chauffage de la piscine à travers l'échangeur de chaleur, allumer / éteindre la chaudière à gaz pour chauffer l'eau. </li><li>  Empêcher la surchauffe de l'échangeur de chaleur en surveillant la présence d'un débit d'eau de piscine dans le circuit secondaire et une surchauffe du circuit secondaire. <br></li><li>  Affichage des statistiques de chauffage en temps réel (température à l'entrée et à la sortie des deux circuits). </li><li>  Enregistrer (enregistrer) les valeurs de température dans la mémoire flash.  Afficher les données pour <br>  une certaine période sous forme de graphique. </li><li>  À l'aide d'un relais, pouvoir allumer / éteindre les pompes de la piscine et le chlorateur. </li><li>  Gérez tous les paramètres de l'appareil à distance via le serveur micro-Web intégré. </li></ul><br><p>  Il y avait aussi la tentation de visser Blink, MQTT.  Mais à partir de ces "cloches et sifflets" dans la première étape <br>  Il a été décidé de refuser.  Et plus encore, je ne voudrais pas prendre la possibilité d'un contrôle quelque part vers l'extérieur.  Le serveur Web intégré à mes fins est tout à fait suffisant.  Et la sécurité est assurée par le fait que vous ne pouvez accéder au réseau domestique depuis le monde extérieur que via un VPN. </p><br><h2>  Matériel informatique </h2><br><p>  En tant que contrôleur, il a été décidé d'utiliser l'ESP8266, bon marché et populaire.  C'était parfait pour mes besoins, sauf pour une chose: faire correspondre les niveaux de signal des capteurs 5 volts avec la logique du contrôleur 3,3 volts.  En principe, les capteurs de Dallas semblent fonctionner à 3 volts, mais j'ai une ligne assez longue entre le contrôleur et les capteurs, environ 7 mètres.  Par conséquent, il est préférable d'augmenter la tension. </p><br><p>  Il a été déterminé qu'il est nécessaire d'avoir le matériel: </p><br><ul><li>  Contrôleur ESP8266 ou son frère aîné ESP32 (en tant que module <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DevKit</a> ). <br></li><li>  Alignement des niveaux de signal pour les capteurs. </li><li>  Le régulateur de puissance est une partie de 5 volts du circuit. </li><li>  Module de commande de relais. </li><li>  Horloge RTC + mémoire flash pour la journalisation. </li><li>  L'écran LCD 2 lignes le plus simple pour afficher les valeurs actuelles des capteurs et l'état de l'appareil et du relais. </li><li>  Plusieurs boutons physiques pour contrôler l'état de l'appareil sans accès via le web. </li></ul><br><p>  De nombreux composants de la liste sont vendus comme modules pour Arduino et de nombreux modules sont compatibles avec la logique 3.3v.  Cependant, je ne voulais pas "coincer" tout cela sur la planche à pain avec des faisceaux de fils, parce que je veux avoir un bel "appareil" soigné.  Oui, et pour l'argent donné aux Chinois pour les modules, vous pouvez complètement dessiner et commander votre carte de circuit imprimé individuelle, et l'attente de son arrivée sera compensée par une installation relativement rapide et fiable. </p><br><p>  Encore une fois, je note que c'est ma première expérience dans les circuits et dans la conception du matériel de ces choses.  J'ai dû beaucoup étudier.  En effet, dans ma spécialité, je suis un peu à l'écart des microcontrôleurs.  Mais tout faire "à genoux" ne permettait pas à l'esprit de perfectionnisme qui habite en moi. </p><br><h2>  Schéma du circuit </h2><br><p>  Il existe un grand nombre de programmes sur le marché qui vous permettent de dessiner un circuit et une carte de circuit imprimé.  Sans expérience dans ce domaine, j'ai immédiatement aimé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EasyEDA</a> - un éditeur en ligne gratuit qui vous permet de peindre magnifiquement un schéma de circuit, de vérifier que rien n'a été oublié et que tous les composants ont des connexions, de dessiner une carte de circuit imprimé, puis de commander immédiatement sa production. </p><br><p>  La première difficulté que j'ai rencontrée: il existe de nombreuses options pour le contrôleur DevKit ESP8266 ou ESP32, certaines diffèrent par l'emplacement des broches et leur fonction, et certaines même par leur largeur.  Il a été décidé de dessiner le circuit de sorte qu'il soit possible de placer DevKit de n'importe quelle largeur et à n'importe quel emplacement des bornes, et sur les côtés de celui-ci - 2 rangées de paires de cavaliers, puis le câblage pour connecter les bornes nécessaires, par rapport au contrôleur spécifiquement acheté. </p><br><p>  Placer sous le contrôleur et 2 rangées de cavaliers jumelés: JH1 et JH2 dans le schéma: </p><br><img src="https://habrastorage.org/webt/mz/a0/nl/mza0nlxbzvfaqjqcti7vc32ikbe.png"><br><p>  L'emplacement des broches d'entrée 5v et de sortie 3.3v de l'alimentation du stabilisateur intégré, ainsi que de GND, me semblait le même pour différents DevKit, mais j'ai quand même décidé de le jouer en toute sécurité et de les faire des cavaliers: JP1, JP2, JP3 dans le diagramme. </p><br><p>  J'ai décidé de signer les cavaliers en les connectant aux composants du circuit avec des fonctions qu'ils vont probablement remplir. </p><br><div class="spoiler">  <b class="spoiler_title">Et voici à quoi ça ressemble avec le DevKit ESP8266, que j'ai finalement acheté et installé</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/cg/3p/b5/cg3pb5pg7clju7haw77dah1udhs.png"></div></div><br><p>  Ici, D1 (GPIO5) et D2 (GPIO4) sont responsables du bus I2C, D5 (GPIO14) pour 1-Wire, D6 (GPIO12) - pour recevoir les impulsions du capteur de débit. </p><br><p>  Schéma du circuit: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ar/jj/n3/arjjn3bgb-ffz_yjofhjy72q_cq.png"></a> <br>  (image cliquable) </p><br><p>  Malgré la présence à bord de l'ESP8266 d'un régulateur de puissance intégré pour 3,3 V, nous avons encore besoin d'avoir 5 volts pour alimenter les capteurs et l'écran LCD, et 12 volts pour alimenter le relais.  Il a été décidé de rendre la carte d'alimentation 12 volts, et de mettre le régulateur de tension AMS1117-5.0 à l'entrée, donnant les 5 volts souhaités à la sortie. </p><br><p>  Pour faire correspondre les niveaux de signal sur le bus à 1 fil, j'ai utilisé un transistor à effet de champ BSS138 c avec des «tractions» de tension des deux côtés. </p><br><img src="https://habrastorage.org/webt/y_/sx/st/y_sxstfcgm3kys4hntq5beb5xby.png"><br><p>  Très bien sur la correspondance de niveau est écrit dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Correspondance des niveaux logiques des appareils 5V et 3,3V</a> . </p><br><p>  Pour faire correspondre les niveaux de signal du capteur de débit, je viens d'utiliser un diviseur de tension entre les résistances.  Le capteur de débit est simplement un dispositif à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">collecteur ouvert</a> .  Certains capteurs peuvent déjà avoir une résistance de rappel intégrée, cela doit être pris en compte: </p><br><img src="https://habrastorage.org/webt/9v/8e/br/9v8ebrvm_bsfzounu3kamf4grc8.png"><br><p>  Le bleu dans le diagramme est une désignation schématique de l'ensemble capteur de débit.  À droite du connecteur se trouvent des diviseurs de tension sélectionnés par moi afin d'avoir un niveau maximum de 3,3 volts en sortie. </p><br><p>  Sur le bus I2C, j'ai accroché une horloge en temps réel DS3231SN et une mémoire flash AT24C256C pour stocker les journaux.  La mémoire flash intégrée à l'ESP8266 ne convient pas, car elle a un petit nombre de cycles de réécriture (10 000 contre 1 million pour AT24Cxxx, selon les fiches techniques). </p><br><p>  Le contrôle des relais est organisé sur un tas de puces PCF8574AT et ULN2803A. </p><br><img src="https://habrastorage.org/webt/9v/8e/br/9v8ebrvm_bsfzounu3kamf4grc8.png"><br><p>  La première puce est un extenseur de port de microcontrôleur I2C.  L'état de la sortie ou de l'entrée active PCF8574AT est sélectionné en sélectionnant une adresse sur le bus I2C. <br>  La puce possède des fonctionnalités intéressantes, bien décrites dans l'article d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">extension de port I2C PCF8574</a> . </p><br><p>  La puce ne peut pas contrôler directement la charge (relais).  Pour cela, une matrice de transistor ULN2803A est utilisée.  Il y a une caractéristique: la matrice peut facilement tirer ses sorties avec une charge au sol, ce qui signifie que si une tension d'alimentation est appliquée au deuxième pôle du relais, le courant traversera l'enroulement du relais et les contacts du relais se fermeront.  Malheureusement, avec cette inclusion, nous obtenons un effet secondaire: la valeur du signal du contrôleur est inversée, et tous les relais "cliquent" lorsque le circuit est allumé.  Je n'ai pas encore compris comment supprimer cette fonctionnalité. </p><br><p>  Plus d'informations sur la puce sont décrites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  L'extenseur de port PCF8574AT peut également être utilisé comme entrée: des boutons matériels peuvent être accrochés à certaines entrées, lisant leurs valeurs sur le bus I2C.  Dans le diagramme, les broches 4-7 peuvent être utilisées pour lire l'état des boutons.  L'essentiel est de ne pas oublier de permettre par programme le serrage intégré des jambes correspondantes à la nutrition. </p><br><p>  En même temps, j'ai laissé le câblage à la matrice du transistor, au cas où vous voudriez brusquement connecter des relais supplémentaires.  Pour d'éventuelles connexions, j'ai apporté tous les fils aux connecteurs (plus précisément, aux trous sous eux où les fils peuvent être soudés ou le connecteur DIP standard de 2,54 mm peut être soudé). </p><br><p>  La broche de l'extenseur de port INT peut être utilisée pour répondre rapidement à la pression d'un bouton.  Il peut être connecté à un port libre sur le contrôleur et définir le déclencheur d'interruption pour changer l'état de cette broche. </p><br><p>  L'écran LCD à deux lignes est également contrôlé via le module d'extension PCF8574AT.  Le point principal: l'affichage est alimenté par 5 volts, tandis que l'affichage lui-même est contrôlé par une logique 3 volts.  Soit dit en passant, les adaptateurs Arduino standard pour I2C ne sont pas conçus pour la double tension.  J'ai trouvé l'idée d'une telle connexion quelque part sur Internet, malheureusement, j'ai perdu le lien, donc je ne cite pas la source. </p><br><h2>  Circuit imprimé </h2><br><p>  Lors de la conception de la carte, il s'est avéré que les pièces ordinaires avec pieds prennent trop de place et que de nombreuses puces dans la conception DIP ne sont pas faciles à trouver.  Après avoir lu sur Internet que l'installation SMD n'est pas si compliquée, et avec les compétences appropriées, elle prend encore moins de temps, j'ai décidé de concevoir la carte pour les pièces SMD.  Et je ne me suis pas trompé.  Il s'est avéré une belle carte mère compacte, où j'ai facilement placé tout ce dont j'ai besoin.  Les pièces SMD, avec un bon fer à souder, un flux et une soudure, se sont avérées vraiment très faciles à monter. </p><br><p>  Sur la carte, j'ai ajouté quelques marges carrées de trous pour le prototypage, si je veux soudainement souder autre chose. </p><br><p>  J'ai fait un circuit imprimé mesurant 97x97 mm.  Il s'intègre facilement dans une boîte électrique de coupe standard.  De plus, les planches de dimensions inférieures à 100x100 sont peu coûteuses à fabriquer.  La production d'un lot minimum de 5 planches selon la disposition développée a coûté 5 USD, leur livraison au Bélarus a coûté 9 USD supplémentaires. </p><br><img src="https://habrastorage.org/webt/u9/ov/ou/u9ovouhbfeuadqoixu_je1zjd54.png"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La conception de la carte</a> se trouve sur le site Web d'EasyEDA et est accessible à tous. </p><br><p>  Je note que sur la photo du contrôleur ci-dessous apparaît le premier échantillon de la carte, sur lequel j'ai "tordu" beaucoup de choses inutiles et inutiles (dans l'espoir d'utiliser ce lot minimal de 5 cartes dans d'autres projets).  Ici et sur EasyEDA, j'ai posté une version «nettoyée» de toutes ces choses inutiles. </p><br><img src="https://habrastorage.org/webt/vb/jn/p9/vbjnp97xoyff3jde4oeyh2hkvpg.jpeg"><br><div class="spoiler">  <b class="spoiler_title">Photos des deux côtés de la planche</b> <div class="spoiler_text"><p>  Face avant: </p><br><img src="https://habrastorage.org/webt/fs/8_/it/fs8_itdlmt1qredzy8b2h0prk4k.jpeg"><br><p>  Face arrière: </p><br><img src="https://habrastorage.org/webt/l8/tc/bo/l8tcboqf53vonco7zla9koydq2s.jpeg"></div></div><br><h2>  Partie logiciel </h2><br>  Pour programmer le microcontrôleur, étant donné l'arriéré sous la forme d'un prototype sur Arduino Uno, il a été décidé d'utiliser l'environnement Arduino avec le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">noyau Arduino ESP8266</a> installé.  Oui, vous pouvez utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lua</a> sur l'ESP8266, mais ils disent qu'il y a des blocages.  Compte tenu de la fonction critique exercée, je ne voudrais pas du tout. <br>  L'environnement Arduino lui-même me semble un peu dépassé, mais, heureusement, il existe une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">extension</a> pour Visual Studio de Visual Micro.  L'environnement vous permet d'utiliser des astuces de code IntelliSence, de passer rapidement aux déclarations de fonctions, de refactoriser le code: en général, tout ce que l'environnement des ordinateurs «adultes» se permet d'être.  La version payante de Visual Micro vous permet également de déboguer facilement le code, mais je me contentais de l'option gratuite. <br><h2>  Structure du projet </h2><br>  Le projet se compose des fichiers suivants: <br><div class="spoiler">  <b class="spoiler_title">Structure du projet dans Visual Studio</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/4i/dn/hu/4idnhu7toeunqk727_fnhcmpl34.png"></div></div><br><table><tbody><tr><th>  Fichier </th><th>  Rendez-vous </th></tr><tr><td>  WaterpoolManager.ino <br></td><td>  Déclaration des variables et constantes de base.  Initialisation.  Boucle principale. <br></td></tr><tr><td>  HeaterMainLogic.ino <br></td><td>  La logique de base du contrôle du relais de la chaudière (en fonction de la température) et des relais auxiliaires. <br></td></tr><tr><td>  Sensors.ino <br></td><td>  Lire les données du capteur <br></td></tr><tr><td>  Settings.ino <br></td><td>  Paramètres de l'appareil, les enregistrer dans la mémoire flash du contrôleur <br></td></tr><tr><td>  LCD.ino <br></td><td>  Sortie d'informations sur LCD <br></td></tr><tr><td>  ClockTimer.ino <br></td><td>  Lecture d'horloge RTC ou simulation d'horloge <br></td></tr><tr><td>  Relays.ino <br></td><td>  Contrôle marche / arrêt du relais <br></td></tr><tr><td>  ButtonLogic.ino <br></td><td>  Logique de réaction à l'état des boutons matériels <br></td></tr><tr><td>  ReadButtonStates.ino <br></td><td>  Lire les états des boutons matériels <br></td></tr><tr><td>  EEPROM_Logging.ino <br></td><td>  Enregistrement des données du capteur dans l'EEPROM <br></td></tr><tr><td>  WebServer.ino <br></td><td>  Serveur Web intégré pour la gestion des appareils et l'affichage de l'état <br></td></tr><tr><td>  <b>Pages Web</b> <br></td><td>  Les pages du serveur Web sont stockées dans ce dossier. <br></td></tr><tr><td>  index.h <br></td><td>  La page principale pour afficher l'état de l'appareil.  Lecture de l'état actuel avec appel ajax.  Actualisez toutes les 5 secondes. <br></td></tr><tr><td>  loggraph.h <br></td><td>  Affiche un journal des données des capteurs et des états des relais dans un graphique.  La bibliothèque jqPlot est utilisée - toute la construction a lieu côté client.  La demande adressée au contrôleur ne concerne qu'un fichier binaire - des copies des données de l'EEPROM. <br></td></tr><tr><td>  logtable.h <br></td><td>  aussi, mais sous forme de tableau <br></td></tr><tr><td>  settings.h <br></td><td>  Gestion des paramètres de l'appareil: définition des limites de température, de débit d'eau, de fréquence d'enregistrement des données <br></td></tr><tr><td>  time.h <br></td><td>  Réglage de l'heure actuelle <br></td></tr><tr><td><br></td><td>  <b>Bibliothèques</b> <br></td></tr><tr><td>  EepromLogger.cpp <br></td><td>  Bibliothèque de journaux Flash <br></td></tr><tr><td>  EepromLogger.h <br></td></tr><tr><td>  crc8.cpp <br></td><td>  8- CRC   <br></td></tr><tr><td> crc8.h <br></td></tr><tr><td> TimeSpan.cpp <br></td><td>      <br></td></tr><tr><td> TimeSpan.h <br></td></tr></tbody></table><br><h2>   </h2><br><p>          OneWire       tempSensAddr.              .       (    4    ): </p><br><pre><code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ds.search(tempSensAddr[<span class="hljs-type"><span class="hljs-type">lastSensorIndex</span></span>]) &amp;&amp; lastSensorIndex &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { Serial.print(<span class="hljs-string"><span class="hljs-string">"ROM ="</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { Serial.print(<span class="hljs-string"><span class="hljs-string">' '</span></span>); Serial.print(tempSensAddr[<span class="hljs-type"><span class="hljs-type">lastSensorIndex</span></span>][<span class="hljs-type"><span class="hljs-type">i</span></span>], HEX); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OneWire::crc8(tempSensAddr[<span class="hljs-type"><span class="hljs-type">lastSensorIndex</span></span>], <span class="hljs-number"><span class="hljs-number">7</span></span>) != tempSensAddr[<span class="hljs-type"><span class="hljs-type">lastSensorIndex</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>]) { Serial.print(<span class="hljs-string"><span class="hljs-string">" CRC is not valid!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lastSensorIndex++; Serial.println(); } ds.reset_search(); lastSensorIndex--; Serial.print(<span class="hljs-string"><span class="hljs-string">"\r\nTemperature sensor count: "</span></span>); Serial.print(lastSensorIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>, DEC);  ,       ().       Serial   LCD  : // Read sensor values and print temperatures ds.reset(); ds.write(<span class="hljs-number"><span class="hljs-number">0</span></span>xCC, TEMP_SENSOR_POWER_MODE); // Request all sensors at the one time ds.write(<span class="hljs-number"><span class="hljs-number">0</span></span>x44, TEMP_SENSOR_POWER_MODE); // Acquire temperatures delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); // Delay is required by temp. sensors char tempString[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte addr = <span class="hljs-number"><span class="hljs-number">0</span></span>; addr &lt;= lastSensorIndex; addr++) { ds.reset(); ds.select(tempSensAddr[<span class="hljs-type"><span class="hljs-type">addr</span></span>]); ds.write(<span class="hljs-number"><span class="hljs-number">0</span></span>xBE, TEMP_SENSOR_POWER_MODE); // Read Scratchpad tempData[<span class="hljs-type"><span class="hljs-type">addr</span></span>] = ds.read() | (ds.read() &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); // Read first <span class="hljs-number"><span class="hljs-number">2</span></span> bytes which carry temperature <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> int tempInCelsius = (tempData[<span class="hljs-type"><span class="hljs-type">addr</span></span>] + <span class="hljs-number"><span class="hljs-number">8</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> celsius, with math rounding Serial.print(tempInCelsius, DEC); // Print temperature Serial.println(<span class="hljs-string"><span class="hljs-string">" C"</span></span>); }</code> </pre> <br><p>  Selon la fiche technique, les capteurs nécessitent au moins 750 ms de délai entre la demande d'une valeur de température et la réception d'une réponse du capteur.  Par conséquent, le code a introduit un retard avec une petite marge. </p><br><p>  Cependant, ce délai, lorsque l'ensemble du périphérique attend simplement une réponse, est acceptable au début, mais il est absolument inapproprié d'attendre à chaque fois avec une interrogation régulière des capteurs.  Par conséquent, le code délicat suivant a été écrit, appelé toutes les 50 ms par minuterie: </p><br><pre> <code class="hljs lua">#define TEMP_MEASURE_PERIOD <span class="hljs-number"><span class="hljs-number">20</span></span> // Time of measuring, * TEMP_TIMER_PERIODICITY ms #define TEMP_TIMER_PERIODICITY <span class="hljs-number"><span class="hljs-number">50</span></span> // Periodicity of timer calling, ms timer.attach_ms(TEMP_TIMER_PERIODICITY, tempReadTimer); int tempMeasureCycleCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; void tempReadTimer() // Called many times <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> second, perform only one small operation per call { tempMeasureCycleCount++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tempMeasureCycleCount &gt;= TEMP_MEASURE_PERIOD) { tempMeasureCycleCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; // Start cycle again } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tempMeasureCycleCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ds.reset(); ds.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(<span class="hljs-number"><span class="hljs-number">0xCC</span></span>, TEMP_SENSOR_POWER_MODE); // Request all sensors at the one <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> ds.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(<span class="hljs-number"><span class="hljs-number">0x44</span></span>, TEMP_SENSOR_POWER_MODE); // Acquire temperatures } // Between phases above <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> below should be &gt; <span class="hljs-number"><span class="hljs-number">750</span></span> ms int addr = TEMP_MEASURE_PERIOD - tempMeasureCycleCount - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (addr &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; addr &lt;= lastSensorIndex) { ds.reset(); ds.<span class="hljs-built_in"><span class="hljs-built_in">select</span></span>(tempSensAddr[addr]); ds.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(<span class="hljs-number"><span class="hljs-number">0xBE</span></span>, TEMP_SENSOR_POWER_MODE); // Read Scratchpad tempData[addr] = ds.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() | (ds.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); // Read first <span class="hljs-number"><span class="hljs-number">2</span></span> bytes which carry temperature data } }</code> </pre> <br><p>  Au début de chaque cycle tempMeasureCycleCount, les capteurs sont invités à lire leurs valeurs.  Après environ 50 cycles de ce type (et au total c'est 50 * 20 = 1000 ms = 1 sec), la valeur de chaque capteur est lue, une à la fois.  Tout le travail est divisé en morceaux afin que le code qui s'exécute dans l'interruption du minuteur ne prenne pas beaucoup de temps du contrôleur. </p><br><p>  La valeur du capteur de débit est calculée comme suit.  Par interruption sur la broche sur laquelle le capteur est accroché, on augmente la valeur du compteur de ticks provenant du capteur de débit: </p><br><pre> <code class="hljs pgsql">pinMode(FLOW_SENSOR_PIN, <span class="hljs-keyword"><span class="hljs-keyword">INPUT</span></span>); attachInterrupt(digitalPinToInterrupt(FLOW_SENSOR_PIN), flow, RISING); // Setup Interrupt <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> flow_frequency; // Flow sensor pulses <span class="hljs-type"><span class="hljs-type">int</span></span> flowMeasureCycleCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">void</span></span> flow() // Flow sensor interrupt <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> { flow_frequency++; }</code> </pre> <br><p>  Dans le même temporisateur où les capteurs de température sont interrogés, nous prenons une fois par seconde cette valeur de tick et la traduisons en litres en utilisant la constante FLOW_SENSOR_CONST, dont la valeur peut être trouvée dans les caractéristiques du capteur: </p><br><pre> <code class="hljs pgsql">flowMeasureCycleCount++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowMeasureCycleCount &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> / TEMP_TIMER_PERIODICITY) { flowMeasureCycleCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; litersInMinute = (flow_frequency / FLOW_SENSOR_CONST); // Pulse frequency (Hz) = FLOW_SENSOR_CONST*Q, Q <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> flow rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> L/min. flow_frequency = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span> Counter }</code> </pre> <br><h2>  Enregistrement des données des capteurs et de l'état de l'appareil </h2><br><p>  Lors du développement du mécanisme de journalisation, le fait que l'appareil puisse être soudainement éteint, c'est-à-dire  à presque tout moment.  Lorsque vous arrêtez l'enregistrement, nous devons être en mesure de restaurer tout ce qui a été enregistré au tout dernier moment.  Dans le même temps, nous ne pouvons pas constamment réécrire la même zone de mémoire flash (par exemple, un certain titre à un certain endroit, en se souvenant de la dernière adresse d'enregistrement), afin d'éviter un "effacement" accéléré du lecteur flash à cet endroit. </p><br><p>  Après un certain «cumul», le modèle d'enregistrement suivant a été inventé et mis en œuvre: </p><br><img src="https://habrastorage.org/webt/ue/zv/vg/uezvvgglwxhvsvn5uhdmkiic8ju.png"><br><p>  Chaque enregistrement est un enregistrement contenant des informations sur la valeur actuelle du débit d'eau, les températures des capteurs, ainsi que l'état de l'appareil codé dans l'octet (les bits individuels indiquent si le relais est activé ou non, si le chauffage est activé ou non): </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> litersInMinute = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tempCelsius[<span class="hljs-number"><span class="hljs-number">4</span></span>]{ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> deviceStatus = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Après chaque enregistrement, il y a un octet de somme de contrôle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CRC</a> , indiquant si l'enregistrement a été correctement écrit et en général, si au moins quelque chose a été écrit dans cet emplacement de mémoire. </p><br><p>  Comme il serait trop coûteux d'enregistrer des données sur l'heure actuelle ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">horodatage</a> ) pour chaque enregistrement en termes de volume, les données sont organisées en grands blocs, avec N enregistrements dans chacun.  L'horodatage de chaque bloc n'est enregistré qu'une seule fois, pour le reste - il est calculé en fonction des informations sur la fréquence de journalisation. </p><br><pre> <code class="hljs vhdl"><span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> int logRecordsInBlock = <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> / loggingPeriodSeconds; // <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">block</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> hour <span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> int block_size = sizeof(Block_Header) + logRecordsInBlock * (record_size + crcSize); <span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> int block_count = total_storage_size / block_size;</code> </pre> <br><p>  Par exemple, avec une fréquence d'enregistrement d'une fois toutes les 30 secondes, nous aurons 120 entrées dans un bloc, et la taille du bloc sera d'environ 840 octets.  Au total, nous pouvons insérer 39 blocs dans la mémoire d'un lecteur flash de 32 kilo-octets.  Avec une telle organisation, il s'avère que chaque bloc commence à une adresse strictement définie en mémoire, et «parcourir» tous les blocs n'est pas un problème. </p><br><p>  En conséquence, avec une rupture soudaine du record lors du dernier arrêt de l'appareil, nous aurons un bloc inachevé (c'est-à-dire dans lequel certains des enregistrements sont manquants).  Lorsque l'appareil est allumé, l'algorithme recherche le dernier en-tête de bloc valide (horodatage + crc).  Et continue l'enregistrement, en commençant par le bloc suivant.  L'enregistrement s'effectue cycliquement: le dernier bloc écrase les données du bloc le plus ancien. </p><br><p>  Lors de la lecture, tous les blocs sont lus séquentiellement.  Les blocs non valides (ceux qui ne passent pas le CRC pour l'horodatage) sont entièrement ignorés.  Les enregistrements de chaque bloc sont lus jusqu'à la réunion du premier enregistrement invalide (c'est-à-dire celui sur lequel l'enregistrement a été interrompu la dernière fois si le bloc n'a pas été entièrement enregistré).  Les autres sont ignorés. <br>  Pour chaque enregistrement, l'heure actuelle est calculée en fonction de l'horodatage du bloc et du numéro de série de l'enregistrement dans le bloc. </p><br><h2>  LCD </h2><br><p>  L'appareil utilise un écran QC1602A, capable d'afficher 2 lignes de 16 caractères.  La première ligne affiche les informations actuelles sur les valeurs actuelles des capteurs: débit et températures.  Si la limite spécifiée est dépassée, un point d'exclamation apparaît près de la valeur.  La deuxième ligne indique l'état du relais de chauffage et de la pompe, ainsi que le temps écoulé depuis la mise en marche ou l'arrêt du chauffage.  Toutes les 5 secondes, l'affichage de la deuxième ligne indique brièvement les limites actuelles.  Des photos de l'affichage dans différents modes sont présentées à la fin de la publication. </p><br><h2>  Graphiques </h2><br><p>  Lorsqu'elles sont demandées via le serveur Web intégré, les données de journalisation sont lues sous forme binaire à l'aide de JavaScript: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xhttp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhttp.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"logs.bin"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); xhttp.responseType = <span class="hljs-string"><span class="hljs-string">"arraybuffer"</span></span>; xhttp.onprogress = updateProgress; xhttp.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">oEvent</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrayBuffer = xhttp.response; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arrayBuffer) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> byteArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(arrayBuffer); … }}; xhttp.send(<span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre> <br><p>  Les lire dans un format non binaire populaire, comme ajax, serait un luxe inadmissible pour le contrôleur, principalement en raison de la grande quantité que le serveur http intégré devrait retourner. </p><br><p>  Pour la même raison, la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jqPlot</a> JavaScript est utilisée pour créer des graphiques et les fichiers de la bibliothèque JS eux-mêmes sont chargés à partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CDN</a> populaires. </p><br><p>  Un exemple de la planification de l'appareil: </p><br><img src="https://habrastorage.org/webt/uh/kr/bc/uhkrbccsl1k8l6w_3am6tunwe5a.png"><br><p>  On voit clairement qu'à environ 9h35 l'appareil était allumé pour le chauffage, la chaudière a commencé à chauffer progressivement le circuit de chauffage (capteurs T3, T4), après quoi la température du circuit de la piscine a commencé à augmenter (capteurs T1, T2).  Vers 10 h 20, la chaudière est passée au chauffage de l'eau chaude dans la maison, la température du circuit de chauffage a baissé.  Puis, après 10 minutes supplémentaires, la chaudière s'est remise à chauffer l'eau de la piscine.  À 10 h 50, un accident s'est produit: la pompe pour faire circuler l'eau dans la piscine s'est soudainement éteinte.  Le débit d'eau a fortement chuté à zéro, le relais de chauffage s'est éteint (ligne pointillée rouge sur le 2ème graphique), empêchant une surchauffe.  Mais l'appareil restait toujours dans un état de chauffe (ligne rouge sur le 2ème graphique).  C'est-à-dire  si la pompe était à nouveau allumée et que les températures étaient normales, l'appareil retournerait au chauffage.  Je note qu'après un arrêt d'urgence de la pompe, les températures dans le circuit d'eau de la piscine (T1, T2) ont commencé à augmenter fortement en raison d'une surchauffe de l'échangeur de chaleur.  Et sinon pour un arrêt brutal de la chaudière, il y aurait des ennuis. </p><br><h2>  Serveur Web intégré </h2><br><p>  Pour communiquer avec le monde extérieur, la classe standard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ESP8266WebServer est utilisée</a> .  Lorsque l'appareil démarre, il est initialisé en tant que point d'accès avec le mot de passe par défaut spécifié dans #define AP_PASS.  Une page Web s'ouvre automatiquement pour sélectionner un réseau Wi-Fi disponible et entrer un mot de passe.  Après avoir entré le mot de passe, l'appareil redémarre et se connecte au point d'accès spécifié. </p><br><h2>  Appareil fini </h2><br><p>  Le dispositif fini a été placé dans une boîte de coupe standard pour le câblage.  Un trou pour l'écran LCD a été découpé, et des trous pour les connecteurs. </p><br><img src="https://habrastorage.org/webt/dz/si/tx/dzsitx4tim2kcxqnticd7ln2vho.jpeg"><br><div class="spoiler">  <b class="spoiler_title">Photos de la façade de l'appareil dans différents modes</b> <div class="spoiler_text"><p>  Avec l'affichage du temps écoulé après la mise en marche: </p><br><img src="https://habrastorage.org/webt/fh/gn/fn/fhgnfnf-emu1rl31w7bm4fbmmvs.jpeg"><br><p>  Avec des limites affichées: </p><br><img src="https://habrastorage.org/webt/qi/8c/r2/qi8cr2ex8uwr3e9xgzs5ms__vou.jpeg"></div></div><br><h2>  Conclusion </h2><br><p>  En conclusion, je tiens à dire que, en développant un tel appareil, j'ai acquis une grande expérience des circuits, de la conception de circuits imprimés, des compétences d'installation pour les composants SMD, dans l'architecture et la programmation des microcontrôleurs, je me suis souvenu du C ++ presque oublié et de la manipulation soigneuse de la mémoire et des autres ressources de contrôleur limitées.  La connaissance de HTML5, JavaScript et les compétences de débogage des scripts dans le navigateur ont également été utiles dans une certaine mesure. </p><br><p>  Ces compétences et le plaisir reçu lors du développement de l'appareil sont les principaux avantages obtenus.  Et les codes source de l'appareil, le schéma de circuit, les cartes de circuits imprimés - veuillez utiliser, modifier.  Tous les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">codes source du projet</a> sont sur GitHab.  Matériel dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet public</a> sur EasyEDA.  J'ai collecté des données sur les puces utilisées dans le projet sur un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lecteur réseau</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413955/">https://habr.com/ru/post/fr413955/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413945/index.html">Plus simple qu'il n'y paraît. Chapitres 4-5</a></li>
<li><a href="../fr413947/index.html">Implémentation du travail avec le serveur Long Poll dans le client VKontakte pour Sailfish OS</a></li>
<li><a href="../fr413949/index.html">Pourquoi lisons-nous encore des livres papier?</a></li>
<li><a href="../fr413951/index.html">Apprenez aux autres à devenir un meilleur programmeur</a></li>
<li><a href="../fr413953/index.html">Quand et pourquoi cela vaut la peine d'utiliser les fonctions fléchées ES6, et quand ce n'est pas le cas</a></li>
<li><a href="../fr413957/index.html">Un exemple de création d'une application sportive en temps réel sur Node.js</a></li>
<li><a href="../fr413959/index.html">Plus petite image Docker - moins de 1 000 octets</a></li>
<li><a href="../fr413963/index.html">Mini CRM pour les petites entreprises</a></li>
<li><a href="../fr413965/index.html">Revue de code: vous vous trompez</a></li>
<li><a href="../fr413967/index.html">Rétro-ingénierie du mode développeur Animal Crossing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>