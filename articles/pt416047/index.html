<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüåæ üîå üì© Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 2: ‚ÄúControle de ataques de hackers‚Äù, parte 2 üë®‚Äçüë©‚Äçüëß üõ©Ô∏è üÉè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula n¬∫ 6.858. "Seguran√ßa de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 2: ‚ÄúControle de ataques de hackers‚Äù, parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416047/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula n¬∫ 6.858.  "Seguran√ßa de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security √© um curso sobre o desenvolvimento e implementa√ß√£o de sistemas de computador seguros.  As palestras abrangem modelos de amea√ßas, ataques que comprometem a seguran√ßa e t√©cnicas de seguran√ßa baseadas em trabalhos cient√≠ficos recentes.  Os t√≥picos incluem seguran√ßa do sistema operacional (SO), recursos, gerenciamento de fluxo de informa√ß√µes, seguran√ßa de idiomas, protocolos de rede, seguran√ßa de hardware e seguran√ßa de aplicativos da web. <br><br>  Palestra 1: ‚ÄúIntrodu√ß√£o: modelos de amea√ßas‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: ‚ÄúControle de ataques de hackers‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Ent√£o, temos um buffer sobre o qual colocamos o "can√°rio".  Acima disso, o valor do <b>EBP salvo pelo</b> ponteiro do ponto de interrup√ß√£o <b>salvo</b> e o endere√ßo de retorno √© colocado acima dele.  Se voc√™ se lembrar, o estouro vai de baixo para cima; portanto, antes de chegar ao endere√ßo de retorno, ele primeiro destruir√° o "can√°rio". <br><br><img src="https://habrastorage.org/webt/va/0q/i_/va0qi_40d-7cknrooq7olqwfbga.jpeg"><br><br>  <b>P√∫blico:</b> por que isso afetar√° o "can√°rio"? <br><br>  <b>Professor:</b> porque √© assumido que o atacante n√£o sabe "pular" arbitrariamente na mem√≥ria.  Os ataques tradicionais de estouro de mem√≥ria come√ßam com um hacker examinando o limite de tamanho do buffer, ap√≥s o qual o estouro come√ßa na linha inferior.  Mas voc√™ est√° certo - se um invasor puder entrar diretamente na barra de endere√ßo de retorno, nenhum ‚Äúcan√°rio‚Äù nos ajudar√°.  No entanto, com um ataque tradicional de estouro de buffer, tudo deve acontecer exatamente dessa maneira - de baixo para cima. <br><br>  Assim, a id√©ia principal de usar um "can√°rio" √© que permitimos que uma explora√ß√£o mal-intencionada transborde o buffer de mem√≥ria.  Temos um c√≥digo de tempo de execu√ß√£o que, ao retornar de uma fun√ß√£o, verifica o "can√°rio" para garantir que ele tenha o valor correto. <br><br>  <b>P√∫blico:</b> Um invasor pode reescrever o endere√ßo de retorno e alterar o "can√°rio"?  Como ele pode verificar se foi modificado, mas continua cumprindo sua fun√ß√£o? <br><br>  <b>Professor:</b> sim, talvez.  Portanto, voc√™ deve ter algum peda√ßo de c√≥digo que realmente verifique isso antes que a fun√ß√£o retorne.  Ou seja, nesse caso, √© necess√°rio ter o suporte de um compilador, que realmente expandir√° a <b>conven√ß√£o de chamada</b> .  Portanto, essa parte da sequ√™ncia de retorno ocorre antes de considerarmos a validade desse valor para garantir que o "can√°rio" n√£o tenha sido destru√≠do.  Somente depois disso podemos pensar em outra coisa. <br><br>  <b>P√∫blico:</b> Um invasor n√£o pode saber ou adivinhar o que significa "can√°rio"? <br><br>  <b>Professor:</b> √© exatamente disso que eu vou falar!  Qual √© o problema com este circuito?  E se, por exemplo, colocarmos o valor A em cada programa?  Ou um ramo inteiro de 4 valores de A?  Obviamente, qualquer hacker pode descobrir o tamanho do buffer, sua capacidade e, assim, determinar a posi√ß√£o do "can√°rio" em qualquer sistema.  Portanto, podemos usar diferentes tipos de quantidades que colocamos em nosso "can√°rio" para evitar isso. <br><br>  H√° uma coisa que voc√™ pode fazer com o nosso "can√°rio".  Ser√° um tipo muito engra√ßado de "can√°rio", que usa fun√ß√µes do programa C e processa caracteres especiais, o chamado tipo determin√≠stico de "can√°rio". <br><br><img src="https://habrastorage.org/webt/ww/nu/7w/wwnu7wtc-tnfgf7iwtux0guvoli.jpeg"><br><br>  Imagine que voc√™ usou o caractere 0 para o ‚Äúcan√°rio‚Äù .O valor bin√°rio de zero √© o byte zero, o caractere zero em ASCII.  Um valor de -1 significa um retorno √† posi√ß√£o anterior e assim por diante.  Muitas fun√ß√µes param ou alteram a opera√ß√£o quando encontram caracteres ou valores como 0, CR, LF, -1.  Imagine que voc√™, como hacker, usa alguma fun√ß√£o de gerenciamento de string para subir no buffer, encontrar o caractere 0 no "can√°rio" e o processo √© interrompido!  Se voc√™ usar a fun√ß√£o ‚Äúretorno de carro‚Äù -1, que geralmente √© usada como terminador de linha, o processo tamb√©m ser√° interrompido.  Ent√£o -1 √© outro sinal m√°gico. <br><br>  H√° mais uma coisa que pode ser usada no "can√°rio" - esses s√£o valores aleat√≥rios dif√≠ceis de adivinhar para o atacante.  O poder do valor aleat√≥rio baseia-se em como √© dif√≠cil para um invasor adivinhar.  Por exemplo, se um invasor perceber que h√° apenas 3 bits de entropia no seu sistema, ele poder√° usar um ataque de for√ßa bruta.  Portanto, as possibilidades de usar n√∫meros aleat√≥rios para proteger contra ataques s√£o bastante limitadas. <br><br><img src="https://habrastorage.org/webt/a0/qf/au/a0qfauye6kmbnvhhfifmesgudy0.jpeg"><br><br>  <b>P√∫blico:</b> Geralmente, eu leio de outro buffer e escrevo o que li nesse buffer desta pilha.  Nessa situa√ß√£o, parece que o valor aleat√≥rio do "can√°rio" √© in√∫til, porque leio os dados de outro buffer e sei onde est√° o "can√°rio".  Eu tenho outro buffer que controlo e que nunca verifico.  E nesse buffer eu posso colocar muito do que eu quero colocar.  N√£o preciso de um "can√°rio" aleat√≥rio, porque posso reescrev√™-lo com seguran√ßa.  Portanto, n√£o vejo como isso realmente funciona - no cen√°rio que voc√™ prop√¥s, quando a fun√ß√£o para ao ler dados do buffer. <br><br>  <b>Professor:</b> Entendo sua pergunta - voc√™ quer dizer que usamos um "can√°rio" determin√≠stico, mas n√£o usamos uma das fun√ß√µes da biblioteca padr√£o que pode ser "enganada" por nossos personagens 0, CR, LF, -1.  Ent√£o sim, na situa√ß√£o que voc√™ descreveu, um "can√°rio" n√£o √© necess√°rio. <br><br>  A id√©ia √© que voc√™ possa preencher esse buffer com bytes de qualquer lugar, mas qualquer coisa que permita adivinhar esses valores ou obt√™-los aleatoriamente levar√° √† falha. <br><br>  <b>P√∫blico:</b> √â poss√≠vel usar algo como o n√∫mero de segundos ou milissegundos como n√∫meros aleat√≥rios e us√°-los em um "can√°rio"? <br><br>  <b>Professor:</b> As chamadas de dados n√£o cont√™m tantos acidentes quanto voc√™ pensa.  Como o programa possui logs ou uma fun√ß√£o que voc√™ pode chamar para descobrir quando o programa foi baixado e outras coisas semelhantes.  Mas, em geral, voc√™ est√° certo - na pr√°tica, se voc√™ pode usar um dispositivo de hardware, geralmente de baixo n√≠vel, com melhores tempos de sistema, esse tipo de abordagem pode funcionar. <br><br>  <b>P√∫blico:</b> mesmo que consigamos visualizar os logs sobre o in√≠cio do estouro de buffer, ainda √© importante a que horas recusamos a solicita√ß√£o.  E se n√£o conseguirmos controlar o tempo que a solicita√ß√£o de um computador ao servidor leva, √© duvidoso que o tempo exato possa ser determinado de maneira determin√≠stica. <br><br>  <b>Professor:</b> muito bem, eu j√° disse que o mal est√° nos detalhes, esse √© exatamente o caso.  Em outras palavras, se voc√™ tiver alguma maneira de, por exemplo, determinar o tipo de canal de temporiza√ß√£o, poder√° descobrir que a quantidade de entropia, ou o n√∫mero de aleatoriedade, preenche n√£o um carimbo de data / hora inteiro, mas muito menos.  Portanto, um invasor pode determinar a hora e o minuto em que voc√™ fez isso, mas n√£o um segundo. <br><br>  <b>P√∫blico:</b> para constar, tentar reduzir sua pr√≥pria aleatoriedade √© uma m√° id√©ia? <br><br>  <b>Professor:</b> absolutamente certo! <br><br>  <b>P√∫blico:</b> ou seja, normalmente, apenas precisamos usar tudo o que nossos sistemas suportam, certo? <br><br>  <b>Professor:</b> sim, √© verdade.  √â como a inven√ß√£o de nosso pr√≥prio sistema de criptografia, que √© outra coisa popular que nossos graduados √†s vezes querem fazer.  Mas n√≥s n√£o somos a NSA, n√£o somos matem√°ticos, ent√£o isso geralmente falha.  Ent√£o voc√™ est√° absolutamente certo sobre isso. <br><br>  Mas mesmo se voc√™ usar a aleatoriedade do sistema, ainda poder√° obter menos bits de entropia do que o esperado.  Deixe-me dar um exemplo de randomiza√ß√£o de fase de endere√ßos.  √â nesse princ√≠pio que a abordagem dos <b>can√°rios de pilha funciona</b> .  Como estamos envolvidos na seguran√ßa de computadores, voc√™ provavelmente est√° se perguntando em que casos os "can√°rios" n√£o conseguem lidar com a tarefa deles e se existem maneiras de falhar no "can√°rio". <br><br>  Uma delas √© um ataque reescrevendo ponteiros de fun√ß√£o.  Porque se um golpe √© atingido no ponteiro de fun√ß√£o, o "can√°rio" n√£o pode fazer nada. <br><br>  Suponha que voc√™ tenha um c√≥digo no formato <b>int * ptr ... ..</b> , o ponteiro inicial, n√£o importa como, ent√£o voc√™ tem o buffer bu <b>buf [128]</b> , a fun√ß√£o <b>gets (buf)</b> e, no fundo, um ponteiro ao qual √© atribu√≠do algum valor : <b>* ptr = 5</b> . <br><br>  Observo que n√£o tentamos atacar o endere√ßo de retorno da fun√ß√£o que cont√©m esse c√≥digo.  Como voc√™ pode ver, quando o buffer estourar, o endere√ßo do ponteiro localizado acima dele ser√° danificado.  Se um invasor pode danificar esse ponteiro, ele pode atribuir 5 a um dos endere√ßos que ele controla.  Todos podem ver que o "can√°rio" n√£o vai ajudar aqui?  Porque n√£o atacamos o caminho ao longo do qual a fun√ß√£o retorna. <br><br><img src="https://habrastorage.org/webt/hz/oq/em/hzoqemqhfljf4w6rzownchcppbc.jpeg"><br><br>  <b>P√∫blico:</b> o ponteiro pode estar localizado abaixo do buffer? <br><br>  <b>Professor:</b> pode, mas a ordem das vari√°veis ‚Äã‚Äãespec√≠ficas depende de muitas coisas diferentes, da maneira como o compilador organiza o conte√∫do, do tamanho da coluna de hardware e assim por diante.  Mas voc√™ est√° certo, se o estouro do buffer subir e o ponteiro estiver localizado abaixo do buffer, ele n√£o poder√° danific√°-lo. <br><br>  <b>P√∫blico-alvo:</b> por que voc√™ n√£o pode associar o "can√°rio" √† fun√ß√£o "can√°rio", como fez com o endere√ßo de retorno? <br><br>  <b>Professor:</b> este √© um momento interessante!  Voc√™ pode fazer essas coisas.  De fato, voc√™ pode tentar imaginar um compilador que, sempre que tiver um ponteiro, ele sempre tenta adicionar um complemento para algumas coisas.  No entanto, verificar todas essas coisas ser√° muito caro.  Porque toda vez que voc√™ deseja usar qualquer ponteiro ou chamar qualquer fun√ß√£o, voc√™ deve ter um c√≥digo que verifique se esse "can√°rio" est√° correto.  Basicamente, voc√™ poderia fazer algo semelhante, mas isso faz sentido?  Vemos que os "can√°rios" n√£o ajudam nessa situa√ß√£o. <br><br>  E mais uma coisa que discutimos anteriormente √© que, se o atacante puder adivinhar a aleatoriedade, ent√£o, em princ√≠pio, os "can√°rios" aleat√≥rios n√£o funcionar√£o.  A cria√ß√£o de recursos de seguran√ßa com base na aleatoriedade √© um t√≥pico separado e muito complexo, por isso n√£o entraremos em detalhes. <br><br><img src="https://habrastorage.org/webt/1v/iw/s5/1viws5-axjes3hud4zigpabrxas.jpeg"><br><br>  <b>P√∫blico-alvo: o</b> canary cont√©m menos bits que um endere√ßo de retorno?  Porque, caso contr√°rio, voc√™ n√£o conseguia se lembrar desse endere√ßo e verificar se ele mudou? <br><br>  <b>Professor:</b> vamos ver.  Voc√™ est√° falando sobre esse esquema quando o "can√°rio" est√° localizado acima do buffer e quer dizer que o sistema n√£o pode ser seguro se for imposs√≠vel olhar para o endere√ßo de retorno e verificar se ele foi alterado. <br><br><img src="https://habrastorage.org/webt/xg/nf/1m/xgnf1mj-jvjf1g1lu27xu7di4pm.jpeg"><br><br>  Sim e n√£o  Observe que, se ocorrer um ataque de estouro de buffer, qualquer coisa acima dele ser√° sobrescrito; portanto, isso ainda poder√° causar problemas.  Mas, basicamente, se essas coisas s√£o imut√°veis ‚Äã‚Äãde certa forma, voc√™ pode fazer algo assim.  Mas o problema √© que, em muitos casos, manipular o endere√ßo de retorno √© algo bastante complicado.  Porque voc√™ pode imaginar que uma fun√ß√£o especial pode ser chamada de lugares diferentes, e assim por diante.  Nesse caso, corremos um pouco √† frente e, se houver tempo no final da palestra, voltaremos a isso. <br><br>  S√£o situa√ß√µes em que um "can√°rio" pode falhar.  Existem outros locais onde a falha √© poss√≠vel, por exemplo, ao atacar as fun√ß√µes <b>malloc</b> e <b>free</b> .  A fun√ß√£o malloc aloca um bloco de mem√≥ria de um determinado tamanho em bytes e retorna um ponteiro para o in√≠cio do bloco.  O conte√∫do do bloco de mem√≥ria alocado n√£o √© inicializado, permanece com valores indefinidos.  E a fun√ß√£o <b>livre</b> libera mem√≥ria previamente alocada dinamicamente. <br><br>  Este √© um ataque √∫nico no estilo de C. Vamos ver o que acontece aqui.  Imagine que voc√™ tem dois ponteiros aqui, p e q, para os quais usamos <b>malloc para</b> alocar 1,024 bytes de mem√≥ria para cada um desses ponteiros.  Suponha que fa√ßamos a fun√ß√£o <b>strcpy</b> para p com algum tipo de erro de buffer controlado por um invasor.  √â aqui que o estouro ocorre.  E ent√£o executamos o comando <b>free q</b> e <b>free p</b> .  Este √© um c√≥digo bastante simples, certo? <br><br><img src="https://habrastorage.org/webt/dt/o7/rt/dto7rtltvhx7lcdnytlifp7cvzw.jpeg"><br><br>  Temos dois ponteiros para os quais alocamos mem√≥ria, usamos um deles para uma determinada fun√ß√£o, ocorre um estouro de buffer e liberamos a mem√≥ria dos dois ponteiros. <br><br>  Suponha que as linhas de mem√≥ria de peq estejam localizadas pr√≥ximas uma da outra no espa√ßo da mem√≥ria.  Nesse caso, coisas ruins podem acontecer, certo?  Como a fun√ß√£o <b>strcpy</b> √© usada para copiar o conte√∫do de <b>str2</b> para <b>str1</b> .  <b>Str2</b> deve ser um ponteiro para uma string que termina com zero e <b>strcpy</b> retorna um ponteiro para <b>str1</b> .  Se as linhas <b>str1</b> e <b>str2 se</b> sobrepuserem, o comportamento da fun√ß√£o <b>strcpy</b> ser√° indefinido. <br><br>  Portanto, a fun√ß√£o <b>strycpy</b> que processa a mem√≥ria <b>p</b> pode ao mesmo tempo afetar a mem√≥ria alocada para <b>q</b> .  E isso pode causar problemas. <br><br>  √â poss√≠vel que voc√™ tenha feito algo assim em seu pr√≥prio c√≥digo inadvertidamente quando usou algum tipo de ponteiro estranho.  E tudo parece funcionar, mas quando voc√™ precisa chamar a fun√ß√£o <b>livre</b> , ocorre um inc√¥modo.  E um invasor pode tirar proveito disso, explicarei por que isso acontece. <br><br>  Imagine que, dentro da implementa√ß√£o das fun√ß√µes <b>free</b> e <b>malloc</b> , o bloco real√ßado se parece com isso. <br><br>  Vamos supor que no topo do bloco haja dados vis√≠veis do aplicativo e abaixo tenhamos o tamanho da vari√°vel.  Esse tamanho n√£o √© o que o aplicativo v√™ diretamente, mas um tipo de "contabilidade" conduzida por <b>free</b> ou <b>malloc</b> , para que voc√™ saiba o tamanho do buffer de mem√≥ria alocado.  Um bloco livre est√° localizado pr√≥ximo ao bloco real√ßado.  Suponha que um bloco livre tenha alguns metadados parecidos com este: temos o tamanho do bloco acima, h√° espa√ßo livre abaixo dele, o ponteiro de tr√°s e o ponteiro de avan√ßo abaixo dele.  E na parte inferior do bloco, o tamanho √© mostrado novamente. <br><br><img src="https://habrastorage.org/webt/vx/q5/-w/vxq5-wfiisbatr5dzny9xaqd7vk.jpeg"><br><br>  Por que temos 2 ponteiros aqui?  Como o sistema de aloca√ß√£o de mem√≥ria, nesse caso, usa uma lista duplamente vinculada para rastrear como os blocos livres est√£o relacionados entre si.  Portanto, ao selecionar um bloco livre, voc√™ o exclui desta lista duplamente vinculada.  E ent√£o, quando voc√™ o liberar, far√° alguma aritm√©tica para o ponteiro e colocar√° essas coisas em ordem.  Depois disso, voc√™ o adiciona a esta lista vinculada, certo? <br><br>  Sempre que voc√™ ouvir sobre a aritm√©tica dos ponteiros, pense que este √© o seu "can√°rio".  Porque haver√° muitos problemas.  Deixe-me lembr√°-lo de que tivemos um buffer overflow <b>p</b> .  Se assumirmos que <b>p</b> e <b>q</b> est√£o pr√≥ximos um do outro, ou muito pr√≥ximos no espa√ßo da mem√≥ria, pode acontecer que esse estouro de buffer possa sobrescrever alguns dados de tamanho do ponteiro alocado <b>q</b> - essa √© a parte inferior do nosso bloco alocado.  Se voc√™ continuar seguindo meu pensamento desde o in√≠cio, sua imagina√ß√£o lhe dir√° onde tudo come√ßa a dar errado.  De fato, em ess√™ncia, o que finalmente acontece com essas opera√ß√µes √© <b>q livre</b> e <b>p livre</b> - eles examinam esses metadados no bloco selecionado para fazer todas as manipula√ß√µes necess√°rias com o ponteiro. <br><br><img src="https://habrastorage.org/webt/an/mo/ug/anmouglu2dii_itv9qshxsu4qes.jpeg"><br><br>  Ou seja, em algum momento da execu√ß√£o, as fun√ß√µes <b>livres</b> receber√£o um certo ponteiro com base no valor do tamanho: <b>p = get.free.block (size)</b> , e o tamanho √© o que o invasor controla, porque realizou um estouro de buffer corretamente ? <br><br>  Ele fez v√°rios c√°lculos aritm√©ticos, olhou para a fun√ß√£o <b>back</b> e os ponteiros deste bloco e agora far√° algo como atualizar os ponteiros ‚Äúback‚Äù e ‚Äúforward‚Äù - estas s√£o as duas √∫ltimas linhas. <br><br><img src="https://habrastorage.org/webt/bv/dt/x_/bvdtx_om6lkusoykjinpssiqro8.jpeg"><br><br>  Mas, na realidade, isso n√£o deve incomod√°-lo.  Este √© apenas um exemplo do c√≥digo que ocorre neste caso.  Mas o fato √© que, devido ao tamanho reescrito pelo hacker, ele agora controla esse ponteiro, que passa pela fun√ß√£o <b>free</b> .  E por causa disso, os dois estados aqui na linha inferior s√£o, na verdade, atualiza√ß√µes de ponteiros.  E como o invasor conseguiu controlar esse <b>p</b> , ele realmente controla esses dois indicadores.  √â neste local que um ataque pode ocorrer. <br><br>  Portanto, ao correr <b>livre</b> e tentar fazer algo como combinar esses dois blocos, voc√™ tem uma lista duplamente vinculada.  Porque se voc√™ tiver dois blocos que colidem um com o outro e os dois estiverem livres, deseje combin√°-los em um grande bloco. <br><br>  Mas se controlarmos o tamanho, significa que controlaremos todo o processo a partir das quatro linhas acima.  Isso significa que, se entendermos como o estouro funciona, poderemos gravar dados na mem√≥ria da maneira que escolhermos.  Como eu disse, essas coisas geralmente acontecem com seu pr√≥prio c√≥digo, se voc√™ n√£o √© inteligente com um ponteiro.  Quando voc√™ comete algum erro duplo livre como <b>free q</b> e <b>free p</b> ou outra coisa, sua fun√ß√£o falha.  Como voc√™ mexeu com os metadados que vivem em cada um desses blocos selecionados e, em algum momento, esse c√°lculo indicar√° algum tipo de valor "lixo", ap√≥s o qual voc√™ estar√° "morto".  Mas se voc√™ √© um invasor, pode escolher esse valor e us√°-lo em seu proveito. <br><br>  Vamos para outra abordagem para evitar ataques de estouro de buffer.  Essa abordagem √© verificar os limites.  O objetivo da verifica√ß√£o de limites √© garantir que, ao usar um ponteiro espec√≠fico, ele se refira apenas ao que √© um objeto de mem√≥ria.  E esse ponteiro est√° dentro dos limites permitidos desse objeto de mem√≥ria.  Essa √© a principal id√©ia da verifica√ß√£o.       ‚Äî   .  ,    C,      . ,      : ,         ,    ? <br><br>   ,        ‚Äì    .      1024    ,         : <b>char  [1024]</b> , <b>char *y = &amp;  [108].</b> <br><br><img src="https://habrastorage.org/webt/ms/_z/bq/ms_zbqzotz_bt7ya9dpcfsuftxq.jpeg"><br><br>    ?    ?  Dif√≠cil dizer.       ,  ,     .      ,  ,   -    . <br>       - , ,      ,   .         .  ,    ,      ,   .  ,   ,      .     ,     ,    . <br><br>    ,     ,      <b>struct</b>   <b>union</b> . ,     .     :     <b>integer</b> ,   <b>struct</b> ,      <b>int</b> . <br><br>  ,  <b>union</b>  ,           .        ,    <b>integer</b>  ,   <b>struct</b> ,    . <br><br> ,     ,   -  : <b>int  p: &amp; (u,s,k)</b> ,      :  u,   s,  k. <br><br><img src="https://habrastorage.org/webt/rp/5p/ph/rp5pphcqpcdmmzhfs6tfy6yhtvg.jpeg"><br><br>  ,    ,    ,     ,    .     ,  ,  <b>union</b>   <b>integer</b> ,   <b>struct</b> .  ,       ,    ,           .      . <br><br>      <b>p'</b> ,     <b>p</b> ,   <b>p'</b>      ,    . <br><br><img src="https://habrastorage.org/webt/_j/hb/d1/_jhbd1twr0i0fex98ytm7bdzfu8.jpeg"><br><br> ,     ,       .          , ,   <b>union</b> .   ,   -    -        <b>union</b> , ,  ,      .        ,        ,   X. ,   ,      ,  ,    .   ,    ,   .        . <br><br>         ,        .      ,      <b>p</b>  <b>p'</b> ,     .        . <br><br>     ?        Electric fencing ‚Äì  .    ,    ,     ,    ,      . <br><br><img src="https://habrastorage.org/webt/eg/c5/bp/egc5bpv_lhcf6c6vgy_i5z5_zgo.jpeg"><br><br>       ,    -    ,    .   ,      ,     .    ,   .       ,   ,        ,    . <br><br>   -     C  C++,    ,     ,      .      - ,  ,  -   .      ,    .    ,   ¬´¬ª ‚Äî  ,          ,   ,     .    ,      ,       . <br><br>       ,         guard page ‚Äì !  ,   . <br><br> 59:00  <br><br> : <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> MIT ¬´  ¬ª.  2: ¬´  ¬ª,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/r4KjHEgg9Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  A vers√£o completa do curso est√° dispon√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416047/">https://habr.com/ru/post/pt416047/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416029/index.html">Computador l√≠quido: captura de √≠ons em grafeno</a></li>
<li><a href="../pt416035/index.html">Scanner 3D odontol√≥gico Shining 3D Autoscan DS EX (Unboxing) por 3Dtool</a></li>
<li><a href="../pt416037/index.html">Inicializa√ß√£o do dia (abril a junho de 2018)</a></li>
<li><a href="../pt416043/index.html">Os pa√≠ses em desenvolvimento est√£o cada vez mais explorando o espa√ßo sideral.</a></li>
<li><a href="../pt416045/index.html">No-break SRC1KI da APC Smart-UPS: Confiabilidade acima de tudo</a></li>
<li><a href="../pt416049/index.html">Codec AV1 Next Generation: Filtro de Corre√ß√£o Direcional CDEF</a></li>
<li><a href="../pt416051/index.html">Mitap de ver√£o Apache Ignite em Moscou</a></li>
<li><a href="../pt416053/index.html">Modula√ß√£o de amplitude de um sinal arbitr√°rio</a></li>
<li><a href="../pt416055/index.html">Atribui√ß√£o e suporte ao FQDN do servidor 3QX</a></li>
<li><a href="../pt416059/index.html">Mobio conversa com Daniil Shuleiko (Yandex.Taxi) sobre fus√£o com Uber, mercado de t√°xi e concorr√™ncia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>