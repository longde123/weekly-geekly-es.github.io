<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🌾 🔌 📩 Curso MIT "Segurança de sistemas de computadores". Palestra 2: “Controle de ataques de hackers”, parte 2 👨‍👩‍👧 🛩️ 🃏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula nº 6.858. "Segurança de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Segurança de sistemas de computadores". Palestra 2: “Controle de ataques de hackers”, parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416047/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula nº 6.858.  "Segurança de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security é um curso sobre o desenvolvimento e implementação de sistemas de computador seguros.  As palestras abrangem modelos de ameaças, ataques que comprometem a segurança e técnicas de segurança baseadas em trabalhos científicos recentes.  Os tópicos incluem segurança do sistema operacional (SO), recursos, gerenciamento de fluxo de informações, segurança de idiomas, protocolos de rede, segurança de hardware e segurança de aplicativos da web. <br><br>  Palestra 1: “Introdução: modelos de ameaças” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: “Controle de ataques de hackers” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Então, temos um buffer sobre o qual colocamos o "canário".  Acima disso, o valor do <b>EBP salvo pelo</b> ponteiro do ponto de interrupção <b>salvo</b> e o endereço de retorno é colocado acima dele.  Se você se lembrar, o estouro vai de baixo para cima; portanto, antes de chegar ao endereço de retorno, ele primeiro destruirá o "canário". <br><br><img src="https://habrastorage.org/webt/va/0q/i_/va0qi_40d-7cknrooq7olqwfbga.jpeg"><br><br>  <b>Público:</b> por que isso afetará o "canário"? <br><br>  <b>Professor:</b> porque é assumido que o atacante não sabe "pular" arbitrariamente na memória.  Os ataques tradicionais de estouro de memória começam com um hacker examinando o limite de tamanho do buffer, após o qual o estouro começa na linha inferior.  Mas você está certo - se um invasor puder entrar diretamente na barra de endereço de retorno, nenhum “canário” nos ajudará.  No entanto, com um ataque tradicional de estouro de buffer, tudo deve acontecer exatamente dessa maneira - de baixo para cima. <br><br>  Assim, a idéia principal de usar um "canário" é que permitimos que uma exploração mal-intencionada transborde o buffer de memória.  Temos um código de tempo de execução que, ao retornar de uma função, verifica o "canário" para garantir que ele tenha o valor correto. <br><br>  <b>Público:</b> Um invasor pode reescrever o endereço de retorno e alterar o "canário"?  Como ele pode verificar se foi modificado, mas continua cumprindo sua função? <br><br>  <b>Professor:</b> sim, talvez.  Portanto, você deve ter algum pedaço de código que realmente verifique isso antes que a função retorne.  Ou seja, nesse caso, é necessário ter o suporte de um compilador, que realmente expandirá a <b>convenção de chamada</b> .  Portanto, essa parte da sequência de retorno ocorre antes de considerarmos a validade desse valor para garantir que o "canário" não tenha sido destruído.  Somente depois disso podemos pensar em outra coisa. <br><br>  <b>Público:</b> Um invasor não pode saber ou adivinhar o que significa "canário"? <br><br>  <b>Professor:</b> é exatamente disso que eu vou falar!  Qual é o problema com este circuito?  E se, por exemplo, colocarmos o valor A em cada programa?  Ou um ramo inteiro de 4 valores de A?  Obviamente, qualquer hacker pode descobrir o tamanho do buffer, sua capacidade e, assim, determinar a posição do "canário" em qualquer sistema.  Portanto, podemos usar diferentes tipos de quantidades que colocamos em nosso "canário" para evitar isso. <br><br>  Há uma coisa que você pode fazer com o nosso "canário".  Será um tipo muito engraçado de "canário", que usa funções do programa C e processa caracteres especiais, o chamado tipo determinístico de "canário". <br><br><img src="https://habrastorage.org/webt/ww/nu/7w/wwnu7wtc-tnfgf7iwtux0guvoli.jpeg"><br><br>  Imagine que você usou o caractere 0 para o “canário” .O valor binário de zero é o byte zero, o caractere zero em ASCII.  Um valor de -1 significa um retorno à posição anterior e assim por diante.  Muitas funções param ou alteram a operação quando encontram caracteres ou valores como 0, CR, LF, -1.  Imagine que você, como hacker, usa alguma função de gerenciamento de string para subir no buffer, encontrar o caractere 0 no "canário" e o processo é interrompido!  Se você usar a função “retorno de carro” -1, que geralmente é usada como terminador de linha, o processo também será interrompido.  Então -1 é outro sinal mágico. <br><br>  Há mais uma coisa que pode ser usada no "canário" - esses são valores aleatórios difíceis de adivinhar para o atacante.  O poder do valor aleatório baseia-se em como é difícil para um invasor adivinhar.  Por exemplo, se um invasor perceber que há apenas 3 bits de entropia no seu sistema, ele poderá usar um ataque de força bruta.  Portanto, as possibilidades de usar números aleatórios para proteger contra ataques são bastante limitadas. <br><br><img src="https://habrastorage.org/webt/a0/qf/au/a0qfauye6kmbnvhhfifmesgudy0.jpeg"><br><br>  <b>Público:</b> Geralmente, eu leio de outro buffer e escrevo o que li nesse buffer desta pilha.  Nessa situação, parece que o valor aleatório do "canário" é inútil, porque leio os dados de outro buffer e sei onde está o "canário".  Eu tenho outro buffer que controlo e que nunca verifico.  E nesse buffer eu posso colocar muito do que eu quero colocar.  Não preciso de um "canário" aleatório, porque posso reescrevê-lo com segurança.  Portanto, não vejo como isso realmente funciona - no cenário que você propôs, quando a função para ao ler dados do buffer. <br><br>  <b>Professor:</b> Entendo sua pergunta - você quer dizer que usamos um "canário" determinístico, mas não usamos uma das funções da biblioteca padrão que pode ser "enganada" por nossos personagens 0, CR, LF, -1.  Então sim, na situação que você descreveu, um "canário" não é necessário. <br><br>  A idéia é que você possa preencher esse buffer com bytes de qualquer lugar, mas qualquer coisa que permita adivinhar esses valores ou obtê-los aleatoriamente levará à falha. <br><br>  <b>Público:</b> É possível usar algo como o número de segundos ou milissegundos como números aleatórios e usá-los em um "canário"? <br><br>  <b>Professor:</b> As chamadas de dados não contêm tantos acidentes quanto você pensa.  Como o programa possui logs ou uma função que você pode chamar para descobrir quando o programa foi baixado e outras coisas semelhantes.  Mas, em geral, você está certo - na prática, se você pode usar um dispositivo de hardware, geralmente de baixo nível, com melhores tempos de sistema, esse tipo de abordagem pode funcionar. <br><br>  <b>Público:</b> mesmo que consigamos visualizar os logs sobre o início do estouro de buffer, ainda é importante a que horas recusamos a solicitação.  E se não conseguirmos controlar o tempo que a solicitação de um computador ao servidor leva, é duvidoso que o tempo exato possa ser determinado de maneira determinística. <br><br>  <b>Professor:</b> muito bem, eu já disse que o mal está nos detalhes, esse é exatamente o caso.  Em outras palavras, se você tiver alguma maneira de, por exemplo, determinar o tipo de canal de temporização, poderá descobrir que a quantidade de entropia, ou o número de aleatoriedade, preenche não um carimbo de data / hora inteiro, mas muito menos.  Portanto, um invasor pode determinar a hora e o minuto em que você fez isso, mas não um segundo. <br><br>  <b>Público:</b> para constar, tentar reduzir sua própria aleatoriedade é uma má idéia? <br><br>  <b>Professor:</b> absolutamente certo! <br><br>  <b>Público:</b> ou seja, normalmente, apenas precisamos usar tudo o que nossos sistemas suportam, certo? <br><br>  <b>Professor:</b> sim, é verdade.  É como a invenção de nosso próprio sistema de criptografia, que é outra coisa popular que nossos graduados às vezes querem fazer.  Mas nós não somos a NSA, não somos matemáticos, então isso geralmente falha.  Então você está absolutamente certo sobre isso. <br><br>  Mas mesmo se você usar a aleatoriedade do sistema, ainda poderá obter menos bits de entropia do que o esperado.  Deixe-me dar um exemplo de randomização de fase de endereços.  É nesse princípio que a abordagem dos <b>canários de pilha funciona</b> .  Como estamos envolvidos na segurança de computadores, você provavelmente está se perguntando em que casos os "canários" não conseguem lidar com a tarefa deles e se existem maneiras de falhar no "canário". <br><br>  Uma delas é um ataque reescrevendo ponteiros de função.  Porque se um golpe é atingido no ponteiro de função, o "canário" não pode fazer nada. <br><br>  Suponha que você tenha um código no formato <b>int * ptr ... ..</b> , o ponteiro inicial, não importa como, então você tem o buffer bu <b>buf [128]</b> , a função <b>gets (buf)</b> e, no fundo, um ponteiro ao qual é atribuído algum valor : <b>* ptr = 5</b> . <br><br>  Observo que não tentamos atacar o endereço de retorno da função que contém esse código.  Como você pode ver, quando o buffer estourar, o endereço do ponteiro localizado acima dele será danificado.  Se um invasor pode danificar esse ponteiro, ele pode atribuir 5 a um dos endereços que ele controla.  Todos podem ver que o "canário" não vai ajudar aqui?  Porque não atacamos o caminho ao longo do qual a função retorna. <br><br><img src="https://habrastorage.org/webt/hz/oq/em/hzoqemqhfljf4w6rzownchcppbc.jpeg"><br><br>  <b>Público:</b> o ponteiro pode estar localizado abaixo do buffer? <br><br>  <b>Professor:</b> pode, mas a ordem das variáveis ​​específicas depende de muitas coisas diferentes, da maneira como o compilador organiza o conteúdo, do tamanho da coluna de hardware e assim por diante.  Mas você está certo, se o estouro do buffer subir e o ponteiro estiver localizado abaixo do buffer, ele não poderá danificá-lo. <br><br>  <b>Público-alvo:</b> por que você não pode associar o "canário" à função "canário", como fez com o endereço de retorno? <br><br>  <b>Professor:</b> este é um momento interessante!  Você pode fazer essas coisas.  De fato, você pode tentar imaginar um compilador que, sempre que tiver um ponteiro, ele sempre tenta adicionar um complemento para algumas coisas.  No entanto, verificar todas essas coisas será muito caro.  Porque toda vez que você deseja usar qualquer ponteiro ou chamar qualquer função, você deve ter um código que verifique se esse "canário" está correto.  Basicamente, você poderia fazer algo semelhante, mas isso faz sentido?  Vemos que os "canários" não ajudam nessa situação. <br><br>  E mais uma coisa que discutimos anteriormente é que, se o atacante puder adivinhar a aleatoriedade, então, em princípio, os "canários" aleatórios não funcionarão.  A criação de recursos de segurança com base na aleatoriedade é um tópico separado e muito complexo, por isso não entraremos em detalhes. <br><br><img src="https://habrastorage.org/webt/1v/iw/s5/1viws5-axjes3hud4zigpabrxas.jpeg"><br><br>  <b>Público-alvo: o</b> canary contém menos bits que um endereço de retorno?  Porque, caso contrário, você não conseguia se lembrar desse endereço e verificar se ele mudou? <br><br>  <b>Professor:</b> vamos ver.  Você está falando sobre esse esquema quando o "canário" está localizado acima do buffer e quer dizer que o sistema não pode ser seguro se for impossível olhar para o endereço de retorno e verificar se ele foi alterado. <br><br><img src="https://habrastorage.org/webt/xg/nf/1m/xgnf1mj-jvjf1g1lu27xu7di4pm.jpeg"><br><br>  Sim e não  Observe que, se ocorrer um ataque de estouro de buffer, qualquer coisa acima dele será sobrescrito; portanto, isso ainda poderá causar problemas.  Mas, basicamente, se essas coisas são imutáveis ​​de certa forma, você pode fazer algo assim.  Mas o problema é que, em muitos casos, manipular o endereço de retorno é algo bastante complicado.  Porque você pode imaginar que uma função especial pode ser chamada de lugares diferentes, e assim por diante.  Nesse caso, corremos um pouco à frente e, se houver tempo no final da palestra, voltaremos a isso. <br><br>  São situações em que um "canário" pode falhar.  Existem outros locais onde a falha é possível, por exemplo, ao atacar as funções <b>malloc</b> e <b>free</b> .  A função malloc aloca um bloco de memória de um determinado tamanho em bytes e retorna um ponteiro para o início do bloco.  O conteúdo do bloco de memória alocado não é inicializado, permanece com valores indefinidos.  E a função <b>livre</b> libera memória previamente alocada dinamicamente. <br><br>  Este é um ataque único no estilo de C. Vamos ver o que acontece aqui.  Imagine que você tem dois ponteiros aqui, p e q, para os quais usamos <b>malloc para</b> alocar 1,024 bytes de memória para cada um desses ponteiros.  Suponha que façamos a função <b>strcpy</b> para p com algum tipo de erro de buffer controlado por um invasor.  É aqui que o estouro ocorre.  E então executamos o comando <b>free q</b> e <b>free p</b> .  Este é um código bastante simples, certo? <br><br><img src="https://habrastorage.org/webt/dt/o7/rt/dto7rtltvhx7lcdnytlifp7cvzw.jpeg"><br><br>  Temos dois ponteiros para os quais alocamos memória, usamos um deles para uma determinada função, ocorre um estouro de buffer e liberamos a memória dos dois ponteiros. <br><br>  Suponha que as linhas de memória de peq estejam localizadas próximas uma da outra no espaço da memória.  Nesse caso, coisas ruins podem acontecer, certo?  Como a função <b>strcpy</b> é usada para copiar o conteúdo de <b>str2</b> para <b>str1</b> .  <b>Str2</b> deve ser um ponteiro para uma string que termina com zero e <b>strcpy</b> retorna um ponteiro para <b>str1</b> .  Se as linhas <b>str1</b> e <b>str2 se</b> sobrepuserem, o comportamento da função <b>strcpy</b> será indefinido. <br><br>  Portanto, a função <b>strycpy</b> que processa a memória <b>p</b> pode ao mesmo tempo afetar a memória alocada para <b>q</b> .  E isso pode causar problemas. <br><br>  É possível que você tenha feito algo assim em seu próprio código inadvertidamente quando usou algum tipo de ponteiro estranho.  E tudo parece funcionar, mas quando você precisa chamar a função <b>livre</b> , ocorre um incômodo.  E um invasor pode tirar proveito disso, explicarei por que isso acontece. <br><br>  Imagine que, dentro da implementação das funções <b>free</b> e <b>malloc</b> , o bloco realçado se parece com isso. <br><br>  Vamos supor que no topo do bloco haja dados visíveis do aplicativo e abaixo tenhamos o tamanho da variável.  Esse tamanho não é o que o aplicativo vê diretamente, mas um tipo de "contabilidade" conduzida por <b>free</b> ou <b>malloc</b> , para que você saiba o tamanho do buffer de memória alocado.  Um bloco livre está localizado próximo ao bloco realçado.  Suponha que um bloco livre tenha alguns metadados parecidos com este: temos o tamanho do bloco acima, há espaço livre abaixo dele, o ponteiro de trás e o ponteiro de avanço abaixo dele.  E na parte inferior do bloco, o tamanho é mostrado novamente. <br><br><img src="https://habrastorage.org/webt/vx/q5/-w/vxq5-wfiisbatr5dzny9xaqd7vk.jpeg"><br><br>  Por que temos 2 ponteiros aqui?  Como o sistema de alocação de memória, nesse caso, usa uma lista duplamente vinculada para rastrear como os blocos livres estão relacionados entre si.  Portanto, ao selecionar um bloco livre, você o exclui desta lista duplamente vinculada.  E então, quando você o liberar, fará alguma aritmética para o ponteiro e colocará essas coisas em ordem.  Depois disso, você o adiciona a esta lista vinculada, certo? <br><br>  Sempre que você ouvir sobre a aritmética dos ponteiros, pense que este é o seu "canário".  Porque haverá muitos problemas.  Deixe-me lembrá-lo de que tivemos um buffer overflow <b>p</b> .  Se assumirmos que <b>p</b> e <b>q</b> estão próximos um do outro, ou muito próximos no espaço da memória, pode acontecer que esse estouro de buffer possa sobrescrever alguns dados de tamanho do ponteiro alocado <b>q</b> - essa é a parte inferior do nosso bloco alocado.  Se você continuar seguindo meu pensamento desde o início, sua imaginação lhe dirá onde tudo começa a dar errado.  De fato, em essência, o que finalmente acontece com essas operações é <b>q livre</b> e <b>p livre</b> - eles examinam esses metadados no bloco selecionado para fazer todas as manipulações necessárias com o ponteiro. <br><br><img src="https://habrastorage.org/webt/an/mo/ug/anmouglu2dii_itv9qshxsu4qes.jpeg"><br><br>  Ou seja, em algum momento da execução, as funções <b>livres</b> receberão um certo ponteiro com base no valor do tamanho: <b>p = get.free.block (size)</b> , e o tamanho é o que o invasor controla, porque realizou um estouro de buffer corretamente ? <br><br>  Ele fez vários cálculos aritméticos, olhou para a função <b>back</b> e os ponteiros deste bloco e agora fará algo como atualizar os ponteiros “back” e “forward” - estas são as duas últimas linhas. <br><br><img src="https://habrastorage.org/webt/bv/dt/x_/bvdtx_om6lkusoykjinpssiqro8.jpeg"><br><br>  Mas, na realidade, isso não deve incomodá-lo.  Este é apenas um exemplo do código que ocorre neste caso.  Mas o fato é que, devido ao tamanho reescrito pelo hacker, ele agora controla esse ponteiro, que passa pela função <b>free</b> .  E por causa disso, os dois estados aqui na linha inferior são, na verdade, atualizações de ponteiros.  E como o invasor conseguiu controlar esse <b>p</b> , ele realmente controla esses dois indicadores.  É neste local que um ataque pode ocorrer. <br><br>  Portanto, ao correr <b>livre</b> e tentar fazer algo como combinar esses dois blocos, você tem uma lista duplamente vinculada.  Porque se você tiver dois blocos que colidem um com o outro e os dois estiverem livres, deseje combiná-los em um grande bloco. <br><br>  Mas se controlarmos o tamanho, significa que controlaremos todo o processo a partir das quatro linhas acima.  Isso significa que, se entendermos como o estouro funciona, poderemos gravar dados na memória da maneira que escolhermos.  Como eu disse, essas coisas geralmente acontecem com seu próprio código, se você não é inteligente com um ponteiro.  Quando você comete algum erro duplo livre como <b>free q</b> e <b>free p</b> ou outra coisa, sua função falha.  Como você mexeu com os metadados que vivem em cada um desses blocos selecionados e, em algum momento, esse cálculo indicará algum tipo de valor "lixo", após o qual você estará "morto".  Mas se você é um invasor, pode escolher esse valor e usá-lo em seu proveito. <br><br>  Vamos para outra abordagem para evitar ataques de estouro de buffer.  Essa abordagem é verificar os limites.  O objetivo da verificação de limites é garantir que, ao usar um ponteiro específico, ele se refira apenas ao que é um objeto de memória.  E esse ponteiro está dentro dos limites permitidos desse objeto de memória.  Essa é a principal idéia da verificação.       —   .  ,    C,      . ,      : ,         ,    ? <br><br>   ,        –    .      1024    ,         : <b>char  [1024]</b> , <b>char *y = &amp;  [108].</b> <br><br><img src="https://habrastorage.org/webt/ms/_z/bq/ms_zbqzotz_bt7ya9dpcfsuftxq.jpeg"><br><br>    ?    ?  Difícil dizer.       ,  ,     .      ,  ,   -    . <br>       - , ,      ,   .         .  ,    ,      ,   .  ,   ,      .     ,     ,    . <br><br>    ,     ,      <b>struct</b>   <b>union</b> . ,     .     :     <b>integer</b> ,   <b>struct</b> ,      <b>int</b> . <br><br>  ,  <b>union</b>  ,           .        ,    <b>integer</b>  ,   <b>struct</b> ,    . <br><br> ,     ,   -  : <b>int  p: &amp; (u,s,k)</b> ,      :  u,   s,  k. <br><br><img src="https://habrastorage.org/webt/rp/5p/ph/rp5pphcqpcdmmzhfs6tfy6yhtvg.jpeg"><br><br>  ,    ,    ,     ,    .     ,  ,  <b>union</b>   <b>integer</b> ,   <b>struct</b> .  ,       ,    ,           .      . <br><br>      <b>p'</b> ,     <b>p</b> ,   <b>p'</b>      ,    . <br><br><img src="https://habrastorage.org/webt/_j/hb/d1/_jhbd1twr0i0fex98ytm7bdzfu8.jpeg"><br><br> ,     ,       .          , ,   <b>union</b> .   ,   -    -        <b>union</b> , ,  ,      .        ,        ,   X. ,   ,      ,  ,    .   ,    ,   .        . <br><br>         ,        .      ,      <b>p</b>  <b>p'</b> ,     .        . <br><br>     ?        Electric fencing –  .    ,    ,     ,    ,      . <br><br><img src="https://habrastorage.org/webt/eg/c5/bp/egc5bpv_lhcf6c6vgy_i5z5_zgo.jpeg"><br><br>       ,    -    ,    .   ,      ,     .    ,   .       ,   ,        ,    . <br><br>   -     C  C++,    ,     ,      .      - ,  ,  -   .      ,    .    ,   «» —  ,          ,   ,     .    ,      ,       . <br><br>       ,         guard page – !  ,   . <br><br> 59:00  <br><br> : <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> MIT «  ».  2: «  »,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/r4KjHEgg9Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  A versão completa do curso está disponível <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416047/">https://habr.com/ru/post/pt416047/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416029/index.html">Computador líquido: captura de íons em grafeno</a></li>
<li><a href="../pt416035/index.html">Scanner 3D odontológico Shining 3D Autoscan DS EX (Unboxing) por 3Dtool</a></li>
<li><a href="../pt416037/index.html">Inicialização do dia (abril a junho de 2018)</a></li>
<li><a href="../pt416043/index.html">Os países em desenvolvimento estão cada vez mais explorando o espaço sideral.</a></li>
<li><a href="../pt416045/index.html">No-break SRC1KI da APC Smart-UPS: Confiabilidade acima de tudo</a></li>
<li><a href="../pt416049/index.html">Codec AV1 Next Generation: Filtro de Correção Direcional CDEF</a></li>
<li><a href="../pt416051/index.html">Mitap de verão Apache Ignite em Moscou</a></li>
<li><a href="../pt416053/index.html">Modulação de amplitude de um sinal arbitrário</a></li>
<li><a href="../pt416055/index.html">Atribuição e suporte ao FQDN do servidor 3QX</a></li>
<li><a href="../pt416059/index.html">Mobio conversa com Daniil Shuleiko (Yandex.Taxi) sobre fusão com Uber, mercado de táxi e concorrência</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>