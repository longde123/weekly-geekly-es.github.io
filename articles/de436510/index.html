<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🏭 🎲 🤟🏽 Kerndaten im Detail 🤴🏾 👨‍🔧 👩🏼‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor kurzem habe ich begonnen, an einem großen Projekt mit Core Data zu arbeiten. Das Übliche ist, dass sich Menschen in Projekten ändern, Erfahrung ve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kerndaten im Detail</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436510/"> Vor kurzem habe ich begonnen, an einem großen Projekt mit Core Data zu arbeiten.  Das Übliche ist, dass sich Menschen in Projekten ändern, Erfahrung verloren geht und die Nuancen vergessen werden.  Es ist unmöglich, jeden in das Studium eines bestimmten Rahmens zu vertiefen - jeder hat seine eigenen Arbeitsprobleme.  Aus diesem Grund habe ich eine kurze Präsentation mit den Punkten vorbereitet, die ich für wichtig oder unzureichend in den Tutorials halte.  Ich teile mit allen und hoffe, dass dies hilft, effektiven Code zu schreiben und keine Fehler zu machen.  Es wird davon ausgegangen, dass Sie sich bereits ein wenig mit dem Thema befassen. <br><br>  Ich werde mit dem Banalen beginnen. <br><br>  Core Data ist ein Framework, das Daten in einer Anwendung verwaltet und speichert.  Sie können Core Data als Wrapper für einen physischen relationalen Speicher betrachten, der Daten in Form von Objekten darstellt, während Core Data selbst keine Datenbank ist. <br><br><h2>  Kerndatenobjekte </h2><br><img src="https://habrastorage.org/webt/aq/ka/bk/aqkabk_js9w9knvyat6xp_u4u5a.png" alt="Bild"><br><a name="habracut"></a><br>  Zum Erstellen von Speicher verwendet die Anwendung die <b>Klassen</b> <b>NSPersistentStoreCoordinator</b> oder <b>NSPersistentContainer</b> .  NSPersistentStoreCoordinator erstellt basierend auf dem Modell einen Speicher des angegebenen Typs. Sie können den Speicherort und zusätzliche Optionen angeben.  NSPersistentContainer kann mit iOS10 verwendet werden und bietet die Möglichkeit, mit einer minimalen Menge an Code zu erstellen. <br><br>  Es funktioniert wie folgt: Wenn eine Datenbank auf dem angegebenen Pfad vorhanden ist, überprüft der Koordinator ihre Version und führt gegebenenfalls eine Migration durch.  Wenn die Datenbank nicht vorhanden ist, wird sie basierend auf dem NSManagedObjectModel-Modell erstellt.  Damit dies alles ordnungsgemäß funktioniert, erstellen Sie vor dem Vornehmen von Änderungen am Modell eine neue Version in Xcode über das Menü Editor -&gt; Modellversion hinzufügen.  Wenn Sie den Pfad erhalten, können Sie die Basis im Emulator finden und öffnen. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel mit NSPersistentStoreCoordinator</b> <div class="spoiler_text"><pre><code class="objectivec hljs">var persistentCoordinator: <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentStoreCoordinator</span></span> = { let modelURL = Bundle.main.url(forResource: <span class="hljs-string"><span class="hljs-string">"Test"</span></span>, withExtension: <span class="hljs-string"><span class="hljs-string">"momd"</span></span>) let managedObjectModel = <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObjectModel</span></span>(contentsOf: modelURL!) let persistentCoordinator = <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentStoreCoordinator</span></span>(managedObjectModel: managedObjectModel!) let documentsPath = <span class="hljs-built_in"><span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span></span>(.documentDirectory, .userDomainMask, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] let storeURL = URL(fileURLWithPath: documentsPath.appending(<span class="hljs-string"><span class="hljs-string">"/Test.sqlite"</span></span>)) print(<span class="hljs-string"><span class="hljs-string">"storeUrl = \(storeURL)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { try persistentCoordinator.addPersistentStore(ofType: <span class="hljs-built_in"><span class="hljs-built_in">NSSQLiteStoreType</span></span>, configurationName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, at: storeURL, options: [<span class="hljs-built_in"><span class="hljs-built_in">NSSQLitePragmasOption</span></span>: [<span class="hljs-string"><span class="hljs-string">"journal_mode"</span></span>:<span class="hljs-string"><span class="hljs-string">"MEMORY"</span></span>]]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> persistentCoordinator } catch { abort() } } ()</code> </pre> <br></div></div><div class="spoiler">  <b class="spoiler_title">Beispiel für NSPersistentContainer</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">var persistentContainer: <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentContainer</span></span> = { let container = <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentContainer</span></span>(name: <span class="hljs-string"><span class="hljs-string">"CoreDataTest"</span></span>) container.loadPersistentStores(completionHandler: { (storeDescription, error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> print(<span class="hljs-string"><span class="hljs-string">"storeDescription = \(storeDescription)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let error = error as <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span>? { fatalError(<span class="hljs-string"><span class="hljs-string">"Unresolved error \(error), \(error.userInfo)"</span></span>) } }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container } ()</code> </pre><br></div></div><br>  Core Data verwendet vier Speichertypen: <br><br>  - SQLite <br>  - binär <br>  - In-Memory <br>  - XML ​​(nur Mac OS) <br><br>  Wenn Sie beispielsweise aus Sicherheitsgründen keine Daten in einer Dateiform speichern möchten, aber gleichzeitig das Caching während der Sitzung und Daten in Form von Objekten verwenden möchten, ist der Speicher vom Typ "In-Memory" durchaus geeignet.  Tatsächlich ist es nicht verboten, mehrere verschiedene Arten von Speichern in einer Anwendung zu haben. <br><br>  Ich möchte ein paar Worte zum <b>NSManagedObjectContext-</b> Objekt sagen.  Im Allgemeinen bietet Apple einen sehr vagen Wortlaut für NSManagedObjectContext - eine Umgebung für die Arbeit mit Core Data-Objekten.  All dies aus dem Wunsch heraus, sich von Assoziationen mit relationalen Datenbanken zu distanzieren und Core Data als benutzerfreundliches Tool zu präsentieren, das kein Verständnis für Schlüssel, Transaktionen und andere Bazdan-Attribute erfordert.  In der Sprache relationaler Datenbanken kann NSManagedObjectContext jedoch gewissermaßen als Transaktionsmanager bezeichnet werden.  Sie haben wahrscheinlich bemerkt, dass es Speicher- und Rollback-Methoden gibt, obwohl Sie höchstwahrscheinlich nur die erste verwenden. <br><br>  Ein Missverständnis dieser einfachen Tatsache führt zur Verwendung eines Einzelkontextmodells, selbst in Situationen, in denen dies nicht ausreicht.  Sie bearbeiten beispielsweise ein großes Dokument und mussten gleichzeitig einige Verzeichnisse herunterladen.  Wann rufen Sie save an?  Wenn wir mit einer relationalen Datenbank arbeiten würden, wäre dies keine Frage, da jede Operation in einer eigenen Transaktion ausgeführt würde.  Core Data bietet auch eine sehr bequeme Möglichkeit, dieses Problem zu lösen - dies ist ein Zweig des untergeordneten Kontexts.  Aber leider wird dies aus irgendeinem Grund selten verwendet.  Hier gibt es einen guten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> zu diesem Thema. <br><br><h2>  Vererbung </h2><br>  Aus irgendeinem Grund, den ich nicht verstehe, gibt es eine sehr große Anzahl von Handbüchern und Beispielen, in denen die Vererbung für Entity / NSManagedObject (Tabellen) in keiner Weise verwendet wird.  Inzwischen ist es ein sehr praktisches Werkzeug.  Wenn Sie keine Vererbung verwenden, können Sie Attributen (Feldern) nur Werte über den KVC-Mechanismus zuweisen, der die Namen und Attributtypen nicht überprüft. Dies kann leicht zu Laufzeitfehlern führen. <br><br>  Die Neudefinition der Klasse für NSManagedObject erfolgt im Core Data Designer: <br><br><img src="https://habrastorage.org/webt/ce/52/_p/ce52_pz39mzguhyiotm5rvhh00k.png" alt="Bild"><br><br><h2>  Vererbung und Codegenerierung </h2><br>  Nachdem Sie den Klassennamen für Entity angegeben haben, können Sie die Codegenerierung verwenden und eine Klasse mit vorgefertigtem Code abrufen: <br><br><img src="https://habrastorage.org/webt/al/dn/7a/aldn7aozwsnv-l7sjv8vau4iwmi.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/kj/ra/kh/kjrakhjgijvth5obsls22g6vtjk.png" alt="Bild"><br><br>  Wenn Sie den automatisch generierten Code anzeigen möchten, dem Projekt jedoch keine Dateien hinzufügen möchten, können Sie einen anderen Weg wählen: Legen Sie die Option „Codegen“ für Entität fest.  In diesem Fall muss der Code in ../ DerivedData / ... gesucht werden. <br><br><img src="https://habrastorage.org/webt/zg/vw/9e/zgvw9e3sulaf6g7qici-uitdsei.png" alt="Bild"><br><br>  Verwenden Sie die Codegenerierung, um Klassen zu erstellen. Tippfehler in Variablennamen können zu Laufzeitfehlern führen. <br><br>  Hier ist ein Code wie dieser: <br><br><pre> <code class="objectivec hljs">@objc public <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Company: <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> {    @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public var inn: String?  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public var name: String?  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public var uid: String?  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public var employee: <span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span>? }</code> </pre><br>  In Kürze hat @NSManaged die gleiche Bedeutung wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">dynamisch</a> in Ziel C. <br>  Core Data selbst kümmert sich um den Empfang von Daten (mit internen Accessoren) für die Attribute seiner Klassen.  Wenn Sie Transitfelder haben, müssen Sie Funktionen hinzufügen, um diese zu berechnen. <br><br>  Von NSManagedObject (Tabellen) geerbte Klassen hatten im Gegensatz zu anderen Klassen vor IOS10 keinen „regulären“ Konstruktor.  Um ein Objekt vom Typ Company zu erstellen, musste mit NSEntityDescription ein ziemlich ungeschicktes Konstrukt geschrieben werden.  Jetzt gibt es eine bequemere Methode zur Initialisierung über den Kontext (NSManagedObjectContext).  Der Code ist unten.  Beachten Sie den Vorteil der Vererbung beim Zuweisen von Attributen gegenüber dem KVC-Mechanismus: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 -    NSEntityDescription,    KVO let company1 = NSEntityDescription.insertNewObject(forEntityName: "Company", into: moc) company1.setValue("077456789111", forKey: "inn") company1.setValue(" ", forKey: "name") // 2 -    NSEntityDescription,     let company2 = NSEntityDescription.insertNewObject(forEntityName: "Company", into: moc) as! Company company2.inn = "077456789222" company2.name = " " // 3 -     (IOS10+),     let company3 = Company(context: moc) company3.inn = "077456789222" company3.name = " "</span></span></code> </pre><br><h2>  Namespace für NSManagedObject </h2><br>  Eine weitere erwähnenswerte Sache ist der Namespace. <br><br><img src="https://habrastorage.org/webt/fk/a7/wl/fka7wlfqlf4cvi1ezcqst4kiiyi.png" alt="Bild"><br><br>  Sie werden keine Schwierigkeiten haben, wenn Sie an ObjectiveC oder Swift arbeiten.  Normalerweise wird dieses Feld standardmäßig korrekt ausgefüllt.  Bei gemischten Projekten kann es Sie jedoch überraschen, dass Sie für Klassen in Swift und ObjectiveC verschiedene Optionen festlegen müssen.  In Swift muss das „Modul“ gefüllt sein.  Wenn dieses Feld nicht ausgefüllt wird, wird dem Klassennamen ein Präfix mit dem Projektnamen hinzugefügt, was zu einem Laufzeitfehler führt.  Lassen Sie in Objetive C das „Modul“ leer, da sonst NSManagedObject nicht gefunden wird, wenn Sie über den Klassennamen darauf zugreifen. <br><br><h2>  Verknüpfungen zwischen Objekten </h2><br>  Im Prinzip wird das Thema Beziehungen gut behandelt, aber ich möchte mich darauf konzentrieren, wie dem übergeordneten Element untergeordnete Entitäten hinzugefügt werden.  Daher zunächst eine kurze Erinnerung an den Mechanismus zum Erstellen von Links.  Betrachten Sie ein traditionelles Beispiel: Das Unternehmen besteht aus Mitarbeitern, die Verbindung ist eins zu viele: <br><br><ul><li>  Stellen Sie auf jeder Seite eine Verbindung her (Tabelle) </li><li>  Danach wird das Feld Inverse verfügbar, es muss in jeder Tabelle ausgefüllt werden. </li></ul><br><img src="https://habrastorage.org/webt/_m/fx/si/_mfxsi_lcnxt8t3zlhh0vbrbsus.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/kb/uo/my/kbuomy1etksutabvijrvxlztiyy.png" alt="Bild"><br><br>  Apple besteht darauf, inverse Beziehungen anzugeben.  Gleichzeitig stärkt die Inversion nicht die Kohärenz, sondern hilft Core Data dabei, Änderungen auf beiden Seiten der Verbindung zu verfolgen. Dies ist wichtig für das Zwischenspeichern und Aktualisieren von Informationen. <br><br>  Es ist auch wichtig, die Löschregel korrekt anzugeben.  Eine Löschregel ist eine Aktion, die mit diesem Objekt ausgeführt wird, wenn das übergeordnete Objekt gelöscht wird. <br><br><ul><li>  Kaskade - Löschen aller untergeordneten Objekte, wenn das übergeordnete Objekt gelöscht wird. </li><li>  Verweigern - Verbot, einen Elternteil zu löschen, wenn ein Kind vorhanden ist </li><li>  Aufheben - Übergeordnete Referenz aufheben </li><li>  Keine Aktion - keine Aktion angegeben, es wird eine Warnung bei der Kompilierung ausgegeben </li></ul><br>  In diesem Beispiel werden beim Löschen eines Unternehmens alle Mitarbeiter gelöscht (Kaskade).  Wenn Sie einen Mitarbeiter löschen, wird der Link zu ihm im Unternehmen zurückgesetzt (Vorbildschirm). <br><br><h2>  Möglichkeiten, dem übergeordneten Element untergeordnete Entitäten hinzuzufügen </h2><br>  <b>1)</b> Die erste Methode ist das Hinzufügen über NSSet.  Fügen Sie dem Unternehmen beispielsweise 2 Mitarbeiter hinzu: <br><br><pre> <code class="objectivec hljs">let set = <span class="hljs-built_in"><span class="hljs-built_in">NSMutableSet</span></span>();    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let employee1 = <span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span>.insertNewObject(forEntityName: <span class="hljs-string"><span class="hljs-string">"Employee"</span></span>, into: moc) as? Employee { employee1.firstName = <span class="hljs-string"><span class="hljs-string">""</span></span> employee1.secondName = <span class="hljs-string"><span class="hljs-string">""</span></span> set.add(employee1) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let emploee2 = <span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span>.insertNewObject(forEntityName: <span class="hljs-string"><span class="hljs-string">"Employee"</span></span>, into: moc) as? Employee { employee2.firstName = <span class="hljs-string"><span class="hljs-string">""</span></span> employee2.secondName = <span class="hljs-string"><span class="hljs-string">""</span></span> set.add(employee2) }    company.employee = set</code> </pre><br>  Diese Methode eignet sich zum Initialisieren des Objekts oder zum Füllen der Datenbank.  Es gibt eine leichte Nuance.  Wenn das Unternehmen bereits Mitarbeiter hatte und Sie einen neuen Satz zugewiesen haben, setzen die ehemaligen Mitarbeiter den Link zum Unternehmen zurück, werden jedoch nicht gelöscht.  Alternativ können Sie eine Liste der Mitarbeiter abrufen und bereits mit diesem Set arbeiten. <br><br><pre> <code class="objectivec hljs">let set = company.mutableSetValue(forKey: <span class="hljs-string"><span class="hljs-string">"employee"</span></span>)</code> </pre> <br>  <b>2)</b> Hinzufügen von untergeordneten Objekten über die übergeordnete ID <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let employee = <span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span>.insertNewObject(forEntityName: <span class="hljs-string"><span class="hljs-string">"Employee"</span></span>, into: moc) as? Employee { employee.firstName = <span class="hljs-string"><span class="hljs-string">""</span></span> employee.secondName = <span class="hljs-string"><span class="hljs-string">""</span></span> employee.company = company }</code> </pre><br>  Die zweite Methode ist praktisch, wenn Sie ein untergeordnetes Objekt hinzufügen oder bearbeiten <br>  separate Form. <br><br>  <b>3)</b> Hinzufügen von untergeordneten Objekten über automatisch generierte Methoden <br><br><pre> <code class="objectivec hljs">extension Company {    @objc(addEmployeeObject:)  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public func addEmployee(_ value: Employee)    @objc(removeEmployeeObject:)  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public func removeFromEmployee(_ value: Employee)    @objc(addEmployee:)  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public func addEmployee(_ values: <span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span>)    @objc(removeEmployee:)  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public func removeFromEmployee(_ values: <span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span>) }</code> </pre><br>  Der Vollständigkeit halber ist es nützlich, über diese Methode Bescheid zu wissen, aber irgendwie war sie für mich nicht nützlich, und ich lösche den zusätzlichen Code, um das Projekt nicht zu überladen. <br><br><h2>  Abfragen untergeordneter Klauseln </h2><br>  In Core Data können Sie keine willkürliche Abfrage zwischen Daten durchführen, wie dies in SQL möglich ist.  Zwischen abhängigen Objekten ist es jedoch einfach, mithilfe eines Standardprädikats zu verfolgen.  Unten finden Sie ein Beispiel für eine Abfrage, bei der alle Unternehmen ausgewählt werden, in denen sich ein Mitarbeiter mit dem angegebenen Namen befindet: <br><br><pre> <code class="objectivec hljs">public <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> func getCompanyWithEmployee(name: String) -&gt; [Company] { let request = <span class="hljs-built_in"><span class="hljs-built_in">NSFetchRequest</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSFetchRequestResult</span></span>&gt;(entityName: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.className()) request.predicate = <span class="hljs-built_in"><span class="hljs-built_in">NSPredicate</span></span>(format: <span class="hljs-string"><span class="hljs-string">"ANY employee.firstName = %@"</span></span>, name) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let result = try moc.fetch(request) as? [Company] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result } } catch { } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [Company]() }</code> </pre><br>  Der Methodenaufruf im Code sieht folgendermaßen aus: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    let companies = Company.getCompanyWithEmployee(name: "")</span></span></code> </pre><br>  Verwenden Sie keine Transitfelder in Abfragen, da deren Werte zum Zeitpunkt der Ausführung der Abfrage nicht definiert sind.  Es tritt kein Fehler auf, aber das Ergebnis ist falsch. <br><br><h2>  Attribute einstellen (Felder) </h2><br>  Sie haben wahrscheinlich bemerkt, dass Entitätsattribute mehrere Optionen haben. <br>  Mit optional ist alles aus dem Namen ersichtlich. <br><br>  Die Option zur Verwendung des Skalartyps wurde in swif angezeigt.  Objective-C verwendet keine Skalartypen für Attribute, da diese nicht Null sein können.  Der Versuch, einem Attribut über KVC einen Skalarwert zuzuweisen, führt zu einem Laufzeitfehler.  Daraus wird deutlich, warum die Attributtypen in Core Data nicht streng mit den Sprachtypen übereinstimmen.  In schnellen und gemischten Projekten können skalare Typattribute verwendet werden. <br><br>  Transitattribute sind berechnete Felder, die <b>nicht</b> in der Datenbank gespeichert sind.  Sie können zur Verschlüsselung verwendet werden.  Diese Attribute erhalten Werte über einen überschriebenen Accessor oder durch Zuweisen von Grundelementen nach Bedarf (z. B. überschriebenes willSave und awakeFromFetch). <br><br><h2>  Attribut-Accessoren: </h2><br>  Wenn Sie keine berechneten Felder verwenden müssen, um beispielsweise eine Verschlüsselung oder etwas anderes durchzuführen, müssen Sie nicht darüber nachdenken, was Attributzubehör ist.  In der Zwischenzeit sind die Operationen zum Abrufen und Zuweisen von Werten zu Attributen nicht „atomar“.  Um zu verstehen, was ich meine, lesen Sie den folgenden Code: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  let name = company.name //  company.willAccessValue(forKey: "name") let name = company.primitiveValue(forKey: "name") company.didAccessValue(forKey: "name") //  company.name = " " //  company.willChangeValue(forKey: "name") company.setPrimitiveValue(" ", forKey: "name") company.didChangeValue(forKey: "name")</span></span></code> </pre><br>  Verwenden Sie in NSManagedObject-Ereignissen Primitive anstelle der üblichen Zuweisung, um Schleifen zu vermeiden.  Ein Beispiel: <br><br><pre> <code class="objectivec hljs">override func willSave() {   let nameP = encrypt(field: primitiveValue(forKey: <span class="hljs-string"><span class="hljs-string">"name"</span></span>), password: password)   setPrimitiveValue(nameP, forKey: <span class="hljs-string"><span class="hljs-string">"nameC"</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.willSave() }  override func awakeFromFetch() {   let nameP = decrypt(field: primitiveValue(forKey: <span class="hljs-string"><span class="hljs-string">"nameC"</span></span>), password: password)   setPrimitiveValue(nameP, forKey: <span class="hljs-string"><span class="hljs-string">"name"</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.awakeFromFetch() }</code> </pre><br>  Wenn Sie plötzlich die Funktion awakeFromFetch in ein Projekt einschrauben müssen, werden Sie überrascht sein, dass es sehr seltsam funktioniert, aber tatsächlich wird es überhaupt nicht aufgerufen, wenn Sie die Anforderung ausführen.  Dies liegt an der Tatsache, dass Core Data über einen sehr intelligenten Caching-Mechanismus verfügt. Wenn sich die Auswahl bereits im Speicher befindet (z. B. weil Sie gerade diese Tabelle ausgefüllt haben), wird die Methode nicht aufgerufen.  Meine Experimente haben jedoch gezeigt, dass Sie sich in Bezug auf berechnete Werte sicher auf die Verwendung von awakeFromFetch verlassen können, wie in der Dokumentation von Apple angegeben.  Wenn Sie zum Testen und Entwickeln awakeFromFetch erzwingen müssen, fügen Sie manageObjectContext.refreshAllObjects () vor der Anforderung hinzu. <br><br>  Das ist alles. <br><br>  Vielen Dank an alle, die bis zum Ende gelesen haben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436510/">https://habr.com/ru/post/de436510/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436500/index.html">Wie der Rahmen von Rise of the Tomb Raider gerendert wird</a></li>
<li><a href="../de436502/index.html">Abonnement verwöhnt oder wie man mehr an dieselben Kunden verkauft</a></li>
<li><a href="../de436504/index.html">System im Paket oder was ist unter Chip-Paketabdeckung?</a></li>
<li><a href="../de436506/index.html">Wie man ohne großen Aufwand einen KI-Rassisten erschafft</a></li>
<li><a href="../de436508/index.html">Investitionen in Höhe von 10 Millionen US-Dollar und Wozniaks Lob - Schaffung eines Bildungscomputers für Kinder</a></li>
<li><a href="../de436512/index.html">Wie wir problematische Releases mit Graphite und Moira finden. Erleben Sie Yandex.Money</a></li>
<li><a href="../de436514/index.html">Erstellen von Geschichten für Instagram aus PHP</a></li>
<li><a href="../de436518/index.html">Haiku β1 - mach / b / OS wieder großartig</a></li>
<li><a href="../de436520/index.html">Verwenden Sie die Online-Überprüfungsdienste nicht, wenn Sie personenbezogene Daten verlieren</a></li>
<li><a href="../de436522/index.html">Entgegen den Anweisungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>