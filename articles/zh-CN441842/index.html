<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😽 🔽 👇🏿 实用围棋：编写现实世界中受支持程序的技巧 🔽 👩🏽‍🤝‍👨🏾 ❎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文重点介绍编写Go代码的最佳实践。 它以演示文稿的形式组成，但没有通常的幻灯片。 我们将尝试简要清楚地介绍每个项目。 

 首先，您需要就最佳编程语言的含义达成一致。 在这里，您可以回忆起Go技术总监Russ Cox的话： 

 如果添加时间因素和其他程序员，那么软件工程就是编程的过程。 
 因此...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>实用围棋：编写现实世界中受支持程序的技巧</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441842/"> 本文重点介绍编写Go代码的最佳实践。 它以演示文稿的形式组成，但没有通常的幻灯片。 我们将尝试简要清楚地介绍每个项目。 <br><br> 首先，您需要就<i>最佳</i>编程语言的含义达成一致。 在这里，您可以回忆起Go技术总监Russ Cox的话： <br><br><blockquote> 如果添加时间因素和其他程序员，那么软件工程就是编程的过程。 </blockquote><br> 因此，Russ区分了<i>编程</i>和<i>软件工程</i>的概念。 在第一种情况下，您可以自己编写程序，第二种情况下，您可以创建一种产品，其他程序员可以随时使用。 工程师来来去去。 团队成长或萎缩。 添加了新功能并修复了错误。 这就是软件开发的本质。 <br><a name="habracut"></a><br><a name="0"></a><h1> 目录内容 </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目录内容</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.基本原则</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">简单性</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">易读性</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.3。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">生产力</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.标识符</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基于清晰而非简短的名称标识符</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">证件长度</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.3。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不要按类型命名变量</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.4。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用单一命名样式</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.5。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用单一声明样式</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.6。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为团队工作</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.评论</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">变量和常量中的注释应描述其内容，而不是目的</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">始终记录公开可用的字符</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.包装结构</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个好的包装始于一个好名字</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">避免使用诸如base，common或util之类的名称</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.3。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">无需深潜即可快速回来</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.4。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使空值有用</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.5。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">避免包装级别状态</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.项目结构</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">套餐更少，但更大</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最小主包装</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6. API结构</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">设计很难被设计滥用的API</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">设计基本用例的API</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.3。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">让函数确定所需的行为。</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7.错误处理</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过消除错误本身消除对错误处理的需要</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">仅处理一次错误</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.并发</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一直做一些工作。</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">留给调用者并行性</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.3。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">切勿在不知道何时停止运行goroutine</a> </li></ul></li></ul><br><a name="1"></a><h1>  1.基本原则 </h1><br> 我可能是其中最早使用Go的用户之一，但这不是我个人的看法。 这些基本原则是Go本身的基础： <br><br><ol><li> 简单性 </li><li> 易读性 </li><li> 生产力 </li></ol><br>  <i>注意事项</i>  <i>请注意，我没有提到“性能”或“并发”。</i>  <i>有比Go更快的语言，但是它们肯定不能简单地进行比较。</i>  <i>有些语言将并行性放在首位，但是就可读性或编程效率而言，它们无法进行比较。</i> <i><br><br></i>  <i>性能和并发性是重要的属性，但不如简单性，可读性和生产率重要。</i> <br><br><a name="1_1"></a><h2> 简单性 </h2><br><blockquote>  <i>“简单是可靠性的前提”</i> -Edsger Dijkstra </blockquote><br> 为什么要追求简单？ 为什么Go程序简单很重要？ <br><br> 我们每个人都遇到了难以理解的代码，对吧？ 当您害怕进行更改时，因为它会破坏程序中您不太了解并且不知道如何解决的另一部分。 这就是困难。 <br><br><blockquote>  <i>“设计软件的方法有两种：第一种是使软件简单到没有明显缺陷，第二种是使软件变得如此复杂而没有明显缺陷。</i>  <i>第一个要困难得多。”</i> -C.E. R. Hoar </blockquote><br> 复杂性使可靠的软件变得不可靠。 复杂性是杀死软件项目的原因。 因此，简单是Go的最终目标。 无论我们编写什么程序，它们都应该很简单。 <br><br><a name="1_2"></a><h2>  1.2。 易读性 </h2><br><blockquote>  <i>“可读性是可维护性不可或缺的一部分”</i> -Mark Reinhold，JVM Conference，2018年 </blockquote><br> 为什么代码可读性如此重要？ 我们为什么要争取可读性？ <br><br><blockquote>  <i>“程序应该为人编写，而机器只能执行它们”</i> -Hal Abelson和Gerald Sassman，“计算机程序的结构和解释” </blockquote><br> 不仅Go程序，而且通常所有软件都是人为人编写的。 机器还处理代码的事实是次要的。 <br><br> 一旦编写了代码，人们将反复阅读：数百次，甚至数千次。 <br><br><blockquote>  <i>“对于程序员而言，最重要的技能是有效交流思想的能力。”</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">加斯顿·霍克</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Gaston Horker）</a> </blockquote><br> 可读性是了解程序功能的关键。 如果您不懂代码，该如何维护？ 如果不支持该软件，它将被重写； 这可能是您公司最后一次使用Go。 <br><br> 如果您正在为自己编写程序，请执行适合您的工作。 但是，如果这是联合项目的一部分，或者该程序将使用足够长的时间以更改其运行的要求，功能或环境，那么您的目标就是使该程序可维护。 <br><br> 编写支持的软件的第一步是确保代码清晰。 <br><br><a name="1_3"></a><h2>  1.3。 生产力 </h2><br><blockquote>  <i>“设计是组织代码的艺术，因此它可以在今天工作，但始终支持变更。”</i> -Sandy Mets </blockquote><br> 作为最后一个基本原则，我想说一下开发人员的生产率。 这是一个很大的话题，但要归结为比例：您花了多少时间在有用的工作上，还有多少-等待工具的响应或无法理解的代码库中无望的徘徊。  Go程序员应该感到他们可以处理很多工作。 <br><br> 开玩笑，说Go语言是在C ++程序编译时开发的。 快速编译是Go的关键功能，也是吸引新开发人员的关键因素。 尽管编译器得到了改进，但通常来说，使用其他语言进行的分钟编译在Go上需要花费几秒钟。 因此，Go开发人员在使用动态语言时感觉像程序员一样高效，但是这些语言的可靠性没有任何问题。 <br><br> 如果我们从根本上谈论开发人员的生产力，那么Go程序员将理解阅读代码本质上比编写代码更为重要。 按照这种逻辑，Go甚至可以使用这些工具以某种样式格式化所有代码。 这消除了学习特定项目的特定方言时的丝毫困难，并有助于识别错误，因为与常规代码相比，它们<i>看上去</i>只是错误的。 <br><br>  Go程序员无需花几天时间调试奇怪的编译错误，复杂的构建脚本或在生产环境中部署代码。 而且最重要的是，他们不会浪费时间去理解同事写的东西。 <br><br> 当Go开发人员谈论<i>可伸缩性时</i> ，它们意味着生产力。 <br><br><a name="2"></a><h1>  2.标识符 </h1><br> 我们将讨论的第一个主题-identifiers是<i>名称</i>的同义词：变量，函数，方法，类型，包等的名称。 <br><br><blockquote>  <i>“坏名字是不良设计的征兆”</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-Dave Cheney</a> </blockquote><br> 鉴于Go的语法有限，对象名称会对程序的可读性产生巨大影响。 可读性是编写好代码的关键因素，因此选择好名字至关重要。 <br><br><a name="2_1"></a><h2>  2.1。 基于清晰而非简短的名称标识符 </h2><br><blockquote>  <i>“重要的是，代码必须显而易见。</i>  <i>您可以在一行中执行的操作，您必须在三行中执行。”</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ukia Smith</a> </blockquote><br>  Go并未针对棘手的单行代码或程序中的最小行数进行优化。 我们没有优化磁盘上源代码的大小，也没有优化在编辑器中键入程序所需的时间。 <br><br><blockquote>  <i>“一个好名字就像个好玩笑。</i>  <i>如果您需要解释一下，那就不再有趣了。”</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dave Cheney</a> </blockquote><br> 要获得最大清晰度，关键是我们选择用来标识程序的名称。 好名字固有的什么素质？ <br><br><ul><li>  <b>一个好名字简明扼要</b> 。 它不必最短，但也可以不包含多余的内容。 它具有很高的信噪比。 </li><li>  <b>一个好名字是描述性的</b> 。 它描述了变量或常量的使用， <i>而不是</i>内容的使用。 好的名称描述的是函数或方法的行为而<i>不是</i>实现的结果。 包装的目的， <i>而不是</i>其内含物。 名称描述的事物越准确，就越好。 </li><li>  <b>一个好名字是可以预见的</b> 。 用一个名字，您必须了解如何使用该对象。 名称应具有描述性，但遵循传统也很重要。 这就是Go程序员说<i>“惯用语”的</i>意思。 </li></ul><br> 让我们更详细地考虑这些属性。 <br><br><a name="2_2"></a><h2>  2.2。 证件长度 </h2><br> 有时，Go的样式会因变量名简短而受到批评。 正如罗伯·派克（Rob Pike） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">所说</a> ：“ Go程序员需要<i>正确</i>长度的标识符。” <br><br>  Andrew Gerrand提供更长的标识符来表示重要性。 <br><br><blockquote>  <i>“名称声明与使用对象之间的距离越大，名称就应该越长”</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">安德鲁·格朗德</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Andrew Gerrand）</a> </blockquote><br> 因此，可以提出一些建议： <br><br><ul><li> 如果声明和<i>最后一次</i>使用之间的距离很小，则短变量名是好的。 <br></li><li> 长变量名应说明理由； 它们越长，就应该越重要。 详细标题与页面上的权重无关。 <br></li><li> 不要在变量名称中包括类型名称。 <br></li><li> 常量名称应描述内部值，而不是如何使用该值。 <br></li><li> 对于循环和分支，首选单字母变量；对于参数和返回值，建议使用单独的单词；对于软件包级别的函数和声明，建议使用多个单词。 <br></li><li> 对于方法，接口和包，最好使用单个单词。 <br></li><li> 请记住，程序包名称是调用方用于引用的名称的一部分。 </li></ul><br> 考虑一个例子。 <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Age <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-comment"><span class="hljs-comment">// AverageAge returns the average age of people. func AverageAge(people []Person) int { if len(people) == 0 { return 0 } var count, sum int for _, p := range people { sum += p.Age count += 1 } return sum / count }</span></span></code> </pre> <br> 在第十行中，声明了范围<code>p</code>的变量，并且仅从下一行调用一次。 也就是说，变量在页面上的生存时间很短。 如果读者对<code>p</code>在程序中的作用感兴趣，则只需阅读两行。 <br><br> 为了进行比较，在函数参数中声明了人员，并使用了7行。  <code>sum</code>和<code>count</code> ，因此它们证明了较长的名称是合理的。 读者需要扫描更多代码以找到它们：这证明了更多专有名称的合理性。 <br><br> 您可以为<code>sum</code>选择<code>s</code> ，为<code>count</code>选择<code>c</code> （或<code>n</code> ），但这会将程序中所有变量的重要性降低到同一水平。 您可以将<code>p</code>替换为<code>people</code> ，但是会有一个问题，即<code>for ... range</code>的迭代变量<code>for ... range</code> 。 一个<code>person</code>看起来会很奇怪，因为寿命短的迭代变量的名称要比其派生的多个值的名称长。 <br><br><blockquote>  <b>提示</b> 。 用空行分隔函数流，因为段落之间的空行破坏了文本流。 在<code>AverageAge</code> ，我们有三个连续的操作。 首先，检查除以零，然后得出总年龄和人数的结论，最后是-平均年龄的计算。 </blockquote><br><h3>  2.2.1。 最主要的是上下文 </h3><br> 重要的是要了解大多数命名技巧都是特定于上下文的。 我想说这是一个原则，而不是一条规则。 <br><br>  <code>i</code>和<code>index</code>什么区别？ 例如，您不能明确地说这样的代码 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index := <span class="hljs-number"><span class="hljs-number">0</span></span>; index &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s); index++ { <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre> <br> 从根本上比 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s); i++ { <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre> <br> 我认为第二种选择并不更糟，因为在这种情况下，区域<code>i</code>或<code>index</code>受<code>for</code>循环主体的限制，并且附加的冗长性对程序的理解几乎没有增加。 <br><br> 但是，哪个功能更易读？ <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *SNMP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oid []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, index </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br> 或 <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *SNMP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br> 在此示例中， <code>oid</code>是SNMP Object ID（SNMP对象ID）的缩写，而附加的<code>o</code>缩写则迫使您在读取代码时从已记录的符号切换为较短的代码。 同样，将<code>index</code>缩小到<code>i</code>会更难理解，因为在SNMP消息中，每个OID的子值都称为索引。 <br><br><blockquote>  <b>提示</b> 。 不要在一个广告中同时使用长和短形式参数。 </blockquote><br><a name="2_3"></a><h2>  2.3。 不要按类型命名变量 </h2><br> 您不称您的宠物为“狗”和“猫”，对吗？ 出于相同的原因，您不应在变量名称中包括类型名称。 它应该描述内容，而不是类型。 考虑一个例子： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usersMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*User</code> </pre> <br> 这个公告有什么好处？ 我们看到这是一张地图，并且与<code>*User</code>类型有关：这可能很好。 但是<code>usersMap</code> <i>确实是一个</i>地图，Go作为一种静态类型的语言，不允许在需要标量变量的地方偶然使用这样的名称，因此<code>Map</code>后缀是多余的。 <br><br> 考虑添加其他变量的情况： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( companiesMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Company productsMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Products )</code> </pre> <br> 现在，我们有了map类型的三个变量： <code>usersMap</code> ， <code>companiesMap</code>和<code>productsMap</code> ，所有行都映射到不同的类型。 我们知道这些是映射，并且如果在代码需要<code>map[string]*User</code>尝试使用<code>companiesMap</code> ，则编译器将引发错误。 在这种情况下，很明显<code>Map</code>后缀不能提高代码的清晰度，这些只是多余的字符。 <br><br> 我建议避免使用任何类似于变量类型的后缀。 <br><br><blockquote>  <b>提示</b> 。 如果<code>users</code>名称没有足够清楚地描述本质，则也可以使用<code>usersMap</code> 。 </blockquote><br> 本技巧也适用于功能参数。 例如： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// } func WriteConfig(w io.Writer, config *Config)</span></span></code> </pre> <br>  <code>*Config</code>参数的<code>config</code>名称是多余的。 我们已经知道这是<code>*Config</code> ，它会立即写入它旁边。 <br><br> 在这种情况下，如果变量的生存期足够短，请考虑使用<code>conf</code>或<code>c</code> 。 <br><br> 如果在我们区域的某个点上有多个<code>*Config</code> ，那么名称<code>conf1</code>和<code>conf2</code>含义就不如<code>original</code>和<code>updated</code> ，因为后者更难以混淆。 <br><br><blockquote>  <b>注意事项</b> 不要让包名窃取好的变量名。 <br><br> 导入的标识符的名称包含程序包的名称。 例如， <code>context</code>包中的<code>Context</code>类型将称为<code>context.Context</code> 。 这使得不可能在包中使用变量或<code>context</code>类型。 <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context context.Context, message </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br> 这将无法编译。 这就是为什么在声明<code>ctx</code>时的原因。例如在本地使用<code>ctx</code>类型，例如<code>ctx</code>类的名称。 <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, message </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> </blockquote><br><a name="2_4"></a><h2>  2.4。 使用单一命名样式 </h2><br> 好名声的另一个特性是，它应该是可预测的。 读者必须立即理解它。 如果这是一个<i>通用</i>名称，那么读者有权假定它与上次相比没有改变含义。 <br><br> 例如，如果代码在数据库描述符中四处移动，则每次显示该参数时，它都应具有相同的名称。 代替<code>d *sql.DB</code> ， <code>dbase *sql.DB</code> ， <code>DB *sql.DB</code>和<code>database *sql.DB</code>之类的各种组合，最好使用一件事： <br><br><pre> <code class="go hljs">db *sql.DB</code> </pre> <br> 理解代码更容易。 如果您看到<code>db</code> ，那么您知道它是<code>*sql.DB</code> ，它是在本地声明的或由调用者提供的。 <br><br> 关于方法接受者的类似建议； 对于此类型的每种方法，请使用相同的收件人名称。 因此，在这种类型的各种方法中，读者将更容易学习接收者的用法。 <br><br><blockquote>  <b>注意事项</b> 接受收件人简称协议与先前提出的建议相矛盾。 这是早期选择成为标准样式的情况之一，例如使用<code>CamelCase</code>而不是<code>snake_case</code> 。 </blockquote><br><blockquote>  <b>提示</b> 。  Go样式指向从其类型派生的收件人的单字母名称或缩写。 可能会发现收件人名称有时与方法中的参数名称冲突。 在这种情况下，建议使参数名称更长一些，并且不要忘记依次使用它。 </blockquote><br> 最后，传统上，一些单字母变量与循环和计数相关联。 例如， <code>i</code> ， <code>j</code>和<code>k</code>通常是<code>for</code>循环中的归纳变量， <code>n</code>通常与计数器或累加器相关联， <code>v</code>是编码函数中value的典型缩写， <code>k</code>通常用于map键，而<code>s</code>通常用作<code>string</code>类型参数的缩写。 <br><br> 与上面的<code>db</code>示例一样，程序员<i>希望</i> <code>i</code>是一个归纳变量。 如果他们在代码中看到它，他们希望很快就会看到一个循环。 <br><br><blockquote>  <b>提示</b> 。 如果嵌套循环太多，以至于<code>i</code> ， <code>j</code>和<code>k</code>变量用完了，那么您可能想将函数分成较小的单元。 </blockquote><br><a name="2_5"></a><h2>  2.5。 使用单一声明样式 </h2><br>  Go至少有六种不同的方式来声明变量。 <br><br><ul><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>; x = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> </li><li><pre> <code class="go hljs">x := <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li></ul><br> 我确定我还没有记住一切。  Go开发人员可能会认为这是一个错误，但是现在更改任何内容为时已晚。 有了这种选择，如何确保风格统一？ <br><br> 我想提出一种声明变量的样式，我自己会尽可能使用这些变量。 <br><br><ul><li>  <b>在声明变量而不进行初始化时，请使用<code>var</code></b> 。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0 var things []Thing // an empty slice of Things var thing Thing // empty Thing struct json.Unmarshall(reader, &amp;thing)</span></span></code> </pre> <br>  <code>var</code>暗示此变量被<i>故意</i>声明为指定类型的空值。 这与使用<code>var</code>声明程序包级别的变量的要求是一致的，这与短声明语法相反，尽管我稍后将争辩说根本不应该使用程序包级别的变量。 </li><li>  <b>使用初始化声明时，请使用<code>:=</code></b> 。 这使读者很清楚<code>:=</code>左侧的变量<code>:=</code>有意初始化的。 <br><br> 为了解释原因，让我们看一下前面的示例，但是这次我们专门初始化每个变量： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing *Thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing) json.Unmarshall(reader, thing)</code> </pre> </li></ul><br> 由于Go没有自动从一种类型转换为另一种类型，因此在第一个和第三个示例中，赋值运算符左侧的类型必须与右侧的类型相同。 编译器可以从右侧的类型推断出声明的变量的类型，因此可以更简洁地编写示例： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing) json.Unmarshall(reader, thing)</code> </pre> <br> 在这里， <code>players</code>显式初始化为<code>0</code> ，这是多余的，因为在任何情况下<code>players</code>器的初始值为零。 因此，最好弄清楚我们要使用空值： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br> 那第二个运算符呢？ 我们无法确定类型并写 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things = <span class="hljs-literal"><span class="hljs-literal">nil</span></span></code> </pre> <br> 因为<code>nil</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">没有类型</a> 。 相反，我们有一个选择：或者我们使用零值来切片... <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing</code> </pre> <br>  ...或创建一个零元素切片？ <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Thing, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br> 在第二种情况下，切片的值<i>不</i>为零，我们使用简短的声明形式向读者表明： <br><br><pre> <code class="go hljs">things := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Thing, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br> 这告诉读者我们决定显式初始化<code>things</code> 。 <br><br> 因此，我们得出第三个声明： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing)</code> </pre> <br> 在这里，变量的显式初始化和“独特”关键字<code>new</code>的引入都被某些Go程序员所不喜欢。 使用推荐的简短语法会产生 <br><br><pre> <code class="go hljs">thing := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing)</code> </pre> <br> 这清楚地表明<code>thing</code>明确初始化为<code>new(Thing)</code>的结果，但仍留下非典型的<code>new</code> 。 可以使用文字解决问题： <br><br><pre> <code class="go hljs">thing := &amp;Thing{}</code> </pre> <br> 这类似于<code>new(Thing)</code> ，并且这种复制使一些Go程序员感到不安。 但是，这意味着我们用指向<code>Thing{}</code>的指针和<code>Thing</code>值为零的显式初始化<code>thing</code> 。 <br><br> 但是最好考虑到使用零值声明<code>thing</code>的事实，并使用运算符的地址在<code>json.Unmarshall</code>传递<code>thing</code>的地址： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing Thing json.Unmarshall(reader, &amp;thing)</code> </pre> <br><blockquote>  <b>注意事项</b> 当然，任何规则都有例外。 例如，有时两个变量紧密相关，因此写起来很奇怪 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max := <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br> 更具可读性的声明： <br><br><pre> <code class="go hljs">min, max := <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> </blockquote><br> 总结一下： <br><br><ul><li> 在声明变量而不进行初始化时，请使用<code>var</code>语法。 <br></li><li> 在声明和显式初始化变量时，请使用<code>:=</code> 。 </li></ul><br><blockquote>  <b>提示</b> 。 明确指出复杂的事物。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> = <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br> 这里的<code>length</code>可以与需要特定数字类型的库一起使用，并且此选项更清楚地表明，与在short声明中相比，将类型length特别选择为uint32： <br><br><pre> <code class="go hljs">length := <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span>(<span class="hljs-number"><span class="hljs-number">0x80</span></span>)</code> </pre> <br> 在第一个示例中，我通过显式初始化使用var声明来故意破坏规则。 背离标准使读者了解发生了不寻常的事情。 </blockquote><br><a name="2_6"></a><h2>  2.6。 为团队工作 </h2><br> 我已经说过，软件开发的本质是创建可读的，受支持的代码。 您的大部分职业可能会从事联合项目。 在这种情况下，我的建议是：遵循团队采用的风格。 <br><br> 在文件中间更改样式很烦人。 一致性很重要，尽管这会损害个人喜好。 我的经验法则是：如果代码适合<code>gofmt</code> ，那么问题通常不值得讨论。 <br><br><blockquote>  <b>提示</b> 。 如果要在整个代码库中重命名，请不要将其与其他更改混合使用。 如果有人使用git bisect，他将不想遍历数千个重命名来查找另一个修改后的代码。 </blockquote><br><h1>  3.评论 </h1><br> 在继续讨论更重要的观点之前，我想花几分钟评论。 <br><br><blockquote>  <i>“好的代码有很多注释，而坏的代码则需要很多注释。”</i> -实用程序员Dave Thomas和Andrew Hunt </blockquote><br> 注释对于程序的可读性非常重要。 每个评论应执行以下一项操作，并且只能执行以下一项操作： <br><br><ol><li> 解释代码的作用。 </li><li> 解释他的做法。 </li><li> 解释<i>原因</i> 。 </li></ol><br> 第一种形式非常适合评论公共角色： <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Open     . //           .</span></span></code> </pre> <br> 第二种方法非常适合方法内部的注释： <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//     var results []chan error for _, dep := range a.Deps { results = append(results, execute(seen, dep)) }</span></span></code> </pre> <br> 第三种形式（“为什么”）的独特之处在于它不会替代或替代前两种形式。 这些注释解释了导致以当前形式编写代码的外部因素。 通常没有这种上下文，很难理解为什么以这种方式编写代码。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;v2.Cluster_CommonLbConfig{ <span class="hljs-comment"><span class="hljs-comment">//  HealthyPanicThreshold HealthyPanicThreshold: &amp;envoy_type.Percent{ Value: 0, }, }</span></span></code> </pre> <br> 在此示例中，当HealthyPanicThreshold设置为零百分比时，可能不会立即知道会发生什么。 该注释旨在澄清值为0会禁用恐慌阈值。 <br><br><a name="3_1"></a><h2>  3.1。 变量和常量中的注释应描述其内容，而不是目的 </h2><br> 我之前说过，变量或常量的名称应描述其用途。 但是对变量或常量的评论应该准确地描述<i>内容</i> ，而不是<i>目的</i> 。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre> <br> 在此示例中，注释描述了<i>为什么</i> <code>randomNumber</code>为6以及它来自何处。 该注释未描述将在哪里使用<code>randomNumber</code> 。 这里还有更多示例： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusContinue = <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-comment"><span class="hljs-comment">// RFC 7231, 6.2.1 StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2 StatusProcessing = 102 // RFC 2518, 10.1 StatusOK = 200 // RFC 7231, 6.3.1</span></span></code> </pre> <br>  <i>在HTTP上下文中，</i>数字<code>100</code>称为<code>StatusContinue</code> ，如RFC 7231中的6.2.1节所定义。 <br><br><blockquote>  <b>提示</b> 。 对于没有初始值的变量，注释应描述谁负责初始化此变量。 <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// sizeCalculationDisabled ,   //     . . dowidth. var sizeCalculationDisabled bool</span></span></code> </pre> <br> 这里的注释告诉读者， <code>dowidth</code>函数负责维护<code>sizeCalculationDisabled</code>的状态。 </blockquote><br><blockquote>  <b>提示</b> 。 隐藏在眼前。 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">凯特·格雷戈里（Kate Gregory</a> ）的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">建议</a> 。 有时，变量的最佳名称隐藏在注释中。 <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   SQL var registry = make(map[string]*sql.Driver)</span></span></code> </pre> <br> 作者添加了一条评论，因为名称<code>registry</code>无法充分说明其目的-这是一个注册表，但是什么是注册表？ <br><br> 如果将变量重命名为sqlDrivers，则很明显它包含SQL驱动程序。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlDrivers = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*sql.Driver)</code> </pre> <br> 现在，注释已变得多余，可以删除。 </blockquote><br><a name="3_2"></a><h2>  3.2。 始终记录公开可用的字符 </h2><br> 软件包的文档是由godoc生成的，因此您应在软件包中声明的每个公共字符上添加注释：变量，常量，函数和方法。 <br><br> 以下是《 Google风格指南》中的两个指南： <br><br><ul><li> 任何既不明显又不简洁的公共职能都应予以评论。 <br></li><li> 无论长度或复杂性如何，都应对库中的任何函数进行注释。 </li></ul><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ioutil <span class="hljs-comment"><span class="hljs-comment">// ReadAll   r      (EOF)   // ..    err == nil, not err == EOF. //  ReadAll     ,     //  . func ReadAll(r io.Reader) ([]byte, error)</span></span></code> </pre> <br> 此规则有一个例外：您无需记录实现该接口的方法。 具体而言，请勿执行以下操作： <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Read   io.Reader func (r *FileReader) Read(buf []byte) (int, error)</span></span></code> </pre> <br> 此评论没有任何意义。 他没有说明该方法的作用：更糟糕的是，他派人去某处寻找文档。 在这种情况下，我建议完全删除该评论。 <br><br> 这是<code>io</code>包中的示例。 <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// LimitReader  Reader,    r, //    EOF  n . //   *LimitedReader. func LimitReader(r Reader, n int64) Reader { return &amp;LimitedReader{r, n} } // LimitedReader   R,     //   N .   Read  N  //    . // Read  EOF,  N &lt;= 0    R  EOF. type LimitedReader struct { R Reader // underlying reader N int64 // max bytes remaining } func (l *LimitedReader) Read(p []byte) (n int, err error) { if lN &lt;= 0 { return 0, EOF } if int64(len(p)) &gt; lN { p = p[0:lN] } n, err = lRRead(p) lN -= int64(n) return }</span></span></code> </pre> <br> 请注意， <code>LimitedReader</code>声明紧随其后的是使用它的函数，而<code>LimitedReader.Read</code>声明紧随<code>LimitedReader</code>本身的声明。 尽管没有记录<code>LimitedReader.Read</code>本身，但是可以理解，这是<code>io.Reader</code>的实现。 <br><br><blockquote>  <b>提示</b> 。 在编写函数之前，请写一个描述它的注释。 如果您发现很难编写注释，则表明您将要编写的代码难以理解。 </blockquote><br><h3>  3.2.1。 不要评论错误的代码，将其重写 </h3><br><blockquote>  <i>“不要评论错误代码-重写它”</i> -Brian Kernighan </blockquote><br> 仅在注释中指出代码片段的难度是不够的。 如果您遇到以下评论之一，则应在开始时注明要重构。 只要知道其金额，您就可以忍受技术债务。 <br><br> 在标准库中，习惯上以TODO风格留下评论的用户的名字作为注释。 <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// TODO(dfc)  O(N^2),     .</span></span></code> </pre> <br> 这不是解决问题的义务，但是指定的用户可能是提出问题的最佳人选。 其他项目随TODO一起提供日期或票证编号。 <br><br><h3>  3.2.2。 不必注释掉代码，而是对其进行重构 </h3><br><blockquote>  <i>“好的代码是最好的文档。</i>  <i>当您要添加注释时，请问自己一个问题：“如何改进代码以便不需要此注释？”</i>  <i>重构并发表评论以使其更加清晰。”</i> -史蒂夫·麦康奈尔 </blockquote><br> 功能只能执行一项任务。 如果由于某些片段与该函数的其余部分无关而要写注释，则可以考虑将其提取到单独的函数中。 <br><br> 较小的功能不仅更清晰，而且更易于彼此分开测试。 将代码隔离到单独的函数中时，其名称可以替换注释。 <br><br><a name="4"></a><h1>  4.包装结构 </h1><br><blockquote>  <i>“编写适当的代码：不显示任何其他模块多余的模块，并且不依赖于其他模块的实现”</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-Dave Thomas</a> </blockquote><br> 每个软件包本质上都是一个单独的小型Go程序。 就像函数或方法的实现对调用者而言无关紧要一样，构成包的公共API的函数，方法和类型的实现也无关紧要。 <br><br> 一个好的Go软件包会在源代码级别上争取与其他软件包的最小连接，以便随着项目的发展，一个软件包中的更改不会在整个代码库中级联。 这种情况极大地阻碍了程序员在此代码库上工作。 <br><br> 在本节中，我们将讨论包装设计，包括其名称以及编写方法和函数的技巧。 <br><br><a name="4_1"></a><h2>  4.1。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 一个好的包装始于一个好名字 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个好的Go软件包以质量名称开头。</font><font style="vertical-align: inherit;">可以将它视为一个简短的演示文稿，仅限于一个单词。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像上一节中的变量名一样，包名非常重要。</font><font style="vertical-align: inherit;">无需考虑此程序包中的数据类型，最好提出以下问题：“此程序包提供什么服务？” </font><font style="vertical-align: inherit;">通常答案不是“此程序包提供X类型”，而是“此程序包允许您通过HTTP连接”。</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">通过功能而不是内容选择包名称。</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1.1。</font><font style="vertical-align: inherit;">好的包装名称必须唯一</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个包在项目中都有一个唯一的名称。</font><font style="vertical-align: inherit;">如果您遵循为软件包目的提供名称的建议，这没有任何困难。</font><font style="vertical-align: inherit;">如果事实证明这两个软件包的名称相同，则很可能是：</font></font><br><br><ol><li>     . </li><li>       .       ,     . </li></ol><br><a name="4_2"></a><h2> 4.2.    <code>base</code> , <code>common</code>  <code>util</code> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">昵称的一个常见原因是所谓的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务包</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，随着时间的推移，各种帮助程序和服务代码会在其中累积。由于很难在那里找到唯一的名称。这通常会导致一个事实，即程序包名称是从其</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容派生而来的</font><font style="vertical-align: inherit;">：实用程序。</font><font style="vertical-align: inherit;">在大型项目中通常会找到</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类似</font></font><code>utils</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或的</font><font style="vertical-align: inherit;">名称，</font></font><code>helpers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在大型项目中，根深蒂固的包层次结构已根植，并且共享了辅助功能。如果将某些功能提取到新程序包中，则导入将分解。在这种情况下，包的名称不反映包的用途，而仅反映由于项目的不正确组织导致导入功能失败的事实。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，我建议分析从何处调用软件包。</font></font><code>utils</code> <code>helpers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并在可能的情况下将相应功能移至调用数据包。</font><font style="vertical-align: inherit;">即使这意味着重复一些辅助代码，也比在两个软件包之间引入导入依赖关系要好。</font></font><br><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ [少量]复制比错误的抽象要便宜得多”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Sandy Mets</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果在许多地方使用实用程序功能，而不是使用一个带有实用程序功能的整体式软件包，则最好制作多个程序包，每个程序包都集中在一个方面。 </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">对服务包使用复数形式。</font><font style="vertical-align: inherit;">例如，</font></font><code>strings</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于字符串处理实用程序。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当两个或多个实现的某些通用功能或客户端和服务器的通用类型合并到单独的程序包中时，经常会遇到</font><font style="vertical-align: inherit;">名称类似</font></font><code>base</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或的</font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序包。</font><font style="vertical-align: inherit;">我认为在这种情况下，有必要通过将客户端，服务器和通用代码组合在一个软件包中并使用与其功能相对应的名称来减少软件包的数量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，为了</font></font><code>net/http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不做单独包装</font></font><code>client</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而是有文件</font></font><code>client.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并</font></font><code>server.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与相应的数据类型，以及</font></font><code>transport.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于运输总量。</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">重要的是要记住，标识符名称包括程序包名称。</font></font><br><br><ul><li><font style="vertical-align: inherit;"></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个包中</font><font style="vertical-align: inherit;">的功能</font></font><code>net/http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成为</font></font><code>http.Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个包中</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">链接。</font></font><br></li><li><font style="vertical-align: inherit;"></font><code>Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包中</font><font style="vertical-align: inherit;">的类型</font></font><code>strings</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在导入其他包时</font><font style="vertical-align: inherit;">会</font><font style="vertical-align: inherit;">转换为</font></font><code>strings.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br></li><li><font style="vertical-align: inherit;"></font><code>Error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">软件包中</font><font style="vertical-align: inherit;">的接口</font></font><code>net</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然与网络错误相关。</font></font></li></ul></blockquote><br><a name="4_3"></a><h2>  4.3。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 无需深潜即可快速回来 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于Go在控制流中不使用异常，因此无需深入研究代码即可为</font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">块提供顶级结构</font></font><code>catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">随着功能的进展，Go代码会在屏幕上向下显示，而不是多层结构。</font><font style="vertical-align: inherit;">我的朋友马特里尔（Matt Ryer）称这种做法为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“视线”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这可以通过使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">边界运算符</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现</font><font style="vertical-align: inherit;">：在函数的输入处带有前提条件的条件块。</font><font style="vertical-align: inherit;">这是包中的一个示例</font></font><code>bytes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnreadRune</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.lastRead &lt;= opInvalid { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.off &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) { b.off -= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) } b.lastRead = opInvalid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进入函数后</font></font><code>UnreadRune</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将检查状态</font></font><code>b.lastRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果先前的操作未进行</font></font><code>ReadRune</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则立即返回错误。该函数的其余部分根据</font></font><code>b.lastRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大于</font><font style="vertical-align: inherit;">的值工作</font></font><code>opInvalid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与相同的函数进行比较，但没有边界运算符：</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnreadRune</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.lastRead &gt; opInvalid { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.off &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) { b.off -= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) } b.lastRead = opInvalid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第一个条件中嵌入了更有可能成功的分支的主体，</font><font style="vertical-align: inherit;">必须通过仔细匹配</font><i><font style="vertical-align: inherit;">右</font></i><font style="vertical-align: inherit;">括号</font><font style="vertical-align: inherit;">来发现</font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成功退出的条件</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在，函数的最后一行返回一个错误，您需要跟踪函数在相应的</font><i><font style="vertical-align: inherit;">右</font></i><font style="vertical-align: inherit;">括号中</font><font style="vertical-align: inherit;">的执行，</font><font style="vertical-align: inherit;">以了解到这一点的方法。</font><font style="vertical-align: inherit;">该选项更难阅读，从而降低了编程和代码支持的质量，因此Go倾向于在早期使用边界运算符并返回错误。</font></font><code>return nil</code><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><a name="4_4"></a><h2>  4.4。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使空值有用 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设不存在显式初始化程序，则每个变量声明将自动使用与清零内存的内容相对应的值（即</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zero）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行初始化</font><font style="vertical-align: inherit;">。值的类型由以下选项之一确定：对于数字类型-零，对于指针类型-nil，对于切片，映射和通道相同。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">始终设置已知默认值的能力对于程序的安全性和正确性很重要，并且可以使Go程序更轻松，更紧凑。这就是Go程序员在说“给一个有用的零值”时要记住的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑一种类型</font></font><code>sync.Mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该类型</font><font style="vertical-align: inherit;">包含两个表示互斥量内部状态的整数字段。这些字段在任何声明中自动为null。</font></font><code>sync.Mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在代码中考虑到了这一事实，因此该类型适用于无需显式初始化的情况。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { mu sync.Mutex val <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i MyInt <span class="hljs-comment"><span class="hljs-comment">// i.mu is usable without explicit initialisation. i.mu.Lock() i.val++ i.mu.Unlock() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有有用的空值的类型的另一个示例是</font></font><code>bytes.Buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您可以声明并开始对其进行写入，而无需显式初始化。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span>) io.Copy(os.Stdout, &amp;b) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此结构的零值表示</font></font><code>len</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两者</font></font><code>cap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相等</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且y </font></font><code>array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是指向具有备份分片数组value的内存的指针</font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这意味着您无需显式剪切，只需声明即可。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// s := make([]string, 0) // s := []string{} var s []string s = append(s, "Hello") s = append(s, "world") fmt.Println(strings.Join(s, " ")) }</span></span></code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>var s []string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与顶部的两条注释行相似，但与它们不同。</font><font style="vertical-align: inherit;">切片值nil与长度为零的切片值之间存在差异。</font><font style="vertical-align: inherit;">以下代码将显示为false。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1 = []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2 []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fmt.Println(reflect.DeepEqual(s1, s2)) }</code> </pre> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未初始化的指针变量（nil指针）的一个有用的（尽管出乎意料的）属性是能够对nil类型的方法进行调用。</font><font style="vertical-align: inherit;">这可用于轻松提供默认值。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/usr/home"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.path } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c1 *Config <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c2 = &amp;Config{ path: <span class="hljs-string"><span class="hljs-string">"/export"</span></span>, } fmt.Println(c1.Path(), c2.Path()) }</code> </pre> <br><a name="4_5"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5。</font><font style="vertical-align: inherit;">避免包装级别状态</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编写易连接的，易于支持的程序的关键是，更改一个程序包对其他不直接依赖第一个程序包的程序产生的影响应该很小。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有两种方法可以在Go中实现弱连接：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用接口来描述功能或方法所需的行为。 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 避免全球地位。 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Go中，我们可以在函数或方法的范围内以及程序包的范围内声明变量。</font><font style="vertical-align: inherit;">当一个变量是公开可用的，并且带有大写字母的标识符时，则其范围实际上是整个程序的全局范围：任何包</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在任何时候都</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以看到此变量的类型和内容。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可变的全局状态在程序的独立部分之间提供了紧密的关系，因为全局变量成为程序中每个函数的不可见参数！</font><font style="vertical-align: inherit;">当此变量的类型改变时，任何依赖于全局变量的函数都会被违反。</font><font style="vertical-align: inherit;">如果程序的另一部分更改了此变量，则可能会违反依赖于全局变量状态的任何函数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如何减少全局变量创建的连接性： </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将相应的变量作为字段移动到需要它们的结构中。 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用接口可以减少行为与该行为的实现之间的联系。 </font></font></li></ol><br><a name="5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.项目结构 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们讨论一下如何将软件包组合到一个项目中。</font><font style="vertical-align: inherit;">这通常是单个Git存储库。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像软件包一样，每个项目都应该有一个明确的目标。</font><font style="vertical-align: inherit;">如果它是一个库，它必须做一件事，例如XML解析或日记。</font><font style="vertical-align: inherit;">您不应该在一个项目中结合多个目标，这将有助于避免产生可怕的库</font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">以我的经验，存储库</font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最终与最大的使用者紧密相关，这使得在不对</font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阻塞</font><font style="vertical-align: inherit;">版本进行更新的情况下，如果不对</font><font style="vertical-align: inherit;">使用者和使用者进行</font><font style="vertical-align: inherit;">更新，就很难对以前的版本进行更正（后端口修复）</font><font style="vertical-align: inherit;">，这会导致许多不相关的更改，而且它们会一路中断API</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您有一个应用程序（Web应用程序，Kubernetes控制器等），则该项目可能具有一个或多个主软件包。</font><font style="vertical-align: inherit;">例如，在我的Kubernetes控制器中，有一个软件包</font></font><code>cmd/contour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可用作部署在Kubernetes集群中的服务器和调试客户端。</font></font><br><br><a name="5_1"></a><h2>  5.1。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 套餐更少，但更大 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在代码审查中，我注意到从其他语言转到Go的程序员的典型错误之一：他们倾向于滥用软件包。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go不提供能见度精细的系统：语言是不够的访问修饰符作为Java（ ，</font><font style="vertical-align: inherit;">，</font></font><code>public</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> </font><font style="vertical-align: inherit;">和隐性</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">没有C ++的友好类的类似物。</font><font style="vertical-align: inherit;">在Go中，我们只有两个访问修饰符：这是公共标识符和私有标识符，由标识符的首字母（大写/小写）指示。</font><font style="vertical-align: inherit;">如果标识符是public，则其名称以大写字母开头，任何其他Go包都可以引用该标识符。</font></font><code>protected</code><font style="vertical-align: inherit;"></font><code>private</code><font style="vertical-align: inherit;"></font><code>default</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您可能会听到“已导出”或“未导出”这两个词作为公共和私有同义词。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 给定有限的访问控制功能，可以使用哪些方法来避免过于复杂的程序包层次结构？ </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在每个软件包中，除了，</font></font><code>cmd/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还</font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须提供源代码。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我已经反复说过，最好不要使用较大的数据包。</font><font style="vertical-align: inherit;">您的默认位置应该是不创建新程序包。</font><font style="vertical-align: inherit;">这会导致太多类型成为公共类型，从而导致可用API的范围越来越小。</font><font style="vertical-align: inherit;">下面我们将更详细地考虑本论文。</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">来自Java吗？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您来自Java或C＃世界，那么请记住一条潜规则：Java软件包等效于一个源文件</font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Go程序包等效于整个Maven模块或.NET程序集。</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1.1。</font><font style="vertical-align: inherit;">使用导入说明按文件对代码进行排序</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果按服务组织软件包，是否应该对软件包中的文件进行相同的处理？</font><font style="vertical-align: inherit;">如何知道何时将一个文件分割</font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成几个</font><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">？</font><font style="vertical-align: inherit;">您怎么知道您走得太远并且需要考虑合并文件？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是我使用的建议：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用一个文件启动每个软件包</font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为该文件提供与目录相同的名称。</font><font style="vertical-align: inherit;">例如，该软件包</font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应</font></font><code>http.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位于directory目录下</font><font style="vertical-align: inherit;">的文件</font><font style="vertical-align: inherit;">中</font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随着软件包的增长，您可以将各种功能拆分为几个文件。</font><font style="vertical-align: inherit;">例如，文件</font></font><code>messages.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将包含类型</font></font><code>Request</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>Response</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，file </font></font><code>client.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-type </font></font><code>Client</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，file </font></font><code>server.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-type服务器。</font></font><br></li><li>       ,    .  ,       . <br></li><li>        . , <code>messages.go</code>     HTTP-       , <code>http.go</code>      , <code>client.go</code>  <code>server.go</code> —    HTTP     . </li></ul><br><blockquote> <b></b> .      . </blockquote><br><blockquote> <b></b> .  Go    .      <i></i> ( —      Go).           . </blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1.2。</font><font style="vertical-align: inherit;">内部测试优先于外部测试</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该工具</font><font style="vertical-align: inherit;">在两个位置</font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支持软件包</font></font><code>testing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果您有程序包</font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则可以编写文件</font></font><code>http2_test.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并使用程序包声明</font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它编译的代码</font></font><code>http2_test.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因为</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它是包的一部分</font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在口语中，这种测试称为内部测试。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该工具</font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还支持以</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结尾的特殊程序包声明</font><font style="vertical-align: inherit;">，即</font></font><code>http_test</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这允许测试文件与代码位于同一包中，但是在编译此类测试时，它们不属于程序包代码的一部分，而是位于其自己的包中。</font><font style="vertical-align: inherit;">这使您可以编写测试，就像另一个程序包正在调用您的代码一样。</font><font style="vertical-align: inherit;">这种测试称为外部测试。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我建议对单元单元测试使用内部测试。这使您可以直接测试每个功能或方法，从而避免了外部测试的繁琐工作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将测试函数的示例（</font></font><code>Example</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">放在外部测试文件中</font><font style="vertical-align: inherit;">。这样可以确保在godoc中查看示例时，这些示例将获得适当的软件包前缀，并且可以轻松复制。</font></font><br><br><blockquote> <b></b> .    ,     . <br><br>   ,    ,   Go      <code>go</code> . ,  <code>net/http</code>       <code>net</code> . <br><br>           <code>.go</code> , ,    . </blockquote><br><h3> 5.1.3.   ,     API </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您的项目有多个程序包，则可能会找到要供其他程序包使用的导出功能，但不适用于公共API。</font><font style="vertical-align: inherit;">在这种情况下，该工具会</font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">识别一个特殊的文件夹名称</font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">名称</font><font style="vertical-align: inherit;">可用于放置对您的项目开放但对其他人关闭的代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要创建这样的程序包，请将其放置在带有名称的目录中</font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或它的子目录中。</font><font style="vertical-align: inherit;">当团队</font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看到带有路径的包的导入时</font></font><code>internal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它将检查调用包在目录或子目录中的位置</font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，一个包</font></font><code>.../a/b/c/internal/d/e/f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只能从目录树导入一个包</font></font><code>.../a/b/c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而不</font><font style="vertical-align: inherit;">能从任何目录</font></font><code>.../a/b/g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或任何其他存储库</font><font style="vertical-align: inherit;">导入</font><font style="vertical-align: inherit;">（参见</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br><br><a name="5_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2。</font><font style="vertical-align: inherit;">最小主包装</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个函数</font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和一个程序包</font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须具有最少的功能，因为它的</font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行为就像一个单例：程序只能具有一个函数</font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，包括测试。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于它</font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是单例，因此对被调用对象有很多限制：它们仅在</font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font><font style="vertical-align: inherit;">期间被调用</font></font><code>main.init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且只能</font><font style="vertical-align: inherit;">被调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一次</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这使得编写代码测试变得困难</font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，您需要努力从主要功能（最好是从主要包）派生尽可能多的逻辑。</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>func main()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须分析标志，打开与数据库，记录器等的连接，然后将执行转移到高级对象。</font></font></blockquote><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. API结构 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我认为最重要的项目设计建议。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原则上，所有先前的句子都不具有约束力。</font><font style="vertical-align: inherit;">这些只是基于个人经验的建议。</font><font style="vertical-align: inherit;">我不会在代码审查中过多地提出这些建议。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API是另一回事，在这里我们更认真地对待错误，因为可以固定其他所有内容而不会破坏向后兼容性：在大多数情况下，这些只是实现细节。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于公共API，从一开始就应该认真考虑其结构，因为随后的更改将对用户造成破坏。</font></font><br><br><a name="6_1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.1。</font><font style="vertical-align: inherit;">设计很难被设计滥用的API</font></font></h2><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«API应该是正确使用简单，不易滥用”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乔希布洛赫</font></font></a> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乔什·布洛赫（Josh Bloch）的建议也许是本文中最有价值的。</font><font style="vertical-align: inherit;">如果该API难以用于简单的事情，则每个API调用都比必要的更为复杂。</font><font style="vertical-align: inherit;">当API调用复杂且不明显时，它很可能会被忽略。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.1.1。</font><font style="vertical-align: inherit;">接受多个相同类型参数的函数时要小心。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乍看之下但很难使用的API的一个很好的例子是当它需要两个或多个相同类型的参数时。</font><font style="vertical-align: inherit;">比较两个函数签名：</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to, from </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这两个功能有什么区别？</font><font style="vertical-align: inherit;">显然，一个返回最多两个数字，另一个则复制文件。</font><font style="vertical-align: inherit;">但这不是重点。</font></font><br><br><pre> <code class="go hljs">Max(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 10 Max(10, 8) // 10</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Max是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可交换的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：参数的顺序无关紧要。</font><font style="vertical-align: inherit;">不论是否比较八和十或十和八，最大值八和十都是十。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是对于CopyFile，情况并非如此。</font></font><br><br><pre> <code class="go hljs">CopyFile(<span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>, <span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span>) CopyFile(<span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span>, <span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些操作员中的哪个将备份您的演示文稿，哪个将被上周的版本覆盖？</font><font style="vertical-align: inherit;">您必须先检查文档才能知道。</font><font style="vertical-align: inherit;">在代码审查的过程中，不清楚参数的顺序是否正确。</font><font style="vertical-align: inherit;">再次，查看文档。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一种可能的解决方案是引入一种负责正确调用的辅助类型</font></font><code>CopyFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Source <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src Source)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dest </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CopyFile(dest, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(src)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> from Source = <span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span> from.CopyTo(<span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"></font><code>CopyFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里总是正确地称呼</font><font style="vertical-align: inherit;">它</font><font style="vertical-align: inherit;">-这可以使用单元测试来陈述-并且可以私下完成，从而进一步减少了错误使用的可能性。</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">具有多个相同类型参数的API很难正确使用。</font></font></blockquote><br><a name="6_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2。</font><font style="vertical-align: inherit;">设计基本用例的API</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几年前，我做了一个</font><font style="vertical-align: inherit;">关于使用</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">功能选项</font></a><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演示</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">以使默认情况下的API更加容易。</font><font style="vertical-align: inherit;">演示的本质是您应该为主要用例开发一个API。</font><font style="vertical-align: inherit;">换句话说，API不应要求用户提供他不感兴趣的额外参数。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2.1。</font><font style="vertical-align: inherit;">不建议使用nil作为参数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，您不应强迫用户提供他不感兴趣的API参数。</font><font style="vertical-align: inherit;">这意味着</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为主要用例设计API</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（默认选项）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是来自net / http包的示例。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http <span class="hljs-comment"><span class="hljs-comment">// ListenAndServe listens on the TCP network address addr and then calls // Serve with handler to handle requests on incoming connections. // Accepted connections are configured to enable TCP keep-alives. // // The handler is typically nil, in which case the DefaultServeMux is used. // // ListenAndServe always returns a non-nil error. func ListenAndServe(addr string, handler Handler) error {</span></span></code> </pre> <br> <code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接受两个参数：一个TCP地址，用于侦听传入的连接和</font></font><code>http.Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理传入的HTTP请求。</font></font><code>Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许第二个参数为</font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在注释中，应注意通常调用对象</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确实会</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过</font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，表示希望将其</font></font><code>http.DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用作隐式参数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，呼叫者</font></font><code>Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有两种方法可以做到这一点。</font></font><br><br><pre> <code class="go hljs">http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, http.DefaultServeMux)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两种选择都做同样的事情。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该应用程序</font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像病毒一样传播。</font><font style="vertical-align: inherit;">该软件包还</font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有一个帮助器</font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此您可以想象函数的结构</font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListenAndServe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, handler Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { l, err := net.Listen(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, addr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> l.Close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Serve(l, handler) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于</font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它允许调用方传递</font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二个参数，因此它</font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也支持此行为。</font><font style="vertical-align: inherit;">实际上，它是在</font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">逻辑中“如果处理程序相等</font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，请使用</font></font><code>DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">”。</font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对一个参数的</font><font style="vertical-align: inherit;">接受</font><font style="vertical-align: inherit;">会使调用者认为可以</font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为两个参数</font><font style="vertical-align: inherit;">传递</font><font style="vertical-align: inherit;">该参数。</font><font style="vertical-align: inherit;">但是这样</font></font><code>Serve</code> <br><br><pre> <code class="go hljs">http.Serve(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 导致可怕的恐慌。 </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">不要在同一个函数签名的参数搭配</font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而不是</font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作者</font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尝试简化默认情况下的API用户的寿命，但安全性受到影响。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在场时，</font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显式和间接使用之间的行数没有差异</font></font><code>DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) http.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 与 </font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) http.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, http.DefaultServeMux)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 保留一行是否值得混淆？ </font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) mux := http.NewServeMux() mux.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux)</code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">认真考虑辅助函数将为程序员节省多少时间。</font><font style="vertical-align: inherit;">清晰胜于简洁。</font></font></blockquote><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">避免使用仅需要测试的参数的公共API。</font><font style="vertical-align: inherit;">避免导出参数值仅在测试期间不同的API。</font><font style="vertical-align: inherit;">相反，导出包装器函数可以隐藏此类参数的传递，并且在测试中使用类似的帮助器函数来传递测试所需的值。</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2.2。</font><font style="vertical-align: inherit;">使用可变长度参数而不是[] T</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 通常，函数或方法采用一片值。 </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShutdownVMs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ids []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这只是一个虚构的示例，但这是很常见的。问题在于这些签名假定将使用多个记录来调用它们。如经验所示，通常只用一个参数调用它们，这些参数必须“打包”在切片内才能满足功能签名的要求。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，由于参数</font></font><code>ids</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是切片，您可以将空切片或零传递给函数，编译器会很高兴。由于测试应涵盖此类情况，因此增加了额外的测试负担。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了提供此类API类的示例，我最近重构了逻辑，如果至少一个参数为非零值，则需要安装一些其他字段。逻辑看起来像这样：</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> svc.MaxConnections &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxPendingRequests &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxRequests &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxRetries &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-comment"><span class="hljs-comment">// apply the non zero parameters }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于运算符</font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变得很长，我想将验证逻辑放入一个单独的函数中。</font><font style="vertical-align: inherit;">这是我想出的：</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// anyPostive indicates if any value is greater than zero. func anyPositive(values ...int) bool { for _, v := range values { if v &gt; 0 { return true } } return false }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这样就可以清楚地说明执行室内机的条件： </font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) { <span class="hljs-comment"><span class="hljs-comment">// apply the non zero parameters }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，存在问题</font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，有人可能会不小心这样称呼它：</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> anyPositive() { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，</font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将返回</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这不是最糟糕的选择。</font><font style="vertical-align: inherit;">如果</font><font style="vertical-align: inherit;">在没有参数的情况下</font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则</font><font style="vertical-align: inherit;">更糟</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，最好能够更改anyPositive的签名，以确保至少有一个参数传递给调用方。</font><font style="vertical-align: inherit;">这可以通过组合常规参数和可变长度参数（可变参数）的参数来完成：</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// anyPostive indicates if any value is greater than zero. func anyPositive(first int, rest ...int) bool { if first &gt; 0 { return true } for _, v := range rest { if v &gt; 0 { return true } } return false }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，</font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您不能使用少于一个参数进行调用。</font></font><br><br><a name="6_3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3。</font><font style="vertical-align: inherit;">让函数确定所需的行为。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设我的任务是编写一个保留</font></font><code>Document</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">磁盘</font><font style="vertical-align: inherit;">结构的函数</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      f. func Save(f *os.File, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我可以编写一个</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写入</font></font><code>Document</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">的函数</font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是有一些问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">签名</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消除了通过网络记录数据的可能性。如果将来出现这种要求，则必须更改函数的签名，这将影响所有调用对象。</font></font><br><br> <code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样令人讨厌的测试，因为它直接与磁盘上的文件一起使用。因此，为了验证其操作，测试必须在写入后读取文件的内容。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而且我必须确保将其</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写入一个临时文件夹并随后将其删除。</font></font><br><br> <code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还定义了许多与方法无关的方法，</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，读取目录并检查路径是否为符号链接。好吧，如果签名</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅描述相关部分</font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该怎么办？</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // ReadWriterCloser. func Save(rwc io.ReadWriteCloser, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">借助</font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它，您可以应用接口分离的原理-并</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在描述文件更常规属性的接口上</font><font style="vertical-align: inherit;">重新定义它</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行此类更改后，</font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以将</font><font style="vertical-align: inherit;">实现该接口的任何类型</font><font style="vertical-align: inherit;">替换为上一个类型</font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这同时扩展了范围</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并向调用方阐明了</font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与其操作相关的</font><font style="vertical-align: inherit;">类型方法</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作者</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能再调用这些不相关的方法</font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为他隐藏在接口的后面</font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是我们可以进一步扩展接口分离的原理。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，如果</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 遵循单一责任的原则，他不太可能会读取他刚刚编写的文件来检查其内容-其他代码应该执行此操作。 </font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // WriteCloser. func Save(wc io.WriteCloser, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，您可以缩小接口的规格以</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅写和关闭。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其次，线程关闭机制y </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是它与文件一起工作时的传统。</font><font style="vertical-align: inherit;">问题是，</font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它将</font><font style="vertical-align: inherit;">在什么情况下</font><font style="vertical-align: inherit;">关闭。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无论是</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事业</font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无条件，不管是在成功的情况下。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这给调用者带来了一个问题，因为他可能想在编写文档后将数据添加到流中。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // Writer. func Save(w io.Writer, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最好的选择是重新定义“保存”以仅与一起使用</font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，从而将运算符从所有其他功能中保存下来，除了将数据写入流中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在应用了接口分离原理之后，该函数同时在要求方面变得更加具体（它只需要一个可以写入的对象），而在功能方面则变得更加通用，因为现在我们可以使用它</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在实现了任何地方保存数据了</font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.错误处理 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font><font style="vertical-align: inherit;">在博客上</font><font style="vertical-align: inherit;">做了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一些介绍</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">写了</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很多</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于该主题的文章，因此我不再重复。</font><font style="vertical-align: inherit;">相反，我想介绍与错误处理有关的其他两个方面。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><a name="7_1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1。</font><font style="vertical-align: inherit;">通过消除错误本身消除对错误处理的需要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我提出了许多改进错误处理语法的建议，但是最好的选择是根本不处理它们。 </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我不会说“删除错误处理”。</font><font style="vertical-align: inherit;">我建议更改代码，以便没有错误处理。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约翰·奥斯特豪特（John Osterhout）的最新</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">软件开发哲学</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">书启发了我提出这一建议</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">其中一章的标题为“从现实中消除错误”。</font><font style="vertical-align: inherit;">让我们尝试应用此建议。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.1。</font><font style="vertical-align: inherit;">行数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们将编写一个函数来计算文件中的行数。 </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( br = bufio.NewReader(r) lines <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err error ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { _, err = br.ReadString(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) lines++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != io.EOF { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我们遵循前面几节的建议时，</font></font><code>CountLines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接受</font></font><code>io.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不</font><font style="vertical-align: inherit;">接受</font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">；调用者已经提供了</font></font><code>io.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们要计算其内容的内容。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们创建</font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后在循环中调用方法</font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，增加计数器，直到到达文件末尾，然后返回读取的行数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">至少我们要编写这样的代码，但是该函数负担着错误处理。例如，有一个奇怪的构造：</font></font><br><br><pre> <code class="go hljs"> _, err = br.ReadString(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) lines++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查错误</font><i><font style="vertical-align: inherit;">之前，</font></i><font style="vertical-align: inherit;">我们增加了行数</font><font style="vertical-align: inherit;">-这看起来很奇怪。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之所以要这样写，是因为</font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果它比换行符早到达文件末尾，它将返回一个错误。</font><font style="vertical-align: inherit;">如果文件末尾没有新行，则会发生这种情况。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要尝试解决此问题，请更改行计数器的逻辑，然后查看是否需要退出循环。</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这种逻辑仍然不完美，您能找到错误吗？</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是我们还没有完成检查错误。</font><font style="vertical-align: inherit;">遇到文件末尾时</font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将返回</font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是预期的情况，因此对于</font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您来说</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">您需要采取一些方式说“停止，没有更多可阅读的内容了”。</font><font style="vertical-align: inherit;">因此，在将错误返回给调用对象之前</font></font><code>CountLine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，您需要检查该错误与无关</font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后将其传递，否则我们返回</font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并说一切都很好。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我认为这是Russ Cox关于错误处理如何隐藏函数的论文的一个很好的例子。</font><font style="vertical-align: inherit;">让我们看一下改进的版本。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { sc := bufio.NewScanner(r) lines := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sc.Scan() { lines++ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, sc.Err() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此改进版本</font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改用</font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在幕后</font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是添加了一个很好的抽象级别，这有助于消除错误处理。</font></font><br><br><blockquote> <b></b> . <code>bufio.Scanner</code>    ,      . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果扫描程序遇到字符串并且未发现错误，则</font><font style="vertical-align: inherit;">该方法</font></font><code>sc.Scan()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回一个值</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。因此，</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅在扫描器缓冲区中有一行文本时才调用</font><font style="vertical-align: inherit;">循环体</font><font style="vertical-align: inherit;">。这意味着</font></font><code>CountLines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当没有新行或文件为空时，新文件将处理情况。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其次，由于它</font><font style="vertical-align: inherit;">在检测到错误时</font></font><code>sc.Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此循环</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在到达文件末尾或检测​​到错误时结束。该类型会</font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记住它遇到的第一个错误，并且使用该方法，</font></font><code>sc.Err()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以在退出循环后立即恢复该错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，它</font></font><code>sc.Err()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">负责处理</font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将其转换为</font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是否到达文件末尾而没有错误。</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果遇到过多的错误处理，请尝试将一些操作提取到帮助程序类型中。</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.2。</font><font style="vertical-align: inherit;">写响应</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我的第二个例子是受</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“错误是价值观”一文的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启发</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前面我们看到了如何打开，写入和关闭文件的示例。</font><font style="vertical-align: inherit;">虽然有错误处理，但它并不过分，因为可以将操作封装在诸如</font></font><code>ioutil.ReadFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和的帮助器中</font></font><code>ioutil.WriteFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，当使用低级网络协议时，需要直接使用I / O原语构建答案。</font><font style="vertical-align: inherit;">在这种情况下，错误处理会变得很麻烦。</font><font style="vertical-align: inherit;">考虑创建HTTP响应的HTTP服务器的片段。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Header <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Key, Value <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Code <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Reason <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 %d %s\r\n"</span></span>, st.Code, st.Reason) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, h := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> headers { _, err := fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, h.Key, h.Value) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, err := fmt.Fprint(w, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } _, err = io.Copy(w, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，使用构建状态栏</font></font><code>fmt.Fprintf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并检查错误。然后，对于每个标题，我们都写一个键和标题值，每次检查错误。最后，我们在标题部分增加了一个标题部分</font></font><code>\r\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，检查错误，然后将响应主体复制到客户端。最后，尽管我们不需要检查来自的错误</font></font><code>io.Copy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是我们需要将其从两个返回值转换为唯一的return值</font></font><code>WriteResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是很多单调的工作。但是，您可以通过应用小型包装器来简化任务</font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br> <code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">满足合同</font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此可以用作包装器。</font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过函数传递记录，直到检测到错误为止。在这种情况下，它拒绝输入并返回上一个错误。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> errWriter <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { io.Writer err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *errWriter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e.err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, e.err } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, e.err = e.Writer.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { ew := &amp;errWriter{Writer: w} fmt.Fprintf(ew, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 %d %s\r\n"</span></span>, st.Code, st.Reason) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, h := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> headers { fmt.Fprintf(ew, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, h.Key, h.Value) } fmt.Fprint(ew, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>) io.Copy(ew, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ew.err }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果你申请</font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到</font></font><code>WriteResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，代码清晰显著改善。</font><font style="vertical-align: inherit;">您不再需要检查每个单独操作中的错误。</font><font style="vertical-align: inherit;">错误消息将作为字段检查移至函数的末尾，从而</font></font><code>ew.err</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">避免了返回的io.Copy值的烦人翻译。</font></font><br><br><a name="7_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2。</font><font style="vertical-align: inherit;">仅处理一次错误</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，我想指出错误应该只处理一次。</font><font style="vertical-align: inherit;">处理意味着检查错误的含义并做出</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">决定。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// WriteAll writes the contents of buf to the supplied writer. func WriteAll(w io.Writer, buf []byte) { w.Write(buf) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您做出的决定少于一个，则可以忽略该错误。</font><font style="vertical-align: inherit;">如我们在这里看到的，来自的错误被</font></font><code>w.WriteAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">忽略。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是</font><font style="vertical-align: inherit;">，针对一个错误</font><font style="vertical-align: inherit;">做出</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">决定也是错误的。</font><font style="vertical-align: inherit;">以下是我经常遇到的代码。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := w.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"unable to write:"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">// annotated error goes to log file return err // unannotated error returned to caller } return nil }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此示例中，如果在time内发生错误</font></font><code>w.Write</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则将该行写入日志，并且还返回给调用方，调用方也可以将其记录并传递给程序的顶层。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用者最有可能执行相同的操作：</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := WriteAll(w, buf); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"could not write config: %v"</span></span>, err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 因此，在日志中创建了重复行的堆栈。 </font></font><br><br><pre> <code class="go hljs">unable to write: io.EOF could not write config: io.EOF</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 但是在程序顶部，您会得到一个原始错误，没有任何上下文。 </font></font><br><br><pre> <code class="go hljs">err := WriteConfig(f, &amp;conf) fmt.Println(err) <span class="hljs-comment"><span class="hljs-comment">// io.EOF</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我想更详细地分析此主题，因为我不考虑同时返回错误和记录我的个人偏好的问题。 </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">// oops, forgot to return } if err := WriteAll(w, buf); err != nil { log.Println("could not write config: %v", err) return err } return nil }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我经常遇到程序员忘记从错误返回的问题。如前所述，Go的风格是使用边界运算符，在函数执行时检查先决条件，然后尽早返回。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此示例中，作者检查了错误，将其注册，但</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">忘记</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了返回。因此，出现了一个细微的问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go错误处理合同指出，在存在错误的情况下，无法对其他返回值的内容进行假设。由于JSON封送失败，因此内容</font></font><code>buf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未知：它可能不包含任何内容，但更糟的是，它可能包含半写的JSON片段。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于程序员在检查并记录错误之后忘记返回，因此损坏的缓冲区将被传送</font></font><code>WriteAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该操作很可能会成功，因此将无法正确写入配置文件。</font><font style="vertical-align: inherit;">但是，该功能正常完成，并且出现问题的唯一迹象是日志中的一行，其中JSON封送失败，而不是配置记录失败。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2.1。</font><font style="vertical-align: inherit;">为错误添加上下文</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发生错误是因为作者试图将上下文添加到错误消息中。</font><font style="vertical-align: inherit;">他试图留下一个标记以指示错误的来源。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们看看另一种方法来完成此操作</font></font><code>fmt.Errorf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := WriteAll(w, buf); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"could not write config: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := w.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"write failed: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果将错误记录与返回一行结合在一起，则更难忘记返回并避免意外继续。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果在写入文件时发生I / O错误，该方法</font></font><code>Error()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将产生如下内容：</font></font><br><br><pre> <code class="go hljs">could not write config: write failed: input/output error</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2.2。</font><font style="vertical-align: inherit;">使用github.com/pkg/errors包装错误</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该模式</font></font><code>fmt.Errorf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以很好地记录</font><font style="vertical-align: inherit;">错误</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消息</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是</font><font style="vertical-align: inherit;">错误</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会被忽略。</font><font style="vertical-align: inherit;">我认为将错误处理为不透明值对于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">松散耦合的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目</font><font style="vertical-align: inherit;">很重要</font><font style="vertical-align: inherit;">，因此，如果只需要使用其值，则源错误的类型无关紧要：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 确保它不为零。 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在屏幕上显示或记录。 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，碰巧您需要还原原始错误。</font><font style="vertical-align: inherit;">要注释此类错误，可以使用类似我的软件包的内容</font></font><code>errors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { f, err := os.Open(path) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"open failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> f.Close() buf, err := ioutil.ReadAll(f) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"read failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { home := os.Getenv(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>) config, err := ReadFile(filepath.Join(home, <span class="hljs-string"><span class="hljs-string">".settings.xml"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config, errors.WithMessage(err, <span class="hljs-string"><span class="hljs-string">"could not read config"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _, err := ReadConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，消息变成了一个不错的K＆D风格的错误： </font></font><br><br><pre> <code class="go hljs">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 其值包含原始原因的链接。 </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _, err := ReadConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"original error: %T %v\n"</span></span>, errors.Cause(err), errors.Cause(err)) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"stack trace:\n%+v\n"</span></span>, err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 因此，您可以恢复原始错误并显示堆栈跟踪： </font></font><br><br><pre> <code class="plaintext hljs">original error: *os.PathError open /Users/dfc/.settings.xml: no such file or directory stack trace: open /Users/dfc/.settings.xml: no such file or directory open failed main.ReadFile /Users/dfc/devel/practical-go/src/errors/readfile2.go:16 main.ReadConfig /Users/dfc/devel/practical-go/src/errors/readfile2.go:29 main.main /Users/dfc/devel/practical-go/src/errors/readfile2.go:35 runtime.main /Users/dfc/go/src/runtime/proc.go:201 runtime.goexit /Users/dfc/go/src/runtime/asm_amd64.s:1333 could not read config</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该包</font></font><code>errors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许您以方便的格式为人和机器将上下文添加到错误值。</font><font style="vertical-align: inherit;">在最近的一次演讲中，我告诉您，在即将发布的Go版本中，这样的包装器将出现在标准库中。</font></font><br><br><a name="8"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.并发 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常选择Go是因为它具有并发功能。开发人员在提高效率（就硬件资源而言）和性能方面做了很多工作，但是Go的并行功能可用于编写既不生产也不可靠的代码。在本文的结尾，我想给出一些技巧，说明如何避免Go的并发功能的某些陷阱。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go的顶级并发支持由渠道以及说明</font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果您从教科书或大学学习过Go语言理论，您可能已经注意到并行性部分始终是课程的最后部分。</font><font style="vertical-align: inherit;">我们的文章没有什么不同：我决定最后讨论并行性，这是Go程序员应该学习的常规技能的补充。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里有一定的二分法，因为Go的主要特征是我们简单易行的并行模型。</font><font style="vertical-align: inherit;">作为一种产品，我们的语言在销售自身时几乎牺牲了这一功能。</font><font style="vertical-align: inherit;">另一方面，并​​发实际上并不是那么容易使用，否则作者不会将并发作为其书籍的最后一章，并且我们不会为我们的代码感到遗憾。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本节讨论了天真地使用Go并发函数的一些陷阱。</font></font><br><br><a name="8_1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.1。</font><font style="vertical-align: inherit;">一直做一些工作。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这个程序有什么问题？ </font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该程序实现了我们的预期目的：它为简单的Web服务器提供服务。</font><font style="vertical-align: inherit;">同时，它在无限循环中花费CPU时间，因为</font></font><code>for{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在最后一行中，它</font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阻止gorutin main，而不执行任何I / O，无需等待阻止，发送或接收消息，或与sheduler进行某种连接。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于Go运行时通常由sheduler提供服务，因此该程序将在处理器上毫无意义地运行，并且可能以活动锁（活动锁）结束。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何解决？</font><font style="vertical-align: inherit;">这是一个选择。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { runtime.Gosched() } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这看起来很愚蠢，但这是现实生活中遇到的常见解决方案。</font><font style="vertical-align: inherit;">这是对潜在问题的误解的症状。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您对Go有所了解，则可以编写如下内容。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空语句将</font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">永远</font><font style="vertical-align: inherit;">被</font><font style="vertical-align: inherit;">阻止。</font><font style="vertical-align: inherit;">这很有用，因为现在我们不仅仅为了call而旋转整个处理器</font></font><code>runtime.GoSched()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，我们只治疗症状，不治疗原因。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我想向您展示另一个解决方案，希望您已经想到了。</font><font style="vertical-align: inherit;">不用</font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在goroutine </font><font style="vertical-align: inherit;">中运行</font><font style="vertical-align: inherit;">，而留下主要goroutine问题，只需</font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在主要goroutine中</font><font style="vertical-align: inherit;">运行即可</font><font style="vertical-align: inherit;">。</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果退出函数</font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则Go程序将无条件终止，无论在程序执行期间运行的其他goroutine做什么。</font></font></blockquote><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，这是我的第一个建议：如果goroutine直到收到另一个结果后才能取得进展，那么通常自己做而不是委派工作就容易了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这通常消除了将结果从goroutine传输回流程启动器所需的大量状态跟踪和通道操纵。</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">许多Go程序员滥用goroutine，尤其是刚开始时。</font><font style="vertical-align: inherit;">就像生活中的其他一切一样，成功的关键在于节制。</font></font></blockquote><br><a name="8_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.2。</font><font style="vertical-align: inherit;">留给调用者并行性</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 两种API有什么区别？ </font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ListDirectory returns the contents of dir. func ListDirectory(dir string) ([]string, error)</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ListDirectory returns a channel over which // directory entries will be published. When the list // of entries is exhausted, the channel will be closed. func ListDirectory(dir string) chan string</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们提到了明显的区别：第一个示例将目录读取到一个片中，然后在出现问题时返回整个片或错误。这是同步发生的，调用者将阻塞</font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直到所有目录条目都已被读取。根据目录的大小，它可能会花费很多时间，并且可能会占用大量内存。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑第二个例子。它有点像经典的Go编程，在这里它</font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回目录条目将通过其传输的通道。关闭通道时，这表明没有更多目录条目。由于通道的填充发生在return之后</font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此可以假设goroutines开始填充通道。</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在第二个选项中，没有必要实际使用goroutine：您可以选择一个足以存储所有目录条目的通道，而不会阻塞，填充，关闭它，然后将该通道返回给调用方。</font><font style="vertical-align: inherit;">但这不太可能，因为在这种情况下，使用大量内存在通道中缓冲所有结果时会出现相同的问题。</font></font></blockquote><br><font style="vertical-align: inherit;"></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通道</font><font style="vertical-align: inherit;">版本</font><font style="vertical-align: inherit;">还有两个问题：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果使用封闭通道作为信号来</font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通知</font><font style="vertical-align: inherit;">没有更多要处理</font><font style="vertical-align: inherit;">的元素，则由于错误而无法通知调用者元素的不完整集合。</font><font style="vertical-align: inherit;">调用者无法传达空目录和错误之间的区别。</font><font style="vertical-align: inherit;">在这两种情况下，似乎都将立即关闭该通道。</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用者在关闭通道时必须继续从通道中读取数据，因为这是了解通道填充goroutine已停止工作的唯一方法。</font><font style="vertical-align: inherit;">这是对使用的严重限制</font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：即使他收到了所有必要的数据，呼叫者也会花时间从通道中读取内容。</font><font style="vertical-align: inherit;">就中型和大型目录的内存使用而言，这可能更有效，但是该方法并不比基于原始切片的方法快。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在这两种情况下，解决方案都是使用回调：在每个目录条目执行时都会在其上下文中调用的函数。 </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListDirectory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fn </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">毫不奇怪，该功能</font></font><code>filepath.WalkDir</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以这样工作。</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果您的函数启动goroutine，则必须为调用者提供一种显式停止该例程的方法。</font><font style="vertical-align: inherit;">通常最容易在调用方上保留异步执行模式。</font></font></blockquote><br><a name="8_3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.3。</font><font style="vertical-align: inherit;">切勿在不知道何时停止运行goroutine</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在前面的示例中，不必要使用goroutine。</font><font style="vertical-align: inherit;">但是Go的主要优势之一是一流的并发功能。</font><font style="vertical-align: inherit;">实际上，在许多情况下，并行工作是非常适当的，因此有必要使用goroutines。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这个简单的应用程序在两个不同的端口上提供HTTP流量：端口8080用于应用程序流量，端口8001用于访问端点</font></font><code>/debug/pprof</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> _ <span class="hljs-string"><span class="hljs-string">"net/http/pprof"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) <span class="hljs-comment"><span class="hljs-comment">// debug http.ListenAndServe("0.0.0.0:8080", mux) // app traffic }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管程序并不复杂，但是它是实际应用程序的基础。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前形式的应用程序会随着问题的发展而出现一些问题，因此让我们立即看一下其中的一些问题。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveDebug() serveApp() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">断处理程序</font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以不同的功能，我们从他们分开</font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们也沿袭了以往的建议，并确保</font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">离开任务，以确保呼叫者的并行性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是这种程序的性能存在一些问题。</font><font style="vertical-align: inherit;">如果我们退出</font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后</font><font style="vertical-align: inherit;">退出</font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么程序将终止，并且将由流程管理器重新启动。</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">正如Go中的函数将并行性留给调用方一样，应用程序也应退出监视其状态并重新启动调用它们的程序。</font><font style="vertical-align: inherit;">不要让应用程序自行重启：最好从应用程序外部处理此过程。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，它</font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从一个单独的goroutine开始，如果释放，则goroutine结束，而程序的其余部分继续。</font><font style="vertical-align: inherit;">您的开发人员不会喜欢这样的事实，因为处理程序</font></font><code>/debug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">早已停止工作</font><font style="vertical-align: inherit;">，因此您无法获得应用程序统计信息</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果需要停止运行的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任何</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> goroutine，</font><font style="vertical-align: inherit;">我们需要确保该应用程序已关闭</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveDebug() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveApp() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，</font></font><code>serverApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他们</font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从中检查错误，</font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并在必要时致电</font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由于两个处理程序都在goroutine中工作，因此我们在中编写了主例程</font></font><code>select{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种方法有很多问题：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果</font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回错误</font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则不会有任何调用</font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且该端口上的HTTP服务将退出而不会停止应用程序。</font></font><br></li><li> <code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用</font></font><code>os.Exit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无条件退出程序；</font><font style="vertical-align: inherit;">延迟的调用将不起作用，其他goroutine将不会收到关闭通知，程序只会停止。</font><font style="vertical-align: inherit;">这使得很难为这些功能编写测试。</font></font></li></ol><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">仅</font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在函数</font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font><font style="vertical-align: inherit;">上</font><font style="vertical-align: inherit;">使用</font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，我们希望将发生的任何错误传达给goroutine的创建者，以便他可以找出为什么她停止并干净地完成了该过程。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> error, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done &lt;- serveDebug() }() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done &lt;- serveApp() }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(done); i++ { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := &lt;-done; err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"error: %v"</span></span>, err) } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Goroutine返回状态可以通过通道获得。通道大小等于我们要控制的goroutine的数量，因此</font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会阻止</font><font style="vertical-align: inherit;">发送到该通道</font><font style="vertical-align: inherit;">，因为这将阻止goroutine的关闭并导致泄漏。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于</font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无法安全地关闭通道，因此</font></font><code>for range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在所有goroutines都报告之前</font><font style="vertical-align: inherit;">，我们无法在通道周期中使用该惯用法</font><font style="vertical-align: inherit;">。相反，我们以一个周期运行所有正在运行的goroutine，这等于通道的容量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们有一种方法可以干净地退出每个goroutine并修复它们遇到的所有错误。剩下的只是向第一个goroutine发送信号以完成工作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对</font></font><code>http.Server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于完成，因此我将此逻辑包装在辅助函数中。</font><font style="vertical-align: inherit;">辅助</font></font><code>serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接受地址和</font></font><code>http.Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，同样地</font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以及所述信道</font></font><code>stop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们使用运行的方法</font></font><code>Shutdown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, handler http.Handler, stop &lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { s := http.Server{ Addr: addr, Handler: handler, } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { &lt;-stop <span class="hljs-comment"><span class="hljs-comment">// wait for stop signal s.Shutdown(context.Background()) }() return s.ListenAndServe() } func serveApp(stop &lt;-chan struct{}) error { mux := http.NewServeMux() mux.HandleFunc("/", func(resp http.ResponseWriter, req *http.Request) { fmt.Fprintln(resp, "Hello, QCon!") }) return serve("0.0.0.0:8080", mux, stop) } func serveDebug(stop &lt;-chan struct{}) error { return serve("127.0.0.1:8001", http.DefaultServeMux, stop) } func main() { done := make(chan error, 2) stop := make(chan struct{}) go func() { done &lt;- serveDebug(stop) }() go func() { done &lt;- serveApp(stop) }() var stopped bool for i := 0; i &lt; cap(done); i++ { if err := &lt;-done; err != nil { fmt.Println("error: %v", err) } if !stopped { stopped = true close(stop) } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，对于通道中的每个值，</font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们关闭通道</font></font><code>stop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这使该通道上的每个gorutin都关闭了自己的通道</font></font><code>http.Server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">反过来，这导致所有剩余的goroutines返回</font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当所有正在运行的gorutins都停止时，它</font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结束并且该过程完全停止。</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">自己编写这样的逻辑是重复的工作，并且有犯错误的风险。</font><font style="vertical-align: inherit;">查看类似</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此程序包的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">东西</font><font style="vertical-align: inherit;">，它将为您完成大部分工作。</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN441842/">https://habr.com/ru/post/zh-CN441842/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN441826/index.html">音频流媒体市场正在发生什么：讨论流媒体平台的发展</a></li>
<li><a href="../zh-CN441830/index.html">Kibana用户指南。 可视化。 第4部分</a></li>
<li><a href="../zh-CN441832/index.html">企业主认为谁是项目经理以及如何处理</a></li>
<li><a href="../zh-CN441834/index.html">不要上班。 但是，如果事情出在你身上怎么办？</a></li>
<li><a href="../zh-CN441836/index.html">一个云的故事：华为+ 3data =云</a></li>
<li><a href="../zh-CN441844/index.html">iRobot Scooba：清洗机器人清洁器常见问题的经验和解决方案</a></li>
<li><a href="../zh-CN441848/index.html">在Avito中为开发人员提供实习：战斗任务并与经验丰富的导师合作</a></li>
<li><a href="../zh-CN441850/index.html">神经网络上的算命：作者本人是否在帖子的评论中指出</a></li>
<li><a href="../zh-CN441852/index.html">42硅谷：如何被选中</a></li>
<li><a href="../zh-CN441854/index.html">REST？ 愚蠢的JSON-RPC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>