<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ¥ üò± üîî Perangkat kompiler Swift. Bagian 4 üßúüèº üßïüèæ ‚õàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah bagian terakhir dari ulasan saya tentang kompiler Swift. Saya akan menunjukkan kepada Anda bagaimana menghasilkan LLVM IR dari AST dan apa ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perangkat kompiler Swift. Bagian 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/440078/"><img src="https://habrastorage.org/webt/aw/ag/tw/awagtwhs7e5-czijhggzhqpl3gq.png"><br><p>  Ini adalah bagian terakhir dari ulasan saya tentang kompiler Swift.  Saya akan menunjukkan kepada Anda bagaimana menghasilkan LLVM IR dari AST dan apa sebenarnya frontend itu.  Jika Anda belum membaca bagian sebelumnya, maka ikuti tautannya: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tinjauan umum komponen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Parsing file sumber</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bahasa perantara cepat</a> <a name="habracut"></a></li></ul><br><h1 id="llvm-ir-gen">  LLVM IR Gen </h1><br><p>  Untuk frontend, ini adalah langkah terakhir.  Generator LLVM IR mengubah SIL menjadi representasi LLVM menengah.  Itu diteruskan ke backend untuk optimasi lebih lanjut dan pembuatan kode mesin. </p><br><h3 id="primer-realizacii">  Contoh implementasi </h3><br><p>  Untuk menghasilkan tampilan perantara, Anda perlu berinteraksi dengan perpustakaan LLVM.  Itu ditulis dalam C ++, tetapi karena Anda tidak dapat memanggilnya dari Swift, Anda harus menggunakan antarmuka-C.  Tapi Anda tidak bisa hanya beralih ke C-library. </p><br><p>  Itu perlu dibungkus dalam sebuah modul.  Buat itu mudah.  Ini instruksi yang bagus.  Untuk LLVM, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembungkus</a> seperti itu sudah ada di domain publik, jadi lebih mudah untuk mengambilnya. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembungkus Swift di</a> atas pustaka LLVM-C diposting pada akun yang sama, tetapi itu tidak akan digunakan dalam artikel ini. </p><br><p>  Untuk menghasilkan tampilan perantara, kelas <b>LLVMIRGen yang</b> sesuai telah dibuat.  Di initializer, dibutuhkan AST yang dibuat oleh parser: </p><br><pre><code class="plaintext hljs">import cllvm class LLVMIRGen { private let ast: ASTNode init(ast: ASTNode) { self.ast = ast }</code> </pre> <br><p>  Metode <b>printTo (_, dump)</b> memulai pembuatan dan menyimpannya dalam bentuk yang dapat dibaca ke file.  Parameter <b>dump</b> digunakan untuk secara opsional menampilkan informasi yang sama ke konsol: </p><br><pre> <code class="plaintext hljs">func printTo(_ fileName: String, dump: Bool) {</code> </pre> <br><p>  Pertama, Anda perlu membuat modul.  Penciptaannya, serta penciptaan entitas lain, dimasukkan ke dalam metode terpisah dan akan dibahas di bawah ini.  Karena ini adalah C, Anda perlu mengelola memori secara manual.  Untuk menghapus modul dari memori, gunakan fungsi <b>LLVMDisposeModule ()</b> : </p><br><pre> <code class="plaintext hljs">let module = generateModule() defer { LLVMDisposeModule(module) }</code> </pre> <br><p>  Nama semua fungsi dan tipe LLVM dimulai dengan awalan yang sesuai.  Misalnya, pointer ke modul adalah tipe <b>LLVMModuleRef</b> , dan untuk builder adalah <b>tipe LLVMBuilderRef</b> .  Builder adalah kelas pembantu (setelah semua, di bawah antarmuka-C yang tidak nyaman, kelas dan metode biasa disembunyikan), yang membantu menghasilkan IR: </p><br><pre> <code class="plaintext hljs">let builder = generateBuilder() defer { LLVMDisposeBuilder(builder) }</code> </pre> <br><p>  Output nomor dari kurung ke konsol akan dilakukan menggunakan fungsi put standar.  Untuk menghubunginya, Anda harus menyatakannya.  Ini terjadi dalam metode <b>generateExternalPutsFunction</b> .  Modul ini diteruskan karena deklarasi perlu ditambahkan padanya.  <strong>Konstanta putsFunction</strong> akan menyimpan pointer ke suatu fungsi sehingga dapat diakses: </p><br><pre> <code class="plaintext hljs">let putsFunction = generateExternalPutsFunction(module: module)</code> </pre> <br><p>  Kompiler Swift menciptakan fungsi <strong>utama</strong> pada tahap SIL.  Karena brace compiler tidak memiliki representasi perantara, fungsi akan segera dihasilkan di LLVM IR. </p><br><p>  Untuk melakukan ini, gunakan metode <b>generateMainFunction (builder, module, mainInternalGenerator)</b> .  Fungsi <strong>utama</strong> tidak akan dipanggil.  Karena itu, Anda tidak perlu menyimpan pointer ke sana: </p><br><pre> <code class="plaintext hljs">generateMainFunction(builder: builder, module: module) { // ... }</code> </pre> <br><p>  Parameter terakhir dari metode ini adalah penutupan, di mana AST dikonversi ke LLVM IR yang sesuai.  Untuk ini, metode terpisah <b>handleAST (_, putsFunction, builder) telah dibuat</b> : </p><br><pre> <code class="plaintext hljs">generateMainFunction(builder: builder, module: module) { handleAST(ast, putsFunction: putsFunction, builder: builder) }</code> </pre> <br><p>  Di akhir metode, representasi perantara yang dihasilkan adalah output ke konsol dan disimpan ke file: </p><br><pre> <code class="plaintext hljs">if dump { LLVMDumpModule(module) } LLVMPrintModuleToFile(module, fileName, nil)</code> </pre> <br><p>  Sekarang, lebih lanjut tentang metode.  Modul ini dihasilkan dengan memanggil fungsi <b>LLVMModuleCreateWithName ()</b> dengan nama yang diinginkan: </p><br><pre> <code class="plaintext hljs">private func generateModule() -&gt; LLVMModuleRef { let moduleName = "BraceCompiller" return LLVMModuleCreateWithName(moduleName) }</code> </pre> <br><p>  Pembangun dibuat lebih mudah.  Dia tidak membutuhkan parameter sama sekali: </p><br><pre> <code class="plaintext hljs">private func generateBuilder() -&gt; LLVMBuilderRef { return LLVMCreateBuilder() }</code> </pre> <br><p>  Untuk mendeklarasikan suatu fungsi, Anda harus terlebih dahulu mengalokasikan memori untuk parameternya dan menyimpan pointer ke Int8 di dalamnya.  Selanjutnya, panggil <b>LLVMFunctionType ()</b> untuk membuat tipe fungsi, meneruskannya dengan tipe nilai balik, array tipe argumen (C-array adalah pointer ke urutan nilai yang sesuai) dan jumlahnya.  <b>LLVMAddFunction ()</b> menambahkan fungsi <b>put</b> ke modul dan mengembalikan pointer ke sana: </p><br><pre> <code class="plaintext hljs">private func generateExternalPutsFunction(module: LLVMModuleRef) -&gt; LLVMValueRef { var putParamTypes = UnsafeMutablePointer&lt;LLVMTypeRef?&gt;.allocate(capacity: 1) defer { putParamTypes.deallocate() } putParamTypes[0] = LLVMPointerType(LLVMInt8Type(), 0) let putFunctionType = LLVMFunctionType(LLVMInt32Type(), putParamTypes, 1, 0) return LLVMAddFunction(module, "puts", putFunctionType) }</code> </pre> <br><p>  <b>main</b> dibuat dengan cara yang serupa, tetapi sebuah body ditambahkan padanya.  Seperti SIL, itu terdiri dari blok dasar.  Untuk melakukan ini, panggil metode <b>LLVMAppendBasicBlock ()</b> , dengan meneruskan fungsi dan nama blok ke sana. </p><br><p>  Sekarang pembangun ikut bermain.  <b>Dengan memanggil LLVMPositionBuilderAtEnd (),</b> ia bergerak ke ujung blok yang masih kosong, dan di dalam penutupan <b>mainInternalGenerator ()</b> , fungsi tubuh akan ditambahkan dengannya. </p><br><p>  Pada akhir metode, nilai konstan 0 dikembalikan dari <b>main</b> . Ini adalah instruksi terakhir dalam fungsi ini: </p><br><pre> <code class="plaintext hljs">private func generateMainFunction(builder: LLVMBuilderRef, module: LLVMModuleRef, mainInternalGenerator: () -&gt; Void) { let mainFunctionType = LLVMFunctionType(LLVMInt32Type(), nil, 0, 0) let mainFunction = LLVMAddFunction(module, "main", mainFunctionType) let mainEntryBlock = LLVMAppendBasicBlock(mainFunction, "entry") LLVMPositionBuilderAtEnd(builder, mainEntryBlock) mainInternalGenerator() let zero = LLVMConstInt(LLVMInt32Type(), 0, 0) LLVMBuildRet(builder, zero) }</code> </pre> <br><p>  Menghasilkan IR menurut AST dalam kompiler tanda kurung sangat sederhana, karena satu-satunya tindakan yang dapat dilakukan dalam "bahasa pemrograman" ini adalah dengan mengeluarkan satu nomor ke konsol.  Anda harus melalui seluruh pohon secara rekursif, dan ketika Anda menemukan <b>nomor</b> node, tambahkan panggilan ke fungsi <b>put</b> .  Jika simpul ini tidak ada, fungsi <b>utama</b> hanya akan berisi pengembalian nilai nol: </p><br><pre> <code class="plaintext hljs">private func handleAST(_ ast: ASTNode, putsFunction: LLVMValueRef, builder: LLVMBuilderRef) { switch ast { case let .brace(childNode): guard let childNode = childNode else { break } handleAST(childNode, putsFunction: putsFunction, builder: builder) case let .number(value): generatePrint(value: value, putsFunction: putsFunction, builder: builder) } }</code> </pre> <br><p>  Panggilan panggilan <b>dibuat</b> menggunakan fungsi <b>LLVMBuildCall ()</b> .  Perlu melewati pembangun, penunjuk ke fungsi, argumen dan nomor mereka.  <b>LLVMBuildGlobalStringPtr ()</b> menciptakan konstanta global untuk menyimpan string.  Dia akan menjadi satu-satunya argumen: </p><br><pre> <code class="plaintext hljs">private func generatePrint(value: Int, putsFunction: LLVMValueRef, builder: LLVMBuilderRef) { let putArgumentsSize = MemoryLayout&lt;LLVMValueRef?&gt;.size let putArguments = UnsafeMutablePointer&lt;LLVMValueRef?&gt;.allocate(capacity: 1) defer { putArguments.deallocate() } putArguments[0] = LLVMBuildGlobalStringPtr(builder, "\(value)", "print") _ = LLVMBuildCall(builder, putsFunction, putArguments, 1, "put") }</code> </pre> <br><p>  Untuk memulai pembuatan IR LLVM, Anda harus membuat turunan dari kelas <b>LLVMIRGen</b> dan memanggil metode <b>printTo (_, dump)</b> : </p><br><pre> <code class="plaintext hljs">let llvmIRGen = LLVMIRGen(ast: ast) llvmIRGen.printTo(outputFilePath, dump: false)</code> </pre> <br><p>  Karena sekarang kompiler tanda kurung benar-benar siap, Anda dapat memulainya dari baris perintah.  Untuk melakukan ini, Anda harus mengumpulkan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi</a> ) dan menjalankan perintah: </p><br><pre> <code class="plaintext hljs">build/debug/BraceCompiler Example/input.b Example/output.ll</code> </pre> <br><p>  Hasilnya adalah representasi perantara ini: </p><br><pre> <code class="plaintext hljs">; ModuleID = 'BraceCompiller' source_filename = "BraceCompiller" @print = private unnamed_addr constant [5 x i8] c"5678\00" declare i32 @puts(i8*) define i32 @main() { entry: %put = call i32 @puts(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @print, i32 0, i32 0)) ret i32 0 }</code> </pre> <br><h3 id="ispolzovanie-generatora-llvm-ir-swift">  Menggunakan LLVM IR Swift Generator </h3><br><p>  LLVM IR juga memiliki bentuk SSA, tetapi tingkat rendah dan lebih mirip assembler.  Deskripsi instruksi dapat ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . </p><br><p>  Pengidentifikasi global dimulai dengan <a href="">b&gt; @ &lt;/ b</a> , lokal dengan <b>%</b> .  Pada contoh di atas, string <b>"5678 \ 00"</b> disimpan dalam konstanta global <a href="">b&gt; @print &lt;/ b</a> , dan kemudian digunakan untuk memanggil fungsi <a href="">b&gt; @puts &lt;/ b</a> menggunakan pernyataan <b>panggilan</b> . </p><br><p>  Untuk melihat sesuatu yang menarik dalam LLVM IR yang dihasilkan oleh kompiler Swift, Anda perlu menyulitkan kode sedikit lagi.  Misalnya, tambahkan tambahan: </p><br><pre> <code class="plaintext hljs">let x = 16 let y = x + 7</code> </pre> <br><p>  <b>Bendera -emit-ir</b> bertanggung jawab untuk menghasilkan LLVM IR: </p><br><pre> <code class="plaintext hljs">swiftc -emit-ir main.swift</code> </pre> <br><p>  Hasil dari perintah: </p><br><pre> <code class="plaintext hljs">; ModuleID = '-' source_filename = "-" target datalayout = "em:o-i64:64-f80:128-n8:16:32:64-S128" target triple = "x86_64-apple-macosx10.14.0" %TSi = type &lt;{ i64 }&gt; @"$S4main1xSivp" = hidden global %TSi zeroinitializer, align 8 @"$S4main1ySivp" = hidden global %TSi zeroinitializer, align 8 @__swift_reflection_version = linkonce_odr hidden constant i16 3 @llvm.used = appending global [1 x i8*] [i8* bitcast (i16* @__swift_reflection_version to i8*)], section "llvm.metadata", align 8 define i32 @main(i32, i8**) #0 { entry: %2 = bitcast i8** %1 to i8* store i64 16, i64* getelementptr inbounds (%TSi, %TSi* @"$S4main1xSivp", i32 0, i32 0), align 8 %3 = load i64, i64* getelementptr inbounds (%TSi, %TSi* @"$S4main1xSivp", i32 0, i32 0), align 8 %4 = call { i64, i1 } @llvm.sadd.with.overflow.i64(i64 %3, i64 7) %5 = extractvalue { i64, i1 } %4, 0 %6 = extractvalue { i64, i1 } %4, 1 br i1 %6, label %8, label %7 ; &lt;label&gt;:7: ; preds = %entry store i64 %5, i64* getelementptr inbounds (%TSi, %TSi* @"$S4main1ySivp", i32 0, i32 0), align 8 ret i32 0 ; &lt;label&gt;:8: ; preds = %entry call void @llvm.trap() unreachable } ; Function Attrs: nounwind readnone speculatable declare { i64, i1 } @llvm.sadd.with.overflow.i64(i64, i64) #1 ; Function Attrs: noreturn nounwind declare void @llvm.trap() #2 attributes #0 = { "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" } attributes #1 = { nounwind readnone speculatable } attributes #2 = { noreturn nounwind } !llvm.module.flags = !{!0, !1, !2, !3, !4, !5, !6, !7} !llvm.linker.options = !{!8, !9, !10} !llvm.asan.globals = !{!11} !0 = !{i32 1, !"Objective-C Version", i32 2} !1 = !{i32 1, !"Objective-C Image Info Version", i32 0} !2 = !{i32 1, !"Objective-C Image Info Section", !"__DATA,__objc_imageinfo,regular,no_dead_strip"} !3 = !{i32 4, !"Objective-C Garbage Collection", i32 1536} !4 = !{i32 1, !"Objective-C Class Properties", i32 64} !5 = !{i32 1, !"wchar_size", i32 4} !6 = !{i32 7, !"PIC Level", i32 2} !7 = !{i32 1, !"Swift Version", i32 6} !8 = !{!"-lswiftSwiftOnoneSupport"} !9 = !{!"-lswiftCore"} !10 = !{!"-lobjc"} !11 = !{[1 x i8*]* @llvm.used, null, null, i1 false, i1 true}</code> </pre> <br><p>  Representasi perantara dari kompiler nyata sedikit lebih rumit.  Ada operasi tambahan di dalamnya, tetapi instruksi yang diperlukan tidak sulit ditemukan.  Di sini konstanta global <b>x</b> dan <b>y</b> dideklarasikan dengan nama yang cacat: </p><br><pre> <code class="plaintext hljs">@"$S4main1xSivp" = hidden global %TSi zeroinitializer, align 8 @"$S4main1ySivp" = hidden global %TSi zeroinitializer, align 8</code> </pre> <br><p>  Di sini dimulai definisi fungsi <b>utama</b> : </p><br><pre> <code class="plaintext hljs">define i32 @main(i32, i8**) #0 {</code> </pre> <br><p>  Pertama, ia menyimpan nilai 16 dalam konstanta <b>x</b> : </p><br><pre> <code class="plaintext hljs">store i64 16, i64* getelementptr inbounds (%TSi, %TSi* @"$S4main1xSivp", i32 0, i32 0), align 8</code> </pre> <br><p>  Kemudian dimuat ke register 3 dan digunakan untuk memanggil tambahan bersama dengan literal 7: </p><br><pre> <code class="plaintext hljs">%3 = load i64, i64* getelementptr inbounds (%TSi, %TSi* @"$S4main1xSivp", i32 0, i32 0), align 8 %4 = call { i64, i1 } @llvm.sadd.with.overflow.i64(i64 %3, i64 7)</code> </pre> <br><p>  Overflow memeriksa penambahan struktur pengembalian.  Nilai pertama adalah hasil dari penambahan, dan yang kedua adalah bendera yang menunjukkan apakah ada overflow. </p><br><p>  Struktur dalam LLVM lebih seperti tuple di Swift.  Tidak memiliki nama untuk bidang, dan Anda perlu mendapatkan nilai menggunakan <b>pernyataan extractvalue</b> .  Parameter pertama menunjukkan jenis bidang dalam struktur, yang kedua - struktur itu sendiri, dan setelah koma - indeks bidang, nilai yang perlu ditarik: </p><br><pre> <code class="plaintext hljs">%5 = extractvalue { i64, i1 } %4, 0 %6 = extractvalue { i64, i1 } %4, 1</code> </pre> <br><p>  Sekarang tanda overflow disimpan dalam register keenam.  Nilai ini diverifikasi menggunakan instruksi cabang.  Jika ada overflow, akan ada transisi ke blok <b>label8</b> , jika tidak, ke <b>label7</b> : </p><br><pre> <code class="plaintext hljs">br i1 %6, label %8, label %7</code> </pre> <br><p>  Dalam yang pertama ini, eksekusi program terganggu oleh panggilan ke <b>perangkap ()</b> .  Dalam yang kedua, hasil penambahan disimpan dalam konstanta <b>y</b> , dan 0 dikembalikan dari fungsi <b>utama</b> : </p><br><pre> <code class="plaintext hljs">; &lt;label&gt;:7: ; preds = %entry store i64 %5, i64* getelementptr inbounds (%TSi, %TSi* @"$S4main1ySivp", i32 0, i32 0), align 8 ret i32 0 ; &lt;label&gt;:8: ; preds = %entry call void @llvm.trap() unreachable</code> </pre> <br><h3 id="generaciya-assemblernogo-koda">  Pembuatan kode perakitan </h3><br><p>  Kompiler Swift juga dapat menampilkan kode rakitan.  Untuk melakukan ini, lewati <b>flag -emit-assembly</b> : </p><br><pre> <code class="plaintext hljs">swiftc -emit-assembly main.swift</code> </pre> <br><p>  Hasil dari perintah: </p><br><pre> <code class="plaintext hljs"> .section __TEXT,__text,regular,pure_instructions .build_version macos, 10, 14 .globl _main .p2align 4, 0x90 _main: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp movq $16, _$S4main1xSivp(%rip) movq _$S4main1xSivp(%rip), %rax addq $7, %rax seto %cl movl %edi, -4(%rbp) movq %rsi, -16(%rbp) movq %rax, -24(%rbp) movb %cl, -25(%rbp) jo LBB0_2 xorl %eax, %eax movq -24(%rbp), %rcx movq %rcx, _$S4main1ySivp(%rip) popq %rbp retq LBB0_2: ud2 .cfi_endproc .private_extern _$S4main1xSivp .globl _$S4main1xSivp .zerofill __DATA,__common,_$S4main1xSivp,8,3 .private_extern _$S4main1ySivp .globl _$S4main1ySivp .zerofill __DATA,__common,_$S4main1ySivp,8,3 .private_extern ___swift_reflection_version .section __TEXT,__const .globl ___swift_reflection_version .weak_definition ___swift_reflection_version .p2align 1 ___swift_reflection_version: .short 3 .no_dead_strip ___swift_reflection_version .linker_option "-lswiftSwiftOnoneSupport" .linker_option "-lswiftCore" .linker_option "-lobjc" .section __DATA,__objc_imageinfo,regular,no_dead_strip L_OBJC_IMAGE_INFO: .long 0 .long 1600 .subsections_via_symbols</code> </pre> <br><p>  Setelah memahami kode representasi perantara yang dijelaskan di atas, Anda dapat menemukan instruksi assembler yang dihasilkannya.  Di sini tersimpan 16 ke konstanta dan memuatnya ke <b>register% rax</b> : </p><br><pre> <code class="plaintext hljs">movq $16, _$S4main1xSivp(%rip) movq _$S4main1xSivp(%rip), %rax</code> </pre> <br><p>  Berikut adalah penambahan 7 dan nilai konstanta.  Hasil penambahan ditempatkan di <b>register% rax</b> : </p><br><pre> <code class="plaintext hljs">addq $7, %rax</code> </pre> <br><p>  Dan ini adalah bagaimana memuat hasilnya ke dalam konstanta <b>y</b> terlihat seperti: </p><br><pre> <code class="plaintext hljs">movq %rax, -24(%rbp) movq -24(%rbp), %rcx movq %rcx, _$S4main1ySivp(%rip)</code> </pre> <br><p>  Kode Sumber: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IR Gen</a> </li></ul><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Swift adalah kompiler yang terstruktur dengan baik, dan tidak sulit untuk mengetahui arsitektur umumnya.  Saya juga terkejut bahwa menggunakan LLVM, Anda dapat dengan mudah menulis bahasa pemrograman Anda sendiri.  Tentu saja, kompiler tanda kurung sangat primitif, tetapi implementasi Kaleidoscope juga sangat dimengerti.  Saya sarankan membaca setidaknya tiga bab pertama dari tutorial. </p><br><p>  Terima kasih kepada semua orang yang membaca.  Saya akan terus mempelajari kompiler Swift dan mungkin menulis tentang apa yang terjadi.  Topik apa yang berhubungan dengannya yang Anda minati? </p><br><h3 id="poleznye-ssylki">  Tautan yang bermanfaat: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Situs Resmi Swift</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Forum resmi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Evolusi cepat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori utama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LLVM</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tutorial Kaleidoskop</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kompilator parenthesis</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440078/">https://habr.com/ru/post/id440078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440066/index.html">Ekstensi VSCode untuk mempermudah pengembangan JavaScript dan Vue</a></li>
<li><a href="../id440070/index.html">Julia, Keturunan Gradien dan Metode Simpleks</a></li>
<li><a href="../id440072/index.html">AresDB Demo: Alat Analisis Real-Time Real-Time Berbasis Open dari Uber</a></li>
<li><a href="../id440074/index.html">Roskomos menganggap itu salah untuk membandingkan mesin Raptor Ilona Mask dan RD-180</a></li>
<li><a href="../id440076/index.html">Terjemahan dan interpretasi iklan dari bahasa Inggris ke bahasa Rusia</a></li>
<li><a href="../id440084/index.html">10 miliar ekspor perangkat lunak dapat diabaikan</a></li>
<li><a href="../id440086/index.html">Dunia Virus MS-DOS</a></li>
<li><a href="../id440088/index.html">bobaflu - aksesoris pemrograman flutter</a></li>
<li><a href="../id440090/index.html">Bagaimana sebenarnya indikator teknis di pasar saham bekerja?</a></li>
<li><a href="../id440092/index.html">Penyelidikan matematis tentang bagaimana pemilihan gubernur yang dipalsukan di Primorye pada 16 September 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>