<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêí üë®‚Äçüåæ üê∏ C√≥mo los tama√±os de las matrices C se convirtieron en parte de la interfaz binaria de la biblioteca üê∂ ü§≥üèΩ üì¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La mayor√≠a de los compiladores de C le permiten acceder a una matriz extern con l√≠mites indefinidos, por ejemplo: 



 extern int external_array[]; in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo los tama√±os de las matrices C se convirtieron en parte de la interfaz binaria de la biblioteca</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451182/"> La mayor√≠a de los compiladores de C le permiten acceder a una matriz <code>extern</code> con l√≠mites indefinidos, por ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array_get</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> external_array[index]; }</code> </pre> <br>  La definici√≥n de matriz externa puede estar en otra unidad de traducci√≥n y puede verse as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  La pregunta es qu√© sucede si esta definici√≥n separada cambia as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> };</code> </pre> <br>  M√°s o menos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <a name="habracut"></a><br>  ¬øSe preservar√° la interfaz binaria (siempre que exista un mecanismo que permita a la aplicaci√≥n determinar el tama√±o de la matriz en tiempo de ejecuci√≥n)? <br><br>  Curiosamente, en muchas arquitecturas, <i>aumentar el tama√±o de la matriz</i> viola la compatibilidad de la interfaz binaria (ABI).  Reducir el tama√±o de la matriz tambi√©n puede causar problemas de compatibilidad.  En este art√≠culo, veremos m√°s de cerca la compatibilidad ABI y explicaremos c√≥mo evitar problemas. <br><br><h1>  Enlaces en la secci√≥n de datos del archivo ejecutable </h1><br>  Para comprender c√≥mo el tama√±o de la matriz se convierte en parte de la interfaz binaria, primero debemos examinar los enlaces en la secci√≥n de datos del archivo ejecutable.  Por supuesto, los detalles dependen de la arquitectura espec√≠fica, y aqu√≠ nos centraremos en la arquitectura x86-64. <br><br>  La arquitectura x86-64 admite el direccionamiento relativo al contador del programa, es decir, el acceso a la variable de matriz global, como en la funci√≥n <code>array_get</code> mostrada anteriormente, se puede compilar en una sola instrucci√≥n <code>movl</code> : <br><br><pre> <code class="cpp hljs">array_get: <span class="hljs-function"><span class="hljs-function">movl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">external_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(,%rdi,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, %eax ret</span></span></code> </pre> <br>  A partir de esto, el ensamblador crea un archivo de objeto en el que la instrucci√≥n se marca como <code>R_X86_64_32S</code> . <br><br><pre> <code class="plaintext hljs">0000000000000000 : 0: mov 0x0(,%rdi,4),%eax 3: R_X86_64_32S external_array 7: retq</code> </pre> <br>  Este movimiento le dice al enlazador ( <code>ld</code> ) c√≥mo llenar la ubicaci√≥n correspondiente de la variable <code>external_array</code> durante el enlace al crear el ejecutable. <br><br>  Esto tiene dos consecuencias importantes. <br><br><ul><li>  Dado que el desplazamiento de la variable se determina en el momento de la construcci√≥n, en el tiempo de ejecuci√≥n no hay sobrecarga para determinarlo.  El √∫nico precio es el acceso a la memoria misma. <br></li><li>  Para determinar el desplazamiento, debe conocer los tama√±os de todos los datos variables.  De lo contrario, ser√≠a imposible calcular el formato de la secci√≥n de datos durante el dise√±o. </li></ul><br>  Para implementaciones en C orientadas al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">formato ejecutable y de enlace (ELF)</a> , como en GNU / Linux, las referencias a variables <code>extern</code> no contienen tama√±os de objeto.  En el ejemplo de <code>array_get</code> tama√±o del objeto es desconocido incluso para el compilador.  De hecho, el archivo de ensamblador completo se ve as√≠ (omitiendo solo la informaci√≥n de promoci√≥n de <code>-fno-asynchronous-unwind-tables</code> , que es t√©cnicamente necesaria para el cumplimiento de psABI): <br><br><pre> <code class="plaintext hljs"> .file "get.c" .text .p2align 4,,15 .globl array_get .type array_get, @function array_get: movl external_array(,%rdi,4), %eax ret .size array_get, .-array_get .ident "GCC: (GNU) 8.3.1 20190223 (Red Hat 8.3.1-2)" .section .note.GNU-stack,"",@progbits</code> </pre> <br>  No hay informaci√≥n de tama√±o para <code>external_array</code> en este archivo ensamblador: la √∫nica referencia de caracteres est√° en la l√≠nea con la instrucci√≥n <code>movl</code> , y los √∫nicos datos num√©ricos en la instrucci√≥n son el tama√±o del elemento de matriz (implicado por <code>movl</code> multiplicado por 4). <br><br>  Si ELF requiere tama√±os para variables indefinidas, incluso ser√° imposible compilar la funci√≥n <code>array_get</code> . <br><br>  ¬øC√≥mo obtiene el enlazador el tama√±o real de los caracteres?  Mira la definici√≥n del s√≠mbolo y usa la informaci√≥n de tama√±o que encuentra all√≠.  Esto permite que el compilador calcule el dise√±o de la secci√≥n de datos y complete los movimientos de datos con los desplazamientos apropiados. <br><br><h1>  Objetos comunes de ELF </h1><br>  Las implementaciones de C para ELF no requieren que el programador agregue marcado al c√≥digo fuente para indicar si la funci√≥n o variable se encuentra en el objeto actual (que puede ser la biblioteca o el archivo ejecutable principal) o en otro objeto.  El enlazador y el cargador din√°mico se encargar√°n de esto. <br><br>  Al mismo tiempo, hab√≠a un deseo de que los archivos ejecutables no redujeran el rendimiento al cambiar el modelo de compilaci√≥n.  Esto significa que al compilar el c√≥digo fuente para el programa principal (es decir, sin <code>-fPIC</code> , y en este caso particular sin <code>-fPIE</code> ), la funci√≥n <code>array_get</code> compila <i>exactamente</i> en <i>la misma</i> secuencia de comandos antes de introducir objetos din√°micos compartidos.  Adem√°s, no importa si la variable <code>external_array</code> est√° definida en el archivo ejecutable m√°s b√°sico o si alg√∫n objeto compartido se carga por separado en tiempo de ejecuci√≥n.  Las instrucciones creadas por el compilador son las mismas en ambos casos. <br><br>  ¬øC√≥mo es esto posible?  Despu√©s de todo, los objetos ELF comunes son independientes de la posici√≥n.  Se cargan en <i>direcciones impredecibles y aleatorias</i> en tiempo de ejecuci√≥n.  Sin embargo, el compilador genera una secuencia de c√≥digo de m√°quina que requiere que estas variables se ubiquen en un <i>desplazamiento fijo calculado durante el enlace</i> , mucho antes de que se inicie el programa. <br><br>  El hecho es que solo un objeto cargado (el archivo ejecutable principal) usa estos desplazamientos fijos.  Todos los dem√°s objetos (el cargador din√°mico en s√≠, la biblioteca de tiempo de ejecuci√≥n C y cualquier otra biblioteca utilizada por el programa) se compilan y compilan como objetos completamente independientes de la posici√≥n (PIC).  Para tales objetos, el compilador carga la direcci√≥n real de cada variable desde la tabla de desplazamiento global (GOT).  Podemos ver esta rotonda si <code>array_get</code> ejemplo de <code>-fPIC</code> con <code>-fPIC</code> , lo que conduce a dicho c√≥digo de ensamblaje: <br><br><pre> <code class="plaintext hljs">array_get: movq external_array@GOTPCREL(%rip), %rax movl (%rax,%rdi,4), %eax ret</code> </pre> <br>  Como resultado, la direcci√≥n de la variable <code>external_array</code> ya no est√° codificada y se puede cambiar en tiempo de ejecuci√≥n inicializando adecuadamente el registro GOT.  Esto significa que en tiempo de ejecuci√≥n, la definici√≥n de <code>external_array</code> puede estar en el mismo objeto compartido, otro objeto compartido o el programa principal.  El cargador din√°mico encontrar√° la definici√≥n adecuada basada en las reglas de b√∫squeda de caracteres ELF y asociar√° la referencia de s√≠mbolo indefinido con su definici√≥n actualizando el registro GOT a su direcci√≥n real. <br><br>  Volvemos al ejemplo original, donde la funci√≥n <code>array_get</code> est√° en el programa principal, por lo que la direcci√≥n de la variable se especifica directamente.  La idea clave implementada en el vinculador es que el programa principal proporcionar√° una definici√≥n de variable <code>external_array</code> , <i>incluso si en realidad se define en un objeto com√∫n en tiempo de ejecuci√≥n</i> .  En lugar de especificar la definici√≥n inicial de la variable en el objeto compartido, el cargador din√°mico seleccionar√° una <i>copia de la</i> variable en la secci√≥n de datos del archivo ejecutable. <br><br>  Esto tiene dos consecuencias importantes.  En primer lugar, recuerde que <code>external_array</code> se define de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  Aqu√≠ hay un inicializador que debe aplicarse a la definici√≥n en el archivo ejecutable principal.  Para hacer esto, en el archivo ejecutable principal, se coloca un enlace a la ubicaci√≥n de copia del s√≠mbolo.  El <code>readelf -rW</code> muestra como <code>R_X86_64_COPY</code> movimiento. <br><br><pre>  La secci√≥n de reubicaci√≥n '.rela.dyn' en el desplazamiento 0x408 contiene 3 entradas:
     Tipo de informaci√≥n de compensaci√≥n Valor del s√≠mbolo Nombre del s√≠mbolo + suma
 0000000000403ff0 0000000100000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
 0000000000403ff8 0000000200000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0
 0000000000404020 0000000300000005 R_X86_64_COPY 0000000000404020 external_array + 0 </pre><br>  Al igual que otros movimientos, el cargador din√°mico maneja el movimiento de copia.  Incluye una operaci√≥n simple de copia a nivel de bits.  El objetivo de la copia est√° determinado por el desplazamiento del desplazamiento ( <code>0000000000404020</code> en el ejemplo).  La fuente se determina en tiempo de ejecuci√≥n en funci√≥n del nombre del s√≠mbolo ( <code>external_array</code> ) y su valor.  Al crear una copia, el cargador din√°mico tambi√©n tendr√° en cuenta el tama√±o del car√°cter para obtener el n√∫mero de bytes que deben copiarse.  Para hacer todo esto posible, el s√≠mbolo <code>external_array</code> se exporta autom√°ticamente desde el archivo ejecutable como un s√≠mbolo espec√≠fico para que sea visible para el cargador din√°mico en tiempo de ejecuci√≥n.  La tabla de s√≠mbolos din√°micos ( <code>.dynsym</code> ) refleja esto, como lo muestra el comando <code>readelf -sW</code> : <br><br><pre>  La tabla de s√≠mbolos '.dynsym' contiene 4 entradas:
    Num: Valor Tama√±o Tipo Enlace Vis Ndx Nombre
      0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 
      1: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.2.5 (2)
      2: 0000000000000000 0 NOTYPE DEAKULT DEFAULT UND __gmon_start__
      3: 0000000000404020 12 OBJETO GLOBAL DEFAULT 22 external_array </pre><br>  ¬øDe d√≥nde proviene la informaci√≥n sobre el tama√±o del objeto (12 bytes, en este ejemplo)?  El vinculador abre todos los objetos comunes, busca su definici√≥n y toma informaci√≥n sobre el tama√±o.  Como antes, esto permite que el enlazador calcule el dise√±o de la secci√≥n de datos para que se puedan usar compensaciones fijas.  Nuevamente, el tama√±o de la definici√≥n en el ejecutable principal es fijo y no se puede cambiar en tiempo de ejecuci√≥n. <br><br>  El enlazador din√°mico tambi√©n redirige enlaces simb√≥licos en objetos compartidos a la copia movida en el ejecutable principal.  Esto garantiza que en todo el programa solo haya una copia de la variable, como lo requiere la sem√°ntica del lenguaje C. De lo contrario, si la variable cambia despu√©s de la inicializaci√≥n, las actualizaciones del archivo ejecutable principal no ser√°n visibles para los objetos din√°micos compartidos y viceversa. <br><br><h1>  Impacto en la compatibilidad binaria </h1><br>  ¬øQu√© sucede si cambiamos la definici√≥n de <code>external_array</code> en un objeto compartido sin vincular (o recompilar) el programa principal?  Primero, considere <i>agregar</i> un elemento de matriz. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> };</code> </pre> <br>  Esto generar√° una advertencia del cargador din√°mico en tiempo de ejecuci√≥n: <br><br> <code>main-program: Symbol `external_array' has different size in shared object, consider re-linking</code> <br> <br>  El programa principal todav√≠a contiene una definici√≥n de <code>external_array</code> con espacio para solo 12 bytes.  Esto significa que la copia est√° incompleta: solo se copian los primeros tres elementos de la matriz.  Como resultado, el acceso al elemento de matriz <code>extern_array[3]</code> no <code>extern_array[3]</code> definido.  Este enfoque afecta no solo al programa principal, sino tambi√©n a todo el c√≥digo en el proceso, porque todas las referencias a <code>extern_array</code> fueron redirigidas a la definici√≥n en el programa principal.  Esto incluye un objeto gen√©rico que proporciona una definici√≥n de <code>extern_array</code> .  Probablemente no est√© listo para enfrentar una situaci√≥n en la que un elemento de matriz en su propia definici√≥n ha desaparecido. <br><br>  ¬øQu√© tal cambiar en la direcci√≥n opuesta, eliminar un elemento? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <br>  Si el programa evita acceder al elemento de matriz <code>extern_array[2]</code> , porque de alguna manera detecta la longitud reducida de la matriz, entonces esto funcionar√°.  Despu√©s de la matriz, hay algo de memoria no utilizada, pero esto no interrumpir√° el programa. <br><br>  Esto significa que obtenemos la siguiente regla: <br><br><ul><li>  Agregar elementos a una variable de matriz global viola la compatibilidad binaria. <br></li><li>  Eliminar elementos puede romper la compatibilidad si no hay un mecanismo que evite el acceso a elementos eliminados. </li></ul><br>  Desafortunadamente, la advertencia del cargador din√°mico parece m√°s inofensiva de lo que realmente es, y para los elementos remotos no hay ninguna advertencia. <br><br><h1>  ¬øC√≥mo evitar esta situaci√≥n? </h1><br>  Detectar cambios ABI es bastante f√°cil con herramientas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libabigail</a> . <br><br>  La forma m√°s f√°cil de evitar esta situaci√≥n es implementar una funci√≥n que devuelva la direcci√≥n de la matriz: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_external_array</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> local_array; }</code> </pre> <br>  Si la definici√≥n de la matriz no puede hacerse est√°tica debido a la forma en que se usa en la biblioteca, en su lugar podemos ocultar su visibilidad y tambi√©n evitar su exportaci√≥n y, por lo tanto, evitar el problema de truncamiento: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] __attribute__ ((visibility (<span class="hljs-string"><span class="hljs-string">"hidden"</span></span>))) = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  Todo es mucho m√°s complicado si la variable de matriz se exporta por razones de compatibilidad con versiones anteriores.  Dado que la matriz de la biblioteca est√° truncada, el antiguo programa principal con una definici√≥n de matriz m√°s corta no podr√° proporcionar acceso a la matriz completa para el nuevo c√≥digo de cliente si se usa con la misma matriz global.  En cambio, la funci√≥n de acceso puede usar una matriz separada (est√°tica u oculta), o tal vez una matriz separada para elementos agregados al final.  La desventaja es que no es posible almacenar todo en una matriz continua si la variable de matriz se exporta por compatibilidad con versiones anteriores.  El dise√±o de la interfaz secundaria debe reflejar esto. <br><br>  Con el control de versiones de los caracteres, puede exportar varias versiones con diferentes tama√±os, sin cambiar nunca el tama√±o en una versi√≥n en particular.  Con este modelo, los nuevos programas relacionados siempre utilizar√°n la √∫ltima versi√≥n, presumiblemente con el tama√±o m√°s grande.  Dado que la versi√≥n y el tama√±o del s√≠mbolo son fijados por el editor de enlaces al mismo tiempo, siempre son consistentes.  La biblioteca GNU C utiliza este enfoque para las variables hist√≥ricas <code>sys_errlist</code> y <code>sys_siglist</code> .  Sin embargo, esto todav√≠a no proporciona una sola matriz continua. <br><br>  A fin de <code>get_external_array</code> , una funci√≥n de acceso (por ejemplo, la funci√≥n <code>get_external_array</code> anterior) es el mejor enfoque para evitar este problema de compatibilidad ABI. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/451182/">https://habr.com/ru/post/451182/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451172/index.html">Julia: funciones y estructuras como funciones</a></li>
<li><a href="../451174/index.html">Adaptaci√≥n de programas para ZX Spectrum a TR-DOS por medios modernos. Parte 1</a></li>
<li><a href="../451176/index.html">Noticias del mundo de OpenStreetMap No. 458 (23/04/2019 - 09/04/2019)</a></li>
<li><a href="../451178/index.html">Prueba de choque de aterrizaje del paraca√≠das del drag√≥n de la tripulaci√≥n</a></li>
<li><a href="../451180/index.html">PCB reemplaza dos motores lineales</a></li>
<li><a href="../451184/index.html">Proyecto Blue Origin Blue Moon: Gente en la Luna para 2024</a></li>
<li><a href="../451186/index.html">El repositorio de LINSTOR y su integraci√≥n con OpenNebula</a></li>
<li><a href="../451188/index.html">Sberbank o all√≠ y de regreso</a></li>
<li><a href="../451196/index.html">Separaci√≥n de perfiles de clientes y aut√≥nomos.</a></li>
<li><a href="../451198/index.html">El papel de la realidad aumentada y la realidad virtual en la NBA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>