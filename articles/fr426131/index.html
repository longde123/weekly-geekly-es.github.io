<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßóüèø üï¥üèº üö• T√©l√©chargez la configuration sur FPGA via USB ou d√©montez FTDI MPSSE üßùüèæ üß¢ üêøÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la vie de chaque tiroir, il arrive un moment o√π vous voulez √©crire votre propre chargeur du fichier de configuration dans le FPGA. J'ai d√ª partic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>T√©l√©chargez la configuration sur FPGA via USB ou d√©montez FTDI MPSSE</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426131/"><img src="https://habrastorage.org/webt/dx/i7/px/dxi7pxs820_gc9p_q_1m6zoaakm.jpeg"><br><br>  Dans la vie de chaque tiroir, il arrive un moment o√π vous voulez √©crire votre propre chargeur du fichier de configuration dans le FPGA.  J'ai d√ª participer √† l'√©laboration d'un stand de formation pour le d√©partement d'une universit√© technique.  Le stand est con√ßu pour √©tudier le traitement num√©rique du signal, bien que cela ne soit pas particuli√®rement important dans le cadre de cet article.  Et la signification est que le FPGA (Altera Cyclone IV) est √† la base du stand, sur lequel les √©tudiants collectent toutes sortes de sch√©mas DSP, tels que con√ßus par l'auteur du stand.  Le support est connect√© √† l'ordinateur via USB.  Vous devez t√©l√©charger le FPGA depuis l'ordinateur via USB. <br><p>  Il a √©t√© d√©cid√© de se connecter √† un PC utilisant FTDI dans son incarnation √† deux canaux - FT2232H.  Un canal sera utilis√© pour la configuration FPGA, l'autre peut √™tre utilis√© pour l'√©change FIFO haute vitesse. </p><a name="habracut"></a><br><p>  FTDI a une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">carte de</a> d√©bogage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MORPH-IC-II</a> , o√π le FPGA Cyclone II est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">flash√©</a> via USB.  Concepts dans le domaine public.  Le code source du chargeur de d√©marrage est partiellement ouvert: le chargeur de d√©marrage lui-m√™me est disponible, cependant, toute la logique de travail avec FTDI est d√©plac√©e vers une biblioth√®que priv√©e et ne peut pas √™tre modifi√©e.  En v√©rit√©, j'avais initialement pr√©vu d'utiliser ce chargeur de d√©marrage dans mon projet, ou, dans des cas extr√™mes, de cr√©er mon shell en fonction de leur DLL.  Le firmware est charg√© dans le FPGA en mode s√©rie passif (passif s√©rie - PS), FTDI fonctionne en mode MPSSE.  Sur la maquette, les performances de la solution MORPH-IC-II ont √©t√© pleinement confirm√©es, mais le probl√®me, comme cela arrive souvent, ne vient pas d'o√π.  Il s'est av√©r√© que pendant le fonctionnement de la dll MORPH-IC-II, tous les appareils FTDI connect√©s sont bloqu√©s, et dans le cadre du complexe de formation, il y a deux autres appareils avec des convertisseurs similaires: un g√©n√©rateur et un analyseur de signal.  Un travail simultan√© avec eux n'est pas possible.  Merde bizarre et ennuyeux. </p><br><p>  Un cas similaire a √©t√© impl√©ment√© par les gars du rover Mars: le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">programmeur USB JTAG MBFTDI</a> .  FTDI y est √©galement utilis√© en mode MPSSE, mais contrairement au MORPH-IC-II, les op√©rations FPGA sont effectu√©es en mode JTAG.  Les sources sont disponibles gratuitement, mais je n'ai pas trouv√© d'indication claire sur leur statut (licence).  Par cons√©quent, pour les utiliser dans un projet commercial, ma main ne s'est pas lev√©e. </p><br><p>  Je corrigerai une telle erreur, tout ce qui sera pr√©sent√© dans le cadre de cet article est post√© dans un r√©f√©rentiel ouvert sous licence BSD. </p><br><h2 id="zagruzka-fayla-konfiguracii-v-mikroshemu-plis">  T√©l√©charger le fichier de configuration sur la puce FPGA </h2><br><p>  Tout d'abord, vous devriez vous occuper du mode de d√©marrage FPGA.  Pour ceux qui commencent tout juste √† se familiariser avec le sujet, je ferai une petite excursion.  Bien que des FPGA Altera (Intel) de la famille Cyclone IV E soient install√©s sur ma carte, les m√©thodes de chargement sont similaires pour l'ensemble du groupe FPGA Cyclone, et on soup√ßonne que sous une forme ou une autre, elles conviennent √† de nombreuses autres familles. </p><br><p>  Ce type de FPGA utilise une SRAM volatile pour stocker les donn√©es de configuration.  Ces donn√©es de configuration d√©terminent la fonctionnalit√© du p√©riph√©rique r√©sultant.  Dans le jargon professionnel, ces donn√©es sont souvent appel√©es ¬´firmware¬ª.  Ainsi, le firmware est stock√© dans une RAM sp√©ciale et chaque fois que l'appareil est allum√©, il doit √™tre charg√© dans la puce FPGA.  Il existe plusieurs fa√ßons (sch√©mas de configuration) par lesquelles le firmware peut √™tre charg√© dans SRAM (la liste est pertinente pour Cyclone IV E): </p><br><ol><li>  S√©rie active (AS). </li><li>  Parall√®le actif (AP) </li><li>  S√©rie passive (PS) </li><li>  Parall√®le passif rapide (FPP). </li><li>  JTAG. </li></ol><br><p>  Le choix d'un mode de d√©marrage sp√©cifique s'effectue √† l'aide de broches FPGA externes (groupe MSEL).  Le mode JTAG est toujours disponible.  Le mode actif implique que lorsque l'alimentation est appliqu√©e, le FPGA lit ind√©pendamment les donn√©es de la m√©moire externe (s√©rie ou parall√®le).  En mode passif, le FPGA attend qu'un support externe lui transf√®re de mani√®re proactive les donn√©es de configuration.  Ces sch√©mas s'int√®grent bien dans le concept de ma√Ætre (ma√Ætre) - esclave (esclave).  Dans les modes actifs, le FPGA agit comme ma√Ætre et dans les modes passifs comme esclave. </p><br><p>  Dans ce probl√®me, ce n'est pas le FPGA, mais l'utilisateur doit d√©cider quand le firmware doit √™tre mis √† jour, donc le mode de d√©marrage doit √™tre passif.  Et pour sauver les jambes de la puce, nous choisissons une interface s√©rie.  Le mode s√©rie passif (PS) et JTAG conviennent ici.  La logique du JTAG est un peu plus compliqu√©e, alors concentrons-nous sur la premi√®re option. <br>  La figure ci-dessous montre le sch√©ma de connexion du FPGA √† un contr√¥leur externe pour le t√©l√©chargement en mode PS. </p><br><img width="400" src="https://habrastorage.org/webt/q-/rj/pe/q-rjpeqe5y8ojlu8ywedoejklxq.png"><br><p>  Pour d√©marrer la configuration, le ma√Ætre externe doit g√©n√©rer une transition basse √† haute sur la ligne <em>nCONFIG</em> .  D√®s que le FPGA est pr√™t √† recevoir des donn√©es, il formera un niveau √©lev√© sur la ligne <em>nSTATUS</em> .  Apr√®s cela, le ma√Ætre peut commencer √† transmettre des donn√©es sur la ligne <em>DATA [0]</em> et les impulsions d'horloge correspondantes sur la ligne <em>DCLK</em> .  Les donn√©es doivent √™tre transmises au p√©riph√©rique cible jusqu'√† ce qu'un niveau √©lev√© soit √©tabli sur la ligne <em>CONF_DONE</em> (ou que les donn√©es ne se terminent pas) et que le FPGA passe √† l'√©tat d'initialisation.  Il convient de noter qu'apr√®s que <em>CONF_DONE est</em> d√©fini sur un, deux impulsions d'horloge suppl√©mentaires doivent √™tre appliqu√©es pour que l'initialisation FPGA commence. </p><br><p>  Les donn√©es sont transmises par le bit le moins significatif ( <abbr title="Bit le moins significatif">LSB</abbr> ) vers l'avant, c'est-√†-dire que si le fichier de configuration contient la s√©quence 02 1B EE 01 FA (prenez l'exemple tel qu'il est tir√© du manuel), la s√©quence doit √™tre form√©e sur la ligne de donn√©es: </p><br><pre><code class="hljs powershell"><span class="hljs-number"><span class="hljs-number">0100</span></span><span class="hljs-literal"><span class="hljs-literal">-0000</span></span> <span class="hljs-number"><span class="hljs-number">1101</span></span><span class="hljs-literal"><span class="hljs-literal">-1000</span></span> <span class="hljs-number"><span class="hljs-number">0111</span></span><span class="hljs-literal"><span class="hljs-literal">-0111</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span><span class="hljs-literal"><span class="hljs-literal">-0000</span></span> <span class="hljs-number"><span class="hljs-number">0101</span></span><span class="hljs-literal"><span class="hljs-literal">-1111</span></span></code> </pre> <br><p>  Ainsi, seules cinq lignes sont utilis√©es: les lignes <em>DATA [0]</em> et <em>DCLK</em> pour la transmission s√©rie, les <em>lignes nCONFIG</em> , <em>nSTATUS</em> , <em>CONF_DONE</em> pour le contr√¥le. <br>  √Ä la base, le mode PS n'est rien de plus que SPI avec une manipulation suppl√©mentaire des drapeaux. <br>  Le taux de transfert de donn√©es doit √™tre inf√©rieur √† la fr√©quence maximale indiqu√©e dans la documentation; pour la s√©rie Cyclone IV E utilis√©e dans le projet, elle est de 66 MHz. </p><br><p>  La fr√©quence de transmission minimale n'existe pas, il est th√©oriquement possible de suspendre la configuration pour une dur√©e ind√©termin√©e.  Cela donne d'excellentes opportunit√©s de d√©bogage √©tape par √©tape avec la participation d'un oscilloscope, que nous utiliserons certainement. </p><br><p>  La figure ci-dessous montre le chronogramme de l'interface avec les temporisations les plus significatives. </p><br><img width="720" src="https://habrastorage.org/webt/54/et/uy/54etuy0yva1est_qtdqp9yopqj8.png"><br><h2 id="hitryy-zver-mpsse">  Sly Beast MPSSE </h2><br><p>  Consid√©rez le fonctionnement de FTDI en mode MPSSE.  Le mode MPSSE (Multi-Protocol Synchronous Serial Engine), √† ‚Äã‚Äãmon avis, est une tentative plus ou moins r√©ussie de cr√©er un certain concepteur d'interface s√©rie, pour donner au d√©veloppeur la possibilit√© d'impl√©menter des protocoles de transfert de donn√©es r√©pandus, tels que SPI, I2C, JTAG, 1-wire et bien d'autres d'autres bas√©s sur eux. </p><br><p>  Actuellement, le mode est disponible pour les microcircuits: FT232H, FT2232D, FT2232H, FT4232H.  Dans mon projet, j'utilise le FT2232H, nous en parlons donc plus largement.  Pour le mode MPSSE, 16 segments sont allou√©s, divis√©s en deux octets: le L inf√©rieur et le H. le plus √©lev√©. Chaque octet peut √™tre lu ou d√©fini.  Les quatre branches inf√©rieures de l'octet L ont des fonctions sp√©ciales - la transmission de donn√©es en s√©rie peut se produire √† travers elles.  Chaque branche peut √™tre configur√©e comme entr√©e ou sortie, une valeur par d√©faut peut √™tre d√©finie pour la sortie.  Pour la transmission s√©quentielle, l'ordre des bits ( <abbr title="Bit le plus significatif">MSB</abbr> / <abbr title="Bit le moins significatif">LSB</abbr> ), la longueur du mot transmis, la fr√©quence des impulsions d'horloge, la synchronisation avant - avant (Rising) ou arri√®re (Falling), vous pouvez choisir de transmettre uniquement des impulsions d'horloge sans donn√©es, ou s√©lectionner une horloge triphas√©e (pertinent pour I2C) et bien plus encore. </p><br><p>  Passez sans probl√®me √† la programmation.  Il existe deux fa√ßons alternatives d'interaction logicielle avec les puces FTDI: la premi√®re, appelons-la classique, dans ce cas, lorsqu'elle est connect√©e √† un port USB, la puce du syst√®me est d√©finie comme un port s√©rie virtuel (COM), le syst√®me d'exploitation utilise le pilote VCP (Virtual COM Port).  Toutes les autres programmations ne diff√®rent pas de la programmation du port COM classique: ouvert - transmis / compt√© - ferm√©.  Et cela est vrai pour divers syst√®mes d'exploitation, y compris Linux et Mac OS.  Cependant, avec cette approche, il ne sera pas possible de r√©aliser toutes les fonctionnalit√©s du contr√¥leur FTDI - la puce fonctionnera comme un adaptateur USB-UART.  La deuxi√®me m√©thode est fournie par la biblioth√®que propri√©taire FTD2XX, cette interface fournit des fonctions sp√©ciales qui ne sont pas disponibles dans l'API de port COM standard, en particulier, il est possible de configurer et d'utiliser des modes de fonctionnement sp√©ciaux, tels que MPSSE, 245 FIFO, Bit-bang.  La biblioth√®que de l'API FTD2XX est bien document√©e par le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide du programmeur du d√©veloppement d'applications logicielles D2XX</a> , largement connu depuis longtemps dans les cercles √©troits.  Et oui, FTD2XX est √©galement disponible pour diff√©rents syst√®mes d'exploitation. </p><br><p>  Les d√©veloppeurs de FTDI ont √©t√© confront√©s √† la t√¢che d'int√©grer la relativement nouvelle MPSSE dans le mod√®le d'interaction logiciel D2XX existant.  Et ils ont r√©ussi, pour travailler en mode MPSSE le m√™me ensemble de fonctions est utilis√© que pour les autres modes "classiques", la m√™me biblioth√®que FTD2XX API est utilis√©e. </p><br><p>  En bref, l'algorithme pour fonctionner en mode MPSSE peut √™tre d√©crit comme suit: </p><br><ol><li>  Recherchez l'appareil dans le syst√®me et ouvrez-le. </li><li>  Initialisez la puce et mettez-la en mode MPSSE. </li><li>  D√©finissez le mode de fonctionnement de MPSEE. </li><li>  Travail direct avec les donn√©es: transmettre, recevoir, g√©rer GPIO - nous impl√©mentons le protocole d'√©change cible. </li><li>  Fermez l'appareil. </li></ol><br><h2 id="pishem-zagruzchik">  √âcrire un chargeur de d√©marrage </h2><br><p>  Passons √† la partie pratique.  Dans mes exp√©riences, j'utiliserai la version Eclipse d'Oxygen.3a Release (4.7.3a) comme IDE, et mingw32-gcc (6.3.0) comme compilateur.  Syst√®me d'exploitation Win7. </p><br><p>  Sur le site Web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FTDI,</a> nous t√©l√©chargeons la derni√®re version actuelle du pilote pour notre syst√®me d'exploitation.  Dans l'archive, nous trouvons le fichier d'en-t√™te ftd2xx.h avec une description de toutes les fonctions de l'API.  L'API elle-m√™me est impl√©ment√©e en tant que ftd2xx.dll, mais nous laisserons l'importation dynamique pour plus tard et utiliserons le lien statique: nous avons besoin du fichier de biblioth√®que ftd2xx.lib.  Pour mon cas, ftd2xx.lib se trouve dans le r√©pertoire i386. </p><br><p>  Dans Eclipse, cr√©ez un nouveau projet C.  La cr√©ation d'un <em>makefile</em> peut √™tre approuv√©e par un IDE.  Dans les param√®tres de l'√©diteur de liens, sp√©cifiez le chemin et le nom de la biblioth√®que ftd2xx (j'ai transf√©r√© les fichiers requis dans le r√©pertoire du projet dans le dossier ftdi).  Je ne me concentrerai pas sur les fonctionnalit√©s de configuration d'un projet pour Eclipse, car je soup√ßonne que la plupart de Win utilise d'autres environnements et compilateurs pour la programmation sous Win. </p><br><h3 id="punkt-pervyy-nayti-devays-i-otkryt-ego">  Premier point.  Trouver un appareil et l'ouvrir </h3><br><p>  L'API FTD2XX vous permet d'ouvrir la puce en utilisant l'une ou l'autre des informations connues √† son sujet.  Il peut s'agir de son num√©ro de s√©rie dans le syst√®me: la premi√®re puce FTDI connect√©e prendra le num√©ro 0, la suivante 1 et ainsi de suite.  Le nombre dans le syst√®me est d√©termin√© par l'ordre dans lequel les microcircuits sont connect√©s, pour le moins, ce n'est pas toujours pratique.  Pour ouvrir la puce par num√©ro, la fonction <code>FT_Open</code> est <code>FT_Open</code> .  Vous pouvez ouvrir la puce par son num√©ro de s√©rie ( <code>FT_OPEN_BY_SERIAL_NUMBER</code> ), sa description ( <code>FT_OPEN_BY_DESCRIPTION</code> ) ou par emplacement ( <code>FT_OPEN_BY_LOCATION</code> ), pour cela, la fonction <code>FT_OpenEx</code> est <code>FT_OpenEx</code> .  Le num√©ro de s√©rie et la description sont stock√©s dans la m√©moire interne de la puce et peuvent y √™tre enregistr√©s lors de la fabrication de l'appareil avec FTDI install√©.  En r√®gle g√©n√©rale, la description caract√©rise le type d'appareil ou de famille et le num√©ro de s√©rie doit √™tre unique pour chaque produit.  Par cons√©quent, le moyen le plus pratique d'identifier les p√©riph√©riques pris en charge par le programme en cours de d√©veloppement est sa description.  Nous ouvrirons la puce FTDI selon la description (descripteur).  En fait, si nous connaissions initialement la ligne de descripteur de puce, nous n'avons pas besoin de rechercher le p√©riph√©rique dans le syst√®me, cependant, √† titre exp√©rimental, nous afficherons tous les p√©riph√©riques connect√©s √† l'ordinateur avec FTDI.  En utilisant la fonction <code>FT_CreateDeviceInfoList</code> , <code>FT_CreateDeviceInfoList</code> cr√©erons une liste d√©taill√©e des puces connect√©es, et en utilisant la fonction <code>FT_GetDeviceInfoList</code> , <code>FT_GetDeviceInfoList</code> consid√©rerons. </p><br><div class="spoiler">  <b class="spoiler_title">Liste des appareils connect√©s.</b>  <b class="spoiler_title">Annonce:</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ftStatus = FT_CreateDeviceInfoList(&amp;numDevs); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ftStatus == FT_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Number of devices is %d\n"</span></span>,numDevs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numDevs == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allocate storage for list based on numDevs devInfo = (FT_DEVICE_LIST_INFO_NODE*)malloc(sizeof(FT_DEVICE_LIST_INFO_NODE)*numDevs); ftStatus = FT_GetDeviceInfoList(devInfo,&amp;numDevs); if (ftStatus == FT_OK) for (int i = 0; i &lt; numDevs; i++) { printf("Dev %d:\n",i); printf(" Flags=0x%x\n",devInfo[i].Flags); printf(" Type=0x%x\n",devInfo[i].Type); printf(" ID=0x%x\n",devInfo[i].ID); printf(" LocId=0x%x\n",devInfo[i].LocId); printf(" SerialNumber=%s\n",devInfo[i].SerialNumber); printf(" Description=%s\n",devInfo[i].Description); }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Bienvenue mon zoo</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">D:\workspace\ftdi-mpsse-ps\<span class="hljs-keyword"><span class="hljs-keyword">Debug</span></span>&gt;ftdi-mpsse-ps.exe Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> devices <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> Dev <span class="hljs-number"><span class="hljs-number">0</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x5</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036001</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x214</span></span> SerialNumber = AI043NNV Description = FT232R USB UART Dev <span class="hljs-number"><span class="hljs-number">1</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x6</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036010</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x2121</span></span> SerialNumber = L731T70OA Description = LESO7 A Dev <span class="hljs-number"><span class="hljs-number">2</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x6</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036010</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x2122</span></span> SerialNumber = L731T70OB Description = LESO7 B Dev <span class="hljs-number"><span class="hljs-number">3</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x8</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036014</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x213</span></span> SerialNumber = FTYZ92L6 Description = LESO4<span class="hljs-number"><span class="hljs-number">.1</span></span>_ER</code> </pre> </div></div><br><p>  Trois appareils avec puces FTDI sont connect√©s √† mon PC: FT232RL (type 0x5), FT2232H (type 0x6) et FT232H (tepe 0x8).  La puce FT2232H du syst√®me √©tait affich√©e sous la forme de deux p√©riph√©riques ind√©pendants (Dev 1 et Dev 2).  L'interface FPGA PS est connect√©e √† Dev 2, son descripteur est ¬´LESO7 B¬ª.  Ouvrez-le: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Open a device with device description "LESO7 B" ftStatus = FT_OpenEx("LESO7 B", FT_OPEN_BY_DESCRIPTION, &amp;ftHandle); if (ftStatus != FT_OK) { printf ("pen failure\r\n"); return -1; }</span></span></code> </pre> <br><p>  La plupart des fonctions API renvoient le statut de leur appel de type <code>FT_STATUS</code> , toutes les valeurs possibles sont d√©crites comme enum dans le fichier d'en-t√™te.  Il y en a beaucoup, mais il suffit de savoir que la valeur <code>FT_OK</code> est l'absence d'erreur, toutes les autres valeurs sont des codes d'erreur.  Un bon style de programmation consiste √† v√©rifier la valeur d'√©tat apr√®s chaque appel √† la fonction API. </p><br><p>  Si le p√©riph√©rique a √©t√© ouvert avec succ√®s, alors dans la variable <code>ftHandle</code> appara√Æt une valeur autre que z√©ro, un descripteur de fichier √©quivalent, qui est utilis√© lorsque vous travaillez avec des fichiers.  La poign√©e r√©sultante √©tablit une connexion avec l'interface mat√©rielle et doit √™tre utilis√©e lors de l'appel de toutes les fonctions de biblioth√®que qui n√©cessitent l'acc√®s √† la puce. <br>  Afin de confirmer dans la pratique l'op√©rabilit√© du syst√®me pour l'√©tape actuelle, nous devons passer imm√©diatement √† l'√©tape cinq de notre algorithme. </p><br><p>  Apr√®s avoir fini de travailler avec la puce, vous devez la fermer.  Pour ce faire, utilisez la fonction <code>FT_Close</code> : </p><br><pre> <code class="cpp hljs">FT_Close(ftHandle);</code> </pre> <br><h3 id="punkt-2-inicializiruem-chip-i-vklyuchaem-mpsse">  Point 2. Initialisez la puce et allumez le MPSSE </h3><br><p>  Le param√®tre est typique de la plupart des modes et est bien d√©crit dans la documentation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">base AN_135 FTDI MPSSE</a> . </p><br><ol><li>  Nous effectuons une r√©initialisation (rezet) de la puce.  Fonction <code>FT_ResetDevice</code> . </li><li>  Dans le cas o√π il y a des ordures dans le tampon de r√©ception, nous les effa√ßons.  Fonction <code>FT_Purge</code> . </li><li>  Ajustez la taille des tampons pour la lecture et l'√©criture.  Fonction <code>FT_SetUSBParameters</code> . </li><li>  D√©sactivez la parit√©.  <code>FT_SetChars</code> . </li><li>  Nous fixons des d√©lais pour la lecture et l'√©criture.  Par d√©faut, les d√©lais d'attente sont d√©sactiv√©s, activez le d√©lai de transmission.  <code>FT_SetTimeouts</code> . </li><li>  Nous configurons le temps d'attente pour l'envoi d'un paquet de la puce √† l'h√¥te.  Par d√©faut, 16 ms, acc√©l√©rez √† 1 ms.  <code>FT_SetLatencyTimer</code> . </li><li>  Activez le contr√¥le de flux pour synchroniser les demandes entrantes.  <code>FT_SetFlowControl</code> . </li><li>  Tout est pr√™t pour activer le mode MPSSE.  R√©initialisez le contr√¥leur MPSSE.  Nous utilisons la fonction <code>FT_SetBitMode</code> , d√©finissons le mode sur 0 (mode = 0, masque = 0). </li><li>  Activez le mode MPSSE.  Fonction <code>FT_SetBitMode</code> - mode = 2, masque = 0. </li></ol><br><p>  Nous unissons et configurons la puce dans la fonction <code>MPSSE_open</code> , en param√®tre nous passons une ligne avec la poign√©e de l'appareil √† ouvrir: </p><br><div class="spoiler">  <b class="spoiler_title">Liste MPSSE_open</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_open</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *description)</span></span></span><span class="hljs-function"> </span></span>{ FT_STATUS ftStatus; ftStatus = FT_OpenEx(description, FT_OPEN_BY_DESCRIPTION, &amp;ftHandle); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ftStatus != FT_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"open failure\r\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FT_DEVICE_NOT_OPENED; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"open OK, %d\r\n"</span></span>, ftHandle); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nConfiguring port for MPSSE use...\n"</span></span>); ftStatus |= FT_ResetDevice(ftHandle); <span class="hljs-comment"><span class="hljs-comment">//Purge USB receive buffer first by reading out all old data from FT2232H receive buff: ftStatus |= FT_Purge(ftHandle, FT_PURGE_RX); //Set USB request transfer sizes to 64K: ftStatus |= FT_SetUSBParameters(ftHandle, 65536, 65536); //Disable event and error characters: ftStatus |= FT_SetChars(ftHandle, 0, 0, 0, 0); //Sets the read and write timeouts in milliseconds: ftStatus |= FT_SetTimeouts(ftHandle, 0, 5000); //Set the latency timer to 1mS (default is 16mS): ftStatus |= FT_SetLatencyTimer(ftHandle, 1); //Turn on flow control to synchronize IN requests: ftStatus |= FT_SetFlowControl(ftHandle, FT_FLOW_RTS_CTS, 0x00, 0x00); //Reset controller: ftStatus |= FT_SetBitMode(ftHandle, 0x0, FT_BITMODE_RESET); //Enable MPSSE mode: ftStatus |= FT_SetBitMode(ftHandle, 0x0, FT_BITMODE_MPSSE); if (ftStatus != FT_OK) { printf("Error in initializing the MPSSE %d\n", ftStatus); return FT_OTHER_ERROR; } Sleep(50); // Wait for all the USB stuff to complete and work return FT_OK; }</span></span></code> </pre> </div></div><br><h3 id="punkt-3-nastroim-rezhim-raboty-mpsee">  Point 3. Configurer le mode de fonctionnement MPSEE </h3><br><p>  En fait, √† ce stade, le processeur MPSSE est activ√© et pr√™t √† recevoir des commandes.  Les commandes sont des s√©quences d'octets, dont le premier est "op-code", suivies des param√®tres de commande.  La commande peut ne pas avoir de param√®tres et se composer d'un "code d'op√©ration".  Les commandes sont transmises √† l'aide de la fonction <code>FT_Write</code> , une r√©ponse du processeur MPSSE peut √™tre obtenue √† l'aide de la fonction <code>FT_Read</code> . </p><br><p>  Apr√®s chaque envoi de commande, il est utile de lire la r√©ponse du processeur, car en cas de commande incorrecte, la r√©ponse peut contenir un message d'erreur - le caract√®re 0xFA.  Le m√©canisme "mauvaise commande - r√©ponse 0xFA" peut √™tre utilis√© pour synchroniser le programme d'application avec le processeur MPSSE.  Si tout va bien, la puce renverra le caract√®re 0xFA sur une commande d√©lib√©r√©ment erron√©e.  Les codes d'op√©ration sont d√©crits dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Processeur de commande pour le mode d'√©mulation de bus h√¥te MPSSE et MCU</a> . <br>  La configuration de MPSSE revient √† d√©finir le d√©bit de donn√©es, la direction et les √©tats initiaux des lignes d'E / S. <br>  Pensez √† d√©finir le d√©bit de donn√©es du processeur MPSSE.  Les param√®tres des puces prenant en charge uniquement le mode pleine vitesse (FT2232 <strong>D</strong> ) et des puces √† haute vitesse (FT2232 <strong>H</strong> , FT232H, FT4232H) sont quelque peu diff√©rents.  Le FT2232D h√©rit√© utilise une horloge de 12 MHz, tandis que les mod√®les modernes utilisent 60 MHz.  D'o√π la formule de calcul du taux de transfert de donn√©es: </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>S</mi><mi>p</mi><mi>e</mi><mi>e</mi><mi>d</mi><mo>&amp;#x200B;</mo><mo>&amp;#x200B;</mo><mo>=</mo><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>f</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi></mrow></msub></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mi>d</mi><mi>i</mi><mi>v</mi><mi>i</mi><mi>s</mi><mi>e</mi><mi>u</mi><mi>r</mi><mo stretchy=&quot;false&quot;>)</mo><mtext>&amp;#xA0;</mtext><mi>c</mi><mi>d</mi><mi>o</mi><mi>t</mi><mn>2</mn></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="44.281ex" height="2.66ex" viewBox="0 -832 19065.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-44" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-61" x="828" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-74" x="1358" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-61" x="1719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-53" x="2249" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-70" x="2894" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-65" x="3398" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-65" x="3864" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-64" x="4331" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMAIN-3D" x="5187" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-66" x="6494" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-72" x="7044" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-61" x="7496" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-63" x="8025" y="0"></use><g transform="translate(8459,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-66" x="0" y="0"></use><g transform="translate(490,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-63" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-6F" x="433" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-72" x="919" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-65" x="1370" y="0"></use></g></g><g transform="translate(10348,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMAIN-31" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMAIN-2B" x="1112" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-64" x="2112" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-69" x="2636" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-76" x="2981" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-69" x="3467" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-73" x="3812" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-65" x="4282" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-75" x="4748" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-72" x="5321" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMAIN-29" x="5772" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-63" x="6412" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-64" x="6845" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-6F" x="7369" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMATHI-74" x="7854" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhvjsZ_wsewooAhmqYUFICP0Xlp3Q#MJMAIN-32" x="8216" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>S</mi><mi>p</mi><mi>e</mi><mi>e</mi><mi>d</mi><mo>‚Äã</mo><mo>‚Äã</mo><mo>=</mo><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><msub><mi>f</mi><mrow class="MJX-TeXAtom-ORD"><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi></mrow></msub></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>d</mi><mi>i</mi><mi>v</mi><mi>i</mi><mi>s</mi><mi>e</mi><mi>u</mi><mi>r</mi><mo stretchy="false">)</mo><mtext>&nbsp;</mtext><mi>c</mi><mi>d</mi><mi>o</mi><mi>t</mi><mn>2</mn></mrow></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> Data Speed ‚Äã‚Äã= \ frac {f_ {core}} {(1 + diviseur) \ cdot 2} </script></p><br><p>  o√π <em>f <sub>core</sub></em> est la fr√©quence du <em><sub>coeur</sub></em> FTDI, <em>Divisor</em> est un diviseur √† deux octets, qui, en fait, r√®gle la fr√©quence d'horloge des donn√©es. <br>  Par cons√©quent, si le diviseur est √©gal √† z√©ro, le taux de transfert de donn√©es maximal sera de 30 Mbps et le taux de transfert de donn√©es minimal sera au niveau d'un diviseur 65535 - 458 bit / s. <br>  Nous confierons le calcul du diviseur au pr√©processeur.  La macro renvoie le diviseur: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FCORE 60000000ul #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV(data_speed) ((FCORE/(2*data_speed)) -1)</span></span></code> </pre> <br><p>  Et ces deux macros renvoient respectivement les octets haut et bas du diviseur: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV_H(data_speed) ((MPSSE_DATA_SPEED_DIV(data_speed)) &gt;&gt; 8) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV_L(data_speed) \ (MPSSE_DATA_SPEED_DIV(data_speed) - (MPSSE_DATA_SPEED_DIV_H(data_speed)&lt;&lt; 8))</span></span></code> </pre> <br><p>  De plus, il convient de noter que dans les puces modernes pour la compatibilit√© avec l'ancien FT2232D, il existe un diviseur suppl√©mentaire de 5, qui transforme 60 MHz en 12 MHz.  Ce s√©parateur est activ√© par d√©faut, dans notre cas il doit √™tre d√©sactiv√©. <br>  On retrouve l'op-code correspondant (0x8A) et la commande casque au processeur: </p><br><div class="spoiler">  <b class="spoiler_title">Liste de soumission d'√©quipe</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], byInputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; DWORD dwNumBytesToRead, dwNumBytesSent = <span class="hljs-number"><span class="hljs-number">0</span></span>, dwNumBytesRead = <span class="hljs-number"><span class="hljs-number">0</span></span>; byOutputBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0x8A</span></span>; ftStatus = FT_Write(ftHandle, byOutputBuffer, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;dwNumBytesSent); Sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, byInputBuffer, dwNumBytesToRead, &amp;dwNumBytesRead); if (ftStatus != FT_OK) { printf("Error\r\n"); return FT_OTHER_ERROR; } else if (dwNumBytesToRead &gt; 0) { printf("dwNumBytesToRead = %d:", dwNumBytesToRead); for ( int i = 0; i &lt; dwNumBytesToRead; i++) printf (" %02Xh", byInputBuffer[i]); printf("\r\n"); return FT_INVALID_PARAMETER; } return FT_OK;</span></span></code> </pre> </div></div><br><p>  √Ä titre exp√©rimental, au lieu de la commande r√©elle 0x8A, nous enverrons la valeur 0xFE, qui ne correspond √† aucun op-code, la sortie de la console: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">dwNumBytesToRead</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>: FAh FEh</code> </pre> <br><p>  Le processeur a renvoy√© deux octets, le mauvais octet de commande est 0xFA et la valeur de cette mauvaise commande.  Ainsi, en envoyant plusieurs commandes √† la fois, nous pouvons non seulement suivre le fait de l'erreur elle-m√™me, mais √©galement comprendre sur quelle √©quipe cette erreur s'est produite. <br>  Afin de ne plus traiter les "nombres magiques" √† l'avenir, nous formaterons tous les codes op√©rationnels sous forme de constantes et les placerons dans un fichier d'en-t√™te s√©par√©. <br>  Pour configurer compl√®tement le mode, vous devez sp√©cifier la direction des lignes d'E / S et leur valeur par d√©faut.  Passons maintenant au sch√©ma de connexion.  Afin de ne pas encombrer un article d√©j√† gonfl√©, j'ai dessin√© un fragment int√©ressant du sch√©ma: </p><br><img width="500" src="https://habrastorage.org/webt/sc/6g/no/sc6gnoqy5_eyc5lsjpmlqbnl2-m.png"><br><p>  Les <em>lignes DCLK</em> , <em>DATA [0]</em> , <em>nCONFIG</em> doivent √™tre configur√©es comme sorties, les <em>lignes</em> <em>nSTATUS</em> , <em>CONF_DONE</em> comme entr√©es.  En utilisant le diagramme, nous d√©terminons quels √©tats initiaux les lignes devraient avoir.  Pour plus de clart√©, le brochage du circuit est r√©sum√© dans le tableau: </p><br><table><thead><tr><th>  Broche FPGA </th><th>  Nom de broche </th><th>  Pin </th><th>  MPSSE </th><th>  Direction </th><th>  d√©faut </th></tr></thead><tbody><tr><td>  DCLK </td><td>  BDBUS0 </td><td>  38 </td><td>  TCK / SK </td><td>  Out </td><td>  0 </td></tr><tr><td>  DONN√âES [0] </td><td>  BDBUS1 </td><td>  39 </td><td>  TDI / DO </td><td>  Out </td><td>  1 </td></tr><tr><td>  nCONFIG </td><td>  BDBUS2 </td><td>  40 </td><td>  TDO / DI </td><td>  Out </td><td>  1 </td></tr><tr><td>  nSTATUS </td><td>  BDBUS3 </td><td>  41 </td><td>  TMS / CS </td><td>  Dans </td><td>  1 </td></tr><tr><td>  CONF_DONE </td><td>  BDBUS4 </td><td>  43 </td><td>  GPIOL0 </td><td>  Dans </td><td>  1 </td></tr></tbody></table><br><p>  Toutes les lignes utilis√©es se trouvent sur l'octet bas du port MPSSE.  Pour d√©finir la valeur, utilisez le code op 0x80.  Cette commande suppose deux arguments: le premier octet suivant le code op est la valeur bit par bit, et le second est la direction (un est le port de sortie, z√©ro est le port d'entr√©e). <br>  Dans le cadre de la lutte contre le "num√©ro magique", tous les num√©ros de ligne s√©rie et leurs valeurs par d√©faut seront format√©s sous forme de constantes: </p><br><div class="spoiler">  <b class="spoiler_title">D√©finir les ports</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_DIRECTION (0x07) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DCLK (0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DATA0 (1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_CONFIG (2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_STATUS (3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONF_DONE (4) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// initial states of the MPSSE interface #define DCLK_DEF (1) #define DATA0_DEF (0) #define N_CONFIG_DEF (1) #define N_STATUS_DEF (1) #define CONF_DONE_DEF (1)</span></span></span></span></code> </pre> </div></div><br><p>  Il ne reste plus qu'√† s'assurer que la boucle TDI - TDO est d√©sactiv√©e (peut √™tre activ√©e pour les tests) et la mettre dans une fonction distincte: </p><br><div class="spoiler">  <b class="spoiler_title">Liste de la fonction MPSSE_setup</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_setup</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent, dwNumBytesToRead, dwNumBytesRead; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], byInputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; FT_STATUS ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Multple commands can be sent to the MPSSE with one FT_Write dwNumBytesToSend = 0; // Start with a fresh index byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_DIVIDER_5; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_ADAPTIVE_CLK; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_3PHASE_CLOCKING; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); dwNumBytesToSend = 0; // Reset output buffer pointer // Set TCK frequency // Command to set clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_TCK_DIVISION; // Set ValueL of clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_DATA_SPEED_DIV_L(DATA_SPEED); // Set 0xValueH of clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_DATA_SPEED_DIV_H(DATA_SPEED); ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); dwNumBytesToSend = 0; // Reset output buffer pointer // Set initial states of the MPSSE interface // - low byte, both pin directions and output values /* | FPGA pin | Pin Name | Pin | MPSSE | Dir | def | | --------- | -------- | --- | ------ | --- | --- | | DCLK | BDBUS0 | 38 | TCK/SK | Out | 0 | | DATA[0] | BDBUS1 | 39 | TDI/DO | Out | 1 | | nCONFIG | BDBUS2 | 40 | TDO/DI | Out | 1 | | nSTATUS | BDBUS3 | 41 | TMS/CS | In | 1 | | CONF_DONE | BDBUS4 | 43 | GPIOL0 | In | 1 | */ // Configure data bits low-byte of MPSSE port: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_LOWBYTE; // Initial state config above: byOutputBuffer[dwNumBytesToSend++] = (DCLK_DEF &lt;&lt; DCLK) | (DATA0_DEF &lt;&lt; DATA0) | (N_CONFIG_DEF &lt;&lt; N_CONFIG) | (N_STATUS_DEF &lt;&lt; N_STATUS) | (CONF_DONE_DEF &lt;&lt; CONF_DONE); // Direction config above: byOutputBuffer[dwNumBytesToSend++] = PORT_DIRECTION; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); // Send off the low GPIO config commands dwNumBytesToSend = 0; // Reset output buffer pointer // Set initial states of the MPSSE interface // - high byte, all input, Initial State -- 0. // Send off the high GPIO config commands: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_HIGHBYTE; byOutputBuffer[dwNumBytesToSend++] = 0x00; byOutputBuffer[dwNumBytesToSend++] = 0x00; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); // Disable loopback: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_LOOP_TDI_TDO; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); Sleep(2); // Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, byInputBuffer, dwNumBytesToRead, &amp;dwNumBytesRead); if (ftStatus != FT_OK) { printf("Unknown error in initializing the MPSSE\r\n"); return FT_OTHER_ERROR; } else if (dwNumBytesToRead &gt; 0) { printf("Error in initializing the MPSSE, bad code:\r\n"); for ( int i = 0; i &lt; dwNumBytesToRead; i++) printf (" %02Xh", byInputBuffer[i]); printf("\r\n"); return FT_INVALID_PARAMETER; } return FT_OK; }</span></span></code> </pre> </div></div><br><h3 id="punkt-4-realizuem-protokol-zagruzki">  Point 4. Nous impl√©mentons le protocole de chargement </h3><br><p>  Tout semble pr√™t pour des exp√©riences pratiques.  Tout d'abord, v√©rifiez que l'initialisation est effectu√©e correctement, dans le corps principal du programme, appelez <code>MPSSE_open()</code> et <code>MPSSE_setup()</code> , et avant de fermer le p√©riph√©rique ( <code>FT_Close</code> ), nous mettons un <code>getchar()</code> vide.  Ex√©cutez le programme et utilisez l'oscilloscope pour vous assurer que toutes les lignes PS sont d√©finies aux niveaux par d√©faut.  En modifiant la valeur de ces niveaux lors de l'initialisation (rien de mauvais ne se produira avec le FPGA), nous nous assurons que le processeur MPSSE donne le r√©sultat souhait√© comme valide - tout fonctionne correctement et vous pouvez proc√©der au transfert de donn√©es. <br>  L'envoi et la r√©ception s√©quentiels de donn√©es sont effectu√©s en mode commande en utilisant le m√™me code d'op√©ration.  Le premier octet de la commande est l'op-code, qui d√©termine le type d'op√©ration, suivi de la longueur de la s√©quence transmise ou re√ßue et, s'il s'agit d'une transmission, des donn√©es r√©elles.  Le processeur MPSSE peut envoyer et recevoir des donn√©es, √©galement en m√™me temps.  La transmission peut √™tre soit le bit le moins significatif en avant (LSB), soit le plus significatif (MSB).  La transmission de donn√©es peut se produire sur les fronts avant ou arri√®re des impulsions d'horloge.  Chaque combinaison d'options a son propre code d'op√©ration, chaque bit de code d'op√©ration d√©crit le mode de fonctionnement: </p><br><table><thead><tr><th>  Bit </th><th>  Fonction </th></tr></thead><tbody><tr><td>  0 </td><td>  Synchronisation en √©criture avant: 0 - positif, 1 - n√©gatif </td></tr><tr><td>  1 </td><td>  1 - travailler avec des octets, 0 - travailler avec des bits </td></tr><tr><td>  2 </td><td>  Bord avant pour la lecture: 0 - positif, 1 - n√©gatif </td></tr><tr><td>  3 </td><td>  Mode de transmission: 1 - LSB, 0 - MSB en premier </td></tr><tr><td>  4 </td><td>  Transmission de donn√©es TDI </td></tr><tr><td>  5 </td><td>  Lecture des donn√©es d'une ligne TDO </td></tr><tr><td>  6 </td><td>  Transmission de donn√©es TMS </td></tr><tr><td>  7 </td><td>  Doit √™tre 0, sinon c'est un autre groupe de commandes </td></tr></tbody></table><br><p>  Lors de la configuration des FPGA selon le sch√©ma PS, les donn√©es sont transmises sur le front montant en mode LSB.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est plus pratique pour nous d‚Äôutiliser des octets plut√¥t que des bits, auquel cas le code d‚Äôop√©ration prendra la valeur 0001_1000b ou 0x18 en repr√©sentation hexad√©cimale. </font><font style="vertical-align: inherit;">Les arguments de la commande seront la longueur de la s√©quence transmise (deux octets, en commen√ßant par le moins significatif) et la s√©quence de donn√©es elle-m√™me. </font><font style="vertical-align: inherit;">Une petite caract√©ristique doit √™tre prise en compte: la longueur est cod√©e moins un. </font><font style="vertical-align: inherit;">Autrement dit, si nous voulons envoyer un octet, alors la longueur sera 0, si nous voulons envoyer 65536, alors nous devons sp√©cifier la longueur de 65535. Je pense qu'il est clair pourquoi cela est fait. </font><font style="vertical-align: inherit;">Envoyons le bloc de donn√©es en tant que fonction </font></font><code>MPSSE_send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></p><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste de la fonction MPSSE_send</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> BYTE byBuffer[<span class="hljs-number"><span class="hljs-number">65536</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE * buff, DWORD dwBytesToWrite)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend = <span class="hljs-number"><span class="hljs-number">0</span></span>, dwNumBytesSent, bytes; FT_STATUS ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Output on rising clock, no input // MSB first, clock a number of bytes out byBuffer[dwNumBytesToSend++] = MPSSE_CMD_LSB_DATA_OUT_BYTES_POS_EDGE; // 0x18 bytes = dwBytesToWrite -1; byBuffer[dwNumBytesToSend++] = (bytes) &amp; 0xFF; // Length L byBuffer[dwNumBytesToSend++] = (bytes &gt;&gt; 8) &amp; 0xFF; // Length H memcpy(&amp;byBuffer[dwNumBytesToSend], buff, dwBytesToWrite); dwNumBytesToSend += dwBytesToWrite; ftStatus = FT_Write(ftHandle, byBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); if (ftStatus != FT_OK ) { printf ("ERROR send data\r\n"); return ftStatus; } else if (dwNumBytesSent != dwNumBytesToSend) { printf ("ERROR send data, %d %d\r\n", dwNumBytesSent, dwNumBytesToSend); } return FT_OK; }</span></span></code> </pre> </div></div><br><p>        ‚Äî      65 ,   - ,        op-code   .   <code>byBuffer</code> ,             <code>buff</code> ,  ,      op-code  .    ,     ,         . <br>    ,        ""  ,       25 , ,  ,     1  ( ,     <code>#define DATA_SPEED 1000000ul</code> ).   : </p><br><pre> <code class="hljs objectivec">BYTE byOutputBuffer[] = {<span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x1B</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">MPSSE_send</span></span>(byOutputBuffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(byOutputBuffer));</code> </pre> <br><p>    ( ): <br> <a href=""><img src="https://habrastorage.org/webt/bp/gp/es/bpgpesvsoradzqfecft07bdjk-u.png"></a> </p><br><p>   ‚Äî    <em>DATA[0]</em> ,   ‚Äî <em>DCLK</em> .             .  ,  ,   . </p><br><p>      ,     SPI  ( ).  ,     PS,     .   <em>nCONFIG</em> , <em>nSTATUS</em> , <em>CONF_DONE</em> .   ‚Äî  ,      ,   ‚Äî ,     . </p><br><p>  <code>MPSSE_get_lbyte</code>    ,  ,         . </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_get_lbyte</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_get_lbyte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE *lbyte)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent, dwNumBytesToRead, dwNumBytesRead; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; FT_STATUS ftStatus; dwNumBytesToSend = <span class="hljs-number"><span class="hljs-number">0</span></span>; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_GET_DATA_BITS_LOWBYTE; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); Sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, lbyte, dwNumBytesToRead, &amp;dwNumBytesRead); if ((ftStatus != FT_OK) &amp; (dwNumBytesToRead != 1)) { printf("Error read Lbyte\r\n"); return FT_OTHER_ERROR; // Exit with error } return FT_OK; }</span></span></code> </pre> </div></div><br><p>  ,  op-code  ,         . ,     -     ,    ,          .    ,   .     <code>MPSSE_set_lbyte</code> : </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_set_lbyte</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_set_lbyte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE lb, BYTE mask)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], lbyte; FT_STATUS ftStatus; ftStatus = MPSSE_get_lbyte(&amp;lbyte); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ftStatus != FT_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Set to zero the bits selected by the mask: lbyte &amp;= ~mask; // Setting zero is not selected by the mask bits: lb &amp;= mask; lbyte |= lb; dwNumBytesToSend = 0; // Set data bits low-byte of MPSSE port: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_LOWBYTE; byOutputBuffer[dwNumBytesToSend++] = lbyte; byOutputBuffer[dwNumBytesToSend++] = PORT_DIRECTION; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); if ((ftStatus != FT_OK) &amp; (dwNumBytesSent != 1)) { printf("Error set Lbyte\r\n"); return FT_OTHER_ERROR; } return FT_OK; }</span></span></code> </pre> </div></div><br><p>   ,     .   :  FTDI;    MPSSE;  rbf-  ,    <em>nCONFIG</em>  ,      <em>N_STATUS</em> ;    rbf-    ;  ,    ,      <em>CONF_DONE</em> .     ,     MPSSE   FTDI       .   ,  <em>nCONFIG</em>      ""  ,     ,        ,     . </p><br><div class="spoiler"> <b class="spoiler_title">  main</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ FT_STATUS ftStatus; BYTE lowByte; DWORD numDevs; <span class="hljs-comment"><span class="hljs-comment">// create the device information list if ( argv[1] == NULL) { printf ("NO file\r\n"); return -1; } frbf = fopen(argv[1],"rb"); if (frbf == NULL) { printf ("Error open rbf\r\n"); return -1; } ftStatus = FT_CreateDeviceInfoList(&amp;numDevs); if ((numDevs == 0) || (ftStatus != FT_OK)) { printf("Error. FTDI devices not found in the system\r\n"); return -1; } ftStatus = MPSSE_open ("LESO7 B"); if (ftStatus != FT_OK) { printf("Error in MPSSE_open %d\n", ftStatus); EXIT(-1); } MPSSE_setup(); if (ftStatus != FT_OK) { printf("Error in MPSSE_setup %d\n", ftStatus); EXIT(-1); } printf ("nConfig -&gt; 0\r\n"); MPSSE_set_lbyte(0, 1 &lt;&lt; N_CONFIG); printf ("nConfig -&gt; 1\r\n"); MPSSE_set_lbyte(1 &lt;&lt; N_CONFIG, 1 &lt;&lt; N_CONFIG); if (MPSSE_get_lbyte(&amp;lowByte) != FT_OK) { EXIT(-1); } if (((lowByte &gt;&gt; N_STATUS) &amp; 1) == 0) { printf("Error. FPGA is not responding\r\n"); EXIT(-1); } int i = 0; size_t readBytes = 0; // Send the configuration file: do { readBytes = fread(buff, 1, MPSSE_PCK_SEND_SIZE, frbf); if (MPSSE_send(buff, readBytes) != FT_OK) EXIT(-1); putchar('*'); if (!((++i)%16)) printf("\r\n"); } while (readBytes == MPSSE_PCK_SEND_SIZE); printf("\r\n"); memset(buff, 0x00, sizeof(buff)); MPSSE_send(buff, 1); //        ? printf("Load complete\r\n"); // wait CONF_DONE set // A low-to-high transition on the CONF_DONE pin indicates that the configuration is // complete and initialization of the device can begin. i = 0; do { if (MPSSE_get_lbyte(&amp;lowByte) != FT_OK) { printf ("Error read CONF_DONE\r\n"); EXIT(-1); } if (i++ &gt; TIMEOUT_CONF_DONE) { printf ("Error CONF_DONE\r\n"); EXIT(-1); } Sleep(2); } while (((lowByte &gt;&gt; CONF_DONE) &amp; 1) == 0); printf("Configuration complete\r\n"); FT_Close(ftHandle); fclose(frbf); }</span></span></code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exemple de d√©marrage d'un programme: </font></font></p><br><pre> <code class="hljs pgsql">pen "LESO7 B" OK nConfig -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> nConfig -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ** <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> complete <span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span> complete</code> </pre> </div></div><br><p>    rbf-  .    .       30 /     . <br>      ,        -  JTAG. </p><br><h3 id="materialy-po-teme">    </h3><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FTDI-MPSSE-Altera PS</a> .   . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a> .   .       . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Software Application Development D2XX Programmer's Guide</a> .        FTDI.   API D2XX. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FTDI MPSSE Basics. Application Note AN_135</a> .    .  FTDI MPSSE.      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Command Processor for MPSSE and MCU Host Bus Emulation Modes. Application Note AN_108</a> .   op-code.   . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D2XX Drivers</a> .  FTDI. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426131/">https://habr.com/ru/post/fr426131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426117/index.html">Le M√©diateur propose de bloquer les publicit√©s contenant des produits pour b√©b√©s potentiellement dangereux</a></li>
<li><a href="../fr426119/index.html">Antiquit√©s: Cryptonomicon Iron</a></li>
<li><a href="../fr426121/index.html">MC.exe (compilateur de messages), rc.exe, link.exe pour g√©n√©rer .dll pour EventMessageFile</a></li>
<li><a href="../fr426123/index.html">Apprenez OpenGL. Le√ßon 6.1. PBR ou rendu physiquement correct. Th√©orie</a></li>
<li><a href="../fr426125/index.html">St√©ro√Ødes de carri√®re. Ascenseurs</a></li>
<li><a href="../fr426133/index.html">Pr√©sentation de la version alpha des instantan√©s de volume dans Kubernetes</a></li>
<li><a href="../fr426135/index.html">Cloud priv√© pour l'Internet des objets</a></li>
<li><a href="../fr426137/index.html">√Çge d'honn√™tet√©</a></li>
<li><a href="../fr426141/index.html">Red Hat remplace Docker par Podman</a></li>
<li><a href="../fr426143/index.html">Animation 3D - vid√©o ou interactive?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>