<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö†Ô∏è üèê üè≥Ô∏è Python consomme beaucoup de m√©moire ou comment r√©duire la taille des objets? üà∑Ô∏è ü§º üë©‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Un probl√®me de m√©moire peut survenir lorsqu'un grand nombre d'objets sont actifs dans la RAM pendant l'ex√©cution d'un programme, en particulier s'il e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python consomme beaucoup de m√©moire ou comment r√©duire la taille des objets?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458518/"><p>  Un probl√®me de m√©moire peut survenir lorsqu'un grand nombre d'objets sont actifs dans la RAM pendant l'ex√©cution d'un programme, en particulier s'il existe des restrictions sur la quantit√© totale de m√©moire disponible. </p><br><p>  Vous trouverez ci-dessous un aper√ßu de certaines m√©thodes de r√©duction de la taille des objets, ce qui peut r√©duire consid√©rablement la quantit√© de RAM n√©cessaire pour les programmes en Python pur. </p><br><p>  <strong>Remarque:</strong> <em>il s'agit de la version anglaise de mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">message d'</a> origine (en russe).</em> </p><a name="habracut"></a><br><p> Pour simplifier, nous consid√©rerons les structures en Python pour repr√©senter des points avec les coordonn√©es <code>x</code> , <code>y</code> , <code>z</code> avec acc√®s aux valeurs de coordonn√©es par leur nom. </p><br><h3 id="dict">  Dict </h3><br><p>  Dans les petits programmes, en particulier dans les scripts, il est assez simple et pratique d'utiliser le <code>dict</code> int√©gr√© pour repr√©senter les informations structurelles: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = {'x':1, 'y':2, 'z':3} &gt;&gt;&gt; x = ob['x'] &gt;&gt;&gt; ob['y'] = y</code> </pre> <br><p>  Avec l'av√®nement d'une impl√©mentation plus compacte en Python 3.6 avec un ensemble ordonn√© de cl√©s, <code>dict</code> est devenu encore plus attrayant.  Cependant, regardons la taille de son empreinte en RAM: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob)) 240</code> </pre> <br><p>  Cela prend beaucoup de m√©moire, surtout si vous devez soudainement cr√©er un grand nombre d'instances: </p><br><div class="scrollable-table"><table><thead><tr><th>  Nombre d'instances </th><th>  Taille des objets </th></tr></thead><tbody><tr><td>  1 000 000 </td><td>  240 Mo </td></tr><tr><td>  10 000 000 </td><td>  2,40 Go </td></tr><tr><td>  100 000 000 </td><td>  24 Go </td></tr></tbody></table></div><br><h3 id="class-instance">  Instance de classe </h3><br><p>  Pour ceux qui aiment tout habiller en classes, il est pr√©f√©rable de d√©finir les structures comme une classe avec acc√®s par nom d'attribut: </p><br><pre> <code class="plaintext hljs">class Point: # def __init__(self, x, y, z): self.x = x self.y = y self.z = z &gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; x = ob.x &gt;&gt;&gt; ob.y = y</code> </pre> <br><p>  La structure de l'instance de classe est int√©ressante: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Champ </th><th>  Taille (octets) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  __weakref__ </td><td>  8 </td></tr><tr><td>  __dict__ </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>56</b> </td></tr></tbody></table></div><br><p>  Ici, <code>__weakref__</code> est une r√©f√©rence √† la liste des soi-disant r√©f√©rences faibles √† cet objet, le champ <code>__dict__</code> est une r√©f√©rence au dictionnaire d'instance de classe, qui contient les valeurs des attributs d'instance (notez que la plate-forme de r√©f√©rences 64 bits occupe 8 octets).  √Ä partir de Python 3.3, l'espace partag√© est utilis√© pour stocker des cl√©s dans le dictionnaire pour toutes les instances de la classe.  Cela r√©duit la taille de la trace d'instance dans la RAM: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob), sys.getsizeof(ob.__dict__)) 56 112</code> </pre> <br><p>  Par cons√©quent, un grand nombre d'instances de classe ont une plus petite empreinte en m√©moire qu'un dictionnaire standard ( <code>dict</code> ): </p><br><div class="scrollable-table"><table><thead><tr><th>  Nombre d'instances </th><th>  La taille </th></tr></thead><tbody><tr><td>  1 000 000 </td><td>  168 Mo </td></tr><tr><td>  10 000 000 </td><td>  1,68 Go </td></tr><tr><td>  100 000 000 </td><td>  16,8 Go </td></tr></tbody></table></div><br><p>  Il est facile de voir que la taille de l'instance en RAM est toujours importante en raison de la taille du dictionnaire de l'instance. </p><br><h3 id="instance-of-class-with--__slots__">  Instance de classe avec __slots__ </h3><br><p>  Une r√©duction significative de la taille d'une instance de classe en RAM est obtenue en √©liminant <code>__dict__</code> et <code>__weakref__</code> .  Ceci est possible √† l'aide d'une "astuce" avec <code>__slots__</code> : </p><br><pre> <code class="plaintext hljs">class Point: __slots__ = 'x', 'y', 'z' def __init__(self, x, y, z): self.x = x self.y = y self.z = z &gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 64</code> </pre> <br><p>  La taille de l'objet dans la RAM est devenue beaucoup plus petite: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Champ </th><th>  Taille (octets) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  z </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>64</b> </td></tr></tbody></table></div><br><p>  L'utilisation de <code>__slots__</code> dans la d√©finition de classe r√©duit consid√©rablement l'encombrement d'un grand nombre d'instances en m√©moire: </p><br><div class="scrollable-table"><table><thead><tr><th>  Nombre d'instances </th><th>  La taille </th></tr></thead><tbody><tr><td>  1 000 000 </td><td>  64 Mo </td></tr><tr><td>  10 000 000 </td><td>  640 Mo </td></tr><tr><td>  100 000 000 </td><td>  6,4 Go </td></tr></tbody></table></div><br><p>  Actuellement, il s'agit de la principale m√©thode de r√©duction substantielle de l'empreinte m√©moire d'une instance d'une classe en RAM. </p><br><p>  Cette r√©duction est obtenue par le fait que dans la m√©moire apr√®s le titre de l'objet, les r√©f√©rences d'objet sont stock√©es - les valeurs d'attribut, et leur acc√®s est effectu√© √† l'aide de descripteurs sp√©ciaux qui se trouvent dans le dictionnaire de classe: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; pprint(Point.__dict__) mappingproxy( .................................... 'x': &lt;member 'x' of 'Point' objects&gt;, 'y': &lt;member 'y' of 'Point' objects&gt;, 'z': &lt;member 'z' of 'Point' objects&gt;})</code> </pre> <br><p>  Pour automatiser le processus de cr√©ation d'une classe avec <code>__slots__</code> , il existe une biblioth√®que [namedlist] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://pypi.org/project/namedlist</a> ).  La fonction <code>namedlist.namedlist</code> cr√©e une classe avec <code>__slots__</code> : </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = namedlist('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Un autre package [attrs] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://pypi.org/project/attrs</a> ) vous permet d'automatiser le processus de cr√©ation de classes avec et sans <code>__slots__</code> . </p><br><h3 id="tuple">  Tuple </h3><br><p>  Python poss√®de √©galement un <code>tuple</code> type int√©gr√© pour repr√©senter les structures de donn√©es immuables.  Un tuple est une structure ou un enregistrement fixe, mais sans nom de champ.  Pour l'acc√®s aux champs, l'index des champs est utilis√©.  Les champs de tuple sont une fois pour toutes associ√©s aux objets valeur au moment de la cr√©ation de l'instance de tuple: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = (1,2,3) &gt;&gt;&gt; x = ob[0] &gt;&gt;&gt; ob[1] = y # ERROR</code> </pre> <br><p>  Les instances de tuple sont assez compactes: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob)) 72</code> </pre> <br><p>  Ils occupent 8 octets en m√©moire de plus que les instances de classes avec <code>__slots__</code> , car la trace de tuple en m√©moire contient √©galement un certain nombre de champs: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Champ </th><th>  Taille (octets) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  ob_size </td><td>  8 </td></tr><tr><td>  [0] </td><td>  8 </td></tr><tr><td>  [1] </td><td>  8 </td></tr><tr><td>  [2] </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>72</b> </td></tr></tbody></table></div><br><h3 id="namedtuple">  Namedtuple </h3><br><p>  √âtant donn√© que le tuple est tr√®s largement utilis√©, un jour, il a √©t√© demand√© que vous puissiez toujours acc√©der aux champs et par nom √©galement.  La r√©ponse √† cette demande a √©t√© le module <code>collections.namedtuple</code> . </p><br><p>  La fonction <code>namedtuple</code> est con√ßue pour automatiser le processus de g√©n√©ration de ces classes: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = namedtuple('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Il cr√©e une sous-classe de tuple, dans laquelle des descripteurs sont d√©finis pour acc√©der aux champs par leur nom.  Pour notre exemple, cela ressemblerait √† ceci: </p><br><pre> <code class="plaintext hljs"> class Point(tuple): # @property def _get_x(self): return self[0] @property def _get_y(self): return self[1] @property def _get_z(self): return self[2] # def __new__(cls, x, y, z): return tuple.__new__(cls, (x, y, z))</code> </pre> <br><p>  Toutes les instances de ces classes ont une empreinte m√©moire identique √† celle d'un tuple.  Un grand nombre d'instances laisse une empreinte m√©moire l√©g√®rement plus grande: </p><br><div class="scrollable-table"><table><thead><tr><th>  Nombre d'instances </th><th>  La taille </th></tr></thead><tbody><tr><td>  1 000 000 </td><td>  72 Mo </td></tr><tr><td>  10 000 000 </td><td>  720 Mo </td></tr><tr><td>  100 000 000 </td><td>  7,2 Go </td></tr></tbody></table></div><br><h3 id="recordclass-mutable-namedtuple-without-cyclic-gc">  Recordclass: mutable nomm√© tuple sans GC cyclique </h3><br><p>  √âtant donn√© que le <code>tuple</code> et, par cons√©quent, les classes <code>namedtuple</code> g√©n√®rent des objets immuables dans le sens o√π l'attribut <code>ob.x</code> ne peut plus √™tre associ√© √† un autre objet de valeur, une demande pour une variante mutable namedtuple est apparue.  Puisqu'il n'y a pas de type int√©gr√© en Python qui soit identique au tuple qui prend en charge les affectations, de nombreuses options ont √©t√© cr√©√©es.  Nous nous concentrerons sur [recordclass] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://pypi.org/project/recordclass</a> ), qui a re√ßu une note de [stackoverflow] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://stackoverflow.com/questions/29290359/existence-of-mutable-named- tuple-in</a> -python / 29419745).  De plus, il peut √™tre utilis√© pour r√©duire la taille des objets en RAM par rapport √† la taille des objets de type <code>tuple</code> . </p><br><p>  Le package <strong>recordclass</strong> introduit le type <code>recordclass.mutabletuple</code> , qui est presque identique au tuple, mais prend √©galement en charge les affectations.  Sur sa base, des sous-classes sont cr√©√©es qui sont presque compl√®tement identiques aux couples nomm√©s, mais prennent √©galement en charge l'affectation de nouvelles valeurs aux champs (sans cr√©er de nouvelles instances).  La fonction <code>recordclass</code> , comme la fonction <code>namedtuple</code> , vous permet d'automatiser la cr√©ation de ces classes: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; Point = recordclass('Point', ('x', 'y', 'z')) &gt;&gt;&gt; ob = Point(1, 2, 3)</code> </pre> <br><p>  Les instances de classe ont la m√™me structure que <code>tuple</code> , mais uniquement sans <code>PyGC_Head</code> : </p><br><div class="scrollable-table"><table><tbody><tr><th>  Champ </th><th>  Taille (octets) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  ob_size </td><td>  8 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>48</b> </td></tr></tbody></table></div><br><p>  Par d√©faut, la fonction <code>recordclass</code> cr√©e une classe qui ne participe pas au m√©canisme de r√©cup√©ration de place cyclique.  En r√®gle g√©n√©rale, <code>namedtuple</code> et <code>recordclass</code> sont utilis√©s pour g√©n√©rer des classes repr√©sentant des enregistrements ou des structures de donn√©es simples (non r√©cursives).  Les utiliser correctement en Python ne g√©n√®re pas de r√©f√©rences circulaires.  Pour cette raison, dans le sillage des instances de classes g√©n√©r√©es par <code>recordclass</code> , par <code>default, the</code> <code>fragment is excluded, which is necessary for classes supporting the cyclic garbage collection mechanism (more precisely: in the</code> PyGC_Head <code>fragment is excluded, which is necessary for classes supporting the cyclic garbage collection mechanism (more precisely: in the</code> <code>structure, corresponding to the created class, in the</code> PyTypeObject <code>structure, corresponding to the created class, in the</code> <code>field, by default, the flag</code> drapeaux <code>field, by default, the flag</code> Py_TPFLAGS_HAVE_GC` n'est pas d√©fini). </p><br><p>  La taille de l'empreinte m√©moire d'un grand nombre d'instances est inf√©rieure √† celle des instances de la classe avec <code>__slots__</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Nombre d'instances </th><th>  La taille </th></tr></thead><tbody><tr><td>  1 000 000 </td><td>  48 Mo </td></tr><tr><td>  10 000 000 </td><td>  480 Mo </td></tr><tr><td>  100 000 000 </td><td>  4,8 Go </td></tr></tbody></table></div><br><h3 id="dataobject">  Dataobject </h3><br><p>  Une autre solution propos√©e dans la biblioth√®que recordclass est bas√©e sur l'id√©e: utiliser la m√™me structure de stockage en m√©moire que dans les instances de classe avec <code>__slots__</code> , mais ne pas participer au m√©canisme cyclique de r√©cup√©ration de place.  Ces classes sont g√©n√©r√©es √† l'aide de la fonction <code>recordclass.make_dataclass</code> : </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; Point = make_dataclass('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  La classe ainsi cr√©√©e, par d√©faut, cr√©e des instances mutables. </p><br><p>  Une autre fa√ßon - utilisez la d√©claration de classe avec l'h√©ritage de <code>recordclass.dataobject</code> : </p><br><pre> <code class="plaintext hljs">class Point(dataobject): x:int y:int z:int</code> </pre> <br><p>  Les classes cr√©√©es de cette mani√®re cr√©eront des instances qui ne participent pas au m√©canisme de collecte de d√©chets cyclique.  La structure de l'instance en m√©moire est la m√™me que dans le cas avec <code>__slots__</code> , mais sans <code>PyGC_Head</code> : </p><br><div class="scrollable-table"><table><tbody><tr><th>  Champ </th><th>  Taille (octets) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>40</b> </td></tr></tbody></table></div><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 40</code> </pre> <br><p>  Pour acc√©der aux champs, des descripteurs sp√©ciaux sont √©galement utilis√©s pour acc√©der au champ par son d√©calage par rapport au d√©but de l'objet, qui se trouvent dans le dictionnaire de classe: </p><br><pre> <code class="plaintext hljs">mappingproxy({'__new__': &lt;staticmethod at 0x7f203c4e6be0&gt;, ....................................... 'x': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c690&gt;, 'y': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c670&gt;, 'z': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c410&gt;})</code> </pre> <br><p>  La taille de l'empreinte m√©moire d'un grand nombre d'instances est le minimum possible pour CPython: </p><br><div class="scrollable-table"><table><thead><tr><th>  Nombre d'instances </th><th>  La taille </th></tr></thead><tbody><tr><td>  1 000 000 </td><td>  40 Mo </td></tr><tr><td>  10 000 000 </td><td>  400 Mo </td></tr><tr><td>  100 000 000 </td><td>  4,0 Go </td></tr></tbody></table></div><br><h3 id="cython">  Cython </h3><br><p>  Il existe une approche bas√©e sur l'utilisation de [Cython] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://cython.org</a> ).  Son avantage est que les champs peuvent prendre les valeurs des types atomiques du langage C.  Des descripteurs pour acc√©der aux champs √† partir de Python pur sont cr√©√©s automatiquement.  Par exemple: </p><br><pre> <code class="plaintext hljs">cdef class Python: cdef public int x, y, z def __init__(self, x, y, z): self.x = x self.y = y self.z = z</code> </pre> <br><p>  Dans ce cas, les instances ont une taille de m√©moire encore plus petite: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 32</code> </pre> <br><p>  La trace d'instance en m√©moire a la structure suivante: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Champ </th><th>  Taille (octets) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  4 </td></tr><tr><td>  y </td><td>  4 </td></tr><tr><td>  y </td><td>  4 </td></tr><tr><td>  est vide </td><td>  4 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>32</b> </td></tr></tbody></table></div><br><p>  La taille de l'empreinte d'un grand nombre de copies est moindre: </p><br><div class="scrollable-table"><table><thead><tr><th>  Num√©ro </th><th>  La taille </th></tr></thead><tbody><tr><td>  1 000 000 </td><td>  32 Mo </td></tr><tr><td>  10 000 000 </td><td>  320 Mo </td></tr><tr><td>  100 000 000 </td><td>  3,2 Go </td></tr></tbody></table></div><br><p>  Cependant, il faut se rappeler que lors de l'acc√®s √† partir du code Python, une conversion de <code>int</code> en objet Python et vice versa sera effectu√©e √† chaque fois. </p><br><h3 id="numpy">  Numpy </h3><br><p>  L'utilisation de tableaux multidimensionnels ou de tableaux d'enregistrements pour une grande quantit√© de donn√©es donne un gain de m√©moire.  Cependant, pour un traitement efficace en Python pur, vous devez utiliser des m√©thodes de traitement qui se concentrent sur l'utilisation des fonctions du package <code>numpy</code> . </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = numpy.dtype(('x', numpy.int32), ('y', numpy.int32), ('z', numpy.int32)])</code> </pre> <br><p>  Un tableau de <code>N</code> √©l√©ments, initialis√© avec des z√©ros, est cr√©√© √† l'aide de la fonction: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; points = numpy.zeros(N, dtype=Point)</code> </pre> <br><p>  La taille du tableau en m√©moire est le minimum possible: </p><br><div class="scrollable-table"><table><thead><tr><th>  Nombre d'objets </th><th>  La taille </th></tr></thead><tbody><tr><td>  1 000 000 </td><td>  12 Mo </td></tr><tr><td>  10 000 000 </td><td>  120 Mo </td></tr><tr><td>  100 000 000 </td><td>  1,20 Go </td></tr></tbody></table></div><br><p>  L'acc√®s normal aux √©l√©ments et aux lignes du tableau n√©cessitera la conversion d'un objet Python en une valeur C <code>int</code> et vice versa.  L'extraction d'une seule ligne entra√Æne la cr√©ation d'un tableau contenant un seul √©l√©ment.  Sa trace ne sera plus aussi compacte: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; sys.getsizeof(points[0]) 68</code> </pre> <br><p>  Par cons√©quent, comme indiqu√© ci-dessus, dans le code Python, il est n√©cessaire de traiter les tableaux √† l'aide des fonctions du package <code>numpy</code> . </p><br><h3 id="conclusion">  Conclusion </h3><br><p>  Sur un exemple clair et simple, il a √©t√© possible de v√©rifier que la communaut√© de d√©veloppeurs et d'utilisateurs du langage de programmation Python (CPython) a de r√©elles possibilit√©s pour une r√©duction significative de la quantit√© de m√©moire utilis√©e par les objets. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458518/">https://habr.com/ru/post/fr458518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458504/index.html">13 astuces pour gagner du temps</a></li>
<li><a href="../fr458506/index.html">Pas Portal 3, mais close: t√©l√©portation quantique d'informations √† l'int√©rieur d'un diamant</a></li>
<li><a href="../fr458508/index.html">Un regard int√©rieur: √©cole doctorale √† l'EPFL. Partie 4.2: l'aspect financier</a></li>
<li><a href="../fr458514/index.html">La violation du RGPD est punie plus activement - de nouvelles amendes et l'impact des r√©glementations en dehors de l'UE</a></li>
<li><a href="../fr458516/index.html">Obtenez un journal de travail de Jira</a></li>
<li><a href="../fr458520/index.html">Le livre "Code haute performance sur la plateforme .NET. 2e √©dition</a></li>
<li><a href="../fr458524/index.html">Nuage de mots VC sur le genou</a></li>
<li><a href="../fr458530/index.html">Zabbix, s√©ries chronologiques et TimescaleDB</a></li>
<li><a href="../fr458532/index.html">Pionniers des nouvelles technologies: Vadim Artsev a racont√© comment il avait cess√© d'√™tre aveugle</a></li>
<li><a href="../fr458536/index.html">Python + Pyside2 ou simplement ¬´Calculatrice¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>