<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüéì ü¶ñ üë®üèª‚Äçüè≠ Funktionsweise von JS: Abstrakte Syntaxb√§ume, Analyse und deren Optimierung ‚òùüèº üåæ üèä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Lesen empfehlen] Die anderen 19 Teile des Zyklus  Teil 1: √úberblick √ºber die Engine, Laufzeitmechanismen, Aufrufstapel 
 Teil 2: Informationen zu V8-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionsweise von JS: Abstrakte Syntaxb√§ume, Analyse und deren Optimierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415269/"><div class="spoiler">  <b class="spoiler_title">[Lesen empfehlen] Die anderen 19 Teile des Zyklus</b> <div class="spoiler_text">  Teil 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberblick √ºber die Engine, Laufzeitmechanismen, Aufrufstapel</a> <br>  Teil 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu V8-Interna und Codeoptimierung</a> <br>  Teil 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwalten des Speichers, vier Arten von Speicherlecks und Umgang mit ihnen</a> <br>  Teil 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisschleife, Async und f√ºnf M√∂glichkeiten zur Verbesserung Ihres Codes mit Async / Warten</a> <br>  Teil 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebSocket und HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was soll ich w√§hlen?</a> <br>  Teil 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen und Umfang von WebAssembly</a> <br>  Teil 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web Worker und f√ºnf Nutzungsszenarien</a> <br>  Teil 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Servicemitarbeiter</a> <br>  Teil 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web-Push-Benachrichtigungen</a> <br>  Teil 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verfolgen Sie √Ñnderungen im DOM mit MutationObserver</a> <br>  Teil 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendering-Engines f√ºr Webseiten und Tipps zur Optimierung ihrer Leistung</a> <br>  Teil 12: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerksubsystem von Browsern, um dessen Leistung und Sicherheit zu optimieren</a> <br>  Teil 12: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerksubsystem von Browsern, um dessen Leistung und Sicherheit zu optimieren</a> <br>  Teil 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Animation mit CSS und JavaScript</a> <br>  Teil 14: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Abstrakte Syntaxb√§ume, Analyse und deren Optimierung</a> <br>  Teil 15: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Klassen und Vererbung, Transpilation in Babel und TypeScript</a> <br>  Teil 16: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Speicher</a> <br>  Teil 17: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Shadow DOM-Technologie und Webkomponenten</a> <br>  Teil 18: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: WebRTC- und P2P-Kommunikationsmechanismen</a> <br>  Teil 19: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Benutzerdefinierte Elemente</a> </div></div><br>  Wir alle wissen, dass der JavaScript-Code f√ºr Webprojekte sehr gro√ü werden kann.  Und je gr√∂√üer der Code, desto l√§nger l√§dt der Browser ihn.  Das Problem liegt hier aber nicht nur in der Zeit der Daten√ºbertragung √ºber das Netzwerk.  Nachdem das Programm geladen wurde, muss es noch analysiert, in Bytecode kompiliert und schlie√ülich ausgef√ºhrt werden.  Heute machen wir Sie auf eine √úbersetzung von Teil 14 der JavaScript-√ñkosystemreihe aufmerksam.  Wir werden n√§mlich √ºber das Parsen von JS-Code sprechen, wie abstrakte Syntaxb√§ume erstellt werden und wie ein Programmierer diese Prozesse beeinflussen kann, um die Geschwindigkeit ihrer Anwendungen zu erh√∂hen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/68b/b2c/231/68bb2c231dd5b82bd35e97ceb36becef.jpg" alt="Bild"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Wie sind Programmiersprachen?</font> </h2><br>  Bevor wir uns mit abstrakten Syntaxb√§umen befassen, wollen wir uns mit der Funktionsweise von Programmiersprachen befassen.  Unabh√§ngig davon, welche Sprache Sie verwenden, m√ºssen Sie immer bestimmte Programme verwenden, die den Quellcode in etwas konvertieren, das bestimmte Befehle f√ºr die Maschinen enth√§lt.  Entweder Interpreter oder Compiler fungieren als solche Programme.  Es spielt keine Rolle, ob Sie in einer interpretierten Sprache (JavaScript, Python, Ruby) oder kompiliert (C #, Java, Rust) schreiben. Ihr Code, bei dem es sich um einfachen Text handelt, durchl√§uft immer die Analysephase, dh, einfacher Text wird in eine Datenstruktur umgewandelt wird als Abstract Syntax Tree (AST) bezeichnet. <br><br>  Abstrakte Syntaxb√§ume bieten nicht nur eine strukturierte Darstellung des Quellcodes, sondern spielen auch eine entscheidende Rolle bei der semantischen Analyse, bei der der Compiler die Richtigkeit von Softwarekonstrukten und die korrekte Verwendung ihrer Elemente √ºberpr√ºft.  Nach dem Bilden des AST und dem Durchf√ºhren von √úberpr√ºfungen wird diese Struktur verwendet, um Bytecode oder Maschinencode zu generieren. <br><br><h2>  <font color="#3AC1EF">Verwenden abstrakter Syntaxb√§ume</font> </h2><br>  Abstrakte Syntaxb√§ume werden nicht nur in Interpreten und Compilern verwendet.  Sie sind in der Welt der Computer in vielen anderen Bereichen n√ºtzlich.  Eine der h√§ufigsten Anwendungen ist die statische Code-Analyse.  Statische Analysatoren f√ºhren den an sie √ºbergebenen Code nicht aus.  Trotzdem m√ºssen sie die Struktur der Programme verstehen. <br><br>  Angenommen, Sie m√∂chten ein Tool entwickeln, das h√§ufig vorkommende Strukturen in Ihrem Code findet.  Die Berichte eines solchen Tools helfen beim Refactoring und reduzieren die Codeduplizierung.  Dies kann unter Verwendung des √ºblichen Zeichenfolgenvergleichs erfolgen, aber dieser Ansatz ist sehr primitiv und seine F√§higkeiten sind begrenzt.  Wenn Sie ein √§hnliches Tool erstellen m√∂chten, m√ºssen Sie keinen eigenen Parser f√ºr JavaScript schreiben.  Es gibt viele Open-Source-Implementierungen solcher Programme, die vollst√§ndig mit der ECMAScript-Spezifikation kompatibel sind.  Zum Beispiel - Esprima und Eichel.  Es gibt auch Tools, die bei der Arbeit mit Parsern helfen k√∂nnen, n√§mlich bei der Arbeit mit abstrakten Syntaxb√§umen. <br><br>  Dar√ºber hinaus werden abstrakte Syntaxb√§ume h√§ufig bei der Entwicklung von Transpilern verwendet.  Angenommen, Sie m√∂chten einen Transpiler entwickeln, der Python-Code in JavaScript-Code konvertiert.  Ein √§hnliches Projekt kann auf der Idee basieren, dass ein Transpiler verwendet wird, um einen abstrakten Syntaxbaum basierend auf Python-Code zu erstellen, der wiederum in JavaScript-Code konvertiert wird.  Wahrscheinlich werden Sie sich hier fragen, wie das m√∂glich ist.  Die Sache ist, dass abstrakte Syntaxb√§ume nur eine alternative Art sind, Code in einer Programmiersprache darzustellen.  Bevor der Code in AST konvertiert wird, sieht er beim Schreiben wie normaler Text aus, der bestimmten Regeln folgt, die die Sprache bilden.  Nach dem Parsen wird dieser Code zu einer Baumstruktur, die dieselben Informationen wie der Quellcode des Programms enth√§lt.  Dadurch ist es m√∂glich, nicht nur den √úbergang vom Quellcode zum AST durchzuf√ºhren, sondern auch die inverse Transformation, wodurch der abstrakte Syntaxbaum in eine Textdarstellung des Programmcodes umgewandelt wird. <br><br><h2>  <font color="#3AC1EF">JavaScript analysieren</font> </h2><br>  Lassen Sie uns dar√ºber sprechen, wie abstrakte Syntaxb√§ume erstellt werden.  Betrachten Sie als Beispiel eine einfache JavaScript-Funktion: <br><br><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * x;    }    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br>  Der Parser erstellt einen abstrakten Syntaxbaum, der in der folgenden Abbildung schematisch dargestellt ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/4f0/bc1/6314f0bc14439c74d13d0aa21f2e63c7.png"></div><br>  <i><font color="#999999">Abstrakter Syntaxbaum</font></i> <br><br>  Bitte beachten Sie, dass dies eine vereinfachte Darstellung der Ergebnisse des Parsers ist.  Ein echter abstrakter Syntaxbaum sieht viel komplizierter aus.  In diesem Fall ist es unser Hauptziel, eine Vorstellung davon zu bekommen, in was sich der Quellcode zun√§chst verwandelt, bevor er ausgef√ºhrt wird.  Wenn Sie sich ansehen m√∂chten, wie ein echter abstrakter Syntaxbaum aussieht, verwenden Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AST Explorer-</a> Website.  Um einen AST f√ºr ein bestimmtes Fragment von JS-Code zu generieren, reicht es aus, ihn in das entsprechende Feld auf der Seite zu platzieren. <br><br>  Vielleicht haben Sie hier eine Frage, warum der Programmierer wissen muss, wie der JS-Parser funktioniert.  Am Ende ist das Parsen und Ausf√ºhren von Code eine Browseraufgabe.  In gewisser Weise hast du recht.  Die folgende Abbildung zeigt die Zeit, die einige bekannte Webprojekte ben√∂tigen, um verschiedene Schritte bei der Ausf√ºhrung von JS-Code auszuf√ºhren. <br><br>  Schauen Sie sich diese Zeichnung genauer an, vielleicht sehen Sie dort etwas Interessantes. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/5c5/448/f14/5c5448f14dc1ec31ed7b2e89bb5a48a4.png"></a> </div><br>  <i><font color="#999999">Zeitaufwand f√ºr die Ausf√ºhrung von JS-Code</font></i> <br><br>  Sehen Sie?  Wenn nicht, schauen Sie noch einmal.  Tats√§chlich sprechen wir √ºber die Tatsache, dass Browser durchschnittlich 15 bis 20% der Zeit damit verbringen, JS-Code zu analysieren.  Und dies sind keine bedingten Daten.  Hier finden Sie statistische Informationen zur Arbeit realer Webprojekte, die JavaScript auf die eine oder andere Weise verwenden.  Vielleicht scheint Ihnen die Zahl von 15% nicht so gro√ü zu sein, aber glauben Sie mir, das ist viel.  Eine typische einseitige Anwendung l√§dt ungef√§hr 0,4 MB JavaScript-Code, und der Browser ben√∂tigt ungef√§hr 370 ms, um diesen Code zu analysieren.  Auch hier kann man sagen, dass es keinen Grund zur Sorge gibt.  Und ja, das allein ist nicht viel.  Vergessen Sie jedoch nicht, dass dies nur die Zeit ist, die erforderlich ist, um den Code zu analysieren und in einen AST umzuwandeln.  Dies beinhaltet nicht die Zeit, die zum Ausf√ºhren des Codes ben√∂tigt wird, oder die Zeit, die zum L√∂sen anderer Aufgaben ben√∂tigt wird, die mit dem Laden der Seite einhergehen, z. B. die Aufgaben zum Verarbeiten von HTML und CSS und zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendern der Seite</a> .  Dar√ºber hinaus sprechen wir nur √ºber Desktop-Browser.  Bei mobilen Systemen ist das noch schlimmer.  Insbesondere kann die Analysezeit f√ºr denselben Code auf Mobilger√§ten 2-5 Mal l√§nger sein als auf dem Desktop.  Schauen Sie sich die folgende Abbildung an. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/8ba/4e0/530/8ba4e0530a7420a96458b00963587380.jpg"></a> </div><br>  <i><font color="#999999">Analysezeit von 1 MB JS-Code auf verschiedenen Ger√§ten</font></i> <br><br>  Hier ist die Zeit, die erforderlich ist, um 1 MB JS-Code auf verschiedenen Mobil- und Desktopger√§ten zu analysieren. <br><br>  Dar√ºber hinaus werden Webanwendungen immer komplexer und immer mehr Aufgaben werden auf die Client-Seite √ºbertragen.  All dies zielt darauf ab, die Benutzererfahrung bei der Arbeit mit Websites zu verbessern, um diese Gef√ºhle denen n√§her zu bringen, die Benutzer bei der Interaktion mit herk√∂mmlichen Anwendungen erleben.  Es ist leicht herauszufinden, wie stark sich dies auf Webprojekte auswirkt.  √ñffnen Sie dazu einfach die Entwicklertools im Browser, besuchen Sie eine moderne Website und sehen Sie, wie viel Zeit f√ºr das Parsen des Codes, das Kompilieren und alles andere aufgewendet wird, was im Browser passiert, wenn Sie die Seite f√ºr die Arbeit vorbereiten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/469/77c/26b/46977c26b690fe60b485f732f43afba8.jpg"></div><br>  <i><font color="#999999">Website-Analyse mit Entwicklertools in einem Browser</font></i> <br><br>  Leider verf√ºgen mobile Browser nicht √ºber solche Tools.  Dies bedeutet jedoch nicht, dass mobile Versionen von Websites nicht analysiert werden k√∂nnen.  Hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">helfen</a> uns Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DeviceTiming</a> .  Mit DeviceTiming k√∂nnen Sie die Zeit messen, die zum Parsen und Ausf√ºhren von Skripten in verwalteten Umgebungen ben√∂tigt wird.  Dies funktioniert aufgrund der Platzierung lokaler Skripte in der durch den Hilfscode gebildeten Umgebung, was dazu f√ºhrt, dass wir jedes Mal, wenn die Seite von verschiedenen Ger√§ten geladen wird, die Zeit f√ºr das Parsen und die Codeausf√ºhrung lokal messen k√∂nnen. <br><br><h2>  <font color="#3AC1EF">Analyseoptimierung und JS-Engines</font> </h2><br>  JS-Engines tun viele n√ºtzliche Dinge, um unn√∂tige Arbeit zu vermeiden und Codeverarbeitungsprozesse zu optimieren.  Hier sind einige Beispiele. <br><br>  Die V8-Engine unterst√ºtzt Streaming-Skripte und Code-Caching.  In diesem Fall wird unter Streaming die Tatsache verstanden, dass das System asynchron geladene Skripte analysiert und Skripts, deren Ausf√ºhrung verz√∂gert ist, in einem separaten Thread ab dem Moment beginnen, in dem der Code geladen wird.  Dies f√ºhrt dazu, dass das Parsen fast gleichzeitig mit dem Abschluss des Ladens des Skripts endet, wodurch sich die f√ºr die Vorbereitung der Seiten f√ºr die Arbeit erforderliche Zeit um etwa 10% verringert. <br><br>  JavaScript-Code wird normalerweise bei jedem Besuch einer Seite in Bytecode kompiliert.  Dieser Bytecode geht jedoch verloren, nachdem der Benutzer zu einer anderen Seite navigiert hat.  Dies liegt an der Tatsache, dass der kompilierte Code zum Zeitpunkt der Kompilierung stark vom Status und Kontext des Systems abh√§ngt.  Um die Situation zu verbessern, hat Chrome 42 die Unterst√ºtzung f√ºr das Zwischenspeichern von Bytecodes eingef√ºhrt.  Dank dieser Innovation wird der kompilierte Code lokal gespeichert. Wenn der Benutzer zu der bereits besuchten Seite zur√ºckkehrt, m√ºssen keine Skripte heruntergeladen, analysiert und kompiliert werden, um ihn f√ºr die Arbeit vorzubereiten.  Dies spart Chrome etwa 40% der Zeit beim Parsen und Kompilieren.  Dar√ºber hinaus f√ºhrt dies bei mobilen Ger√§ten zu einer Einsparung von Batteriestrom. <br><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Carakan-</a> Engine, die im Opera-Browser verwendet wurde und lange Zeit durch V8 ersetzt wurde, k√∂nnte die Kompilierungsergebnisse bereits verarbeiteter Skripte wiederverwenden.  Es war nicht erforderlich, dass diese Skripte mit derselben Seite verbunden oder sogar aus derselben Dom√§ne geladen wurden.  Diese Caching-Technik ist in der Tat sehr effektiv und erm√∂glicht es Ihnen, den Kompilierungsschritt vollst√§ndig abzubrechen.  Sie st√ºtzt sich auf typische Benutzerverhaltensszenarien und darauf, wie Menschen mit Webressourcen arbeiten.  Wenn der Benutzer w√§hrend der Arbeit mit einer Webanwendung einer bestimmten Abfolge von Aktionen folgt, wird derselbe Code geladen. <br><br>  Der von FireFox verwendete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpiderMonkey-</a> Interpreter speichert nicht alles hintereinander zwischen.  Es unterst√ºtzt ein √úberwachungssystem, das die Anzahl der Aufrufe eines bestimmten Skripts z√§hlt.  Basierend auf diesen Indikatoren werden Abschnitte des Codes bestimmt, die optimiert werden m√ºssen, dh diejenigen, die die maximale Last haben. <br><br>  Nat√ºrlich k√∂nnen einige Browserentwickler entscheiden, dass ihre Produkte √ºberhaupt kein Caching ben√∂tigen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Masei Stachovyak</a> , ein f√ºhrender Entwickler des Safari-Browsers, sagt, dass Safari nicht am Zwischenspeichern von kompiliertem Bytecode beteiligt ist.  Die M√∂glichkeit des Caching wurde in Betracht gezogen, wurde jedoch noch nicht implementiert, da die Codegenerierung weniger als 2% der gesamten Programmausf√ºhrungszeit in Anspruch nimmt. <br><br>  Diese Optimierungen wirken sich nicht direkt auf das Parsen des Quellcodes in JS aus.  Im Laufe ihrer Anwendung wird alles getan, um diesen Schritt in bestimmten F√§llen vollst√§ndig zu √ºberspringen.  Egal wie schnell das Parsen ist, es dauert immer noch einige Zeit, und das v√∂llige Fehlen des Parsens ist vielleicht das Beispiel f√ºr eine perfekte Optimierung. <br><br><h2>  <font color="#3AC1EF">Reduzieren Sie die Vorbereitungszeit f√ºr Webanwendungen</font> </h2><br>  Wie wir oben herausgefunden haben, w√§re es sch√∂n, den Bedarf an Parsing-Skripten zu minimieren, aber Sie k√∂nnen es nicht vollst√§ndig entfernen. Lassen Sie uns also dar√ºber sprechen, wie Sie die Zeit reduzieren k√∂nnen, die f√ºr die Vorbereitung von Webanwendungen f√ºr die Arbeit erforderlich ist.  Tats√§chlich kann daf√ºr viel getan werden.  Sie k√∂nnen beispielsweise die Menge des in der Anwendung enthaltenen JS-Codes minimieren.  Ein kleiner Code, der eine Seite f√ºr die Arbeit vorbereitet, kann schneller analysiert werden, und die Ausf√ºhrung dauert h√∂chstwahrscheinlich weniger lange als ein umfangreicherer Code. <br><br>  Um die Codemenge zu reduzieren, k√∂nnen Sie das Laden auf der Seite nur so organisieren, wie es wirklich ben√∂tigt wird, und nicht mit einem gro√üen Code, der absolut alles enth√§lt, was f√ºr das gesamte Webprojekt ben√∂tigt wird.  So f√∂rdert beispielsweise das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PRPL-</a> Muster einen solchen Ansatz zum Laden von Code.  Alternativ k√∂nnen Sie die Abh√§ngigkeiten √ºberpr√ºfen und feststellen, ob sie redundant sind, sodass dies nur zu einem ungerechtfertigten Wachstum der Codebasis f√ºhrt.  Tats√§chlich haben wir hier ein gro√ües Thema angesprochen, das eines gesonderten Materials w√ºrdig ist.  Zur√ºck zum Parsen. <br><br>  In diesem Material werden daher Techniken erl√§utert, mit denen ein Webentwickler einem Parser helfen kann, seine Arbeit schneller zu erledigen.  Solche Techniken existieren.  Moderne JS-Parser verwenden heuristische Algorithmen, um zu bestimmen, ob ein bestimmter Code so schnell wie m√∂glich ausgef√ºhrt werden muss oder ob er sp√§ter ausgef√ºhrt werden muss.  Basierend auf diesen Vorhersagen analysiert der Parser entweder das Codefragment vollst√§ndig unter Verwendung des eifrigen Parsing-Algorithmus oder verwendet den Lazy-Parsing-Algorithmus.  Mit einer vollst√§ndigen Analyse verstehen Sie die Funktionen, die Sie so schnell wie m√∂glich kompilieren m√ºssen.  W√§hrend dieses Prozesses werden drei Hauptaufgaben gel√∂st: Erstellen eines AST, Erstellen einer Hierarchie von Sichtbarkeitsbereichen und Auffinden von Syntaxfehlern.  Die Lazy-Analyse wird dagegen nur f√ºr Funktionen verwendet, die noch nicht kompiliert werden m√ºssen.  Dadurch wird kein AST erstellt und es wird nicht nach Fehlern gesucht.  Mit diesem Ansatz wird nur eine Hierarchie von Sichtbarkeitsbereichen erstellt, was im Vergleich zu Verarbeitungsfunktionen, die so schnell wie m√∂glich ausgef√ºhrt werden m√ºssen, etwa die H√§lfte der Zeit spart. <br><br>  In der Tat ist das Konzept nicht neu.  Selbst veraltete Browser wie IE9 unterst√ºtzen solche Optimierungsans√§tze, obwohl moderne Systeme nat√ºrlich weit fortgeschritten sind. <br><br>  Lassen Sie uns ein Beispiel untersuchen, das die Funktionsweise dieser Mechanismen veranschaulicht.  Angenommen, wir haben den folgenden JS-Code: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>;   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y;   }   console.log(baz(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)); }</code> </pre> <br>  Wie im vorherigen Beispiel f√§llt der Code in den Parser, der seine Analyse durchf√ºhrt und den AST bildet.  Infolgedessen stellt der Parser einen Code dar, der aus den folgenden Hauptteilen besteht (wir werden die <code>foo</code> Funktion nicht beachten): <br><br><ul><li>  Deklarieren einer Balkenfunktion, die ein Argument ( <code>x</code> ) akzeptiert.  Diese Funktion verf√ºgt √ºber einen R√ºckgabebefehl und gibt das Ergebnis des Hinzuf√ºgens von <code>x</code> und 10 zur√ºck. </li><li>  Deklarieren einer <code>baz</code> Funktion, die zwei Argumente ( <code>x</code> und <code>y</code> ) <code>baz</code> .  Sie hat auch einen R√ºckgabebefehl, sie gibt das Ergebnis des Hinzuf√ºgens von <code>x</code> und <code>y</code> . </li><li>  Aufruf der <code>baz</code> Funktion mit zwei Argumenten - 100 und 200. </li><li>  Aufruf der Funktion <code>console.log</code> mit einem Argument, dem Wert, der von der zuvor aufgerufenen Funktion zur√ºckgegeben wird. </li></ul><br>  So sieht es aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/ba5/f7b/6dfba5f7b7e40d5067424ada6a1c9855.png"></div><br>  <i><font color="#999999">Das Ergebnis des Parsens des Beispielcodes ohne Anwendung der Optimierung</font></i> <br><br>  Sprechen wir dar√ºber, was hier los ist.  Der Parser sieht die Deklaration der <code>console.log</code> , die Deklaration der <code>baz</code> Funktion, den Aufruf der <code>baz</code> Funktion und den Aufruf der <code>console.log</code> Funktion.  Beim Parsen dieses Codes st√∂√üt der Parser offensichtlich auf eine Aufgabe, deren Ausf√ºhrung die Ergebnisse dieses Programms nicht beeinflusst.  Es geht darum, die Funktionsleiste zu analysieren.  Warum ist die Analyse dieser Funktion nicht praktikabel?  Die Sache ist, dass die <code>bar</code> , zumindest im dargestellten Codefragment, niemals aufgerufen wird.  Dieses einfache Beispiel mag weit hergeholt erscheinen, aber viele reale Anwendungen haben eine gro√üe Anzahl von Funktionen, die niemals aufgerufen werden. <br><br>  In einer solchen Situation k√∂nnen wir, anstatt die Balkenfunktion zu analysieren, einfach aufzeichnen, dass sie deklariert ist, aber nirgendwo verwendet wird.  Gleichzeitig wird die eigentliche Analyse dieser Funktion durchgef√ºhrt, wenn sie unmittelbar vor ihrer Ausf√ºhrung erforderlich wird.  Wenn Sie eine verz√∂gerte Analyse durchf√ºhren, m√ºssen Sie nat√ºrlich den Hauptteil der Funktion erkennen und ihre Deklaration aufzeichnen, aber hier endet die Arbeit.  F√ºr eine solche Funktion ist es nicht erforderlich, einen abstrakten Syntaxbaum zu bilden, da das System keine Informationen dar√ºber hat, dass diese Funktion ausgef√ºhrt werden soll.  Dar√ºber hinaus wird kein Heapspeicher zugewiesen, was normalerweise erhebliche Systemressourcen erfordert.  Kurz gesagt, die Weigerung, unn√∂tige Funktionen zu analysieren, f√ºhrt zu einer signifikanten Steigerung der Codeleistung. <br><br>  Infolgedessen bildet der reale Parser im vorherigen Beispiel eine Struktur, die dem folgenden Schema √§hnelt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bb/202/a4d/3bb202a4de7b21c31cff3648403096ac.png"></div><br>  <i><font color="#999999">Ergebnis des Parsens von Beispielcode mit Optimierung</font></i> <br><br>  Beachten Sie, dass der Parser die Deklaration der Funktionsleiste notiert hat, sich jedoch nicht mit deren weiterer Analyse befasst hat.  Das System hat keine Anstrengungen unternommen, um den Funktionscode zu analysieren.  In diesem Fall war der Hauptteil der Funktion ein Befehl, das Ergebnis einfacher Berechnungen zur√ºckzugeben.  In den meisten realen Anwendungen kann der Funktionscode jedoch viel l√§nger und komplexer sein und viele R√ºckgabebefehle, Bedingungen, Schleifen, Variablendeklarationsbefehle und verschachtelte Funktionen enthalten.  All dies zu analysieren, sofern solche Funktionen niemals aufgerufen werden, ist Zeitverschwendung. <br><br>  Das oben beschriebene Konzept ist nicht kompliziert, aber seine praktische Umsetzung ist keine leichte Aufgabe.  Hier haben wir ein sehr einfaches Beispiel untersucht, und tats√§chlich ist es bei der Entscheidung, ob ein bestimmter Code in einem Programm ben√∂tigt wird, erforderlich, Funktionen und Schleifen sowie bedingte Operatoren und Objekte zu analysieren.  Im Allgemeinen k√∂nnen wir sagen, dass der Parser absolut alles im Programm verarbeiten und analysieren muss. <br><br>  Hier ist zum Beispiel ein sehr verbreitetes Muster f√ºr die Implementierung von Modulen in JavaScript: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myModule = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//      //    })();</span></span></code> </pre> <br>  Die meisten modernen JS-Parser erkennen dieses Muster, f√ºr sie ist es ein Signal, dass der im Modul befindliche Code vollst√§ndig analysiert werden muss. <br><br>  Aber was ist, wenn Parser immer faul analysiert haben?  Dies ist leider keine gute Idee.  Tatsache ist, dass bei diesem Ansatz, wenn Code so schnell wie m√∂glich ausgef√ºhrt werden muss, das System langsamer wird.  Der Parser f√ºhrt einen faulen Parsing-Durchgang durch. Danach beginnt er sofort, vollst√§ndig zu analysieren, was so schnell wie m√∂glich zu tun ist.  Dies f√ºhrt zu einer Verlangsamung von etwa 50% im Vergleich zum Ansatz, bei dem der Parser sofort beginnt, den wichtigsten Code vollst√§ndig zu analysieren. <br><br><h2>  <font color="#3AC1EF">Codeoptimierung unter Ber√ºcksichtigung der Merkmale der Analyse</font> </h2><br>  Nachdem wir ein wenig dar√ºber herausgefunden haben, was in den Parsern vor sich geht, ist es an der Zeit, dar√ºber nachzudenken, was getan werden kann, um ihnen zu helfen.  Wir k√∂nnen Code schreiben, damit das Parsen von Funktionen zum gew√ºnschten Zeitpunkt durchgef√ºhrt wird.  Es gibt ein Muster, das die meisten Parser verstehen.  Es dr√ºckt sich darin aus, dass Funktionen in Klammern stehen.  Ein solches Design sagt dem Parser fast immer, dass die Funktion sofort zerlegt werden muss.  Wenn der Parser eine √∂ffnende Klammer erkennt, unmittelbar danach die Funktionsdeklaration folgt, beginnt er sofort mit dem Parsen der Funktion.  Wir k√∂nnen dem Parser helfen, indem wir diese Technik anwenden, wenn wir Funktionen beschreiben, die so schnell wie m√∂glich ausgef√ºhrt werden m√ºssen. <br><br>  Angenommen, wir haben eine Funktion <code>foo</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br>  Da dieses Codefragment keinen expliziten Hinweis darauf enth√§lt, dass diese Funktion sofort ausgef√ºhrt werden soll, f√ºhrt der Browser nur die verz√∂gerte Analyse durch.  Wir sind jedoch zuversichtlich, dass wir diese Funktion sehr bald ben√∂tigen werden, damit wir zum n√§chsten Trick greifen k√∂nnen. <br><br>  Speichern Sie zun√§chst die Funktion in einer Variablen: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; };</code> </pre> <br>  Bitte beachten Sie, dass wir den urspr√ºnglichen Funktionsnamen zwischen dem <code>function</code> und der √∂ffnenden Klammer belassen haben.  Es kann nicht gesagt werden, dass dies absolut notwendig ist, aber es wird empfohlen, genau das zu tun, denn wenn eine Ausnahme ausgel√∂st wird, w√§hrend die Funktion ausgef√ºhrt wird, k√∂nnen Sie den Namen der Funktion in den Stack-Trace-Daten sehen, nicht <code>&lt;anonymous&gt;</code> . <br><br>  Nach der obigen √Ñnderung verwendet der Parser weiterhin die verz√∂gerte Analyse.  Um dies zu √§ndern, reicht ein kleines Detail aus.  Die Funktion muss in Klammern stehen: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; });</code> </pre> <br>  Wenn der Parser nun eine √∂ffnende Klammer vor dem <code>function</code> findet, beginnt er sofort mit dem Parsen dieser Funktion. <br><br>  Es ist m√∂glicherweise nicht einfach, solche Optimierungen manuell durchzuf√ºhren, da Sie dazu wissen m√ºssen, in welchen F√§llen der Parser eine verz√∂gerte Analyse durchf√ºhrt und in welchen F√§llen die vollst√§ndige.  Dazu m√ºssen Sie au√üerdem entscheiden, ob eine bestimmte Funktion so schnell wie m√∂glich einsatzbereit sein muss oder nicht. <br><br>  Programmierer werden diese zus√§tzliche Arbeit sicherlich nicht √ºbernehmen wollen.  Au√üerdem ist der auf diese Weise verarbeitete Code schwieriger zu lesen und zu verstehen, was nicht weniger wichtig ist als alles, was bereits gesagt wurde.  In dieser Situation helfen uns spezielle Softwarepakete wie Optimize.js.  Ihr Hauptziel ist es, die anf√§ngliche Startzeit f√ºr JS-Quellcode zu optimieren.  Sie f√ºhren eine statische Code-Analyse durch und √§ndern sie so, dass die Funktionen, die so schnell wie m√∂glich ausgef√ºhrt werden m√ºssen, in Klammern eingeschlossen sind. Dies f√ºhrt dazu, dass der Browser sie sofort analysiert und f√ºr die Ausf√ºhrung vorbereitet. <br><br>  Nehmen wir also an, wir programmieren, ohne wirklich an irgendetwas zu denken, und wir haben das folgende Codefragment: <br><br><pre> <code class="hljs matlab">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">; })</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Es sieht ganz normal aus, funktioniert wie erwartet und wird schnell ausgef√ºhrt, da der Parser die √∂ffnende Klammer vor dem <code>function</code> .  So weit so gut. ,       ,     ,    : <br><br><pre> <code class="hljs matlab">!<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">}</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>     ,    ,   .   ,   -        . <br><br>   ,      ,      .  ,     , ,         .  ,  ,    ,        .     ,        ,    .         Optimize.js.       Optimize.js,    : <br><br><pre> <code class="hljs matlab">!(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">})</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>      ,   .    ,   .       ,   ,         ,   ‚Äî     . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>  ,  JS-   ‚Äî ,    .        ?   ,           ,  , ,          .   ,    ,  ,    ,    JS-      ,          .  ,    ,       ,   -,        .       -  .       ,   ,    .          ,     , , ,              .  , JS-     ,  ,   V8     ,   ,     .                 . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br>   ,       -: <br><br><ul><li>   .    . </li><li>       ,       . </li><li> ,   ,   ,  JS-.          ,     ,   . </li><li>       DeviceTiming  ,      . </li><li>    Optimize.js  ,      ,         . </li></ul><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>    ,    ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SessionStack</a> ,      ,    -,       .     ,         .     ‚Äî       . ,     ‚Äî    ,      -,  ,       ,       . <br><br>  <b>Liebe Leser!</b>     -        JavaScript-? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415269/">https://habr.com/ru/post/de415269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415257/index.html">8 M√∂glichkeiten zur Verbesserung der Datenvisualisierung</a></li>
<li><a href="../de415259/index.html">select / poll / epoll: praktischer Unterschied</a></li>
<li><a href="../de415261/index.html">VFX-K√ºnstler in der Spieleentwicklung: Features, Karriere, Entwicklung</a></li>
<li><a href="../de415263/index.html">Wie wir der Karte Eing√§nge hinzugef√ºgt und die Gr√∂√üe der Basen um 10% reduziert haben</a></li>
<li><a href="../de415265/index.html">Auf der Suche nach einem Nachfolger des KL-7: RACE und AROFLEX</a></li>
<li><a href="../de415271/index.html">Wie Gantt-Diagramme das Projektmanagement vereinfachen</a></li>
<li><a href="../de415273/index.html">Erlernen der Grundlagen der Programmierung</a></li>
<li><a href="../de415275/index.html">Das Buch "C # 7 und .NET Core. Plattform√ºbergreifende Entwicklung f√ºr Profis. 3. Auflage</a></li>
<li><a href="../de415277/index.html">Was ist neu in ARKit 2.0?</a></li>
<li><a href="../de415279/index.html">Warum mit einem Mikroskop N√§gel einschlagen, wenn Sie Alpine Linux haben?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>