<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🎓 🦖 👨🏻‍🏭 Funktionsweise von JS: Abstrakte Syntaxbäume, Analyse und deren Optimierung ☝🏼 🌾 🏊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Lesen empfehlen] Die anderen 19 Teile des Zyklus  Teil 1: Überblick über die Engine, Laufzeitmechanismen, Aufrufstapel 
 Teil 2: Informationen zu V8-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionsweise von JS: Abstrakte Syntaxbäume, Analyse und deren Optimierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415269/"><div class="spoiler">  <b class="spoiler_title">[Lesen empfehlen] Die anderen 19 Teile des Zyklus</b> <div class="spoiler_text">  Teil 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überblick über die Engine, Laufzeitmechanismen, Aufrufstapel</a> <br>  Teil 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu V8-Interna und Codeoptimierung</a> <br>  Teil 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwalten des Speichers, vier Arten von Speicherlecks und Umgang mit ihnen</a> <br>  Teil 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisschleife, Async und fünf Möglichkeiten zur Verbesserung Ihres Codes mit Async / Warten</a> <br>  Teil 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebSocket und HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was soll ich wählen?</a> <br>  Teil 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen und Umfang von WebAssembly</a> <br>  Teil 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web Worker und fünf Nutzungsszenarien</a> <br>  Teil 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Servicemitarbeiter</a> <br>  Teil 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web-Push-Benachrichtigungen</a> <br>  Teil 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verfolgen Sie Änderungen im DOM mit MutationObserver</a> <br>  Teil 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendering-Engines für Webseiten und Tipps zur Optimierung ihrer Leistung</a> <br>  Teil 12: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerksubsystem von Browsern, um dessen Leistung und Sicherheit zu optimieren</a> <br>  Teil 12: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerksubsystem von Browsern, um dessen Leistung und Sicherheit zu optimieren</a> <br>  Teil 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Animation mit CSS und JavaScript</a> <br>  Teil 14: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Abstrakte Syntaxbäume, Analyse und deren Optimierung</a> <br>  Teil 15: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Klassen und Vererbung, Transpilation in Babel und TypeScript</a> <br>  Teil 16: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Speicher</a> <br>  Teil 17: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Shadow DOM-Technologie und Webkomponenten</a> <br>  Teil 18: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: WebRTC- und P2P-Kommunikationsmechanismen</a> <br>  Teil 19: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Benutzerdefinierte Elemente</a> </div></div><br>  Wir alle wissen, dass der JavaScript-Code für Webprojekte sehr groß werden kann.  Und je größer der Code, desto länger lädt der Browser ihn.  Das Problem liegt hier aber nicht nur in der Zeit der Datenübertragung über das Netzwerk.  Nachdem das Programm geladen wurde, muss es noch analysiert, in Bytecode kompiliert und schließlich ausgeführt werden.  Heute machen wir Sie auf eine Übersetzung von Teil 14 der JavaScript-Ökosystemreihe aufmerksam.  Wir werden nämlich über das Parsen von JS-Code sprechen, wie abstrakte Syntaxbäume erstellt werden und wie ein Programmierer diese Prozesse beeinflussen kann, um die Geschwindigkeit ihrer Anwendungen zu erhöhen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/68b/b2c/231/68bb2c231dd5b82bd35e97ceb36becef.jpg" alt="Bild"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Wie sind Programmiersprachen?</font> </h2><br>  Bevor wir uns mit abstrakten Syntaxbäumen befassen, wollen wir uns mit der Funktionsweise von Programmiersprachen befassen.  Unabhängig davon, welche Sprache Sie verwenden, müssen Sie immer bestimmte Programme verwenden, die den Quellcode in etwas konvertieren, das bestimmte Befehle für die Maschinen enthält.  Entweder Interpreter oder Compiler fungieren als solche Programme.  Es spielt keine Rolle, ob Sie in einer interpretierten Sprache (JavaScript, Python, Ruby) oder kompiliert (C #, Java, Rust) schreiben. Ihr Code, bei dem es sich um einfachen Text handelt, durchläuft immer die Analysephase, dh, einfacher Text wird in eine Datenstruktur umgewandelt wird als Abstract Syntax Tree (AST) bezeichnet. <br><br>  Abstrakte Syntaxbäume bieten nicht nur eine strukturierte Darstellung des Quellcodes, sondern spielen auch eine entscheidende Rolle bei der semantischen Analyse, bei der der Compiler die Richtigkeit von Softwarekonstrukten und die korrekte Verwendung ihrer Elemente überprüft.  Nach dem Bilden des AST und dem Durchführen von Überprüfungen wird diese Struktur verwendet, um Bytecode oder Maschinencode zu generieren. <br><br><h2>  <font color="#3AC1EF">Verwenden abstrakter Syntaxbäume</font> </h2><br>  Abstrakte Syntaxbäume werden nicht nur in Interpreten und Compilern verwendet.  Sie sind in der Welt der Computer in vielen anderen Bereichen nützlich.  Eine der häufigsten Anwendungen ist die statische Code-Analyse.  Statische Analysatoren führen den an sie übergebenen Code nicht aus.  Trotzdem müssen sie die Struktur der Programme verstehen. <br><br>  Angenommen, Sie möchten ein Tool entwickeln, das häufig vorkommende Strukturen in Ihrem Code findet.  Die Berichte eines solchen Tools helfen beim Refactoring und reduzieren die Codeduplizierung.  Dies kann unter Verwendung des üblichen Zeichenfolgenvergleichs erfolgen, aber dieser Ansatz ist sehr primitiv und seine Fähigkeiten sind begrenzt.  Wenn Sie ein ähnliches Tool erstellen möchten, müssen Sie keinen eigenen Parser für JavaScript schreiben.  Es gibt viele Open-Source-Implementierungen solcher Programme, die vollständig mit der ECMAScript-Spezifikation kompatibel sind.  Zum Beispiel - Esprima und Eichel.  Es gibt auch Tools, die bei der Arbeit mit Parsern helfen können, nämlich bei der Arbeit mit abstrakten Syntaxbäumen. <br><br>  Darüber hinaus werden abstrakte Syntaxbäume häufig bei der Entwicklung von Transpilern verwendet.  Angenommen, Sie möchten einen Transpiler entwickeln, der Python-Code in JavaScript-Code konvertiert.  Ein ähnliches Projekt kann auf der Idee basieren, dass ein Transpiler verwendet wird, um einen abstrakten Syntaxbaum basierend auf Python-Code zu erstellen, der wiederum in JavaScript-Code konvertiert wird.  Wahrscheinlich werden Sie sich hier fragen, wie das möglich ist.  Die Sache ist, dass abstrakte Syntaxbäume nur eine alternative Art sind, Code in einer Programmiersprache darzustellen.  Bevor der Code in AST konvertiert wird, sieht er beim Schreiben wie normaler Text aus, der bestimmten Regeln folgt, die die Sprache bilden.  Nach dem Parsen wird dieser Code zu einer Baumstruktur, die dieselben Informationen wie der Quellcode des Programms enthält.  Dadurch ist es möglich, nicht nur den Übergang vom Quellcode zum AST durchzuführen, sondern auch die inverse Transformation, wodurch der abstrakte Syntaxbaum in eine Textdarstellung des Programmcodes umgewandelt wird. <br><br><h2>  <font color="#3AC1EF">JavaScript analysieren</font> </h2><br>  Lassen Sie uns darüber sprechen, wie abstrakte Syntaxbäume erstellt werden.  Betrachten Sie als Beispiel eine einfache JavaScript-Funktion: <br><br><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * x;    }    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br>  Der Parser erstellt einen abstrakten Syntaxbaum, der in der folgenden Abbildung schematisch dargestellt ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/4f0/bc1/6314f0bc14439c74d13d0aa21f2e63c7.png"></div><br>  <i><font color="#999999">Abstrakter Syntaxbaum</font></i> <br><br>  Bitte beachten Sie, dass dies eine vereinfachte Darstellung der Ergebnisse des Parsers ist.  Ein echter abstrakter Syntaxbaum sieht viel komplizierter aus.  In diesem Fall ist es unser Hauptziel, eine Vorstellung davon zu bekommen, in was sich der Quellcode zunächst verwandelt, bevor er ausgeführt wird.  Wenn Sie sich ansehen möchten, wie ein echter abstrakter Syntaxbaum aussieht, verwenden Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AST Explorer-</a> Website.  Um einen AST für ein bestimmtes Fragment von JS-Code zu generieren, reicht es aus, ihn in das entsprechende Feld auf der Seite zu platzieren. <br><br>  Vielleicht haben Sie hier eine Frage, warum der Programmierer wissen muss, wie der JS-Parser funktioniert.  Am Ende ist das Parsen und Ausführen von Code eine Browseraufgabe.  In gewisser Weise hast du recht.  Die folgende Abbildung zeigt die Zeit, die einige bekannte Webprojekte benötigen, um verschiedene Schritte bei der Ausführung von JS-Code auszuführen. <br><br>  Schauen Sie sich diese Zeichnung genauer an, vielleicht sehen Sie dort etwas Interessantes. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/5c5/448/f14/5c5448f14dc1ec31ed7b2e89bb5a48a4.png"></a> </div><br>  <i><font color="#999999">Zeitaufwand für die Ausführung von JS-Code</font></i> <br><br>  Sehen Sie?  Wenn nicht, schauen Sie noch einmal.  Tatsächlich sprechen wir über die Tatsache, dass Browser durchschnittlich 15 bis 20% der Zeit damit verbringen, JS-Code zu analysieren.  Und dies sind keine bedingten Daten.  Hier finden Sie statistische Informationen zur Arbeit realer Webprojekte, die JavaScript auf die eine oder andere Weise verwenden.  Vielleicht scheint Ihnen die Zahl von 15% nicht so groß zu sein, aber glauben Sie mir, das ist viel.  Eine typische einseitige Anwendung lädt ungefähr 0,4 MB JavaScript-Code, und der Browser benötigt ungefähr 370 ms, um diesen Code zu analysieren.  Auch hier kann man sagen, dass es keinen Grund zur Sorge gibt.  Und ja, das allein ist nicht viel.  Vergessen Sie jedoch nicht, dass dies nur die Zeit ist, die erforderlich ist, um den Code zu analysieren und in einen AST umzuwandeln.  Dies beinhaltet nicht die Zeit, die zum Ausführen des Codes benötigt wird, oder die Zeit, die zum Lösen anderer Aufgaben benötigt wird, die mit dem Laden der Seite einhergehen, z. B. die Aufgaben zum Verarbeiten von HTML und CSS und zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendern der Seite</a> .  Darüber hinaus sprechen wir nur über Desktop-Browser.  Bei mobilen Systemen ist das noch schlimmer.  Insbesondere kann die Analysezeit für denselben Code auf Mobilgeräten 2-5 Mal länger sein als auf dem Desktop.  Schauen Sie sich die folgende Abbildung an. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/8ba/4e0/530/8ba4e0530a7420a96458b00963587380.jpg"></a> </div><br>  <i><font color="#999999">Analysezeit von 1 MB JS-Code auf verschiedenen Geräten</font></i> <br><br>  Hier ist die Zeit, die erforderlich ist, um 1 MB JS-Code auf verschiedenen Mobil- und Desktopgeräten zu analysieren. <br><br>  Darüber hinaus werden Webanwendungen immer komplexer und immer mehr Aufgaben werden auf die Client-Seite übertragen.  All dies zielt darauf ab, die Benutzererfahrung bei der Arbeit mit Websites zu verbessern, um diese Gefühle denen näher zu bringen, die Benutzer bei der Interaktion mit herkömmlichen Anwendungen erleben.  Es ist leicht herauszufinden, wie stark sich dies auf Webprojekte auswirkt.  Öffnen Sie dazu einfach die Entwicklertools im Browser, besuchen Sie eine moderne Website und sehen Sie, wie viel Zeit für das Parsen des Codes, das Kompilieren und alles andere aufgewendet wird, was im Browser passiert, wenn Sie die Seite für die Arbeit vorbereiten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/469/77c/26b/46977c26b690fe60b485f732f43afba8.jpg"></div><br>  <i><font color="#999999">Website-Analyse mit Entwicklertools in einem Browser</font></i> <br><br>  Leider verfügen mobile Browser nicht über solche Tools.  Dies bedeutet jedoch nicht, dass mobile Versionen von Websites nicht analysiert werden können.  Hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">helfen</a> uns Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DeviceTiming</a> .  Mit DeviceTiming können Sie die Zeit messen, die zum Parsen und Ausführen von Skripten in verwalteten Umgebungen benötigt wird.  Dies funktioniert aufgrund der Platzierung lokaler Skripte in der durch den Hilfscode gebildeten Umgebung, was dazu führt, dass wir jedes Mal, wenn die Seite von verschiedenen Geräten geladen wird, die Zeit für das Parsen und die Codeausführung lokal messen können. <br><br><h2>  <font color="#3AC1EF">Analyseoptimierung und JS-Engines</font> </h2><br>  JS-Engines tun viele nützliche Dinge, um unnötige Arbeit zu vermeiden und Codeverarbeitungsprozesse zu optimieren.  Hier sind einige Beispiele. <br><br>  Die V8-Engine unterstützt Streaming-Skripte und Code-Caching.  In diesem Fall wird unter Streaming die Tatsache verstanden, dass das System asynchron geladene Skripte analysiert und Skripts, deren Ausführung verzögert ist, in einem separaten Thread ab dem Moment beginnen, in dem der Code geladen wird.  Dies führt dazu, dass das Parsen fast gleichzeitig mit dem Abschluss des Ladens des Skripts endet, wodurch sich die für die Vorbereitung der Seiten für die Arbeit erforderliche Zeit um etwa 10% verringert. <br><br>  JavaScript-Code wird normalerweise bei jedem Besuch einer Seite in Bytecode kompiliert.  Dieser Bytecode geht jedoch verloren, nachdem der Benutzer zu einer anderen Seite navigiert hat.  Dies liegt an der Tatsache, dass der kompilierte Code zum Zeitpunkt der Kompilierung stark vom Status und Kontext des Systems abhängt.  Um die Situation zu verbessern, hat Chrome 42 die Unterstützung für das Zwischenspeichern von Bytecodes eingeführt.  Dank dieser Innovation wird der kompilierte Code lokal gespeichert. Wenn der Benutzer zu der bereits besuchten Seite zurückkehrt, müssen keine Skripte heruntergeladen, analysiert und kompiliert werden, um ihn für die Arbeit vorzubereiten.  Dies spart Chrome etwa 40% der Zeit beim Parsen und Kompilieren.  Darüber hinaus führt dies bei mobilen Geräten zu einer Einsparung von Batteriestrom. <br><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Carakan-</a> Engine, die im Opera-Browser verwendet wurde und lange Zeit durch V8 ersetzt wurde, könnte die Kompilierungsergebnisse bereits verarbeiteter Skripte wiederverwenden.  Es war nicht erforderlich, dass diese Skripte mit derselben Seite verbunden oder sogar aus derselben Domäne geladen wurden.  Diese Caching-Technik ist in der Tat sehr effektiv und ermöglicht es Ihnen, den Kompilierungsschritt vollständig abzubrechen.  Sie stützt sich auf typische Benutzerverhaltensszenarien und darauf, wie Menschen mit Webressourcen arbeiten.  Wenn der Benutzer während der Arbeit mit einer Webanwendung einer bestimmten Abfolge von Aktionen folgt, wird derselbe Code geladen. <br><br>  Der von FireFox verwendete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpiderMonkey-</a> Interpreter speichert nicht alles hintereinander zwischen.  Es unterstützt ein Überwachungssystem, das die Anzahl der Aufrufe eines bestimmten Skripts zählt.  Basierend auf diesen Indikatoren werden Abschnitte des Codes bestimmt, die optimiert werden müssen, dh diejenigen, die die maximale Last haben. <br><br>  Natürlich können einige Browserentwickler entscheiden, dass ihre Produkte überhaupt kein Caching benötigen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Masei Stachovyak</a> , ein führender Entwickler des Safari-Browsers, sagt, dass Safari nicht am Zwischenspeichern von kompiliertem Bytecode beteiligt ist.  Die Möglichkeit des Caching wurde in Betracht gezogen, wurde jedoch noch nicht implementiert, da die Codegenerierung weniger als 2% der gesamten Programmausführungszeit in Anspruch nimmt. <br><br>  Diese Optimierungen wirken sich nicht direkt auf das Parsen des Quellcodes in JS aus.  Im Laufe ihrer Anwendung wird alles getan, um diesen Schritt in bestimmten Fällen vollständig zu überspringen.  Egal wie schnell das Parsen ist, es dauert immer noch einige Zeit, und das völlige Fehlen des Parsens ist vielleicht das Beispiel für eine perfekte Optimierung. <br><br><h2>  <font color="#3AC1EF">Reduzieren Sie die Vorbereitungszeit für Webanwendungen</font> </h2><br>  Wie wir oben herausgefunden haben, wäre es schön, den Bedarf an Parsing-Skripten zu minimieren, aber Sie können es nicht vollständig entfernen. Lassen Sie uns also darüber sprechen, wie Sie die Zeit reduzieren können, die für die Vorbereitung von Webanwendungen für die Arbeit erforderlich ist.  Tatsächlich kann dafür viel getan werden.  Sie können beispielsweise die Menge des in der Anwendung enthaltenen JS-Codes minimieren.  Ein kleiner Code, der eine Seite für die Arbeit vorbereitet, kann schneller analysiert werden, und die Ausführung dauert höchstwahrscheinlich weniger lange als ein umfangreicherer Code. <br><br>  Um die Codemenge zu reduzieren, können Sie das Laden auf der Seite nur so organisieren, wie es wirklich benötigt wird, und nicht mit einem großen Code, der absolut alles enthält, was für das gesamte Webprojekt benötigt wird.  So fördert beispielsweise das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PRPL-</a> Muster einen solchen Ansatz zum Laden von Code.  Alternativ können Sie die Abhängigkeiten überprüfen und feststellen, ob sie redundant sind, sodass dies nur zu einem ungerechtfertigten Wachstum der Codebasis führt.  Tatsächlich haben wir hier ein großes Thema angesprochen, das eines gesonderten Materials würdig ist.  Zurück zum Parsen. <br><br>  In diesem Material werden daher Techniken erläutert, mit denen ein Webentwickler einem Parser helfen kann, seine Arbeit schneller zu erledigen.  Solche Techniken existieren.  Moderne JS-Parser verwenden heuristische Algorithmen, um zu bestimmen, ob ein bestimmter Code so schnell wie möglich ausgeführt werden muss oder ob er später ausgeführt werden muss.  Basierend auf diesen Vorhersagen analysiert der Parser entweder das Codefragment vollständig unter Verwendung des eifrigen Parsing-Algorithmus oder verwendet den Lazy-Parsing-Algorithmus.  Mit einer vollständigen Analyse verstehen Sie die Funktionen, die Sie so schnell wie möglich kompilieren müssen.  Während dieses Prozesses werden drei Hauptaufgaben gelöst: Erstellen eines AST, Erstellen einer Hierarchie von Sichtbarkeitsbereichen und Auffinden von Syntaxfehlern.  Die Lazy-Analyse wird dagegen nur für Funktionen verwendet, die noch nicht kompiliert werden müssen.  Dadurch wird kein AST erstellt und es wird nicht nach Fehlern gesucht.  Mit diesem Ansatz wird nur eine Hierarchie von Sichtbarkeitsbereichen erstellt, was im Vergleich zu Verarbeitungsfunktionen, die so schnell wie möglich ausgeführt werden müssen, etwa die Hälfte der Zeit spart. <br><br>  In der Tat ist das Konzept nicht neu.  Selbst veraltete Browser wie IE9 unterstützen solche Optimierungsansätze, obwohl moderne Systeme natürlich weit fortgeschritten sind. <br><br>  Lassen Sie uns ein Beispiel untersuchen, das die Funktionsweise dieser Mechanismen veranschaulicht.  Angenommen, wir haben den folgenden JS-Code: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>;   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y;   }   console.log(baz(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)); }</code> </pre> <br>  Wie im vorherigen Beispiel fällt der Code in den Parser, der seine Analyse durchführt und den AST bildet.  Infolgedessen stellt der Parser einen Code dar, der aus den folgenden Hauptteilen besteht (wir werden die <code>foo</code> Funktion nicht beachten): <br><br><ul><li>  Deklarieren einer Balkenfunktion, die ein Argument ( <code>x</code> ) akzeptiert.  Diese Funktion verfügt über einen Rückgabebefehl und gibt das Ergebnis des Hinzufügens von <code>x</code> und 10 zurück. </li><li>  Deklarieren einer <code>baz</code> Funktion, die zwei Argumente ( <code>x</code> und <code>y</code> ) <code>baz</code> .  Sie hat auch einen Rückgabebefehl, sie gibt das Ergebnis des Hinzufügens von <code>x</code> und <code>y</code> . </li><li>  Aufruf der <code>baz</code> Funktion mit zwei Argumenten - 100 und 200. </li><li>  Aufruf der Funktion <code>console.log</code> mit einem Argument, dem Wert, der von der zuvor aufgerufenen Funktion zurückgegeben wird. </li></ul><br>  So sieht es aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/ba5/f7b/6dfba5f7b7e40d5067424ada6a1c9855.png"></div><br>  <i><font color="#999999">Das Ergebnis des Parsens des Beispielcodes ohne Anwendung der Optimierung</font></i> <br><br>  Sprechen wir darüber, was hier los ist.  Der Parser sieht die Deklaration der <code>console.log</code> , die Deklaration der <code>baz</code> Funktion, den Aufruf der <code>baz</code> Funktion und den Aufruf der <code>console.log</code> Funktion.  Beim Parsen dieses Codes stößt der Parser offensichtlich auf eine Aufgabe, deren Ausführung die Ergebnisse dieses Programms nicht beeinflusst.  Es geht darum, die Funktionsleiste zu analysieren.  Warum ist die Analyse dieser Funktion nicht praktikabel?  Die Sache ist, dass die <code>bar</code> , zumindest im dargestellten Codefragment, niemals aufgerufen wird.  Dieses einfache Beispiel mag weit hergeholt erscheinen, aber viele reale Anwendungen haben eine große Anzahl von Funktionen, die niemals aufgerufen werden. <br><br>  In einer solchen Situation können wir, anstatt die Balkenfunktion zu analysieren, einfach aufzeichnen, dass sie deklariert ist, aber nirgendwo verwendet wird.  Gleichzeitig wird die eigentliche Analyse dieser Funktion durchgeführt, wenn sie unmittelbar vor ihrer Ausführung erforderlich wird.  Wenn Sie eine verzögerte Analyse durchführen, müssen Sie natürlich den Hauptteil der Funktion erkennen und ihre Deklaration aufzeichnen, aber hier endet die Arbeit.  Für eine solche Funktion ist es nicht erforderlich, einen abstrakten Syntaxbaum zu bilden, da das System keine Informationen darüber hat, dass diese Funktion ausgeführt werden soll.  Darüber hinaus wird kein Heapspeicher zugewiesen, was normalerweise erhebliche Systemressourcen erfordert.  Kurz gesagt, die Weigerung, unnötige Funktionen zu analysieren, führt zu einer signifikanten Steigerung der Codeleistung. <br><br>  Infolgedessen bildet der reale Parser im vorherigen Beispiel eine Struktur, die dem folgenden Schema ähnelt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bb/202/a4d/3bb202a4de7b21c31cff3648403096ac.png"></div><br>  <i><font color="#999999">Ergebnis des Parsens von Beispielcode mit Optimierung</font></i> <br><br>  Beachten Sie, dass der Parser die Deklaration der Funktionsleiste notiert hat, sich jedoch nicht mit deren weiterer Analyse befasst hat.  Das System hat keine Anstrengungen unternommen, um den Funktionscode zu analysieren.  In diesem Fall war der Hauptteil der Funktion ein Befehl, das Ergebnis einfacher Berechnungen zurückzugeben.  In den meisten realen Anwendungen kann der Funktionscode jedoch viel länger und komplexer sein und viele Rückgabebefehle, Bedingungen, Schleifen, Variablendeklarationsbefehle und verschachtelte Funktionen enthalten.  All dies zu analysieren, sofern solche Funktionen niemals aufgerufen werden, ist Zeitverschwendung. <br><br>  Das oben beschriebene Konzept ist nicht kompliziert, aber seine praktische Umsetzung ist keine leichte Aufgabe.  Hier haben wir ein sehr einfaches Beispiel untersucht, und tatsächlich ist es bei der Entscheidung, ob ein bestimmter Code in einem Programm benötigt wird, erforderlich, Funktionen und Schleifen sowie bedingte Operatoren und Objekte zu analysieren.  Im Allgemeinen können wir sagen, dass der Parser absolut alles im Programm verarbeiten und analysieren muss. <br><br>  Hier ist zum Beispiel ein sehr verbreitetes Muster für die Implementierung von Modulen in JavaScript: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myModule = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//      //    })();</span></span></code> </pre> <br>  Die meisten modernen JS-Parser erkennen dieses Muster, für sie ist es ein Signal, dass der im Modul befindliche Code vollständig analysiert werden muss. <br><br>  Aber was ist, wenn Parser immer faul analysiert haben?  Dies ist leider keine gute Idee.  Tatsache ist, dass bei diesem Ansatz, wenn Code so schnell wie möglich ausgeführt werden muss, das System langsamer wird.  Der Parser führt einen faulen Parsing-Durchgang durch. Danach beginnt er sofort, vollständig zu analysieren, was so schnell wie möglich zu tun ist.  Dies führt zu einer Verlangsamung von etwa 50% im Vergleich zum Ansatz, bei dem der Parser sofort beginnt, den wichtigsten Code vollständig zu analysieren. <br><br><h2>  <font color="#3AC1EF">Codeoptimierung unter Berücksichtigung der Merkmale der Analyse</font> </h2><br>  Nachdem wir ein wenig darüber herausgefunden haben, was in den Parsern vor sich geht, ist es an der Zeit, darüber nachzudenken, was getan werden kann, um ihnen zu helfen.  Wir können Code schreiben, damit das Parsen von Funktionen zum gewünschten Zeitpunkt durchgeführt wird.  Es gibt ein Muster, das die meisten Parser verstehen.  Es drückt sich darin aus, dass Funktionen in Klammern stehen.  Ein solches Design sagt dem Parser fast immer, dass die Funktion sofort zerlegt werden muss.  Wenn der Parser eine öffnende Klammer erkennt, unmittelbar danach die Funktionsdeklaration folgt, beginnt er sofort mit dem Parsen der Funktion.  Wir können dem Parser helfen, indem wir diese Technik anwenden, wenn wir Funktionen beschreiben, die so schnell wie möglich ausgeführt werden müssen. <br><br>  Angenommen, wir haben eine Funktion <code>foo</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br>  Da dieses Codefragment keinen expliziten Hinweis darauf enthält, dass diese Funktion sofort ausgeführt werden soll, führt der Browser nur die verzögerte Analyse durch.  Wir sind jedoch zuversichtlich, dass wir diese Funktion sehr bald benötigen werden, damit wir zum nächsten Trick greifen können. <br><br>  Speichern Sie zunächst die Funktion in einer Variablen: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; };</code> </pre> <br>  Bitte beachten Sie, dass wir den ursprünglichen Funktionsnamen zwischen dem <code>function</code> und der öffnenden Klammer belassen haben.  Es kann nicht gesagt werden, dass dies absolut notwendig ist, aber es wird empfohlen, genau das zu tun, denn wenn eine Ausnahme ausgelöst wird, während die Funktion ausgeführt wird, können Sie den Namen der Funktion in den Stack-Trace-Daten sehen, nicht <code>&lt;anonymous&gt;</code> . <br><br>  Nach der obigen Änderung verwendet der Parser weiterhin die verzögerte Analyse.  Um dies zu ändern, reicht ein kleines Detail aus.  Die Funktion muss in Klammern stehen: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; });</code> </pre> <br>  Wenn der Parser nun eine öffnende Klammer vor dem <code>function</code> findet, beginnt er sofort mit dem Parsen dieser Funktion. <br><br>  Es ist möglicherweise nicht einfach, solche Optimierungen manuell durchzuführen, da Sie dazu wissen müssen, in welchen Fällen der Parser eine verzögerte Analyse durchführt und in welchen Fällen die vollständige.  Dazu müssen Sie außerdem entscheiden, ob eine bestimmte Funktion so schnell wie möglich einsatzbereit sein muss oder nicht. <br><br>  Programmierer werden diese zusätzliche Arbeit sicherlich nicht übernehmen wollen.  Außerdem ist der auf diese Weise verarbeitete Code schwieriger zu lesen und zu verstehen, was nicht weniger wichtig ist als alles, was bereits gesagt wurde.  In dieser Situation helfen uns spezielle Softwarepakete wie Optimize.js.  Ihr Hauptziel ist es, die anfängliche Startzeit für JS-Quellcode zu optimieren.  Sie führen eine statische Code-Analyse durch und ändern sie so, dass die Funktionen, die so schnell wie möglich ausgeführt werden müssen, in Klammern eingeschlossen sind. Dies führt dazu, dass der Browser sie sofort analysiert und für die Ausführung vorbereitet. <br><br>  Nehmen wir also an, wir programmieren, ohne wirklich an irgendetwas zu denken, und wir haben das folgende Codefragment: <br><br><pre> <code class="hljs matlab">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">; })</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Es sieht ganz normal aus, funktioniert wie erwartet und wird schnell ausgeführt, da der Parser die öffnende Klammer vor dem <code>function</code> .  So weit so gut. ,       ,     ,    : <br><br><pre> <code class="hljs matlab">!<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">}</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>     ,    ,   .   ,   -        . <br><br>   ,      ,      .  ,     , ,         .  ,  ,    ,        .     ,        ,    .         Optimize.js.       Optimize.js,    : <br><br><pre> <code class="hljs matlab">!(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">})</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>      ,   .    ,   .       ,   ,         ,   —     . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>  ,  JS-   — ,    .        ?   ,           ,  , ,          .   ,    ,  ,    ,    JS-      ,          .  ,    ,       ,   -,        .       -  .       ,   ,    .          ,     , , ,              .  , JS-     ,  ,   V8     ,   ,     .                 . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br>   ,       -: <br><br><ul><li>   .    . </li><li>       ,       . </li><li> ,   ,   ,  JS-.          ,     ,   . </li><li>       DeviceTiming  ,      . </li><li>    Optimize.js  ,      ,         . </li></ul><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>    ,    ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SessionStack</a> ,      ,    -,       .     ,         .     —       . ,     —    ,      -,  ,       ,       . <br><br>  <b>Liebe Leser!</b>     -        JavaScript-? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415269/">https://habr.com/ru/post/de415269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415257/index.html">8 Möglichkeiten zur Verbesserung der Datenvisualisierung</a></li>
<li><a href="../de415259/index.html">select / poll / epoll: praktischer Unterschied</a></li>
<li><a href="../de415261/index.html">VFX-Künstler in der Spieleentwicklung: Features, Karriere, Entwicklung</a></li>
<li><a href="../de415263/index.html">Wie wir der Karte Eingänge hinzugefügt und die Größe der Basen um 10% reduziert haben</a></li>
<li><a href="../de415265/index.html">Auf der Suche nach einem Nachfolger des KL-7: RACE und AROFLEX</a></li>
<li><a href="../de415271/index.html">Wie Gantt-Diagramme das Projektmanagement vereinfachen</a></li>
<li><a href="../de415273/index.html">Erlernen der Grundlagen der Programmierung</a></li>
<li><a href="../de415275/index.html">Das Buch "C # 7 und .NET Core. Plattformübergreifende Entwicklung für Profis. 3. Auflage</a></li>
<li><a href="../de415277/index.html">Was ist neu in ARKit 2.0?</a></li>
<li><a href="../de415279/index.html">Warum mit einem Mikroskop Nägel einschlagen, wenn Sie Alpine Linux haben?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>