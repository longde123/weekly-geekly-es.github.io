<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüîß üßúüèø üë®üèº‚Äç‚öïÔ∏è D√©pendance des performances du code sur le contexte de la d√©claration des variables en JavaScript üßïüèæ üïâÔ∏è üëÜüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Initialement, cet article a √©t√© con√ßu comme une petite r√©f√©rence pour son propre usage, et en g√©n√©ral il n'√©tait pas pr√©vu d'√™tre un article, cependan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©pendance des performances du code sur le contexte de la d√©claration des variables en JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469523/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/cx/hu/udcxhuvjpmyigj19lmdrz8ojyja.jpeg"></div><br>  Initialement, cet article a √©t√© con√ßu comme une petite r√©f√©rence pour son propre usage, et en g√©n√©ral il n'√©tait pas pr√©vu d'√™tre un article, cependant, dans le processus de prise de mesures, certaines fonctionnalit√©s int√©ressantes sont apparues dans la mise en ≈ìuvre de l'architecture <i><b>JavaScript</b></i> qui affectent fortement les performances du code final dans certains cas.  Je sugg√®re, et vous, de vous familiariser avec les r√©sultats obtenus, en passant √©galement en revue certains sujets connexes: <i><b>pour les</b></i> boucles, l'environnement (contexte d'ex√©cution) et les blocs. <br><br><a name="habracut"></a>  √Ä la fin de mon article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Utilisation des d√©clarations de variables let et des fonctionnalit√©s des fermetures JavaScript r√©sultantes¬ª,</a> j'ai bri√®vement abord√© la comparaison des performances des d√©clarations de variables <i><b>let (LexicalDeclaration)</b></i> et <i><b>var (VarDeclaredNames)</b></i> en boucles.  √Ä titre de comparaison, nous avons utilis√© le temps d'ex√©cution du tri manuel (sans l'aide de <i><b>Array.prototype.sort ()</b></i> ) du tableau, l'une des m√©thodes les plus simples est le tri par s√©lection, car avec une longueur de tableau de 100000, nous avons obtenu un peu plus de 5 milliards.  it√©rations en deux cycles (externe et imbriqu√©), et, ce montant devrait permettre au final une estimation ad√©quate. <br><br>  Pour <i><b>var,</b></i> il triait la vue: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, len = arr.length; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 9.082 . //   Chrome: 10.783 .</span></span></code> </pre> <br>  Et pour <i><b>laisser</b></i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, len = arr.length; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.261 . //   Chrome: 5.391 .</span></span></code> </pre> <br>  En voyant ces chiffres, il semblerait, on peut affirmer sans √©quivoque que <i><b>les</b></i> publicit√©s d√©passent compl√®tement la vitesse de variation.  Mais, en plus de cette conclusion, la question est rest√©e en suspens: que se passera-t-il si nous mettons <i><b>les</b></i> d√©clarations <i><b>let en</b></i> dehors des boucles <i><b>for</b></i> ? <br><br>  Mais, avant de faire cela, vous devez approfondir le travail de la boucle <i><b>for</b></i> , guid√© par la sp√©cification actuelle d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><i>ECMAScript 2019 (ECMA-262)</i></a> : <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>Runtime Semantics: LabelledEvaluation With parameter labelSet. IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Expression;Expression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the first Expression is present, then a. Let exprRef be the result of evaluating the first Expression. b. Perform ? GetValue(exprRef). <span class="hljs-number"><span class="hljs-number">2</span></span>. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, ¬´ ¬ª, labelSet). IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(varVariableDeclarationList;Expression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. Let varDcl be the result of evaluating VariableDeclarationList. <span class="hljs-number"><span class="hljs-number">2</span></span>. ReturnIfAbrupt(varDcl). <span class="hljs-number"><span class="hljs-number">3</span></span>. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, ¬´ ¬ª, labelSet). IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(LexicalDeclarationExpression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. Let oldEnv be the running execution context's LexicalEnvironment. <span class="hljs-number"><span class="hljs-number">2</span></span>. Let loopEnv be NewDeclarativeEnvironment(oldEnv). <span class="hljs-number"><span class="hljs-number">3</span></span>. Let loopEnvRec be loopEnv's EnvironmentRecord. <span class="hljs-number"><span class="hljs-number">4</span></span>. Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">5</span></span>. Let boundNames be the BoundNames of LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">6</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element dn of boundNames, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> isConst is true, then i. Perform ! loopEnvRec.CreateImmutableBinding(dn, true). b. <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span>, i. Perform ! loopEnvRec.CreateMutableBinding(dn, false). <span class="hljs-number"><span class="hljs-number">7</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to loopEnv. <span class="hljs-number"><span class="hljs-number">8</span></span>. Let forDcl be the result of evaluating LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">9</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> forDcl is an abrupt completion, then a. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to oldEnv. b. Return Completion(forDcl). <span class="hljs-number"><span class="hljs-number">10</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be ¬´ ¬ª. <span class="hljs-number"><span class="hljs-number">11</span></span>. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet). <span class="hljs-number"><span class="hljs-number">12</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to oldEnv. <span class="hljs-number"><span class="hljs-number">13</span></span>. Return Completion(bodyResult).</code> </pre>  <i>Remarque: les deux-points apr√®s IterationStatements, dans la source ne sont pas encadr√©s par des apostrophes - sont ajout√©s ici afin qu'il n'y ait pas de formatage automatique qui g√¢che √† peu pr√®s la lisibilit√© du texte.</i> <br><br>  Ici, comme nous le voyons, il y a trois options pour appeler et poursuivre le travail de la boucle <i><b>for</b></i> : <br><ul><li>  avec <i>instruction for (Expression; Expression; Expression)</i> <br>  <i><b>ForBodyEvaluation</b> (la deuxi√®me expression, la troisi√®me expression, instruction, "", labelSet)</i> . </li><li>  avec l' <i>instruction <b>for</b> (varVariableDeclarationList; Expression; Expression)</i> <br>  <i><b>ForBodyEvaluation</b> (la premi√®re expression, la deuxi√®me expression, instruction, "", labelSet).</i> </li><li>  at <i><b>for</b> (LexicalDeclarationExpression; Expression), instruction</i> <br>  <i><b>ForBodyEvaluation</b> (la premi√®re expression, la deuxi√®me expression, instruction, perIterationLets, labelSet)</i> </li></ul><br>  Dans la derni√®re, troisi√®me variante, contrairement aux deux premi√®res, le quatri√®me param√®tre n'est pas vide - <i><b>perIterationLets</b></i> - ce sont en fait les m√™mes d√©clarations <i><b>let</b></i> dans le premier param√®tre pass√© √† la boucle <i><b>for</b></i> .  Ils sont sp√©cifi√©s au paragraphe 10: <br>  <i>- Si <b>isConst</b> est <b>faux</b> , laissez <b>perIterationLets</b> √™tre boundNames;</i>  <i>sinon laissez perIterationLets √™tre "".</i> <br>  Si une constante a √©t√© pass√©e √† <i><b>for</b></i> , mais pas une variable, le param√®tre <i><b>perIterationLets</b></i> devient vide. <br><br>  De plus, dans la troisi√®me option, il est n√©cessaire de pr√™ter attention au paragraphe 2: <br>  <i>- Laissez loopEnv √™tre <b>NewDeclarativeEnvironment</b> (oldEnv).</i> <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">8</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>NewDeclarativeEnvironment ( E ) When the abstract operation NewDeclarativeEnvironment is called with a Lexical Environment as argument E the following steps are performed: <span class="hljs-number"><span class="hljs-number">1</span></span>. Let env be a new Lexical Environment. <span class="hljs-number"><span class="hljs-number">2</span></span>. Let envRec be a new declarative Environment Record containing no bindings. <span class="hljs-number"><span class="hljs-number">3</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> env's EnvironmentRecord to envRec. <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the outer lexical environment reference of env to E. <span class="hljs-number"><span class="hljs-number">5</span></span>. Return env.</code> </pre> <br>  Ici, en tant que param√®tre <i><b>E</b></i> , l'environnement √† partir duquel la boucle <i><b>for a</b></i> √©t√© appel√©e (global, n'importe quelle fonction, etc.) est pris, et un nouvel environnement est cr√©√© pour ex√©cuter la boucle <i><b>for</b></i> en r√©f√©rence √† l'environnement externe qui l'a cr√©√©e (point 4).  Nous sommes int√©ress√©s par ce fait car l'environnement est un contexte d'ex√©cution. <br><br>  Et nous nous souvenons que les d√©clarations de variables <i><b>let</b></i> et <i><b>const</b></i> sont li√©es contextuellement au bloc dans lequel elles sont d√©clar√©es. <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">14</span></span>Runtime Semantics: BlockDeclarationInstantiation ( code, env ) Note When a Block or CaseBlock is evaluated a new declarative Environment Record is created and bindings <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each block scoped variable, constant, function, or class declared <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the block are instantiated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the Environment Record. BlockDeclarationInstantiation is performed as follows using arguments code and env. code is the Parse Node corresponding to the body of the block. env is the Lexical Environment <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> which bindings are to be created. <span class="hljs-number"><span class="hljs-number">1</span></span>. Let envRec be env's EnvironmentRecord. <span class="hljs-number"><span class="hljs-number">2</span></span>. Assert: envRec is a declarative Environment Record. <span class="hljs-number"><span class="hljs-number">3</span></span>. Let declarations be the LexicallyScopedDeclarations of code. <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> declarations, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element dn of the BoundNames of d, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> IsConstantDeclaration of d is true, then <span class="hljs-number"><span class="hljs-number">1</span></span>. Perform ! envRec.CreateImmutableBinding(dn, true). ii. <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>. Perform ! envRec.CreateMutableBinding(dn, false). b. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> d is a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration, then i. Let fn be the sole element of the BoundNames of d. ii. Let fo be the result of performing InstantiateFunctionObject <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d with argument env. iii. Perform envRec.InitializeBinding(fn, fo).</code> </pre> <br>  Remarque: comme dans les deux premi√®res variantes de l'appel de la boucle <i><b>for</b></i> , il n'y avait pas de telles d√©clarations, il n'√©tait pas n√©cessaire de cr√©er un nouvel environnement pour elles. <br><br>  Nous allons plus loin et consid√©rons ce qu'est <i><b>ForBodyEvaluation</b></i> : <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">8</span></span>Runtime Semantics: ForBodyEvaluation ( test, increment, stmt, perIterationBindings, labelSet ) The abstract operation ForBodyEvaluation with arguments test, increment, stmt, perIterationBindings, and labelSet is performed as follows: <span class="hljs-number"><span class="hljs-number">1</span></span>. Let V be undefined. <span class="hljs-number"><span class="hljs-number">2</span></span>. Perform ? CreatePerIterationEnvironment(perIterationBindings). <span class="hljs-number"><span class="hljs-number">3</span></span>. Repeat, a. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> test is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> [empty], then i. Let testRef be the result of evaluating test. ii. Let testValue be ? GetValue(testRef). iii. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> ToBoolean(testValue) is false, return NormalCompletion(V). b. Let result be the result of evaluating stmt. c. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> LoopContinues(result, labelSet) is false, return Completion(UpdateEmpty(result, V)). d. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> result.[[Value]] is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty, <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> V to result.[[Value]]. e. Perform ? CreatePerIterationEnvironment(perIterationBindings). f. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> increment is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> [empty], then i. Let incRef be the result of evaluating increment. ii. Perform ? GetValue(incRef).</code> </pre> <br>  √Ä quoi vous devez d'abord faire attention: <br><ul><li>  description des param√®tres entrants: <br><ul><li>  <i><b>test</b></i> : expression v√©rifi√©e pour la v√©rit√© avant la prochaine it√©ration du corps de boucle (par exemple: <i><b>i &lt;len</b></i> ); </li><li>  <i><b>increment</b></i> : expression √©valu√©e au d√©but de chaque nouvelle it√©ration (sauf la premi√®re) (par exemple: <i><b>i ++</b></i> ); </li><li>  <i><b>stmt</b></i> : corps de boucle </li><li>  <i><b>perIterationBindings</b></i> : variables d√©clar√©es avec <i><b>let</b></i> dans le premier param√®tre <i><b>for</b></i> (par exemple: <i><b>let i = 0 || let i || let i, j</b></i> ); </li><li>  <i><b>labelSet</b></i> : √©tiquette de la boucle; </li></ul></li><li>  point 2: ici, si le param√®tre non vide <i><b>perIterationBindings est pass√©</b></i> , un deuxi√®me environnement est cr√©√© pour effectuer le passage initial de la boucle; </li><li>  paragraphe 3.a: v√©rification d'une condition donn√©e pour poursuivre l'ex√©cution du cycle; </li><li>  clause 3.b: ex√©cution du corps de cycle; </li><li>  point 3.e: cr√©er un nouvel environnement. </li></ul><br>  Eh bien, et, directement, l'algorithme pour cr√©er des environnements internes de la boucle <i><b>for</b></i> : <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">9</span></span>Runtime Semantics: CreatePerIterationEnvironment ( perIterationBindings ) <span class="hljs-number"><span class="hljs-number">1</span></span>. The abstract operation CreatePerIterationEnvironment with argument perIterationBindings is performed as follows: <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> perIterationBindings has any elements, then a. Let lastIterationEnv be the running execution context's LexicalEnvironment. b. Let lastIterationEnvRec be lastIterationEnv's EnvironmentRecord. c. Let outer be lastIterationEnv's outer environment reference. d. Assert: outer is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> null. e. Let thisIterationEnv be NewDeclarativeEnvironment(outer). f. Let thisIterationEnvRec be thisIterationEnv's EnvironmentRecord. g. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element bn of perIterationBindings, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i. Perform ! thisIterationEnvRec.CreateMutableBinding(bn, false). ii. Let lastValue be ? lastIterationEnvRec.GetBindingValue(bn, true). iii. Perform thisIterationEnvRec.InitializeBinding(bn, lastValue). h. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to thisIterationEnv. <span class="hljs-number"><span class="hljs-number">2</span></span>. Return undefined.</code> </pre> <br>  Comme nous pouvons le voir, le premier paragraphe v√©rifie la pr√©sence de tout √©l√©ment dans le param√®tre pass√©, et le paragraphe 1 n'est effectu√© que s'il y a des annonces <i><b>let</b></i> .  Tous les nouveaux environnements sont cr√©√©s en r√©f√©rence au m√™me contexte externe et prennent les derni√®res valeurs de l'it√©ration pr√©c√©dente (environnement de travail pr√©c√©dent) comme nouvelles liaisons de variables <i><b>let</b></i> . <br><br>  √Ä titre d'exemple, consid√©rons une expression similaire: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { arr.push(i); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br>  Et voici comment il peut √™tre d√©compos√© sans utiliser <i><b>for</b></i> (avec une certaine conventionnalit√©): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = []; <span class="hljs-comment"><span class="hljs-comment">//    { let i = 0; //     for } //   ,   { let i = 0; //    i    if (i &lt; 3) arr.push(i); } //    { let i = 0; //    i    i++; if (i &lt; 3) arr.push(i); } //    { let i = 1; //    i    i++; if (i &lt; 3) arr.push(i); } //    { let i = 2; //    i    i++; if (i &lt; 3) arr.push(i); } console.log(arr); // Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br>  En fait, nous arrivons √† la conclusion que pour chaque contexte, et ici nous en avons cinq, nous faisons de nouvelles liaisons pour <i><b>les</b></i> variables <i><b>let</b></i> d√©clar√©es comme premier param√®tre de <i><b>for</b></i> (important: cela ne s'applique pas aux d√©clarations <i><b>let</b></i> directement dans le corps de la boucle). <br><br>  Voici √† quoi ressemble, par exemple, cette boucle lors de l'utilisation de <i><b>var</b></i> lorsqu'il n'y a pas de liaisons suppl√©mentaires: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr2 = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br>  Et nous pouvons arriver √† une conclusion apparemment logique que si, pendant l'ex√©cution de nos boucles, il n'est pas n√©cessaire de cr√©er des liaisons distinctes pour chaque it√©ration ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus sur les situations dans lesquelles cela, au contraire, peut avoir du sens</a> ), nous devons faire la d√©claration des variables incr√©mentielles avant avec une boucle <i><b>for</b></i> , qui devrait nous √©viter de cr√©er et de supprimer un grand nombre de contextes et, en th√©orie, d'am√©liorer les performances. <br><br>  Essayons de le faire, en utilisant le m√™me tri d'un tableau de 100 000 √©l√©ments comme exemple, et pour des raisons de beaut√©, nous faisons √©galement la d√©finition de toutes les autres variables avant <i><b>pour</b></i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 34.246 . //   Chrome: 10.803 .</span></span></code> </pre> <br>  R√©sultat inattendu ... Tout le contraire de ce qui √©tait attendu, pour √™tre pr√©cis.  Le inconv√©nient de <i><b>Firefox</b></i> dans ce test est particuli√®rement frappant. <br><br>  Ok  Cela n'a pas fonctionn√©, retournons la d√©claration des variables <i><b>i</b></i> et <i><b>j</b></i> aux param√®tres des cycles correspondants: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 6.575 . //   Chrome: 6.749 .</span></span></code> </pre> <br>  Hm.  Il semblerait, techniquement, que la seule diff√©rence entre le dernier exemple et l'exemple au d√©but de l'article soit les d√©clarations faites des variables <i><b>min, mini</b></i> et <i><b>len en</b></i> dehors de la boucle <i><b>for</b></i> , et bien que la diff√©rence soit toujours contextuelle, elle n'est pas tr√®s int√©ressante pour nous maintenant, et, en plus nous nous sommes d√©barrass√©s de la n√©cessit√© de d√©clarer ces variables 99 999 fois dans le corps du cycle de niveau sup√©rieur, ce qui, en th√©orie, devrait augmenter la productivit√© plut√¥t que la r√©duire de plus d'une seconde. <br><br>  Autrement dit, il s'av√®re qu'en quelque sorte, travailler avec des variables d√©clar√©es dans le param√®tre ou le corps de la boucle <i><b>for</b></i> se produit beaucoup plus rapidement qu'en dehors de celui-ci. <br><br>  Mais, nous ne semblions pas voir d'instructions ¬´turbo¬ª dans la sp√©cification de la boucle <i><b>for</b></i> qui pourraient nous conduire √† une telle id√©e.  Par cons√©quent, ce ne sont pas les sp√©cificit√©s du travail de la boucle <i><b>for en</b></i> particulier, mais autre chose ... Par exemple, les caract√©ristiques des d√©clarations <i><b>let</b></i> : quelle est la principale caract√©ristique qui distingue <i><b>let</b></i> de <i><b>var</b></i> ?  Contexte d'ex√©cution des blocs!  Et dans nos deux derniers exemples, nous avons utilis√© des publicit√©s en dehors du bloc.  Mais, que se passe-t-il si au lieu de d√©placer ces d√©clarations vers <i><b>for,</b></i> nous s√©lectionnons simplement un bloc s√©par√© pour elles? <br><br><pre> <code class="javascript hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.262 . //   Chrome: 5.405 .</span></span></code> </pre> <br>  Voila!  Il s'av√®re que le hic, c'est <i><b>que les</b></i> annonces de <i><b>location ont</b></i> eu lieu dans un contexte mondial, et d√®s que nous leur avons allou√© un bloc distinct, tous les probl√®mes ont disparu l√†. <br><br>  Et ici, il serait bon de rappeler une autre fa√ßon, l√©g√®rement injustifi√©e, de d√©clarer des variables - <i><b>var</b></i> . <br><br>  Dans l'exemple au d√©but de l'article, le temps de tri √† l'aide de <i><b>var a</b></i> montr√© un r√©sultat extr√™mement d√©plorable par rapport √† <i><b>let</b></i> .  Mais, si vous regardez de plus pr√®s cet exemple, vous pouvez constater que, comme <i><b>var</b></i> n'avait pas de liaisons de blocs de variables, le contexte r√©el des variables √©tait global.  Et nous, sur l'exemple de <i><b>let</b></i> , avons d√©j√† d√©couvert comment cela peut affecter les performances (et, ce qui est typique, lorsque vous utilisez <i><b>let</b></i> , le rabattement de la vitesse s'est av√©r√© √™tre plus fort que dans le cas de <i><b>var</b></i> , en particulier dans <i><b>Firefox</b></i> ).  Par cons√©quent, pour √™tre juste, nous allons ex√©cuter un exemple avec <i><b>var</b></i> cr√©ant un nouveau contexte pour les variables: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } test(); <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.255 . //   Chrome: 5.411 .</span></span></code> </pre> <br>  Et, nous avons obtenu le r√©sultat presque identique √† ce qui √©tait lors de l'utilisation de <i><b>let</b></i> . <br><br>  Enfin, v√©rifions si le ralentissement se produit en lisant la variable globale sans changer sa valeur. <br><br>  <i><b>laisse</b></i> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.262 . //   Chrome: 5.391 .</span></span></code> </pre> <br>  <i><b>var</b></i> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> len = arr.length; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j, min, mini; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } test(); <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.258 . //   Chrome: 5.439 .</span></span></code> </pre> <br>  Les r√©sultats indiquent que la lecture de la variable globale n'a pas affect√© le temps d'ex√©cution. <br><br><h3>  Pour r√©sumer </h3><br><ol><li>  Changer les variables globales est beaucoup plus lent que changer les variables locales.  En tenant compte de cela, il est possible d'optimiser le code dans des situations appropri√©es en cr√©ant un bloc ou une fonction s√©par√©e, y compris pour d√©clarer des variables, au lieu d'ex√©cuter une partie du code dans un contexte global.  Oui, dans presque tous les manuels, vous pouvez trouver des recommandations pour cr√©er le moins de liaisons globales possible, mais g√©n√©ralement, seul un encrassement de l'espace de noms global est indiqu√© comme raison, et pas un mot sur les probl√®mes de performances possibles. </li><li>  Malgr√© le fait que l'ex√©cution de boucles avec une d√©claration <i><b>let</b></i> dans le premier param√®tre <i><b>for</b></i> cr√©e un grand nombre d'environnements, cela n'a presque aucun effet sur les performances, contrairement aux situations o√π nous prenons de telles d√©clarations en dehors du bloc.  N√©anmoins, il ne faut pas exclure la possibilit√© de l'existence de situations exotiques lorsque ce facteur affectera plus significativement la productivit√©. </li><li>  Les performances des variables <i><b>var</b></i> ne sont toujours pas inf√©rieures √† celles des variables <i><b>let</b></i> , cependant, elles ne les d√©passent pas (encore une fois, dans le cas g√©n√©ral), ce qui nous am√®ne √† la conclusion suivante qu'il n'y a aucune raison d'utiliser les d√©clarations <i><b>var</b></i> sauf √† des fins de compatibilit√©.  Cependant, s'il est n√©cessaire de manipuler des variables globales en changeant leurs valeurs, la variante avec <i><b>var</b></i> en termes de performances sera pr√©f√©rable (au moins pour le moment, si, en particulier, on suppose que le script peut √©galement √™tre ex√©cut√© sur le moteur Gecko). </li></ol><br><h4>  Les r√©f√©rences </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ECMAScript 2019 (ECMA-262)</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation des d√©clarations let des variables et des fonctionnalit√©s des fermetures r√©sultantes en JavaScript</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469523/">https://habr.com/ru/post/fr469523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469505/index.html">3 fa√ßons pratiques d'amener les entreprises sur les march√©s √©trangers: approches et techniques de vraies entreprises</a></li>
<li><a href="../fr469507/index.html">Troisi√®me vuln√©rabilit√© du client Steam Windows, mais pas 0day</a></li>
<li><a href="../fr469509/index.html">Sch√©mas angulaires, ou comment j'ai √©crit mon mod√®le pour cli angulaire</a></li>
<li><a href="../fr469515/index.html">Pr√©paration de l'application pour Istio</a></li>
<li><a href="../fr469521/index.html">J'ai achet√© une moto pour rouler, pas pour tomber</a></li>
<li><a href="../fr469525/index.html">Syst√®me de contr√¥le automatis√© pour une pelle mini√®re</a></li>
<li><a href="../fr469527/index.html">L'interphone est-il une oreille d'espion?</a></li>
<li><a href="../fr469529/index.html">Le rendu de texte vous d√©teste</a></li>
<li><a href="../fr469531/index.html">"Comparer les langages de programmation sur une base meilleure-pire est une occupation compl√®tement idiote."</a></li>
<li><a href="../fr469533/index.html">Probl√®mes et menaces d'identification biom√©trique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>