<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🔧 🧜🏿 👨🏼‍⚕️ Dépendance des performances du code sur le contexte de la déclaration des variables en JavaScript 🧕🏾 🕉️ 👆🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Initialement, cet article a été conçu comme une petite référence pour son propre usage, et en général il n'était pas prévu d'être un article, cependan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dépendance des performances du code sur le contexte de la déclaration des variables en JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469523/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/cx/hu/udcxhuvjpmyigj19lmdrz8ojyja.jpeg"></div><br>  Initialement, cet article a été conçu comme une petite référence pour son propre usage, et en général il n'était pas prévu d'être un article, cependant, dans le processus de prise de mesures, certaines fonctionnalités intéressantes sont apparues dans la mise en œuvre de l'architecture <i><b>JavaScript</b></i> qui affectent fortement les performances du code final dans certains cas.  Je suggère, et vous, de vous familiariser avec les résultats obtenus, en passant également en revue certains sujets connexes: <i><b>pour les</b></i> boucles, l'environnement (contexte d'exécution) et les blocs. <br><br><a name="habracut"></a>  À la fin de mon article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Utilisation des déclarations de variables let et des fonctionnalités des fermetures JavaScript résultantes»,</a> j'ai brièvement abordé la comparaison des performances des déclarations de variables <i><b>let (LexicalDeclaration)</b></i> et <i><b>var (VarDeclaredNames)</b></i> en boucles.  À titre de comparaison, nous avons utilisé le temps d'exécution du tri manuel (sans l'aide de <i><b>Array.prototype.sort ()</b></i> ) du tableau, l'une des méthodes les plus simples est le tri par sélection, car avec une longueur de tableau de 100000, nous avons obtenu un peu plus de 5 milliards.  itérations en deux cycles (externe et imbriqué), et, ce montant devrait permettre au final une estimation adéquate. <br><br>  Pour <i><b>var,</b></i> il triait la vue: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, len = arr.length; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 9.082 . //   Chrome: 10.783 .</span></span></code> </pre> <br>  Et pour <i><b>laisser</b></i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, len = arr.length; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.261 . //   Chrome: 5.391 .</span></span></code> </pre> <br>  En voyant ces chiffres, il semblerait, on peut affirmer sans équivoque que <i><b>les</b></i> publicités dépassent complètement la vitesse de variation.  Mais, en plus de cette conclusion, la question est restée en suspens: que se passera-t-il si nous mettons <i><b>les</b></i> déclarations <i><b>let en</b></i> dehors des boucles <i><b>for</b></i> ? <br><br>  Mais, avant de faire cela, vous devez approfondir le travail de la boucle <i><b>for</b></i> , guidé par la spécification actuelle d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><i>ECMAScript 2019 (ECMA-262)</i></a> : <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>Runtime Semantics: LabelledEvaluation With parameter labelSet. IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Expression;Expression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the first Expression is present, then a. Let exprRef be the result of evaluating the first Expression. b. Perform ? GetValue(exprRef). <span class="hljs-number"><span class="hljs-number">2</span></span>. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet). IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(varVariableDeclarationList;Expression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. Let varDcl be the result of evaluating VariableDeclarationList. <span class="hljs-number"><span class="hljs-number">2</span></span>. ReturnIfAbrupt(varDcl). <span class="hljs-number"><span class="hljs-number">3</span></span>. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet). IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(LexicalDeclarationExpression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. Let oldEnv be the running execution context's LexicalEnvironment. <span class="hljs-number"><span class="hljs-number">2</span></span>. Let loopEnv be NewDeclarativeEnvironment(oldEnv). <span class="hljs-number"><span class="hljs-number">3</span></span>. Let loopEnvRec be loopEnv's EnvironmentRecord. <span class="hljs-number"><span class="hljs-number">4</span></span>. Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">5</span></span>. Let boundNames be the BoundNames of LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">6</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element dn of boundNames, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> isConst is true, then i. Perform ! loopEnvRec.CreateImmutableBinding(dn, true). b. <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span>, i. Perform ! loopEnvRec.CreateMutableBinding(dn, false). <span class="hljs-number"><span class="hljs-number">7</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to loopEnv. <span class="hljs-number"><span class="hljs-number">8</span></span>. Let forDcl be the result of evaluating LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">9</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> forDcl is an abrupt completion, then a. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to oldEnv. b. Return Completion(forDcl). <span class="hljs-number"><span class="hljs-number">10</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be « ». <span class="hljs-number"><span class="hljs-number">11</span></span>. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet). <span class="hljs-number"><span class="hljs-number">12</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to oldEnv. <span class="hljs-number"><span class="hljs-number">13</span></span>. Return Completion(bodyResult).</code> </pre>  <i>Remarque: les deux-points après IterationStatements, dans la source ne sont pas encadrés par des apostrophes - sont ajoutés ici afin qu'il n'y ait pas de formatage automatique qui gâche à peu près la lisibilité du texte.</i> <br><br>  Ici, comme nous le voyons, il y a trois options pour appeler et poursuivre le travail de la boucle <i><b>for</b></i> : <br><ul><li>  avec <i>instruction for (Expression; Expression; Expression)</i> <br>  <i><b>ForBodyEvaluation</b> (la deuxième expression, la troisième expression, instruction, "", labelSet)</i> . </li><li>  avec l' <i>instruction <b>for</b> (varVariableDeclarationList; Expression; Expression)</i> <br>  <i><b>ForBodyEvaluation</b> (la première expression, la deuxième expression, instruction, "", labelSet).</i> </li><li>  at <i><b>for</b> (LexicalDeclarationExpression; Expression), instruction</i> <br>  <i><b>ForBodyEvaluation</b> (la première expression, la deuxième expression, instruction, perIterationLets, labelSet)</i> </li></ul><br>  Dans la dernière, troisième variante, contrairement aux deux premières, le quatrième paramètre n'est pas vide - <i><b>perIterationLets</b></i> - ce sont en fait les mêmes déclarations <i><b>let</b></i> dans le premier paramètre passé à la boucle <i><b>for</b></i> .  Ils sont spécifiés au paragraphe 10: <br>  <i>- Si <b>isConst</b> est <b>faux</b> , laissez <b>perIterationLets</b> être boundNames;</i>  <i>sinon laissez perIterationLets être "".</i> <br>  Si une constante a été passée à <i><b>for</b></i> , mais pas une variable, le paramètre <i><b>perIterationLets</b></i> devient vide. <br><br>  De plus, dans la troisième option, il est nécessaire de prêter attention au paragraphe 2: <br>  <i>- Laissez loopEnv être <b>NewDeclarativeEnvironment</b> (oldEnv).</i> <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">8</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>NewDeclarativeEnvironment ( E ) When the abstract operation NewDeclarativeEnvironment is called with a Lexical Environment as argument E the following steps are performed: <span class="hljs-number"><span class="hljs-number">1</span></span>. Let env be a new Lexical Environment. <span class="hljs-number"><span class="hljs-number">2</span></span>. Let envRec be a new declarative Environment Record containing no bindings. <span class="hljs-number"><span class="hljs-number">3</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> env's EnvironmentRecord to envRec. <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the outer lexical environment reference of env to E. <span class="hljs-number"><span class="hljs-number">5</span></span>. Return env.</code> </pre> <br>  Ici, en tant que paramètre <i><b>E</b></i> , l'environnement à partir duquel la boucle <i><b>for a</b></i> été appelée (global, n'importe quelle fonction, etc.) est pris, et un nouvel environnement est créé pour exécuter la boucle <i><b>for</b></i> en référence à l'environnement externe qui l'a créée (point 4).  Nous sommes intéressés par ce fait car l'environnement est un contexte d'exécution. <br><br>  Et nous nous souvenons que les déclarations de variables <i><b>let</b></i> et <i><b>const</b></i> sont liées contextuellement au bloc dans lequel elles sont déclarées. <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">14</span></span>Runtime Semantics: BlockDeclarationInstantiation ( code, env ) Note When a Block or CaseBlock is evaluated a new declarative Environment Record is created and bindings <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each block scoped variable, constant, function, or class declared <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the block are instantiated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the Environment Record. BlockDeclarationInstantiation is performed as follows using arguments code and env. code is the Parse Node corresponding to the body of the block. env is the Lexical Environment <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> which bindings are to be created. <span class="hljs-number"><span class="hljs-number">1</span></span>. Let envRec be env's EnvironmentRecord. <span class="hljs-number"><span class="hljs-number">2</span></span>. Assert: envRec is a declarative Environment Record. <span class="hljs-number"><span class="hljs-number">3</span></span>. Let declarations be the LexicallyScopedDeclarations of code. <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> declarations, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element dn of the BoundNames of d, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> IsConstantDeclaration of d is true, then <span class="hljs-number"><span class="hljs-number">1</span></span>. Perform ! envRec.CreateImmutableBinding(dn, true). ii. <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>. Perform ! envRec.CreateMutableBinding(dn, false). b. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> d is a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration, then i. Let fn be the sole element of the BoundNames of d. ii. Let fo be the result of performing InstantiateFunctionObject <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d with argument env. iii. Perform envRec.InitializeBinding(fn, fo).</code> </pre> <br>  Remarque: comme dans les deux premières variantes de l'appel de la boucle <i><b>for</b></i> , il n'y avait pas de telles déclarations, il n'était pas nécessaire de créer un nouvel environnement pour elles. <br><br>  Nous allons plus loin et considérons ce qu'est <i><b>ForBodyEvaluation</b></i> : <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">8</span></span>Runtime Semantics: ForBodyEvaluation ( test, increment, stmt, perIterationBindings, labelSet ) The abstract operation ForBodyEvaluation with arguments test, increment, stmt, perIterationBindings, and labelSet is performed as follows: <span class="hljs-number"><span class="hljs-number">1</span></span>. Let V be undefined. <span class="hljs-number"><span class="hljs-number">2</span></span>. Perform ? CreatePerIterationEnvironment(perIterationBindings). <span class="hljs-number"><span class="hljs-number">3</span></span>. Repeat, a. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> test is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> [empty], then i. Let testRef be the result of evaluating test. ii. Let testValue be ? GetValue(testRef). iii. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> ToBoolean(testValue) is false, return NormalCompletion(V). b. Let result be the result of evaluating stmt. c. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> LoopContinues(result, labelSet) is false, return Completion(UpdateEmpty(result, V)). d. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> result.[[Value]] is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty, <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> V to result.[[Value]]. e. Perform ? CreatePerIterationEnvironment(perIterationBindings). f. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> increment is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> [empty], then i. Let incRef be the result of evaluating increment. ii. Perform ? GetValue(incRef).</code> </pre> <br>  À quoi vous devez d'abord faire attention: <br><ul><li>  description des paramètres entrants: <br><ul><li>  <i><b>test</b></i> : expression vérifiée pour la vérité avant la prochaine itération du corps de boucle (par exemple: <i><b>i &lt;len</b></i> ); </li><li>  <i><b>increment</b></i> : expression évaluée au début de chaque nouvelle itération (sauf la première) (par exemple: <i><b>i ++</b></i> ); </li><li>  <i><b>stmt</b></i> : corps de boucle </li><li>  <i><b>perIterationBindings</b></i> : variables déclarées avec <i><b>let</b></i> dans le premier paramètre <i><b>for</b></i> (par exemple: <i><b>let i = 0 || let i || let i, j</b></i> ); </li><li>  <i><b>labelSet</b></i> : étiquette de la boucle; </li></ul></li><li>  point 2: ici, si le paramètre non vide <i><b>perIterationBindings est passé</b></i> , un deuxième environnement est créé pour effectuer le passage initial de la boucle; </li><li>  paragraphe 3.a: vérification d'une condition donnée pour poursuivre l'exécution du cycle; </li><li>  clause 3.b: exécution du corps de cycle; </li><li>  point 3.e: créer un nouvel environnement. </li></ul><br>  Eh bien, et, directement, l'algorithme pour créer des environnements internes de la boucle <i><b>for</b></i> : <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">9</span></span>Runtime Semantics: CreatePerIterationEnvironment ( perIterationBindings ) <span class="hljs-number"><span class="hljs-number">1</span></span>. The abstract operation CreatePerIterationEnvironment with argument perIterationBindings is performed as follows: <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> perIterationBindings has any elements, then a. Let lastIterationEnv be the running execution context's LexicalEnvironment. b. Let lastIterationEnvRec be lastIterationEnv's EnvironmentRecord. c. Let outer be lastIterationEnv's outer environment reference. d. Assert: outer is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> null. e. Let thisIterationEnv be NewDeclarativeEnvironment(outer). f. Let thisIterationEnvRec be thisIterationEnv's EnvironmentRecord. g. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element bn of perIterationBindings, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i. Perform ! thisIterationEnvRec.CreateMutableBinding(bn, false). ii. Let lastValue be ? lastIterationEnvRec.GetBindingValue(bn, true). iii. Perform thisIterationEnvRec.InitializeBinding(bn, lastValue). h. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to thisIterationEnv. <span class="hljs-number"><span class="hljs-number">2</span></span>. Return undefined.</code> </pre> <br>  Comme nous pouvons le voir, le premier paragraphe vérifie la présence de tout élément dans le paramètre passé, et le paragraphe 1 n'est effectué que s'il y a des annonces <i><b>let</b></i> .  Tous les nouveaux environnements sont créés en référence au même contexte externe et prennent les dernières valeurs de l'itération précédente (environnement de travail précédent) comme nouvelles liaisons de variables <i><b>let</b></i> . <br><br>  À titre d'exemple, considérons une expression similaire: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { arr.push(i); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br>  Et voici comment il peut être décomposé sans utiliser <i><b>for</b></i> (avec une certaine conventionnalité): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = []; <span class="hljs-comment"><span class="hljs-comment">//    { let i = 0; //     for } //   ,   { let i = 0; //    i    if (i &lt; 3) arr.push(i); } //    { let i = 0; //    i    i++; if (i &lt; 3) arr.push(i); } //    { let i = 1; //    i    i++; if (i &lt; 3) arr.push(i); } //    { let i = 2; //    i    i++; if (i &lt; 3) arr.push(i); } console.log(arr); // Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br>  En fait, nous arrivons à la conclusion que pour chaque contexte, et ici nous en avons cinq, nous faisons de nouvelles liaisons pour <i><b>les</b></i> variables <i><b>let</b></i> déclarées comme premier paramètre de <i><b>for</b></i> (important: cela ne s'applique pas aux déclarations <i><b>let</b></i> directement dans le corps de la boucle). <br><br>  Voici à quoi ressemble, par exemple, cette boucle lors de l'utilisation de <i><b>var</b></i> lorsqu'il n'y a pas de liaisons supplémentaires: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr2 = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br>  Et nous pouvons arriver à une conclusion apparemment logique que si, pendant l'exécution de nos boucles, il n'est pas nécessaire de créer des liaisons distinctes pour chaque itération ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus sur les situations dans lesquelles cela, au contraire, peut avoir du sens</a> ), nous devons faire la déclaration des variables incrémentielles avant avec une boucle <i><b>for</b></i> , qui devrait nous éviter de créer et de supprimer un grand nombre de contextes et, en théorie, d'améliorer les performances. <br><br>  Essayons de le faire, en utilisant le même tri d'un tableau de 100 000 éléments comme exemple, et pour des raisons de beauté, nous faisons également la définition de toutes les autres variables avant <i><b>pour</b></i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 34.246 . //   Chrome: 10.803 .</span></span></code> </pre> <br>  Résultat inattendu ... Tout le contraire de ce qui était attendu, pour être précis.  Le inconvénient de <i><b>Firefox</b></i> dans ce test est particulièrement frappant. <br><br>  Ok  Cela n'a pas fonctionné, retournons la déclaration des variables <i><b>i</b></i> et <i><b>j</b></i> aux paramètres des cycles correspondants: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 6.575 . //   Chrome: 6.749 .</span></span></code> </pre> <br>  Hm.  Il semblerait, techniquement, que la seule différence entre le dernier exemple et l'exemple au début de l'article soit les déclarations faites des variables <i><b>min, mini</b></i> et <i><b>len en</b></i> dehors de la boucle <i><b>for</b></i> , et bien que la différence soit toujours contextuelle, elle n'est pas très intéressante pour nous maintenant, et, en plus nous nous sommes débarrassés de la nécessité de déclarer ces variables 99 999 fois dans le corps du cycle de niveau supérieur, ce qui, en théorie, devrait augmenter la productivité plutôt que la réduire de plus d'une seconde. <br><br>  Autrement dit, il s'avère qu'en quelque sorte, travailler avec des variables déclarées dans le paramètre ou le corps de la boucle <i><b>for</b></i> se produit beaucoup plus rapidement qu'en dehors de celui-ci. <br><br>  Mais, nous ne semblions pas voir d'instructions «turbo» dans la spécification de la boucle <i><b>for</b></i> qui pourraient nous conduire à une telle idée.  Par conséquent, ce ne sont pas les spécificités du travail de la boucle <i><b>for en</b></i> particulier, mais autre chose ... Par exemple, les caractéristiques des déclarations <i><b>let</b></i> : quelle est la principale caractéristique qui distingue <i><b>let</b></i> de <i><b>var</b></i> ?  Contexte d'exécution des blocs!  Et dans nos deux derniers exemples, nous avons utilisé des publicités en dehors du bloc.  Mais, que se passe-t-il si au lieu de déplacer ces déclarations vers <i><b>for,</b></i> nous sélectionnons simplement un bloc séparé pour elles? <br><br><pre> <code class="javascript hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.262 . //   Chrome: 5.405 .</span></span></code> </pre> <br>  Voila!  Il s'avère que le hic, c'est <i><b>que les</b></i> annonces de <i><b>location ont</b></i> eu lieu dans un contexte mondial, et dès que nous leur avons alloué un bloc distinct, tous les problèmes ont disparu là. <br><br>  Et ici, il serait bon de rappeler une autre façon, légèrement injustifiée, de déclarer des variables - <i><b>var</b></i> . <br><br>  Dans l'exemple au début de l'article, le temps de tri à l'aide de <i><b>var a</b></i> montré un résultat extrêmement déplorable par rapport à <i><b>let</b></i> .  Mais, si vous regardez de plus près cet exemple, vous pouvez constater que, comme <i><b>var</b></i> n'avait pas de liaisons de blocs de variables, le contexte réel des variables était global.  Et nous, sur l'exemple de <i><b>let</b></i> , avons déjà découvert comment cela peut affecter les performances (et, ce qui est typique, lorsque vous utilisez <i><b>let</b></i> , le rabattement de la vitesse s'est avéré être plus fort que dans le cas de <i><b>var</b></i> , en particulier dans <i><b>Firefox</b></i> ).  Par conséquent, pour être juste, nous allons exécuter un exemple avec <i><b>var</b></i> créant un nouveau contexte pour les variables: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } test(); <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.255 . //   Chrome: 5.411 .</span></span></code> </pre> <br>  Et, nous avons obtenu le résultat presque identique à ce qui était lors de l'utilisation de <i><b>let</b></i> . <br><br>  Enfin, vérifions si le ralentissement se produit en lisant la variable globale sans changer sa valeur. <br><br>  <i><b>laisse</b></i> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.262 . //   Chrome: 5.391 .</span></span></code> </pre> <br>  <i><b>var</b></i> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> len = arr.length; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j, min, mini; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } test(); <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.258 . //   Chrome: 5.439 .</span></span></code> </pre> <br>  Les résultats indiquent que la lecture de la variable globale n'a pas affecté le temps d'exécution. <br><br><h3>  Pour résumer </h3><br><ol><li>  Changer les variables globales est beaucoup plus lent que changer les variables locales.  En tenant compte de cela, il est possible d'optimiser le code dans des situations appropriées en créant un bloc ou une fonction séparée, y compris pour déclarer des variables, au lieu d'exécuter une partie du code dans un contexte global.  Oui, dans presque tous les manuels, vous pouvez trouver des recommandations pour créer le moins de liaisons globales possible, mais généralement, seul un encrassement de l'espace de noms global est indiqué comme raison, et pas un mot sur les problèmes de performances possibles. </li><li>  Malgré le fait que l'exécution de boucles avec une déclaration <i><b>let</b></i> dans le premier paramètre <i><b>for</b></i> crée un grand nombre d'environnements, cela n'a presque aucun effet sur les performances, contrairement aux situations où nous prenons de telles déclarations en dehors du bloc.  Néanmoins, il ne faut pas exclure la possibilité de l'existence de situations exotiques lorsque ce facteur affectera plus significativement la productivité. </li><li>  Les performances des variables <i><b>var</b></i> ne sont toujours pas inférieures à celles des variables <i><b>let</b></i> , cependant, elles ne les dépassent pas (encore une fois, dans le cas général), ce qui nous amène à la conclusion suivante qu'il n'y a aucune raison d'utiliser les déclarations <i><b>var</b></i> sauf à des fins de compatibilité.  Cependant, s'il est nécessaire de manipuler des variables globales en changeant leurs valeurs, la variante avec <i><b>var</b></i> en termes de performances sera préférable (au moins pour le moment, si, en particulier, on suppose que le script peut également être exécuté sur le moteur Gecko). </li></ol><br><h4>  Les références </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ECMAScript 2019 (ECMA-262)</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation des déclarations let des variables et des fonctionnalités des fermetures résultantes en JavaScript</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469523/">https://habr.com/ru/post/fr469523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469505/index.html">3 façons pratiques d'amener les entreprises sur les marchés étrangers: approches et techniques de vraies entreprises</a></li>
<li><a href="../fr469507/index.html">Troisième vulnérabilité du client Steam Windows, mais pas 0day</a></li>
<li><a href="../fr469509/index.html">Schémas angulaires, ou comment j'ai écrit mon modèle pour cli angulaire</a></li>
<li><a href="../fr469515/index.html">Préparation de l'application pour Istio</a></li>
<li><a href="../fr469521/index.html">J'ai acheté une moto pour rouler, pas pour tomber</a></li>
<li><a href="../fr469525/index.html">Système de contrôle automatisé pour une pelle minière</a></li>
<li><a href="../fr469527/index.html">L'interphone est-il une oreille d'espion?</a></li>
<li><a href="../fr469529/index.html">Le rendu de texte vous déteste</a></li>
<li><a href="../fr469531/index.html">"Comparer les langages de programmation sur une base meilleure-pire est une occupation complètement idiote."</a></li>
<li><a href="../fr469533/index.html">Problèmes et menaces d'identification biométrique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>