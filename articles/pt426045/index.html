<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¥üèº üßíüèø üë©üèº‚Äçüéì Exce√ß√µes especiais no .NET e como prepar√°-las üèÇüèª üìü ‚ÜïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As v√°rias exce√ß√µes no .NET t√™m suas pr√≥prias caracter√≠sticas e pode ser muito √∫til conhec√™-las. Como enganar o CLR? Como permanecer vivo em tempo de e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exce√ß√µes especiais no .NET e como prepar√°-las</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/426045/">  As v√°rias exce√ß√µes no .NET t√™m suas pr√≥prias caracter√≠sticas e pode ser muito √∫til conhec√™-las.  Como enganar o CLR?  Como permanecer vivo em tempo de execu√ß√£o capturando uma StackOverflowException?  Que exce√ß√µes parece imposs√≠vel captar, mas se voc√™ realmente quiser, pode? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f1/314/78d/4f131478de33b4a6acd0ed25a0e53987.png"><br><br>  Sob o corte, a transcri√ß√£o do relat√≥rio de Eugene ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">epeshk</a> ) Peshkov da nossa confer√™ncia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DotNext 2018 Piter</a> , onde ele falou sobre essas e outras caracter√≠sticas das exce√ß√µes. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WLSrYgMWif4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Oi  Meu nome √© Eugene.  Trabalho na SKB Kontur e desenvolvo um sistema de hospedagem e implanto aplicativos para Windows.  O resultado final √© que temos muitas equipes de produtos que escrevem seus pr√≥prios servi√ßos e os hospedam conosco.  Fornecemos a eles uma solu√ß√£o f√°cil e simples para uma variedade de tarefas de infraestrutura.  Por exemplo, para monitorar o consumo de recursos do sistema ou concluir r√©plicas para o servi√ßo. <br><br>  √Äs vezes, os aplicativos hospedados em nosso sistema desmoronam.  Vimos muitas maneiras de como um aplicativo pode falhar em tempo de execu√ß√£o.  Um desses m√©todos √© lan√ßar alguma exce√ß√£o inesperada e encantadora. <br><br>  Hoje vou falar sobre os recursos das exce√ß√µes no .NET.  Encontramos alguns desses recursos na produ√ß√£o e outros no decorrer de experimentos. <br><br><h2>  Planejar </h2><br><ol><li>  Comportamento de exce√ß√£o do .NET <br></li><li>  Manipula√ß√£o de exce√ß√£o do Windows e hacks <br></li></ol><br>  Tudo o que se segue √© verdadeiro para Windows.  Todos os exemplos foram testados na vers√£o mais recente da estrutura completa do .NET 4.7.1.  Tamb√©m haver√° algumas refer√™ncias ao .NET Core. <br><br><h2>  Viola√ß√£o de acesso </h2><br>  Essa exce√ß√£o ocorre durante opera√ß√µes incorretas de mem√≥ria.  Por exemplo, se um aplicativo tentar acessar uma √°rea de mem√≥ria √† qual n√£o tem acesso.  A exce√ß√£o √© de n√≠vel baixo e, geralmente, se isso acontecer, ser√° necess√°ria uma depura√ß√£o muito longa. <br><br>  Vamos tentar obter essa exce√ß√£o usando C #.  Para fazer isso, escreveremos o byte 42 no endere√ßo 1000 (presumimos que 1000 seja um endere√ßo aleat√≥rio e nosso aplicativo provavelmente n√£o tem acesso a ele). <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre> <br>  WriteByte faz exatamente o que precisamos: escreve um byte no endere√ßo fornecido.  Esperamos que esta chamada gere uma AccessViolationException.  Esse c√≥digo realmente lan√ßar√° essa exce√ß√£o, ele poder√° manipular e o aplicativo continuar√° funcionando.  Agora vamos mudar um pouco o c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] {<span class="hljs-number"><span class="hljs-number">42</span></span>}; Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre><br>  Se, em vez de WriteByte, voc√™ usar o m√©todo Copy e copiar o byte 42 para o endere√ßo 1000, usando try-catch, o AccessViolation n√£o poder√° ser capturado.  Ao mesmo tempo, uma mensagem ser√° exibida no console informando que o aplicativo foi encerrado devido a uma AccessViolationException n√£o tratada. <br><br><pre> <code class="cs hljs">Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre><br>  Acontece que temos duas linhas de c√≥digo, enquanto a primeira trava o aplicativo inteiro com o AccessViolation e a segunda gera uma exce√ß√£o processada do mesmo tipo.  Para entender por que isso acontece, veremos como esses m√©todos s√£o organizados por dentro. <br><br>  Vamos come√ßar com o m√©todo Copy. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Copy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">)</span></span> { Marshal.CopyToNative((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>) source, startIndex, destination, length); } [MethodImpl(MethodImplOptions.InternalCall)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyToNative</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, IntPtr destination, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  A √∫nica coisa que o m√©todo Copy faz √© chamar o m√©todo CopyToNative, implementado dentro do .NET.  Se nosso aplicativo ainda travar e ocorrer uma exce√ß√£o em algum lugar, isso s√≥ poder√° ocorrer dentro de CopyToNative.  A partir daqui, podemos fazer a primeira observa√ß√£o: se o c√≥digo .NET chamado c√≥digo nativo e AccessViolation ocorrerem dentro dele, o c√≥digo .NET n√£o poder√° lidar com essa exce√ß√£o por algum motivo. <br><br>  Agora vamos entender por que foi poss√≠vel processar o AccessViolation usando o m√©todo WriteByte.  Vamos dar uma olhada no c√≥digo para este m√©todo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteByte</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { *(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) ptr = val; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NullReferenceException) {     <span class="hljs-comment"><span class="hljs-comment">// this method is documented to throw AccessViolationException on any AV throw new AccessViolationException(); } }</span></span></code> </pre><br>  Este m√©todo √© totalmente implementado no c√≥digo gerenciado.  Ele usa o ponteiro do C # para gravar dados no endere√ßo desejado e tamb√©m captura uma NullReferenceException.  Se o NRE for interceptado, uma AccessViolationException ser√° lan√ßada.  Portanto, √© necess√°rio por causa da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especifica√ß√£o</a> .  Nesse caso, todas as exce√ß√µes lan√ßadas pela constru√ß√£o throw s√£o tratadas.  Portanto, se uma NullReferenceException ocorrer durante a execu√ß√£o do c√≥digo dentro do WriteByte, podemos capturar o AccessViolation.  Poderia ocorrer um NRE, no nosso caso, ao acessar o endere√ßo 1000 em vez do endere√ßo zero? <br><br>  Reescrevemos o c√≥digo usando ponteiros C # diretamente e vemos que, ao acessar um endere√ßo diferente de zero, uma NullReferenceException √© realmente lan√ßada: <br><br><pre> <code class="cs hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) <span class="hljs-number"><span class="hljs-number">1000</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre><br>  Para entender por que isso acontece, precisamos lembrar como a mem√≥ria do processo funciona.  Na mem√≥ria do processo, todos os endere√ßos s√£o virtuais.  Isso significa que o aplicativo possui um grande espa√ßo de endere√ßo e apenas algumas p√°ginas s√£o exibidas na mem√≥ria f√≠sica real.  Mas h√° uma peculiaridade: os primeiros 64 KB de endere√ßos nunca s√£o mapeados para a mem√≥ria f√≠sica e n√£o s√£o fornecidos ao aplicativo.  O Rantime .NET sabe disso e o usa.  Se o AccessViolation ocorreu no c√≥digo gerenciado, o tempo de execu√ß√£o verifica qual endere√ßo na mem√≥ria foi acessado e gera uma exce√ß√£o apropriada.  Para endere√ßos de 0 a 2 ^ 16 - NullReference, para todos os outros - AccessViolation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/775/3d4/38f/7753d438fc8a977ac0bb54e431d81c6f.png"><br><br>  Vamos ver por que o NullReference √© lan√ßado n√£o apenas ao acessar o endere√ßo zero.  Imagine que voc√™ est√° acessando um campo de um objeto de um tipo de refer√™ncia e a refer√™ncia a esse objeto √© nula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/127/a27/867/127a27867ef7a568a242797758855b44.png"><br><br>  Nessa situa√ß√£o, esperamos obter uma NullReferenceException.  O acesso ao campo de um objeto ocorre por deslocamento em rela√ß√£o ao endere√ßo desse objeto.  Acontece que nos voltaremos para um endere√ßo pr√≥ximo do zero (lembre-se de que o link para o objeto original √© zero).  Com esse comportamento de tempo de execu√ß√£o, obtemos a exce√ß√£o esperada sem verifica√ß√£o adicional do endere√ßo do pr√≥prio objeto. <br><br>  Mas o que acontece se nos voltarmos para o campo de um objeto, e esse objeto em si ocupa mais de 64 KB? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/356/897/143/356897143b1275403569dc9f9a71471a.png"><br><br>  Podemos obter o AccessViolation neste caso?  Vamos fazer um experimento.  Vamos criar um objeto muito grande e nos referiremos a seus campos.  Um campo no in√≠cio do objeto, o segundo no final: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08d/619/95a/08d61995a01630f94f31f759890af4a8.png"><br><br>  Ambos os m√©todos lan√ßar√£o uma NullReferenceException.  Nenhuma AccessViolationException ocorrer√°. <br>  Vejamos as instru√ß√µes que ser√£o geradas para esses m√©todos.  No segundo caso, o compilador JIT adicionou uma instru√ß√£o cmp adicional que acessa o endere√ßo do pr√≥prio objeto, chamando AccessViolation com um endere√ßo zero, que ser√° convertido pelo tempo de execu√ß√£o em um NullReferenceException. <br><br>  Vale ressaltar que, para este experimento, n√£o √© suficiente usar uma matriz como um objeto grande.  Porque  Deixe essa pergunta para o leitor, escreva id√©ias nos coment√°rios :) <br><br>  Vamos resumir os experimentos com o AccessViolation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffa/86b/0a8/ffa86b0a85f29a16936c92845f5d3e1e.png"><br><br>  AccessViolationException se comporta de maneira diferente dependendo de onde a exce√ß√£o ocorreu (no c√≥digo gerenciado ou no nativo).  Al√©m disso, se uma exce√ß√£o ocorreu no c√≥digo gerenciado, o endere√ßo do objeto ser√° verificado. <br><br>  A quest√£o √©: podemos lidar com uma AccessViolationException que ocorreu no c√≥digo nativo ou no c√≥digo gerenciado, mas n√£o convertido em NullReference e n√£o lan√ßado usando throw?  √Äs vezes, esse √© um recurso √∫til, especialmente ao trabalhar com c√≥digo n√£o seguro.  A resposta a esta pergunta depende da vers√£o do .NET. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/67a/785/318/67a785318bc8b5f084a3b23fa36e766b.png"><br><br>  No .NET 1.0, n√£o havia AccessViolationException.  Todos os links foram considerados v√°lidos ou nulos.  Na √©poca do .NET 2.0, ficou claro que, sem o trabalho direto com a mem√≥ria - de jeito nenhum, o AccessViolation aparecia enquanto era process√°vel.  No 4.0 e acima, ele ainda era pratic√°vel, mas o processamento n√£o √© t√£o simples.  Para capturar essa exce√ß√£o, agora voc√™ precisa marcar o m√©todo no qual o bloco catch est√° localizado com o atributo HandleProcessCorruptedStateException.  Aparentemente, os desenvolvedores fizeram isso porque pensavam que AccessViolationException n√£o era a exce√ß√£o que deveria ser capturada em um aplicativo regular. <br>  Al√©m disso, para compatibilidade com vers√µes anteriores, √© poss√≠vel usar as configura√ß√µes de tempo de execu√ß√£o: <br><br><ul><li>  legacyNullReferenceExceptionPolicy retorna o comportamento do .NET 1.0 - todos os AVs se transformam em NRE <br></li><li>  legacyCorruptedStateExceptionsPolicy retorna o comportamento do .NET 2.0 - todos os antiv√≠rus s√£o interceptados <br></li></ul><br>  No .NET, o Core AccessViolation n√£o √© tratado. <br><br>  Em nossa produ√ß√£o, havia uma situa√ß√£o assim: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad7/0f1/6d3/ad70f16d3438d1e8ab80e43ba29d5412.png"><br><br>  Um aplicativo criado no .NET 4.7.1 usou uma biblioteca de c√≥digos compartilhada criada no .NET 3.5.  Havia um auxiliar nesta biblioteca para executar uma a√ß√£o peri√≥dica: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isRunning) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { log.Error(e); } WaitForNextExecution(... ); }</code> </pre><br>  Passamos a a√ß√£o do nosso aplicativo para esse ajudante.  Aconteceu que ele caiu com o AccessViolation.  Como resultado, nosso aplicativo registrava constantemente o AccessViolation, em vez de travar porque  o c√≥digo da biblioteca em 3.5 pode peg√°-lo.  Deve-se observar que a intercepta√ß√£o n√£o depende da vers√£o do tempo de execu√ß√£o na qual o aplicativo est√° sendo executado, mas do TargetFramework, no qual o aplicativo foi constru√≠do, e de suas depend√™ncias. <br><br>  Para resumir.  O processamento do AccessVilolation depende de onde ele se originou - no c√≥digo nativo ou gerenciado -, bem como nas configura√ß√µes TargetFramework e de tempo de execu√ß√£o. <br><br><h2>  Interrup√ß√£o de thread </h2><br>  √Äs vezes, no c√≥digo, voc√™ precisa interromper a execu√ß√£o de um dos threads.  Para fazer isso, voc√™ pode usar o thread.Abort (); <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... Thread.ResetAbort(); } }); ... thread.Abort();</code> </pre><br>  Quando o m√©todo Abort √© chamado em um thread parado, √© lan√ßada uma ThreadAbortException.  Vamos analisar suas caracter√≠sticas.  Por exemplo, um c√≥digo como este: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ‚Ä¶ } }); ... thread.Abort();</code> </pre><br>  Absolutamente equivalente a isso: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }); ... thread.Abort();</code> </pre><br>  Se voc√™ ainda precisar processar o ThreadAbort e executar algumas outras a√ß√µes no segmento parado, poder√° usar o m√©todo Thread.ResetAbort ();  Ele interrompe o processo de interrup√ß√£o do fluxo e a exce√ß√£o para de subir mais alto na pilha.  √â importante entender que o pr√≥prio m√©todo thread.Abort () n√£o garante nada - o c√≥digo no thread parado pode impedir que ele pare. <br><br>  Outro recurso do thread.Abort () √© que ele n√£o poder√° interromper o c√≥digo se estiver no catch e finalmente bloqueia. <br><br>  Dentro do c√≥digo da estrutura, geralmente √© poss√≠vel encontrar m√©todos em que o bloco try est√° vazio e toda a l√≥gica est√° finalmente dentro.  Isso √© feito apenas para impedir que esse c√≥digo seja lan√ßado por um ThreadAbortException. <br><br>  Al√©m disso, uma chamada para o m√©todo thread.Abort () aguarda o lan√ßamento de um ThreadAbortException.  Combine esses dois fatos e fa√ßa com que o m√©todo thread.Abort () possa bloquear o thread de chamada. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { }       <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { } <span class="hljs-comment"><span class="hljs-comment">// &lt;-- No ThreadAbortException in catch       finally { // &lt;-- No ThreadAbortException in finally           Thread.Sleep(- 1); } }); thread.Start(); ... thread.Abort(); // Never returns</span></span></code> </pre><br>  Na realidade, isso pode ser encontrado ao usar o uso.  Ele √© implantado em try / finalmente, dentro do finalmente, o m√©todo Dispose √© chamado.  Pode ser arbitrariamente complexo, conter manipuladores de eventos, usar bloqueios.  E se thread.Abort foi chamado em tempo de execu√ß√£o, Dispose - thread.Abort () aguardar√° por isso.  Ent√£o, temos uma trava quase do zero. <br><br>  No .NET Core, o m√©todo thread.Abort () lan√ßa uma PlatformNotSupportedException.  E acho que isso √© muito bom, porque me motiva a n√£o usar thread.Abort (), mas m√©todos n√£o invasivos para interromper a execu√ß√£o do c√≥digo, por exemplo, usando o CancellationToken. <br><br><h2>  SEM MEM√ìRIA </h2><br>  Essa exce√ß√£o pode ser obtida se a mem√≥ria na m√°quina for menor que o necess√°rio.  Ou quando encontramos as limita√ß√µes de um processo de 32 bits.  Mas voc√™ pode obt√™-lo mesmo que o computador tenha muita mem√≥ria livre e o processo seja de 64 bits. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr4gb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue/<span class="hljs-number"><span class="hljs-number">2</span></span>];</code> </pre><br>  O c√≥digo acima lan√ßar√° OutOfMemory.  O fato √© que, por padr√£o, objetos maiores que 2 GB n√£o s√£o permitidos.  Isso pode ser corrigido definindo gcAllowVeryLargeObjects em App.config.  Nesse caso, uma matriz de 4 GB √© criada. <br><br>  Agora vamos tentar criar uma matriz ainda mais. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> largeArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue];</code> </pre><br>  Agora, mesmo o gcAllowVeryLargeObjects n√£o ajudar√°.  Isso ocorre porque o .NET tem um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">limite no √≠ndice m√°ximo em uma matriz</a> .  Essa restri√ß√£o √© menor que int.MaxValue. <br><br>  √çndice m√°ximo da matriz: <br><br><ul><li>  matrizes de bytes - 0x7FFFFFC7 <br></li><li>  outras matrizes - 0X7F <b>E</b> FFFFF <br></li></ul><br>  Nesse caso, ocorrer√° uma OutOfMemoryException, embora na verdade tenhamos enfrentado uma restri√ß√£o de tipo de dados, n√£o uma falta de mem√≥ria. <br><br>  √Äs vezes, o OutOfMemory √© explicitamente descartado pelo c√≥digo gerenciado dentro da estrutura .NET: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/efd/c84/d98/efdc84d98a7786e39c9c5931ac523d13.png"><br>  Esta √© uma implementa√ß√£o do m√©todo string.Concat.  Se o comprimento da sequ√™ncia de resultados for maior que int.MaxValue, uma OutOfMemoryException ser√° lan√ßada imediatamente. <br><br>  Vamos para a situa√ß√£o em que OutOfMemory surge no caso em que a mem√≥ria realmente se esgota. <br><br><pre> <code class="cs hljs">LimitMemory(<span class="hljs-number"><span class="hljs-number">64.</span></span>Mb()); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>)   list.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (OutOfMemoryException e) { Console.WriteLine(e); }</code> </pre><br>  Primeiro, limitamos a mem√≥ria do nosso processo a 64 MB.  Em seguida, dentro do loop, selecione novas matrizes de bytes, salve-as em alguma planilha para que o GC n√£o as colete e tente capturar OutOfMemory. <br><br>  Nesse caso, tudo pode acontecer: <br><br><ul><li>  Exce√ß√£o tratada <br></li><li>  Processo cair√° <br></li><li>  Vamos pegar, mas a exce√ß√£o falhar√° novamente <br></li><li>  Vamos pegar, mas o StackOverflow falhar√° <br></li></ul><br>  Nesse caso, o programa ser√° completamente n√£o determin√≠stico.  Vamos analisar todas as op√ß√µes: <br><br><ol><li>  Uma exce√ß√£o pode ser tratada.  Dentro do .NET, n√£o h√° nada que o impe√ßa de manipular uma OutOfMemoryException. <br></li><li>  O processo pode cair.  N√£o esque√ßa que temos um aplicativo gerenciado.  Isso significa que dentro dele √© executado n√£o apenas o nosso c√≥digo, mas tamb√©m o c√≥digo de tempo de execu√ß√£o.  Por exemplo, GC.  Portanto, pode ocorrer uma situa√ß√£o em que o tempo de execu√ß√£o deseja alocar mem√≥ria para si mesmo, mas n√£o pode faz√™-lo; portanto, n√£o conseguiremos capturar a exce√ß√£o. <br></li><li>  Vamos direto ao ponto, mas a exce√ß√£o falhar√° novamente.  Dentro da captura, tamb√©m fazemos o trabalho em que precisamos de mem√≥ria (imprimimos uma exce√ß√£o no console), e isso pode causar uma nova exce√ß√£o. <br></li><li>  Vamos pegar, mas o StackOverflow falhar√°.  O StackOverflow em si ocorre quando o m√©todo WriteLine √© chamado, mas n√£o h√° excesso de pilha aqui, mas ocorre uma situa√ß√£o diferente.  Vamos analis√°-lo em mais detalhes. <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/6e3/d32/752/6e3d32752ba10fd39d1f4a5e2e6648a7.png"><br><br>  Na mem√≥ria virtual, as p√°ginas podem n√£o apenas ser mapeadas para a mem√≥ria f√≠sica, mas tamb√©m podem ser reservadas.  Se a p√°gina estiver reservada, o aplicativo notou que iria us√°-la.  Se a p√°gina j√° estiver mapeada para mem√≥ria real ou troca, ser√° chamada de "confirmada" (confirmada).  A pilha usa essa capacidade de dividir a mem√≥ria em reservada e confirmada.  Parece algo como isto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b17/9e4/41f/b179e441f0c00f18e2a5fdf12b3093a9.png"><br><br>  Acontece que chamamos o m√©todo WriteLine, que ocupa algum lugar na pilha.  Acontece que toda a mem√≥ria bloqueada j√° terminou, o que significa que o sistema operacional neste momento deve pegar outra p√°gina reservada na pilha e mape√°-la para a mem√≥ria f√≠sica real, que j√° est√° cheia de matrizes de bytes.  Isso leva √† exce√ß√£o do StackOverflow. <br><br>  O c√≥digo a seguir permitir√° que voc√™ comprometa toda a mem√≥ria da pilha no in√≠cio do fluxo imediatamente. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; F(), <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>).Start();</code> </pre><br>  Como alternativa, voc√™ pode usar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">configura√ß√£o de tempo de execu√ß√£o</a> disableCommitThreadStack.  Ele precisa ser desativado para que a pilha de encadeamentos seja confirmada com anteced√™ncia.  Vale ressaltar que o comportamento padr√£o descrito na documenta√ß√£o e observado na realidade √© diferente. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46e/0e6/dbd/46e0e6dbd47906fb1d0ddf74ac927383.png"><br><br><h2>  Estouro de pilha </h2><br>  Vamos dar uma olhada em StackOverflowException.  Vejamos dois exemplos de c√≥digo.  Em um deles, executamos uma recurs√£o infinita, o que leva a um estouro de pilha; no segundo, lan√ßamos essa exce√ß√£o com throw. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { InfiniteRecursion(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StackOverflowException(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br>  Como todas as exce√ß√µes lan√ßadas com throw s√£o tratadas, no segundo caso, capturaremos a exce√ß√£o.  E com o primeiro caso, tudo √© mais interessante.  V√° para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MSDN</a> : <br><br><blockquote>  "Voc√™ n√£o pode capturar exce√ß√µes de estouro de pilha, porque o c√≥digo de tratamento de exce√ß√£o pode exigir a pilha." <br>  MSDN </blockquote><br>  Ele diz aqui que n√£o conseguiremos capturar uma StackOverflowException, pois a pr√≥pria intercepta√ß√£o pode exigir espa√ßo adicional na pilha que j√° foi finalizado. <br><br>  Para proteger de alguma forma contra essa exce√ß√£o, podemos fazer o seguinte.  Primeiro, voc√™ pode limitar a profundidade da recurs√£o.  Em segundo lugar, voc√™ pode usar os m√©todos da classe RuntimeHelpers: <br><br><blockquote>  RuntimeHelpers.EnsureSufficientExecutionStack (); <br><br><ul><li>  "Garante que o espa√ßo restante da pilha seja grande o suficiente para executar a fun√ß√£o m√©dia do .NET Framework."  - MSDN <br></li><li>  InsufficientExecutionStackException <br></li><li>  512 KB - x86, Qualquer CPU, 2 MB - x64 (metade do tamanho da pilha) <br></li><li>  64/128 KB - .NET Core <br></li><li>  Verifique apenas o espa√ßo de endere√ßo da pilha <br></li></ul><br></blockquote><br>  A documenta√ß√£o para esse m√©todo diz que verifica se h√° espa√ßo suficiente na pilha para executar a fun√ß√£o .NET <i>m√©dia</i> .  Mas qual √© a fun√ß√£o <i>m√©dia</i> ?  De fato, no .NET Framework, esse m√©todo verifica se pelo menos metade do seu tamanho est√° livre na pilha.  No .NET Core, ele verifica 64K gratuitamente. <br><br>  Um an√°logo tamb√©m apareceu no .NET Core: RuntimeHelpers.TryEnsureSufficientExecutionStack () que retorna um bool, em vez de lan√ßar uma exce√ß√£o. <br><br>  O C # 7.2 introduziu a capacidade de usar Span e blockallock juntos sem usar c√≥digo n√£o seguro.  Talvez por isso, o stackalloc seja usado com mais frequ√™ncia no c√≥digo e ser√° √∫til ter uma maneira de se proteger do StackOverflow ao us√°-lo, escolhendo onde alocar mem√≥ria.  Como tal, √© proposto um m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que verifica a possibilidade de aloca√ß√£o na pilha</a> e na constru√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">trystackalloc</a> . <br><br><pre> <code class="cs hljs">Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; span; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanAllocateOnStack(size)) span = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> span = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size];</code> </pre><br>  Voltar para a documenta√ß√£o StackOverflow no MSDN <br><br><blockquote>  Em vez disso, quando ocorre um estouro de pilha em um <b>aplicativo normal</b> , o Common Language Runtime (CLR) termina o processo. ‚Äù <br>  MSDN <br></blockquote><br>  Se houver um aplicativo "normal" que cai durante o StackOverflow, existem aplicativos n√£o normais que n√£o caem?  Para responder a essa pergunta, voc√™ precisar√° descer um n√≠vel do n√≠vel de aplicativo gerenciado para o n√≠vel CLR. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/186/516/64d/18651664dd1c1d1346e5377f0e0b3995.png"><br><br><blockquote>  "Um aplicativo que <b>hospeda o CLR</b> pode alterar o comportamento padr√£o e especificar que o CLR <b>descarregue o dom√≠nio do aplicativo</b> onde a exce√ß√£o ocorre, mas permite que o processo continue."  - MSDN <br>  StackOverflowException -&gt; AppDomainUnloadedException <br></blockquote><br>  Um aplicativo que hospeda o CLR pode redefinir o comportamento do estouro de pilha para que, em vez de concluir todo o processo, o Dom√≠nio do Aplicativo seja descarregado, no fluxo no qual esse estouro ocorreu.  Assim, podemos transformar um StackOverflowException em um AppDomainUnloadedException. <br><br>  Quando um aplicativo gerenciado √© iniciado, o tempo de execu√ß√£o do .NET √© iniciado automaticamente.  Mas voc√™ pode seguir o outro caminho.  Por exemplo, escreva um aplicativo n√£o gerenciado (em C ++ ou outro idioma) que usar√° uma API especial para aumentar o CLR e iniciar nosso aplicativo.  Um aplicativo que executa o CLR internamente ser√° chamado CLR-host.  Ao escrev√™-lo, podemos configurar muitas coisas em tempo de execu√ß√£o.  Por exemplo, substitua o gerenciador de mem√≥ria e o gerenciador de threads.  Em produ√ß√£o, usamos o host CLR para evitar a troca de p√°ginas de mem√≥ria. <br><br>  O c√≥digo a seguir configura o host CLR para que o AppDomain (C ++) seja descarregado durante o StackOverflow: <br><br><pre> <code class="cpp hljs">ICLRPolicyManager *policyMgr; pCLRControl-&gt;GetCLRManager(IID_ICLRPolicyManager, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) (&amp;policyMgr)); policyMgr-&gt;SetActionOnFailure(FAIL_StackOverflow, eRudeUnloadAppDomain);</code> </pre><br>  Essa √© uma boa maneira de escapar do StackOverflow?  Provavelmente n√£o muito.  Primeiro, tivemos que escrever c√≥digo C ++, o que n√£o queremos fazer.  Em segundo lugar, devemos alterar nosso c√≥digo C # para que a fun√ß√£o que pode lan√ßar uma StackOverflowException seja executada em um AppDomain separado e em um thread separado.  Nosso c√≥digo se transformar√° imediatamente em tal macarr√£o: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; InfiniteRecursion()); thread.Start(); thread.Join(); }); AppDomain.Unload(appDomain); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AppDomainUnloadedException) { }</code> </pre><br>  Para chamar o m√©todo InfiniteRecursion, escrevemos v√°rias linhas.  Terceiro, come√ßamos a usar o AppDomain.  E isso quase garante um monte de novos problemas.  Incluindo com exce√ß√µes.  Considere um exemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain( <span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException()); System.Runtime.Serialization.SerializationException: Type <span class="hljs-string"><span class="hljs-string">'CustomException'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> not marked <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> serializable. at System.AppDomain.DoCallBack(CrossAppDomainDelegate callBackDelegate)</code> </pre><br>  Como nossa exce√ß√£o n√£o est√° marcada como serializ√°vel, nosso c√≥digo ser√° descartado com uma SerializationException.  E para corrigir esse problema, n√£o basta marcar nossa exce√ß√£o com o atributo Serializable, ainda precisamos implementar um construtor adicional para serializa√ß√£o. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext ctx</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">info, context</span></span></span><span class="hljs-function">)</span></span>{} } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException());</code> </pre><br>  Tudo n√£o √© muito bonito, ent√£o vamos al√©m - ao n√≠vel do sistema operacional e dos hacks, que n√£o devem ser usados ‚Äã‚Äãna produ√ß√£o. <br><br><h2>  Seh / veh </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/2c5/7a2/aff/2c57a2aff0542b2a02ad8ab34d097412.png"><br><br>  Observe que, enquanto as exce√ß√µes gerenciadas voavam entre o gerenciado e o CLR, as exce√ß√µes SEH voam entre o CLR e o Windows. <br><br>  SEH - Tratamento Estruturado de Exce√ß√µes <br><br><ul><li>  Mecanismo de manipula√ß√£o de exce√ß√£o do Windows <br></li><li>  Tratamento uniforme de exce√ß√µes de software e hardware <br></li><li>  Exce√ß√µes de C # implementadas no topo do SEH <br></li></ul><br>  O SEH √© um mecanismo de manipula√ß√£o de exce√ß√µes no Windows, que permite lidar igualmente de maneira uniforme com as exce√ß√µes que vieram, por exemplo, do n√≠vel do processador ou foram associadas √† l√≥gica do pr√≥prio aplicativo. <br><br>  O Rantime .NET conhece as exce√ß√µes SEH e pode convert√™-las em exce√ß√µes gerenciadas: <br><br><ul><li>  EXCEPTION_STACK_OVERFLOW -&gt; Travamento <br></li><li>  EXCEPTION_ACCESS_VIOLATION -&gt; AccessViolationException <br></li><li>  EXCEPTION_ACCESS_VIOLATION -&gt; NullReferenceException <br></li><li>  EXCEPTION_INT_DIVIDE_BY_ZERO -&gt; DivideByZeroException <br></li><li>  Exce√ß√µes de SEH desconhecidas -&gt; SEHException <br></li></ul><br>  Podemos interagir com o SEH atrav√©s do WinApi. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionFlags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nNumberOfArguments,IntPtr lpArguments</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// DivideByZeroException RaiseException(0xc0000094, 0, 0, IntPtr.Zero); // Stack overflow RaiseException(0xc00000fd, 0, 0, IntPtr.Zero);</span></span></code> </pre><br>   ,  throw    SEH. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> -&gt; RaiseException(<span class="hljs-number"><span class="hljs-number">0xe0434f4d</span></span>, ...)</code> </pre><br>   ,    CLR-exception     ,        ,    . <br><br> VEH ‚Äî    ,  SEH,     ,      .  SEH     try-catch,  VEH      .            ,     .   VEH ‚Äî  ,     SEH-  ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b8/79d/848/7b879d848390b9e3d1b9156b00b8e2bf.png"><br><br>           ,    SEH-     EXCEPTION_STACK_OVERFLOW   ,   .NET   . <br><br>  VEH    WinApi: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">, SetLastError = true)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddVectoredExceptionHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr FirstHandler,  VECTORED_EXCEPTION_HANDLER VectoredHandler</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> VEH : <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> { EXCEPTION_CONTINUE_SEARCH = <span class="hljs-number"><span class="hljs-number">0</span></span>, EXCEPTION_EXECUTE_HANDLER = <span class="hljs-number"><span class="hljs-number">1</span></span>, EXCEPTION_CONTINUE_EXECUTION = <span class="hljs-number"><span class="hljs-number">-1</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_POINTERS { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EXCEPTION_RECORD* ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IntPtr Context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_RECORD { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> ExceptionCode; ... }</code> </pre><br>  Context          .     EXCEPTION_RECORD   ExceptionCode  .        ,   CLR    .    : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.ExceptionRecord == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> record = e. ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record-&gt;ExceptionCode != ExceptionStackOverflow) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; record-&gt;ExceptionCode = <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_EXECUTE_HANDLER; }</code> </pre><br>   ,       HandleSO,     ,      StackOverflowException (        WinApi    ). <br><br><pre> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()) ; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T HandleSO&lt;T&gt;(Func&lt;T&gt; action) { Kernel32. AddVectoredExceptionHandler(IntPtr.Zero, Handler); Kernel32.SetThreadStackGuarantee(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> size); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) when ((<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) Marshal. GetExceptionCode() == <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T); } HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br>      SetThreadStackGuarantee.         StackOverflow. <br><br>          .          ,      . <br><br> ,  ,   HandleSO    ? <br><br><pre> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()); HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br>   AccessViolationException.    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/639/e93/c8d/639e93c8d187dc31fc37a2ac7247f193.png"><br>      .       ,   Guard page.          ‚Äì STATUS_GUARD_PAGE_VIOLATION,   Guard page   .     ,         ‚Äì           stack-pointer    ,   .   ‚Äî  AccessViolationException.        StackOverflow ‚Äì c     ‚Äì   _resetstkoflw    C (msvcrt.dll). <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _resetstkoflw();</code> </pre><br>     AccessViolationException  .NET Core  Windows,     .               ,   .NET Core   VEH   AccessViolation.         AddVectoredExceptionHandler: <br><br><pre> <code class="cs hljs">Kernel32.AddVectoredExceptionHandler(FirstHandler: (IntPtr) <span class="hljs-number"><span class="hljs-number">1</span></span>, handler);</code> </pre><br>   ,   : <br><br><ul><li>    ,  ; <br></li><li>     ; <br></li><li>       ; <br></li><li>          .NET   ,    . <br></li></ul><br><h2>  Refer√™ncias </h2><br> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    </a> <br> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dotnext 2016 Moscow ‚Äî Adam Sitnik ‚Äî Exceptional Exceptions in .NET</a> <br> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DotNetBook: Exceptions</a> <br> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">.NET Inside Out Part 8 ‚Äî Handling Stack Overflow Exception in C# with VEH</a> ‚Äî    StackOverflow. <br><br><blockquote> 22-23     <b>DotNext 2018 Moscow</b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">¬´ :   ¬ª</a> .       ,  ,        .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ,    ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426045/">https://habr.com/ru/post/pt426045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426029/index.html">Voc√™ desiste e quer sair da tarefa? √â assim que o treinamento eficaz para desenvolvedores se parece</a></li>
<li><a href="../pt426031/index.html">Preocupar-se em capturar o mundo com intelig√™ncia artificial pode se basear em suposi√ß√µes n√£o cient√≠ficas</a></li>
<li><a href="../pt426033/index.html">Tit√£s matem√°ticos colidem com prova √©pica da hip√≥tese do ABC</a></li>
<li><a href="../pt426039/index.html">Lan√ßamento de emerg√™ncia "Soyuz MS-10" (equipe resgatada, transmitida)</a></li>
<li><a href="../pt426041/index.html">Solu√ß√£o simb√≥lica de equa√ß√µes diferenciais lineares e sistemas pelo m√©todo de transforma√ß√£o de Laplace usando SymPy</a></li>
<li><a href="../pt426047/index.html">10 √≥timos livros para iniciantes em ingl√™s</a></li>
<li><a href="../pt426051/index.html">Melhorando as habilidades de depura√ß√£o de software - algumas dicas</a></li>
<li><a href="../pt426053/index.html">Cache do manipulador de eventos e melhoria no desempenho do aplicativo React</a></li>
<li><a href="../pt426055/index.html">TensorFlow.js e clmtrackr.js: rastreando a dire√ß√£o do olhar do usu√°rio no navegador</a></li>
<li><a href="../pt426059/index.html">Tutu PHP Meetup # 2: V√≠deo de discursos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>