<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèº‚Äçü§ù‚Äçüßëüèª üö∏ ‚õ∫Ô∏è Docker-compose Comment attendre que le conteneur soit pr√™t üëåüèº üßìüèΩ üë®üèø‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Il existe de nombreux articles sur l'ex√©cution de conteneurs et l'√©criture de docker-compose.yml . Mais pour moi pendant longtemps, la ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker-compose Comment attendre que le conteneur soit pr√™t</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454552/"><h1>  Pr√©sentation </h1><br>  Il existe de nombreux articles sur l'ex√©cution de conteneurs et l'√©criture de <b>docker-compose.yml</b> .  Mais pour moi pendant longtemps, la question n'√©tait pas claire de savoir comment proc√©der correctement si un conteneur ne devait pas √™tre lanc√© jusqu'√† ce qu'un autre conteneur soit pr√™t √† traiter ses demandes ou √† effectuer une certaine quantit√© de travail. <br><a name="habracut"></a><br>  Cette question est devenue pertinente apr√®s que nous avons commenc√© √† utiliser activement <b>docker-compose</b> , au lieu de lancer des dockers individuels. <br><br><h1>  √Ä quoi √ßa sert? </h1><br>  En effet, laissons l'application dans le conteneur B d√©pendre de la disponibilit√© du service dans le conteneur A. Et au d√©marrage, l'application dans le conteneur B ne re√ßoit pas ce service.  Que faut-il faire? <br><br>  Il y a deux options: <br><br><ul><li>  le premier est de mourir (de pr√©f√©rence avec un code d'erreur) </li><li>  la seconde consiste √† attendre, puis √† mourir de toute fa√ßon, si l'application dans le conteneur B n'a pas r√©pondu pendant le d√©lai imparti </li></ul><br>  Apr√®s la mort du conteneur B, <b>docker-compose</b> (en fonction de la configuration bien s√ªr) le red√©marrera et l'application dans le conteneur B tentera √† nouveau d'acc√©der au service dans le conteneur A. <br><br>  Cela continuera jusqu'√† ce que le service du conteneur A soit pr√™t √† r√©pondre aux demandes ou jusqu'√† ce que nous remarquions que le conteneur est constamment surcharg√©. <br>  Et en fait, c'est la voie normale pour une architecture multi-conteneurs. <br><br>  Mais, en particulier, nous avons √©t√© confront√©s √† une situation o√π le conteneur A d√©marre et pr√©pare les donn√©es pour le conteneur B.L'application dans le conteneur B n'est pas en mesure de v√©rifier si les donn√©es sont pr√™tes ou non, elle commence imm√©diatement √† travailler avec elles.  Par cons√©quent, nous devons recevoir et traiter nous-m√™mes le signal de disponibilit√© des donn√©es. <br><br>  Je pense que vous pouvez toujours donner quelques cas d'utilisation.  Mais surtout, vous devez comprendre exactement pourquoi vous faites cela.  Sinon, il est pr√©f√©rable d'utiliser les outils de <b>composition Docker</b> standard. <br><br><h1>  Un peu d'id√©ologie </h1><br>  Si vous lisez attentivement la documentation, tout y est √©crit.  √Ä savoir, chaque <br>  l'unit√© est ind√©pendante et doit veiller √† ce que tous les services <br>  avec lequel il va travailler, sont √† sa disposition. <br><br>  Par cons√©quent, la question n'est pas de d√©marrer ou de ne pas d√©marrer le conteneur, mais de <br>  √† l'int√©rieur du conteneur, v√©rifiez l'√©tat de pr√©paration de tous les services requis et seulement <br>  puis transf√©rez le contr√¥le √† l'application conteneur. <br><br><h1>  Comment est-il mis en ≈ìuvre </h1><br>  Pour r√©soudre ce probl√®me, la description de <b>docker-compose</b> m'a beaucoup aid√©, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette</a> partie <br>  et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article</a> sur la bonne utilisation de <b>point</b> d' <b>entr√©e</b> et <b>cmd</b> . <br><br>  Donc, ce que nous devons obtenir: <br><br><ul><li>  il y a une annexe A que nous avons envelopp√©e dans le conteneur A </li><li>  il d√©marre et commence √† r√©pondre OK sur le port 8000 </li><li>  et aussi, il y a l'application B, que nous commen√ßons √† partir du conteneur B, mais elle devrait commencer √† fonctionner pas plus t√¥t que l'application A commencera √† r√©pondre aux demandes sur le port 8000 </li></ul><br>  La documentation officielle propose deux fa√ßons de r√©soudre ce probl√®me. <br><br>  La premi√®re consiste √† √©crire votre propre point d' <b>entr√©e</b> dans le conteneur, qui effectuera toutes les v√©rifications, puis √† d√©marrer l'application de travail. <br><br>  La seconde consiste √† utiliser le fichier de commandes d√©j√† √©crit <b>wait-for-it.sh</b> . <br>  Nous avons essay√© dans les deux sens. <br><br><h2>  √âcrire votre propre point d'entr√©e </h2><br>  Qu'est-ce que le point d' <b>entr√©e</b> ? <br><br>  Il s'agit uniquement du fichier ex√©cutable que vous sp√©cifiez lors de la cr√©ation du conteneur dans le <b>Dockerfile</b> dans le champ <b>ENTRYPOINT</b> .  Ce fichier, comme d√©j√† mentionn√©, effectue des v√©rifications, puis lance l'application principale du conteneur. <br><br>  Donc, ce que nous obtenons: <br><br>  Cr√©ez un dossier <i>Entrypoint</i> . <br><br>  Il a deux sous-dossiers - <i>container_A</i> et <i>container_B</i> .  Nous y cr√©erons nos conteneurs. <br><br>  Pour le conteneur A, prenons un simple serveur http sur python.  Apr√®s le d√©marrage, il commence √† r√©pondre pour obtenir des demandes sur le port 8000. <br><br>  Pour rendre notre exp√©rience plus explicite, nous avons d√©fini un d√©lai de 15 secondes avant de d√©marrer le serveur. <br><br>  Il s'av√®re que le <b>fichier docker</b> suivant <b>pour le conteneur A</b> : <br><br><pre><code class="plaintext hljs">FROM python:3 EXPOSE 8000 CMD sleep 15 &amp;&amp; python3 -m http.server --cgi</code> </pre> <br>  Pour le conteneur B, cr√©ez le <b>fichier docker</b> suivant <b>pour le conteneur B</b> : <br><br><pre> <code class="plaintext hljs">FROM ubuntu:18.04 RUN apt-get update RUN apt-get install -y curl COPY ./entrypoint.sh /usr/bin/entrypoint.sh ENTRYPOINT [ "entrypoint.sh" ] CMD ["echo", "!!!!!!!! Container_A is available now !!!!!!!!"]</code> </pre><br>  Et mettez notre ex√©cutable entrypoint.sh dans le m√™me dossier.  Nous allons l'avoir comme √ßa <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash set -e host="conteiner_a" port="8000" cmd="$@" &gt;&amp;2 echo "!!!!!!!! Check conteiner_a for available !!!!!!!!" until curl http://"$host":"$port"; do &gt;&amp;2 echo "Conteiner_A is unavailable - sleeping" sleep 1 done &gt;&amp;2 echo "Conteiner_A is up - executing command" exec $cmd</span></span></code> </pre><br>  Que se passe-t-il dans le conteneur B: <br><br><ul><li>  Quand il d√©marre, il d√©marre <b>ENTRYPOINT</b> , c'est-√†-dire  lance <b>entrypoint.sh</b> </li><li>  <b>entrypoint.sh</b> , en utilisant <b>curl</b> , commence √† interroger le port 8000 pour le conteneur A. Il le fait jusqu'√† ce qu'il re√ßoive une r√©ponse 200 (c'est-√†-dire que <b>curl</b> se terminera dans ce cas par un r√©sultat nul et la boucle se terminera) </li><li>  Lorsque 200 est re√ßu, la boucle se termine et le contr√¥le passe √† la commande sp√©cifi√©e dans la variable <b>$ cmd</b> .  Et cela indique ce que nous avons indiqu√© dans le fichier docker dans le champ <b>CMD</b> , c'est-√†-dire  <i>echo "!!! Container_A est disponible maintenant !!!!!!!!"</i>  Pourquoi en est-il ainsi, est d√©crit dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> ci-dessus </li><li>  Nous imprimons - <i>!!!</i>  <i>Container_A est disponible maintenant !!!</i>  <i>et conclure.</i> </li></ul><br>  Nous allons tout d√©marrer avec <b>docker-compose</b> . <br><br>  <b>docker-compose.yml</b> nous avons ici ceci: <br><br><pre> <code class="plaintext hljs">version: '3' networks: waiting_for_conteiner: services: conteiner_a: build: ./conteiner_A container_name: conteiner_a image: conteiner_a restart: unless-stopped networks: - waiting_for_conteiner ports: - 8000:8000 conteiner_b: build: ./conteiner_B container_name: conteiner_b image: waiting_for_conteiner.entrypoint.conteiner_b restart: "no" networks: - waiting_for_conteiner</code> </pre><br>  Ici, dans <b>conteiner_a, il n'est</b> pas n√©cessaire de sp√©cifier les <i>ports: 8000: 8000</i> .  Cela a √©t√© fait afin de pouvoir v√©rifier le fonctionnement du serveur http fonctionnant dedans de l'ext√©rieur. <br><br>  En outre, le conteneur B ne red√©marre pas apr√®s l'arr√™t. <br><br>  Nous lan√ßons: <br><br><pre> <code class="plaintext hljs">docker-compose up ‚Äî-build</code> </pre><br>  Nous voyons que pendant 15 secondes, il y a un message sur l'indisponibilit√© du conteneur A, puis <br><br><pre> <code class="plaintext hljs">conteiner_b | Conteiner_A is unavailable - sleeping conteiner_b | % Total % Received % Xferd Average Speed Time Time Time Current conteiner_b | Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt; conteiner_b | &lt;html&gt; conteiner_b | &lt;head&gt; conteiner_b | &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; conteiner_b | &lt;title&gt;Directory listing for /&lt;/title&gt; conteiner_b | &lt;/head&gt; conteiner_b | &lt;body&gt; conteiner_b | &lt;h1&gt;Directory listing for /&lt;/h1&gt; conteiner_b | &lt;hr&gt; conteiner_b | &lt;ul&gt; conteiner_b | &lt;li&gt;&lt;a href=".dockerenv"&gt;.dockerenv&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="bin/"&gt;bin/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="boot/"&gt;boot/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="dev/"&gt;dev/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="etc/"&gt;etc/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="home/"&gt;home/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="lib/"&gt;lib/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="lib64/"&gt;lib64/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="media/"&gt;media/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="mnt/"&gt;mnt/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="opt/"&gt;opt/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="proc/"&gt;proc/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="root/"&gt;root/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="run/"&gt;run/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="sbin/"&gt;sbin/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="srv/"&gt;srv/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="sys/"&gt;sys/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="tmp/"&gt;tmp/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="usr/"&gt;usr/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="var/"&gt;var/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;/ul&gt; conteiner_b | &lt;hr&gt; conteiner_b | &lt;/body&gt; conteiner_b | &lt;/html&gt; 100 987 100 987 0 0 98700 0 --:--:-- --:--:-- --:--:-- 107k conteiner_b | Conteiner_A is up - executing command conteiner_b | !!!!!!!! Container_A is available now !!!!!!!!</code> </pre><br>  Nous obtenons une r√©ponse √† votre demande, imprimez <nobr><i>!!!</i></nobr>  <nobr><i>Container_A est disponible maintenant !!!!!!!!</i></nobr>  et conclure. <br><br><h2>  Utilisation de wait-for-it.sh </h2><br>  Il vaut la peine de dire tout de suite que ce chemin n'a pas fonctionn√© pour nous comme d√©crit dans la documentation. <br>  √Ä savoir, il est connu que si <b>ENTRYPOINT</b> et <b>CMD sont</b> √©crits dans le <b>Dockerfile</b> , alors lorsque le conteneur d√©marre, la commande de <b>ENTRYPOINT</b> sera ex√©cut√©e et le contenu de <b>CMD lui</b> sera transmis en tant que param√®tres. <br><br>  Il est √©galement connu que <b>ENTRYPOINT</b> et <b>CMD</b> sp√©cifi√©s dans le <b>Dockerfile</b> peuvent √™tre red√©finis dans <b>docker-compose.yml</b> <br><br>  Le <b>format de</b> d√©marrage <b>wait-for-it.sh est</b> le suivant: <br><br><pre> <code class="plaintext hljs">wait-for-it.sh __ -- ___</code> </pre><br>  Ensuite, comme indiqu√© dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> , nous pouvons d√©finir un nouveau <b>ENTRYPOINT</b> dans <b>docker-compose.yml</b> , et le <b>CMD sera</b> remplac√© √† partir du <b>Dockerfile</b> . <br><br>  Ainsi, nous obtenons: <br><br>  <b>Le fichier Docker pour le conteneur A</b> reste inchang√©: <br><br><pre> <code class="plaintext hljs">FROM python:3 EXPOSE 8000 CMD sleep 15 &amp;&amp; python3 -m http.server --cgi</code> </pre><br>  <b>Fichier Docker pour le conteneur B</b> <br><br><pre> <code class="plaintext hljs">FROM ubuntu:18.04 COPY ./wait-for-it.sh /usr/bin/wait-for-it.sh CMD ["echo", "!!!!!!!! Container_A is available now !!!!!!!!"]</code> </pre><br>  <b>Docker-compose.yml</b> ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">version: '3' networks: waiting_for_conteiner: services: conteiner_a: build: ./conteiner_A container_name: conteiner_a image: conteiner_a restart: unless-stopped networks: - waiting_for_conteiner ports: - 8000:8000 conteiner_b: build: ./conteiner_B container_name: conteiner_b image: waiting_for_conteiner.wait_for_it.conteiner_b restart: "no" networks: - waiting_for_conteiner entrypoint: ["wait-for-it.sh", "-s" , "-t", "20", "conteiner_a:8000", "--"]</code> </pre><br>  Nous ex√©cutons la commande <b>wait-for-it</b> , lui demandons d'attendre 20 secondes jusqu'√† ce que le conteneur A prenne vie et sp√©cifions un autre param√®tre <b>¬´-¬ª</b> , qui devrait s√©parer les param√®tres <b>wait-for-it</b> du programme qu'il lancera apr√®s son ach√®vement. <br><br>  Nous essayons! <br>  Et malheureusement, nous n'obtenons rien. <br><br>  Si nous v√©rifions avec quels arguments nous <b>ex√©cutons</b> l' <b>attente</b> , alors nous verrons que seul ce que nous avons sp√©cifi√© dans le point d' <b>entr√©e lui est transmis</b> , la <b>CMD</b> du conteneur n'est pas attach√©e. <br><br><h3>  Option de travail </h3><br>  Ensuite, il n'y a qu'une seule option.  Ce que nous avons sp√©cifi√© dans le <b>CMD</b> dans le <b>Dockerfile</b> , nous devons le transf√©rer √† la <b>commande</b> dans <b>docker-compose.yml</b> . <br><br>  Ensuite, <b>laissez le Dockerfile du</b> conteneur B inchang√©, et <b>docker-compose.yml</b> ressemblera √† ceci: <br><br><pre> <code class="plaintext hljs">version: '3' networks: waiting_for_conteiner: services: conteiner_a: build: ./conteiner_A container_name: conteiner_a image: conteiner_a restart: unless-stopped networks: - waiting_for_conteiner ports: - 8000:8000 conteiner_b: build: ./conteiner_B container_name: conteiner_b image: waiting_for_conteiner.wait_for_it.conteiner_b restart: "no" networks: - waiting_for_conteiner entrypoint: ["wait-for-it.sh", "-s" ,"-t", "20", "conteiner_a:8000", "--"] command: ["echo", "!!!!!!!! Container_A is available now !!!!!!!!"]</code> </pre><br>  Et dans cette version, cela fonctionne. <br><br>  En conclusion, il faut dire qu'√† notre avis, la bonne voie est la premi√®re.  Il est le plus polyvalent et vous permet d'effectuer un contr√¥le de pr√©paration de toutes les mani√®res possibles.  <b>L'attente est</b> juste un utilitaire utile que vous pouvez utiliser s√©par√©ment ou en l'int√©grant dans votre <b>entrypoint.sh</b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454552/">https://habr.com/ru/post/fr454552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454536/index.html">Amplificateur au capteur de fr√©quence cardiaque classique</a></li>
<li><a href="../fr454538/index.html">Frontend Weekly Digest (27 mai - 2 juin 2019)</a></li>
<li><a href="../fr454540/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 367 (27 mai - 2 juin 2019)</a></li>
<li><a href="../fr454542/index.html">R√©seaux de t√©l√©vision par c√¢ble pour les plus petits. Partie 7: R√©cepteurs optiques</a></li>
<li><a href="../fr454546/index.html">De combien de programmeurs avez-vous besoin pour prendre une tasse de caf√©</a></li>
<li><a href="../fr454556/index.html">Nouvelles du monde d'OpenStreetMap n ¬∞ 462 (05.21.2019-27.05.2019)</a></li>
<li><a href="../fr454558/index.html">PHP Digest n ¬∞ 157 (20 mai - 3 juin 2019)</a></li>
<li><a href="../fr454562/index.html">Pourquoi le concept de bytecode n'est pas aussi pertinent qu'auparavant</a></li>
<li><a href="../fr454568/index.html">Mozilla a qualifi√© la ¬´mauvaise¬ª distribution de packages Web sign√©e num√©riquement par Google</a></li>
<li><a href="../fr454570/index.html">Recr√©er un ancien jeu DOS en C ++ 17</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>