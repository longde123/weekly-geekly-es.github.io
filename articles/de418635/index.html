<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧖🏽 🎋 👨‍🏫 Erstellen eines Emulator-Arcade-Automaten. Teil 1 👩‍👩‍👧‍👧 🖇️ 🌐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Schreiben eines Arcade-Maschinenemulators ist ein großartiges Bildungsprojekt, und in diesem Tutorial werden wir den gesamten Entwicklungsprozess ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines Emulator-Arcade-Automaten. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418635/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/735/b99/6eb735b9990860a94f9ef0a18ba46a82.jpg" alt="Bild"></div><br>  Das Schreiben eines Arcade-Maschinenemulators ist ein großartiges Bildungsprojekt, und in diesem Tutorial werden wir den gesamten Entwicklungsprozess sehr detailliert betrachten.  Möchten Sie den Prozessor wirklich in die Finger bekommen?  Dann ist das Erstellen eines Emulators der beste Weg, dies zu lernen. <br><br>  Sie benötigen Kenntnisse in C sowie Kenntnisse in Assembler.  Wenn Sie die Assemblersprache nicht kennen, ist das Schreiben eines Emulators der beste Weg, um sie zu lernen.  Sie müssen auch die hexadezimale Mathematik beherrschen (auch als Basis 16 oder einfach als „Hex“ bezeichnet).  Ich werde über dieses Thema sprechen. <br><br>  Ich habe mich für einen Emulator für die Space Invaders-Maschine entschieden, die den 8080-Prozessor verwendet. Dieses Spiel und dieser Prozessor sind sehr beliebt, da Sie im Internet viele Informationen darüber finden können.  Sie benötigen es, um das Projekt abzuschließen. <br><br>  Der gesamte Quellcode des Tutorials wird auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github</a> hochgeladen.  Wenn Sie die Arbeit mit Git nicht beherrschen, finden Sie auf der Github-Seite eine Schaltfläche "ZIP herunterladen", mit der Sie das Archiv mit dem gesamten Code herunterladen können. <br><a name="habracut"></a><br><h1>  Einführung in Binär- und Hexadezimalzahlen </h1><br>  In der "normalen" Mathematik wird das Dezimalzahlensystem verwendet.  Jede Ziffer der Zahl kann einen Wert von null bis neun haben. Wenn wir 9 überschreiten, addieren wir eins zur Zahl in der nächsten Ziffer und beginnen erneut bei Null.  Das ist alles ganz einfach und unkompliziert, und Sie haben wahrscheinlich nie darüber nachgedacht. <br><br>  Möglicherweise haben Sie gewusst oder gehört, dass Computer mit Binärdaten arbeiten.  Computerfreaks nennen Base-10-Dezimalmathematik und Binär-Call-Base-2.  In der binären Notation kann jede Ziffer einer Zahl nur zwei Werte haben, null oder eins.  Im Binärcode lautet die Anzahl wie folgt: 0, 1, 10, 11, 100, 101, 110, 111, 1000. Dies sind keine Dezimalzahlen, daher können Sie sie nicht "Null, Eins, Zehn, Elf, Einhundert, Einhundertein" nennen.  Sie werden ausgesprochen als "Null, Eins, Eins-Null, Eins-Eins, Eins-Null-Null" usw.  Ich lese Binärzahlen selten laut vor, aber wenn nötig, müssen Sie das verwendete Zahlensystem klar angeben.  Zehn, elf und einhundert haben in der binären Notation keine Bedeutung. <br><br>  In Dezimalschreibweise hat eine Zahl die folgenden Ziffern: Einheiten, Zehner, Hunderter, Tausende, Zehntausende usw.  Im binären System die folgenden Ziffern: Einheiten, Zweien, Vierer, Achtel usw.  <strong>In der Informatik wird der Wert jedes Binärbits als Bit bezeichnet.</strong>  <strong>8 Bits bilden ein Byte.</strong> <br><br>  In binären Begriffen wird eine Folge von Zahlen schnell sehr lang.  Um die Dezimalzahl 20.000 binär darzustellen, sind 16 Ziffern erforderlich: 0b100111000100000.  Um dieses Problem zu beheben, ist es zweckmäßig, ein Hexadezimalzahlensystem zu verwenden, das auch als Basis-16 (oder Hex) bezeichnet wird.  In Basis 16 enthält jede Ziffer 16 Werte.  Für Werte von null bis neun werden die gleichen Zeichen wie in Basis 10 verwendet, aber für die verbleibenden 6 Werte werden Substitutionen in Form der ersten 6 Buchstaben des Alphabets von A bis F verwendet. <br><br>  Die Abrechnung im Hexadezimalsystem erfolgt wie folgt: 0 1 2 3 4 5 6 7 8 9 ABCDEF 10 11 12 usw.  Im Hexadezimalbereich haben Zehner, Hunderter usw. nicht die gleiche Bedeutung wie im Dezimalbereich, daher sprechen die Menschen Zahlen separat aus.  Zum Beispiel wird $ A57 laut als "A-fünf-sieben" ausgesprochen.  Aus Gründen der Übersichtlichkeit können Sie auch Hex hinzufügen, z. B. "A-fünf-sieben-hex".  Im Hexadezimalzahlensystem entspricht das Äquivalent der Dezimalzahl 20.000 $ 4E20 - eine viel kompaktere Form im Vergleich zu 16 Bit des Binärsystems. <br><br>  Ich denke, das Hexadezimalsystem wurde aufgrund einer sehr natürlichen Umwandlung von binär nach hexadezimal und umgekehrt gewählt.  Jede hexadezimale Ziffer entspricht 4 Bits (4 Bits) einer ähnlichen Binärzahl.  <strong>2 hexadezimale Ziffern bilden ein Byte (8 Bits).</strong>  Eine einzelne hexadezimale Ziffer kann als Knabbern bezeichnet werden, und einige Leute schreiben sie sogar als „Nybble“ durch y. <br><br><table><tbody><tr><th colspan="4">  Jede hexadezimale Ziffer besteht aus 4 Binärziffern </th></tr><tr><td>  Hex </td><td>  A. </td><td>  5 </td><td>  7 </td></tr><tr><td>  Binär </td><td>  1010 </td><td>  0101 </td><td>  0111 </td></tr></tbody></table><br>  Beim Schreiben von C-Code wird angenommen, dass die Zahl dezimal ist (Basis-10), sofern nicht anders angegeben.  Um dem C-Compiler mitzuteilen, dass die Zahl binär ist, fügen wir die Zahl Null und den Buchstaben b in Kleinbuchstaben hinzu: <code>0b1101101</code> .  Die Hexadezimalzahl kann in C-Code geschrieben werden, indem am Anfang von Null und x in Kleinbuchstaben <code>0xA57</code> wird: <code>0xA57</code> .  Einige Assemblersprachen verwenden das Dollarzeichen $: <code>$A57</code> , um eine Hex-Zahl anzugeben. <br><br>  Wenn Sie darüber nachdenken, ist der Zusammenhang zwischen Binär-, Hexadezimal- und Dezimalzahlen ziemlich offensichtlich, aber für den ersten Ingenieur, der vor der Erfindung des Computers daran gedacht hatte, sollte dies ein Moment der Einsicht geworden sein. <br><br>  Das alles verstanden?  Großartig. <br><br><h1>  Eine kurze Einführung in den Prozessor </h1><br>  <em>Wenn Sie dies bereits wissen, können Sie den Abschnitt sicher überspringen.</em> <br><br>  Eine Zentraleinheit (CPU) ist eine Maschine zum Ausführen von Programmen.  Die Grundblöcke der CPU sind Register und Anweisungen.  Als Softwareentwickler können Sie diese Register als Variablen behandeln.  In unserem 8080-Prozessor gibt es unter anderem 8-Bit-Register mit den Namen A, B, C, D und E. Diese Register können als der folgende C-Code interpretiert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> A, B, C, D, E;</code> </pre> <br>  Alle Prozessoren haben auch einen Programmzähler (Programmzähler, PC).  Sie können es als Zeiger nehmen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pc;</code> </pre> <br>  Für eine CPU ist ein Programm eine Folge von Hexadezimalzahlen.  Jeder Assembler-Befehl in 8080 entspricht 1-3 Bytes im Programm.  Um herauszufinden, welcher Befehl welcher Nummer entspricht, ist das Prozessorhandbuch (oder andere Informationen zum 8080-Prozessor aus dem Internet) hilfreich. <br><br>  Die Namen von Befehlen (Anweisungen) sind häufig Mnemoniken aus den von diesen Befehlen ausgeführten Operationen.  Die Mnemonik zum Laden in 8080 ist MOV (Verschieben), und ADD wird verwendet, um die Addition durchzuführen. <br><br><h4>  Beispiele </h4><br>  Der aktuelle Befehlswert, der vom Befehlszähler angezeigt wird, ist 0x79.  Dies entspricht der <code>MOV A,C</code> Anweisung <code>MOV A,C</code> 8080-Prozessors. Dieser Assembler-Code im C-Code sieht wie folgt aus: <code>A=C;</code>  . <br><br>  Wenn stattdessen der Wert im PC 0x80 wäre, würde der Prozessor <code>ADD B</code> ausführen <code>ADD B</code>  In C entspricht dies der Zeichenfolge <code>A = A + B;</code>  . <br><br>  Eine vollständige Liste der 8080-Prozessoranweisungen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Um unseren Emulator zu implementieren, werden wir diese Informationen verwenden. <br><br><h4>  Timings </h4><br>  In der CPU erfordert die Ausführung jedes Befehls eine bestimmte Zeit (Timing), gemessen in Zyklen.  In modernen Prozessoren kann es schwierig sein, diese Informationen zu erhalten, da das Timing von vielen verschiedenen Aspekten abhängt.  Bei älteren Prozessoren wie dem 8080 sind die Timings jedoch konstant, und diese Informationen werden häufig vom Prozessorhersteller bereitgestellt.  Beispielsweise dauert ein Übertragungsbefehl von Register zu Register MOV 1 Zyklus. <br><br>  Timing-Informationen sind nützlich, um effizienten Code in den Prozessor zu schreiben.  Ein Programmierer kann versuchen, Anweisungen zu vermeiden, deren Ausführung viele Zyklen dauert. <br><br>  Wichtiger für uns ist, dass wir Timing-Informationen verwenden, um den Prozessor zu emulieren.  Damit das Spiel wie auf dem Original funktioniert, müssen die Anweisungen mit der richtigen Geschwindigkeit ausgeführt werden.  Einige Emulatoren geben sich viel Mühe, aber wenn wir dazu kommen, müssen wir uns entscheiden, welche Genauigkeit wir erreichen wollen. <br><br><h1>  Logische Operationen </h1><br>  Bevor wir das Thema Binär- und Hexadezimalzahlen schließen, sollten wir über logische Operationen sprechen.  Sie sind wahrscheinlich bereits daran gewöhnt, Logik in Ihrem Code zu verwenden, beispielsweise in Konstrukten wie <code>if ((conditionA) and (conditionB))</code> .  In Programmen, die direkt mit Hardware arbeiten, müssen Sie häufig einzelne Zahlenbits bearbeiten. <br><br><h3>  UND-Betrieb </h3><br>  Hier sind alle möglichen Ergebnisse der UND-Operation (UND) (Wahrheitstabelle) zwischen zwei Einzelbitzahlen. <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Ergebnis </td></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  1 </td><td>  0 </td></tr><tr><td>  1 </td><td>  0 </td><td>  0 </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td></tr></tbody></table><br>  Das Ergebnis von UND ist nur dann gleich Eins, wenn beide Werte gleich Eins sind.  Wenn wir zwei Zahlen mit der UND-Operation kombinieren, ist UND für jedes Bit einer Zahl UND mit dem entsprechenden Bit der anderen Zahl.  Das Ergebnis wird in diesem Bit der Zielnummer gespeichert.  Wahrscheinlich besser, um nur ein Beispiel zu betrachten: <br><br><table><tbody><tr><td></td><td colspan="8">  binär </td><td>  hex </td></tr><tr><td>  Quelle x </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  $ 6B </td></tr><tr><td>  Quelle y </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  $ D2 </td></tr><tr><td>  x UND y </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  $ 42 </td></tr></tbody></table><br>  In C ist die logische UND-Verknüpfung ein einfaches kaufmännisches Und "&amp;". <br><br><h3>  Operation ODER (ODER) </h3><br>  Die ODER-Verknüpfung funktioniert auf ähnliche Weise.  Der einzige Unterschied besteht darin, dass das Ergebnis gleich eins ist, wenn mindestens einer der Werte von x oder y gleich eins ist. <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Ergebnis </td></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  1 </td><td>  1 </td></tr><tr><td>  1 </td><td>  0 </td><td>  1 </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td></tr></tbody></table><br><table><tbody><tr><td></td><td colspan="8">  binär </td><td>  hex </td></tr><tr><td>  Quelle x </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  $ 6B </td></tr><tr><td>  Quelle y </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  $ D2 </td></tr><tr><td>  x ODER y </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  $ Fb </td></tr></tbody></table><br>  In C wird eine logische ODER-Verknüpfung durch einen vertikalen Balken "|" angezeigt. <br><br><h3>  Warum ist das wichtig? </h3><br>  In vielen älteren Prozessoren und insbesondere in Arcade-Maschinen erfordert das Spiel oft, nur mit einem Bit der Zahl zu arbeiten.  Oft gibt es einen ähnlichen Code: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/*  1:     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buttons_ptr = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-number"><span class="hljs-number">0x2043</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buttons = *buttons_ptr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buttons &amp; <span class="hljs-number"><span class="hljs-number">0x4</span></span>) HandleLeftButton(); <span class="hljs-comment"><span class="hljs-comment">/*  2:  LED-    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * LED_pointer = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) <span class="hljs-number"><span class="hljs-number">0x2089</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> led = *LED_pointer; led = led | <span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-comment"><span class="hljs-comment">//,  LED   6 *LED_pointer = led; /*  3:   LED- */ char * LED_pointer = (char *) 0x2089; char led = *LED_pointer; led = led &amp; 0xBF; //  6 *LED_pointer = led;</span></span></code> </pre> <br>  In Beispiel 1 ist die im Speicher zugewiesene Adresse $ 2043 die Adresse der Tasten auf dem Bedienfeld.  Dieser Code liest und reagiert auf die gedrückte Taste.  (Natürlich wird dieser Code in Space Invaders in Assemblersprache sein!) <br><br>  In Beispiel 2 möchte das Spiel eine LED-Anzeige aufleuchten lassen, die sich in Bit 6 der im Speicher zugewiesenen $ 2089-Adresse befindet.  Der Code sollte den vorhandenen Wert lesen, nur ein Bit ändern und ihn zurückschreiben. <br><br>  In Beispiel 3 müssen Sie den Indikator von Beispiel 2 ausschalten, damit der Code Bit 6 der Adresse $ 2089 zurücksetzt.  Dies kann erreicht werden, indem die UND-Operation für das Indikatorsteuerbyte mit einem Wert ausgeführt wird, für den nur Bit 6 Null ist. Wir werden also nur 6 beeinflussen und die verbleibenden Bits unverändert lassen. <br><br>  Dies wird normalerweise als "Maske" bezeichnet.  In C wird eine Maske normalerweise mit dem Operator NOT geschrieben, der durch eine Tilde ("~") gekennzeichnet ist.  Anstatt <code>~0x40</code> schreiben, schreibe ich einfach <code>~0x40</code> und erhalte die gleiche Nummer, aber ohne großen Aufwand. <br><br><h1>  Einführung in die Assemblersprache </h1><br>  Wenn Sie dieses Tutorial lesen, sind Sie wahrscheinlich mit Computerprogrammierung vertraut, beispielsweise in Java oder Python.  Mit diesen Sprachen können Sie viel Arbeit in nur wenigen Codezeilen erledigen.  Code gilt als geschickt geschrieben, wenn er in möglichst wenigen Zeilen so viel Arbeit wie möglich leistet und möglicherweise sogar die Funktionalität der integrierten Bibliotheken nutzt.  Solche Sprachen werden "Hochsprachen" genannt. <br><br>  In der Assemblersprache sind dagegen keine lebensrettenden Funktionen integriert, und möglicherweise sind viele einfache Codezeilen erforderlich, um einfache Aufgaben auszuführen.  Assemblersprache wird als einfache Sprache betrachtet.  Darin muss man sich daran gewöhnen, im Stil zu denken: "Welche spezifische Abfolge von Schritten muss unternommen werden, um diese Aufgabe zu erledigen?" <br><br>  Das Wichtigste, was Sie über die Assembler-Sprache wissen müssen, ist, dass jede Zeile in einen Prozessorbefehl übersetzt wird. <br><br>  Betrachten Sie eine solche Konstruktion aus der C-Sprache: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = b + <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  In der Assemblersprache muss diese Aufgabe in der folgenden Reihenfolge ausgeführt werden: <br><br><ol><li>  Laden Sie die Adresse der Variablen B in Register 1 </li><li>  Laden Sie den Inhalt dieser Speicheradresse in Register 2 </li><li>  Addiere den direkten Wert 0x64 zu Register 2 </li><li>  Laden Sie die Adresse der Variablen A in Register 1 </li><li>  Schreiben Sie den Inhalt von Register 2 in die in Register 1 gespeicherte Adresse </li></ol><br>  Im Code sieht es ungefähr so ​​aus: <br><br><pre> <code class="hljs pgsql"> lea a1, #<span class="hljs-meta"><span class="hljs-meta">$1000</span></span> ;   a lea a2, #<span class="hljs-meta"><span class="hljs-meta">$1008</span></span> ;   b <span class="hljs-keyword"><span class="hljs-keyword">move</span></span>.l d0,(a2) <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>.l d0, #<span class="hljs-meta"><span class="hljs-meta">$64</span></span> mov (a1),d0</code> </pre> <br>  Folgendes ist zu beachten: <br><br><ul><li>  In einer höheren Sprache entscheidet der Compiler, wo die Variablen im Speicher abgelegt werden sollen.  Wenn Sie Code in Assembler schreiben, sind Sie selbst für jede Speicheradresse verantwortlich, die Sie verwenden werden. </li><li>  In den meisten Assemblersprachen bedeuten Klammern "Speicher an dieser Adresse". </li><li>  In den meisten Assemblersprachen bezeichnet # eine algebraische Zahl, die auch als Sofortwert bezeichnet wird.  In Zeile 1 des obigen Beispiels schreibt der Code beispielsweise tatsächlich den Wert # 0x1000, um a1 zu registrieren.  Wenn der Code wie <code>move.l a1, ($1000)</code> erhält a1 den Speicherinhalt unter der Adresse 0x1000. </li><li>  Jeder Prozessor hat seine eigene Assemblersprache, und das Portieren von Code von einem Prozessor zu einem anderen kann schwierig sein. </li><li>  Dies ist keine echte Prozessorassemblersprache, ich habe sie als Beispiel angeführt. </li></ul><br>  Eines haben jedoch High-Level-Smart-Programmierer und Assembler-Assistenten gemeinsam.  Assembler-Programmierer halten es für eine Ehre, die Aufgabe so effizient wie möglich zu erledigen und die Anzahl der verwendeten Anweisungen zu minimieren.  Der Code für Arcade-Automaten ist normalerweise stark optimiert und alle Säfte werden aus jedem zusätzlichen Byte und Zyklus herausgepresst. <br><br><h1>  Stapel </h1><br>  Lassen Sie uns etwas mehr über die Assemblersprache sprechen.  In jedem recht komplexen Computerprogramm werden in Assembler Unterprogramme verwendet.  Die meisten CPUs haben eine Struktur, die als Stapel bezeichnet wird. <br><br>  Stellen Sie sich einen Stapel in Form eines Stapels vor.  Wenn wir eine Nummer speichern müssen, legen wir sie oben auf den Stapel.  Wenn wir es zurückbringen müssen, nehmen wir es von der Oberseite des Stapels.  Assembler-Programmierer nennen das Poppen der Nummer auf dem Stapel "Push", und das Herausspringen wird als "Pop" bezeichnet. <br><br>  Angenommen, mein Programm muss eine Unterroutine aufrufen.  Ich kann ähnlichen Code schreiben: <br><br><pre> <code class="hljs css"> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1000</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">d0</span></span> ;  <span class="hljs-selector-tag"><span class="hljs-selector-tag">d0</span></span>   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1004</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;     0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1008</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">d1</span></span> ;  <span class="hljs-selector-tag"><span class="hljs-selector-tag">d1</span></span>   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1010</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;  .. 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1014</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">a0</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1018</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x101C</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">a1</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1020</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1024</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-id"><span class="hljs-selector-id">#0x1030</span></span> ;   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1028</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x102C</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#0x2040</span></span> ;   <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x2040</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1030</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a1</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>) ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1034</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1038</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a0</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>) ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x103c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span>  ..</code> </pre> <br>  Der oben gezeigte Code schiebt die Werte d0, d1, a0 und a1 auf den Stapel.  Die meisten Prozessoren verwenden einen Stapelzeiger.  Dies kann ein reguläres Register sein, das üblicherweise als Stapelzeiger verwendet wird, oder ein spezielles Register mit Funktionen für bestimmte Anweisungen. <br><br>  Auf Prozessoren der 68K-Serie wird der Stapelzeiger nur durch Konvention bestimmt, andernfalls handelt es sich um ein reguläres Register.  In unserem 8080-Prozessor ist das SP-Register ein spezielles Register.  Es verfügt über PUSH- und POP-Befehle, die in nur einem Befehl vom Stapel geschrieben und eingeblendet werden. <br><br>  In unserem Emulatorprojekt schreiben wir keinen Code von Grund auf neu.  Wenn Sie jedoch Programme in Assemblersprache analysieren müssen, ist es gut zu lernen, solche Konstruktionen zu erkennen. <br><br><h4>  Hochsprachen </h4><br>  Beim Schreiben eines Programms in einer höheren Sprache werden alle Vorgänge zum Speichern und Wiederherstellen von Registern bei jedem Funktionsaufruf ausgeführt.  Wir denken nicht an sie, weil der Compiler sich mit ihnen befasst.  Funktionsaufrufe in einer Hochsprache können viel Speicher und Prozessorzeit in Anspruch nehmen. <br><br>  Haben Sie jemals einen Programmabsturz beim Aufrufen eines Unterprogramms in einer Endlosschleife erlebt?  Dies kann passieren, weil bei jedem Funktionsaufruf Registerwerte auf den Stapel verschoben wurden und der Speicher irgendwann nicht mehr über genügend Speicher verfügt.  (Wenn der Stapel zu groß wird, wird dies als Stapelüberlauf oder Stapelüberlauf bezeichnet.) <br><br>  Möglicherweise haben Sie von Inline-Funktionen gehört.  Sie vermeiden das Speichern und Wiederherstellen von Registern, indem sie den Routinecode in die aufrufende Funktion aufnehmen.  Der Code wird größer, aber dank dessen werden mehrere Befehle und Lese- / Schreibvorgänge im Speicher gespeichert. <br><br><h4>  Konventionen aufrufen </h4><br>  Wenn Sie ein Assembler-Programm schreiben, das nur Ihren Code aufruft, können Sie selbst entscheiden, wie die Routinen miteinander kommunizieren.  Wie kehre ich beispielsweise nach Abschluss der Routine zur aufrufenden Funktion zurück?  Eine Möglichkeit besteht darin, die Absenderadresse in ein bestimmtes Register zu schreiben.  Die andere besteht darin, die Absenderadresse oben auf dem Stapel zu platzieren.  Sehr oft hängt die Entscheidung davon ab, was der Prozessor unterstützt.  Der 8080 verfügt über einen CALL-Befehl, der die Rücksprungadresse einer Funktion auf den Stapel überträgt.  Vielleicht verwenden Sie diesen 8080-Befehl, um Unterprogrammaufrufe zu implementieren. <br><br>  Eine weitere Entscheidung muss getroffen werden.  Liegt die Registererhaltung in der Verantwortung der aufrufenden Funktion oder Unterroutine?  Im obigen Beispiel werden die Register von der aufrufenden Funktion gespeichert.  Aber was ist, wenn wir 32 Register haben?  Das Speichern und Wiederherstellen von 32 Registern, wenn eine Routine nur einen kleinen Teil davon verwendet, ist Zeitverschwendung. <br><br>  Der Kompromiss kann ein gemischter Ansatz sein.  Angenommen, wir wählen eine Richtlinie, in der eine Routine die Register r10-r32 verwenden kann, ohne deren Inhalt zu speichern, r1-r9 jedoch nicht zerstören kann.  In einer ähnlichen Situation kennt die aufrufende Funktion Folgendes: <br><br><ul><li>  Bei der Rückkehr von einer Funktion bleibt der Inhalt von r1-r9 unverändert </li><li>  Ich kann mich nicht auf den Inhalt von r10-r32 verlassen </li><li>  Wenn ich nach dem Aufrufen einer Unterroutine einen Wert in r10-r32 benötige, muss ich ihn vor dem Aufrufen irgendwo speichern </li></ul><br>  Ebenso kennt jede Routine Folgendes: <br><br><ul><li>  Ich kann r10-r32 zerstören </li><li>  Wenn ich r1-r9 verwenden möchte, muss ich den Inhalt speichern und wiederherstellen, bevor ich zu der Funktion zurückkehre, die mich aufgerufen hat </li></ul><br><h4>  Abi </h4><br>  Auf den meisten modernen Plattformen werden solche Richtlinien von Ingenieuren erstellt und in Dokumenten veröffentlicht, die als ABI (Application Binary Interface) bezeichnet werden.  Dank dieses Dokuments wissen Compiler-Ersteller, wie sie Code kompilieren, der von anderen Compilern kompilierten Code aufrufen kann.  Wenn Sie Assembler-Code schreiben möchten, der in einer solchen Umgebung funktionieren kann, müssen Sie ABI kennen und den entsprechenden Code schreiben. <br><br>  Die Kenntnis von ABI hilft auch beim Debuggen von Code, wenn Sie keinen Zugriff auf die Quelle haben.  Das ABI definiert die Position von Parametern für Funktionen. Wenn Sie also ein Unterprogramm berücksichtigen, können Sie diese Adressen untersuchen, um zu verstehen, was an die Funktionen übergeben wird. <br><br><h4>  Zurück zum Emulator </h4><br>  Der meiste handgeschriebene Assembler-Code, insbesondere für ältere Prozessoren und Arcade-Spiele, folgt nicht ABI.  Programme werden zusammengestellt und haben möglicherweise nicht viele Routinen.  Jede Routine speichert und stellt Register nur im Notfall wieder her. <br><br>  Wenn Sie verstehen möchten, was das Programm tut, markieren Sie zunächst die Adressen, die für CALL-Befehle bestimmt sind. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418635/">https://habr.com/ru/post/de418635/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418625/index.html">Geheimer Anruf bei Andy Grove, der Apple beim Kauf des NeXT half</a></li>
<li><a href="../de418627/index.html">Weitere Informationen zu Methoden zur Lösung linearer algebraischer Gleichungssysteme</a></li>
<li><a href="../de418629/index.html">So überprüfen Sie unabhängig, ob Sie Ihr Produkt patentieren und eine Patentrecherche durchführen können</a></li>
<li><a href="../de418631/index.html">7 Richtlinien für Javascript-Code</a></li>
<li><a href="../de418633/index.html">JavaScript-Reaktivität: Ein einfaches und intuitives Beispiel</a></li>
<li><a href="../de418637/index.html">Kubernetes an die Massen: Slurm startet am 3. August</a></li>
<li><a href="../de418639/index.html">Akka Streams für bloße Sterbliche</a></li>
<li><a href="../de418641/index.html">Ein Fehler, der einen Designer davon abhält, zu wachsen</a></li>
<li><a href="../de418643/index.html">Sitzen gegen Stehen: Wie kann man besser arbeiten?</a></li>
<li><a href="../de418645/index.html">Beiträge von der Frühjahrskonferenz C ++ Russia 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>