<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñüèΩ üéã üë®‚Äçüè´ Erstellen eines Emulator-Arcade-Automaten. Teil 1 üë©‚Äçüë©‚Äçüëß‚Äçüëß üñáÔ∏è üåê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Schreiben eines Arcade-Maschinenemulators ist ein gro√üartiges Bildungsprojekt, und in diesem Tutorial werden wir den gesamten Entwicklungsprozess ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines Emulator-Arcade-Automaten. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418635/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/735/b99/6eb735b9990860a94f9ef0a18ba46a82.jpg" alt="Bild"></div><br>  Das Schreiben eines Arcade-Maschinenemulators ist ein gro√üartiges Bildungsprojekt, und in diesem Tutorial werden wir den gesamten Entwicklungsprozess sehr detailliert betrachten.  M√∂chten Sie den Prozessor wirklich in die Finger bekommen?  Dann ist das Erstellen eines Emulators der beste Weg, dies zu lernen. <br><br>  Sie ben√∂tigen Kenntnisse in C sowie Kenntnisse in Assembler.  Wenn Sie die Assemblersprache nicht kennen, ist das Schreiben eines Emulators der beste Weg, um sie zu lernen.  Sie m√ºssen auch die hexadezimale Mathematik beherrschen (auch als Basis 16 oder einfach als ‚ÄûHex‚Äú bezeichnet).  Ich werde √ºber dieses Thema sprechen. <br><br>  Ich habe mich f√ºr einen Emulator f√ºr die Space Invaders-Maschine entschieden, die den 8080-Prozessor verwendet. Dieses Spiel und dieser Prozessor sind sehr beliebt, da Sie im Internet viele Informationen dar√ºber finden k√∂nnen.  Sie ben√∂tigen es, um das Projekt abzuschlie√üen. <br><br>  Der gesamte Quellcode des Tutorials wird auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github</a> hochgeladen.  Wenn Sie die Arbeit mit Git nicht beherrschen, finden Sie auf der Github-Seite eine Schaltfl√§che "ZIP herunterladen", mit der Sie das Archiv mit dem gesamten Code herunterladen k√∂nnen. <br><a name="habracut"></a><br><h1>  Einf√ºhrung in Bin√§r- und Hexadezimalzahlen </h1><br>  In der "normalen" Mathematik wird das Dezimalzahlensystem verwendet.  Jede Ziffer der Zahl kann einen Wert von null bis neun haben. Wenn wir 9 √ºberschreiten, addieren wir eins zur Zahl in der n√§chsten Ziffer und beginnen erneut bei Null.  Das ist alles ganz einfach und unkompliziert, und Sie haben wahrscheinlich nie dar√ºber nachgedacht. <br><br>  M√∂glicherweise haben Sie gewusst oder geh√∂rt, dass Computer mit Bin√§rdaten arbeiten.  Computerfreaks nennen Base-10-Dezimalmathematik und Bin√§r-Call-Base-2.  In der bin√§ren Notation kann jede Ziffer einer Zahl nur zwei Werte haben, null oder eins.  Im Bin√§rcode lautet die Anzahl wie folgt: 0, 1, 10, 11, 100, 101, 110, 111, 1000. Dies sind keine Dezimalzahlen, daher k√∂nnen Sie sie nicht "Null, Eins, Zehn, Elf, Einhundert, Einhundertein" nennen.  Sie werden ausgesprochen als "Null, Eins, Eins-Null, Eins-Eins, Eins-Null-Null" usw.  Ich lese Bin√§rzahlen selten laut vor, aber wenn n√∂tig, m√ºssen Sie das verwendete Zahlensystem klar angeben.  Zehn, elf und einhundert haben in der bin√§ren Notation keine Bedeutung. <br><br>  In Dezimalschreibweise hat eine Zahl die folgenden Ziffern: Einheiten, Zehner, Hunderter, Tausende, Zehntausende usw.  Im bin√§ren System die folgenden Ziffern: Einheiten, Zweien, Vierer, Achtel usw.  <strong>In der Informatik wird der Wert jedes Bin√§rbits als Bit bezeichnet.</strong>  <strong>8 Bits bilden ein Byte.</strong> <br><br>  In bin√§ren Begriffen wird eine Folge von Zahlen schnell sehr lang.  Um die Dezimalzahl 20.000 bin√§r darzustellen, sind 16 Ziffern erforderlich: 0b100111000100000.  Um dieses Problem zu beheben, ist es zweckm√§√üig, ein Hexadezimalzahlensystem zu verwenden, das auch als Basis-16 (oder Hex) bezeichnet wird.  In Basis 16 enth√§lt jede Ziffer 16 Werte.  F√ºr Werte von null bis neun werden die gleichen Zeichen wie in Basis 10 verwendet, aber f√ºr die verbleibenden 6 Werte werden Substitutionen in Form der ersten 6 Buchstaben des Alphabets von A bis F verwendet. <br><br>  Die Abrechnung im Hexadezimalsystem erfolgt wie folgt: 0 1 2 3 4 5 6 7 8 9 ABCDEF 10 11 12 usw.  Im Hexadezimalbereich haben Zehner, Hunderter usw. nicht die gleiche Bedeutung wie im Dezimalbereich, daher sprechen die Menschen Zahlen separat aus.  Zum Beispiel wird $ A57 laut als "A-f√ºnf-sieben" ausgesprochen.  Aus Gr√ºnden der √úbersichtlichkeit k√∂nnen Sie auch Hex hinzuf√ºgen, z. B. "A-f√ºnf-sieben-hex".  Im Hexadezimalzahlensystem entspricht das √Ñquivalent der Dezimalzahl 20.000 $ 4E20 - eine viel kompaktere Form im Vergleich zu 16 Bit des Bin√§rsystems. <br><br>  Ich denke, das Hexadezimalsystem wurde aufgrund einer sehr nat√ºrlichen Umwandlung von bin√§r nach hexadezimal und umgekehrt gew√§hlt.  Jede hexadezimale Ziffer entspricht 4 Bits (4 Bits) einer √§hnlichen Bin√§rzahl.  <strong>2 hexadezimale Ziffern bilden ein Byte (8 Bits).</strong>  Eine einzelne hexadezimale Ziffer kann als Knabbern bezeichnet werden, und einige Leute schreiben sie sogar als ‚ÄûNybble‚Äú durch y. <br><br><table><tbody><tr><th colspan="4">  Jede hexadezimale Ziffer besteht aus 4 Bin√§rziffern </th></tr><tr><td>  Hex </td><td>  A. </td><td>  5 </td><td>  7 </td></tr><tr><td>  Bin√§r </td><td>  1010 </td><td>  0101 </td><td>  0111 </td></tr></tbody></table><br>  Beim Schreiben von C-Code wird angenommen, dass die Zahl dezimal ist (Basis-10), sofern nicht anders angegeben.  Um dem C-Compiler mitzuteilen, dass die Zahl bin√§r ist, f√ºgen wir die Zahl Null und den Buchstaben b in Kleinbuchstaben hinzu: <code>0b1101101</code> .  Die Hexadezimalzahl kann in C-Code geschrieben werden, indem am Anfang von Null und x in Kleinbuchstaben <code>0xA57</code> wird: <code>0xA57</code> .  Einige Assemblersprachen verwenden das Dollarzeichen $: <code>$A57</code> , um eine Hex-Zahl anzugeben. <br><br>  Wenn Sie dar√ºber nachdenken, ist der Zusammenhang zwischen Bin√§r-, Hexadezimal- und Dezimalzahlen ziemlich offensichtlich, aber f√ºr den ersten Ingenieur, der vor der Erfindung des Computers daran gedacht hatte, sollte dies ein Moment der Einsicht geworden sein. <br><br>  Das alles verstanden?  Gro√üartig. <br><br><h1>  Eine kurze Einf√ºhrung in den Prozessor </h1><br>  <em>Wenn Sie dies bereits wissen, k√∂nnen Sie den Abschnitt sicher √ºberspringen.</em> <br><br>  Eine Zentraleinheit (CPU) ist eine Maschine zum Ausf√ºhren von Programmen.  Die Grundbl√∂cke der CPU sind Register und Anweisungen.  Als Softwareentwickler k√∂nnen Sie diese Register als Variablen behandeln.  In unserem 8080-Prozessor gibt es unter anderem 8-Bit-Register mit den Namen A, B, C, D und E. Diese Register k√∂nnen als der folgende C-Code interpretiert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> A, B, C, D, E;</code> </pre> <br>  Alle Prozessoren haben auch einen Programmz√§hler (Programmz√§hler, PC).  Sie k√∂nnen es als Zeiger nehmen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pc;</code> </pre> <br>  F√ºr eine CPU ist ein Programm eine Folge von Hexadezimalzahlen.  Jeder Assembler-Befehl in 8080 entspricht 1-3 Bytes im Programm.  Um herauszufinden, welcher Befehl welcher Nummer entspricht, ist das Prozessorhandbuch (oder andere Informationen zum 8080-Prozessor aus dem Internet) hilfreich. <br><br>  Die Namen von Befehlen (Anweisungen) sind h√§ufig Mnemoniken aus den von diesen Befehlen ausgef√ºhrten Operationen.  Die Mnemonik zum Laden in 8080 ist MOV (Verschieben), und ADD wird verwendet, um die Addition durchzuf√ºhren. <br><br><h4>  Beispiele </h4><br>  Der aktuelle Befehlswert, der vom Befehlsz√§hler angezeigt wird, ist 0x79.  Dies entspricht der <code>MOV A,C</code> Anweisung <code>MOV A,C</code> 8080-Prozessors. Dieser Assembler-Code im C-Code sieht wie folgt aus: <code>A=C;</code>  . <br><br>  Wenn stattdessen der Wert im PC 0x80 w√§re, w√ºrde der Prozessor <code>ADD B</code> ausf√ºhren <code>ADD B</code>  In C entspricht dies der Zeichenfolge <code>A = A + B;</code>  . <br><br>  Eine vollst√§ndige Liste der 8080-Prozessoranweisungen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Um unseren Emulator zu implementieren, werden wir diese Informationen verwenden. <br><br><h4>  Timings </h4><br>  In der CPU erfordert die Ausf√ºhrung jedes Befehls eine bestimmte Zeit (Timing), gemessen in Zyklen.  In modernen Prozessoren kann es schwierig sein, diese Informationen zu erhalten, da das Timing von vielen verschiedenen Aspekten abh√§ngt.  Bei √§lteren Prozessoren wie dem 8080 sind die Timings jedoch konstant, und diese Informationen werden h√§ufig vom Prozessorhersteller bereitgestellt.  Beispielsweise dauert ein √úbertragungsbefehl von Register zu Register MOV 1 Zyklus. <br><br>  Timing-Informationen sind n√ºtzlich, um effizienten Code in den Prozessor zu schreiben.  Ein Programmierer kann versuchen, Anweisungen zu vermeiden, deren Ausf√ºhrung viele Zyklen dauert. <br><br>  Wichtiger f√ºr uns ist, dass wir Timing-Informationen verwenden, um den Prozessor zu emulieren.  Damit das Spiel wie auf dem Original funktioniert, m√ºssen die Anweisungen mit der richtigen Geschwindigkeit ausgef√ºhrt werden.  Einige Emulatoren geben sich viel M√ºhe, aber wenn wir dazu kommen, m√ºssen wir uns entscheiden, welche Genauigkeit wir erreichen wollen. <br><br><h1>  Logische Operationen </h1><br>  Bevor wir das Thema Bin√§r- und Hexadezimalzahlen schlie√üen, sollten wir √ºber logische Operationen sprechen.  Sie sind wahrscheinlich bereits daran gew√∂hnt, Logik in Ihrem Code zu verwenden, beispielsweise in Konstrukten wie <code>if ((conditionA) and (conditionB))</code> .  In Programmen, die direkt mit Hardware arbeiten, m√ºssen Sie h√§ufig einzelne Zahlenbits bearbeiten. <br><br><h3>  UND-Betrieb </h3><br>  Hier sind alle m√∂glichen Ergebnisse der UND-Operation (UND) (Wahrheitstabelle) zwischen zwei Einzelbitzahlen. <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Ergebnis </td></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  1 </td><td>  0 </td></tr><tr><td>  1 </td><td>  0 </td><td>  0 </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td></tr></tbody></table><br>  Das Ergebnis von UND ist nur dann gleich Eins, wenn beide Werte gleich Eins sind.  Wenn wir zwei Zahlen mit der UND-Operation kombinieren, ist UND f√ºr jedes Bit einer Zahl UND mit dem entsprechenden Bit der anderen Zahl.  Das Ergebnis wird in diesem Bit der Zielnummer gespeichert.  Wahrscheinlich besser, um nur ein Beispiel zu betrachten: <br><br><table><tbody><tr><td></td><td colspan="8">  bin√§r </td><td>  hex </td></tr><tr><td>  Quelle x </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  $ 6B </td></tr><tr><td>  Quelle y </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  $ D2 </td></tr><tr><td>  x UND y </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  $ 42 </td></tr></tbody></table><br>  In C ist die logische UND-Verkn√ºpfung ein einfaches kaufm√§nnisches Und "&amp;". <br><br><h3>  Operation ODER (ODER) </h3><br>  Die ODER-Verkn√ºpfung funktioniert auf √§hnliche Weise.  Der einzige Unterschied besteht darin, dass das Ergebnis gleich eins ist, wenn mindestens einer der Werte von x oder y gleich eins ist. <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Ergebnis </td></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  1 </td><td>  1 </td></tr><tr><td>  1 </td><td>  0 </td><td>  1 </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td></tr></tbody></table><br><table><tbody><tr><td></td><td colspan="8">  bin√§r </td><td>  hex </td></tr><tr><td>  Quelle x </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  $ 6B </td></tr><tr><td>  Quelle y </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  $ D2 </td></tr><tr><td>  x ODER y </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  $ Fb </td></tr></tbody></table><br>  In C wird eine logische ODER-Verkn√ºpfung durch einen vertikalen Balken "|" angezeigt. <br><br><h3>  Warum ist das wichtig? </h3><br>  In vielen √§lteren Prozessoren und insbesondere in Arcade-Maschinen erfordert das Spiel oft, nur mit einem Bit der Zahl zu arbeiten.  Oft gibt es einen √§hnlichen Code: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/*  1:     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buttons_ptr = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-number"><span class="hljs-number">0x2043</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buttons = *buttons_ptr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buttons &amp; <span class="hljs-number"><span class="hljs-number">0x4</span></span>) HandleLeftButton(); <span class="hljs-comment"><span class="hljs-comment">/*  2:  LED-    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * LED_pointer = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) <span class="hljs-number"><span class="hljs-number">0x2089</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> led = *LED_pointer; led = led | <span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-comment"><span class="hljs-comment">//,  LED   6 *LED_pointer = led; /*  3:   LED- */ char * LED_pointer = (char *) 0x2089; char led = *LED_pointer; led = led &amp; 0xBF; //  6 *LED_pointer = led;</span></span></code> </pre> <br>  In Beispiel 1 ist die im Speicher zugewiesene Adresse $ 2043 die Adresse der Tasten auf dem Bedienfeld.  Dieser Code liest und reagiert auf die gedr√ºckte Taste.  (Nat√ºrlich wird dieser Code in Space Invaders in Assemblersprache sein!) <br><br>  In Beispiel 2 m√∂chte das Spiel eine LED-Anzeige aufleuchten lassen, die sich in Bit 6 der im Speicher zugewiesenen $ 2089-Adresse befindet.  Der Code sollte den vorhandenen Wert lesen, nur ein Bit √§ndern und ihn zur√ºckschreiben. <br><br>  In Beispiel 3 m√ºssen Sie den Indikator von Beispiel 2 ausschalten, damit der Code Bit 6 der Adresse $ 2089 zur√ºcksetzt.  Dies kann erreicht werden, indem die UND-Operation f√ºr das Indikatorsteuerbyte mit einem Wert ausgef√ºhrt wird, f√ºr den nur Bit 6 Null ist. Wir werden also nur 6 beeinflussen und die verbleibenden Bits unver√§ndert lassen. <br><br>  Dies wird normalerweise als "Maske" bezeichnet.  In C wird eine Maske normalerweise mit dem Operator NOT geschrieben, der durch eine Tilde ("~") gekennzeichnet ist.  Anstatt <code>~0x40</code> schreiben, schreibe ich einfach <code>~0x40</code> und erhalte die gleiche Nummer, aber ohne gro√üen Aufwand. <br><br><h1>  Einf√ºhrung in die Assemblersprache </h1><br>  Wenn Sie dieses Tutorial lesen, sind Sie wahrscheinlich mit Computerprogrammierung vertraut, beispielsweise in Java oder Python.  Mit diesen Sprachen k√∂nnen Sie viel Arbeit in nur wenigen Codezeilen erledigen.  Code gilt als geschickt geschrieben, wenn er in m√∂glichst wenigen Zeilen so viel Arbeit wie m√∂glich leistet und m√∂glicherweise sogar die Funktionalit√§t der integrierten Bibliotheken nutzt.  Solche Sprachen werden "Hochsprachen" genannt. <br><br>  In der Assemblersprache sind dagegen keine lebensrettenden Funktionen integriert, und m√∂glicherweise sind viele einfache Codezeilen erforderlich, um einfache Aufgaben auszuf√ºhren.  Assemblersprache wird als einfache Sprache betrachtet.  Darin muss man sich daran gew√∂hnen, im Stil zu denken: "Welche spezifische Abfolge von Schritten muss unternommen werden, um diese Aufgabe zu erledigen?" <br><br>  Das Wichtigste, was Sie √ºber die Assembler-Sprache wissen m√ºssen, ist, dass jede Zeile in einen Prozessorbefehl √ºbersetzt wird. <br><br>  Betrachten Sie eine solche Konstruktion aus der C-Sprache: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = b + <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  In der Assemblersprache muss diese Aufgabe in der folgenden Reihenfolge ausgef√ºhrt werden: <br><br><ol><li>  Laden Sie die Adresse der Variablen B in Register 1 </li><li>  Laden Sie den Inhalt dieser Speicheradresse in Register 2 </li><li>  Addiere den direkten Wert 0x64 zu Register 2 </li><li>  Laden Sie die Adresse der Variablen A in Register 1 </li><li>  Schreiben Sie den Inhalt von Register 2 in die in Register 1 gespeicherte Adresse </li></ol><br>  Im Code sieht es ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="hljs pgsql"> lea a1, #<span class="hljs-meta"><span class="hljs-meta">$1000</span></span> ;   a lea a2, #<span class="hljs-meta"><span class="hljs-meta">$1008</span></span> ;   b <span class="hljs-keyword"><span class="hljs-keyword">move</span></span>.l d0,(a2) <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>.l d0, #<span class="hljs-meta"><span class="hljs-meta">$64</span></span> mov (a1),d0</code> </pre> <br>  Folgendes ist zu beachten: <br><br><ul><li>  In einer h√∂heren Sprache entscheidet der Compiler, wo die Variablen im Speicher abgelegt werden sollen.  Wenn Sie Code in Assembler schreiben, sind Sie selbst f√ºr jede Speicheradresse verantwortlich, die Sie verwenden werden. </li><li>  In den meisten Assemblersprachen bedeuten Klammern "Speicher an dieser Adresse". </li><li>  In den meisten Assemblersprachen bezeichnet # eine algebraische Zahl, die auch als Sofortwert bezeichnet wird.  In Zeile 1 des obigen Beispiels schreibt der Code beispielsweise tats√§chlich den Wert # 0x1000, um a1 zu registrieren.  Wenn der Code wie <code>move.l a1, ($1000)</code> erh√§lt a1 den Speicherinhalt unter der Adresse 0x1000. </li><li>  Jeder Prozessor hat seine eigene Assemblersprache, und das Portieren von Code von einem Prozessor zu einem anderen kann schwierig sein. </li><li>  Dies ist keine echte Prozessorassemblersprache, ich habe sie als Beispiel angef√ºhrt. </li></ul><br>  Eines haben jedoch High-Level-Smart-Programmierer und Assembler-Assistenten gemeinsam.  Assembler-Programmierer halten es f√ºr eine Ehre, die Aufgabe so effizient wie m√∂glich zu erledigen und die Anzahl der verwendeten Anweisungen zu minimieren.  Der Code f√ºr Arcade-Automaten ist normalerweise stark optimiert und alle S√§fte werden aus jedem zus√§tzlichen Byte und Zyklus herausgepresst. <br><br><h1>  Stapel </h1><br>  Lassen Sie uns etwas mehr √ºber die Assemblersprache sprechen.  In jedem recht komplexen Computerprogramm werden in Assembler Unterprogramme verwendet.  Die meisten CPUs haben eine Struktur, die als Stapel bezeichnet wird. <br><br>  Stellen Sie sich einen Stapel in Form eines Stapels vor.  Wenn wir eine Nummer speichern m√ºssen, legen wir sie oben auf den Stapel.  Wenn wir es zur√ºckbringen m√ºssen, nehmen wir es von der Oberseite des Stapels.  Assembler-Programmierer nennen das Poppen der Nummer auf dem Stapel "Push", und das Herausspringen wird als "Pop" bezeichnet. <br><br>  Angenommen, mein Programm muss eine Unterroutine aufrufen.  Ich kann √§hnlichen Code schreiben: <br><br><pre> <code class="hljs css"> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1000</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">d0</span></span> ;  <span class="hljs-selector-tag"><span class="hljs-selector-tag">d0</span></span>   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1004</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;     0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1008</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">d1</span></span> ;  <span class="hljs-selector-tag"><span class="hljs-selector-tag">d1</span></span>   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1010</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;  .. 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1014</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">a0</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1018</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x101C</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">a1</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1020</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1024</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-id"><span class="hljs-selector-id">#0x1030</span></span> ;   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1028</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x102C</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#0x2040</span></span> ;   <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x2040</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1030</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a1</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>) ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1034</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1038</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a0</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>) ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x103c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span>  ..</code> </pre> <br>  Der oben gezeigte Code schiebt die Werte d0, d1, a0 und a1 auf den Stapel.  Die meisten Prozessoren verwenden einen Stapelzeiger.  Dies kann ein regul√§res Register sein, das √ºblicherweise als Stapelzeiger verwendet wird, oder ein spezielles Register mit Funktionen f√ºr bestimmte Anweisungen. <br><br>  Auf Prozessoren der 68K-Serie wird der Stapelzeiger nur durch Konvention bestimmt, andernfalls handelt es sich um ein regul√§res Register.  In unserem 8080-Prozessor ist das SP-Register ein spezielles Register.  Es verf√ºgt √ºber PUSH- und POP-Befehle, die in nur einem Befehl vom Stapel geschrieben und eingeblendet werden. <br><br>  In unserem Emulatorprojekt schreiben wir keinen Code von Grund auf neu.  Wenn Sie jedoch Programme in Assemblersprache analysieren m√ºssen, ist es gut zu lernen, solche Konstruktionen zu erkennen. <br><br><h4>  Hochsprachen </h4><br>  Beim Schreiben eines Programms in einer h√∂heren Sprache werden alle Vorg√§nge zum Speichern und Wiederherstellen von Registern bei jedem Funktionsaufruf ausgef√ºhrt.  Wir denken nicht an sie, weil der Compiler sich mit ihnen befasst.  Funktionsaufrufe in einer Hochsprache k√∂nnen viel Speicher und Prozessorzeit in Anspruch nehmen. <br><br>  Haben Sie jemals einen Programmabsturz beim Aufrufen eines Unterprogramms in einer Endlosschleife erlebt?  Dies kann passieren, weil bei jedem Funktionsaufruf Registerwerte auf den Stapel verschoben wurden und der Speicher irgendwann nicht mehr √ºber gen√ºgend Speicher verf√ºgt.  (Wenn der Stapel zu gro√ü wird, wird dies als Stapel√ºberlauf oder Stapel√ºberlauf bezeichnet.) <br><br>  M√∂glicherweise haben Sie von Inline-Funktionen geh√∂rt.  Sie vermeiden das Speichern und Wiederherstellen von Registern, indem sie den Routinecode in die aufrufende Funktion aufnehmen.  Der Code wird gr√∂√üer, aber dank dessen werden mehrere Befehle und Lese- / Schreibvorg√§nge im Speicher gespeichert. <br><br><h4>  Konventionen aufrufen </h4><br>  Wenn Sie ein Assembler-Programm schreiben, das nur Ihren Code aufruft, k√∂nnen Sie selbst entscheiden, wie die Routinen miteinander kommunizieren.  Wie kehre ich beispielsweise nach Abschluss der Routine zur aufrufenden Funktion zur√ºck?  Eine M√∂glichkeit besteht darin, die Absenderadresse in ein bestimmtes Register zu schreiben.  Die andere besteht darin, die Absenderadresse oben auf dem Stapel zu platzieren.  Sehr oft h√§ngt die Entscheidung davon ab, was der Prozessor unterst√ºtzt.  Der 8080 verf√ºgt √ºber einen CALL-Befehl, der die R√ºcksprungadresse einer Funktion auf den Stapel √ºbertr√§gt.  Vielleicht verwenden Sie diesen 8080-Befehl, um Unterprogrammaufrufe zu implementieren. <br><br>  Eine weitere Entscheidung muss getroffen werden.  Liegt die Registererhaltung in der Verantwortung der aufrufenden Funktion oder Unterroutine?  Im obigen Beispiel werden die Register von der aufrufenden Funktion gespeichert.  Aber was ist, wenn wir 32 Register haben?  Das Speichern und Wiederherstellen von 32 Registern, wenn eine Routine nur einen kleinen Teil davon verwendet, ist Zeitverschwendung. <br><br>  Der Kompromiss kann ein gemischter Ansatz sein.  Angenommen, wir w√§hlen eine Richtlinie, in der eine Routine die Register r10-r32 verwenden kann, ohne deren Inhalt zu speichern, r1-r9 jedoch nicht zerst√∂ren kann.  In einer √§hnlichen Situation kennt die aufrufende Funktion Folgendes: <br><br><ul><li>  Bei der R√ºckkehr von einer Funktion bleibt der Inhalt von r1-r9 unver√§ndert </li><li>  Ich kann mich nicht auf den Inhalt von r10-r32 verlassen </li><li>  Wenn ich nach dem Aufrufen einer Unterroutine einen Wert in r10-r32 ben√∂tige, muss ich ihn vor dem Aufrufen irgendwo speichern </li></ul><br>  Ebenso kennt jede Routine Folgendes: <br><br><ul><li>  Ich kann r10-r32 zerst√∂ren </li><li>  Wenn ich r1-r9 verwenden m√∂chte, muss ich den Inhalt speichern und wiederherstellen, bevor ich zu der Funktion zur√ºckkehre, die mich aufgerufen hat </li></ul><br><h4>  Abi </h4><br>  Auf den meisten modernen Plattformen werden solche Richtlinien von Ingenieuren erstellt und in Dokumenten ver√∂ffentlicht, die als ABI (Application Binary Interface) bezeichnet werden.  Dank dieses Dokuments wissen Compiler-Ersteller, wie sie Code kompilieren, der von anderen Compilern kompilierten Code aufrufen kann.  Wenn Sie Assembler-Code schreiben m√∂chten, der in einer solchen Umgebung funktionieren kann, m√ºssen Sie ABI kennen und den entsprechenden Code schreiben. <br><br>  Die Kenntnis von ABI hilft auch beim Debuggen von Code, wenn Sie keinen Zugriff auf die Quelle haben.  Das ABI definiert die Position von Parametern f√ºr Funktionen. Wenn Sie also ein Unterprogramm ber√ºcksichtigen, k√∂nnen Sie diese Adressen untersuchen, um zu verstehen, was an die Funktionen √ºbergeben wird. <br><br><h4>  Zur√ºck zum Emulator </h4><br>  Der meiste handgeschriebene Assembler-Code, insbesondere f√ºr √§ltere Prozessoren und Arcade-Spiele, folgt nicht ABI.  Programme werden zusammengestellt und haben m√∂glicherweise nicht viele Routinen.  Jede Routine speichert und stellt Register nur im Notfall wieder her. <br><br>  Wenn Sie verstehen m√∂chten, was das Programm tut, markieren Sie zun√§chst die Adressen, die f√ºr CALL-Befehle bestimmt sind. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418635/">https://habr.com/ru/post/de418635/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418625/index.html">Geheimer Anruf bei Andy Grove, der Apple beim Kauf des NeXT half</a></li>
<li><a href="../de418627/index.html">Weitere Informationen zu Methoden zur L√∂sung linearer algebraischer Gleichungssysteme</a></li>
<li><a href="../de418629/index.html">So √ºberpr√ºfen Sie unabh√§ngig, ob Sie Ihr Produkt patentieren und eine Patentrecherche durchf√ºhren k√∂nnen</a></li>
<li><a href="../de418631/index.html">7 Richtlinien f√ºr Javascript-Code</a></li>
<li><a href="../de418633/index.html">JavaScript-Reaktivit√§t: Ein einfaches und intuitives Beispiel</a></li>
<li><a href="../de418637/index.html">Kubernetes an die Massen: Slurm startet am 3. August</a></li>
<li><a href="../de418639/index.html">Akka Streams f√ºr blo√üe Sterbliche</a></li>
<li><a href="../de418641/index.html">Ein Fehler, der einen Designer davon abh√§lt, zu wachsen</a></li>
<li><a href="../de418643/index.html">Sitzen gegen Stehen: Wie kann man besser arbeiten?</a></li>
<li><a href="../de418645/index.html">Beitr√§ge von der Fr√ºhjahrskonferenz C ++ Russia 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>