<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧣 🛌🏾 👩🏻‍🎓 Apache Hadoop Code Quality: production VS test ⚙️ 🤷 💿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pour obtenir un code de production de haute qualité, il ne suffit pas de fournir une couverture de test maximale. Sans aucun doute, pour obtenir des r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Hadoop Code Quality: production VS test</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/480928/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c48/f76/cf1/c48f76cf15c8138ce1d944918b1dcc07.png" alt="Figure 1"></div><br>  Pour obtenir un code de production de haute qualité, il ne suffit pas de fournir une couverture de test maximale.  Sans aucun doute, pour obtenir des résultats élevés, le code principal du projet et les tests doivent fonctionner en tandem parfaitement cohérent.  Par conséquent, vous devez faire attention aux tests autant qu'au code principal.  La rédaction d'un bon test est la clé pour rattraper une régression de la production.  Pour montrer l'importance du fait que les bogues dans les tests ne sont pas pires qu'en production, nous considérerons la prochaine analyse des avertissements de l'analyseur statique PVS-Studio.  Cible: Apache Hadoop. <br><a name="habracut"></a><br><h2>  À propos du projet </h2><br>  Ceux qui étaient autrefois intéressés par le Big Data ont probablement entendu parler ou travaillé avec un projet comme <a href="https://hadoop.apache.org/">Apache Hadoop</a> .  En bref, Hadoop est un framework qui peut être utilisé comme base pour construire et travailler avec des systèmes Big Data. <br><br>  Hadoop se compose de quatre modules principaux, chacun effectuant une tâche spécifique nécessaire à un système d'analyse de Big Data: <br><br><ul><li>  Hadoop commun </li><li>  Mapreduce </li><li>  Système de fichiers distribué Hadoop (Système de fichiers distribué Hadoop) </li><li>  Fil </li></ul><br>  Cependant, il existe de nombreux documents pour vous familiariser avec Internet. <br><br><h2>  À propos de la vérification </h2><br>  Comme indiqué dans la <a href="https://www.viva64.com/ru/m/0044/">documentation</a> , PVS-Studio peut être intégré au projet de différentes manières: <br><br><ul><li>  en utilisant le plugin maven; </li><li>  en utilisant le plugin gradle; </li><li>  Utilisation d'IntellJ IDEA </li><li>  en utilisant l'analyseur directement. </li></ul><br>  Hadoop a été construit sur la base du système de construction maven, il n'y a donc eu aucune difficulté avec la vérification. <br><br>  Après avoir intégré le script de la documentation et légèrement ajusté un de pom.xml (il y avait des modules dans les dépendances qui n'étaient pas là), l'analyse est allée! <br><br>  Après l'analyse, en choisissant les avertissements les plus intéressants, j'ai remarqué que j'avais le même nombre d'avertissements dans le code de production et les tests.  Habituellement, je ne considère pas le déclenchement d'un analyseur qui tombe sur des tests.  Mais, en les divisant, je ne pouvais pas manquer les avertissements de la catégorie «tests» devant mon attention.  «Pourquoi pas?», Ai-je pensé, car les bogues dans les tests ont également des conséquences.  Ils peuvent conduire à des tests incorrects ou partiels, voire à des bêtises (juste pour le spectacle, afin qu'ils soient toujours verts). <br><br>  Ainsi, en rassemblant les avertissements les plus intéressants, en les divisant par code (production, test) et les quatre principaux modules Hadoop, je porte à votre attention une analyse du fonctionnement de l'analyseur. <br><br><h2>  Code de production </h2><br><h3>  Hadoop commun </h3><br>  <a href="https://www.viva64.com/ru/w/v6033/">V6033</a> Un élément avec la même clé 'KDC_BIND_ADDRESS' a déjà été ajouté.  MiniKdc.java (163), MiniKdc.java (162) <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MiniKdc</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Set&lt;String&gt; PROPERTIES = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;String&gt;(); .... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { PROPERTIES.add(ORG_NAME); PROPERTIES.add(ORG_DOMAIN); PROPERTIES.add(KDC_BIND_ADDRESS); PROPERTIES.add(KDC_BIND_ADDRESS); <span class="hljs-comment"><span class="hljs-comment">// &lt;= PROPERTIES.add(KDC_PORT); PROPERTIES.add(INSTANCE); .... } .... }</span></span></code> </pre> <br>  Une valeur ajoutée deux fois à un <i>HashSet</i> est un défaut courant lors de la vérification de projets.  En fait, le deuxième ajout sera ignoré.  Eh bien, si cette duplication est un accident absurde.  Et si cela signifiait vraiment ajouter une autre valeur? <br><br><h3>  Mapreduce </h3><br>  <a href="https://www.viva64.com/ru/w/v6072/">V6072</a> Deux fragments de code similaires ont été trouvés.  Il s'agit peut-être d'une faute de frappe et la variable «localFiles» devrait être utilisée à la place de «localArchives».  LocalDistributedCacheManager.java (183), LocalDistributedCacheManager.java (178), LocalDistributedCacheManager.java (176), LocalDistributedCacheManager.java (181) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobConf conf, JobID jobId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Update the configuration object with localized data. if (!localArchives.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils .arrayToString(localArchives.toArray(new String[localArchives // &lt;= .size()]))); } if (!localFiles.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils .arrayToString(localFiles.toArray(new String[localArchives // &lt;= .size()]))); } .... }</span></span></code> </pre> <br>  Diagnostics V6072 fait des résultats parfois très intéressants.  L'essence du diagnostic est de rechercher le même type de fragments de code qui ont été obtenus par copier-coller et en remplaçant une ou deux variables, mais en même temps, certaines variables étaient «sous-estimées». <br><br>  Le code ci-dessus le démontre.  Dans le premier bloc, les actions sont effectuées avec la variable <i>localArchives</i> , dans le bloc suivant du même type, avec <i>localFiles</i> .  Et si vous étudiez consciencieusement ce code et ne le passez pas en revue rapidement, comme c'est souvent le cas avec la révision de code, notez l'endroit où vous avez oublié de remplacer la variable <i>localArchives</i> . <br><br>  Une telle omission pourrait conduire au scénario suivant: <br><br><ul><li>  Supposons que nous ayons <i>localArchives</i> (taille = 4) et <i>localFiles</i> (taille = 2); </li><li>  Lors de la création du tableau <i>localFiles.toArray (nouveau String [localArchives.size ()])</i> , nous obtenons que les 2 derniers éléments soient <i>nuls</i> (["pathToFile1", "pathToFile2", null, null]); </li><li>  Après cela, <i>org.apache.hadoop.util.StringUtils.arrayToString</i> renverra une représentation sous forme de chaîne de notre tableau dans laquelle les derniers noms de fichiers seront représentés comme "null" ("pathToFile1, pathToFile2, null, null" <i>)</i> ; </li><li>  Tout cela sera transmis, et qui sait quels contrôles il y a pour de tels cas =). </li></ul><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007 L'</a> expression 'children.size ()&gt; 0' est toujours vraie.  Queue.java (347) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHierarchySameAs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Queue newState)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || children.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(children.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } .... }</code> </pre> <br>  Étant donné que la vérification du nombre d'éléments à 0 est effectuée séparément, une vérification supplémentaire de <i>children.size ()&gt; 0</i> donnera toujours la valeur true. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/ru/w/v6001/">V6001</a> Il existe des sous-expressions identiques 'this.bucketSize' à gauche et à droite de l'opérateur '%'.  RollingWindow.java (79) <br><br><pre> <code class="java hljs"> RollingWindow(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> windowLenMs, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numBuckets) { buckets = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket[numBuckets]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numBuckets; i++) { buckets[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.windowLenMs = windowLenMs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize = windowLenMs / numBuckets; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize % bucketSize != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw new IllegalArgumentException( "The bucket size in the rolling window is not integer: windowLenMs= " + windowLenMs + " numBuckets= " + numBuckets); } }</span></span></code> </pre> <br>  Ce défaut réside dans le fait que la variable est divisée en elle-même.  Par conséquent, la vérification de la multiplicité passera toujours et, en cas de données d'entrée incorrectes ( <i>windowLenMs</i> , <i>numBuckets</i> ), l'exception ne sera pas levée. <br><br><h3>  Fil </h3><br>  <a href="https://www.viva64.com/ru/w/v6067/">V6067</a> Deux ou plusieurs branches de cas effectuent les mêmes actions.  TimelineEntityV2Converter.java (386), TimelineEntityV2Converter.java (389) <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ApplicationReport </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToApplicationReport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TimelineEntity entity)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (metrics != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> memorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedVcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedMemorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TimelineMetric metric : metrics) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (metric.getId()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_CPU_METRICS: vcoreSeconds = getAverageValue(metric.getValues().values()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_METRICS: memorySeconds = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS: preemptedVcoreSeconds = ....; <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS: preemptedVcoreSeconds = ....; // &lt;= break; default: // Should not happen.. break; } } .... } .... }</span></span></code> </pre> <br>  Dans deux branches de <i>cas</i> , les mêmes fragments de code.  Cela arrive tout le temps!  Dans le nombre prédominant de cas, ce n'est pas une vraie erreur, mais seulement une occasion de penser à une refactorisation des <i>commutateurs</i> .  Mais pas pour le cas en question.  Dans les extraits de code répétitifs, la valeur de la variable <i>preemptedVcoreSeconds est définie</i> .  Si vous faites attention aux noms de toutes les variables et constantes, vous pouvez conclure que dans le cas de <i>metric.getId () == APP_MEM_PREEMPT_METRICS</i> , la valeur de la variable <i>preemptedMemorySeconds</i> doit être définie, et non <i>preemptedVcoreSeconds</i> .  À cet égard, <i>preemptedMemorySeconds</i> restera toujours 0 après l'exécution de l'instruction 'switch', et la valeur de <i>preemptedVcoreSeconds</i> peut être incorrecte. <br><br>  <a href="https://www.viva64.com/ru/w/v6046/">V6046</a> Format incorrect.  Un nombre différent d'éléments de format est attendu.  Arguments non utilisés: 2. AbstractSchedulerPlanFollower.java (186) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synchronizePlan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Plan plan, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shouldReplan)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setQueueEntitlement(planQueueName, ....); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (YarnException e) { LOG.warn(<span class="hljs-string"><span class="hljs-string">"Exception while trying to size reservation for plan: {}"</span></span>, currResId, planQueueName, e); } .... }</code> </pre> <br>  Variable inutilisée <i>planQueueName</i> lors de la connexion.  Ici, ils ont trop copié ou n'ont pas modifié la chaîne de format.  Mais néanmoins, je suis enclin au bon vieux et, en apportant parfois un mauvais service, au copier-coller. <br><br><h2>  Code de test </h2><br><h3>  Hadoop commun </h3><br>  <a href="https://www.viva64.com/ru/w/v6072/">V6072</a> Deux fragments de code similaires ont été trouvés.  Il s'agit peut-être d'une faute de frappe et la variable «allSecretsB» devrait être utilisée à la place de «allSecretsA».  TestZKSignerSecretProvider.java (316), TestZKSignerSecretProvider.java (309), TestZKSignerSecretProvider.java (306), TestZKSignerSecretProvider.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMultiple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> order)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... currentSecretA = secretProviderA.getCurrentSecret(); allSecretsA = secretProviderA.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretA); Assert.assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, allSecretsA.length); <span class="hljs-comment"><span class="hljs-comment">// &lt;= Assert.assertArrayEquals(secretA2, allSecretsA[0]); Assert.assertArrayEquals(secretA1, allSecretsA[1]); currentSecretB = secretProviderB.getCurrentSecret(); allSecretsB = secretProviderB.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretB); Assert.assertEquals(2, allSecretsA.length); // &lt;= Assert.assertArrayEquals(secretA2, allSecretsB[0]); Assert.assertArrayEquals(secretA1, allSecretsB[1]); .... }</span></span></code> </pre> <br>  Et encore V6072.  Attention aux variables <i>allSecretsA</i> et <i>allSecretsB</i> . <br><br>  <a href="https://www.viva64.com/ru/w/v6043/">V6043</a> Envisagez d'inspecter l'opérateur «pour».  Les valeurs initiales et finales de l'itérateur sont identiques.  TestTFile.java (235) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrepWithUnknownLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scanner scanner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = start; i &lt; start; i++) { String key = String.format(localFormatter, i); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] read = readKey(scanner); assertTrue(<span class="hljs-string"><span class="hljs-string">"keys not equal"</span></span>, Arrays.equals(key.getBytes(), read)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { read = readValue(scanner); assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ie) { <span class="hljs-comment"><span class="hljs-comment">// should have thrown exception } String value = "value" + key; read = readLongValue(scanner, value.getBytes().length); assertTrue("values nto equal", Arrays.equals(read, value.getBytes())); scanner.advance(); } return (start + n); }</span></span></code> </pre> <br>  Un test toujours vert?  =).  Le corps de la boucle, qui fait partie du test, n'est jamais exécuté.  Cela est dû au fait que les valeurs de début et de fin du compteur correspondent dans l'instruction <i>for</i> .  Par conséquent, la condition <i>i &lt;start nous</i> donnera immédiatement faux, ce qui conduira à ce comportement.  J'ai parcouru le fichier avec les tests et suis arrivé à la conclusion qu'il était nécessaire d'écrire dans l'état de la boucle <i>i &lt;(start + n)</i> . <br><br><h3>  Mapreduce </h3><br>  a href = " <a href="https://www.viva64.com/ru/w/v6007/">www.viva64.com/en/w/v6007</a> "&gt; V6007 L'expression 'byteAm &lt;0' est toujours fausse.  DataWriter.java (322) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">GenerateOutput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeSegment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> byteAm, OutputStream out)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> headerLen = getHeaderLength(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byteAm &lt; headerLen) { <span class="hljs-comment"><span class="hljs-comment">// not enough bytes to write even the header return new GenerateOutput(0, 0); } // adjust for header length byteAm -= headerLen; if (byteAm &lt; 0) { // &lt;= byteAm = 0; } .... }</span></span></code> </pre> <br>  La condition <i>byteAm &lt;0 est</i> toujours fausse.  Pour comprendre, remontons le code ci-dessus.  Si l'exécution du test atteint l'opération <i>byteAm - = headerLen</i> , cela signifie qu'il y aura <i>byteAm&gt; = headerLen</i> .  À partir de là, après avoir effectué la soustraction, la valeur de <i>byteAm</i> ne sera jamais négative.  Ce qui devait prouver. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/ru/w/v6072/">V6072</a> Deux fragments de code similaires ont été trouvés.  Il s'agit peut-être d'une faute de frappe et la variable «normalFile» devrait être utilisée à la place de «normalDir».  TestWebHDFS.java (625), TestWebHDFS.java (615), TestWebHDFS.java (614), TestWebHDFS.java (624) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWebHdfsErasureCodingFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalDir = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(<span class="hljs-string"><span class="hljs-string">"/dir"</span></span>); dfs.mkdirs(normalDir); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(normalDir, <span class="hljs-string"><span class="hljs-string">"file.log"</span></span>); .... <span class="hljs-comment"><span class="hljs-comment">// logic block #1 FileStatus expectedNormalDirStatus = dfs.getFileStatus(normalDir); FileStatus actualNormalDirStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalDirStatus.isErasureCoded(), actualNormalDirStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalDir); assertTrue(normalDir + " should have erasure coding unset in " + ....); // logic block #2 FileStatus expectedNormalFileStatus = dfs.getFileStatus(normalFile); FileStatus actualNormalFileStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalFileStatus.isErasureCoded(), actualNormalFileStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalFile); assertTrue( normalFile + " should have erasure coding unset in " + ....); }</span></span></code> </pre> <br>  Ne le croyez pas, et encore V6072!  Suivez simplement les <i>variables</i> <i>normalDir</i> et <i>normalFile</i> <br><br>  <a href="https://www.viva64.com/ru/w/v6027/">V6027</a> Les variables sont initialisées via l'appel à la même fonction.  Il s'agit probablement d'une erreur ou d'un code non optimisé.  TestDFSAdmin.java (883), TestDFSAdmin.java (879) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyNodesAndCorruptBlocks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numLiveDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptECBlockGroups, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DFSClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyReplicatedBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyECBlocks)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init vars */</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String expectedCorruptedECBlockGroupsStr = String.format( <span class="hljs-string"><span class="hljs-string">"Block groups with corrupt internal blocks: %d"</span></span>, numCorruptECBlockGroups); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyReplicatedBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyECBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); .... }</code> </pre> <br>  Dans ce fragment, les variables le plus <i>élevéPriorityLowRedundancyReplicatedBlocksStr</i> et le plus <i>élevéPriorityLowRedundancyECBlocksStr sont</i> initialisés avec les mêmes valeurs.  C'est souvent le cas, mais pas dans cette situation.  Les noms de variables ici sont longs et similaires les uns aux autres, donc je ne suis pas surpris qu'il n'y ait pas eu de modifications correspondantes avec le copier-coller.  Pour remédier à la situation, lors de l'initialisation de la variable <i>LowestPriorityLowRedundancyECBlocksStr,</i> vous devez utiliser le paramètre d'entrée <i>LowestPriorityLowRedundancyECBlocks</i> .  En plus de cela, très probablement, vous devez toujours corriger la chaîne de format. <br><br>  <a href="https://www.viva64.com/ru/w/v6019/">V6019</a> Code inaccessible détecté.  Il est possible qu'une erreur soit présente.  TestReplaceDatanodeFailureReplication.java (222) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyFileContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., SlowWriter[] slowwriters)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ LOG.info(<span class="hljs-string"><span class="hljs-string">"Verify the file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; slowwriters.length; i++) { LOG.info(slowwriters[i].filepath + ....); FSDataInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { in = fs.open(slowwriters[i].filepath); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>, x;; j++) { x = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x) != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { Assert.assertEquals(j, x); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { IOUtils.closeStream(in); } } }</code> </pre> <br>  L'analyseur jure que la modification du compteur <i>i ++</i> dans la boucle est impossible.  Cela signifie que dans une boucle <i>for (int i = 0; i &lt;slowwriters.length; i ++) {....}</i> pas plus d'une itération ne sera effectuée.  Voyons pourquoi.  Ainsi, dans la première itération, nous associons le flux au fichier correspondant aux <i>ralentisseurs [0]</i> pour une lecture plus approfondie.  À travers la boucle <i>for (int j = 0, x ;; j ++), nous</i> lisons le contenu du fichier par octet, où: <br><br><ul><li>  si nous lisons quelque chose d'adéquat, alors via <i>assertEquals nous</i> comparons l'octet de lecture avec la valeur actuelle du compteur <i>j</i> (en cas de vérification infructueuse, nous quittons le test avec échec); </li><li>  si le fichier a réussi le test et que nous avons atteint la fin du fichier (lire -1), nous quittons la méthode. </li></ul><br>  Par conséquent, peu importe ce qui se passe lors de la vérification des <i>ralentisseurs [0]</i> , il ne s'agit pas de vérifier les éléments suivants.  Très probablement, la <i>pause</i> devrait être utilisée au lieu du <i>retour</i> . <br><br><h3>  Fil </h3><br>  <a href="https://www.viva64.com/ru/w/v6019/">V6019</a> Code inaccessible détecté.  Il est possible qu'une erreur soit présente.  TestNodeManager.java (176) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCreationOfNodeLabelsProviderService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { Assert.fail(<span class="hljs-string"><span class="hljs-string">"Exception caught"</span></span>); e.printStackTrace(); } }</code> </pre> <br>  Dans cette situation, stacktrace ne sera jamais imprimé si une exception se produit, car la méthode <i>Assert.fail</i> interrompra le test.  S'il y a suffisamment de message que l'exception est interceptée, alors pour ne pas être confus, l'impression stacktrace'a doit être supprimée.  Si l'impression est nécessaire, il vous suffit de les échanger. <br><br>  Il existe de nombreux endroits de ce type: <ul><li>  V6019 Code inaccessible détecté.  Il est possible qu'une erreur soit présente.  TestResourceTrackerService.java (928) </li><li>  V6019 Code inaccessible détecté.  Il est possible qu'une erreur soit présente.  TestResourceTrackerService.java (737) </li><li>  V6019 Code inaccessible détecté.  Il est possible qu'une erreur soit présente.  TestResourceTrackerService.java (685) </li><li>  .... </li></ul><br>  <a href="https://www.viva64.com/ru/w/v6072/">V6072</a> Deux fragments de code similaires ont été trouvés.  Il s'agit peut-être d'une faute de frappe et la variable «publicCache» devrait être utilisée à la place de «usercache».  TestResourceLocalizationService.java (315), TestResourceLocalizationService.java (309), TestResourceLocalizationService.java (307), TestResourceLocalizationService.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testDirectoryCleanupOnNewlyCreatedStateStore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, URISyntaxException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// verify directory creation for (Path p : localDirs) { p = new Path((new URI(p.toString())).getPath()); // logic block #1 Path usercache = new Path(p, ContainerLocalizer.USERCACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(usercache), ....); // logic block #2 Path publicCache = new Path(p, ContainerLocalizer.FILECACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(publicCache), ....); .... } .... }</span></span></code> </pre> <br>  Et enfin, encore V6072 =).  Variables pour vous familiariser avec un fragment suspect: <i>usercache</i> et <i>publicCache</i> . <br><br><h2>  Conclusion </h2><br>  Pendant le développement, des centaines de milliers de lignes de code sont écrites.  Si le code de production essaie de se maintenir à l'abri des bogues, des défauts et des lacunes (le développeur teste son propre code, procède à une révision du code, et bien plus encore), alors les tests sont clairement inférieurs à cela.  Les défauts dans les tests peuvent se cacher discrètement derrière une "coche verte".  Et comme vous le comprenez d'après l'analyse des avertissements d'aujourd'hui, un test réussi est loin d'être toujours un test garanti. <br><br>  Lors de la vérification de la base de code Apache Hadoop, l'analyse statique a démontré son besoin non seulement pour le code qui entre en production, mais aussi pour les tests qui jouent également un rôle important dans le développement. <br><br>  Donc, si vous vous souciez de la qualité de votre code et de votre base de test, je vous recommande de vous tourner vers l'analyse statique.  Et le premier candidat au test, je propose d'essayer <a href="https://www.viva64.com/ru/pvs-studio-download/">PVS-Studio</a> . <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/480918/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Maxim Stefanov.  <a href="https://habr.com/en/company/pvs-studio/blog/480918/">Apache Hadoop Code Quality: Production VS Test</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480928/">https://habr.com/ru/post/fr480928/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480918/index.html">Apache Hadoop Code Quality: Production VS Test</a></li>
<li><a href="../fr480920/index.html">Test des commutateurs TP-Link avec PoE longue portée. Et un peu sur les mises à niveau des anciens modèles</a></li>
<li><a href="../fr480922/index.html">Evgeny Usvitsky: «Tout le monde dans le monde sait où obtenir les géodonnées librement - uniquement dans OSM»</a></li>
<li><a href="../fr480924/index.html">Comment et pourquoi les créateurs du remake de MediEvil ont repensé le boss culte du jeu</a></li>
<li><a href="../fr480926/index.html">Théorie des probabilités pour un rendu physiquement précis</a></li>
<li><a href="../fr480930/index.html">Tapez tout</a></li>
<li><a href="../fr480936/index.html">IntelliJ IDEA conversion rapide UPPER_CASE en camelCase</a></li>
<li><a href="../fr480938/index.html">La crypto-monnaie à travers les yeux des juges russes</a></li>
<li><a href="../fr480940/index.html">Exécutez un test d'interface utilisateur multi-navigateur avec Cucumber et Selenoid dans Gitlab CI avec rapport Allure</a></li>
<li><a href="../fr480944/index.html">Top 5 des tendances du marketing par e-mail en 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>