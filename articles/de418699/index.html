<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐊 🚠 🚣🏾 Erstellen eines Emulator-Arcade-Automaten. Teil 3 🧑 📎 ⛵️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teile eins und zwei . 

 8080 Prozessor Emulator 
 Emulator-Shell 
 Sie sollten nun über alle erforderlichen Kenntnisse verfügen, um mit der Erstellun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines Emulator-Arcade-Automaten. Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418699/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ec/e50/f3a/4ece50f3a555bfb39878326ec26addd5.jpg" alt="Bild"></div><br>  Teile <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei</a> . <br><br><h1>  8080 Prozessor Emulator </h1><br><h1>  Emulator-Shell </h1><br>  Sie sollten nun über alle erforderlichen Kenntnisse verfügen, um mit der Erstellung eines 8080-Prozessoremulators zu beginnen. <br><br>  <em>Ich werde versuchen, meinen Code so klar wie möglich zu machen, jeder Opcode wird separat implementiert.</em>  <em>Wenn Sie sich damit vertraut gemacht haben, möchten Sie es möglicherweise neu schreiben, um die Leistung zu optimieren oder Code wiederzuverwenden.</em> <br><br>  Zunächst werde ich eine Speicherstruktur erstellen, die Felder für alles enthält, was mir beim Schreiben eines Disassemblers notwendig erschien.  Es wird auch einen Platz für einen Speicherpuffer geben, der RAM sein wird. <br><a name="habracut"></a><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> z:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> s:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> p:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> cy:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ac:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pad:<span class="hljs-number"><span class="hljs-number">3</span></span>; } ConditionCodes; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State8080</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> c; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> e; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> h; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> l; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sp; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *memory; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cc</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> int_enable; } State8080;</code> </pre> <br>  Erstellen Sie nun eine Prozedur mit einem Fehleraufruf, die das Programm mit einem Fehler beendet.  Es wird ungefähr so ​​aussehen: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnimplementedInstruction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// pc    ,     printf ("Error: Unimplemented instruction\n"); exit(1); } int Emulate8080Op(State8080* state) { unsigned char *opcode = &amp;state-&gt;memory[state-&gt;pc]; switch(*opcode) { case 0x00: UnimplementedInstruction(state); break; case 0x01: UnimplementedInstruction(state); break; case 0x02: UnimplementedInstruction(state); break; case 0x03: UnimplementedInstruction(state); break; case 0x04: UnimplementedInstruction(state); break; /*....*/ case 0xfe: UnimplementedInstruction(state); break; case 0xff: UnimplementedInstruction(state); break; } state-&gt;pc+=1; //  }</span></span></code> </pre> <br>  Lassen Sie uns einige Opcodes implementieren. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">//NOP -  ! case 0x01: //LXI B, state-&gt;c = opcode[1]; state-&gt;b = opcode[2]; state-&gt;pc += 2; //   2  break; /*....*/ case 0x41: state-&gt;b = state-&gt;c; break; //MOV B,C case 0x42: state-&gt;b = state-&gt;d; break; //MOV B,D case 0x43: state-&gt;b = state-&gt;e; break; //MOV B,E } state-&gt;pc+=1; }</span></span></code> </pre> <br>  So.  Für jeden Opcode ändern wir den Status und den Speicher, wie es ein auf einem echten 8080 ausgeführter Befehl tun würde. <br><br>  Der 8080 hat ungefähr 7 Typen, je nachdem, wie Sie sie klassifizieren: <br><br><ul><li>  Datenübertragung </li><li>  Arithmetik </li><li>  Logisch </li><li>  Zweige </li><li>  Stapel </li><li>  Eingabe-Ausgabe </li><li>  Besonderes </li></ul><br>  Schauen wir uns jeden einzeln an. <br><br><h1>  Rechengruppe </h1><br>  Arithmetische Anweisungen sind viele der 256 Opcodes des 8080-Prozessors, die verschiedene Arten der Addition und Subtraktion enthalten.  Die meisten arithmetischen Anweisungen arbeiten mit Register A und speichern das Ergebnis in A. (Register A wird auch als Akkumulator bezeichnet). <br><br>  Es ist interessant festzustellen, dass diese Befehle Bedingungscodes beeinflussen.  Statuscodes (auch Flags genannt) werden abhängig vom Ergebnis des ausgeführten Befehls gesetzt.  Nicht alle Befehle wirken sich auf Flags aus, und nicht alle Teams, die sich auf Flags auswirken, wirken sich auf alle Flags gleichzeitig aus. <br><br><h3>  Flaggen 8080 </h3><br>  In einem 8080-Prozessor werden Flags als Z, S, P, CY und AC bezeichnet. <br><br><ul><li>  Z (Null, Null) nimmt den Wert 1 an, wenn das Ergebnis Null ist </li><li>  S (Vorzeichen) nimmt den Wert 1 an, wenn Bit 7 (das höchstwertige Bit, das höchstwertige Bit, MSB) des mathematischen Befehls gegeben ist </li><li>  P (Parität, Parität) wird gesetzt, wenn das Ergebnis gerade ist, und wird zurückgesetzt, wenn es ungerade ist </li><li>  CY (Übertrag) nimmt den Wert 1 an, wenn als Ergebnis des Befehls eine Übertragung oder Ausleihe in ein höherwertiges Bit durchgeführt wird </li><li>  AC (Auxillary Carry) wird hauptsächlich für BCD-Mathematik (Binary Coded Decimal) verwendet.  Weitere Informationen finden Sie im Handbuch. In Space Invaders wird dieses Flag nicht verwendet. </li></ul><br>  Statuscodes werden in bedingten Verzweigungsbefehlen verwendet. Beispielsweise führt JZ eine Verzweigung nur durch, wenn das Z-Flag gesetzt ist. <br><br>  Die meisten Anweisungen haben drei Formen: für Register, für unmittelbare Werte und für den Speicher.  Lassen Sie uns ein paar Anweisungen implementieren, um ihre Formulare zu verstehen und zu sehen, wie die Arbeit mit Statuscodes aussieht.  (Beachten Sie, dass ich das Hilfsübertragungsflag nicht implementiere, da es nicht verwendet wird. Wenn ich es implementiert habe, konnte ich es nicht testen.) <br><br><h4>  Anmeldeformular </h4><br>  Hier ist eine beispielhafte Implementierung von zwei Anweisungen mit einem Registerformular;  Im ersten Fall habe ich den Code bereitgestellt, um seine Arbeit verständlicher zu machen, und im zweiten Fall wird eine kompaktere Form vorgestellt, die dasselbe tut. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD B { //      , //      uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;b; //  :    , //    , //      if ((answer &amp; 0xff) == 0) state-&gt;cc.z = 1; else state-&gt;cc.z = 0; //  :   7 , //    , //      if (answer &amp; 0x80) state-&gt;cc.s = 1; else state-&gt;cc.s = 0; //   if (answer &gt; 0xff) state-&gt;cc.cy = 1; else state-&gt;cc.cy = 0; //    state-&gt;cc.p = Parity( answer &amp; 0xff); state-&gt;a = answer &amp; 0xff; } //  ADD     case 0x81: //ADD C { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;c; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br>  Ich emuliere 8-Bit-Mathematikbefehle mit einer 16-Bit-Zahl.  Dies erleichtert es, Fälle zu verfolgen, in denen die Berechnungen einen Übertrag erzeugen. <br><br><h4>  Formular für unmittelbare Werte </h4><br>  Die Form für unmittelbare Werte ist fast dieselbe, außer dass das Byte nach dem Befehl die Quelle des hinzugefügten ist.  Da "opcode" ein Zeiger auf den aktuellen Befehl im Speicher ist, ist opcode [1] sofort das nächste Byte. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xC6</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADI  { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) opcode[1]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h4>  Form für die Erinnerung </h4><br>  In der Speicherform wird ein Byte hinzugefügt, zu dem die in einem Paar von HL-Registern gespeicherte Adresse angibt. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x86</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD M { uint16_t offset = (state-&gt;h&lt;&lt;8) | (state-&gt;l); uint16_t answer = (uint16_t) state-&gt;a + state-&gt;memory[offset]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h3>  Anmerkungen </h3><br>  Die übrigen arithmetischen Anweisungen werden auf ähnliche Weise implementiert.  Ergänzungen: <br><br><ul><li>  In verschiedenen Versionen mit Übertrag (ADC, ACI, SBB, SUI) verwenden wir gemäß dem Referenzhandbuch Übertragsbits in den Berechnungen. </li><li>  INX und DCX wirken sich auf Registerpaare aus, diese Befehle wirken sich nicht auf Flags aus. </li><li>  DAD ist ein weiterer Befehl eines Registerpaares, der nur das Übertragsflag betrifft </li><li>  INR und DCR beeinflussen das Übertragsflag nicht </li></ul><br><h1>  Zweiggruppe </h1><br>  Nachdem Sie sich mit den Statuscodes befasst haben, wird die Zweigstellengruppe für Sie klar genug.  Es gibt zwei Arten der Verzweigung: Übergänge (JMP) und Aufrufe (CALL).  JMP setzt den PC nur auf den Wert des Sprungziels.  CALL wird für Routinen verwendet, schreibt die Rücksprungadresse in den Stapel und weist dem PC dann die Zieladresse zu.  RET kehrt von CALL zurück, empfängt die Adresse vom Stapel und schreibt sie auf den PC. <br><br>  Sowohl JMP als auch CALL gehen nur zu absoluten Adressen, die nach dem Opcode in Bytes codiert sind. <br><br><h3>  Jmp </h3><br>  Der JMP-Befehl verzweigt bedingungslos zur Zieladresse.  Es gibt auch bedingte Verzweigungsbefehle für alle Statuscodes (außer AC): <br><br><ul><li>  JNZ und JZ für Null </li><li>  JNC und JC für die Migration </li><li>  JPO und JPE für Parität </li><li>  JP (Plus) und JM (Minus) für das Zeichen </li></ul><br>  Hier ist eine Implementierung einiger von ihnen: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc2</span></span>: <span class="hljs-comment"><span class="hljs-comment">//JNZ  if (0 == state-&gt;cc.z) state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; else //    state-&gt;pc += 2; break; case 0xc3: //JMP  state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; break;</span></span></code> </pre> <br><h3>  CALL und RET </h3><br>  CALL schiebt die Adresse des Befehls nach dem Aufruf auf den Stapel und springt dann zur Zieladresse.  RET empfängt die Adresse vom Stapel und speichert sie auf dem PC.  Bedingte Versionen von CALL und RET existieren für alle Zustände. <br><br><ul><li>  CZ, CNZ, RZ, RNZ für Null </li><li>  CNC, CC, RNC, RC zur Übertragung </li><li>  CPO, CPE, RPO, RPE für Parität </li><li>  CP, CM, RP, RM für Zeichen </li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break; case 0xc9: //RET state-&gt;pc = state-&gt;memory[state-&gt;sp] | (state-&gt;memory[state-&gt;sp+1] &lt;&lt; 8); state-&gt;sp += 2; break;</span></span></code> </pre> <br><h3>  Anmerkungen </h3><br><ul><li>  Der PCHL-Befehl springt bedingungslos zu einer Adresse in einem Paar von HL-Registern. </li><li>  Ich habe das zuvor diskutierte RST nicht in diese Gruppe aufgenommen.  Es schreibt die Rücksprungadresse in den Stapel und springt dann zu der vordefinierten Adresse am unteren Rand des Speichers. </li></ul><br><h1>  Logische Gruppe </h1><br>  Diese Gruppe führt logische Operationen aus (siehe den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Beitrag des</a> Tutorials).  Aufgrund ihrer Natur ähneln sie einer arithmetischen Gruppe darin, dass die meisten Operationen mit Register A (Laufwerk) arbeiten und die meisten Operationen Flags beeinflussen.  Alle Operationen werden mit 8-Bit-Werten ausgeführt. In dieser Gruppe gibt es keine Befehle, die Registerpaare betreffen. <br><br><h3>  Boolesche Operationen </h3><br>  UND, ODER, NICHT (CMP) und "exklusiv oder" (XOR) werden als Boolesche Operationen bezeichnet.  ODER und UND habe ich früher erklärt.  Der NOT-Befehl (für den 8080-Prozessor heißt er CMA oder Komplementakkumulator) ändert einfach die Bitwerte - alle Einheiten werden zu Nullen und Nullen werden zu Einsen. <br><br>  Ich nehme XOR als „Differenzerkenner“ wahr.  Ihre Wahrheitstabelle sieht so aus: <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Ergebnis </td></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  1 </td><td>  1 </td></tr><tr><td>  1 </td><td>  0 </td><td>  1 </td></tr><tr><td>  1 </td><td>  1 </td><td>  0 </td></tr></tbody></table><br>  AND, OR und XOR haben eine Form für Register, Speicher und unmittelbare Werte.  (CMP hat nur einen Befehl, bei dem zwischen Groß- und Kleinschreibung unterschieden wird).  Hier ist eine Implementierung eines Paares von Opcodes: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x2F</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CMA (not) state-&gt;a = ~state-&gt;a //  ,  CMA     break; case 0xe6: //ANI  { uint8_t x = state-&gt;a &amp; opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = 0; //  ,  ANI  CY state-&gt;a = x; state-&gt;pc++; //   } break;</span></span></code> </pre> <br><h3>  Zyklische Schaltbefehle </h3><br>  Diese Befehle ändern die Reihenfolge der Bits in den Registern.  Eine Verschiebung nach rechts verschiebt sie um ein Bit nach rechts und eine Verschiebung nach links - um ein Bit nach links: <br><br> <code>  (0b00010000) = 0b00001000</code> <br> <br> <code>  (0b00000001) = 0b00000010</code> <br> <br>  Sie scheinen wertlos zu sein, aber in Wirklichkeit ist dies nicht so.  Sie können verwendet werden, um durch Zweierpotenzen zu multiplizieren und zu teilen.  Nehmen Sie als Beispiel die Linksverschiebung.  <code>0b00000001</code> ist dezimal 1, und <code>0b00000001</code> es nach links verschieben, wird es <code>0b00000010</code> , <code>0b00000010</code> dezimal 2. Wenn wir eine weitere Verschiebung nach links durchführen, erhalten wir <code>0b00000100</code> , <code>0b00000100</code> 4. Eine weitere Verschiebung nach links, und wir multiplizieren mit 8. Dies funktioniert mit jedem durch Zahlen: 5 ( <code>0b00000101</code> ) ergibt bei <code>0b00001010</code> nach links 10 ( <code>0b00001010</code> ).  Eine weitere Verschiebung nach links ergibt 20 ( <code>0b00010100</code> ).  Eine Verschiebung nach rechts bewirkt dasselbe, jedoch zur Teilung. <br><br>  Der 8080 verfügt nicht über einen Multiplikationsbefehl, kann jedoch mit diesen Befehlen implementiert werden.  Wenn Sie verstehen, wie das geht, erhalten Sie Bonuspunkte.  Einmal wurde mir eine solche Frage bei einem Interview gestellt.  (Ich habe es getan, obwohl ich ein paar Minuten gebraucht habe.) <br><br>  Diese Befehle drehen den Antrieb zyklisch und wirken sich nur auf das Übertragsflag aus.  Hier sind einige Befehle: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x0f</span></span>: <span class="hljs-comment"><span class="hljs-comment">//RRC { uint8_t x = state-&gt;a; state-&gt;a = ((x &amp; 1) &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break; case 0x1f: //RAR { uint8_t x = state-&gt;a; state-&gt;a = (state-&gt;cc.cy &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break;</span></span></code> </pre> <br><h3>  Vergleich </h3><br>  Die Aufgabe von CMP und CPI besteht nur darin, Flags (zum Verzweigen) zu setzen.  Sie tun dies, indem sie Flags subtrahieren, aber das Ergebnis nicht speichern. <br><br><ul><li>  Gleichermaßen: Wenn zwei Zahlen gleich sind, wird das Z-Flag gesetzt, da ihre Subtraktion voneinander Null ergibt. </li><li>  Größer als: Wenn A größer als der zu vergleichende Wert ist, wird das CY-Flag gelöscht (da die Subtraktion ohne Ausleihen erfolgen kann). </li><li>  Kleiner: Wenn A kleiner als der Vergleichswert ist, wird das CY-Flag gesetzt (da A die Ausleihe abschließen muss, um die Subtraktion abzuschließen). </li></ul><br>  Es gibt Versionen dieser Befehle für Register, Speicher und Sofortwerte.  Die Implementierung ist eine einfache Subtraktion, ohne das Ergebnis zu speichern: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xfe</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CPI  { uint8_t x = state-&gt;a - opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); //  ,    p -   state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = (state-&gt;a &lt; opcode[1]); state-&gt;pc++; } break;</span></span></code> </pre> <br><h3>  CMC und STC </h3><br>  Sie vervollständigen die logische Gruppe.  Sie werden verwendet, um das Übertragsflag zu setzen und zu löschen. <br><br><h1>  Gruppe von Eingabe-Ausgabe- und Spezialbefehlen </h1><br>  Diese Befehle können keiner anderen Kategorie zugewiesen werden.  Ich werde sie der Vollständigkeit halber erwähnen, aber es scheint mir, dass wir wieder zu ihnen zurückkehren müssen, wenn wir beginnen, die Hardware von Space Invaders zu emulieren. <br><br><ul><li>  EI und DI aktivieren oder deaktivieren die Fähigkeit des Prozessors, Interrupts zu verarbeiten.  Ich habe das Interrupt_enabled-Flag zur Prozessorstatusstruktur hinzugefügt und es mit diesen Befehlen gesetzt / zurückgesetzt. </li><li>  Es scheint, dass RIM und SIM hauptsächlich für serielle E / A verwendet werden.  Wenn Sie interessiert sind, können Sie das Handbuch lesen, aber diese Befehle werden in Space Invaders nicht verwendet.  Ich werde sie nicht emulieren. </li><li>  HLT ist ein Stopp.  Ich glaube nicht, dass wir es emulieren müssen, aber Sie können Ihren Beendigungscode (oder Beendigungscode (0)) aufrufen, wenn Sie diesen Befehl sehen. </li><li>  IN und OUT sind Befehle, mit denen das 8080-Prozessorgerät mit externen Geräten kommuniziert.  Während wir sie implementieren, werden sie nichts anderes tun, als ihr Datenbyte zu überspringen.  (Später werden wir zu ihnen zurückkehren). </li><li>  NOP ist "keine Operation".  Eine Anwendung von NOP besteht darin, das Timing des Bedienfelds zu steuern (die Ausführung dauert vier CPU-Zyklen). </li></ul><br>  Eine weitere Anwendung von NOP ist die Codemodifikation.  Angenommen, wir müssen den ROM-Code des Spiels ändern.  Wir können nicht einfach unnötige Opcodes löschen, da wir nicht alle CALL- und JMP-Befehle ändern möchten (sie sind falsch, wenn mindestens ein Teil des Codes verschoben wird).  Mit NOP können wir den Code loswerden.  <em>Das Hinzufügen von Code ist viel schwieriger!</em>  <em>Sie können es hinzufügen, indem Sie irgendwo im ROM Speicherplatz suchen und den Befehl in JMP ändern.</em> <br><br><h1>  Stapelgruppe </h1><br>  Wir haben die Mechanik für die meisten Teams in der Stapelgruppe bereits abgeschlossen.  Wenn Sie die Arbeit mit mir gemacht haben, sind diese Befehle einfach zu implementieren. <br><br><h3>  PUSH und POP </h3><br>  PUSH und POP funktionieren nur mit Registerpaaren.  PUSH schreibt ein Registerpaar in den Stapel, und POP nimmt 2 Bytes vom oberen Rand des Stapels und schreibt sie in ein Registerpaar. <br><br>  Es gibt vier Opcodes für PUSH und POP, einen für jedes der Paare: BC, DE, HL und PSW.  PSW ist ein spezielles Paar von Laufwerksflagregistern und Statuscodes.  Hier ist meine Implementierung von PUSH und POP für BC und PSW.  Es gibt keine Kommentare darin - ich denke nicht, dass es hier etwas besonders Kniffliges gibt. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc1</span></span>: <span class="hljs-comment"><span class="hljs-comment">//POP B { state-&gt;c = state-&gt;memory[state-&gt;sp]; state-&gt;b = state-&gt;memory[state-&gt;sp+1]; state-&gt;sp += 2; } break; case 0xc5: //PUSH B { state-&gt;memory[state-&gt;sp-1] = state-&gt;b; state-&gt;memory[state-&gt;sp-2] = state-&gt;c; state-&gt;sp = state-&gt;sp - 2; } break; case 0xf1: //POP PSW { state-&gt;a = state-&gt;memory[state-&gt;sp+1]; uint8_t psw = state-&gt;memory[state-&gt;sp]; state-&gt;cc.z = (0x01 == (psw &amp; 0x01)); state-&gt;cc.s = (0x02 == (psw &amp; 0x02)); state-&gt;cc.p = (0x04 == (psw &amp; 0x04)); state-&gt;cc.cy = (0x05 == (psw &amp; 0x08)); state-&gt;cc.ac = (0x10 == (psw &amp; 0x10)); state-&gt;sp += 2; } break; case 0xf5: //PUSH PSW { state-&gt;memory[state-&gt;sp-1] = state-&gt;a; uint8_t psw = (state-&gt;cc.z | state-&gt;cc.s &lt;&lt; 1 | state-&gt;cc.p &lt;&lt; 2 | state-&gt;cc.cy &lt;&lt; 3 | state-&gt;cc.ac &lt;&lt; 4 ); state-&gt;memory[state-&gt;sp-2] = psw; state-&gt;sp = state-&gt;sp - 2; } break;</span></span></code> </pre> <br><h3>  SPHL und XTHL </h3><br>  Es gibt zwei weitere Teams in der Stapelgruppe - SPHL und XTHL. <br><br><ul><li>  <code>SPHL</code> verschiebt HL zu SP (wodurch SP gezwungen wird, eine neue Adresse zu erhalten). </li><li>  <code>XTHL</code> tauscht das, was sich oben auf dem Stapel befindet, mit dem, was sich in einem Paar HL-Registern befindet.  Warum sollten Sie das tun müssen?  Ich weiß nicht. </li></ul><br><h1>  Ein bisschen mehr über Binärzahlen </h1><br>  Wenn Sie ein Computerprogramm schreiben, müssen Sie unter anderem die Art der Daten auswählen, die für die Zahlen verwendet werden - ob sie negativ sein sollen und wie groß sie maximal sein sollen.  Für den CPU-Emulator benötigen wir den Datentyp, der mit dem Datentyp der Ziel-CPU übereinstimmt. <br><br><h3>  Signiert und nicht signiert </h3><br>  Als wir über Hex-Zahlen sprachen, betrachteten wir sie als vorzeichenlos - das heißt, jede Binärziffer der Hexadezimalzahl hatte einen positiven Wert und jede wurde als Zweierpotenz (Einheiten, zwei, vier usw.) betrachtet. <br><br>  Wir haben uns mit der Frage der Computerspeicherung negativer Zahlen befasst.  Wenn Sie wissen, dass die betreffenden Daten ein Vorzeichen haben, dh negativ sein können, können Sie eine negative Zahl am höchstwertigen Bit der Zahl (höchstwertiges Bit, MSB) erkennen.  Wenn die Datengröße ein Byte beträgt, ist jede Zahl mit einem bestimmten MSB-Bitwert negativ und jede mit einem MSB von Null ist positiv. <br><br>  Der Wert einer negativen Zahl wird als zusätzlicher Code gespeichert.  Wenn wir eine vorzeichenbehaftete Zahl haben und das MSB gleich eins ist und wir herausfinden möchten, wie die Zahl lautet, können wir sie wie folgt konvertieren: Führen Sie ein binäres „NICHT“ für Hex-Zahlen aus und fügen Sie dann eine hinzu. <br><br>  Für die Hex-Zahl 0x80 ist beispielsweise ein MSB-Bit gesetzt, dh es ist negativ.  Das binäre "NICHT" der Zahl 0x80 ist 0x7f oder dezimal 127. 127 + 1 = 128. Das heißt, 0x80 in dezimal ist -128.  Zweites Beispiel: 0xC5.  Nicht (0xC5) = 0x3A = Dezimalzahl 58 +1 = Dezimalzahl 59. Das heißt, 0xC5 ist Dezimalzahl -59. <br><br>  Was bei Zahlen mit zusätzlichem Code überrascht, ist, dass wir mit ihnen wie mit vorzeichenlosen Zahlen Berechnungen durchführen können und sie weiterhin <em>funktionieren</em> .  Der Computer muss mit Schildern nichts Besonderes tun.  Ich werde einige Beispiele zeigen, die dies beweisen. <br><br><pre>  Beispiel 1<font></font>
<font></font>
      Dezimal-Hex-Binär    
       -3 0xFD 1111 1101    
    + 10 0x0A +0000 1010    
    ----- -----------    
        7 0x07 1 0000 0111    
                        ^ Dies wird im Übertragsbit aufgezeichnet<font></font>
<font></font>
    Beispiel 2    <font></font>
<font></font>
      Dezimal-Hex-Binär    
      -59 0xC5 1100 0101    
    + 33 0x21 +0010 0001    
    ----- -----------    
      -26 0xE6 1110 0110 </pre><br><br>  In Beispiel 1 sehen wir, dass das Addieren von 10 und -3 zu 7 führt. Das Additionsergebnis wurde übertragen, sodass das C-Flag gesetzt werden kann. In Beispiel 2 war das Additionsergebnis negativ, daher dekodieren wir dies: Nicht (0xE6) = 0x19 = 25 + 1 = 26. <code>0xE6 = -26</code> Explosion des Gehirns! <br><br>  Wenn Sie möchten, lesen Sie mehr über den zusätzlichen Code auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> . <br><br><h3>  Datentypen </h3><br>  In C besteht eine Beziehung zwischen Datentypen und der Anzahl der für diesen Typ verwendeten Bytes.  Tatsächlich interessieren wir uns nur für ganze Zahlen.  Die Standard- / Old-School-C-Datentypen sind char, int und long sowie ihre Freunde char ohne Vorzeichen, int ohne Vorzeichen und long ohne Vorzeichen.  Das Problem ist, dass diese Typen auf verschiedenen Plattformen und in verschiedenen Compilern unterschiedliche Größen haben können. <br><br>  Daher ist es am besten, einen Datentyp für unsere Plattform auszuwählen, der die Größe der Daten explizit deklariert.  Wenn Ihre Plattform stdint.h hat, können Sie int8_t, uint8_t usw. verwenden. <br><br>  Die Größe einer Ganzzahl bestimmt die maximale Anzahl, die darin gespeichert werden kann.  Bei vorzeichenlosen Ganzzahlen können Sie Zahlen von 0 bis 255 in 8 Bit speichern. Wenn Sie in hexadezimal übersetzen, ist dies von 0x00 bis 0xFF.  Da 0xFF "alle Bits gesetzt" hat und der Dezimalzahl 255 entspricht, ist es völlig logisch, dass das Intervall einer vorzeichenlosen Einzelbyte-Ganzzahl 0-255 beträgt.  Intervalle sagen uns, dass alle Größen von ganzen Zahlen genau gleich funktionieren - Zahlen entsprechen der Zahl, die erhalten wird, wenn alle Bits gesetzt sind. <br><br><table><tbody><tr><th>  Typ </th><th>  Intervall </th><th>  Hex </th></tr><tr><td>  8-Bit ohne Vorzeichen </td><td>  0-255 </td><td>  0x0-0xFF </td></tr><tr><td>  8-Bit signiert </td><td>  -128-127 </td><td>  0x80-0x7F </td></tr><tr><td>  16-Bit ohne Vorzeichen </td><td>  0-65535 </td><td>  0x0-0xFFFF </td></tr><tr><td>  16-Bit signiert </td><td>  -32768-32767 </td><td>  0x8000-0x7FFF </td></tr><tr><td>  32-Bit ohne Vorzeichen </td><td>  0-4294967295 </td><td>  0x0-0xFFFFFFFFFF </td></tr><tr><td>  32-Bit signiert </td><td>  -2147483648-2147483647 </td><td>  0x80000000-0x7FFFFFFF </td></tr></tbody></table><br>  Noch interessanter ist, dass -1 in jedem vorzeichenbehafteten Datentyp eine Zahl ist, für die alle Bits gesetzt sind (0xFF für vorzeichenbehaftetes Byte, 0xFFFF für vorzeichenbehaftete 16-Bit-Zahl und 0xFFFFFFFF für vorzeichenbehaftete 32-Bit-Zahl).  Wenn die Daten als vorzeichenlos betrachtet werden, wird für alle gegebenen Bits die maximal mögliche Anzahl für diesen Datentyp erhalten. <br><br>  Um Prozessorregister zu emulieren, wählen wir den Datentyp aus, der der Größe dieses Registers entspricht.  Es lohnt sich wahrscheinlich, standardmäßig nicht signierte Typen auszuwählen und zu konvertieren, wenn Sie sie als signiert betrachten müssen.  Zum Beispiel verwenden wir den Datentyp uint8_t, um ein 8-Bit-Register darzustellen. <br><br><h3>  Hinweis: Verwenden Sie einen Debugger, um Datentypen zu konvertieren </h3><br>  Wenn gdb auf Ihrer Plattform installiert ist, ist es sehr praktisch, es für die Arbeit mit Binärzahlen zu verwenden.  Im Folgenden werde ich ein Beispiel zeigen. In der unten gezeigten Sitzung sind Zeilen, die mit # beginnen, Kommentare, die ich später hinzugefügt habe. <br><br> <code>#  /c,   gdb      <br> (gdb) print /c 0xFD <br> $1 = -3 '?' <br> <br> #  /x,   gdb    hex <br> #   "p"  "print" <br> (gdb) p /c 0xA <br> $2 = 10 '\n' <br> <br> #    2  " " <br> (gdb) p /c 0xC5 <br> $3 = -59 '?' <br> (gdb) p /c 0xC5+0x21 <br> $4 = -26 '?' <br> <br> #  print  ,  gdb    <br> (gdb) p 0x21 <br> $9 = 33 <br> <br> #     ,     gdb, <br> #  ,      <br> (gdb) p 0xc5 <br> $5 = 197 # <br> (gdb) p /c 0xc5 <br> $3 = -59 '?' # <br> (gdb) p 0xfd <br> $6 = 253 <br> <br> #        (   32- ) <br> (gdb) p /x -3 <br> $7 = 0xfffffffd <br> <br> #   1     <br> (gdb) print (char) 0xff <br> $1 = -1 '?' <br> #   1     <br> (gdb) print (unsigned char) 0xff <br> $2 = 255 '?'</code> <br> <br>  Wenn ich mit Hex-Zahlen arbeite, mache ich das immer in gdb - und das passiert fast jeden Tag.  So viel einfacher als das Öffnen eines Programmierrechners mit einer grafischen Benutzeroberfläche.  Öffnen Sie auf Linux- (und Mac OS X-) Computern zum Starten einer GDB-Sitzung einfach ein Terminal und geben Sie "GDB" ein.  Wenn Sie Xcode unter OS X verwenden, können Sie nach dem Starten des Programms die Konsole in Xcode verwenden (die Konsole, an die die printf-Ausgabe ausgegeben wird).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unter Windows ist der GDB-Debugger von Cygwin erhältlich. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPU Emulator Termination </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem Sie all diese Informationen erhalten haben, sind Sie bereit für eine lange Reise. </font><font style="vertical-align: inherit;">Sie müssen entscheiden, wie Sie den Emulator implementieren - entweder eine vollständige 8080-Emulation erstellen oder nur die Befehle implementieren, die zum Abschließen des Spiels erforderlich sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich für eine vollständige Emulation entscheiden, benötigen Sie einige weitere Tools. </font><font style="vertical-align: inherit;">Ich werde im nächsten Abschnitt darüber sprechen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere Möglichkeit besteht darin, nur die vom Spiel verwendeten Anweisungen zu emulieren. </font><font style="vertical-align: inherit;">Wir werden weiterhin das riesige Switch-Konstrukt ausfüllen, das wir im Abschnitt Emulator Shell erstellt haben. </font><font style="vertical-align: inherit;">Wir werden den folgenden Vorgang wiederholen, bis wir einen einzigen nicht realisierten Befehl haben:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Starten Sie den Emulator mit ROM Space Invaders </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Aufruf wird beendet, </font></font><code>UnimplementedInstruction()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn der Befehl nicht bereit ist</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Emulieren Sie diese Anweisung </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gehe zu 1 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das erste, was ich tat, als ich anfing, meinen Emulator zu schreiben, war, Code von meinem Disassembler hinzuzufügen. </font><font style="vertical-align: inherit;">So konnte ich einen Befehl ausgeben, der wie folgt ausgeführt werden sollte:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; Disassemble8080Op(state-&gt;memory, state-&gt;pc); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-comment"><span class="hljs-comment">//NOP /* ... */ } /*    */ printf("\tC=%d,P=%d,S=%d,Z=%d\n", state-&gt;cc.cy, state-&gt;cc.p, state-&gt;cc.s, state-&gt;cc.z); printf("\tA $%02x B $%02x C $%02x D $%02x E $%02x H $%02x L $%02x SP %04x\n", state-&gt;a, state-&gt;b, state-&gt;c, state-&gt;d, state-&gt;e, state-&gt;h, state-&gt;l, state-&gt;sp); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe am Ende auch Code hinzugefügt, um alle Register und Statusflags anzuzeigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gute Nachrichten: Um in das Programm für 50.000 Teams einzutauchen, benötigen wir nur eine Teilmenge der 8080-Opcodes. Ich werde sogar eine Liste der Opcodes geben, die implementiert werden müssen:</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Opcode </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Team </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x00 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nein </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x01 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI B, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x05 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCR B. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x06 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI B, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x09 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vater b </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0d </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCR C. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI C, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0f </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rrc </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x11 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI D, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x13 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inx d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x19 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Papa d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x1a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LDAX D. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x21 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI H, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x23 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inx h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x26 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI H, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x29 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Papa h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x31 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI SP, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x32 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> STA adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x36 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI M, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x3a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lda adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x3e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI A, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x56 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV D, M. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x5e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV E, M. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x66 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV H, M. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x6f </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV L, A. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x77 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV M, A. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, D. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7b </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, E. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7c </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, H. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, M. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xa7 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANA A. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xaf </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> XRA A. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop b </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jnz adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jmp adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DRÜCKEN B. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ADI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc9 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ret </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xcd </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rufen Sie adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OUT D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DRÜCKEN D. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DRÜCKEN H. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xeb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Xchg </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> POP PSW </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PSW DRÜCKEN </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ei </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfe </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPI D8 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies sind nur 50 Anweisungen, und 10 davon sind Bewegungen, die trivial implementiert werden. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debuggen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber ich habe schlechte Nachrichten. </font><font style="vertical-align: inherit;">Ihr Emulator wird mit ziemlicher Sicherheit nicht richtig funktionieren, und Fehler in einem solchen Code sind sehr schwer zu finden. </font><font style="vertical-align: inherit;">Wenn Sie wissen, welcher Befehl sich schlecht verhält (z. B. ein Übergang oder ein Aufruf von bedeutungslosem Code), können Sie versuchen, den Fehler zu beheben, indem Sie Ihren Code untersuchen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neben der Überprüfung des Codes gibt es noch eine andere Möglichkeit, das Problem zu beheben: Vergleichen Sie Ihren Emulator mit einem Emulator, der mit Sicherheit funktioniert. </font><font style="vertical-align: inherit;">Wir gehen davon aus, dass ein anderer Emulator immer korrekt funktioniert und alle Unterschiede Fehler in Ihrem Emulator sind. </font><font style="vertical-align: inherit;">Zum Beispiel können Sie meinen Emulator verwenden. </font><font style="vertical-align: inherit;">Sie können sie manuell parallel ausführen. </font><font style="vertical-align: inherit;">Sie können Zeit sparen, wenn Sie meinen Code in Ihr Projekt integrieren, um den folgenden Prozess zu erhalten:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen Sie einen Status für Ihren Emulator </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstelle einen Zustand für mich </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Für das nächste Team </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rufen Sie Ihren Emulator mit Ihrem Status an </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich rufe meine mit meinem Vermögen an </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vergleichen Sie unsere beiden Staaten </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suche nach Fehlern in irgendwelchen Unterschieden </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gehe zu 3 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere Möglichkeit besteht darin, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese Site</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> manuell zu verwenden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ein 8080 Javascript-Prozessor-Emulator, der sogar ROM Space Invaders enthält. </font><font style="vertical-align: inherit;">Hier ist der Prozess:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Starten Sie die Space Invaders-Emulation neu, indem Sie auf die Schaltfläche Space Invaders klicken </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Drücken Sie die Taste „Run 1“, um den Befehl auszuführen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir führen den folgenden Befehl in unserem Emulator aus </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vergleichen Sie den Prozessorstatus mit Ihrem </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn die Bedingungen übereinstimmen, gehe zu 2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Bedingungen nicht übereinstimmen, ist Ihre Anweisungsemulation fehlerhaft. </font><font style="vertical-align: inherit;">Korrigieren Sie es und beginnen Sie erneut mit Schritt 1.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe diese Methode am Anfang verwendet, um meinen 8080-Emulator zu debuggen. Ich werde nicht lügen - der Prozess kann langwierig sein. Infolgedessen stellten sich viele meiner Probleme als Tippfehler und Fehler beim Kopieren und Einfügen heraus, die nach der Erkennung sehr einfach zu beheben waren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie Ihren Code Schritt für Schritt ausführen, werden die meisten der ersten 30.000 Anweisungen in einem Zyklus von etwa $ 1a5f ausgeführt. Wenn Sie sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javascript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Emulator</font></a><font style="vertical-align: inherit;"> ansehen </font><font style="vertical-align: inherit;">, können Sie sehen, dass dieser Code Daten auf den Bildschirm kopiert. Ich bin sicher, dass dieser Code oft aufgerufen wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem ersten Rendern des Bildschirms bleibt das Programm nach 50.000 Befehlen in dieser Endlosschleife stecken:</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-number"><span class="hljs-number">0</span></span>ada LDA <span class="hljs-meta"><span class="hljs-meta">$20</span></span>c0 <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ANA A <span class="hljs-number"><span class="hljs-number">0</span></span>ade JNZ <span class="hljs-meta"><span class="hljs-meta">$0</span></span>ada</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wartet, bis sich der Wert im Speicher bei $ 20c0 auf Null ändert. </font><font style="vertical-align: inherit;">Da der Code in dieser Schleife $ 20c0 nicht genau ändert, muss es sich um ein Signal von einem anderen Ort handeln. </font><font style="vertical-align: inherit;">Es ist Zeit, über die Emulation des „Eisens“ eines Arcade-Automaten zu sprechen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir mit dem nächsten Abschnitt fortfahren, stellen Sie sicher, dass Ihr CPU-Emulator in diese Endlosschleife fällt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Referenz siehe </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meine Quellen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Volle 8080-Emulation </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Lektion, die mich viel gekostet hat: Implementieren Sie keine Teams, die Sie nicht testen können. </font><font style="vertical-align: inherit;">Dies ist eine gute Faustregel für jede in der Entwicklung befindliche Software. </font><font style="vertical-align: inherit;">Wenn Sie das Team nicht überprüfen, wird es definitiv kaputt sein. </font><font style="vertical-align: inherit;">Und je weiter Sie sich von der Implementierung entfernen, desto schwieriger wird es, Probleme zu finden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine andere Lösung, wenn Sie einen vollständigen 8080-Emulator erstellen und sicherstellen möchten, dass er funktioniert. </font><font style="vertical-align: inherit;">Ich habe einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code für 8080</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> namens cpudiag.asm entdeckt, der zum Testen jedes 8080-Prozessorbefehls entwickelt wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich </font><font style="vertical-align: inherit;">führe </font><font style="vertical-align: inherit;">Sie aus mehreren Gründen nach dem ersten in diesen Prozess ein:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich wollte, dass die Beschreibung dieses Prozesses für einen anderen Prozessor wiederholt wird. </font><font style="vertical-align: inherit;">Ich glaube nicht, dass das Analogon von cpudiag.asm für alle Prozessoren existiert.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen können, ist der Prozess ziemlich mühsam. </font><font style="vertical-align: inherit;">Ich denke, ein Anfänger beim Debuggen von Assembler-Code wird große Schwierigkeiten haben, wenn diese Schritte nicht aufgeführt sind.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So habe ich diesen Test mit meinem Emulator verwendet. </font><font style="vertical-align: inherit;">Sie können es verwenden oder einen besseren Weg finden, um es zu integrieren.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Baugruppe testen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe ein paar Dinge ausprobiert, aber als Ergebnis habe ich mich für </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese schöne Seite entschieden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich habe den Text cpudiag.asm in den linken Bereich eingefügt und den Build ohne Probleme abgeschlossen. </font><font style="vertical-align: inherit;">Ich habe eine Minute gebraucht, um herauszufinden, wie ich das Ergebnis herunterladen kann. Durch Klicken auf die Schaltfläche „Make Beautiful Code“ unten links habe ich eine Datei namens test.bin heruntergeladen, die den Code 8080 kompiliert. Ich konnte dies mit meinem Disassembler überprüfen. </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden Sie cpudiag.asm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus dem Spiegel auf meiner Website herunter. </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden Sie cpudiag.bin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (kompilierter Code 8080) von meiner Website </font><a href=""><font style="vertical-align: inherit;">herunter</font></a><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Laden Sie einen Test auf meinen Emulator hoch </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt Invasoren zu laden. * Dateien lade ich diese Binärdatei. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ergeben sich kleine Schwierigkeiten. Erstens enthält der Quell-Assembler-Code eine Zeile, </font></font><code>ORG 00100H</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dh, die gesamte Datei wird unter der Annahme kompiliert, dass sich die erste Codezeile in 0x100 hex befindet. Ich hatte noch nie zuvor Code in Assembler 8080 geschrieben, daher wusste ich nicht, was diese Zeile bewirkt. Ich brauchte nur eine Minute, um herauszufinden, dass alle Zweigstellenadressen falsch waren und der Speicher bei 0x100 beginnen musste. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens muss ich, da mein Emulator von vorne anfängt, zuerst zum echten Code übergehen. Nachdem ich den Hex-Wert an der Null-Adresse in den Speicher eingefügt hatte </font></font><code>JMP $0100</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, habe ich mich damit befasst. (Oder Sie können den PC einfach mit einem Wert von 0x100 initialisieren.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drittens habe ich einen Fehler im kompilierten Code gefunden. </font><font style="vertical-align: inherit;">Ich denke, der Grund ist die falsche Verarbeitung der letzten Codezeile </font></font><code>STACK EQU TEMPP+256</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber ich bin mir nicht sicher. </font><font style="vertical-align: inherit;">Wie dem auch sei, der Stapel während der Kompilierung befand sich bei $ 6ad, und die ersten PUSH begannen, den Code neu zu schreiben. </font><font style="vertical-align: inherit;">Ich schlug vor, dass die Variable wie der Rest des Codes auch um 0x100 versetzt werden sollte, also habe ich sie behoben, indem ich "0x7" in die Codezeile eingefügt habe, die den Stapelzeiger initialisiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da ich in meinem Emulator keine DAA- oder Zusatzmigration implementiert habe, ändere ich den Code, um diese Prüfung zu überspringen (wir überspringen sie nur mit JMP).</font></font><br><br><pre> <code class="cpp hljs"> ReadFileIntoMemoryAt(state, <span class="hljs-string"><span class="hljs-string">"/Users/kpmiller/Desktop/invaders/cpudiag.bin"</span></span>, <span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   JMP 0x100 state-&gt;memory[0]=0xc3; state-&gt;memory[1]=0; state-&gt;memory[2]=0x01; //Fix the stack pointer from 0x6ad to 0x7ad // this 0x06 byte 112 in the code, which is // byte 112 + 0x100 = 368 in memory state-&gt;memory[368] = 0x7; //  DAA state-&gt;memory[0x59c] = 0xc3; //JMP state-&gt;memory[0x59d] = 0xc2; state-&gt;memory[0x59e] = 0x05;</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Test versucht, eine Schlussfolgerung zu ziehen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offensichtlich stützt sich dieser Test auf die Hilfe des CP / M-Betriebssystems. Ich fand heraus, dass CP / M einen Code für $ 0005 hat, der Nachrichten an die Konsole druckt, und änderte meine CALL-Emulation, um dieses Verhalten zu behandeln. Ich bin nicht sicher, ob alles richtig gelaufen ist, aber es hat für die beiden Nachrichten funktioniert, die das Programm zu drucken versucht. Meine CALL-Emulation zum Ausführen dieses Tests sieht folgendermaßen aus:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  #ifdef FOR_CPUDIAG if (5 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { if (state-&gt;c == 9) { uint16_t offset = (state-&gt;d&lt;&lt;8) | (state-&gt;e); char *str = &amp;state-&gt;memory[offset+3]; // - while (*str != '$') printf("%c", *str++); printf("\n"); } else if (state-&gt;c == 2) { //    ,   ,    printf ("print char routine called\n"); } } else if (0 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { exit(0); } else #endif { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei diesem Test habe ich mehrere Probleme in meinem Emulator gefunden. Ich bin mir nicht sicher, welcher von ihnen in das Spiel involviert sein würde, aber wenn sie es wären, wäre es sehr schwierig, sie zu finden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe alle Opcodes implementiert (mit Ausnahme von DAA und seinen Freunden). Ich habe 3-4 Stunden gebraucht, um Probleme in meinen Herausforderungen zu beheben und neue zu implementieren. Es war definitiv schneller als der oben beschriebene manuelle Prozess - bevor ich diesen Test fand, verbrachte ich mehr als 4 Stunden mit dem manuellen Prozess. Wenn Sie diese Erklärung herausfinden können, empfehle ich, diese Methode zu verwenden, anstatt sie manuell zu vergleichen. Die Kenntnis des manuellen Prozesses ist jedoch auch eine große Fähigkeit. Wenn Sie einen anderen Prozessor emulieren möchten, sollten Sie darauf zurückgreifen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie diesen Vorgang nicht ausführen können oder er zu kompliziert erscheint, lohnt es sich auf jeden Fall, den oben beschriebenen Ansatz mit zwei verschiedenen Emulatoren zu wählen, die in Ihrem Programm ausgeführt werden. </font><font style="vertical-align: inherit;">Wenn mehrere Millionen Befehle im Programm erscheinen und Interrupts hinzugefügt werden, ist es unmöglich, zwei Emulatoren manuell zu vergleichen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418699/">https://habr.com/ru/post/de418699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418687/index.html">3,5 "Umdrehung: Details eines kleinen Auslegers von Disketten mit Dämpfen</a></li>
<li><a href="../de418689/index.html">Erstellen von Komponentenbibliotheken in Figma, Einsparen eines Budgets am Beispiel einer Online-Auktion</a></li>
<li><a href="../de418691/index.html">Rancher: Kubernetes in 5 Minuten auf Bare Metal</a></li>
<li><a href="../de418693/index.html">Warum ist Glück im Gehirn so schwer zu erkennen?</a></li>
<li><a href="../de418695/index.html">Anti-Piraterie-Kriege - Das Imperium schlägt zurück</a></li>
<li><a href="../de418701/index.html">Wir studieren syntaktische Parser für die russische Sprache</a></li>
<li><a href="../de418705/index.html">Futex-Grundlagen</a></li>
<li><a href="../de418709/index.html">Müssen Sie sich zwingen: Treiber und Schnittstellenbarrieren</a></li>
<li><a href="../de418711/index.html">Token Managed Registers 1.0</a></li>
<li><a href="../de418713/index.html">Spiel zur Verbesserung der Qualität von Wikipedia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>