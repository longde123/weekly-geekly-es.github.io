<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêä üö† üö£üèæ Erstellen eines Emulator-Arcade-Automaten. Teil 3 üßë üìé ‚õµÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teile eins und zwei . 

 8080 Prozessor Emulator 
 Emulator-Shell 
 Sie sollten nun √ºber alle erforderlichen Kenntnisse verf√ºgen, um mit der Erstellun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines Emulator-Arcade-Automaten. Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418699/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ec/e50/f3a/4ece50f3a555bfb39878326ec26addd5.jpg" alt="Bild"></div><br>  Teile <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei</a> . <br><br><h1>  8080 Prozessor Emulator </h1><br><h1>  Emulator-Shell </h1><br>  Sie sollten nun √ºber alle erforderlichen Kenntnisse verf√ºgen, um mit der Erstellung eines 8080-Prozessoremulators zu beginnen. <br><br>  <em>Ich werde versuchen, meinen Code so klar wie m√∂glich zu machen, jeder Opcode wird separat implementiert.</em>  <em>Wenn Sie sich damit vertraut gemacht haben, m√∂chten Sie es m√∂glicherweise neu schreiben, um die Leistung zu optimieren oder Code wiederzuverwenden.</em> <br><br>  Zun√§chst werde ich eine Speicherstruktur erstellen, die Felder f√ºr alles enth√§lt, was mir beim Schreiben eines Disassemblers notwendig erschien.  Es wird auch einen Platz f√ºr einen Speicherpuffer geben, der RAM sein wird. <br><a name="habracut"></a><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> z:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> s:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> p:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> cy:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ac:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pad:<span class="hljs-number"><span class="hljs-number">3</span></span>; } ConditionCodes; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State8080</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> c; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> e; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> h; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> l; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sp; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *memory; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cc</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> int_enable; } State8080;</code> </pre> <br>  Erstellen Sie nun eine Prozedur mit einem Fehleraufruf, die das Programm mit einem Fehler beendet.  Es wird ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnimplementedInstruction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// pc    ,     printf ("Error: Unimplemented instruction\n"); exit(1); } int Emulate8080Op(State8080* state) { unsigned char *opcode = &amp;state-&gt;memory[state-&gt;pc]; switch(*opcode) { case 0x00: UnimplementedInstruction(state); break; case 0x01: UnimplementedInstruction(state); break; case 0x02: UnimplementedInstruction(state); break; case 0x03: UnimplementedInstruction(state); break; case 0x04: UnimplementedInstruction(state); break; /*....*/ case 0xfe: UnimplementedInstruction(state); break; case 0xff: UnimplementedInstruction(state); break; } state-&gt;pc+=1; //  }</span></span></code> </pre> <br>  Lassen Sie uns einige Opcodes implementieren. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">//NOP -  ! case 0x01: //LXI B, state-&gt;c = opcode[1]; state-&gt;b = opcode[2]; state-&gt;pc += 2; //   2  break; /*....*/ case 0x41: state-&gt;b = state-&gt;c; break; //MOV B,C case 0x42: state-&gt;b = state-&gt;d; break; //MOV B,D case 0x43: state-&gt;b = state-&gt;e; break; //MOV B,E } state-&gt;pc+=1; }</span></span></code> </pre> <br>  So.  F√ºr jeden Opcode √§ndern wir den Status und den Speicher, wie es ein auf einem echten 8080 ausgef√ºhrter Befehl tun w√ºrde. <br><br>  Der 8080 hat ungef√§hr 7 Typen, je nachdem, wie Sie sie klassifizieren: <br><br><ul><li>  Daten√ºbertragung </li><li>  Arithmetik </li><li>  Logisch </li><li>  Zweige </li><li>  Stapel </li><li>  Eingabe-Ausgabe </li><li>  Besonderes </li></ul><br>  Schauen wir uns jeden einzeln an. <br><br><h1>  Rechengruppe </h1><br>  Arithmetische Anweisungen sind viele der 256 Opcodes des 8080-Prozessors, die verschiedene Arten der Addition und Subtraktion enthalten.  Die meisten arithmetischen Anweisungen arbeiten mit Register A und speichern das Ergebnis in A. (Register A wird auch als Akkumulator bezeichnet). <br><br>  Es ist interessant festzustellen, dass diese Befehle Bedingungscodes beeinflussen.  Statuscodes (auch Flags genannt) werden abh√§ngig vom Ergebnis des ausgef√ºhrten Befehls gesetzt.  Nicht alle Befehle wirken sich auf Flags aus, und nicht alle Teams, die sich auf Flags auswirken, wirken sich auf alle Flags gleichzeitig aus. <br><br><h3>  Flaggen 8080 </h3><br>  In einem 8080-Prozessor werden Flags als Z, S, P, CY und AC bezeichnet. <br><br><ul><li>  Z (Null, Null) nimmt den Wert 1 an, wenn das Ergebnis Null ist </li><li>  S (Vorzeichen) nimmt den Wert 1 an, wenn Bit 7 (das h√∂chstwertige Bit, das h√∂chstwertige Bit, MSB) des mathematischen Befehls gegeben ist </li><li>  P (Parit√§t, Parit√§t) wird gesetzt, wenn das Ergebnis gerade ist, und wird zur√ºckgesetzt, wenn es ungerade ist </li><li>  CY (√úbertrag) nimmt den Wert 1 an, wenn als Ergebnis des Befehls eine √úbertragung oder Ausleihe in ein h√∂herwertiges Bit durchgef√ºhrt wird </li><li>  AC (Auxillary Carry) wird haupts√§chlich f√ºr BCD-Mathematik (Binary Coded Decimal) verwendet.  Weitere Informationen finden Sie im Handbuch. In Space Invaders wird dieses Flag nicht verwendet. </li></ul><br>  Statuscodes werden in bedingten Verzweigungsbefehlen verwendet. Beispielsweise f√ºhrt JZ eine Verzweigung nur durch, wenn das Z-Flag gesetzt ist. <br><br>  Die meisten Anweisungen haben drei Formen: f√ºr Register, f√ºr unmittelbare Werte und f√ºr den Speicher.  Lassen Sie uns ein paar Anweisungen implementieren, um ihre Formulare zu verstehen und zu sehen, wie die Arbeit mit Statuscodes aussieht.  (Beachten Sie, dass ich das Hilfs√ºbertragungsflag nicht implementiere, da es nicht verwendet wird. Wenn ich es implementiert habe, konnte ich es nicht testen.) <br><br><h4>  Anmeldeformular </h4><br>  Hier ist eine beispielhafte Implementierung von zwei Anweisungen mit einem Registerformular;  Im ersten Fall habe ich den Code bereitgestellt, um seine Arbeit verst√§ndlicher zu machen, und im zweiten Fall wird eine kompaktere Form vorgestellt, die dasselbe tut. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD B { //      , //      uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;b; //  :    , //    , //      if ((answer &amp; 0xff) == 0) state-&gt;cc.z = 1; else state-&gt;cc.z = 0; //  :   7 , //    , //      if (answer &amp; 0x80) state-&gt;cc.s = 1; else state-&gt;cc.s = 0; //   if (answer &gt; 0xff) state-&gt;cc.cy = 1; else state-&gt;cc.cy = 0; //    state-&gt;cc.p = Parity( answer &amp; 0xff); state-&gt;a = answer &amp; 0xff; } //  ADD     case 0x81: //ADD C { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;c; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br>  Ich emuliere 8-Bit-Mathematikbefehle mit einer 16-Bit-Zahl.  Dies erleichtert es, F√§lle zu verfolgen, in denen die Berechnungen einen √úbertrag erzeugen. <br><br><h4>  Formular f√ºr unmittelbare Werte </h4><br>  Die Form f√ºr unmittelbare Werte ist fast dieselbe, au√üer dass das Byte nach dem Befehl die Quelle des hinzugef√ºgten ist.  Da "opcode" ein Zeiger auf den aktuellen Befehl im Speicher ist, ist opcode [1] sofort das n√§chste Byte. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xC6</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADI  { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) opcode[1]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h4>  Form f√ºr die Erinnerung </h4><br>  In der Speicherform wird ein Byte hinzugef√ºgt, zu dem die in einem Paar von HL-Registern gespeicherte Adresse angibt. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x86</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD M { uint16_t offset = (state-&gt;h&lt;&lt;8) | (state-&gt;l); uint16_t answer = (uint16_t) state-&gt;a + state-&gt;memory[offset]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h3>  Anmerkungen </h3><br>  Die √ºbrigen arithmetischen Anweisungen werden auf √§hnliche Weise implementiert.  Erg√§nzungen: <br><br><ul><li>  In verschiedenen Versionen mit √úbertrag (ADC, ACI, SBB, SUI) verwenden wir gem√§√ü dem Referenzhandbuch √úbertragsbits in den Berechnungen. </li><li>  INX und DCX wirken sich auf Registerpaare aus, diese Befehle wirken sich nicht auf Flags aus. </li><li>  DAD ist ein weiterer Befehl eines Registerpaares, der nur das √úbertragsflag betrifft </li><li>  INR und DCR beeinflussen das √úbertragsflag nicht </li></ul><br><h1>  Zweiggruppe </h1><br>  Nachdem Sie sich mit den Statuscodes befasst haben, wird die Zweigstellengruppe f√ºr Sie klar genug.  Es gibt zwei Arten der Verzweigung: √úberg√§nge (JMP) und Aufrufe (CALL).  JMP setzt den PC nur auf den Wert des Sprungziels.  CALL wird f√ºr Routinen verwendet, schreibt die R√ºcksprungadresse in den Stapel und weist dem PC dann die Zieladresse zu.  RET kehrt von CALL zur√ºck, empf√§ngt die Adresse vom Stapel und schreibt sie auf den PC. <br><br>  Sowohl JMP als auch CALL gehen nur zu absoluten Adressen, die nach dem Opcode in Bytes codiert sind. <br><br><h3>  Jmp </h3><br>  Der JMP-Befehl verzweigt bedingungslos zur Zieladresse.  Es gibt auch bedingte Verzweigungsbefehle f√ºr alle Statuscodes (au√üer AC): <br><br><ul><li>  JNZ und JZ f√ºr Null </li><li>  JNC und JC f√ºr die Migration </li><li>  JPO und JPE f√ºr Parit√§t </li><li>  JP (Plus) und JM (Minus) f√ºr das Zeichen </li></ul><br>  Hier ist eine Implementierung einiger von ihnen: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc2</span></span>: <span class="hljs-comment"><span class="hljs-comment">//JNZ  if (0 == state-&gt;cc.z) state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; else //    state-&gt;pc += 2; break; case 0xc3: //JMP  state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; break;</span></span></code> </pre> <br><h3>  CALL und RET </h3><br>  CALL schiebt die Adresse des Befehls nach dem Aufruf auf den Stapel und springt dann zur Zieladresse.  RET empf√§ngt die Adresse vom Stapel und speichert sie auf dem PC.  Bedingte Versionen von CALL und RET existieren f√ºr alle Zust√§nde. <br><br><ul><li>  CZ, CNZ, RZ, RNZ f√ºr Null </li><li>  CNC, CC, RNC, RC zur √úbertragung </li><li>  CPO, CPE, RPO, RPE f√ºr Parit√§t </li><li>  CP, CM, RP, RM f√ºr Zeichen </li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break; case 0xc9: //RET state-&gt;pc = state-&gt;memory[state-&gt;sp] | (state-&gt;memory[state-&gt;sp+1] &lt;&lt; 8); state-&gt;sp += 2; break;</span></span></code> </pre> <br><h3>  Anmerkungen </h3><br><ul><li>  Der PCHL-Befehl springt bedingungslos zu einer Adresse in einem Paar von HL-Registern. </li><li>  Ich habe das zuvor diskutierte RST nicht in diese Gruppe aufgenommen.  Es schreibt die R√ºcksprungadresse in den Stapel und springt dann zu der vordefinierten Adresse am unteren Rand des Speichers. </li></ul><br><h1>  Logische Gruppe </h1><br>  Diese Gruppe f√ºhrt logische Operationen aus (siehe den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Beitrag des</a> Tutorials).  Aufgrund ihrer Natur √§hneln sie einer arithmetischen Gruppe darin, dass die meisten Operationen mit Register A (Laufwerk) arbeiten und die meisten Operationen Flags beeinflussen.  Alle Operationen werden mit 8-Bit-Werten ausgef√ºhrt. In dieser Gruppe gibt es keine Befehle, die Registerpaare betreffen. <br><br><h3>  Boolesche Operationen </h3><br>  UND, ODER, NICHT (CMP) und "exklusiv oder" (XOR) werden als Boolesche Operationen bezeichnet.  ODER und UND habe ich fr√ºher erkl√§rt.  Der NOT-Befehl (f√ºr den 8080-Prozessor hei√üt er CMA oder Komplementakkumulator) √§ndert einfach die Bitwerte - alle Einheiten werden zu Nullen und Nullen werden zu Einsen. <br><br>  Ich nehme XOR als ‚ÄûDifferenzerkenner‚Äú wahr.  Ihre Wahrheitstabelle sieht so aus: <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Ergebnis </td></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  1 </td><td>  1 </td></tr><tr><td>  1 </td><td>  0 </td><td>  1 </td></tr><tr><td>  1 </td><td>  1 </td><td>  0 </td></tr></tbody></table><br>  AND, OR und XOR haben eine Form f√ºr Register, Speicher und unmittelbare Werte.  (CMP hat nur einen Befehl, bei dem zwischen Gro√ü- und Kleinschreibung unterschieden wird).  Hier ist eine Implementierung eines Paares von Opcodes: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x2F</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CMA (not) state-&gt;a = ~state-&gt;a //  ,  CMA     break; case 0xe6: //ANI  { uint8_t x = state-&gt;a &amp; opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = 0; //  ,  ANI  CY state-&gt;a = x; state-&gt;pc++; //   } break;</span></span></code> </pre> <br><h3>  Zyklische Schaltbefehle </h3><br>  Diese Befehle √§ndern die Reihenfolge der Bits in den Registern.  Eine Verschiebung nach rechts verschiebt sie um ein Bit nach rechts und eine Verschiebung nach links - um ein Bit nach links: <br><br> <code>  (0b00010000) = 0b00001000</code> <br> <br> <code>  (0b00000001) = 0b00000010</code> <br> <br>  Sie scheinen wertlos zu sein, aber in Wirklichkeit ist dies nicht so.  Sie k√∂nnen verwendet werden, um durch Zweierpotenzen zu multiplizieren und zu teilen.  Nehmen Sie als Beispiel die Linksverschiebung.  <code>0b00000001</code> ist dezimal 1, und <code>0b00000001</code> es nach links verschieben, wird es <code>0b00000010</code> , <code>0b00000010</code> dezimal 2. Wenn wir eine weitere Verschiebung nach links durchf√ºhren, erhalten wir <code>0b00000100</code> , <code>0b00000100</code> 4. Eine weitere Verschiebung nach links, und wir multiplizieren mit 8. Dies funktioniert mit jedem durch Zahlen: 5 ( <code>0b00000101</code> ) ergibt bei <code>0b00001010</code> nach links 10 ( <code>0b00001010</code> ).  Eine weitere Verschiebung nach links ergibt 20 ( <code>0b00010100</code> ).  Eine Verschiebung nach rechts bewirkt dasselbe, jedoch zur Teilung. <br><br>  Der 8080 verf√ºgt nicht √ºber einen Multiplikationsbefehl, kann jedoch mit diesen Befehlen implementiert werden.  Wenn Sie verstehen, wie das geht, erhalten Sie Bonuspunkte.  Einmal wurde mir eine solche Frage bei einem Interview gestellt.  (Ich habe es getan, obwohl ich ein paar Minuten gebraucht habe.) <br><br>  Diese Befehle drehen den Antrieb zyklisch und wirken sich nur auf das √úbertragsflag aus.  Hier sind einige Befehle: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x0f</span></span>: <span class="hljs-comment"><span class="hljs-comment">//RRC { uint8_t x = state-&gt;a; state-&gt;a = ((x &amp; 1) &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break; case 0x1f: //RAR { uint8_t x = state-&gt;a; state-&gt;a = (state-&gt;cc.cy &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break;</span></span></code> </pre> <br><h3>  Vergleich </h3><br>  Die Aufgabe von CMP und CPI besteht nur darin, Flags (zum Verzweigen) zu setzen.  Sie tun dies, indem sie Flags subtrahieren, aber das Ergebnis nicht speichern. <br><br><ul><li>  Gleicherma√üen: Wenn zwei Zahlen gleich sind, wird das Z-Flag gesetzt, da ihre Subtraktion voneinander Null ergibt. </li><li>  Gr√∂√üer als: Wenn A gr√∂√üer als der zu vergleichende Wert ist, wird das CY-Flag gel√∂scht (da die Subtraktion ohne Ausleihen erfolgen kann). </li><li>  Kleiner: Wenn A kleiner als der Vergleichswert ist, wird das CY-Flag gesetzt (da A die Ausleihe abschlie√üen muss, um die Subtraktion abzuschlie√üen). </li></ul><br>  Es gibt Versionen dieser Befehle f√ºr Register, Speicher und Sofortwerte.  Die Implementierung ist eine einfache Subtraktion, ohne das Ergebnis zu speichern: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xfe</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CPI  { uint8_t x = state-&gt;a - opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); //  ,    p -   state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = (state-&gt;a &lt; opcode[1]); state-&gt;pc++; } break;</span></span></code> </pre> <br><h3>  CMC und STC </h3><br>  Sie vervollst√§ndigen die logische Gruppe.  Sie werden verwendet, um das √úbertragsflag zu setzen und zu l√∂schen. <br><br><h1>  Gruppe von Eingabe-Ausgabe- und Spezialbefehlen </h1><br>  Diese Befehle k√∂nnen keiner anderen Kategorie zugewiesen werden.  Ich werde sie der Vollst√§ndigkeit halber erw√§hnen, aber es scheint mir, dass wir wieder zu ihnen zur√ºckkehren m√ºssen, wenn wir beginnen, die Hardware von Space Invaders zu emulieren. <br><br><ul><li>  EI und DI aktivieren oder deaktivieren die F√§higkeit des Prozessors, Interrupts zu verarbeiten.  Ich habe das Interrupt_enabled-Flag zur Prozessorstatusstruktur hinzugef√ºgt und es mit diesen Befehlen gesetzt / zur√ºckgesetzt. </li><li>  Es scheint, dass RIM und SIM haupts√§chlich f√ºr serielle E / A verwendet werden.  Wenn Sie interessiert sind, k√∂nnen Sie das Handbuch lesen, aber diese Befehle werden in Space Invaders nicht verwendet.  Ich werde sie nicht emulieren. </li><li>  HLT ist ein Stopp.  Ich glaube nicht, dass wir es emulieren m√ºssen, aber Sie k√∂nnen Ihren Beendigungscode (oder Beendigungscode (0)) aufrufen, wenn Sie diesen Befehl sehen. </li><li>  IN und OUT sind Befehle, mit denen das 8080-Prozessorger√§t mit externen Ger√§ten kommuniziert.  W√§hrend wir sie implementieren, werden sie nichts anderes tun, als ihr Datenbyte zu √ºberspringen.  (Sp√§ter werden wir zu ihnen zur√ºckkehren). </li><li>  NOP ist "keine Operation".  Eine Anwendung von NOP besteht darin, das Timing des Bedienfelds zu steuern (die Ausf√ºhrung dauert vier CPU-Zyklen). </li></ul><br>  Eine weitere Anwendung von NOP ist die Codemodifikation.  Angenommen, wir m√ºssen den ROM-Code des Spiels √§ndern.  Wir k√∂nnen nicht einfach unn√∂tige Opcodes l√∂schen, da wir nicht alle CALL- und JMP-Befehle √§ndern m√∂chten (sie sind falsch, wenn mindestens ein Teil des Codes verschoben wird).  Mit NOP k√∂nnen wir den Code loswerden.  <em>Das Hinzuf√ºgen von Code ist viel schwieriger!</em>  <em>Sie k√∂nnen es hinzuf√ºgen, indem Sie irgendwo im ROM Speicherplatz suchen und den Befehl in JMP √§ndern.</em> <br><br><h1>  Stapelgruppe </h1><br>  Wir haben die Mechanik f√ºr die meisten Teams in der Stapelgruppe bereits abgeschlossen.  Wenn Sie die Arbeit mit mir gemacht haben, sind diese Befehle einfach zu implementieren. <br><br><h3>  PUSH und POP </h3><br>  PUSH und POP funktionieren nur mit Registerpaaren.  PUSH schreibt ein Registerpaar in den Stapel, und POP nimmt 2 Bytes vom oberen Rand des Stapels und schreibt sie in ein Registerpaar. <br><br>  Es gibt vier Opcodes f√ºr PUSH und POP, einen f√ºr jedes der Paare: BC, DE, HL und PSW.  PSW ist ein spezielles Paar von Laufwerksflagregistern und Statuscodes.  Hier ist meine Implementierung von PUSH und POP f√ºr BC und PSW.  Es gibt keine Kommentare darin - ich denke nicht, dass es hier etwas besonders Kniffliges gibt. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc1</span></span>: <span class="hljs-comment"><span class="hljs-comment">//POP B { state-&gt;c = state-&gt;memory[state-&gt;sp]; state-&gt;b = state-&gt;memory[state-&gt;sp+1]; state-&gt;sp += 2; } break; case 0xc5: //PUSH B { state-&gt;memory[state-&gt;sp-1] = state-&gt;b; state-&gt;memory[state-&gt;sp-2] = state-&gt;c; state-&gt;sp = state-&gt;sp - 2; } break; case 0xf1: //POP PSW { state-&gt;a = state-&gt;memory[state-&gt;sp+1]; uint8_t psw = state-&gt;memory[state-&gt;sp]; state-&gt;cc.z = (0x01 == (psw &amp; 0x01)); state-&gt;cc.s = (0x02 == (psw &amp; 0x02)); state-&gt;cc.p = (0x04 == (psw &amp; 0x04)); state-&gt;cc.cy = (0x05 == (psw &amp; 0x08)); state-&gt;cc.ac = (0x10 == (psw &amp; 0x10)); state-&gt;sp += 2; } break; case 0xf5: //PUSH PSW { state-&gt;memory[state-&gt;sp-1] = state-&gt;a; uint8_t psw = (state-&gt;cc.z | state-&gt;cc.s &lt;&lt; 1 | state-&gt;cc.p &lt;&lt; 2 | state-&gt;cc.cy &lt;&lt; 3 | state-&gt;cc.ac &lt;&lt; 4 ); state-&gt;memory[state-&gt;sp-2] = psw; state-&gt;sp = state-&gt;sp - 2; } break;</span></span></code> </pre> <br><h3>  SPHL und XTHL </h3><br>  Es gibt zwei weitere Teams in der Stapelgruppe - SPHL und XTHL. <br><br><ul><li>  <code>SPHL</code> verschiebt HL zu SP (wodurch SP gezwungen wird, eine neue Adresse zu erhalten). </li><li>  <code>XTHL</code> tauscht das, was sich oben auf dem Stapel befindet, mit dem, was sich in einem Paar HL-Registern befindet.  Warum sollten Sie das tun m√ºssen?  Ich wei√ü nicht. </li></ul><br><h1>  Ein bisschen mehr √ºber Bin√§rzahlen </h1><br>  Wenn Sie ein Computerprogramm schreiben, m√ºssen Sie unter anderem die Art der Daten ausw√§hlen, die f√ºr die Zahlen verwendet werden - ob sie negativ sein sollen und wie gro√ü sie maximal sein sollen.  F√ºr den CPU-Emulator ben√∂tigen wir den Datentyp, der mit dem Datentyp der Ziel-CPU √ºbereinstimmt. <br><br><h3>  Signiert und nicht signiert </h3><br>  Als wir √ºber Hex-Zahlen sprachen, betrachteten wir sie als vorzeichenlos - das hei√üt, jede Bin√§rziffer der Hexadezimalzahl hatte einen positiven Wert und jede wurde als Zweierpotenz (Einheiten, zwei, vier usw.) betrachtet. <br><br>  Wir haben uns mit der Frage der Computerspeicherung negativer Zahlen befasst.  Wenn Sie wissen, dass die betreffenden Daten ein Vorzeichen haben, dh negativ sein k√∂nnen, k√∂nnen Sie eine negative Zahl am h√∂chstwertigen Bit der Zahl (h√∂chstwertiges Bit, MSB) erkennen.  Wenn die Datengr√∂√üe ein Byte betr√§gt, ist jede Zahl mit einem bestimmten MSB-Bitwert negativ und jede mit einem MSB von Null ist positiv. <br><br>  Der Wert einer negativen Zahl wird als zus√§tzlicher Code gespeichert.  Wenn wir eine vorzeichenbehaftete Zahl haben und das MSB gleich eins ist und wir herausfinden m√∂chten, wie die Zahl lautet, k√∂nnen wir sie wie folgt konvertieren: F√ºhren Sie ein bin√§res ‚ÄûNICHT‚Äú f√ºr Hex-Zahlen aus und f√ºgen Sie dann eine hinzu. <br><br>  F√ºr die Hex-Zahl 0x80 ist beispielsweise ein MSB-Bit gesetzt, dh es ist negativ.  Das bin√§re "NICHT" der Zahl 0x80 ist 0x7f oder dezimal 127. 127 + 1 = 128. Das hei√üt, 0x80 in dezimal ist -128.  Zweites Beispiel: 0xC5.  Nicht (0xC5) = 0x3A = Dezimalzahl 58 +1 = Dezimalzahl 59. Das hei√üt, 0xC5 ist Dezimalzahl -59. <br><br>  Was bei Zahlen mit zus√§tzlichem Code √ºberrascht, ist, dass wir mit ihnen wie mit vorzeichenlosen Zahlen Berechnungen durchf√ºhren k√∂nnen und sie weiterhin <em>funktionieren</em> .  Der Computer muss mit Schildern nichts Besonderes tun.  Ich werde einige Beispiele zeigen, die dies beweisen. <br><br><pre>  Beispiel 1<font></font>
<font></font>
      Dezimal-Hex-Bin√§r    
       -3 0xFD 1111 1101    
    + 10 0x0A +0000 1010    
    ----- -----------    
        7 0x07 1 0000 0111    
                        ^ Dies wird im √úbertragsbit aufgezeichnet<font></font>
<font></font>
    Beispiel 2    <font></font>
<font></font>
      Dezimal-Hex-Bin√§r    
      -59 0xC5 1100 0101    
    + 33 0x21 +0010 0001    
    ----- -----------    
      -26 0xE6 1110 0110 </pre><br><br>  In Beispiel 1 sehen wir, dass das Addieren von 10 und -3 zu 7 f√ºhrt. Das Additionsergebnis wurde √ºbertragen, sodass das C-Flag gesetzt werden kann. In Beispiel 2 war das Additionsergebnis negativ, daher dekodieren wir dies: Nicht (0xE6) = 0x19 = 25 + 1 = 26. <code>0xE6 = -26</code> Explosion des Gehirns! <br><br>  Wenn Sie m√∂chten, lesen Sie mehr √ºber den zus√§tzlichen Code auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> . <br><br><h3>  Datentypen </h3><br>  In C besteht eine Beziehung zwischen Datentypen und der Anzahl der f√ºr diesen Typ verwendeten Bytes.  Tats√§chlich interessieren wir uns nur f√ºr ganze Zahlen.  Die Standard- / Old-School-C-Datentypen sind char, int und long sowie ihre Freunde char ohne Vorzeichen, int ohne Vorzeichen und long ohne Vorzeichen.  Das Problem ist, dass diese Typen auf verschiedenen Plattformen und in verschiedenen Compilern unterschiedliche Gr√∂√üen haben k√∂nnen. <br><br>  Daher ist es am besten, einen Datentyp f√ºr unsere Plattform auszuw√§hlen, der die Gr√∂√üe der Daten explizit deklariert.  Wenn Ihre Plattform stdint.h hat, k√∂nnen Sie int8_t, uint8_t usw. verwenden. <br><br>  Die Gr√∂√üe einer Ganzzahl bestimmt die maximale Anzahl, die darin gespeichert werden kann.  Bei vorzeichenlosen Ganzzahlen k√∂nnen Sie Zahlen von 0 bis 255 in 8 Bit speichern. Wenn Sie in hexadezimal √ºbersetzen, ist dies von 0x00 bis 0xFF.  Da 0xFF "alle Bits gesetzt" hat und der Dezimalzahl 255 entspricht, ist es v√∂llig logisch, dass das Intervall einer vorzeichenlosen Einzelbyte-Ganzzahl 0-255 betr√§gt.  Intervalle sagen uns, dass alle Gr√∂√üen von ganzen Zahlen genau gleich funktionieren - Zahlen entsprechen der Zahl, die erhalten wird, wenn alle Bits gesetzt sind. <br><br><table><tbody><tr><th>  Typ </th><th>  Intervall </th><th>  Hex </th></tr><tr><td>  8-Bit ohne Vorzeichen </td><td>  0-255 </td><td>  0x0-0xFF </td></tr><tr><td>  8-Bit signiert </td><td>  -128-127 </td><td>  0x80-0x7F </td></tr><tr><td>  16-Bit ohne Vorzeichen </td><td>  0-65535 </td><td>  0x0-0xFFFF </td></tr><tr><td>  16-Bit signiert </td><td>  -32768-32767 </td><td>  0x8000-0x7FFF </td></tr><tr><td>  32-Bit ohne Vorzeichen </td><td>  0-4294967295 </td><td>  0x0-0xFFFFFFFFFF </td></tr><tr><td>  32-Bit signiert </td><td>  -2147483648-2147483647 </td><td>  0x80000000-0x7FFFFFFF </td></tr></tbody></table><br>  Noch interessanter ist, dass -1 in jedem vorzeichenbehafteten Datentyp eine Zahl ist, f√ºr die alle Bits gesetzt sind (0xFF f√ºr vorzeichenbehaftetes Byte, 0xFFFF f√ºr vorzeichenbehaftete 16-Bit-Zahl und 0xFFFFFFFF f√ºr vorzeichenbehaftete 32-Bit-Zahl).  Wenn die Daten als vorzeichenlos betrachtet werden, wird f√ºr alle gegebenen Bits die maximal m√∂gliche Anzahl f√ºr diesen Datentyp erhalten. <br><br>  Um Prozessorregister zu emulieren, w√§hlen wir den Datentyp aus, der der Gr√∂√üe dieses Registers entspricht.  Es lohnt sich wahrscheinlich, standardm√§√üig nicht signierte Typen auszuw√§hlen und zu konvertieren, wenn Sie sie als signiert betrachten m√ºssen.  Zum Beispiel verwenden wir den Datentyp uint8_t, um ein 8-Bit-Register darzustellen. <br><br><h3>  Hinweis: Verwenden Sie einen Debugger, um Datentypen zu konvertieren </h3><br>  Wenn gdb auf Ihrer Plattform installiert ist, ist es sehr praktisch, es f√ºr die Arbeit mit Bin√§rzahlen zu verwenden.  Im Folgenden werde ich ein Beispiel zeigen. In der unten gezeigten Sitzung sind Zeilen, die mit # beginnen, Kommentare, die ich sp√§ter hinzugef√ºgt habe. <br><br> <code>#  /c,   gdb      <br> (gdb) print /c 0xFD <br> $1 = -3 '?' <br> <br> #  /x,   gdb    hex <br> #   "p"  "print" <br> (gdb) p /c 0xA <br> $2 = 10 '\n' <br> <br> #    2  " " <br> (gdb) p /c 0xC5 <br> $3 = -59 '?' <br> (gdb) p /c 0xC5+0x21 <br> $4 = -26 '?' <br> <br> #  print  ,  gdb    <br> (gdb) p 0x21 <br> $9 = 33 <br> <br> #     ,     gdb, <br> #  ,      <br> (gdb) p 0xc5 <br> $5 = 197 # <br> (gdb) p /c 0xc5 <br> $3 = -59 '?' # <br> (gdb) p 0xfd <br> $6 = 253 <br> <br> #        (   32- ) <br> (gdb) p /x -3 <br> $7 = 0xfffffffd <br> <br> #   1     <br> (gdb) print (char) 0xff <br> $1 = -1 '?' <br> #   1     <br> (gdb) print (unsigned char) 0xff <br> $2 = 255 '?'</code> <br> <br>  Wenn ich mit Hex-Zahlen arbeite, mache ich das immer in gdb - und das passiert fast jeden Tag.  So viel einfacher als das √ñffnen eines Programmierrechners mit einer grafischen Benutzeroberfl√§che.  √ñffnen Sie auf Linux- (und Mac OS X-) Computern zum Starten einer GDB-Sitzung einfach ein Terminal und geben Sie "GDB" ein.  Wenn Sie Xcode unter OS X verwenden, k√∂nnen Sie nach dem Starten des Programms die Konsole in Xcode verwenden (die Konsole, an die die printf-Ausgabe ausgegeben wird).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unter Windows ist der GDB-Debugger von Cygwin erh√§ltlich. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPU Emulator Termination </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem Sie all diese Informationen erhalten haben, sind Sie bereit f√ºr eine lange Reise. </font><font style="vertical-align: inherit;">Sie m√ºssen entscheiden, wie Sie den Emulator implementieren - entweder eine vollst√§ndige 8080-Emulation erstellen oder nur die Befehle implementieren, die zum Abschlie√üen des Spiels erforderlich sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich f√ºr eine vollst√§ndige Emulation entscheiden, ben√∂tigen Sie einige weitere Tools. </font><font style="vertical-align: inherit;">Ich werde im n√§chsten Abschnitt dar√ºber sprechen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere M√∂glichkeit besteht darin, nur die vom Spiel verwendeten Anweisungen zu emulieren. </font><font style="vertical-align: inherit;">Wir werden weiterhin das riesige Switch-Konstrukt ausf√ºllen, das wir im Abschnitt Emulator Shell erstellt haben. </font><font style="vertical-align: inherit;">Wir werden den folgenden Vorgang wiederholen, bis wir einen einzigen nicht realisierten Befehl haben:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Starten Sie den Emulator mit ROM Space Invaders </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Aufruf wird beendet, </font></font><code>UnimplementedInstruction()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn der Befehl nicht bereit ist</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Emulieren Sie diese Anweisung </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gehe zu 1 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das erste, was ich tat, als ich anfing, meinen Emulator zu schreiben, war, Code von meinem Disassembler hinzuzuf√ºgen. </font><font style="vertical-align: inherit;">So konnte ich einen Befehl ausgeben, der wie folgt ausgef√ºhrt werden sollte:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; Disassemble8080Op(state-&gt;memory, state-&gt;pc); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-comment"><span class="hljs-comment">//NOP /* ... */ } /*    */ printf("\tC=%d,P=%d,S=%d,Z=%d\n", state-&gt;cc.cy, state-&gt;cc.p, state-&gt;cc.s, state-&gt;cc.z); printf("\tA $%02x B $%02x C $%02x D $%02x E $%02x H $%02x L $%02x SP %04x\n", state-&gt;a, state-&gt;b, state-&gt;c, state-&gt;d, state-&gt;e, state-&gt;h, state-&gt;l, state-&gt;sp); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe am Ende auch Code hinzugef√ºgt, um alle Register und Statusflags anzuzeigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gute Nachrichten: Um in das Programm f√ºr 50.000 Teams einzutauchen, ben√∂tigen wir nur eine Teilmenge der 8080-Opcodes. Ich werde sogar eine Liste der Opcodes geben, die implementiert werden m√ºssen:</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Opcode </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Team </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x00 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nein </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x01 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI B, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x05 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCR B. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x06 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI B, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x09 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vater b </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0d </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCR C. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI C, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0f </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rrc </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x11 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI D, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x13 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inx d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x19 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Papa d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x1a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LDAX D. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x21 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI H, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x23 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inx h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x26 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI H, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x29 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Papa h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x31 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI SP, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x32 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> STA adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x36 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI M, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x3a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lda adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x3e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI A, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x56 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV D, M. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x5e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV E, M. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x66 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV H, M. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x6f </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV L, A. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x77 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV M, A. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, D. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7b </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, E. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7c </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, H. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, M. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xa7 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANA A. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xaf </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> XRA A. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop b </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jnz adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jmp adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DR√úCKEN B. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ADI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc9 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ret </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xcd </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rufen Sie adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OUT D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DR√úCKEN D. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DR√úCKEN H. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xeb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Xchg </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> POP PSW </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PSW DR√úCKEN </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ei </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfe </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPI D8 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies sind nur 50 Anweisungen, und 10 davon sind Bewegungen, die trivial implementiert werden. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debuggen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber ich habe schlechte Nachrichten. </font><font style="vertical-align: inherit;">Ihr Emulator wird mit ziemlicher Sicherheit nicht richtig funktionieren, und Fehler in einem solchen Code sind sehr schwer zu finden. </font><font style="vertical-align: inherit;">Wenn Sie wissen, welcher Befehl sich schlecht verh√§lt (z. B. ein √úbergang oder ein Aufruf von bedeutungslosem Code), k√∂nnen Sie versuchen, den Fehler zu beheben, indem Sie Ihren Code untersuchen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neben der √úberpr√ºfung des Codes gibt es noch eine andere M√∂glichkeit, das Problem zu beheben: Vergleichen Sie Ihren Emulator mit einem Emulator, der mit Sicherheit funktioniert. </font><font style="vertical-align: inherit;">Wir gehen davon aus, dass ein anderer Emulator immer korrekt funktioniert und alle Unterschiede Fehler in Ihrem Emulator sind. </font><font style="vertical-align: inherit;">Zum Beispiel k√∂nnen Sie meinen Emulator verwenden. </font><font style="vertical-align: inherit;">Sie k√∂nnen sie manuell parallel ausf√ºhren. </font><font style="vertical-align: inherit;">Sie k√∂nnen Zeit sparen, wenn Sie meinen Code in Ihr Projekt integrieren, um den folgenden Prozess zu erhalten:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen Sie einen Status f√ºr Ihren Emulator </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstelle einen Zustand f√ºr mich </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºr das n√§chste Team </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rufen Sie Ihren Emulator mit Ihrem Status an </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich rufe meine mit meinem Verm√∂gen an </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vergleichen Sie unsere beiden Staaten </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suche nach Fehlern in irgendwelchen Unterschieden </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gehe zu 3 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere M√∂glichkeit besteht darin, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese Site</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> manuell zu verwenden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ein 8080 Javascript-Prozessor-Emulator, der sogar ROM Space Invaders enth√§lt. </font><font style="vertical-align: inherit;">Hier ist der Prozess:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Starten Sie die Space Invaders-Emulation neu, indem Sie auf die Schaltfl√§che Space Invaders klicken </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dr√ºcken Sie die Taste ‚ÄûRun 1‚Äú, um den Befehl auszuf√ºhren. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir f√ºhren den folgenden Befehl in unserem Emulator aus </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vergleichen Sie den Prozessorstatus mit Ihrem </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn die Bedingungen √ºbereinstimmen, gehe zu 2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Bedingungen nicht √ºbereinstimmen, ist Ihre Anweisungsemulation fehlerhaft. </font><font style="vertical-align: inherit;">Korrigieren Sie es und beginnen Sie erneut mit Schritt 1.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe diese Methode am Anfang verwendet, um meinen 8080-Emulator zu debuggen. Ich werde nicht l√ºgen - der Prozess kann langwierig sein. Infolgedessen stellten sich viele meiner Probleme als Tippfehler und Fehler beim Kopieren und Einf√ºgen heraus, die nach der Erkennung sehr einfach zu beheben waren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie Ihren Code Schritt f√ºr Schritt ausf√ºhren, werden die meisten der ersten 30.000 Anweisungen in einem Zyklus von etwa $ 1a5f ausgef√ºhrt. Wenn Sie sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javascript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Emulator</font></a><font style="vertical-align: inherit;"> ansehen </font><font style="vertical-align: inherit;">, k√∂nnen Sie sehen, dass dieser Code Daten auf den Bildschirm kopiert. Ich bin sicher, dass dieser Code oft aufgerufen wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem ersten Rendern des Bildschirms bleibt das Programm nach 50.000 Befehlen in dieser Endlosschleife stecken:</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-number"><span class="hljs-number">0</span></span>ada LDA <span class="hljs-meta"><span class="hljs-meta">$20</span></span>c0 <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ANA A <span class="hljs-number"><span class="hljs-number">0</span></span>ade JNZ <span class="hljs-meta"><span class="hljs-meta">$0</span></span>ada</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wartet, bis sich der Wert im Speicher bei $ 20c0 auf Null √§ndert. </font><font style="vertical-align: inherit;">Da der Code in dieser Schleife $ 20c0 nicht genau √§ndert, muss es sich um ein Signal von einem anderen Ort handeln. </font><font style="vertical-align: inherit;">Es ist Zeit, √ºber die Emulation des ‚ÄûEisens‚Äú eines Arcade-Automaten zu sprechen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir mit dem n√§chsten Abschnitt fortfahren, stellen Sie sicher, dass Ihr CPU-Emulator in diese Endlosschleife f√§llt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Referenz siehe </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meine Quellen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Volle 8080-Emulation </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Lektion, die mich viel gekostet hat: Implementieren Sie keine Teams, die Sie nicht testen k√∂nnen. </font><font style="vertical-align: inherit;">Dies ist eine gute Faustregel f√ºr jede in der Entwicklung befindliche Software. </font><font style="vertical-align: inherit;">Wenn Sie das Team nicht √ºberpr√ºfen, wird es definitiv kaputt sein. </font><font style="vertical-align: inherit;">Und je weiter Sie sich von der Implementierung entfernen, desto schwieriger wird es, Probleme zu finden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine andere L√∂sung, wenn Sie einen vollst√§ndigen 8080-Emulator erstellen und sicherstellen m√∂chten, dass er funktioniert. </font><font style="vertical-align: inherit;">Ich habe einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code f√ºr 8080</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> namens cpudiag.asm entdeckt, der zum Testen jedes 8080-Prozessorbefehls entwickelt wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich </font><font style="vertical-align: inherit;">f√ºhre </font><font style="vertical-align: inherit;">Sie aus mehreren Gr√ºnden nach dem ersten in diesen Prozess ein:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich wollte, dass die Beschreibung dieses Prozesses f√ºr einen anderen Prozessor wiederholt wird. </font><font style="vertical-align: inherit;">Ich glaube nicht, dass das Analogon von cpudiag.asm f√ºr alle Prozessoren existiert.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen k√∂nnen, ist der Prozess ziemlich m√ºhsam. </font><font style="vertical-align: inherit;">Ich denke, ein Anf√§nger beim Debuggen von Assembler-Code wird gro√üe Schwierigkeiten haben, wenn diese Schritte nicht aufgef√ºhrt sind.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So habe ich diesen Test mit meinem Emulator verwendet. </font><font style="vertical-align: inherit;">Sie k√∂nnen es verwenden oder einen besseren Weg finden, um es zu integrieren.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Baugruppe testen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe ein paar Dinge ausprobiert, aber als Ergebnis habe ich mich f√ºr </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese sch√∂ne Seite entschieden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich habe den Text cpudiag.asm in den linken Bereich eingef√ºgt und den Build ohne Probleme abgeschlossen. </font><font style="vertical-align: inherit;">Ich habe eine Minute gebraucht, um herauszufinden, wie ich das Ergebnis herunterladen kann. Durch Klicken auf die Schaltfl√§che ‚ÄûMake Beautiful Code‚Äú unten links habe ich eine Datei namens test.bin heruntergeladen, die den Code 8080 kompiliert. Ich konnte dies mit meinem Disassembler √ºberpr√ºfen. </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden Sie cpudiag.asm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus dem Spiegel auf meiner Website herunter. </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden Sie cpudiag.bin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (kompilierter Code 8080) von meiner Website </font><a href=""><font style="vertical-align: inherit;">herunter</font></a><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Laden Sie einen Test auf meinen Emulator hoch </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt Invasoren zu laden. * Dateien lade ich diese Bin√§rdatei. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ergeben sich kleine Schwierigkeiten. Erstens enth√§lt der Quell-Assembler-Code eine Zeile, </font></font><code>ORG 00100H</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dh, die gesamte Datei wird unter der Annahme kompiliert, dass sich die erste Codezeile in 0x100 hex befindet. Ich hatte noch nie zuvor Code in Assembler 8080 geschrieben, daher wusste ich nicht, was diese Zeile bewirkt. Ich brauchte nur eine Minute, um herauszufinden, dass alle Zweigstellenadressen falsch waren und der Speicher bei 0x100 beginnen musste. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens muss ich, da mein Emulator von vorne anf√§ngt, zuerst zum echten Code √ºbergehen. Nachdem ich den Hex-Wert an der Null-Adresse in den Speicher eingef√ºgt hatte </font></font><code>JMP $0100</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, habe ich mich damit befasst. (Oder Sie k√∂nnen den PC einfach mit einem Wert von 0x100 initialisieren.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drittens habe ich einen Fehler im kompilierten Code gefunden. </font><font style="vertical-align: inherit;">Ich denke, der Grund ist die falsche Verarbeitung der letzten Codezeile </font></font><code>STACK EQU TEMPP+256</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber ich bin mir nicht sicher. </font><font style="vertical-align: inherit;">Wie dem auch sei, der Stapel w√§hrend der Kompilierung befand sich bei $ 6ad, und die ersten PUSH begannen, den Code neu zu schreiben. </font><font style="vertical-align: inherit;">Ich schlug vor, dass die Variable wie der Rest des Codes auch um 0x100 versetzt werden sollte, also habe ich sie behoben, indem ich "0x7" in die Codezeile eingef√ºgt habe, die den Stapelzeiger initialisiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da ich in meinem Emulator keine DAA- oder Zusatzmigration implementiert habe, √§ndere ich den Code, um diese Pr√ºfung zu √ºberspringen (wir √ºberspringen sie nur mit JMP).</font></font><br><br><pre> <code class="cpp hljs"> ReadFileIntoMemoryAt(state, <span class="hljs-string"><span class="hljs-string">"/Users/kpmiller/Desktop/invaders/cpudiag.bin"</span></span>, <span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   JMP 0x100 state-&gt;memory[0]=0xc3; state-&gt;memory[1]=0; state-&gt;memory[2]=0x01; //Fix the stack pointer from 0x6ad to 0x7ad // this 0x06 byte 112 in the code, which is // byte 112 + 0x100 = 368 in memory state-&gt;memory[368] = 0x7; //  DAA state-&gt;memory[0x59c] = 0xc3; //JMP state-&gt;memory[0x59d] = 0xc2; state-&gt;memory[0x59e] = 0x05;</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Test versucht, eine Schlussfolgerung zu ziehen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offensichtlich st√ºtzt sich dieser Test auf die Hilfe des CP / M-Betriebssystems. Ich fand heraus, dass CP / M einen Code f√ºr $ 0005 hat, der Nachrichten an die Konsole druckt, und √§nderte meine CALL-Emulation, um dieses Verhalten zu behandeln. Ich bin nicht sicher, ob alles richtig gelaufen ist, aber es hat f√ºr die beiden Nachrichten funktioniert, die das Programm zu drucken versucht. Meine CALL-Emulation zum Ausf√ºhren dieses Tests sieht folgenderma√üen aus:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  #ifdef FOR_CPUDIAG if (5 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { if (state-&gt;c == 9) { uint16_t offset = (state-&gt;d&lt;&lt;8) | (state-&gt;e); char *str = &amp;state-&gt;memory[offset+3]; // - while (*str != '$') printf("%c", *str++); printf("\n"); } else if (state-&gt;c == 2) { //    ,   ,    printf ("print char routine called\n"); } } else if (0 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { exit(0); } else #endif { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei diesem Test habe ich mehrere Probleme in meinem Emulator gefunden. Ich bin mir nicht sicher, welcher von ihnen in das Spiel involviert sein w√ºrde, aber wenn sie es w√§ren, w√§re es sehr schwierig, sie zu finden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe alle Opcodes implementiert (mit Ausnahme von DAA und seinen Freunden). Ich habe 3-4 Stunden gebraucht, um Probleme in meinen Herausforderungen zu beheben und neue zu implementieren. Es war definitiv schneller als der oben beschriebene manuelle Prozess - bevor ich diesen Test fand, verbrachte ich mehr als 4 Stunden mit dem manuellen Prozess. Wenn Sie diese Erkl√§rung herausfinden k√∂nnen, empfehle ich, diese Methode zu verwenden, anstatt sie manuell zu vergleichen. Die Kenntnis des manuellen Prozesses ist jedoch auch eine gro√üe F√§higkeit. Wenn Sie einen anderen Prozessor emulieren m√∂chten, sollten Sie darauf zur√ºckgreifen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie diesen Vorgang nicht ausf√ºhren k√∂nnen oder er zu kompliziert erscheint, lohnt es sich auf jeden Fall, den oben beschriebenen Ansatz mit zwei verschiedenen Emulatoren zu w√§hlen, die in Ihrem Programm ausgef√ºhrt werden. </font><font style="vertical-align: inherit;">Wenn mehrere Millionen Befehle im Programm erscheinen und Interrupts hinzugef√ºgt werden, ist es unm√∂glich, zwei Emulatoren manuell zu vergleichen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418699/">https://habr.com/ru/post/de418699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418687/index.html">3,5 "Umdrehung: Details eines kleinen Auslegers von Disketten mit D√§mpfen</a></li>
<li><a href="../de418689/index.html">Erstellen von Komponentenbibliotheken in Figma, Einsparen eines Budgets am Beispiel einer Online-Auktion</a></li>
<li><a href="../de418691/index.html">Rancher: Kubernetes in 5 Minuten auf Bare Metal</a></li>
<li><a href="../de418693/index.html">Warum ist Gl√ºck im Gehirn so schwer zu erkennen?</a></li>
<li><a href="../de418695/index.html">Anti-Piraterie-Kriege - Das Imperium schl√§gt zur√ºck</a></li>
<li><a href="../de418701/index.html">Wir studieren syntaktische Parser f√ºr die russische Sprache</a></li>
<li><a href="../de418705/index.html">Futex-Grundlagen</a></li>
<li><a href="../de418709/index.html">M√ºssen Sie sich zwingen: Treiber und Schnittstellenbarrieren</a></li>
<li><a href="../de418711/index.html">Token Managed Registers 1.0</a></li>
<li><a href="../de418713/index.html">Spiel zur Verbesserung der Qualit√§t von Wikipedia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>