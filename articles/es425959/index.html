<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¨ üçå üë©üèæ‚Äç‚öñÔ∏è Algunos consejos angulares ‚úãüèø üïµÔ∏è üöÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ha pasado suficiente tiempo desde el lanzamiento de Angular actualizado. Actualmente, se han completado muchos proyectos. Desde el "comienzo", muchos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algunos consejos angulares</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425959/"><p>  Ha pasado suficiente tiempo desde el lanzamiento de Angular actualizado.  Actualmente, se han completado muchos proyectos.  Desde el "comienzo", muchos desarrolladores ya se han movido al uso significativo de este marco, sus capacidades y han aprendido a sortear las trampas.  Cada desarrollador y / o equipo ya ha formado sus propias gu√≠as de estilo y mejores pr√°cticas, o utilizan otras.  Pero al mismo tiempo, a menudo tiene que lidiar con una gran cantidad de c√≥digo Angular, que no utiliza muchas de las caracter√≠sticas de este marco y / o est√° escrito al estilo de AngularJS. </p><br><p>  Este art√≠culo presenta algunas de las caracter√≠sticas y caracter√≠sticas del uso del marco angular, que, seg√∫n la modesta opini√≥n del autor, no est√°n cubiertos adecuadamente en los manuales o no son utilizados por los desarrolladores. <a name="habracut"></a>  El art√≠culo analiza el uso de solicitudes HTTP "Interceptores", el uso de Guardias de ruta para limitar el acceso a los usuarios.  Se dan algunas recomendaciones para usar RxJS y administrar el estado de la aplicaci√≥n.  Tambi√©n se presentan algunas recomendaciones sobre el dise√±o del c√≥digo del proyecto, lo que probablemente har√° que el c√≥digo del proyecto sea m√°s limpio y comprensible.  El autor espera que este art√≠culo sea √∫til no solo para desarrolladores que reci√©n est√°n comenzando a familiarizarse con Angular, sino tambi√©n para desarrolladores experimentados. </p><br><h2 id="rabota-s-http">  Trabajar con HTTP </h2><br><p>  La construcci√≥n de cualquier aplicaci√≥n web cliente se realiza alrededor de las solicitudes HTTP al servidor.  Esta parte discute algunas de las caracter√≠sticas del marco angular para trabajar con solicitudes HTTP. </p><br><h3 id="ispolzuem-interceptors">  Usando interceptores </h3><br><p>  En algunos casos, puede ser necesario modificar la solicitud antes de que llegue al servidor.  O necesita cambiar cada respuesta.  Comenzando con Angular 4.3, se ha lanzado un nuevo HttpClient.  Agreg√≥ la capacidad de interceptar una solicitud usando interceptores (¬°S√≠, finalmente fueron devueltos solo en la versi√≥n 4.3! Esta fue una de las caracter√≠sticas faltantes m√°s esperadas de AngularJs que no migr√≥ a Angular).  Este es un tipo de middleware entre la http-api y la solicitud real. </p><br><p>  Un caso de uso com√∫n puede ser la autenticaci√≥n.  Para obtener una respuesta del servidor, a menudo necesita agregar alg√∫n tipo de mecanismo de autenticaci√≥n a la solicitud.  Esta tarea utilizando interceptores se resuelve de manera bastante simple: </p><br><pre><code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> { Injectable } from "@angular/core";</span></span> <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> { Observable } from "rxjs/Observable";</span></span> <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from @angular/common/http";</span></span> @Injectable() export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JWTInterceptor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpInterceptor</span></span></span><span class="hljs-class"> </span></span>{ intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; { req = req.clone({ setHeaders: { authorization: localStorage.getItem(<span class="hljs-string"><span class="hljs-string">"token"</span></span>) } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next.handle(req); } }</code> </pre> <br><p>  Debido a que una aplicaci√≥n puede tener m√∫ltiples interceptores, est√°n organizados en una cadena.  El primer elemento es llamado por el propio marco angular.  Posteriormente, somos responsables de transmitir la solicitud al siguiente interceptor.  Para hacer esto, llamamos al m√©todo de manejo del siguiente elemento en la cadena tan pronto como terminemos.  Conectamos el interceptor: </p><br><pre> <code class="hljs powershell">import { BrowserModule } from <span class="hljs-string"><span class="hljs-string">"@angular/platform-browser"</span></span>; import { NgModule } from <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; import { AppComponent } from <span class="hljs-string"><span class="hljs-string">"./app.component"</span></span>; import { HttpClientModule } from <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; import { HTTP_INTERCEPTORS } from <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; @NgModule({ declarations: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>], imports: [<span class="hljs-type"><span class="hljs-type">BrowserModule</span></span>, <span class="hljs-type"><span class="hljs-type">HttpClientModule</span></span>], providers: [ { <span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">HTTP_INTERCEPTORS</span></span>, <span class="hljs-type"><span class="hljs-type">useClass</span></span>: <span class="hljs-type"><span class="hljs-type">JWTInterceptor</span></span>, <span class="hljs-type"><span class="hljs-type">multi</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span> } ], bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> {}</code> </pre> <br><p>  Como puede ver, la conexi√≥n e implementaci√≥n de interceptores es bastante simple. </p><br><h3 id="otslezhivanie-progressa">  Seguimiento del progreso </h3><br><p>  Una de las caracter√≠sticas de <code>HttpClient</code> es la capacidad de rastrear el progreso de una solicitud.  Por ejemplo, si necesita descargar un archivo grande, probablemente quiera informar al usuario sobre el progreso de la descarga.  Para obtener progreso, debe establecer la propiedad <code>HttpRequest</code> objeto <code>HttpRequest</code> en <code>true</code> .  Un ejemplo de un servicio que implementa este enfoque: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Observable"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpClient } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Injectable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpRequest } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Subject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Subject"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpEventType } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpResponse } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileUploadService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private http: HttpClient) {} public post(url: string, <span class="hljs-attr"><span class="hljs-attr">file</span></span>: File): Observable&lt;number&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject&lt;number&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpRequest(<span class="hljs-string"><span class="hljs-string">"POST"</span></span>, url, file, { <span class="hljs-attr"><span class="hljs-attr">reportProgress</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.request(req).subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.type === HttpEventType.UploadProgress) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> percent = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round((<span class="hljs-number"><span class="hljs-number">100</span></span> * event.loaded) / event.total); subject.next(percent); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HttpResponse) { subject.complete(); } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> subject.asObservable(); } }</code> </pre> <br><p>  El m√©todo de publicaci√≥n devuelve un <code>Observable</code> que representa el progreso de la descarga.  Todo lo que se necesita ahora es mostrar el progreso de carga en el componente. </p><br><h2 id="marshrutizaciya-ispolzuem-route-guard">  Enrutamiento  Usando Guardia de ruta </h2><br><p>  El enrutamiento le permite asignar solicitudes de aplicaciones a recursos espec√≠ficos dentro de la aplicaci√≥n.  Muy a menudo es necesario resolver el problema de limitar la visibilidad de la ruta a lo largo de la cual se ubican ciertos componentes, dependiendo de algunas condiciones.  En estos casos, Angular tiene un mecanismo de restricci√≥n de transici√≥n.  Como ejemplo, hay un servicio que implementar√° guardia de ruta.  Supongamos que en una aplicaci√≥n la autenticaci√≥n de usuario se implementa utilizando JWT.  Una versi√≥n simplificada del servicio que verifica si el usuario est√° autorizado puede representarse como: </p><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Injectable</span></span>() export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{ constructor(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> jwtHelper: JwtHelperService) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAuthenticated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> token = localStorage.getItem(<span class="hljs-string"><span class="hljs-string">"token"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//        return !this.jwtHelper.isTokenExpired(token); } }</span></span></code> </pre> <br><p>  Para implementar la protecci√≥n de ruta, debe implementar la interfaz <code>CanActivate</code> , que consiste en una sola funci√≥n <code>canActivate</code> . </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Injectable()</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthGuardService</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CanActivate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> auth: AuthService, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> router: Router) {} canActivate(): boolean { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.auth.isAuthenticated()) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.router.navigate([<span class="hljs-string"><span class="hljs-string">"login"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  La implementaci√≥n de <code>AuthGuardService</code> utiliza el <code>AuthGuardService</code> descrito anteriormente para verificar la autorizaci√≥n del usuario.  El m√©todo <code>canActivate</code> devuelve un valor booleano que se puede usar en la condici√≥n de activaci√≥n de ruta. </p><br><p>  Ahora podemos aplicar el protector de ruta creado a cualquier ruta o ruta.  Para hacer esto, al declarar <code>Routes</code> especificamos nuestro servicio, que hereda la interfaz <code>CanActivate</code> , en la secci√≥n <code>canActivate</code> : </p><br><pre> <code class="hljs powershell">export const ROUTES: Routes = [ { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-type"><span class="hljs-type">component</span></span>: <span class="hljs-type"><span class="hljs-type">HomeComponent</span></span> }, { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">"profile"</span></span>, <span class="hljs-type"><span class="hljs-type">component</span></span>: <span class="hljs-type"><span class="hljs-type">UserComponent</span></span>, <span class="hljs-type"><span class="hljs-type">canActivate</span></span>: [<span class="hljs-type"><span class="hljs-type">AuthGuardService</span></span>] }, { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">"**"</span></span>, <span class="hljs-type"><span class="hljs-type">redirectTo</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } ];</code> </pre> <br><p>  En este caso, la ruta <code>/profile</code> tiene el valor de configuraci√≥n opcional <code>canActivate</code> .  <code>AuthGuard</code> descrito anteriormente se pasa como un argumento a esta propiedad <code>canActivate</code> .  A continuaci√≥n, se <code>canActivate</code> m√©todo <code>canActivate</code> cada vez que alguien intente acceder a la ruta <code>/profile</code> .  Si el usuario est√° autorizado, obtendr√° acceso a la ruta <code>/profile</code> , de lo contrario ser√° redirigido a la ruta <code>/login</code> . </p><br><p>  Debe tener en cuenta que <code>canActivate</code> a√∫n le permite activar el componente en esta ruta, pero no le permite cambiar a √©l.  Si necesita proteger la activaci√≥n y carga del componente, entonces para este caso podemos usar <code>canLoad</code> .  <code>CanLoad</code> implementaci√≥n de <code>CanLoad</code> se puede hacer por analog√≠a. </p><br><h2 id="gotovim-rxjs">  Cocinar RxJS </h2><br><p>  Angular est√° construido sobre RxJS.  RxJS es una biblioteca para trabajar con flujos de datos as√≠ncronos y basados ‚Äã‚Äãen eventos utilizando secuencias observables.  RxJS es una implementaci√≥n de JavaScript de la API ReactiveX.  En su mayor parte, los errores que ocurren al trabajar con esta biblioteca est√°n asociados con un conocimiento superficial de los conceptos b√°sicos de su implementaci√≥n. </p><br><h3 id="ispolzuem-async-vmesto-podpisyvaniya-na-sobytiya">  Usar as√≠ncrono en lugar de suscribirse a eventos </h3><br><p>  Un gran n√∫mero de desarrolladores que recientemente han venido a usar el marco Angular usan la funci√≥n de <code>subscribe</code> de <code>Observable</code> para recibir y guardar datos en el componente: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"my-component"</span></span></span><span class="hljs-meta">, template: ` &lt;span&gt;{{localData.name}} : {{localData.value}}&lt;/span&gt;` })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{ localData; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(http: HttpClient) { http.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"api/data"</span></span>).subscribe(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.localData = <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; }); } }</code> </pre> <br><p>  En cambio, podemos suscribirnos a trav√©s de la plantilla usando una tuber√≠a as√≠ncrona: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"my-component"</span></span></span><span class="hljs-meta">, template: ` &lt;p&gt;{{data.name | async}} : {{data.value | async}}&lt;/p&gt;` })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(http: HttpClient) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = http.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"api/data"</span></span>); } }</code> </pre> <br><p>  Al suscribirse a trav√©s de una plantilla, evitamos p√©rdidas de memoria porque Angular cancela autom√°ticamente la suscripci√≥n de <code>Observable</code> cuando se rompe un componente.  En este caso, para las solicitudes HTTP, el uso de la tuber√≠a as√≠ncrona pr√°cticamente no proporciona ning√∫n beneficio, excepto por una cosa: la as√≠ncrona cancelar√° la solicitud si los datos ya no son necesarios y no completar√° el procesamiento de la solicitud. </p><br><p>  Muchas caracter√≠sticas de los <code>Observables</code> no se utilizan al suscribirse manualmente.  <code>Observables</code> comportamiento de los <code>Observables</code> se puede extender repitiendo (por ejemplo, reintentando en una solicitud http), actualizaci√≥n basada en temporizador o almacenamiento en cach√© previo. </p><br><h3 id="ispolzuem--dlya-oboznacheniya-observables">  Use <code>$</code> para denotar observables </h3><br><p>  El siguiente p√°rrafo est√° relacionado con el dise√±o de los c√≥digos fuente de la aplicaci√≥n y se deduce del p√°rrafo anterior.  Para distinguir las variables <code>Observable</code> de las simples, con frecuencia puede escuchar los consejos para usar el signo " <code>$</code> " en el nombre de una variable o campo.  Este simple truco eliminar√° la confusi√≥n en las variables cuando se usa as√≠ncrono. </p><br><pre> <code class="hljs cs">import { Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; import { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Rx"</span></span>; import { UserClient } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../services/user.client"</span></span>; import { User } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../services/user"</span></span>; @Component({ selector: <span class="hljs-string"><span class="hljs-string">"user-list"</span></span>, template: ` &lt;ul <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"user_list"</span></span> *ngIf=<span class="hljs-string"><span class="hljs-string">"(users$ | async).length"</span></span>&gt; &lt;li <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"user"</span></span> *ngFor=<span class="hljs-string"><span class="hljs-string">"let user of users$ | async"</span></span>&gt; {{ user.name }} - {{ user.birth_date }} &lt;/li&gt; &lt;/ul&gt;` }) export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">UserList</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> users$: Observable&lt;User[]&gt;; constructor(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> userClient: UserClient) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnInit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.users$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client.getUsers(); } }</code> </pre> <br><h3 id="kogda-nuzhno-otpisyvatsya-unsubscribe">  Cu√°ndo darse de baja (darse de baja) </h3><br><p>  La pregunta m√°s com√∫n que tiene un desarrollador cuando conoce brevemente Angular es cu√°ndo a√∫n necesita darse de baja y cu√°ndo no.  Para responder a esta pregunta, primero debe decidir qu√© tipo de <code>Observable</code> se est√° utilizando actualmente.  En Angular hay 2 tipos de <code>Observable</code> : finito e infinito, algunos producen un finito, otros, respectivamente, un n√∫mero infinito de valores. </p><br><p>  <code>Http</code> <code>Observable</code> es compacto, y los oyentes / oyentes de eventos DOM son <code>Observable</code> infinitos. </p><br><p>  Si la suscripci√≥n a los valores de un <code>Observable</code> infinito <code>Observable</code> realiza manualmente (sin utilizar una tuber√≠a as√≠ncrona), se debe responder sin fallar.  Si nos suscribimos manualmente a un Observable finito, entonces no es necesario darse de baja, RxJS se encargar√° de esto.  En el caso de los <code>Observables</code> compactos <code>Observables</code> podemos cancelar la suscripci√≥n si <code>Observable</code> tiene un tiempo de ejecuci√≥n m√°s largo de lo necesario, por ejemplo, una solicitud HTTP m√∫ltiple. </p><br><p>  Un ejemplo de <code>Observables</code> compactos: </p><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> http: HttpClient) { } ngOnInit() { Observable.timer(<span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"http://api.com"</span></span>).subscribe(...); } }</code> </pre> <br><p>  Ejemplo de observables infinitos </p><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> element : ElementRef) { } interval: Subscription; click: Subscription; ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.interval = Observable.interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.click = Observable.fromEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element.nativeElement, <span class="hljs-string"><span class="hljs-string">"click"</span></span>).subscribe(...); } ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.interval.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.click.unsubscribe(); } }</code> </pre> <br><p>  A continuaci√≥n, en m√°s detalle est√°n los casos en los que necesita darse de baja </p><br><ol><li>  Es necesario darse de baja del formulario y de los controles individuales a los que se ha suscrito: </li></ol><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form = new FormGroup({...}); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.valueChangesSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form.valueChanges.subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.statusChangesSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form.statusChanges.subscribe(...); } ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.valueChangesSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.statusChangesSubs.unsubscribe(); } }</code> </pre> <br><ol><li>  Enrutador  De acuerdo con la documentaci√≥n, Angular deber√≠a darse de baja, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sin embargo</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esto no sucede</a> .  Por lo tanto, para evitar m√°s problemas, escribimos nosotros mismos: </li></ol><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> route: ActivatedRoute, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> router: Router) { } ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.params.subscribe(..); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.queryParams.subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.fragment.subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.url.subscribe(..); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.router.events.subscribe(...); } ngOnDestroy() { <span class="hljs-comment"><span class="hljs-comment">//        observables } }</span></span></code> </pre> <br><ol><li>  Secuencias sin fin.  Los ejemplos son secuencias creadas usando <code>interva()</code> u oyentes de eventos <code>(fromEvent())</code> : </li></ol><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> element : ElementRef) { } interval: Subscription; click: Subscription; ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.intervalSubs = Observable.interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clickSubs = Observable.fromEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element.nativeElement, <span class="hljs-string"><span class="hljs-string">"click"</span></span>).subscribe(...); } ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.intervalSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clickSubs.unsubscribe(); } }</code> </pre> <br><h3 id="takeuntil-i-takewhile">  takeUntil y takeWhile </h3><br><p>  Para simplificar el trabajo con <code>Observables</code> infinitos en RxJS, hay dos funciones convenientes: <code>takeUntil</code> y <code>takeWhile</code> .  Realizan la misma acci√≥n: al darse de baja del <code>Observable</code> al final de alguna condici√≥n, la diferencia es solo en los valores aceptados.  <code>takeWhile</code> acepta un <code>boolean</code> y <code>takeUntil</code> un <code>Subject</code> . <br>  Ejemplo de <code>takeWhile</code> : </p><br><pre> <code class="hljs java">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnDestroy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> user: User; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> alive: <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userService .authenticate(email, password) .takeWhile(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.alive) .subscribe(user =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.user = user; }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.alive = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br><p>  En este caso, cuando se cambia la bandera <code>alive</code> , el <code>Observable</code> dar√° de baja.  En este ejemplo, cancele la suscripci√≥n cuando se destruye el componente. <br>  Ejemplo de <code>takeUntil</code> : </p><br><pre> <code class="hljs java">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnDestroy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> user: User; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unsubscribe: Subject&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userService.authenticate(email, password) .takeUntil(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribe) .subscribe(user =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.user = user; }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribe.next(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribe.complete(); } }</code> </pre> <br><p>  En este caso, para darse de baja de <code>Observable</code> informamos que el <code>subject</code> toma el siguiente valor y lo completa. </p><br><p>  El uso de estas funciones evitar√° fugas y simplificar√° el trabajo al darse de baja de los datos.  ¬øQu√© funci√≥n usar?  La respuesta a esta pregunta debe guiarse por las preferencias personales y los requisitos actuales. </p><br><h2 id="upravlenie-sostoyaniem-v-angular-prilozheniyah-ngrxstore">  Gesti√≥n de estado en aplicaciones angulares, @ ngrx / store </h2><br><p>  Muy a menudo, al desarrollar aplicaciones complejas, nos enfrentamos a la necesidad de almacenar el estado y responder a sus cambios.  Existen muchas bibliotecas para aplicaciones desarrolladas en el marco ReactJs que le permiten controlar el estado de la aplicaci√≥n y responder a sus cambios: Flux, Redux, Redux-saga, etc.  Para aplicaciones angulares, hay un contenedor de estado basado en RxJS inspirado en Redux - @ ngrx / store.  La gesti√≥n adecuada del estado de la aplicaci√≥n salvar√° al desarrollador de muchos problemas con la expansi√≥n adicional de la aplicaci√≥n. </p><br><p>  Por que Redux <br>  Redux se posiciona como un contenedor de estado predecible para aplicaciones JavaScript.  Redux est√° inspirado en Flux y Elm. </p><br><p>  Redux sugiere pensar en la aplicaci√≥n como un estado inicial modificable por una secuencia de acciones, que puede ser un buen enfoque para crear aplicaciones web complejas. </p><br><p>  Redux no est√° asociado con ning√∫n marco espec√≠fico, y aunque fue desarrollado para React, puede usarse con Angular o jQuery. </p><br><p>  Los principales postulados de Redux: </p><br><ul><li>  un repositorio para todo el estado de la aplicaci√≥n </li><li>  estado de solo lectura </li><li>  los cambios se realizan mediante funciones "puras", que est√°n sujetas a los siguientes requisitos: </li><li>  no debe hacer llamadas externas a trav√©s de una red o base de datos; </li><li>  devuelve un valor que depende solo de los par√°metros pasados; </li><li>  los argumentos son inmutables, es decir  las funciones no deber√≠an cambiarlos; </li><li>  llamar a una funci√≥n pura con los mismos argumentos siempre devuelve el mismo resultado; </li></ul><br><p>  Un ejemplo de una funci√≥n de gesti√≥n del estado: </p><br><pre> <code class="hljs julia">// counter.ts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ActionReducer, Action } from <span class="hljs-string"><span class="hljs-string">"@ngrx/store"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> INCREMENT = <span class="hljs-string"><span class="hljs-string">"INCREMENT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DECREMENT = <span class="hljs-string"><span class="hljs-string">"DECREMENT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RESET = <span class="hljs-string"><span class="hljs-string">"RESET"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> counterReducer(state: number = <span class="hljs-number"><span class="hljs-number">0</span></span>, action: Action) { switch (action.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { case INCREMENT: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state + <span class="hljs-number"><span class="hljs-number">1</span></span>; case DECREMENT: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state - <span class="hljs-number"><span class="hljs-number">1</span></span>; case RESET: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre> <br><p>  El reductor se importa en el m√≥dulo principal de la aplicaci√≥n y, mediante la funci√≥n <code>StoreModule.provideStore(reducers)</code> , lo ponemos a disposici√≥n del inyector angular: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> app.<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.ts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { StoreModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@ngrx/store"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { counterReducer } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./counter"</span></span>; @NgModule({ imports: [ BrowserModule, StoreModule.provideStore({ counter: counterReducer }) ] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span><span class="hljs-class"> { }</span></span></code> </pre> <br><p>  A continuaci√≥n, se introduce el servicio de la <code>Store</code> en los componentes y servicios necesarios.  La funci√≥n store.select () se utiliza para seleccionar el estado "sector": </p><br><pre> <code class="hljs django"><span class="xml"><span class="xml">// app.component.ts ... interface AppState { counter: number; } @Component({ selector: "my-app", template: ` </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span></span><span class="xml"><span class="hljs-tag">)=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"increment()"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Increment</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Current Count: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ counter | async }}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span></span><span class="xml"><span class="hljs-tag">)=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"decrement()"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Decrement</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span></span><span class="xml"><span class="hljs-tag">)=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"reset()"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Reset Counter</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">` }) class AppComponent { counter: Observable</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">number</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">; constructor(private store: Store</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">AppState</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) { this.counter = store.select("counter"); } increment() { this.store.dispatch({ type: INCREMENT }); } decrement() { this.store.dispatch({ type: DECREMENT }); } reset() { this.store.dispatch({ type: RESET }); } }</span></span></code> </pre> <br><h3 id="ngrxrouter-store">  @ ngrx / router-store </h3><br><p>  En algunos casos, es conveniente asociar el estado de la aplicaci√≥n con la ruta actual de la aplicaci√≥n.  Para estos casos, existe el m√≥dulo @ ngrx / router-store.  Para que la aplicaci√≥n use el <code>router-store</code> para guardar el estado, simplemente conecte <code>routerReducer</code> y agregue una llamada a <code>RouterStoreModule.connectRoute</code> en el m√≥dulo de aplicaci√≥n principal: </p><br><pre> <code class="hljs powershell">import { StoreModule } from <span class="hljs-string"><span class="hljs-string">"@ngrx/store"</span></span>; import { routerReducer, RouterStoreModule } from <span class="hljs-string"><span class="hljs-string">"@ngrx/router-store"</span></span>; @NgModule({ imports: [ <span class="hljs-type"><span class="hljs-type">BrowserModule</span></span>, <span class="hljs-type"><span class="hljs-type">StoreModule.provideStore</span></span>({ <span class="hljs-type"><span class="hljs-type">router</span></span>: <span class="hljs-type"><span class="hljs-type">routerReducer</span></span> }), <span class="hljs-type"><span class="hljs-type">RouterStoreModule.connectRouter</span></span>() ], bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <br><p>  Ahora agregue el <code>RouterState</code> al estado principal de la aplicaci√≥n: </p><br><pre> <code class="hljs cs">import { RouterState } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@ngrx/router-store"</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">AppState</span></span> { ... router: RouterState; };</code> </pre> <br><p>  Adem√°s, podemos indicar el estado inicial de la aplicaci√≥n al declarar tienda: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">StoreModule</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.provideStore</span></span>( { <span class="hljs-attribute"><span class="hljs-attribute">router</span></span>: routerReducer }, { <span class="hljs-attribute"><span class="hljs-attribute">router</span></span>: { path: window.location.pathname + window.location.search } } );</code> </pre> <br><p>  Acciones admitidas: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { go, replace, <span class="hljs-keyword"><span class="hljs-keyword">search</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">show</span></span>, back, forward } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "@ngrx/router-store"; //      store.dispatch(go(["/path", { routeParam: <span class="hljs-number"><span class="hljs-number">1</span></span> }], { query: "string" })); //        store.dispatch(replace(["/path"], { query: "string" })); //        store.dispatch(<span class="hljs-keyword"><span class="hljs-keyword">show</span></span>(["/path"], { query: "string" })); //       store.dispatch(<span class="hljs-keyword"><span class="hljs-keyword">search</span></span>({ query: "string" })); //   store.dispatch(back()); //   store.dispatch(forward());</code> </pre> <br><p>  UPD: El comentario sugiri√≥ que estas acciones no estar√°n disponibles en la nueva versi√≥n @ngrx, para la nueva versi√≥n <a href="">https://github.com/ngrx/platform/blob/master/MIGRATION.md#ngrxrouter-store</a> </p><br><p>  El uso del contenedor de estado eliminar√° muchos problemas al desarrollar aplicaciones complejas.  Sin embargo, es importante hacer que la gesti√≥n del estado sea lo m√°s simple posible.  Muy a menudo, uno tiene que lidiar con aplicaciones en las que hay un anidamiento excesivo de estados, lo que solo complica la comprensi√≥n de la aplicaci√≥n. </p><br><h2 id="organizaciya-koda">  Organizaci√≥n del c√≥digo </h2><br><h3 id="izbavlyaemsya-ot-gromozdkih-vyrazheniy-v-import">  Deshacerse de las expresiones voluminosas en la <code>import</code> </h3><br><p>  Muchos desarrolladores son conscientes de una situaci√≥n en la que las expresiones en la <code>import</code> bastante engorrosas.  Esto es especialmente notable en aplicaciones grandes donde hay muchas bibliotecas reutilizables. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SomeService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "../../../core/subpackage1/subpackage2/some.service";</code> </pre> <br><p>  ¬øQu√© m√°s hay de malo en este c√≥digo?  En caso de que necesite transferir nuestro componente a otro directorio, las expresiones en <code>import</code> no ser√°n v√°lidas. </p><br><p>  En este caso, el uso de alias nos permitir√° alejarnos de las expresiones voluminosas en la <code>import</code> y hacer que nuestro c√≥digo sea mucho m√°s limpio.  Para preparar el proyecto para usar alias, debe agregar las propiedades baseUrl y path en <code>tsconfig.json</code> : </p><br><pre> <code class="hljs perl">/ tsconfig.json { <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { ... <span class="hljs-string"><span class="hljs-string">"baseUrl"</span></span>: <span class="hljs-string"><span class="hljs-string">"src"</span></span>, <span class="hljs-string"><span class="hljs-string">"paths"</span></span>: { <span class="hljs-string"><span class="hljs-string">"@app/*"</span></span>: [<span class="hljs-string"><span class="hljs-string">"app/*"</span></span>], <span class="hljs-string"><span class="hljs-string">"@env/*"</span></span>: [<span class="hljs-string"><span class="hljs-string">"environments/*"</span></span>] } } }</code> </pre> <br><p>  Con estos cambios, es bastante f√°cil administrar complementos: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Component, OnInit } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Observable"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SomeService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@app/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { environment } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@env/environment"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LocalService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./local.service"</span></span>; @Component({ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExampleComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( private someService: SomeService, private localService: LocalService ) { } }</code> </pre> <br><p>  En este ejemplo, <code>SomeService</code> importa directamente desde <code>@app/core</code> lugar de una expresi√≥n voluminosa (por ejemplo, <code>@app/core/some-package/some.service</code> ).  Esto es posible gracias a la reexportaci√≥n de componentes p√∫blicos en el archivo <code>index.ts</code> principal.  Es recomendable crear un archivo <code>index.ts</code> para cada paquete en el que necesite reexportar todos los m√≥dulos p√∫blicos: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> index.ts <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./core.module"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./auth/auth.service"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./user/user.service"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./some-service/some.service"</span></span>;</code> </pre> <br><h3 id="core-shared-i-feature-moduli">  M√≥dulos principales, compartidos y de funciones </h3><br><p>  Para una gesti√≥n m√°s flexible de los componentes de la aplicaci√≥n, a menudo se recomienda en la literatura y varios recursos de Internet para difundir la visibilidad de sus componentes.  En este caso, la administraci√≥n de los componentes de la aplicaci√≥n se simplifica.  La siguiente separaci√≥n se usa m√°s com√∫nmente: m√≥dulos principales, compartidos y de funciones. </p><br><h4 id="coremodule">  Coremodule </h4><br><p>  El objetivo principal de CoreModule es describir los servicios que tendr√°n una instancia para toda la aplicaci√≥n (es decir, implementar el patr√≥n singleton).  Estos a menudo incluyen un servicio de autorizaci√≥n o un servicio para obtener informaci√≥n del usuario.  Ejemplo de CoreModule: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule, Optional, SkipSelf } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { CommonModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpClientModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SomeSingletonService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./some-singleton/some-singleton.service"</span></span>; @NgModule({ <span class="hljs-attr"><span class="hljs-attr">imports</span></span>: [CommonModule, HttpClientModule], <span class="hljs-attr"><span class="hljs-attr">declarations</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">providers</span></span>: [SomeSingletonService] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoreModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   CoreModule    NgModule the AppModule */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( @Optional() @SkipSelf() parentModule: CoreModule ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentModule) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"CoreModule is already loaded. Import only in AppModule"</span></span>); } } }</code> </pre> <br><h4 id="sharedmodule">  M√≥dulo compartido </h4><br><p>  Este m√≥dulo describe componentes simples.  Estos componentes no importan ni inyectan dependencias de otros m√≥dulos en sus constructores.  Deben recibir todos los datos a trav√©s de los atributos en la plantilla del componente.  <code>SharedModule</code> no depende del resto de nuestra aplicaci√≥n, tambi√©n es un lugar ideal para importar y reexportar componentes de material angular u otras bibliotecas de interfaz de usuario. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { CommonModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { FormsModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/forms"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { MdButtonModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/material"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SomeCustomComponent } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./some-custom/some-custom.component"</span></span>; @NgModule({ <span class="hljs-attr"><span class="hljs-attr">imports</span></span>: [CommonModule, FormsModule, MdButtonModule], <span class="hljs-attr"><span class="hljs-attr">declarations</span></span>: [SomeCustomComponent], <span class="hljs-attr"><span class="hljs-attr">exports</span></span>: [ <span class="hljs-comment"><span class="hljs-comment">/*  Angular Material*/</span></span> CommonModule, FormsModule, MdButtonModule, <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> SomeCustomComponent ] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SharedModule</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><h4 id="featuremodule">  M√≥dulo de funciones </h4><br><p>  Aqu√≠ puede repetir la gu√≠a de estilo angular.  Se crea un FeatureModule separado para cada funci√≥n de aplicaci√≥n independiente.  FeatureModule debe importar servicios solo desde <code>CoreModule</code> .  Si alg√∫n m√≥dulo necesitaba importar un servicio desde otro m√≥dulo, es posible que este servicio se mueva a <code>CoreModule</code> . </p><br><p>  En algunos casos, es necesario usar el servicio solo por algunos m√≥dulos y no es necesario exportarlo a <code>CoreModule</code> .  En este caso, puede crear un <code>SharedModule</code> especial, que se usar√° solo en estos m√≥dulos. <br>  ,     ‚Äî   ,     -  ,    ,  <code>CoreModule</code>  ,  <code>SharedModule</code> . </p><br><p>        ,     .    ,   .    ,   ,             . </p><br><h3 id="spisok-literatury">  Referencias </h3><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ngrx/store</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://stepansuvorov.com/blog/2017/06/angular-rxjs-unsubscribe-or-not-unsubscribe/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://medium.com/@tomastrajan/6-best-practices-pro-tips-for-angular-cli-better-developer-experience-7b328bc9db81</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://habr.com/post/336280/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://angular.io/docs</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425959/">https://habr.com/ru/post/es425959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425947/index.html">Ratatouille corporativo</a></li>
<li><a href="../es425951/index.html">C√≥mo piratearon blockchain y criptomonedas: 6 ataques exitosos "51 por ciento"</a></li>
<li><a href="../es425953/index.html">Estaci√≥n meteorol√≥gica en Arduino de la A a la Z. Parte 3</a></li>
<li><a href="../es425955/index.html">8 interesantes errores beta de iOS 12 y c√≥mo los buscamos</a></li>
<li><a href="../es425957/index.html">Bicicletas de gas o b√∫squedas de productos extra√±os (comercio electr√≥nico)</a></li>
<li><a href="../es425961/index.html">"Aprender la primavera es una lecci√≥n sin sentido" - Josh Long, el principal evangelista de Spring en la cocina interior del proyecto</a></li>
<li><a href="../es425963/index.html">Estaci√≥n meteorol√≥gica en Arduino de la A a la Z. Parte 4</a></li>
<li><a href="../es425965/index.html">SAP Data Management Suite como un complejo para trabajar con Big Data en empresas</a></li>
<li><a href="../es425967/index.html">Motosierra Masacre de silicio</a></li>
<li><a href="../es425969/index.html">¬øC√≥mo me convertir√© en desarrollador web ... y lo har√©?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>