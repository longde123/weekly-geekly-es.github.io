<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüéì üßôüèø üßóüèº Escrevendo sua camada de rede no Swift: abordagem orientada a protocolo üëçüèΩ üîä üèà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Agora, quase 100% dos aplicativos usam redes, para que todos se deparem com a organiza√ß√£o e o uso da camada de rede. Existem duas abordagens principai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escrevendo sua camada de rede no Swift: abordagem orientada a protocolo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443514/"><img src="https://habrastorage.org/webt/gg/rb/pk/ggrbpkas55pf0eigg33hin46i0g.png"><br><br>  Agora, quase 100% dos aplicativos usam redes, para que todos se deparem com a organiza√ß√£o e o uso da camada de rede.  Existem duas abordagens principais para solucionar esse problema: o uso de bibliotecas de terceiros ou a sua pr√≥pria implementa√ß√£o da camada de rede.  Neste artigo, consideraremos a segunda op√ß√£o e tentaremos implementar uma camada de rede usando todos os recursos mais recentes da linguagem, usando protocolos e enumera√ß√µes.  Isso salvar√° o projeto de depend√™ncias desnecess√°rias na forma de bibliotecas adicionais.  Aqueles que j√° viram Moya reconhecer√£o imediatamente muitos detalhes semelhantes na implementa√ß√£o e uso, do jeito que s√£o, s√≥ que desta vez faremos sozinhos sem tocar em Moya e Alamofire. <br><a name="habracut"></a><br><br>  Neste guia, veremos como implementar uma camada de rede no Swift puro, sem usar bibliotecas de terceiros.  Depois de revisar este artigo, seu c√≥digo se tornar√° <br><br><ul><li>  protocolo orientado </li><li>  f√°cil de usar </li><li>  f√°cil de usar </li><li>  tipo seguro </li><li>  para endpoints enums ser√£o usados </li></ul><br><br>  Abaixo est√° um exemplo de como o uso da nossa camada de rede cuidar√° de sua implementa√ß√£o: <br><br><img src="https://habrastorage.org/webt/zg/f5/jy/zgf5jybl_jika5ljlt-h3pcdg1e.png"><br><br>  Simplesmente escrevendo <i><b>router.request (.</b></i> E usando todo o poder das enumera√ß√µes, veremos todas as op√ß√µes de consulta poss√≠veis e seus par√¢metros. <br><br>  <b>Primeiro, um pouco sobre a estrutura do projeto</b> <br><br>  Sempre que voc√™ cria algo novo, e para poder entender tudo facilmente no futuro, √© muito importante organizar e estruturar tudo corretamente.  Acredito que uma estrutura de pastas organizada adequadamente √© um detalhe importante ao construir a arquitetura do aplicativo.  Para que possamos organizar tudo corretamente em pastas, vamos cri√°-las antecipadamente.  Isso se parecer√° com a estrutura geral de pastas no projeto: <br><br><img src="https://habrastorage.org/webt/vw/fz/y0/vwfzy0nlpqmg6mccy85s2q6iqrg.png"><br><br>  <b>Protocolo do tipo de ponto final</b> <br><br>  Primeiro de tudo, precisamos definir nosso protocolo <i><b>EndPointType</b></i> .  Este protocolo conter√° todas as informa√ß√µes necess√°rias para configurar a solicita√ß√£o.  O que √© uma solicita√ß√£o (ponto de extremidade)?  Em ess√™ncia, √© um URLRequest com todos os componentes relacionados, como cabe√ßalhos, par√¢metros de solicita√ß√£o, corpo da solicita√ß√£o.  O protocolo <i><b>EndPointType</b></i> √© a parte mais importante da nossa implementa√ß√£o da camada de rede.  Vamos criar um arquivo e <i><b>denomine</b></i> -o <i><b>EndPointType</b></i> .  Coloque esse arquivo na pasta Servi√ßo (n√£o na pasta EndPoint, por qu√™ - ficar√° claro mais tarde) <br><br><img src="https://habrastorage.org/webt/-9/j0/ul/-9j0ulvgk-w_hftxxyqwolmbujy.png"><br><br>  <b>Protocolos HTTP</b> <br><br>  Nosso <i><b>EndPointType</b></i> cont√©m v√°rios protocolos que precisamos para criar uma solicita√ß√£o.  Vamos ver o que s√£o esses protocolos. <br><br>  <b>HTTPMethod</b> <br><br>  Crie um arquivo, nomeie-o <i><b>HTTPMethod</b></i> e coloque-o na pasta Servi√ßo.  Esta listagem ser√° usada para definir o m√©todo HTTP de nossa solicita√ß√£o. <br><br><img src="https://habrastorage.org/webt/j2/3x/nr/j23xnrcovqknw9dzxhf-xva898q.png"><br><br>  <b>HTTPTask</b> <br>  Crie um arquivo, <i><b>chame</b></i> -o de <i><b>HTTPTask</b></i> e coloque-o na pasta Servi√ßo.  HTTPTask √© respons√°vel por configurar os par√¢metros de uma solicita√ß√£o espec√≠fica.  Voc√™ pode adicionar quantas op√ß√µes de consulta diferentes forem necess√°rias, mas eu, por sua vez, vou fazer consultas regulares, consultas com par√¢metros, consultas com par√¢metros e cabe√ßalhos, portanto, somente esses tr√™s tipos de consulta ser√£o feitos. <br><br><img src="https://habrastorage.org/webt/v5/4m/j6/v54mj6yxsvdwuiossyq3em2biia.png"><br><br>  Na pr√≥xima se√ß√£o, discutiremos os <i><b>par√¢metros</b></i> e como trabalharemos com eles <br><br>  <b>HTTPHeaders</b> <br><br>  <i><b>Os HTTPHeaders</b></i> s√£o apenas tipos de letra para um dicion√°rio.  Voc√™ pode cri√°-lo na parte superior do seu arquivo <i><b>HTTPTask</b></i> . <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">HTTPHeaders</span></span> = [<span class="hljs-type"><span class="hljs-type">String</span></span>:<span class="hljs-type"><span class="hljs-type">String</span></span>]</code> </pre> <br><br>  <b>Par√¢metros e codifica√ß√£o</b> <br><br>  Crie um arquivo, nomeie-o como <i><b>ParameterEncoding</b></i> e coloque-o na pasta Encoding.  Crie typealias para <i><b>Parameters</b></i> , ser√° novamente um dicion√°rio regular.  Fazemos isso para tornar o c√≥digo mais compreens√≠vel e leg√≠vel. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Parameters</span></span> = [<span class="hljs-type"><span class="hljs-type">String</span></span>:<span class="hljs-type"><span class="hljs-type">Any</span></span>]</code> </pre> <br><br>  Em seguida, defina um protocolo <i><b>ParameterEncoder</b></i> com uma √∫nica fun√ß√£o de codifica√ß√£o.  O m√©todo de codifica√ß√£o possui dois par√¢metros: <i><b>inout URLRequest</b></i> e <i><b>Parameters</b></i> .  <b>INOUT</b> √© uma palavra-chave Swift que define um par√¢metro de fun√ß√£o como uma refer√™ncia.  Normalmente, os par√¢metros s√£o passados ‚Äã‚Äãpara a fun√ß√£o como valores.  Ao escrever <i><b>inout</b></i> antes de um par√¢metro de fun√ß√£o em uma chamada, voc√™ define esse par√¢metro como um tipo de refer√™ncia.  Para saber mais sobre argumentos inout, voc√™ pode seguir este link.  Em resumo, <i><b>inout</b></i> permite alterar o valor da vari√°vel em si, que foi passada para a fun√ß√£o, e n√£o apenas obter seu valor no par√¢metro e trabalhar com ele dentro da fun√ß√£o.  O protocolo <i><b>ParameterEncoder</b></i> ser√° implementado no <i><b>JSONParameterEncoder</b></i> e no <i><b>URLPameterEncoder</b></i> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParameterEncoder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(urlRequest: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">inout</span></span></span></span><span class="hljs-function"><span class="hljs-params"> URLRequest, with parameters: Parameters)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> }</code> </pre> <br><br>  <i><b>ParameterEncoder</b></i> cont√©m uma √∫nica fun√ß√£o cuja tarefa √© codificar par√¢metros.  Esse m√©todo pode gerar um erro que precisa ser tratado, ent√£o usamos o throw. <br><br>  Tamb√©m pode ser √∫til produzir erros n√£o padr√£o, mas personalizados.  √â sempre muito dif√≠cil descriptografar o que o Xcode oferece a voc√™.  Quando voc√™ tem todos os erros personalizados e descritos, sempre sabe exatamente o que aconteceu.  Para fazer isso, vamos definir uma enumera√ß√£o que herda de <i><b>Error</b></i> . <br><br><img src="https://habrastorage.org/webt/tl/bj/dd/tlbjddm7l48ho1alexej8rrj15q.png"><br><br>  Crie um arquivo, nomeie-o como <i><b>URLParameterEncoder</b></i> e coloque-o na pasta <i><b>Encoding</b></i> . <br><br><img src="https://habrastorage.org/webt/s-/eh/tg/s-ehtgdznm1pcdjyrhn3r4fibjs.png"><br><br>  Este c√≥digo pega uma lista de par√¢metros, converte e formata-os para uso como par√¢metros de URL.  Como voc√™ sabe, alguns caracteres n√£o s√£o permitidos no URL.  Os par√¢metros tamb√©m s√£o separados pelo s√≠mbolo "&amp;", portanto, devemos cuidar disso.  Tamb√©m devemos definir o valor padr√£o para os cabe√ßalhos se eles n√£o estiverem definidos na solicita√ß√£o. <br><br>  Essa √© a parte do c√≥digo que deve ser coberta por testes de unidade.  Construir uma solicita√ß√£o de URL √© a chave, caso contr√°rio, podemos provocar muitos erros desnecess√°rios.  Se voc√™ usa a API aberta, obviamente n√£o deseja usar todo o volume poss√≠vel de solicita√ß√µes para testes com falha.  Se voc√™ quiser saber mais sobre testes de unidade, comece com este artigo. <br><br>  <b>JSONParameterEncoder</b> <br><br>  Crie um arquivo, <i><b>denomine JSONParameterEncoder</b></i> e coloque-o na pasta Encoding. <br><br><img src="https://habrastorage.org/webt/qf/nc/gp/qfncgpv0juhwx6xnvn4llxqv0eu.png"><br><br>  Tudo √© o mesmo que no caso de <i><b>URLParameter</b></i> , apenas aqui vamos converter os par√¢metros para JSON e adicionar novamente os par√¢metros que definem a codifica√ß√£o "application / json" ao cabe√ßalho. <br><br>  <b>Networkrouter</b> <br><br>  Crie um arquivo, nomeie-o <i><b>NetworkRouter</b></i> e coloque-o na pasta Servi√ßo.  Vamos come√ßar definindo tipealias para o fechamento. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">NetworkRouterCompletion</span></span> = (<span class="hljs-number"><span class="hljs-number">_</span></span> data: <span class="hljs-type"><span class="hljs-type">Data?</span></span>,<span class="hljs-number"><span class="hljs-number">_</span></span> response: <span class="hljs-type"><span class="hljs-type">URLResponse?</span></span>,<span class="hljs-number"><span class="hljs-number">_</span></span> error: <span class="hljs-type"><span class="hljs-type">Error?</span></span>)-&gt;()</code> </pre><br><br>  Em seguida, definimos o protocolo <i><b>NetworkRouter</b></i> . <br><br><img src="https://habrastorage.org/webt/uf/zd/s0/ufzds0f3ci0fvx9mr0hingvxjtc.png"><br><br>  <i><b>O NetworkRouter</b></i> possui um <i><b>EndPoint</b></i> que ele usa para solicita√ß√µes e, assim que a solicita√ß√£o √© conclu√≠da, o resultado dessa solicita√ß√£o √© passado para o fechamento do <i><b>NetworkRouterCompletion</b></i> .  O protocolo tamb√©m possui uma fun√ß√£o de <i><b>cancelamento</b></i> , que pode ser usada para interromper solicita√ß√µes de carga e descarga de longo prazo.  Tamb√©m usamos o tipo <i><b>associado</b></i> aqui, porque queremos que o nosso <i><b>roteador</b></i> suporte qualquer tipo de <i><b>EndPointType</b></i> .  Sem usar o tipo associado, o roteador precisaria ter algum tipo espec√≠fico que implemente <i><b>EndPointType</b></i> .  Se voc√™ quiser saber mais sobre o tipo associado, leia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este artigo</a> . <br><br>  <b>Roteador</b> <br><br>  Crie um arquivo, chame-o de <i><b>roteador</b></i> e coloque-o na pasta Servi√ßo.  Declaramos uma vari√°vel privada do tipo <i><b>URLSessionTask</b></i> .  Todo o trabalho estar√° nele.  Tornamos privado, porque n√£o queremos que ningu√©m de fora possa alter√°-lo. <br><br><img src="https://habrastorage.org/webt/gb/wk/cx/gbwkcxouam1y86i-sruvzyhub_c.png"><br><br>  <b>Pedido</b> <br><br>  Aqui criamos o <i><b>URLSession</b></i> usando o <i><b>URLSession.shared</b></i> , esta √© a maneira mais f√°cil de criar.  Mas lembre-se de que esse m√©todo n√£o √© o √∫nico.  Voc√™ pode usar configura√ß√µes de <i><b>URLSession</b></i> mais complexas que podem alterar seu comportamento.  Mais sobre isso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste artigo</a> . <br><br>  A solicita√ß√£o √© criada chamando a fun√ß√£o <i>buildRequest.A</i> chamada de fun√ß√£o √© <i>agrupada</i> em do-try-catch, porque as fun√ß√µes de codifica√ß√£o dentro de <i>buildRequest</i> podem <i>gerar</i> exce√ß√µes.  <i>Resposta</i> , <i>dados</i> e <i>erro</i> s√£o passados ‚Äã‚Äãpara conclus√£o. <br><br><img src="https://habrastorage.org/webt/oi/3c/jl/oi3cjllxhvs7n_m39kmy9r7q29k.png"><br><br>  <b>Pedido de compila√ß√£o</b> <br><br>  Criamos nossa solicita√ß√£o usando a fun√ß√£o <i>buildRequest</i> .  Essa fun√ß√£o √© respons√°vel por todo o trabalho vital em nossa camada de rede.  Converte essencialmente <i><b>EndPointType</b></i> em <i><b>URLRequest</b></i> .  E assim que o <i><b>EndPoint se</b></i> transformar em uma solicita√ß√£o, podemos passar para a <i><b>sess√£o</b></i> .  Muitas coisas est√£o acontecendo aqui, ent√£o vamos dar uma olhada nos m√©todos.  Primeiro, <i>vamos</i> examinar o m√©todo <i>buildRequest</i> : <br><br>  1. Inicializamos a vari√°vel de solicita√ß√£o <i><b>URLRequest</b></i> .  Definimos nosso URL base e adicionamos o caminho da solicita√ß√£o espec√≠fica que ser√° usada para ele. <br><br>  2. Atribua <i>request.httpMethod o</i> m√©todo http do nosso <i><b>EndPoint</b></i> . <br><br>  3. Criamos um bloco do-try-catch, porque nossos codificadores podem gerar um erro.  Ao criar um grande bloco do-try-catch, eliminamos a necessidade de criar um bloco separado para cada tentativa. <br><br>  4. No switch, verifique <i><b>route.task</b></i> . <br><br>  5. Dependendo do tipo de tarefa, chamamos o codificador correspondente. <br><br><img src="https://habrastorage.org/webt/pt/ij/58/ptij58jibcjvvawtyb44axo5mq4.png"><br><br>  <b>Configurar par√¢metros</b> <br><br>  Crie a fun√ß√£o <i><b>configureParameters</b></i> no roteador. <br><br><img src="https://habrastorage.org/webt/fb/gf/fy/fbgffycewgssxqrnxglvsvftl0w.png"><br><br>  Essa fun√ß√£o √© respons√°vel por converter nossos par√¢metros de consulta.  Como nossa API assume o uso de <i><b>bodyParameters</b></i> na forma de JSON e <i><b>URLParameters</b></i> convertidos para o formato de URL, simplesmente passamos os par√¢metros apropriados para as fun√ß√µes de convers√£o correspondentes, descritas no come√ßo do artigo.  Se voc√™ usar uma API que inclua v√°rios tipos de codifica√ß√µes, nesse caso, eu recomendaria adicionar <i><b>HTTPTask com</b></i> uma enumera√ß√£o adicional com o tipo de codifica√ß√£o.  Esta listagem deve conter todos os tipos poss√≠veis de codifica√ß√µes.  Depois disso, em configureParameters, adicione mais um argumento com essa enumera√ß√£o.  Dependendo do seu valor, alterne usando switch e fa√ßa a codifica√ß√£o necess√°ria. <br><br>  <b>Adicionar cabe√ßalhos adicionais</b> <br><br>  Crie a fun√ß√£o <i>addAdditionalHeaders</i> no roteador. <br><br><img src="https://habrastorage.org/webt/ow/07/8a/ow078aeoow6qlavpxiobwl6nbh0.png"><br><br>  Basta adicionar todos os cabe√ßalhos necess√°rios √† solicita√ß√£o. <br><br>  <b>Cancelar</b> <br><br>  A fun√ß√£o de <i>cancelamento</i> parecer√° bastante simples: <br><br><img src="https://habrastorage.org/webt/v4/3t/mm/v43tmm1dlso_cwstw6sy444vyu4.png"><br><br>  <b>Exemplo de uso</b> <br><br>  Agora vamos tentar usar nossa camada de rede em um exemplo real.  Vamos nos conectar ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TheMovieDB</a> para receber dados para o nosso aplicativo. <br><br>  <b>MovieEndPoint</b> <br><br>  Crie um arquivo <i><b>MovieEndPoint</b></i> e coloque-o na pasta EndPoint.  MovieEndPoint √© o mesmo que <br>  e TargetType em Moya.  Aqui, implementamos nosso pr√≥prio EndPointType.  Um artigo descrevendo como usar o Moya para um exemplo semelhante pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste link</a> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation enum NetworkEnvironment { case qa case production case staging } public enum MovieApi { case recommended(id:Int) case popular(page:Int) case newMovies(page:Int) case video(id:Int) } extension MovieApi: EndPointType { var environmentBaseURL : String { switch NetworkManager.environment { case .production: return "https:<span class="hljs-comment"><span class="hljs-comment">//api.themoviedb.org/3/movie/" case .qa: return "https://qa.themoviedb.org/3/movie/" case .staging: return "https://staging.themoviedb.org/3/movie/" } } var baseURL: URL { guard let url = URL(string: environmentBaseURL) else { fatalError("baseURL could not be configured.")} return url } var path: String { switch self { case .recommended(let id): return "\(id)/recommendations" case .popular: return "popular" case .newMovies: return "now_playing" case .video(let id): return "\(id)/videos" } } var httpMethod: HTTPMethod { return .get } var task: HTTPTask { switch self { case .newMovies(let page): return .requestParameters(bodyParameters: nil, urlParameters: ["page":page, "api_key":NetworkManager.MovieAPIKey]) default: return .request } } var headers: HTTPHeaders? { return nil } }</span></span></code> </pre><br><br>  <b>Moviemodel</b> <br><br>  Para analisar o modelo de dados <i><b>MovieModel</b></i> e JSON no modelo, o protocolo Decodable √© usado.  Coloque esse arquivo na pasta <i><b>Modelo</b></i> . <br><br>  <i>Nota</i> : para um conhecimento mais detalhado dos protocolos Codable, Decodable e Encodable, voc√™ pode ler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">meu outro artigo</a> , que descreve em detalhes todos os recursos de trabalhar com eles. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation struct MovieApiResponse { let page: Int let numberOfResults: Int let numberOfPages: Int let movies: [Movie] } extension MovieApiResponse: Decodable { private enum MovieApiResponseCodingKeys: String, CodingKey { case page case numberOfResults = "total_results" case numberOfPages = "total_pages" case movies = "results" } init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: MovieApiResponseCodingKeys.self) page = try container.decode(Int.self, forKey: .page) numberOfResults = try container.decode(Int.self, forKey: .numberOfResults) numberOfPages = try container.decode(Int.self, forKey: .numberOfPages) movies = try container.decode([Movie].self, forKey: .movies) } } struct Movie { let id: Int let posterPath: String let backdrop: String let title: String let releaseDate: String let rating: Double let overview: String } extension Movie: Decodable { enum MovieCodingKeys: String, CodingKey { case id case posterPath = "poster_path" case backdrop = "backdrop_path" case title case releaseDate = "release_date" case rating = "vote_average" case overview } init(from decoder: Decoder) throws { let movieContainer = try decoder.container(keyedBy: MovieCodingKeys.self) id = try movieContainer.decode(Int.self, forKey: .id) posterPath = try movieContainer.decode(String.self, forKey: .posterPath) backdrop = try movieContainer.decode(String.self, forKey: .backdrop) title = try movieContainer.decode(String.self, forKey: .title) releaseDate = try movieContainer.decode(String.self, forKey: .releaseDate) rating = try movieContainer.decode(Double.self, forKey: .rating) overview = try movieContainer.decode(String.self, forKey: .overview) } }</code> </pre><br><br>  <b>Gerente de rede</b> <br><br>  Crie um arquivo <i><b>NetworkManager</b></i> na pasta Manager.  No momento, o NetworkManager cont√©m apenas duas propriedades est√°ticas: uma chave de API e uma enumera√ß√£o que descreve o tipo de servidor ao qual se conectar.  <i><b>O NetworkManager</b></i> tamb√©m cont√©m um <i><b>roteador</b></i> do tipo <i><b>MovieApi</b></i> . <br><br><img src="https://habrastorage.org/webt/yj/it/-b/yjit-b1afnahwsvjkkjnaezgpdu.png"><br><br>  <b>Resposta de rede</b> <br><br>  Crie a enumera√ß√£o <i><b>NetworkResponse</b></i> no NetworkManager. <br><br><img src="https://habrastorage.org/webt/vv/fv/7s/vvfv7sl-q-dmnz289jdcntmhs0k.png"><br><br>  Usamos essa enumera√ß√£o ao processar respostas a solicita√ß√µes e exibiremos a mensagem correspondente. <br><br>  <b>Resultado</b> <br><br>  Crie uma enumera√ß√£o de <i><b>resultados</b></i> no NetworkManager. <br><br><img src="https://habrastorage.org/webt/en/oj/ad/enojad3e4jxk2jgkntgblqftivu.png"><br><br>  Usamos <i><b>Result</b></i> para determinar se a solicita√ß√£o foi bem-sucedida ou n√£o.  Caso contr√°rio, retornaremos uma mensagem de erro com o motivo. <br><br>  <b>Processamento de resposta de solicita√ß√£o</b> <br><br>  Crie a fun√ß√£o <i><b>handleNetworkResponse</b></i> .  Essa fun√ß√£o usa um argumento, como um <i><b>HTTPResponse,</b></i> e retorna Result. <br><br><img src="https://habrastorage.org/webt/wt/uv/5f/wtuv5f7cptiudu69o8mn16psbsy.png"><br><br>  Nesta fun√ß√£o, dependendo do statusCode recebido do HTTPResponse, retornamos uma mensagem de erro ou um sinal de uma solicita√ß√£o bem-sucedida.  Normalmente, um c√≥digo no intervalo de 200..299 significa sucesso. <br><br>  <b>Fazendo uma solicita√ß√£o de rede</b> <br><br>  Ent√£o, fizemos tudo para come√ßar a usar nossa camada de rede, vamos tentar fazer uma solicita√ß√£o. <br><br>  Solicitaremos uma lista de novos filmes.  Crie uma fun√ß√£o e <i><b>chame</b></i> -a de <i><b>getNewMovies</b></i> . <br><br><img src="https://habrastorage.org/webt/ei/yn/fn/eiynfnoketqomcziq5nzv6ulaao.png"><br><br>  Vamos dar um passo a passo: <br><br>  1. Definimos o m√©todo <i><b>getNewMovies</b></i> com dois argumentos: o n√∫mero da p√°gina de pagina√ß√£o e o manipulador de conclus√£o, que retorna uma matriz opcional de modelos de <i><b>filme</b></i> ou um erro opcional. <br><br>  2. Ligue para o <i><b>roteador</b></i> .  Passamos o n√∫mero da p√°gina e <i>conclu√≠mos o</i> processo no fechamento. <br><br>  3. <i><b>URLSession</b></i> retorna um erro se n√£o houver rede ou n√£o foi poss√≠vel fazer uma solicita√ß√£o por qualquer motivo.  Observe que este n√£o √© um erro de API; esses erros ocorrem no cliente e geralmente ocorrem devido √† baixa qualidade da conex√£o com a Internet. <br><br>  4. Precisamos transmitir nossa <i><b>resposta</b></i> ao <i><b>HTTPURLResponse</b></i> , porque precisamos acessar a propriedade <i>statusCode</i> . <br><br>  5. Declare o <i><b>resultado</b></i> e inicialize-o usando o m√©todo <i><b>handleNetworkResponse</b></i> <br><br>  6. <i><b>Sucesso</b></i> significa que a solicita√ß√£o foi bem-sucedida e recebemos a resposta esperada.  Depois, verificamos se os dados vieram com a resposta e, se n√£o, simplesmente terminamos o m√©todo por meio de retorno. <br><br>  7. Se a resposta vier com dados, √© necess√°rio analisar os dados recebidos no modelo.  Depois disso, passamos a matriz de modelos resultante para conclus√£o. <br><br>  8. Em caso de erro, basta passar o erro para <i>conclus√£o</i> . <br><br>  √â isso, √© assim que nossa pr√≥pria camada de rede funciona no Swift puro, sem usar nenhuma depend√™ncia na forma de pods e bibliotecas de terceiros.  Para fazer uma solicita√ß√£o de API de teste para obter uma lista de filmes, crie um MainViewController com a propriedade <i><b>NetworkManager</b></i> e chame o m√©todo <i><b>getNewMovies</b></i> atrav√©s dele. <br><br><pre> <code class="swift hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> networkManager: <span class="hljs-type"><span class="hljs-type">NetworkManager!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(networkManager: <span class="hljs-type"><span class="hljs-type">NetworkManager</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(nibName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, bundle: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.networkManager = networkManager } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"init(coder:) has not been implemented"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() view.backgroundColor = .green networkManager.getNewMovies(page: <span class="hljs-number"><span class="hljs-number">1</span></span>) { movies, error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> movies = movies { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(movies) } } } }</code> </pre> <br><br>  <b>B√¥nus pequeno</b> <br><br>  Voc√™ teve situa√ß√µes no Xcode quando n√£o entendeu que tipo de espa√ßo reservado √© usado em um local espec√≠fico?  Por exemplo, veja o c√≥digo que acabamos de escrever para o <i><b>roteador</b></i> . <br><br><img src="https://habrastorage.org/webt/sd/cb/ga/sdcbgacxit9y-j4zk8w32slxqm8.png"><br><br>  N√≥s mesmos determinamos o <i><b>NetworkRouterCompletion</b></i> , mas mesmo neste caso, √© f√°cil esquecer que tipo e como us√°-lo.  Mas nosso amado Xcode cuidou de tudo, e basta clicar duas vezes no espa√ßo reservado e o Xcode substituir√° o tipo desejado. <br><br><img src="https://habrastorage.org/webt/la/wo/oj/lawoojq5qsvsdzzvfzarqc-wnsk.png"><br><br>  <b>Conclus√£o</b> <br><br>  Agora, temos uma implementa√ß√£o de uma camada de rede orientada a protocolo, que √© muito f√°cil de usar e que voc√™ sempre pode personalizar de acordo com suas necessidades.  Compreendemos sua funcionalidade e como todos os mecanismos funcionam. <br><br>  Voc√™ pode encontrar o c√≥digo fonte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste reposit√≥rio</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443514/">https://habr.com/ru/post/pt443514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443504/index.html">A World Wide Web tem trinta anos - o que acontecer√° a seguir?</a></li>
<li><a href="../pt443506/index.html">Analisador simples para youtube em tabelas do google</a></li>
<li><a href="../pt443508/index.html">Jogos educativos de tabuleiro para programadores</a></li>
<li><a href="../pt443510/index.html">Notebook Compaq Armada 7700 - como um desenvolvimento da linha Compaq LTE</a></li>
<li><a href="../pt443512/index.html">Hackathon de An√°lise de Dados em Nizhny Novgorod</a></li>
<li><a href="../pt443516/index.html">Hacker Geohot decidiu libertar pessoas da simula√ß√£o de IA</a></li>
<li><a href="../pt443518/index.html">RBKmoney Payments under the hood - microsservi√ßos, protocolos e configura√ß√£o de plataforma</a></li>
<li><a href="../pt443520/index.html">Escolhendo um carro para um especialista em TI ou dicas para bules de uma chaleira</a></li>
<li><a href="../pt443522/index.html">Hospedagem: op√ß√µes, compara√ß√µes, estat√≠sticas do usu√°rio</a></li>
<li><a href="../pt443524/index.html">Fa√ßa voc√™ mesmo anima√ß√µes em Flash no Unity3D. Parte Um, L√≠rico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>