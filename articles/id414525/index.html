<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ê ü§¨ üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø Buku ‚ÄúSpark Efektif. Penskalaan dan pengoptimalan " üßü ü§òüèø ‚Ñ¢Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam posting ini, kita akan melihat mengakses API Spark dari berbagai bahasa pemrograman di JVM, serta beberapa masalah kinerja ketika melampaui baha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku ‚ÄúSpark Efektif. Penskalaan dan pengoptimalan "</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/414525/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/g1/uu/lu/g1uulu2edgzcixecswin9lfylnc.jpeg" align="left" alt="gambar"></a>  Dalam posting ini, kita akan melihat mengakses API Spark dari berbagai bahasa pemrograman di JVM, serta beberapa masalah kinerja ketika melampaui bahasa Scala.  Bahkan jika Anda bekerja di luar JVM, bagian ini mungkin berguna, karena bahasa non-JVM sering bergantung pada Java API, dan bukan pada Scala API. <br><br>  Bekerja dalam bahasa pemrograman lain tidak selalu berarti Anda harus melampaui JVM, dan bekerja di JVM memiliki banyak keuntungan dalam hal kinerja - terutama karena Anda tidak perlu menyalin data.  Meskipun tidak perlu menggunakan pustaka atau adapter yang mengikat khusus untuk mengakses Spark dari luar bahasa Scala, memohon kode Scala dari bahasa pemrograman lain bisa jadi sulit.  Kerangka kerja Spark mendukung penggunaan Java 8 dalam ekspresi lambda, dan mereka yang menggunakan versi JDK yang lebih lama memiliki kesempatan untuk mengimplementasikan antarmuka yang sesuai dari paket fungsi org.apache.spark.api.ja.java.fungsi.  Bahkan dalam kasus di mana Anda tidak perlu menyalin data, bekerja dalam bahasa pemrograman lain mungkin memiliki nuansa kecil namun penting terkait dengan kinerja. <br><a name="habracut"></a><br>  Yang paling mencolok adalah kesulitan dalam mengakses berbagai Scala API ketika memanggil fungsi dengan tag kelas atau ketika menggunakan properti yang disediakan menggunakan konversi tipe implisit (misalnya, semua fungsi set RDD terkait dengan kelas Double dan Tuple).  Untuk mekanisme yang bergantung pada konversi tipe implisit, kelas konkret yang setara sering diberikan bersama dengan konversi eksplisit kepada mereka.  Tag kelas Dummy (katakanlah, AnyRef) dapat diteruskan ke fungsi yang bergantung pada tag kelas (seringkali adaptor melakukan ini secara otomatis.  Menerapkan kelas spesifik alih-alih konversi tipe implisit biasanya tidak mengarah ke overhead tambahan, tetapi tag kelas dummy dapat memberlakukan batasan pada beberapa optimisasi kompiler. <br><br>  API Java tidak terlalu berbeda dari Scala API dalam hal properti, hanya kadang-kadang beberapa fungsionalitas atau API pengembang hilang.  Bahasa pemrograman JVM lainnya, seperti bahasa Clojure dengan DSL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flambo</a> dan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gemerlap</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">didukung</a> menggunakan berbagai API Java alih-alih memanggil Scala API secara langsung.  Karena sebagian besar binding bahasa, bahkan bahasa non-JVM seperti Python dan R, melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java</a> API, akan sangat berguna untuk menghadapinya. <br><br>  API Java sangat mirip dengan API Scala, meskipun mereka tidak tergantung pada tag kelas dan konversi implisit.  Tidak adanya yang terakhir berarti bahwa alih-alih secara otomatis mengonversi set RDD dari Tuple atau objek ganda ke kelas khusus dengan fungsi tambahan, Anda harus menggunakan fungsi konversi tipe eksplisit (misalnya, mapToDouble atau mapToPair).  Fungsi yang ditentukan hanya ditentukan untuk set RDD Java;  untungnya untuk kompatibilitas, tipe khusus ini hanya adapter untuk set Scala RDD.  Selain itu, fungsi-fungsi khusus ini mengembalikan berbagai tipe data, seperti JavaDoubleRDD dan JavaPairRDD, dengan fitur-fitur yang disediakan oleh transformasi bahasa Scala implisit. <br><br>  Mari kita kembali ke contoh kanonik penghitungan kata menggunakan Java API (Contoh 7.1).  Karena memanggil Scala API dari Java kadang-kadang bisa menjadi tugas yang menakutkan, hampir semua API framework Java Spark diimplementasikan dalam bahasa Scala dengan tag kelas tersembunyi dan konversi tersirat.  Karena itu, adapter Java adalah lapisan yang sangat tipis, rata-rata hanya terdiri dari beberapa baris kode, dan menulis ulang mereka hampir tanpa usaha. <br><br>  Contoh 7.1  Penghitungan Kata (Jawa) <br><br><pre><code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> scala.Tuple2;</span></span>  <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> org.apache.spark.api.java.JavaRDD;</span></span> <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> org.apache.spark.api.java.JavaPairRDD </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> org.apache.spark.api.java.JavaSparkContext;</span></span>  <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> java.util.regex.Pattern;</span></span> <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> java.util.Arrays;</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordCount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Pattern pattern = Pattern.compile(<span class="hljs-string"><span class="hljs-string">" "</span></span>);  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(String[] args) throws Exception { JavaSparkContext jsc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JavaSparkContext(); JavaRDD&lt;String&gt; lines = jsc.textFile(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); JavaRDD&lt;String&gt; words = lines.flatMap(e -&gt; Arrays.asList(                                           pattern.split(e)).iterator()); JavaPairRDD&lt;String, Integer&gt; wordsIntial = words.mapToPair(  e -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Tuple2&lt;String, Integer&gt;(e, <span class="hljs-number"><span class="hljs-number">1</span></span>));   } }</code> </pre> <br>  Terkadang Anda mungkin perlu mengubah RDD Java ke RDD Scala atau sebaliknya.  Ini paling sering diperlukan untuk pustaka yang membutuhkan input atau mengembalikan set Scala RDD, tapi kadang-kadang properti Spark dasar mungkin belum tersedia di Java API.  Mengubah RDD Java ke Scala RDD adalah cara termudah untuk menggunakan fitur-fitur baru ini. <br><br>  Jika Anda perlu mentransfer RDD Java yang diatur ke pustaka Scala, yang mengharapkan Spark RDD biasa pada input, Anda dapat mengakses RDD Scala yang mendasarinya menggunakan metode rdd ().  Paling sering ini cukup untuk mentransfer RDD akhir ke perpustakaan Scala yang diinginkan;  Di antara pengecualian yang menonjol adalah Scala libraries, yang mengandalkan konversi implisit dari jenis set konten konten atau informasi tag kelas dalam pekerjaan mereka.  Dalam hal ini, cara termudah untuk mengakses konversi tersirat adalah dengan menulis adaptor kecil di Scala.  Jika kerang Scala tidak dapat digunakan, maka Anda dapat memanggil fungsi yang sesuai dari kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaConverters</a> dan membentuk tag kelas dummy. <br><br>  Untuk membuat tag kelas dummy, Anda dapat menggunakan metode scala.reflect.ClassTag $ .MODULE $ .AnyRef () atau mendapatkan yang asli menggunakan scala.reflect.ClassTag $ .MODULE $ .apply (CLASS), seperti yang ditunjukkan dalam contoh 7.2 dan 7.3. <br><br>  Untuk mengonversi dari Scala RDD ke RDD Java, informasi tag kelas seringkali lebih penting daripada kebanyakan perpustakaan Spark.  Alasannya adalah bahwa meskipun berbagai kelas JavaRDD menyediakan konstruktor yang dapat diakses publik yang menggunakan Scala RDD sebagai argumen, mereka dimaksudkan untuk dipanggil dari kode Scala, dan oleh karena itu memerlukan informasi tentang tag kelas. <br><br>  Tag kelas Dummy paling sering digunakan dalam kode generik atau templat, di mana jenis pastinya tidak diketahui pada waktu kompilasi.  Tag semacam itu sering kali cukup, meskipun ada kemungkinan kehilangan beberapa nuansa di sisi kode Scala;  dalam kasus yang sangat jarang, kode Scala memerlukan informasi tag kelas yang akurat.  Dalam hal ini, Anda harus menggunakan tag asli.  Dalam kebanyakan kasus, ini tidak memerlukan banyak usaha dan meningkatkan kinerja, jadi cobalah untuk menggunakan tag tersebut sedapat mungkin. <br><br>  Contoh 7.2.  Membuat RDD Java / Scala Kompatibel dengan Tag Kelas Dummy <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static JavaPairRDD wrapPairRDDFakeCt( RDD&lt;Tuple2&lt;String, <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>&gt;&gt; RDD) { //       AnyRef ‚Äî   //        , //        , //        //    ClassTag&lt;<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>&gt; fake = ClassTag$.MODULE$.AnyRef(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> JavaPairRDD(rdd, fake, fake); }</code> </pre> <br>  Contoh 7.3.  Memastikan Kompatibilitas RDD Java / Scala <br><br><pre> <code class="hljs ruby">public static JavaPairRDD wrapPairRDD( RDD&lt;Tuple2&lt;String, Object<span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>RDD) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ClassTag&lt;String&gt; strCt = ClassTag$.MODULE$.apply(String.class); ClassTag&lt;Long&gt; longCt = ClassTag$.MODULE$.apply(scala.Long.class); return new JavaPairRDD(rdd, strCt, longCt); }</code> </pre> <br>  Spark SQL dan API pipa ML sebagian besar dibuat konsisten di Jawa dan Scala.  Namun, fungsi pembantu khusus Java ada, dan fungsi Scala yang setara dengannya tidak mudah untuk dipanggil.  Berikut adalah contohnya: berbagai fungsi numerik, seperti plus, minus, dll., Untuk kelas Kolom.  Sulit untuk memanggil ekivalen kelebihan muatan mereka dari bahasa Scala (+, -).  Alih-alih menggunakan JavaDataFrame dan JavaSQLContext, metode yang disyaratkan Java tersedia di SQLContext dan set DataFrame biasa.  Ini mungkin membingungkan Anda, karena beberapa metode yang disebutkan dalam dokumentasi Java tidak dapat digunakan dari kode Java, tetapi dalam kasus seperti itu fungsi dengan nama yang sama disediakan untuk panggilan dari Jawa. <br><br>  Fungsi yang ditentukan pengguna (UDFs) dalam bahasa Jawa, dan dalam hal ini, di sebagian besar bahasa lain kecuali Scala, mereka memerlukan menentukan jenis nilai yang dikembalikan oleh fungsi, karena itu tidak dapat dideduksi secara logis, mirip dengan bagaimana hal itu dilakukan dalam Scala (contoh 7.4) . <br><br>  Contoh 7.4.  Sampel UDF untuk Java <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">sqlContext</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.udf</span></span>() <span class="hljs-selector-class"><span class="hljs-selector-class">.register</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">strlen</span></span>", (<span class="hljs-selector-tag"><span class="hljs-selector-tag">String</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.length</span></span>(), <span class="hljs-selector-tag"><span class="hljs-selector-tag">DataTypes</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.StringType</span></span>);</code> </pre> <br>  Meskipun jenis yang dibutuhkan oleh Scala dan Java API berbeda, pembungkus tipe pengumpulan Java tidak memerlukan penyalinan tambahan.  Dalam kasus iterator, konversi tipe yang diperlukan untuk adaptor dilakukan secara tertunda ketika elemen diakses, yang memungkinkan kerangka Spark untuk membuang data jika perlu (seperti yang dibahas dalam bagian "Melakukan transformasi iterator-iterator menggunakan fungsi mapPartitions" di halaman 121).  Ini sangat penting karena bagi banyak operasi sederhana biaya menyalin data mungkin lebih tinggi daripada biaya perhitungan itu sendiri. <br><br><h3>  Melampaui Scala dan JVM </h3><br>  Jika Anda tidak membatasi diri pada JVM, maka jumlah bahasa pemrograman yang tersedia untuk pekerjaan meningkat secara dramatis.  Namun, dengan arsitektur Spark saat ini, bekerja di luar JVM - terutama pada node kerja - dapat menyebabkan kenaikan biaya yang signifikan karena menyalin data dalam node kerja antara JVM dan kode bahasa target.  Dalam operasi yang kompleks, bagian dari biaya menyalin data relatif kecil, tetapi dalam operasi sederhana dapat dengan mudah menyebabkan penggandaan total biaya komputasi. <br><br>  Bahasa pemrograman non-JVM pertama yang secara langsung didukung di luar Spark adalah Python, API dan antarmuka-nya telah menjadi model yang menjadi dasar implementasi untuk bahasa pemrograman non-JVM lainnya. <br><br><h3>  Bagaimana PySpark Bekerja </h3><br>  PySpark terhubung ke JVM Spark menggunakan campuran saluran pada pekerja dan Py4J, perpustakaan khusus yang menyediakan interaksi Python / Java, pada driver.  Di bawah ini, pada pandangan pertama, arsitektur sederhana menyembunyikan banyak nuansa kompleks, berkat yang berfungsi PySpark, seperti yang ditunjukkan pada Gambar.  7.1.  Salah satu masalah utama: bahkan ketika data disalin dari pekerja Python ke JVM, itu bukan dalam bentuk bahwa mesin virtual dapat dengan mudah diurai.  Upaya khusus diperlukan oleh pekerja Python dan Java untuk memastikan bahwa JVM memiliki informasi yang cukup untuk operasi seperti partisi. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/10/ez/wf/10ezwfv-1jvl1gxwsansnexwvj4.png" alt="gambar"></div><br><h3>  Kit RDD PySpark </h3><br>  Biaya sumber daya untuk mentransfer data ke dan dari JVM, serta untuk menjalankan pelaksana Python, adalah signifikan.  Anda dapat menghindari banyak masalah kinerja dengan API RDD Suite PySpark menggunakan API DataFrame / Dataset, karena data tetap berada di JVM selama mungkin. <br><br>  Menyalin data dari JVM ke Python dilakukan dengan menggunakan soket dan byte serial.  Versi yang lebih umum untuk berinteraksi dengan program dalam bahasa lain tersedia melalui antarmuka PipedRDD, aplikasi yang diperlihatkan dalam subbagian ‚ÄúMenggunakan pipa‚Äù. <br><br>  Organisasi saluran untuk pertukaran data (dalam dua arah) untuk setiap transformasi akan terlalu mahal.  Akibatnya, PySpark mengatur (jika mungkin) Python mengubah pipa di dalam juru bahasa Python, merantai operasi filter, dan setelah itu memetakannya, pada objek Python iterator menggunakan kelas PipelinedRDD khusus.  Bahkan ketika Anda perlu mengacak data dan PySpark tidak dapat menghubungkan konversi di mesin virtual pekerja individu, Anda dapat menggunakan kembali juru bahasa Python, sehingga biaya memulai juru bahasa tidak akan melambat lebih jauh. <br><br>  Ini hanya bagian dari teka-teki.  PipedRDD biasa bekerja dengan tipe String, yang tidak begitu mudah untuk diacak karena kurangnya kunci alami.  Di PySpark, dan dalam gambar dan kesamaan dalam pustaka yang mengikat banyak bahasa pemrograman lain, jenis khusus PairwiseRDD digunakan, di mana kuncinya adalah bilangan bulat panjang, dan deserialisasi dilakukan oleh kode pengguna dalam bahasa Scala, yang dimaksudkan untuk mengurai nilai Python.  Biaya deserialisasi ini tidak terlalu tinggi, tetapi ini menunjukkan bahwa Scala dalam kerangka kerja Spark pada dasarnya menganggap hasil kode Python berfungsi sebagai array byte "buram". <br><br>  Untuk semua kesederhanaannya, pendekatan integrasi ini bekerja sangat baik, dan sebagian besar operasi pada set Scala RDD tersedia dalam Python.  Di beberapa tempat yang paling sulit dalam kode, perpustakaan diakses, misalnya, MLlib, serta memuat / menyimpan data dari berbagai sumber. <br><br>  Bekerja dengan berbagai format data juga membebankan keterbatasannya, karena sebagian besar kode untuk memuat / menyimpan data dari kerangka kerja Spark didasarkan pada antarmuka Hadoop Java.  Ini berarti bahwa semua data yang dimuat pertama kali dimuat ke dalam JVM, dan baru kemudian dipindahkan ke Python. <br><br>  Dua pendekatan biasanya digunakan untuk berinteraksi dengan MLlib: PySpark menggunakan tipe data khusus dengan konversi tipe Scala, atau algoritmanya diimplementasikan kembali dengan Python.  Masalah-masalah ini dapat dihindari dengan paket Spark ML, yang menggunakan antarmuka DataFrame / Dataset, yang biasanya menyimpan data dalam JVM. <br><br><h3>  PySpark DataFrame dan Kit Data </h3><br>  Set DataFrame dan Dataset tidak memiliki banyak masalah kinerja dengan API Set RDD Python karena mereka menyimpan data dalam JVM selama mungkin.  Tes kinerja yang sama yang kami lakukan untuk menggambarkan keunggulan set DataFrame atas set RDD (lihat Gambar 3.1) menunjukkan perbedaan yang signifikan ketika berjalan dengan Python (Gambar 7.2). <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d9/mk/tl/d9mktl7qhe3hg8z2e9lnyanlgde.png" alt="gambar"></div><br>  Untuk banyak operasi dengan set DataFrame dan Dataset, Anda mungkin tidak perlu memindahkan data dari JVM sama sekali, meskipun menggunakan berbagai ekspresi UDF, UDAF, dan Python lambda secara alami membutuhkan pemindahan sebagian data ke dalam JVM.  Ini mengarah ke skema yang disederhanakan berikut untuk banyak operasi, yang terlihat seperti yang ditunjukkan pada Gambar.  7.3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4e/3q/el/4e3qel6hamrvb5ipzycqh9sftcg.png" alt="gambar"></div><br><h3>  Akses ke objek Java yang mendasari dan kode campuran dalam Scala </h3><br>  Konsekuensi penting dari arsitektur PySpark adalah bahwa banyak kelas kerangka kerja Spark Python sebenarnya adalah adaptor untuk menerjemahkan panggilan dari kode Python ke dalam bentuk JVM yang dapat dimengerti. <br><br>  Jika Anda bekerja dengan pengembang Scala / Java dan ingin berinteraksi dengan kode mereka, maka sebelumnya tidak akan ada adaptor untuk mengakses kode Anda, tetapi Anda dapat mendaftarkan Java / Scala UDF Anda dan menggunakannya dari kode Python.  Dimulai dengan Spark 2.1, ini dapat dilakukan dengan menggunakan metode registerJavaFunction dari objek sqlContext. <br><br>  Terkadang adaptor ini tidak memiliki semua mekanisme yang diperlukan, dan karena Python tidak memiliki perlindungan yang kuat terhadap pemanggilan metode pribadi, Anda dapat segera beralih ke JVM.  Teknik yang sama akan memungkinkan Anda untuk mengakses kode Anda sendiri di JVM dan, dengan sedikit usaha, mengubah hasilnya kembali ke objek Python. <br><br>  Di subbagian "Rencana kueri besar dan algoritme berulang" pada hal.  91 kami mencatat pentingnya menggunakan versi JVM dari DataFrame dan set RDD untuk mengurangi rencana kueri.  Ini adalah solusi, karena ketika rencana kueri menjadi terlalu besar untuk diproses oleh pengoptimal Spark SQL, pengoptimal SQL, karena menempatkan set RDD di tengah, kehilangan kemampuan untuk melihat melampaui saat data muncul di RDD.  Hal yang sama dapat dicapai dengan bantuan API Python publik, namun, banyak keuntungan dari set DataFrame akan hilang, karena semua data harus bolak-balik melalui simpul kerja Python.  Sebagai gantinya, Anda dapat mengurangi grafik asal dengan terus menyimpan data dalam JVM (seperti yang ditunjukkan pada Contoh 7.5). <br><br>  Contoh 7.5  Memotong rencana permintaan besar untuk DataFrame menggunakan Python <br><br><pre> <code class="hljs python"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutLineage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(df)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    DataFrame ‚Äî     .. :              &gt;&gt;&gt; df = RDD.toDF() &gt;&gt;&gt; cutDf = cutLineage(df) &gt;&gt;&gt; cutDf.count() 3 """</span></span> jRDD = df._jdf.toJavaRDD() jSchema = df._jdf.schema() jRDD.cache() sqlCtx = df.sql_ctx <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: javaSqlCtx = sqlCtx._jsqlContext <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: javaSqlCtx = sqlCtx._ssql_ctx newJavaDF = javaSqlCtx.createDataFrame(jRDD, jSchema) newDF = DataFrame(newJavaDF, sqlCtx) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newDF</code> </pre> <br>  Secara umum, dengan konvensi, sintaks _j [disingkat_name] digunakan untuk mengakses versi Java internal sebagian besar objek Python.  Jadi, misalnya, objek SparkContext memiliki _jsc, yang memungkinkan Anda untuk mendapatkan objek Java SparkContext internal.  Ini hanya mungkin dalam program driver, jadi ketika Anda mengirim objek PySpark ke node kerja, Anda tidak akan dapat mengakses komponen Java internal dan sebagian besar API tidak akan berfungsi. <br><br>  Untuk mengakses kelas Spark di JVM, yang tidak memiliki adaptor Python, Anda dapat menggunakan gateway Py4J pada driver.  Objek SparkContext berisi tautan ke gateway di properti _gateway.  Sintaksis sc._gateway.jvm. [Full_class_name_in_JVM] akan memungkinkan akses ke objek Java apa pun. <br><br>  Teknik serupa akan bekerja untuk kelas Scala Anda sendiri jika diatur menurut classpath.  Anda bisa menambahkan file JAR ke classpath menggunakan perintah spark-submit dengan parameter --jars atau dengan mengatur properti konfigurasi spark.driver.extraClassPath.  Contoh 7.6, yang membantu menghasilkan beras.  7.2, sengaja dirancang untuk menghasilkan data untuk pengujian kinerja menggunakan kode Scala yang ada. <br><br>  Contoh 7.6  Memanggil kelas non-Spark-JVM menggunakan Py4J <br><br><pre> <code class="hljs pgsql">sc = sqlCtx._sc #  <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span> Context,   <span class="hljs-number"><span class="hljs-number">2.1</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>   , #  <span class="hljs-number"><span class="hljs-number">2.0</span></span>, ‚Äî  ,   :p try: try: javaSqlCtx = sqlCtx._jsqlContext <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: javaSqlCtx = sqlCtx._ssql_ctx <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: javaSqlCtx = sqlCtx._jwrapped jsc = sc._jsc scalasc = jsc.sc() gateway = sc._gateway #  java-,   RDD JVM- # <span class="hljs-keyword"><span class="hljs-keyword">Row</span></span> (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Double</span></span>).   RDD  Python   #  RDD  Java (   <span class="hljs-keyword"><span class="hljs-keyword">Row</span></span>),   # ,      . #   Java-RDD  <span class="hljs-keyword"><span class="hljs-keyword">Row</span></span> ‚Äî     #    DataFrame,     #    RDD  <span class="hljs-keyword"><span class="hljs-keyword">Row</span></span>. java_rdd = (gateway.jvm.com.highperformancespark.examples. tools.GenerateScalingData. generateMiniScaleRows(scalasc, <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>, numCols)) #     <span class="hljs-type"><span class="hljs-type">JSON</span></span>     . #  Python-     Java-. schema = StructType([ StructField("zip", IntegerType()), StructField("fuzzyness", DoubleType())]) #   <span class="hljs-number"><span class="hljs-number">2.1</span></span> /  <span class="hljs-number"><span class="hljs-number">2.1</span></span> try: jschema = javaSqlCtx.parseDataType(<span class="hljs-keyword"><span class="hljs-keyword">schema</span></span>.json()) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: jschema = sqlCtx._jsparkSession.parseDataType(<span class="hljs-keyword"><span class="hljs-keyword">schema</span></span>.json()) #  RDD (Java)  DataFrame (Java) java_dataframe = javaSqlCtx.createDataFrame(java_rdd, jschema) #  DataFrame (Java)  DataFrame (Python) python_dataframe = DataFrame(java_dataframe, sqlCtx) #  DataFrame (Python)   RDD pairRDD = python_dataframe.rdd.map(lambda <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>: (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (python_dataframe, pairRDD)</code> </pre> <br><br>  Meskipun banyak kelas Python hanyalah adapter dari objek Java, tidak semua objek Java dapat dibungkus dengan objek Python dan kemudian digunakan dalam Spark.  Sebagai contoh, objek dalam set RDD PySpark direpresentasikan sebagai string serial, yang hanya dapat diurai dengan mudah dalam kode Python.  Untungnya, objek DataFrame distandarisasi antara bahasa pemrograman yang berbeda, jadi jika Anda dapat mengonversi data Anda menjadi set DataFrame, Anda kemudian dapat membungkusnya dalam objek Python dan menggunakannya secara langsung sebagai Python DataFrame, atau mengonversi Python DataFrame ke RDD dari ini. bahasa yang sama. <br><br>  ¬ªInformasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  20% diskon kupon untuk Penyemprot - <b>Spark</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414525/">https://habr.com/ru/post/id414525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414513/index.html">27 alat pengembangan web open source yang bagus</a></li>
<li><a href="../id414515/index.html">Pelajaran Optimasi Server Aplikasi Web</a></li>
<li><a href="../id414517/index.html">Ilmuwan Oxford: probabilitas bahwa kita sendirian di bagian alam semesta yang dapat diperkirakan jauh lebih tinggi daripada nol</a></li>
<li><a href="../id414519/index.html">Bagaimana mengubah 15 menit rapat Scrum menjadi rumah penuh?</a></li>
<li><a href="../id414523/index.html">Perbandingan quadcopters DJI Mavic Pro dan Mavic Air</a></li>
<li><a href="../id414527/index.html">Apa yang menanti kita di Highload ++ Siberia, kecuali beruang yang dicat</a></li>
<li><a href="../id414531/index.html">Tidak ada yang tahu apa yang akan terjadi pada belanja online mulai 1 Juli</a></li>
<li><a href="../id414535/index.html">Manchester: tempat kelahiran dari kesedihan, post-punk dan dua klub sepakbola terkenal</a></li>
<li><a href="../id414537/index.html">Bagaimana kami membuat salah satu game AR terbaik di dunia tanpa lalu lintas berbayar</a></li>
<li><a href="../id414539/index.html">Penjahat dunia maya semakin mencuri data pribadi Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>