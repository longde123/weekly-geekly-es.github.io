<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗡️ 👩🏿‍🏫 ⤴️ 用于研究难以置信的快速Web应用程序的性能指标 👍🏽 🌬️ 💳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="有句话说：“无法衡量，就无法改善。” 这篇文章的作者（我们今天要翻译的译本）是为Superhuman工作的 。 他说，这家公司正在开发世界上最快的电子邮件客户端。 在这里，我们将讨论什么是“快速”，以及如何创建工具来测量难以置信的快速Web应用程序的性能。 

  

 应用速度测量 
 为了改善我...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>用于研究难以置信的快速Web应用程序的性能指标</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/470872/"> 有句话说：“无法衡量，就无法改善。” 这篇文章的作者（我们今天要翻译的译本）是为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Superhuman工作的</a> 。 他说，这家公司正在开发世界上最快的电子邮件客户端。 在这里，我们将讨论什么是“快速”，以及如何创建工具来测量难以置信的快速Web应用程序的性能。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/q6/af/pp/q6afppxtd4rv6r-iqwvk9-6nyai.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">应用速度测量</font> </h2><br> 为了改善我们的发展，我们花费了大量时间来衡量其速度。 而且，事实证明，绩效指标是难以理解和应用的指标。 <br><br> 一方面，很难设计能够准确描述用户在使用系统时所经历的感觉的度量。 另一方面，要创建如此精确的指标以至于它们的分析使您能够做出明智的决定并不容易。 结果，许多开发团队无法信任他们收集的有关项目绩效的数据。 <br><br> 即使开发人员拥有可靠和准确的指标，使用它们也不容易。 如何定义“快速”一词？ 如何在速度和一致性之间找到平衡？ 如何学习快速检测性能下降或学习评估优化对系统的影响？ <br><br> 在这里，我们想分享一些有关Web应用程序性能分析工具开发的想法。 <br><br><h2>  <font color="#3AC1EF">1.使用正确的“时钟”</font> </h2><br>  JavaScript有两种检索时间戳的机制： <code>performance.now()</code>和<code>new Date()</code> 。 <br><br> 它们有何不同？ 以下两个差异对我们至关重要： <br><br><ul><li>  <code>performance.now()</code>方法更加准确。  <code>new Date()</code>构造的精度为±1 ms，而<code>performance.now()</code>的精度已经为±100 µs（是的，大约是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">微秒</a> ！）。 </li><li> 由<code>performance.now()</code>方法返回的值始终以恒定速率增加，并且与系统时间无关。 此方法仅测量时间间隔，而无需关注系统时间。 并在<code>new Date()</code>影响系统时间。 如果重新安排系统时钟，它还将更改<code>new Date ()</code>返回的值，这将破坏性能监视数据。 </li></ul><br> 尽管用<code>performance.now()</code>方法表示的“时钟”显然更适合于测量时间间隔，但它们也不理想。  <code>performance.now()</code>和<code>new Date()</code>遇到相同的问题，这在系统处于睡眠状态时会表现出来：测量包括机器甚至不处于活动状态的时间。 <br><br><h2>  <font color="#3AC1EF">2.检查应用程序活动</font> </h2><br> 如果您要衡量Web应用程序的性能，请从其选项卡切换到其他选项卡-这将破坏数据收集过程。 怎么了 事实是浏览器限制了位于后台选项卡中的应用程序。 <br><br> 在两种情况下，指标可能会失真。 结果，该应用程序看起来比实际速度要慢得多。 <br><br><ol><li> 电脑进入睡眠模式。 </li><li> 该应用程序在浏览器的后台选项卡中运行。 </li></ol><br> 这两种情况的发生并不罕见。 幸运的是，我们有两种解决方案。 <br><br> 首先，我们可以简单地忽略失真的指标，丢弃与某些合理值相差太大的测量结果。 例如，按下按钮时调用的代码根本无法执行15分钟！ 也许这是您唯一需要解决的两个问题。 <br><br> 其次，可以使用<code>document.hidden</code>属性和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">visiblechange</a>事件。 当用户从感兴趣的浏览器选项卡切换到另一个选项卡或返回到我们感兴趣的选项卡时，会引发<code>visibilitychange</code>更改事件。 当计算机开始工作并退出睡眠模式时，浏览器窗口最小化或最大化时，将调用此方法。 换句话说，这正是我们所需要的。 另外，只要选项卡在后台， <code>document.hidden</code>属性为<code>true</code> 。 <br><br> 这是一个简单示例，演示了<code>document.hidden</code>属性和<code>visibilitychange</code>事件的使用。 <br><br><pre> <code class="plaintext hljs">let lastVisibilityChange = 0 window.addEventListener('visibilitychange', () =&gt; {  lastVisibilityChange = performance.now() }) //    ,      , //  ,   ,     if (metric.start &lt; lastVisibilityChange || document.hidden) return</code> </pre> <br> 如您所见，我们丢弃了一些数据，但这很好。 事实是，当程序无法完全使用系统资源时，这些数据与程序的那些时期有关。 <br><br> 现在我们讨论了我们不感兴趣的指标。 但是在很多情况下，收集的数据对我们来说非常有趣。 让我们看看如何收集这些数据。 <br><br><h2>  <font color="#3AC1EF">3.搜索指示器，以使您能够最好地捕获事件开始的时间</font> </h2><br>  JavaScript最具争议的功能之一是该语言的事件循环是单线程的。 在某个时间点，只有一条代码能够执行，其执行不能中断。 <br><br> 如果用户在执行某个代码时按下按钮，则在完成该代码的执行之前，程序将不知道该按钮。 例如，如果应用程序在一个连续周期中花费了1000毫秒，并且用户在该周期开始后100毫秒按下了<code>Escape</code>按钮，则该事件将不会再记录900毫秒。 <br><br> 这会严重扭曲指标。 如果我们需要准确地测量用户对程序的理解程度，那么这将是一个巨大的问题！ <br><br> 幸运的是，解决这个问题并不是那么困难。 如果我们正在谈论当前事件，那么可以使用<code>window.event.timeStamp</code> （创建事件的时间），而不是使用<code>performance.now()</code> （看到事件的时间）。 <br><br> 事件的时间戳由主浏览器进程设置。 由于锁定JS事件循环时此过程不会阻塞，因此<code>event.timeStamp</code>为我们提供了有关实际触发事件的更多有价值的信息。 <br><br> 应当指出，这种机制不是理想的。 因此，从按下物理按钮到相应事件到达Chrome的那一刻之间，经过了9到15毫秒的无法解释的时间（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是一篇</a>很棒的文章，您可以从中了解发生这种情况的原因）。 <br><br> 但是，即使我们可以衡量事件到达Chrome所需的时间，我们也不应将此时间纳入指标。 怎么了 事实是，我们无法将这样的优化引入可能严重影响此类延迟的代码中。 我们无法以任何方式改进它们。 <br><br> 结果，如果我们谈论寻找事件开始的时间戳，那么<code>event.timeStamp</code>指示器在这里看起来最合适。 <br><br> 事件何时结束的最佳估计是什么？ <br><br><h2>  <font color="#3AC1EF">4.关闭requestAnimationFrame（）中的计时器</font> </h2><br>  JavaScript中事件循环设备的功能还带来了另外一个后果：某些与您的代码无关的代码可以在它之后但在浏览器在屏幕上显示页面的更新版本之前执行。 <br><br> 考虑一下React。 执行代码后，React将更新DOM。 如果仅在代码中测量时间，则意味着您将不会测量执行React代码所花费的时间。 <br><br> 为了测量这额外的时间，我们使用<code>requestAnimationFrame()</code>关闭计时器。 仅当浏览器准备输出下一帧时，才执行此操作。 <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; { metric.finish(performance.now()) })</code> </pre> <br> 这是框架的生命周期（该图取自<code>requestAnimationFrame</code>上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这一</a>奇妙材料）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/439/0d4/4034390d4dd3060d8653bf03d72d4ca2.png"></div><br>  <i><font color="#999999">框架生命周期</font></i> <br><br> 如该图所示，在处理器完成之后，即在显示框架之前，将调用<code>requestAnimationFrame()</code> 。 如果我们在此处关闭计时器，则意味着我们可以完全确定，花费时间刷新屏幕的所有内容都包含在该时间间隔内收集的数据中。 <br><br> 到目前为止还不错，但是现在情况变得相当复杂... <br><br><h2>  <font color="#3AC1EF">5.忽略创建页面布局及其可视化所需的时间。</font> </h2><br> 上图显示了框架的生命周期，它说明了我们遇到的另一个问题。 在框架生命周期的最后，有版式块（形成页面布局）和画图（显示页面）。 如果您不考虑完成这些操作所需的时间，那么我们测量的时间将少于一些更新数据出现在屏幕上的时间。 <br><br> 幸运的是， <code>requestAnimationFrame</code>还有另外一个王牌。 调用由<code>requestAnimationFrame</code>传递的函数时，将为该函数传递一个时间戳，该时间戳指示当前帧形成的开始时间（即，位于图的最左侧的那一帧）。 该时间戳通常非常接近上一帧的结束时间。 <br><br> 结果，可以通过测量从<code>event.timeStamp</code>时刻到形成下一帧的时间所经过的总时间来纠正上述缺陷。 注意嵌套的<code>requestAnimationFrame</code> ： <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; {  requestAnimationFrame((timestamp) =&gt; { metric.finish(timestamp) }) })</code> </pre> <br> 尽管上面显示的内容看起来是解决该问题的绝佳方法，但最终，我们决定不使用此设计。 事实是，尽管该技术使得获得更可靠的数据成为可能，但是这种数据的准确性降低了。  Chrome中的帧以16毫秒的频率形成。 这意味着我们可以使用的最高精度为±16 ms。 而且，如果浏览器过载并跳过帧，那么准确性将更低，并且这种恶化将是不可预测的。 <br><br> 如果实施此解决方案，则代码性能的重大提高（例如，将之前执行的任务加速到32 ms，最高可达15 ms）可能不会影响性能测量结果。 <br><br> 不考虑创建页面布局及其输出所需的时间，我们得到了我们控制下的代码的更准确指标（±100μs）。 结果，我们可以获得对该代码所做的任何改进的数值表达式。 <br><br> 我们还探索了类似的想法： <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; {  setTimeout(() =&gt; { metric.finish(performance.now()) } })</code> </pre> <br> 这将包括渲染时间，但是指示器的精度将不限于±16 ms。 但是，我们决定也不使用这种方法。 如果系统遇到长输入事件，则在更新用户界面之后，对<code>setTimeout</code>传输的调用可能会大大延迟并执行。 <br><br><h2>  <font color="#3AC1EF">6.澄清“低于目标的事件所占百分比”</font> </h2><br> 我们正在开发一个项目，并将重点放在高性能上，尝试通过两种方式对其进行优化： <br><br><ol><li> 速度 最快的任务的执行时间应尽可能接近0 ms。 </li><li> 均匀性 最慢的任务的执行时间应尽可能接近最快的任务的执行时间。 </li></ol><br> 由于这些指标会随时间而变化，因此它们很难可视化，也不容易讨论。 是否有可能建立一个可视化的指标体系，以激励我们优化速度和均匀性？ <br><br> 一种典型的方法是测量延迟的90％。 这种方法使您可以沿Y轴绘制折线图，​​该线可以节省时间（以毫秒为单位）。 此图使您可以看到90％的事件都在折线图下方，也就是说，它们的执行速度比折线图指示的时间快。 <br><br> 众所周知， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">100 ms</a>是所谓的“快”和“慢”之间的界限。 <br><br> 但是，如果我们知道延迟的第90个百分位数是103 ms，那么我们将如何发现用户的工作感觉呢？ 不是特别多。 哪些指标将为用户提供可用性？ 无法肯定地知道这一点。 <br><br> 但是，如果我们知道延迟的第90个百分位数是93 ms，该怎么办？ 有人认为93优于103，但我们无法就这些指标以及它们对用户对项目的理解表示什么。 同样，这个问题没有确切答案。 <br><br> 我们找到了解决该问题的方法。 它包括测量执行时间不超过100 ms的事件的百分比。 这种方法有三大优点： <br><br><ul><li> 该指标是面向用户的。 她可以告诉我们我们的应用程序有多快的时间百分比，以及有多少百分比的用户将其视为快速。 </li><li> 该度量标准使我们能够将测量结果恢复到由于没有在帧的最后端完成任务所花费的时间而丢失的精度（我们在第5节中讨论了这一点）。 由于我们将目标指标设置为适合多个框架的事实，因此接近该指标的测量结果可能小于或大于该指标。 </li><li> 此指标更易于计算。 只需计算执行时间低于目标指标的事件数，然后将其除以事件总数即可。 百分位数要难得多。 有有效的近似值，但是为了正确处理所有事情，您需要考虑每个维度。 </li></ul><br> 这种方法只有一个缺点：如果指标比目标差，那么将很难注意到它们的改进。 <br><br><h2>  <font color="#3AC1EF">7.在指标分析中使用几个阈值</font> </h2><br> 为了可视化性能优化的结果，我们在系统中引入了多个附加阈值-100 ms以上及以下。 <br><br> 我们将延迟分为以下几类： <br><br><ul><li> 少于50毫秒（快速）。 </li><li>  50到100毫秒（良好）。 </li><li>  100至1000毫秒（慢）。 </li><li> 超过1000毫秒（非常慢）。 </li></ul><br>  “非常慢”的结果使我们看到我们非常错过某个地方。 因此，我们用鲜红色突出显示它们。 <br><br>  50毫秒内的变化对变化非常敏感。 在这里，性能改进通常在与100毫秒对应的组中很久之前就可见。 <br><br> 例如，下图直观显示了超人中线程查看的性能。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/773/9e8/eb57739e82476e3b7a2c9212908ff5bf.png"></div><br>  <i><font color="#999999">查看线程</font></i> <br><br> 它显示了性能下降的时期，然后-改善的结果。 如果仅查看与100毫秒（蓝色列的上部）相对应的指示器，则很难评估性能下降。 查看适合50毫秒（绿色列的上部）的结果时，性能问题已经很清楚地看到了。 <br><br> 如果我们使用传统方法来研究性能指标，则可能不会注意到上图中显示的问题，该问题对系统的影响。 但是，由于我们进行测量的方式以及对指标进行可视化的方式，我们能够非常快速地发现并解决问题。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 事实证明，找到正确的方法来处理性能指标非常困难。 我们设法开发出一种方法，使我们能够创建用于测量Web应用程序性能的高质量工具。 即，我们正在谈论以下内容： <br><br><ol><li> 使用<code>event.timeStamp</code>测量事件的开始时间。 </li><li> 事件结束时间是使用传递给<code>requestAnimationFrame()</code>的回调中的<code>performance.now()</code>来衡量的。 </li><li> 当应用程序处于非活动浏览器选项卡上时，该应用程序发生的所有事情都将被忽略。 </li><li> 数据使用指标进行汇总，指标可以描述为“低于目标的事件百分比”。 </li><li> 数据可以通过几个级别的阈值可视化。 </li></ol><br> 该技术为您提供了创建可靠和准确指标的工具。 您可以构建清楚地表明性能下降的图表，还可以可视化优化结果。 最重要的是-您有机会更快地进行快速项目。 <br><br>  <b>亲爱的读者们！</b> 您如何分析Web应用程序的性能？ <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN470872/">https://habr.com/ru/post/zh-CN470872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN470856/index.html">电报GRAM钱包：服务条款</a></li>
<li><a href="../zh-CN470858/index.html">上古：第386个处理器和九十年代的基准</a></li>
<li><a href="../zh-CN470864/index.html">关于切换到面板的乐趣，而不仅仅是</a></li>
<li><a href="../zh-CN470868/index.html">第一个字节的时间：这是什么，为什么重要</a></li>
<li><a href="../zh-CN470870/index.html">预加载字体</a></li>
<li><a href="../zh-CN470874/index.html">优化Wikipedia上的JavaScript加载</a></li>
<li><a href="../zh-CN470876/index.html">使用Babel创建自定义JavaScript语法结构。 第一部分</a></li>
<li><a href="../zh-CN470878/index.html">使用Babel创建自定义JavaScript语法结构。 第二部分</a></li>
<li><a href="../zh-CN470880/index.html">游戏机制。 冒险，零和引人注目的言语治疗概念</a></li>
<li><a href="../zh-CN470882/index.html">您为什么要抓住我的鼠标或将棋盘游戏作为社交互动的典范</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>