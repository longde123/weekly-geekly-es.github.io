<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏿 🌞 👩🏾‍🤝‍👨🏿 Pelo menos um truque do Vim que você não conhecia 👩🏻‍🍳 🍡 🚪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Trabalho na Vim há oito anos e constantemente descobri algo novo. É considerado uma virtude do Vim. Quanto a mim, isso é uma falta de abertura: um mon...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pelo menos um truque do Vim que você não conhecia</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454742/"> Trabalho na Vim há oito anos e constantemente descobri algo novo.  É considerado uma virtude do Vim.  Quanto a mim, isso é uma falta de abertura: um monte de funções ocultas estão ocultas demais. <br><br>  Eles falam sobre a beleza da edição modal e dos objetos de texto, mas me parece que a essência do Vim não é essa.  O Vim é uma colcha de retalhos de subsistemas entupidos com ferramentas adicionais.  Somente no modo de edição normal, mais de cem atalhos de teclado!  Essa densidade de kits de ferramentas explica em grande parte por que o Vim é tão útil.  Se “mostrar todas as tags para uma palavra-chave” for apenas <code>g]</code> , esse comando será usado com muito mais frequência. <br><br>  Sistemas com falta de abertura precisam confiar na liderança.  Mas para o Vim não existem muitos deles.  Existem artigos para iniciantes, como <code>ciw</code> (que não devem ser confundidos com a CIA, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o manual da CIA para o Vim</a> ) e similares.  E há artigos de especialistas imersos em subsistemas.  Mas ninguém fala sobre esses truques especiais que fazem você exclamar: caramba, como eu precisei nos últimos seis anos! <br><a name="habracut"></a><br>  Este artigo é sobre alguns dos pequenos truques que uso no Vim.  Nenhum deles é desmontado em todos os detalhes; portanto, se algo estiver interessado, recomendo que você desenterre informações adicionais.  Eles também não estão relacionados um com o outro.  Mas isso é normal.  Em geral, existem mais que o suficiente para realmente ajudar quase todo mundo. <br><br><h1>  Estrutura do artigo </h1><br>  Muito rudes, os usuários do Vim se enquadram em duas categorias.  <b>Os puristas</b> apreciam o tamanho pequeno e a onipresença.  Como regra, eles minimizam a configuração caso você precise trabalhar em um computador desconhecido (por exemplo, via ssh).  Os extensores, por outro lado, preenchem o Vim com plug-ins, funções e mapeamentos locais em uma tentativa fútil de fingir usar o Emacs.  Se você tirar o vimrc deles, os caras permanecerão completamente indefesos. <br><br>  Como você provavelmente adivinha, estou muito mais próximo dos expansores do que dos puristas.  Dividi os truques em duas seções, dependendo se as alterações são necessárias no Vim base. <br><br><h1>  Puristas </h1><br>  Para comandos modais, são usadas as visualizações de ajuda padrão, ou seja, <code>&lt;cr&gt;</code> significa pressionar a tecla Enter.  Quando você precisar de ajuda <code>:h</code> para uma linha específica, por exemplo <code>:h E676</code> , a linha estará entre parênteses. <br><br><h2>  Vários comandos no modo normal </h2><br><h4>  ": e @: </h4><br>  <code>":</code> é um registro que mantém o último comando executado. Você pode digitar <code>":p</code> para imprimi-lo no buffer.  <code>@:</code> repete o último comando. <br><br><h4>  "= </h4><br>  Registre-se para "expressões".  Aqui você pode inserir qualquer expressão do vimL e inseri-la, use com ctrl-R, etc. Assim, por exemplo, o registro de data e hora local é inserido digitando <code>"=strftime("%c")&lt;cr&gt;p</code> . <br><br><h4>  mA, 'A </h4><br>  <code>m{letter}</code> coloca a marca na posição do cursor.  Então <code>'{letter}</code> irá para esta linha.  Para letras minúsculas, atua no buffer, sendo adequado para navegação.  Funciona globalmente para letras maiúsculas: mesmo se você estiver em outro arquivo, <code>'A</code> irá para o arquivo rotulado <code></code>  Você pode ver todas as suas tags com o comando <code>:marks:</code> <br><br><h4>  ctrl-A e ctrl-X </h4><br>  Aumenta e diminui o próximo número na linha no local do cursor ou à direita dele.  Como ele vai imediatamente para o número, a combinação pode ser usada de qualquer lugar.  <code>10c-A</code> muito mais simples que <code>wwwwwciw20</code> . <br><br><h4>  q: </h4><br>  Abre o histórico das equipes anteriores.  Você pode trabalhar com ele como em qualquer texto do Vim, mas as alterações não são salvas.  No entanto, você pode executar o comando modificado usando <code>&lt;CR&gt;</code> .  Isso permite que você mude muito rapidamente e reinicie os comandos ou procure pelos antigos para reutilização. <br><br><h4>  q / q? </h4><br>  O mesmo que <code>q:</code> exceto pesquisa. <br><br><h4>  Ctrl-I, Ctrl-O </h4><br>  Move para o local seguinte ou anterior no jumplist.  Útil para verificação rápida e depois voltar atrás.  É muito bom ler os arquivos de ajuda. <br><br><h2>  Macros </h2><br>  Veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta postagem</a> para uma visão mais profunda do uso de macros. <br><br><h2>  Modo visual </h2><br><h4>  gv </h4><br>  Seleciona o item visual anterior. <br><br><h4>  v_o </h4><br>  Vai para o outro lado do bloco visual.  Útil se você iniciou uma linha muito baixa ou algo assim.  No modo de bloco, ele vai para o ângulo diagonal oposto e use <code>v_O</code> para alternar para o <code>v_O</code> horizontal oposto. <br><br><h4>  g Ctrl-A / Ctrl-X </h4><br>  No modo visual, ctrl-A simplesmente incrementa o primeiro número em cada linha.  Por outro lado, <code>g ctrl-A</code> aumentará uma linha com cada linha.  Isso é muito mais fácil de explicar na tabela: <br><br><div class="scrollable-table"><table><thead><tr><th>  <strong>selecionado</strong> </th><th> <code>ctrl-A</code> </th> <th> <code>g ctrl-A</code> </th> <th> <code>2 g ctrl-A</code> </th> </tr></thead><tbody><tr><td><pre>  a 0
 b 0
 c
 d 0 </pre></td><td><pre>  a 1
 b 1
 c
 d 1 </pre></td><td><pre>  a 1
 b 2
 c
 d 3 </pre></td><td><pre>  a 2
 b 4
 c
 d 6 </pre></td></tr></tbody></table></div><br><h4>  Operadores: v, V, cv (: h o_v) </h4><br>  Você provavelmente sabe que, no modo visual, pode selecionar caracteres (v), linhas (V) e blocos (ctrl-V).  Mas essas três combinações podem ser usadas como operadores de movimento para o fragmento correspondente.  Por exemplo, você tem o seguinte texto: <br><br> <code>abc <br> abc <br> abc</code> <br> <br>  Se você colocar o cursor na parte superior <code>b</code> pressionar <code>d2j</code> , ele excluirá todas as três linhas, porque <code>j</code> se moverá linha a linha.  Se <code>d&lt;cV&gt;2j</code> pressionado, o movimento se tornará bloco a bloco e somente a coluna do meio com três letras <code>b</code> será excluída. <br><br>  Um caso de uso é excluído na pesquisa.  Normal <code>d/</code> move caractere por caractere.  Portanto, eu uso <code>dV/</code> para movimento linha por linha com exclusão.  Há outra maneira de fazer isso: <br><br><h4>  / regex / {n} </h4><br>  Mova n linhas abaixo da partida ou o máximo de linhas se o valor for negativo.  Como efeito colateral, o movimento ocorre linha por linha.  Portanto, se você desejar excluir a primeira linha correspondente à <code>regex</code> , poderá inserir <code>d/regex//0</code> . <br><br><h2>  Ex-equipes </h2><br>  Você insere ex-comandos no modo de comando, por exemplo, o comando <code>:s</code> .  Além da substituição, existem muitos outros comandos úteis.  Todos esses exemplos exigem um intervalo, como <code>%</code> . <br><br><h4>  : g / regex / ex </h4><br>  Executa o comando apenas nas linhas correspondentes à expressão regular.  Por exemplo, você pode inserir <code>g/regex/d</code> para excluir todas as linhas correspondentes a regex.  O comando <code>v</code> é semelhante a <code>g</code> , mas funciona em todas as linhas que <i>não</i> correspondem à expressão regular. <br><br>  Truques se tornam mais poderosos com a norma e alguns outros. <br><br><h4>  : norma {Vim} </h4><br>  Age como se você executasse {Vim} em cada linha do intervalo.  Por exemplo, <code>g/regex/norm f dw</code> excluirá a primeira palavra após o primeiro espaço em cada linha correspondente à expressão regular da expressão regular.  Isso geralmente é muito mais simples que uma macro. <br><br>  <code>norm</code> obedece a todas as suas comparações.  Por exemplo, se você atribuiu <code>jk</code> a <code>&lt;esc&gt;</code> no modo de inserção, a <code>norm I jk$diw</code> adicionará um espaço ao início da linha, <i>deixe o modo de inserção</i> e exclua a última palavra da linha.  Eu realmente gosto dessa funcionalidade, mas se você preferir não usar seus mapeamentos, poderá aplicar a <code>norm!</code>  . <br><br><h4>  : co. </h4><br>  Copia um intervalo para a linha atual.  Você também pode especificar valores arbitrários em vez de um período, por exemplo, <code>+3</code> ou <code>'a. mv</code>  <code>'a. mv</code> para mover. <br><br><h4>  : y {reg} </h4><br>  Copia o intervalo para o <code>{reg}</code> .  Se <code>{reg}</code> maiúscula, ele será adicionado ao caso existente.  ou seja, uma equipe <br><br> <code>let @a = '' | %g/regex/y A</code> <br> <br>  copiará para todas as linhas correspondentes à <code>regex</code> no arquivo inteiro.  Isso ajuda a extrair o texto corrompido do arquivo e copiá-lo para a área de transferência do sistema (usando <code>let @+ = @a</code> ). <br><br><h4>  : windo {ex} </h4><br>  Executa um comando em todas as janelas.  Por exemplo <code>:windo $</code> todas as janelas para baixo.  Existem <code>bufdo</code> , <code>cdo</code> , <code>tabdo</code> e outros. <br><br>  Funciona muito bem com <code>g</code> e <code>s</code> .  Para substituir todas as combinações de <code>AA</code> pelo <code>BB</code> com uma visualização das substituições, você pode inserir o <code>vimgrep AA</code> carregando todas as correspondências no quickfix e, em seguida, <code>cdo s/AA/BB/cge</code> para pesquisar / substituir todas as correspondências. <br><br><h2>  Vim para Extensores </h2><br>  Aqui estão listados truques que exigem salvar nas configurações ou alterar uma sessão do Vim.  Hipoteticamente, eles podem ser usados ​​no modo "puritano", simplesmente digitando comandos, mas alguns envolvem mudanças bastante sérias que contradizem o espírito do purismo. <br><br>  Aqui é apenas o mais incomum.  Muitas pessoas atribuem <code>H</code> ao limite <code>^</code> , portanto não vale a pena mencionar essas coisas.  Além disso, não faz sentido falar sobre <code>vim-sensible</code> ou <code>vim-surround</code> , mas apenas sobre plugins mais exóticos. <br><br>  Se você está constantemente configurando seu vimrc, por favor, adicione um comando separado para isso: <br><br> <code>command! Vimrc :vs $MYVIMRC</code> <br> <br><h2>  Configurações </h2><br>  Eu tenho todas as configurações, combinações de teclas e funções armazenadas em um único arquivo vimrc.  Dividir em vários arquivos dificulta a pesquisa. <br><br>  A maioria das configurações não são realmente "truques".  É melhor olhar para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vim-sensible</a> : quase todas as configurações de lá se adequam ao seu vimrc. <br><br><h4>  set lazyredraw </h4><br>  Não redesenhe a tela no meio de uma macro (para melhorar o desempenho). <br><br><h4>  definir smartcase / ignorecase </h4><br>  Com essas duas configurações, uma pesquisa sem letras maiúsculas torna maiúsculas e minúsculas e uma pesquisa com letras maiúsculas diferencia maiúsculas de minúsculas. <br><br><h4>  definir undofile </h4><br>  Salvando ações, mesmo se você fechar e abrir o Vim, para que as ações de desfazer estejam sempre disponíveis.  Muito útil em combinação com o plugin undotree. <br><br><h4>  definir foldcolumn = {n} </h4><br>  Coluna lateral com blocos recolhidos.  Quanto maior <code>n</code> , mais blocos recolhidos são mostrados na coluna e, no restante, o número é indicado. <br><br><h4>  definir sufixosadd = {str} </h4><br>  <code>gf</code> geralmente significa "ir para o arquivo abaixo do cursor", mas requer uma extensão de arquivo na linha.  <code>suffixesadd</code> adiciona a extensão especificada.  Se <code>suffixesadd=.md</code> , o comando <code>gf</code> na linha 'foo' procurará os arquivos <code>foo</code> e <code>foo.md</code> <br><br><h4>  set inccommand = nosplit </h4><br>  Somente para Neovim.  A <code>incommand</code> mostra em tempo real as mudanças que a equipe fará.  Atualmente, apenas <code>s</code> é suportado, mas mesmo isso é incrivelmente útil.  Se você digitar <code>:s/regex</code> , todas as correspondências serão destacadas.  Se você adicionar <code>/change</code> , ele mostrará todas as substituições.  Funciona com todas as propriedades de regex, incluindo backlinks e grupos. <br><br><h3>  definir statusline (: h statusline) </h3><br>  Determina o que exibir no painel na parte inferior de cada janela.  Aqui a formatação é muito mais complicada e complicada do que em outras configurações, então você precisa gastar tempo explicando isso.  Existem alguns truques simples.  Primeiro, observe a barra de status padrão do Vim: <br><br> <code>:set statusline=%&lt;%f\ %h%m%r%=%-14.(%l,%c%V%)\ %P</code> <br> <br>  Aqui é mais fácil substituir <code>%P</code> (porcentagem do arquivo sobre o cursor).  O formato da barra de status é o valor após o sinal de porcentagem entre chaves.  Portanto, para arquivos Markdown, você pode escrever isto: <br><br> <code>:set statusline=%&lt;%f\ %h%m%r%=%-14.(%l,%c%V%)\ %{wordcount()[\"words\"]}</code> <br> <br>  E substitua a porcentagem do arquivo pelo número de palavras no documento. <br><br>  Ou instale o <code>tabline</code> .  Se você não usar guias, essa linha poderá ser transformada em uma "linha de status global".  Por exemplo <br><br> <code>set tabline=%{strftime('%c')}</code> <br> <br>  sempre mostrará a data no topo. <br><br><h2>  Key Bindings </h2><br>  Eu tenho <i>muitas</i> ligações. <br><br>  Muitas teclas convenientes no Vim são estupidamente atribuídas por padrão.  Por exemplo, salvar o pressionamento de tecla <code>s</code> é sinônimo de <code>cl</code> (salvar um pressionamento de tecla) e <code>U</code> é o mesmo que <code>u</code> , exceto para escrever desfazer como uma nova alteração, que é funcionalmente inútil.  <code>Q</code> idêntico ao <code>gQ</code> e, de qualquer forma, é uma tremenda armadilha.  <code>Z</code> usado apenas para <code>ZZ</code> e <code>ZQ</code> .  Puxa, até o manual do Vim recomenda reatribuir as teclas <code>_</code> e para algumas funções, porque "você provavelmente nunca as usa".  Eu preferiria não salvar um clique, mas adicionar funções completamente novas ao teclado.  Aqui estão algumas das minhas ligações: <br><br><h4>  nnoremap Q @@ </h4><br>  Sem desacelerar a transição para o modo ex, repete a última macro. <br><br><h4>  nnoremap s "_d </h4><br>  Faz com que a tecla <code>s</code> (com as configurações apropriadas para <code>ss</code> e <code>S</code> ) funcione como d, apenas sem salvar o texto excluído no registro.  Útil para não entupir o registro. <br><br><h4>  nnoremap &lt;cj&gt; &lt;cw&gt; j </h4><br>  Vá para a janela abaixo.  Designações apropriadas para <code>h</code> , <code>k</code> , <code>l</code> .  Trabalhar com o Windows é muito mais fácil. <br><br><h4>  nnoremap &lt;líder&gt; e: exe getline (linha ('.')) &lt;cr&gt; </h4><br>  Execute a linha atual como se fosse um comando.  Em experimentos, geralmente é mais conveniente que <code>q:</code> <br><br><h2>  Argumentos especiais (: h map-argumentos) </h2><br>  O <code>map &lt;buffer&gt; lhs rhs</code> ativa o mapeamento de chave somente para esse buffer.  Ele realmente funciona convenientemente com comandos automáticos como uma combinação temporária de teclas ou ao definir atribuições por meio de uma função.  As designações de buffer têm precedência sobre as globais, ou seja, você pode substituir o comando geral mais útil em uma situação específica. <br><br>  O <code>map &lt;expr&gt; {lhs} {expr}</code> verifica <code>{expr}</code> e usa o valor de retorno como o remapeamento final das chaves.  Um caso de uso simples é obrigatório com base em condições.  Eu tenho estes: <br><br> <code>nnoremap &lt;expr&gt; k (v:count == 0 ? 'gk' : 'k') <br> nnoremap &lt;expr&gt; j (v:count == 0 ? 'gj' : 'j')</code> <br> <br>  O que faz <code>j</code> e <code>k</code> moverem ao longo da linha <i>até que um</i> número seja encontrado e, depois disso, a tecla é cancelada.  Portanto, posso navegar em longos parágrafos da prosa sem quebrar combinações como <code>10j</code> . <br><br>  O argumento <code>&lt;silent&gt;</code> ajuda se alguma ligação executar comandos ex. <br><br><h2>  inoremaps </h2><br>  Graças ao <code>inoremap</code> ligações funcionam no modo de inserção.  Lá eles começam a trabalhar, então <code>inoremap ;a aaaa</code> apresentará 'aaaa' em vez de '; a'.  Se você quiser fazer algo no modo normal, use <code>&lt;cO&gt;</code> .  Por exemplo, se tivermos <br><br> <code>inoremap ;1 &lt;co&gt;ma</code> <br> <br>  então <code>;1</code> definirá <code>'a</code> . <br><br>  Eu gosto de especificar o uso de ponto e vírgula como uma chave para reatribuições, porque em textos normais quase sempre há um espaço ou uma nova linha após o ponto e vírgula. <br><br><h2>  autocmd </h2><br>  Comandos automáticos são ótimos para configuração.  Geralmente você os configura assim: <br><br><pre> <code class="plaintext hljs">augroup {name} autocmd! " Prevents duplicate autocommands au {events} {file regex} {command} augroup END</code> </pre> <br>  Então, se algum dos eventos {events} ocorrer no arquivo {file regex}, o comando {command} será acionado.  Os eventos estão listados <code>:h event</code> .  Por exemplo, se você escrever <br><br><pre> <code class="plaintext hljs">augroup every autocmd! au InsertEnter * set norelativenumber au InsertLeave * set relativenumber augroup END</code> </pre> <br>  o vim desativará o número relativo apenas para o modo de inserção. <br><br>  O comando <code>au {event} &lt;buffer&gt; {ex}</code> aplica o comando auto apenas ao buffer atual.  Às vezes eu uso isso para adicionar manipuladores de eventos de curto prazo a um arquivo específico. <br><br><h3>  BufNewFile, BufRead </h3><br>  <code>BufnewFile</code> inicia quando um novo arquivo é criado, <code>BufRead</code> - quando o buffer é aberto pela primeira vez.  Eles geralmente são usados ​​para adicionar parâmetros e remaps a tipos de arquivos específicos.  Eu tenho um desses: <br><br><pre> <code class="plaintext hljs">augroup md autocmd! au BufNewFile,BufRead *.md syntax keyword todo TODO au BufNewFile,BufRead *.md inoremap &lt;buffer&gt; ;` ```&lt;cr&gt;&lt;cr&gt;```&lt;Up&gt;&lt;Up&gt; augroup END</code> </pre> <br>  Somente nos arquivos Markdown a linha TODO é destacada e os caracteres <code>;`</code> no modo de inserção adicionam uma notação de código. <br><br>  As equipes automáticas permitem que você faça coisas muito mais complexas.  Por exemplo, <code>au</code> para <code>BufWriteCmd</code> substitui o salvamento padrão, permitindo implementar a lógica personalizada.  Isso vai além dos "truques" e entra no reino da "magia negra". <br><br><h2>  Plugins </h2><br>  A maioria das pessoas conhece plugins populares como o <code>vim-surround</code> e o <code>NERDtree</code> .  Aqui está uma lista de alguns pouco conhecidos que acho muito úteis. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Undotree</a> </h3><br>  Na maioria dos editores de texto, as ações de desfazer ocorrem linearmente.  Se você fizer uma alteração em A, desfaça-a e faça uma alteração em B, então A será perdido para sempre.  No entanto, o Vim armazena toda a árvore de ações desfeitas.  O comando <code>u</code> reverte a ação no galho de árvore atual e <code>g</code> vai para a versão <i>cronológica</i> anterior.  Você pode visualizar a lista de ações canceladas com o comando <code>:undolist</code> . <br><br>  Mas esse formato não é muito claro.  É muito melhor ver a árvore real.  É exatamente isso que o <code>Undotree</code> faz: apresenta uma boa representação ASCII da árvore de ações canceladas com navegação conveniente. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vim.swap</a> </h3><br>  O plug-in fornece comandos para a troca de argumentos, para que você possa substituir <code>(a, f(b, c))</code> por <code>(f(b, c), a)</code> em algumas teclas.  Eu regularmente tenho que fazer essas edições, então essa é uma grande melhoria na qualidade de vida. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Neoterm</a> </h3><br>  Conecta uma API de nível superior ao terminal incorporado neo / vim.  Por exemplo <code>:T {text}</code> envia {text} para o console.  Bom para criar um ambiente interativo. <br><br><h2>  "TODO {{{ </h2><br>  Muitos tópicos não são abordados neste artigo porque são muito técnicos ou precisam ser explicados em detalhes, como a gravação de funções ou o sistema de sintaxe.  E eu não sei muito.  Gostaria de estudar os seguintes tópicos com mais detalhes: <br><br><h3>  Janelas de visualização, Quickfix e lista </h3><br>  Às vezes, uso ferramentas com essas janelas, mas não sei como manipulá-las.  Gostaria de adicionar erros de correção rápida ao meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plug-in TLA +</a> .  Também gosto da ideia de colocar informações de suporte e comandos de retorno de chamada na janela de visualização.  Isso abre algumas possibilidades que são difíceis de reproduzir no IDE. <br><br><h2>  API Neovim </h2><br>  O Neovim oferece uma API avançada para integrar o Vim a programas externos.  Seu script Python pode enviar comandos para a instância do Neovim e você pode controlar o editor através do servidor, por exemplo.  Eu vi algumas demos conceituais interessantes em que o preenchimento automático acontece com base nas informações de um navegador.  Parece ser muito legal! <br><br><h2>  Objetos de texto </h2><br>  Nunca criou tal. <br><br><hr><br>  Portanto, essa foi uma breve visão geral de algumas das funções implícitas do Vim.  Espero que você tenha descoberto algo útil! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454742/">https://habr.com/ru/post/pt454742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454732/index.html">5 técnicas robustas de priorização para equipes de TI</a></li>
<li><a href="../pt454734/index.html">Backup, Parte 4: Visão geral e testes zbackup, restic, borgbackup</a></li>
<li><a href="../pt454736/index.html">Suporte do Visual Studio 2019 no PVS-Studio</a></li>
<li><a href="../pt454738/index.html">Suporte do Visual Studio 2019 no PVS-Studio</a></li>
<li><a href="../pt454740/index.html">Maio 2019 Joomla Digest</a></li>
<li><a href="../pt454744/index.html">Visão geral dos relatórios de trilha Java da conferência RigaDevDays</a></li>
<li><a href="../pt454748/index.html">Guia de sobrevivência do MongoDB</a></li>
<li><a href="../pt454750/index.html">UI rápida - galopando pela Europa</a></li>
<li><a href="../pt454754/index.html">Quando vale a pena checar a hipótese de não menos eficácia?</a></li>
<li><a href="../pt454756/index.html">Verificando a eficácia do site e das configurações de publicidade, o custo de atrair clientes da empresa atacadista</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>