<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õΩÔ∏è ‚ôªÔ∏è ‚ú≥Ô∏è Divulga√ß√£o de mem√≥ria do kernel no sistema operacional moderno üìì üë®üèæ‚Äç‚öñÔ∏è üåù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Debaixo do cortador, est√° a tradu√ß√£o da parte inicial do documento Detectando a divulga√ß√£o da mem√≥ria do kernel com emula√ß√£o x86 e rastreamento de man...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Divulga√ß√£o de mem√≥ria do kernel no sistema operacional moderno</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415685/"><p> Debaixo do cortador, est√° a tradu√ß√£o da <strong>parte inicial do</strong> documento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Detectando a divulga√ß√£o da mem√≥ria do kernel com emula√ß√£o x86 e rastreamento de manchas</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo Projeto Zero</a> ), por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mateusz Jurczyk</a> . </p><br><p>  Na parte traduzida do documento: </p><br><ul><li>  Espec√≠ficos da linguagem de programa√ß√£o C (como parte do problema de expans√£o de mem√≥ria) </li><li>  os detalhes da opera√ß√£o dos kernels Windows e Linux (como parte do problema de expans√£o de mem√≥ria) </li><li>  import√¢ncia da divulga√ß√£o da mem√≥ria do kernel e impacto na seguran√ßa do SO </li><li>  m√©todos e t√©cnicas existentes para detectar e combater a divulga√ß√£o da mem√≥ria do kernel </li></ul><br><p>  Embora o documento enfoque os mecanismos de comunica√ß√£o entre o kernel privilegiado do SO e os aplicativos do usu√°rio, a ess√™ncia do problema pode ser generalizada para qualquer transfer√™ncia de dados entre diferentes dom√≠nios de seguran√ßa: o hipervisor √© a m√°quina convidada, o servi√ßo privilegiado do sistema (daemon) √© o aplicativo da GUI, o cliente da rede √© o servidor etc. . </p><br><p><img src="https://habrastorage.org/webt/ne/uy/1q/neuy1q8npc2ba-y3vcaycx9kqxe.jpeg" alt="KDPV"></p><a name="habracut"></a><br><h2 id="vvedenie">  1. Introdu√ß√£o </h2><br><p>  Uma das tarefas dos sistemas operacionais modernos √© garantir a separa√ß√£o de privil√©gios entre aplicativos do usu√°rio e o kernel do sistema operacional.  Em primeiro lugar, isso inclui o fato de que a influ√™ncia de cada programa no tempo de execu√ß√£o deve ser limitada por uma determinada pol√≠tica de seguran√ßa e, em segundo lugar, que os programas podem acessar apenas as informa√ß√µes que t√™m permiss√£o para ler.  O segundo √© dif√≠cil de fornecer, dadas as propriedades da linguagem C (a principal linguagem de programa√ß√£o usada no desenvolvimento do kernel), que torna extremamente dif√≠cil a transfer√™ncia segura de dados entre diferentes dom√≠nios de seguran√ßa. </p><br><p>  Os sistemas operacionais modernos que operam nas plataformas x86 / x86-64 s√£o multithread e usam um modelo cliente-servidor no qual os aplicativos no modo usu√°rio (clientes) s√£o executados independentemente e chamam o kernel do SO (servidor) com a inten√ß√£o de trabalhar com um recurso gerenciado pelo sistema.  O mecanismo usado pelo c√≥digo do modo de usu√°rio ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anel 3</a> ) para chamar um conjunto predefinido de fun√ß√µes do kernel (anel 0) √© chamado de chamadas do sistema ou (brevemente) syscalls.  Uma chamada t√≠pica do sistema √© mostrada na Figura 1: <br><img src="https://habrastorage.org/webt/dh/p3/hr/dhp3hruaqmh7onhd0mweycvv4bg.png" alt="Figura 1: Chamada do sistema"><br>  <em>Figura 1: Ciclo de vida das chamadas do sistema.</em> </p><br><p>  √â muito importante evitar o vazamento inadvertido do conte√∫do da mem√≥ria do kernel ao interagir com programas no modo de usu√°rio.  Existe um risco significativo de divulgar dados confidenciais do kernel.  Os dados podem ser transmitidos implicitamente nos par√¢metros de sa√≠da de chamadas do sistema seguras (de outros pontos de vista). </p><br><p>  A divulga√ß√£o da mem√≥ria privilegiada do sistema ocorre quando o kernel do sistema operacional retorna uma regi√£o de mem√≥ria maior (excesso) do que o necess√°rio para armazenar as informa√ß√µes correspondentes (contidas dentro).  Os bytes frequentemente redundantes cont√™m dados que foram preenchidos em um contexto diferente e, em seguida, a mem√≥ria n√£o foi pr√©-inicializada, o que impediria a dissemina√ß√£o de informa√ß√µes em novas estruturas de dados. </p><br><h2 id="specifika-yazyka-programmirovaniya-c">  Espec√≠ficos da linguagem de programa√ß√£o C </h2><br><p>  Nesta se√ß√£o, examinamos v√°rios aspectos da linguagem C que s√£o mais importantes para o problema de expans√£o de mem√≥ria. </p><br><h4 id="neopredelennoe-sostoyanie-neinicializirovannyh-peremennyh">  Estado indefinido de vari√°veis ‚Äã‚Äãn√£o inicializadas </h4><br><p>  Vari√°veis ‚Äã‚Äãindividuais de tipos simples (como char ou int), bem como membros de estruturas de dados (matrizes, estruturas e uni√µes) permanecem em um estado indefinido at√© a primeira inicializa√ß√£o (independentemente de serem colocadas na pilha ou na pilha).  Cita√ß√µes relevantes da especifica√ß√£o C11 (ISO / IEC 9899: 201x Comit√™ N1570, abril de 2011): </p><br><blockquote>  6.7.9 Inicializa√ß√£o <br>  ... <br>  10 Se um objeto com dura√ß√£o de armazenamento autom√°tico n√£o for inicializado explicitamente, <u>seu valor ser√° indeterminado</u> . <br><br>  7.22.3.4 A fun√ß√£o malloc <br>  ... <br>  2 A fun√ß√£o malloc aloca espa√ßo para um objeto cujo tamanho √© especificado por tamanho e <u>cujo valor √© indeterminado</u> . <br><br>  7.22.3.5 A fun√ß√£o realloc <br>  ... <br>  2 A fun√ß√£o realloc desaloca o objeto antigo apontado por ptr e retorna um ponteiro para um novo objeto que possui o tamanho especificado por tamanho.  O conte√∫do do novo objeto deve ser o mesmo que o do objeto antigo antes da desaloca√ß√£o, at√© o menor dos tamanhos novo e antigo.  Quaisquer bytes no novo objeto al√©m do tamanho do objeto antigo <u>t√™m valores indeterminados</u> . </blockquote><p>  A parte que se aplica ao c√≥digo do sistema √© mais relevante para os objetos localizados na pilha, pois o kernel do SO geralmente possui interfaces de aloca√ß√£o din√¢mica com sua pr√≥pria sem√¢ntica (n√£o necessariamente compat√≠vel com a biblioteca C padr√£o, como ser√° descrito mais adiante). </p><br><p>  At√© onde sabemos, nenhum dos tr√™s compiladores C mais populares para Windows e Linux (Microsoft C / C ++ Compiler, gcc, LLVM) cria c√≥digo que pr√©-inicializa vari√°veis ‚Äã‚Äãn√£o inicializadas por programadores na pilha no modo Release-build (ou equivalente).  Existem op√ß√µes do compilador para marcar quadros de pilha com bytes especiais - marcadores (/ RTCs no Microsoft Visual Studio, por exemplo), mas eles n√£o s√£o usados ‚Äã‚Äãnas vers√µes do Release por motivos de desempenho.  Como resultado, vari√°veis ‚Äã‚Äãn√£o inicializadas na pilha <em>herdam os</em> valores antigos das √°reas de mem√≥ria correspondentes. </p><br><p>  Considere um exemplo de implementa√ß√£o padr√£o de uma chamada de sistema fict√≠cia do Windows que multiplica um n√∫mero inteiro de entrada por dois e retorna o resultado da multiplica√ß√£o (Listagem 1).  Obviamente, no caso especial (InputValue == 0), a vari√°vel OutputValue permanece n√£o inicializada e √© copiada de volta para o cliente.  Este erro permite abrir quatro bytes de mem√≥ria da pilha do kernel para cada chamada. </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtMultiplyByTwo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD InputValue, LPDWORD OutputPointer)</span></span></span><span class="hljs-function"> </span></span>{ DWORD OutputValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InputValue != <span class="hljs-number"><span class="hljs-number">0</span></span>) { OutputValue = InputValue * <span class="hljs-number"><span class="hljs-number">2</span></span>; } *OutputPointer = OutputValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listagem de c√≥digo 1: Expandindo a mem√≥ria por meio de uma vari√°vel local n√£o inicializada.</em> </p><br><p>  Os vazamentos atrav√©s de uma vari√°vel local n√£o inicializada n√£o s√£o muito comuns na pr√°tica: por um lado, os compiladores modernos frequentemente detectam e alertam sobre esses problemas; por outro lado, esses vazamentos s√£o erros funcionais que podem ser detectados durante o desenvolvimento ou o teste.  No entanto, o segundo exemplo (na Listagem 2) mostra que um vazamento tamb√©m pode ocorrer atrav√©s do campo de estrutura. </p><br><p>  Nesse caso, o campo de estrutura reservada nunca √© explicitamente usado no c√≥digo, mas ainda √© copiado para o modo de usu√°rio e, portanto, tamb√©m exp√µe quatro bytes de mem√≥ria do kernel ao c√≥digo de chamada.  Este exemplo mostra claramente que inicializar cada campo de cada estrutura retornada ao cliente para todas as ramifica√ß√µes da execu√ß√£o de c√≥digo n√£o √© uma tarefa f√°cil.  Em muitos casos, a inicializa√ß√£o for√ßada parece il√≥gica, especialmente se esse campo n√£o desempenhar nenhum papel pr√°tico.  Mas √© o fato de que uma vari√°vel n√£o inicializada (ou campo de estrutura) na pilha (ou na pilha) aceita o conte√∫do dos dados armazenados anteriormente nessa √°rea de mem√≥ria (no contexto de outra opera√ß√£o), est√° no cora√ß√£o do problema de expans√£o de mem√≥ria do kernel. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSCALL_OUTPUT</span></span></span><span class="hljs-class"> {</span></span> DWORD Sum; DWORD Product; DWORD Reserved; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtArithOperations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; OutputStruct.Product = InputValue * <span class="hljs-number"><span class="hljs-number">2</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listagem 2: Expandindo a mem√≥ria atrav√©s de um campo de estrutura reservado.</em> </p><br><h4 id="vyravnivanie-struktur-i-zapolnyayuschie-padding-bayty">  Alinhamento de estruturas e bytes de preenchimento </h4><br><p>  A inicializa√ß√£o de todos os campos da estrutura de sa√≠da √© um bom come√ßo para evitar a expans√£o da mem√≥ria.  Mas isso n√£o √© suficiente para garantir que na representa√ß√£o de baixo n√≠vel n√£o haja bytes n√£o inicializados.  Vamos voltar √† especifica√ß√£o C11: </p><br><blockquote>  6.5.3.4 Os operadores sizeof e Alignof <br>  ... <br>  4 [...] Quando aplicado a um operando que possui estrutura ou tipo de uni√£o, o resultado √© o n√∫mero total de bytes desse objeto, <u>incluindo preenchimento interno e √† direita</u> . <br><br>  6.2.8 Alinhamento de objetos <br>  1 Os tipos de objetos completos t√™m requisitos de alinhamento que <u>imp√µem restri√ß√µes aos endere√ßos nos quais os objetos desse tipo podem ser alocados</u> .  Um alinhamento √© um valor inteiro integrado definido pela implementa√ß√£o que representa o n√∫mero de bytes entre endere√ßos sucessivos nos quais um determinado objeto pode ser alocado.  [...] <br><br>  6.7.2.1 Especi Ô¨Å cadores de estrutura e uni√£o <br>  ... <br>  17 <u>Pode haver preenchimento sem nome no final de uma estrutura ou uni√£o</u> . </blockquote><p>  Ou seja, os compiladores da linguagem C para arquiteturas x86 (-64) usam o alinhamento natural dos campos de estruturas (com um tipo primitivo): cada um desses campos √© alinhado por N bytes, onde N √© o tamanho do campo.  Al√©m disso, estruturas e jun√ß√µes inteiras tamb√©m s√£o alinhadas quando declaradas em uma matriz, e o requisito para alinhamento de campos aninhados √© atendido.  Para garantir o alinhamento, bytes de preenchimento impl√≠cito s√£o inseridos nas estruturas, quando necess√°rio.  Embora n√£o estejam diretamente acess√≠veis no c√≥digo-fonte, esses bytes tamb√©m herdam valores antigos das √°reas de mem√≥ria e podem transmitir informa√ß√µes para o modo de usu√°rio. </p><br><p>  No exemplo da Listagem 3, a estrutura SYSCALL_OUTPUT √© retornada de volta ao c√≥digo de chamada.  Ele cont√©m campos de 4 e 8 bytes, separados por 4 bytes de preenchimento, necess√°rios para que o endere√ßo do campo LargeSum se torne um m√∫ltiplo de 8.  Apesar de ambos os campos terem sido inicializados corretamente, os bytes de preenchimento n√£o s√£o definidos explicitamente, o que novamente leva √† expans√£o da mem√≥ria da pilha do kernel.  A localiza√ß√£o espec√≠fica da estrutura na mem√≥ria √© mostrada na Figura 2. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSCALL_OUTPUT</span></span></span><span class="hljs-class"> {</span></span> DWORD Sum; QWORD LargeSum; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtSmallSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; OutputStruct.LargeSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listagem 3: Expandindo a mem√≥ria alinhando a estrutura.</em> </p><br><p><img src="https://habrastorage.org/webt/pw/i1/1a/pwi11anmkjf_ujlkogv2bjmbsuo.png" alt="Figura 2: Alinhando a estrutura"><br>  Figura 2: Representa√ß√£o da estrutura na mem√≥ria com o alinhamento em mente. </p><br><p>  Vazamentos atrav√©s de alinhamentos s√£o relativamente comuns, pois muitos par√¢metros de sa√≠da de chamadas do sistema s√£o representados por estruturas.  O problema √© especialmente grave para plataformas de 64 bits, onde o tamanho dos ponteiros, size_t e tipos semelhantes aumenta de 4 para 8 bytes, o que leva ao aparecimento de preenchimento necess√°rio para alinhar os campos dessas estruturas. </p><br><p>  Como os bytes de preenchimento n√£o podem ser endere√ßados no c√≥digo-fonte, √© necess√°rio usar o memset ou uma fun√ß√£o semelhante para redefinir toda a √°rea de mem√≥ria da estrutura antes de inicializar qualquer um de seus campos e copi√°-lo para o modo de usu√°rio, por exemplo: </p><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;OutputStruct, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(OutputStruct));</code> </pre> <br><p>  No entanto, o Seacord RC em seu livro "The CERT C Coding Standard, Segunda Edi√ß√£o: 98 Regras para o Desenvolvimento de Sistemas Seguros, Confi√°veis ‚Äã‚Äãe Seguros. Addison-Wesley Professional" 2014 afirma que essa n√£o √© uma solu√ß√£o ideal porque o preenchimento de bytes ) ainda pode ser <em>desativado</em> depois de chamar memset, por exemplo, como um efeito colateral de opera√ß√µes com campos adjacentes.  A preocupa√ß√£o pode ser justificada pela seguinte declara√ß√£o na especifica√ß√£o C: </p><br><blockquote>  6.2.6 Representa√ß√µes de tipos <br>  6.2.6.1 Geral <br>  ... <br>  6 <u>Quando um valor √© armazenado em um objeto de estrutura ou tipo de uni√£o</u> , inclusive em um objeto membro, os bytes da representa√ß√£o do objeto que correspondem a <u>quaisquer bytes de preenchimento recebem valores n√£o especificados</u> .  [...] </blockquote><p>  No entanto, na pr√°tica, nenhum dos compiladores C testados lemos ou gravamos fora das √°reas de mem√≥ria dos campos declarados explicitamente.  Parece que essa opini√£o √© compartilhada pelos desenvolvedores de sistemas operacionais que usam memset. </p><br><h4 id="obedineniya-unions-i-polya-raznogo-razmera">  Uni√µes e campos de tamanhos diferentes </h4><br><p>  As jun√ß√µes s√£o outra constru√ß√£o complexa da linguagem C no contexto da comunica√ß√£o com c√≥digo de chamada menos privilegiado.  Considere como a especifica√ß√£o C11 descreve a representa√ß√£o de uni√µes na mem√≥ria: </p><br><blockquote>  6.2.5 Tipos <br>  ... <br>  20 Qualquer n√∫mero de tipos derivados pode ser constru√≠do a partir dos tipos de objeto e fun√ß√£o, como segue: [...] <u>Um tipo de uni√£o descreve um conjunto n√£o vazio de objetos membros sobrepostos</u> , cada um dos quais com um nome opcionalmente especificado e um tipo possivelmente distinto. <br><br>  6.7.2.1 Especi Ô¨Å cadores de estrutura e uni√£o <br>  ... <br>  6 Conforme discutido em 6.2.5, uma estrutura √© um tipo que consiste em uma sequ√™ncia de membros, cujo armazenamento √© alocado em uma sequ√™ncia ordenada, e <u>uma uni√£o √© um tipo que consiste em uma sequ√™ncia de membros cujo armazenamento se sobrep√µe</u> . <br>  ... <br>  16 <u>O tamanho de um sindicato √© suficiente para conter o maior de seus membros</u> .  O valor de no m√°ximo um dos membros pode ser armazenado em um objeto de uni√£o a qualquer momento. </blockquote><p>  O problema √© que, se a uni√£o consistir em v√°rios campos de tamanhos diferentes e apenas um campo de tamanho menor for explicitamente inicializado, os bytes restantes alocados para acomodar campos grandes permanecer√£o n√£o inicializados.  Vejamos um exemplo de um manipulador de chamadas do sistema hipot√©tico, mostrado na Listagem 4, junto com a aloca√ß√£o de mem√≥ria de uni√£o SYSCALL_OUTPUT mostrada na Figura 3. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _SYSCALL_OUTPUT { DWORD Sum; QWORD LargeSum; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtSmallSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listagem de c√≥digo 4: Expandindo a mem√≥ria inicializando parcialmente uma uni√£o.</em> </p><br><p><img src="https://habrastorage.org/webt/pa/8y/ck/pa8yckhciassiwm9yc19nssczwo.png" alt="Figura 3: Alinhando uma jun√ß√£o"><br>  <em>Figura 3: Representa√ß√£o da uni√£o na mem√≥ria com alinhamento.</em> </p><br><p>  Acontece que o tamanho total da uni√£o SYSCALL_OUTPUT √© de 8 bytes (devido ao tamanho do campo LargeSum maior).  No entanto, a fun√ß√£o define apenas o valor do campo menor, deixando 4 bytes √† direita n√£o inicializados, o que posteriormente leva a um vazamento no aplicativo cliente. </p><br><p>  Uma implementa√ß√£o segura deve definir apenas o campo Soma no espa√ßo de endere√ßo do usu√°rio e n√£o copiar o objeto inteiro com √°reas de mem√≥ria potencialmente n√£o utilizadas.  Outra corre√ß√£o de trabalho √© chamar a fun√ß√£o memset para anular uma c√≥pia da uni√£o na mem√≥ria do kernel antes de definir qualquer um de seus campos e transferi-la de volta ao modo de usu√°rio. </p><br><h4 id="nebezopasnyy-sizeof">  Tamanho inseguro </h4><br><p>  Conforme mostrado nas duas se√ß√µes anteriores, o uso do operador sizeof pode contribuir direta ou indiretamente para revelar a mem√≥ria do kernel, fazendo com que mais dados sejam copiados do que o inicializado anteriormente. </p><br><p>  C n√£o possui o aparato necess√°rio para transferir com seguran√ßa os dados do kernel para o espa√ßo do usu√°rio - ou, mais geralmente, entre contextos de seguran√ßa diferentes.  O idioma n√£o cont√©m metadados de tempo de execu√ß√£o que podem indicar explicitamente quais bytes foram definidos em cada estrutura de dados usada para interagir com o kernel do SO.  Como resultado, a responsabilidade recai sobre o programador, que deve determinar quais partes de cada objeto devem ser passadas para o c√≥digo de chamada.  Se feito corretamente, voc√™ precisar√° escrever uma fun√ß√£o de c√≥pia segura separada para cada estrutura de sa√≠da usada nas chamadas do sistema.  O que, por sua vez, levar√° a um incha√ßo no tamanho do c√≥digo, a uma deteriora√ß√£o de sua legibilidade e, em geral, ser√° uma tarefa tediosa e demorada. </p><br><p>  Por outro lado, √© conveniente e simples copiar toda a √°rea de mem√≥ria do kernel com uma √∫nica chamada de mem√≥ria e o argumento sizeof, al√©m de permitir que o cliente determine quais partes da sa√≠da ser√£o usadas.  Acontece que essa abordagem √© usada hoje em Windows e Linux.  E quando um caso espec√≠fico de vazamento de informa√ß√µes √© detectado, um patch com uma chamada memset √© imediatamente fornecido e distribu√≠do pelo fabricante do SO.  Infelizmente, isso n√£o resolve o problema no caso geral. </p><br><h2 id="specifika-konkretnyh-os">  Espec√≠ficos do SO </h2><br><p>  Existem certas solu√ß√µes de design de kernel, m√©todos de programa√ß√£o e padr√µes de c√≥digo que afetam a tend√™ncia do sistema operacional a vulnerabilidades de expans√£o de mem√≥ria.  Eles s√£o considerados nas seguintes subse√ß√µes. </p><br><h4 id="pereispolzovanie-dinamicheskoy-pamyati">  Reutilizando a mem√≥ria din√¢mica </h4><br><p>  Os alocadores atuais de mem√≥ria din√¢mica (no modo de usu√°rio e no kernel) s√£o altamente otimizados, pois seu desempenho tem um impacto significativo no desempenho de todo o sistema.  Uma das otimiza√ß√µes mais importantes √© a reutiliza√ß√£o da mem√≥ria: quando liberada, a mem√≥ria correspondente raramente √© completamente descartada; em vez disso, √© salva na lista de regi√µes prontas para serem retornadas na pr√≥xima vez em que for alocada.  Para salvar os ciclos da CPU, as √°reas de mem√≥ria padr√£o n√£o s√£o limpas entre a desaloca√ß√£o e a nova aloca√ß√£o.  Como resultado disso, duas partes desconectadas do kernel trabalham com o mesmo intervalo de mem√≥ria por um curto per√≠odo de tempo.  Isso significa que o vazamento do conte√∫do da mem√≥ria din√¢mica do kernel permite revelar os dados de v√°rios componentes do sistema operacional. </p><br><p>  Nos par√°grafos seguintes, apresentamos uma breve vis√£o geral dos alocadores usados ‚Äã‚Äãnos kernels do Windows e Linux e suas qualidades mais not√°veis. </p><br><p>  <strong>Windows</strong> <br>  A fun√ß√£o principal do gerenciador de pool de kernel do Windows √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ExAllocatePoolWithTag</a> , que pode ser chamada diretamente ou atrav√©s de um dos shells dispon√≠veis: ExAllocatePool {‚àÖ, Ex, WithQuotaTag, WithTagPriority}.  Nenhuma dessas fun√ß√µes libera o conte√∫do da mem√≥ria retornada, por padr√£o ou atrav√©s de qualquer sinalizador de entrada.  Pelo contr√°rio, todos eles t√™m o seguinte aviso na respectiva documenta√ß√£o do MSDN: </p><br><blockquote>  Nota A mem√≥ria que a fun√ß√£o aloca n√£o √© inicializada.  Um driver no modo kernel deve zerar essa mem√≥ria primeiro para torn√°-la vis√≠vel para o software no modo usu√°rio (para evitar vazamentos de conte√∫do potencialmente privilegiado). </blockquote><p>  O c√≥digo de chamada pode selecionar um dos seis principais tipos de conjuntos: NonPagedPool, NonPagedPoolNx, NonPagedPoolSession, NonPagedPoolSessionNx, PagedPool e PagedPoolSession.  Cada um deles possui uma regi√£o separada no espa√ßo de endere√ßo virtual e, portanto, as √°reas de mem√≥ria alocadas podem ser reutilizadas apenas no mesmo tipo de pool.  A frequ√™ncia de reutiliza√ß√£o de peda√ßos de mem√≥ria √© muito alta e as √°reas zeradas geralmente s√£o retornadas apenas se um registro adequado n√£o for encontrado nas listas de lookaside ou se a solicita√ß√£o for t√£o grande que novas p√°ginas de mem√≥ria sejam necess√°rias.  Em outras palavras, atualmente n√£o h√° praticamente nenhum fator que impe√ßa a divulga√ß√£o da mem√≥ria do pool no Windows, e quase todos esses erros podem ser usados ‚Äã‚Äãpara vazar dados confidenciais de diferentes partes do kernel. </p><br><p>  <strong>Linux</strong> <br>  O kernel do Linux possui tr√™s interfaces principais para alocar mem√≥ria dinamicamente: </p><br><ul><li>  <strong>kmalloc</strong> - uma fun√ß√£o comum usada para alocar blocos de mem√≥ria de tamanho arbitr√°rio (cont√≠nuo no espa√ßo de endere√ßo virtual e f√≠sico), usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aloca√ß√£o de mem√≥ria de laje</a> . </li><li>  <strong>kmem_cache_create</strong> e <strong>kmem_cache_alloc</strong> - um mecanismo especializado para alocar objetos de tamanho fixo (estruturas, por exemplo), tamb√©m usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aloca√ß√£o de mem√≥ria de laje</a> . </li><li>  <strong>O vmalloc</strong> √© uma fun√ß√£o de aloca√ß√£o raramente usada que retorna regi√µes cuja continuidade n√£o √© garantida no n√≠vel da mem√≥ria f√≠sica. </li></ul><br><p>  Essas fun√ß√µes (por si s√≥) n√£o garantem que as regi√µes selecionadas n√£o contenham dados antigos (potencialmente confidenciais), o que possibilita abrir a mem√≥ria do heap do kernel.  No entanto, existem v√°rias maneiras pelas quais o c√≥digo de chamada pode solicitar mem√≥ria nula: </p><br><ul><li>  A fun√ß√£o <strong>kmalloc</strong> possui um an√°logo do <strong>kzalloc</strong> , o que garante que a mem√≥ria retornada seja limpa. </li><li>  O sinalizador opcional __GFP_ZERO pode ser passado para <strong>kmalloc</strong> , <strong>kmem_cache_alloc</strong> e algumas outras fun√ß√µes para obter o mesmo resultado. </li><li>  <strong>kmem_cache_create</strong> aceita um ponteiro para uma fun√ß√£o construtora opcional que √© chamada para pr√©-inicializar cada objeto antes de retorn√°-lo ao c√≥digo de chamada.  O construtor pode ser implementado como um wrapper em torno de um memset para zerar uma determinada √°rea de mem√≥ria. </li></ul><br><p>  Vemos a disponibilidade dessas op√ß√µes como condi√ß√µes favor√°veis ‚Äã‚Äã√† seguran√ßa do kernel, pois incentivam os desenvolvedores a tomar decis√µes informadas e permitem que eles simplesmente trabalhem com as fun√ß√µes de aloca√ß√£o de mem√≥ria existentes, em vez de adicionar chamadas memset adicionais ap√≥s cada aloca√ß√£o de mem√≥ria din√¢mica. </p><br><h4 id="massivy-fiksirovannogo-razmera">  Matrizes de tamanho fixo </h4><br><p>  O acesso a v√°rios recursos do sistema operacional pode ser obtido por seus nomes de teste.  A variedade de recursos nomeados no Windows √© muito grande, por exemplo: arquivos e diret√≥rios, chaves e valores de chaves do registro, janelas, fontes e muito mais.  Para alguns deles, o comprimento do nome √© limitado e √© expresso por uma constante, como MAX_PATH (260) ou LF_FACESIZE (32).  Nesses casos, os desenvolvedores do kernel geralmente simplificam o c√≥digo declarando os buffers de tamanho m√°ximo e copiando-os como um todo (por exemplo, usando a palavra-chave sizeof) em vez de trabalhar apenas com a parte correspondente da linha.  Isso √© especialmente √∫til se as strings forem membros de estruturas maiores.  Esses objetos podem ser movidos livremente na mem√≥ria sem se preocupar em gerenciar ponteiros para a mem√≥ria din√¢mica. </p><br><p>  Como seria de esperar, buffers grandes raramente s√£o usados ‚Äã‚Äãcompletamente e o espa√ßo de armazenamento restante geralmente n√£o √© liberado.  Isso pode levar a vazamentos particularmente graves de longas √°reas cont√≠guas da mem√≥ria do kernel.  No exemplo da Listagem 5, a chamada do sistema usa a fun√ß√£o RtlGetSystemPath para carregar o caminho do sistema no buffer local e, se a chamada for bem-sucedida, todos os 260 bytes ser√£o passados ‚Äã‚Äãpara o chamador, independentemente do comprimento real da linha. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtGetSystemPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PCHAR OutputPath)</span></span></span><span class="hljs-function"> </span></span>{ CHAR SystemPath[MAX_PATH]; NTSTATUS Status; Status = RtlGetSystemPath(SystemPath, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SystemPath)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NT_SUCCESS(Status)) { RtlCopyMemory(OutputPath, SystemPath, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SystemPath)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status; }</code> </pre> <br><p>  <em>Listagem 5: Expandindo a mem√≥ria inicializando parcialmente o buffer de cadeia.</em> </p><br><p>  A regi√£o da mem√≥ria copiada de volta para o espa√ßo do usu√°rio neste exemplo √© mostrada na Figura 4. </p><br><p><img src="https://habrastorage.org/webt/ki/8j/5z/ki8j5zyo73i5k4o12grlolwsrhk.png" alt="Figura 4: Mem√≥ria de buffer de seq√º√™ncia inicializada"><br>  <em>Figura 4: Mem√≥ria de um buffer de linha parcialmente inicializado.</em> </p><br><p>  Uma implementa√ß√£o segura deve retornar apenas o caminho solicitado, e n√£o o buffer inteiro usado para armazenamento.  Este exemplo mais uma vez demonstra como a estimativa do tamanho dos dados com o operador sizeof (usado como par√¢metro para RtlCopyMemory) pode estar completamente incorreta com rela√ß√£o √† quantidade real de dados que o kernel deve passar para a √°rea do usu√°rio. </p><br><h4 id="proizvolnyy-razmer-vyhodnyh-dannyh-sistemnogo-vyzova">  Tamanho da sa√≠da da chamada do sistema arbitr√°rio </h4><br><p>  A maioria das chamadas do sistema aceita ponteiros para a sa√≠da do modo de usu√°rio, juntamente com o tamanho do buffer.  Na maioria dos casos, as informa√ß√µes de tamanho devem ser usadas apenas para determinar se o buffer fornecido √© suficiente para receber a sa√≠da de chamada do sistema.  N√£o use o tamanho inteiro do buffer de sa√≠da fornecido para especificar a quantidade de mem√≥ria a ser copiada.  No entanto, vemos casos em que o kernel tenta usar todos os bytes do buffer de sa√≠da do usu√°rio, sem contar a quantidade de dados reais que precisam ser copiados.  Um exemplo desse comportamento √© mostrado na Listagem 6. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtMagicValues</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPDWORD OutputPointer, DWORD OutputLength)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OutputLength &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(DWORD)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_BUFFER_TOO_SMALL; } LPDWORD KernelBuffer = Allocate(OutputLength); KernelBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0xdeadbeef</span></span>; KernelBuffer[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0xbadc0ffe</span></span>; KernelBuffer[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0xcafed00d</span></span>; RtlCopyMemory(OutputPointer, KernelBuffer, OutputLength); Free(KernelBuffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listagem 6: Expandindo a mem√≥ria por meio de um buffer de sa√≠da de tamanho arbitr√°rio.</em> </p><br><p>  O objetivo de uma chamada do sistema √© fornecer ao c√≥digo de chamada tr√™s valores especiais de 32 bits, ocupando um total de 12 bytes.  Embora a verifica√ß√£o do tamanho correto do buffer no in√≠cio da fun√ß√£o esteja correta, o uso do argumento OutputLength deve terminar a√≠.  Sabendo que o buffer de sa√≠da √© grande o suficiente para salvar o resultado, o kernel pode alocar 12 bytes de mem√≥ria, preench√™-lo e copiar o conte√∫do de volta para o buffer fornecido no modo de usu√°rio.  Em vez disso, uma chamada do sistema aloca um bloco de pool (al√©m disso, com um comprimento controlado pelo usu√°rio) e copia toda a mem√≥ria alocada no espa√ßo do usu√°rio.  Acontece que todos os bytes, exceto os 12 primeiros, n√£o s√£o inicializados e s√£o abertos erroneamente ao usu√°rio, como mostra a Figura 5. </p><br><p><img src="https://habrastorage.org/webt/m7/hy/dj/m7hydjfgkhaqgizxuhr2xcmv8jw.png" alt="Figura 5: Mem√≥ria de buffer arbitr√°ria"><br>  <em>Figura 5: Mem√≥ria buffer de tamanho arbitr√°rio.</em> </p><br><p>  O esquema discutido nesta se√ß√£o √© especialmente comum para o Windows.  Um erro semelhante pode fornecer ao invasor uma primitiva extremamente √∫til para expans√£o de mem√≥ria: </p><br><ul><li> ,      Windows,                  .            ,       . </li><li>              .   ,     ,                .      ,    (   ‚Äî  )  . </li></ul><br><p>  ,        .      ,     ,       . </p><br><h2 id="faktory-sposobstvuyuschie-poyavleniyu-oshibok-raskrytiya-pamyati"> ,      </h2><br><p>     ,           .         ,          Windows    . </p><br><p> <strong>  </strong> <br>  ,       ,   .        ,      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AddressSanitizer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PageHeap</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Special Pool</a> .  , ,   -          .         ,         .   ,         ,       ,           ,        ,       .       <em></em>     ,      (   ). </p><br><p>  ,             ,  ,       .               ,                  . </p><br><p> <strong>,    API</strong> <br>           API,   Windows (Win32/User32 API). API         ,   ,          ,     .     ,  ,        , ,      .              <em></em>  . </p><br><h2 id="znachimost-i-vliyanie-na-bezopasnost-sistemy">       </h2><br><p>   ,             .          ,            .      ,     <em></em>       ,       ,      .        ,         ,    . </p><br><p>  ,      ,          .     ,       KASLR (Kernel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Address Space Layout Randomization</a> ),                .  :   Windows,    Hacking Team   2015  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Juan Vazquez. Revisiting an Info Leak</a> )         (derandomize)     win32k.sys,       . ,         Matt Tait'  Google Project Zero ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kernel-mode ASLR leak via uninitialized memory returned to usermode by NtGdiGetTextMetrics</a> )     MS15-080 (CVE-2015-2433). </p><br><p> <strong></strong> <br>       (/)   ,      ,      (control Ô¨Çow),  :   ,   ,   ,   ,   StackGuard  Linux  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">/GS  Windows</a> .    ,             .        ,   ,            . </p><br><p> <strong>  (/)</strong> <br>    (/)    ,    ,      ,    :  ,   ,  ,     .               ,     ,      .         .  ,         ( ,    )   ,  ,      . </p><br><h2 id="drugie-suschestvuyuschie-issledovaniya">    </h2><br><p><img src="https://habrastorage.org/webt/wp/ky/ap/wpkyap5uiyz52hrghshrxxve1v0.jpeg" alt="KDPV # 2"></p><br><h4 id="microsoft-windows">  Microsoft Windows </h4><br><p> <strong></strong> <br>  2015            Windows.   2015  Matt Tait           win32k!NtGdiGetTextMetrics.          Windows   Hacking Team.   ,      ,       ,    0-day       Windows. </p><br><p>    2015, WanderingGlitch (HP Zero Day Initiative)          ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Acknowledgments ‚Äì 2015</a> ).           Ruxcon 2016 (  )    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Leaking Windows Kernel Pointers"</a> . </p><br><p>  ,   2017 fanxiaocao  pjf  IceSword Lab (Qihoo 360)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Automatically Discovering Windows Kernel Information Leak Vulnerabilities"</a> ,    ,      14   2017  (8      ).        Bochspwn Reloaded,             ,            .        VMware     (Bochs)         .   ,  Bochspwn Reloaded,                . </p><br><p>         ,  ,    2010-2011          ,     win32k: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Challenge: On 32bit Windows7, explain where the upper 16bits of eax come from after a call to NtUserRegisterClassExWOW()"</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Subtle information disclosure in WIN32K.SYS syscall return values"</a> .          Windows 8,   2015  Matt Tait ,           : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google Project Zero Bug Tracker</a> . </p><br><p> <strong></strong> <br>       (   ),  ,    2017   - Windows        -,   : Joseph Bialek ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Anyone notice my change to the Windows IO Manager to generically kill a class of info disclosure? BuÔ¨ÄeredIO output buÔ¨Äer is always zero'd"</a> .      ,  IOCTL-          . </p><br><p>        ,   Visual Studio 15.5   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">POD-</a> ,       "= {0}",   .       ,      padding- ()   . </p><br><h4 id="linux">  Linux </h4><br><p>    Windows,   Linux        ,         2010 .        ,             (  )   (    ) .  ,        Windows  Linux         ,        ‚Äî ,    . </p><br><p> <strong></strong> <br>    ,   Linux       .   "Linux kernel vulnerabilities: State-of-the-art defenses and open problems"   2010    2011   28    .   2017-  "Securing software systems by preventing information leaks" Lu K.    59  ,    2013-   2016-.          . : Rosenberg  Oberheide    25 ,     Linux  2009-2010 ,     .          Linux c <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">grsecurity</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PaX-hardened</a> . Vasiliy Kulikov   25   2010-2011 ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   Coccinelle</a> .  , Mathias Krause <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   21      2013 </a>   50      . </p><br><p>    ,      ,           Linux.     ‚Äî   -Wuninitialized (  gcc,   LLVM),          .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  kmemcheck</a> ,      Valgrind'   .        ,        .         ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">KernelAddressSANitizer</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">KernelMemorySANitizer</a> .      KMSAN    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">syzkaller</a> (   ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> 19    </a> ,        . </p><br><p>               Linux.  2014 ‚Äî 2016  Peir¬¥o      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Coccinelle</a>     ,      Linux  3.12: "Detecting stack based kernel information leaks" International Joint Conference SOCO14-CISIS14-ICEUTE14, pages 321‚Äì331 (Springer, 2014)  "An analysis on the impact and detection of kernel stack infoleaks" Logic Journal of the IGPL.         ,          .  2016- Lu       UniSan ‚Äî   ,    ,                 :   ,   .            ,        20%     (350   1800),      19     Linux  Android. </p><br><p>             ‚Äî    (multi-variant program execution),            ,      .           ,             .     ,  KASLR,   -,         .         ,  2006    DieHard: probabilistic memory safety for unsafe languages,   2017  ‚Äî BUDDY: Securing software systems by preventing information leaks.     John North   "Identifying Memory Address Disclosures" 2015- . ,  SafeInit (Comprehensive and Practical Mitigation of Uninitialized Read Vulnerabilities)  ,          ,            .       , ,   ,        Linux. </p><br><p> <strong></strong> <br>                  ,   .      ,       :     ,        .     ,  , -    ,             .                   . </p><br><p>        CONFIG_PAGE_POISONING  CONFIG_DEBUG_SLAB,       -.       -,      .        , ,  ,       Linux. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">grsecurity</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PaX</a>    .  ,   PAX_MEMORY_SANITIZE   ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">slab</a> ,    (        ‚Äî   ).  ,  PAX_MEMORY_STRUCTLEAK     ,    (  ),       .         padding- (),          100% .  ,      ‚Äî PAX_MEMORY_STACKLEAK,            .      ,      ,        .       (Kernel Self Protection Project)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> STACKLEAK</a>   . </p><br><p>               Linux: </p><br><div class="spoiler"> <b class="spoiler_title">Secure deallocation, Chow  , 2005</b> <div class="spoiler_text"><p> Chow, Jim and PfaÔ¨Ä, Ben and GarÔ¨Ånkel, Tal and Rosenblum, Mendel. Shredding Your Garbage: Reducing Data Lifetime Through Secure Deallocation. In USENIX Security Symposium, pages 22‚Äì22, 2005. </p></div></div><br><p>  ,       ,          ( )  .         Linux     . </p><br><div class="spoiler"> <b class="spoiler_title">Split Kernel, Kurmus  Zippel, 2014</b> <div class="spoiler_text"><p> Kurmus, Anil and Zippel, Robby. A tale of two kernels: Towards ending kernel hardening wars with split kernel. In Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security, pages 1366‚Äì1377. ACM, 2014. </p></div></div><br><p>      ,           . </p><br><div class="spoiler"> <b class="spoiler_title">SafeInit, Milburn  , 2017</b> <div class="spoiler_text"><p> Milburn, Alyssa and Bos, Herbert and GiuÔ¨Ärida, Cristiano. SafeInit: Comprehensive and Practical Mitigation of Uninitialized Read Vulnerabilities. In Proceedings of the 2017 Annual Network and Distributed System Security Symposium (NDSS)(San Diego, CA), 2017. </p></div></div><br><p>         ,      ,         . </p><br><div class="spoiler"> <b class="spoiler_title">UniSan, Lu  , 2016</b> <div class="spoiler_text"><p> Lu, Kangjie and Song, Chengyu and Kim, Taesoo and Lee, Wenke. UniSan: Proactive kernel memory initialization to eliminate data leakages. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, pages 920‚Äì932. ACM, 2016. </p></div></div><br><p>    SafeInit         ,  ,       ,      ,      . </p><br><p>       ,  Linux             . </p><br><h2 id="vmesto-epiloga-ot-perevodchika">   ( ) </h2><br><p>        ,    ,          (      ).  :  (),     , ,    ,   ( - )     .   ,          . , ,        . </p><br><p>     ,             : </p><br><ul><li> Bochspwn Reloaded ‚Äì detection with software x86 emulation </li><li> Windows bug reproduction techniques </li><li> Alternative detection methods </li><li> Other data sinks </li><li> Future work </li><li> Other system instrumentation schemes </li></ul><br><p>  ,     :)          ,       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt415685/">https://habr.com/ru/post/pt415685/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt415675/index.html">Resumo de not√≠cias do PostgreSQL. Edi√ß√£o n√∫mero 8</a></li>
<li><a href="../pt415677/index.html">Cidades em crescimento t√™m dificuldade em mover as massas de pessoas verticalmente e na superf√≠cie</a></li>
<li><a href="../pt415679/index.html">Por que crian√ßas ricas mostram bons resultados em um experimento com marshmallow</a></li>
<li><a href="../pt415681/index.html">A hist√≥ria da cria√ß√£o do int√©rprete de linguagem gestual</a></li>
<li><a href="../pt415683/index.html">Experimente voc√™ mesmo na programa√ß√£o Q #</a></li>
<li><a href="../pt415687/index.html">Fintech Digest: Banco Central obriga os bancos a verificar os dispositivos dos clientes dos quais o dinheiro √© transferido</a></li>
<li><a href="../pt415689/index.html">Jogamos batalha mar√≠tima no BGP</a></li>
<li><a href="../pt415691/index.html">Compara√ß√£o de Classifica√ß√£o do Exchange</a></li>
<li><a href="../pt415693/index.html">Oumuamua. Chegou, perplexo, voou para longe (e n√£o prometeu voltar). E um dia desses Mais uma vez intrigado</a></li>
<li><a href="../pt415695/index.html">O Google admitiu que tamb√©m queria comprar o GitHub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>