<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧤 🤾 🤶🏿 我们阅读了数据手册2：STM32上的SPI; STM8上的PWM定时器和中断 🍯 👩‍👩‍👦 🐽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在第一部分中，我试图告诉那些从Arduino裤子成长出来的电子爱好者，以及为什么他们应该阅读数据表和其他微控制器文档。 结果文本很大，所以我答应在另一篇文章中显示实际示例。 好吧，他称自己为货物... 


 今天，我将展示如何在STM32（蓝色药丸）和STM8控制器上使用数据表来解决相当简单的任务...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们阅读了数据手册2：STM32上的SPI; STM8上的PWM定时器和中断</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/456094/"><p><img src="https://habrastorage.org/webt/zz/sh/fd/zzshfdfytuphbmlregcazfpxo2a.jpeg"></p><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分中，</a>我试图告诉那些从Arduino裤子成长出来的电子爱好者，以及为什么他们应该阅读数据表和其他微控制器文档。 结果文本很大，所以我答应在另一篇文章中显示实际示例。 好吧，他称自己为货物... </p><br><p> 今天，我将展示如何在STM32（蓝色药丸）和STM8控制器上使用数据表来解决相当简单的任务，但对于许多项目而言却是必需的。 所有演示项目都专用于我最喜欢的LED，我们将大量点亮它们，为此，我们将不得不使用各种有趣的外围设备。 </p><a name="habracut"></a><br><p> 文字再次变大了，为方便起见，我在做内容： </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">STM32蓝色药丸：16个带DM634驱动器的LED</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">STM8：配置六个PWM引脚</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">STM8：三个引脚上的8个RGB LED，中断</a> </p><br><p>  <em>免责声明：我不是工程师，我不假装对电子产品有深入的了解，因此该文章适用于像我这样的恋人。</em>  <em>实际上，两年前，我以自己为目标受众。</em>  <em>如果有人告诉我，在不熟悉的芯片上阅读数据表并不令人害怕，我将不会花费很多时间在Internet上搜索一些代码，并用剪刀和创可贴发明拐杖。</em> </p><br><p>  <em>本文的重点是数据表，而不是项目，因此代码可能不会过于梳理，而且经常受到限制。</em>  <em>尽管适合初次接触新芯片，但项目本身非常简单。</em> </p><br><p>  <em>我希望我的文章可以帮助处于类似阶段的人进行业余爱好潜水。</em> </p><br><h1 id="stm32">  STM32 </h1><br><h1 id="16-svetodiodov-c-dm634-i-spi">  16个带DM634和SPI的LED </h1><br><p> 一个使用Blue Pill（STM32F103C8T6）和DM634 LED驱动器的小项目。 借助数据表，我们将处理驱动程序，IO端口STM和配置SPI。 </p><br><h2 id="dm634">  DM634 </h2><br><p> 台湾芯片具有16个16位PWM输出，可以成串连接。 最年轻的12位模型以国内项目<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lightpack闻名</a> 。 一次，我在DM63x和著名的TLC5940之间进行选择，我选择了DM，原因有以下几个：1）Aliexpress上的TLC绝对是假的，但事实并非如此；  2）DM具有一个带有自己的频率发生器的自治PWM；  3）它可以在莫斯科便宜地购买，而不必等待与阿里的包裹。 好吧，当然，有趣的是学习如何自己管理芯片，而不是使用现成的库。 现在，这些芯片主要采用SSOP24封装，易于焊接至适配器。 </p><br><p> 由于制造商是台湾人，因此该芯片的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据表</a>用中文英文书写，这很有趣。 首先，查看<em>引脚连接</em> （ <em>Pin Connection</em> ）以了解要连接到的支脚以及<em>引脚说明</em> （ <em>Pin Description</em> ）。  16结论： </p><br><p><img src="https://habrastorage.org/webt/uj/n8/mo/ujn8mooelrxoxg7xzvvfsdh4er8.png"><br>  <sup>流入直流电源（漏极开路）</sup> </p><br><p>  <strong>水槽</strong> / <strong>漏极开路输出</strong> -漏极; 流入电流源； 有源输出接地-LED通过阴极连接到驱动器。 从电气上来说，这当然不是“开漏”，但在数据手册中，通常以漏电模式来指定输出。 </p><br><p><img src="https://habrastorage.org/webt/yk/bq/p4/ykbqp4ivabirkgahd2d7l_9gjny.png"><br>  <sup>REXT和GND之间的外部电阻可设置输出电流值</sup> </p><br><p> 在REXT引脚和地之间安装了一个基准电阻，该电阻控制输出的内部电阻，请参见数据表第9页的图表。 在DM634中，也可以通过设置<em>全局亮度</em>来以编程方式控制该电阻； 我不会在本文中详细介绍，我只是在此处放置了一个2.2-3 kOhm的电阻器。 </p><br><p> 要了解如何控制芯片，请查看设备接口的说明： </p><br><p><img src="https://habrastorage.org/webt/7s/5n/to/7s5ntogguqr1yb6fu2l5pchaob8.png"></p><br><p> 是的，这就是中国英语的全部荣耀。 翻译是有问题的，您可以根据需要理解，但是还有另一种方法-查看数据表中与功能紧密的TLC5940的连接描述方式： </p><br><p><img src="https://habrastorage.org/webt/qi/za/j2/qizaj2wq08ppbzehiszsd2spqz8.png"><br>  <sub>...仅需三个引脚即可将数据输入设备。</sub>  <sub>SCLK信号的上升沿将数据从SIN引脚移至内部寄存器。</sub>  <sub>下载完所有数据后，短高XLAT信号将捕获内部寄存器中的串行数据。</sub>  <sub>内部寄存器-XLAT触发的闸阀。</sub>  <sub>所有数据都以最高有效位发送。</sub> </p><br><p>  <strong>闩锁</strong> -闩锁/闩锁/夹具。 <br>  <strong>上升沿</strong> -脉冲的前沿 <br>  <strong>MSB优先</strong> - <strong>最高有效</strong> （最左边）位向前。 <br>  <strong>时钟数据</strong> -顺序（按位）传输数据。 </p><br><p>  <em>闩锁一词</em>经常在芯片的文档中找到，并以各种方式进行翻译，因此，我将让我自己理解 </p><div class="spoiler">  <b class="spoiler_title">小型教育计划</b> <div class="spoiler_text">  LED驱动器本质上是一个移位寄存器。 名称中的“移位”是设备内部数据的按位移动：向内推入的每个新位都将整个链推向自己的前面。 由于没有人希望观察移位期间LED的混乱闪烁，因此该过程在通过<em>锁存器</em>与工作寄存器分开的缓冲寄存器中进行-这是一种等待室，其中按所需顺序排列位。 一切准备就绪后，百叶窗将打开，并且将位发送至工作位置，以替换前一批。 无论使用哪种组合，微电路文档中的“ <em>闩锁</em> ”一词几乎总是暗示着这种阻尼器。 </div></div><br><p> 因此，向DM634的数据传输如下：将DAI输入设置为远端LED的高位，上下拉DCK； 将DAI输入设置为下一位，拉DCK。 依此类推，直到所有位都发送完（ <em>送入</em> ），然后拉LAT。 这可以手动完成（ <em>bit-bang</em> ），但最好为此使用经过改进的SPI接口，因为它在我们的STM32中有两个副本。 </p><br><h2 id="sinyaya-tabletka-stm32f103"> 蓝色平板电脑STM32F103 </h2><br><p> 简介：STM32控制器比Atmega328复杂得多，令人恐惧。 同时，出于节能的考虑，几乎所有外围设备在启动时都被禁用，并且时钟频率从内部来源为8 MHz。 幸运的是，STM程序员编写了将芯片提高到“计算出的” 72 MHz的代码，并且我所知道的所有IDE的作者都将其包括在初始化过程中，因此我们不需要计时（但是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您可以，如果您确实愿意的话</a> ）。 但是您必须打开外围设备。 </p><br><p> 文档：Blue Pill上安装了流行的STM32F103C8T6芯片，有两个有用的文档： </p><br><ul><li>  STM32F103x8和STM32F103xB微控制器的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据手册</a> ; </li><li> 整个STM32F103系列及更高版本的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参考手册</a> 。 </li></ul><br><p> 在数据表中，我们可能感兴趣： </p><br><ul><li> 引脚排列-芯片引脚排列-如果我们决定自己制作电路板； </li><li> 内存映射-特定芯片的存储卡。 在《参考手册》中，有一张整行的卡，其中列出了我们不在的寄存器。 </li><li> 表引脚定义-列出引脚的主要功能和替代功能； 对于Internet上的“蓝色药丸”，您可以找到带有引脚列表及其功能的更方便的图片。 因此，请立即在“蓝色药丸”引脚图上用Google搜索，并保留此图片： </li></ul><br><p><img src="https://habrastorage.org/webt/_q/q_/o4/_qq_o4hwzc3k1nzqluqtaqpuye0.png"><br>  <em>注意：在互联网上的图片中，评论中发现了一个错误，对此表示感谢。</em>  <em>图片已被替换，但这是一个教训-最好检查非数据表中的信息。</em> </p><br><p> 我们删除数据表，打开参考手册，现在我们只使用它。 <br> 程序：我们处理标准输入/输出，配置SPI，打开所需的外设。 </p><br><h3 id="vvod-vyvod"> 输入输出 </h3><br><p>  Atmega328 I / O非常简单，这就是为什么大量STM32选项会造成混淆的原因。 现在我们只需要得出结论，但是甚至有四个选择： </p><br><p><img src="https://habrastorage.org/webt/qv/ao/t6/qvaot6ql0b4z6c0bvv71dumovji.png"><br>  <sub>开漏输出，推挽输出，备用推挽输出，备用开漏</sub> </p><br><p>  “ <em>推挽</em> ”（ <em>push-pull</em> ）-Arduina的常见结论是，引脚可以为HIGH或LOW。 但是，尽管存在“开漏”的问题，但实际上仍然很简单： </p><br><p><img src="https://habrastorage.org/webt/qa/e-/al/qae-alom88ushdmghd8wcu2l0q4.png"><br><img src="https://habrastorage.org/webt/en/oh/ny/enohnyxpb5u8cs4_t_m-cmtxbwy.png"><br>  <sub>输出配置/当端口分配给输出时：/输出缓冲器打开：/-开漏模式：“ 0”激活输出寄存器中的N-MOS，“ 1”使端口保留在输出寄存器中的Hi-Z模式（未激活P-MOS ）/-“推-推”模式：输出寄存器中的“ 0”激活N-MOS，输出寄存器中的“ 1”激活P-MOS。</sub> </p><br><p> 开漏和<em>推挽</em>之间的所有区别是，在第一个引脚中它不能接受高电平状态：当将一个单元写入输出寄存器时，它将切换到<em>高阻抗</em> <em>-Z</em> ）。 记录零时，两种模式下的引脚在逻辑上和电气上的行为均相同。 </p><br><p> 在正常输出模式下，该引脚仅转换输出寄存器的内容。 在“替代”中，它由相应的外围设备控制（请参见9.1.4）： </p><br><p><img src="https://habrastorage.org/webt/wu/mz/fv/wumzfvlk-fueikoig1wg6npj59u.png"><br>  <sub>如果端口位配置为备用功能输出，则禁用输出寄存器，并且该引脚连接到外设输出信号</sub> </p><br><p>  <em>引脚定义</em>数据表中描述了每个引脚的替代功能，该功能位于下载的图片中。 当被问及如果引脚具有几种替代功能该怎么办时，答案在数据表中给出了脚注： </p><br><p><img src="https://habrastorage.org/webt/g1/hq/mi/g1hqmixkcdtdiius8u45hjfzagy.png"><br>  <sub>如果多个外设单元使用同一引脚，为了避免其他功能之间的冲突，一次只能使用一个外设单元，并使用外设时钟激活位（在相应的RCC寄存器中）进行切换。</sub> </p><br><p> 最后，处于输出模式的引脚也具有时钟速度。 这是另一个节能功能，在我们的案例中，我们只需将其设置为最大值，然后将其忘记即可。 </p><br><p> 因此：我们使用SPI，因此两个引脚（带有数据和时钟信号）应为“另一种推挽功能”，而另一个（LAT）应为“正常推挽”功能。 但是在分配它们之前，我们将处理SPI。 </p><br><h3 id="spi">  SPI </h3><br><div class="spoiler">  <b class="spoiler_title">另一个小型教育计划</b> <div class="spoiler_text"><p>  SPI或串行外围设备接口（串行外围设备接口）-一种简单且非常有效的接口，用于与其他MK和通常与外界的通信。 上面已经描述了其工作原理，其中涉及中文LED驱动器（在参考手册中，请参见第25节）。  SPI可以在主机（“主机”）和从机（“从机”）模式下运行。  SPI具有四个基本通道，但可能不涉及所有这些通道： </p><br><ul><li>  MOSI，主机输出/从机输入：该引脚在主机模式下发送，但在从机模式下接收数据。 </li><li>  MISO，主机输入/从机输出：相反，在主机中接受，在从机中-给出； </li><li>  SCK，串行时钟：设置主机中数据传输的频率或从机中接收时钟信号。 本质上是跳动； </li><li>  SS，从机选择：通过该通道，从机得知他们希望从中获得某些东西。 在STM32上，它称为NSS，其中N =负，即 如果该通道接地，则控制器将成为从属。 与漏极开路输出模式很好地结合在一起，但这是另一回事。 </li></ul></div></div><br><p> 像其他所有内容一样，STM32上的SPI也具有丰富的功能，这使其在某种程度上难以理解。 例如，它不仅可以与SPI一起使用，而且还可以与I2S接口一起使用，并且在文档中它们的描述混杂在一起，您需要及时消除多余的内容。 我们的任务非常简单：您只需要使用MOSI和SCK发送数据。 我们转到第25.3.4节（半双工通信），在其中找到<em>1个时钟和1个单向数据线</em> （1个时钟信号和1个单向数据流）： </p><br><p><img src="https://habrastorage.org/webt/3o/wg/pm/3owgpmokhpahr9rkftf5ns2lclw.png"><br>  <sub>在这种模式下，应用程序在仅发送或仅接收模式下使用SPI。</sub>  <sub>/仅发送模式类似于双工模式：数据在发送引脚上发送（主模式下为MOSI，从模式下为MISO），接收引脚（分别为MISO或MOSI）可以用作常规输入输出引脚。</sub>  <sub>在这种情况下，应用程序忽略Rx缓冲区就足够了（如果读取它，将不会传输任何数据）。</sub> </p><br><p> 好吧，MISO引脚是免费的，让我们将LAT信号连接到它。 我们将讨论Slave Select，它可以在STM32上以编程方式进行控制，这非常方便。 我们在SPI一般说明的第25.3.1节中阅读了同名的段落： </p><br><p><img src="https://habrastorage.org/webt/8t/ng/jf/8tngjfopfxskwyq_gl8tlogcp2o.png"><br>  <sub>NSS程序控制（SSM = 1）/有关选择从站的信息包含在寄存器SPI_CR1的SSI位中。</sub>  <sub>外部NSS引脚保持空闲状态以用于其他应用需求。</sub> </p><br><p> 现在该写寄存器了。 我决定使用SPI2，我们正在数据表中寻找基地址-在3.3内存映射部分： </p><br><p><img src="https://habrastorage.org/webt/os/xd/6p/osxd6pdv5zfwombf5xflzfikj5c.png"></p><br><p> 好，我们开始： </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI2_(mem_offset) (*(volatile uint32_t *)(0x40003800 + (mem_offset)))</span></span></code> </pre> <br><p> 我们打开第25.3.3节，上面写着“在主模式下配置SPI”： </p><br><p><img src="https://habrastorage.org/webt/s8/ah/o5/s8aho5pbdv55j5vhhwecvewrm3m.png"></p><br><p>  <strong>1.通过SPI_CR1寄存器中的BR [2：0]位设置串行时钟速度。</strong> </p><br><p> 寄存器收集在同名的参考手册部分。  CR1的<em>地址偏移量</em> （ <em>Address offset</em> ）为0x00，默认情况下，所有位都将重置（ <em>重置值</em> 0x0000）： </p><br><p><img src="https://habrastorage.org/webt/vt/46/um/vt46umrvbimjon75durupo3zsao.png"></p><br><p>  BR位设置控制器时钟分频器，从而确定SPI工作的频率。  STM32的频率为72 MHz，根据其数据表，LED驱动器的最高频率为25 MHz，因此您需要将其分为4个（BR [2：0] = 001）。 </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_CR1 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_0 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_1 0x0010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_2 0x0020 _SPI2_ (_SPI_CR1) |= BR_0;</span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// pclk/4</span></span></span></span></code> </pre> <br><p>  <strong>2.将CPOL和CPHA位置1，以确定数据传输和串行接口时钟之间的关系（请参见第240页的图）</strong> </p><br><p> 由于我们在这里阅读数据表，而不考虑电路，因此，让我们更好地研究第704页上的CPOL和CPHA位的文字说明（SPI通用说明）： </p><br><p><img src="https://habrastorage.org/webt/2h/pj/in/2hpjinoa65388hdfarcc9lwnqok.png"><br>  <sub>时钟相位和极性</sub> <sub><br></sub>  <sub>使用SPI_CR1寄存器的CPOL和CPHA位，可以通过编程选择四个时序关系选项。</sub>  <sub>当没有数据传输时，CPOL（时钟极性）位控制时钟的状态。</sub>  <sub>该位控制主模式和从模式。</sub>  <sub>如果CPOL复位，则空闲模式下SCK引脚为低电平。</sub>  <sub>如果CPOL位置1，则SCK引脚在空闲模式下为高电平。</sub> <sub><br></sub>  <sub>如果将CPHA位（时钟相位）置1，则SCK信号的第二个边沿充当高位的陷阱门（如果CPOL被清除，则下降，如果CPOL被置位，则上升）。</sub>  <sub>时钟信号的第二次变化捕获数据。</sub>  <sub>如果CPHA位被清零，则SCK信号的上升沿用作高位的陷阱门（如果置位CPOL，则下降；如果清零CPOL，则上升。</sub>  <sub>时钟信号的第一次变化会捕获数据。</sub> </p><br><p> 掌握了这些知识之后，我们得出结论，两个位都必须保持为零，因为 我们需要SCK信号在不使用时保持低电平，并沿脉冲的前沿传输数据（请参见DM634数据表中的上升沿）。 </p><br><p> 顺便说一句，在这里我们首先遇到了ST数据表中的词汇功能：例如，在Atmega中，短语“将位重置为零”被写入<em>来重置位</em>而不<em>清除位</em> 。 </p><br><p>  <strong>3.将DFF位置1以定义8位或16位数据块格式。</strong> </p><br><p> 我专门采用了16位DM634，以免像DM633那样困扰12位PWM数据的传输。  DFF放入一个单元很有意义： </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DFF 0x0800 _SPI2_ (_SPI_CR1) |= DFF; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 16-bit mode</span></span></span></span></code> </pre> <br><p>  <strong>4.配置寄存器SPI_CR1中的LSBFIRST位，以确定块格式</strong> </p><br><p> 顾名思义，LSBFIRST将低位设置为正向。 但是DM634希望从高位开始接收数据。 因此，我们将其丢弃。 </p><br><p>  <strong>5.在硬件模式下，如果需要从NSS引脚输入，则在整个字节传输序列期间向NSS引脚发送高电平信号。</strong>  <strong>在NSS编程模式下，将寄存器SPI_CR1中的SSM和SSI位置1。</strong>  <strong>如果NSS引脚应在输出端工作，则仅必须将SSOE位置1。</strong> </p><br><p> 安装SSM和SSI可以忽略NSS硬件模式： </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSI 0x0100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSM 0x0200 _SPI2_ (_SPI_CR1) |= SSM | SSI; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//enable software control of SS, SS high</span></span></span></span></code> </pre> <br><p>  <strong>6.必须将MSTR和SPE位置1（仅当NSS施加高电平信号时，它们才保持设置状态）</strong> </p><br><p> 实际上，通过这些位，我们将SPI分配为主设备并将其打开： </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MSTR 0x0004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPE 0x0040 _SPI2_ (_SPI_CR1) |= MSTR; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//SPI master //  ,  SPI _SPI2_ (_SPI_CR1) |= SPE;</span></span></span></span></code> </pre> <br><p> 配置了SPI，让我们编写一些函数，这些函数立即将字节发送到驱动程序。 我们继续阅读25.3.3“在主模式下配置SPI”： </p><br><p><img src="https://habrastorage.org/webt/sb/rg/u5/sbrgu5xwvaj7vc8a9rk2guxfdeq.png"><br>  <sub>数据传输程序</sub> <sub><br></sub>  <sub>当一个字节被写入发送缓冲器时，传输开始。</sub> <sub><br></sub>  <sub>在发送第一个位期间，数据字节以<strong>并行</strong>模式（从内部总线）加载到移位寄存器中，然后以<strong>串行</strong>模式发送到MOSI引脚，第一个或最后一位向前，具体取决于寄存器CPI_CR1中LSBFIRST位的设置。</sub>  <sub>数据<strong>从Tx缓冲区</strong>传输<strong>到移位寄存器</strong>后，TXE标志被置1，如果CPI_CR1寄存器中的TXEIE位置1，也会产生中断。</sub> </p><br><p> 我在翻译中突出了几个单词，以引起人们对STM控制器中SPI实现的一项功能的关注。 在Atmega上，仅在整个字节都<em>耗尽</em>后才设置TXE标志（ <em>Tx空</em> ，Tx空，准备接收数据）。 在此字节被推入内部移位寄存器后，此标志置位。 由于所有位同时（并行）被推送到那里，然后依次发送数据，因此在完全发送字节之前设置TXE。 这很重要，因为 对于我们的LED驱动器，我们需要在发送<em>所有</em>数据后拉LAT引脚，即 仅TXE标志对我们来说还不够。 </p><br><p> 这意味着我们需要其他标志。 让我们在25.3.7中看到“状态标志”： </p><br><p><img src="https://habrastorage.org/webt/_d/vn/jj/_dvnjjudvkmdyutpylvwfkfknng.png"><br>  &lt;...&gt; <br><img src="https://habrastorage.org/webt/3y/wv/nd/3ywvndaij5blabzqfq2n6wzdbfe.png"><br>  <sub>忙标志</sub> <sub><br></sub>  <sub>BSY标志由硬件设置和重置（对其进行写入不会产生任何影响）。</sub>  <sub>BSY标志指示SPI通信层的状态。</sub> <sub><br></sub>  <sub>重置：</sub> <sub><br></sub>  <sub>传输完成时（主模式除外，如果传输是连续的）</sub> <sub><br></sub>  <sub>禁用SPI时</sub> <sub><br></sub>  <sub>发生向导模式错误时（MODF = 1）</sub> <sub><br></sub>  <sub>如果传输不连续，则在每次数据传输之间清除BSY标志。</sub> </p><br><p> 好吧，派上用场。 我们找出发送缓冲区的位置。 为此，请阅读“ SPI数据寄存器”： </p><br><p><img src="https://habrastorage.org/webt/sj/gk/o7/sjgko7dcnefgkio4jk9xrwt67bs.png"><br>  <sub>位15：0 DR [15：0]数据寄存器</sub> <sub><br></sub>  <sub>接收到的数据或要传输的数据。</sub> <sub><br></sub>  <sub>数据寄存器分为两个缓冲区-一个用于写（发送缓冲区），另一个用于读（接收缓冲区）。</sub>  <sub>写入数据寄存器将写入Tx缓冲区，而从数据寄存器读取将返回Rx缓冲区中包含的值。</sub> </p><br><p> 好，状态寄存器中有TXE和BSY标志： </p><br><p><img src="https://habrastorage.org/webt/-k/pi/q9/-kpiq96tkpbqvvr1vly6nlzpwoe.png"></p><br><p> 我们写： </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_DR 0x0C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_SR 0x08 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BSY 0x0080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TXE 0x0002 void dm_shift16(uint16_t value) { _SPI2_(_SPI_DR) = value; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//send 2 bytes while (!(_SPI2_(_SPI_SR) &amp; TXE)); //wait until they're sent }</span></span></span></span></code> </pre> <br><p> 好吧，由于我们需要两次发送16个字节，这取决于LED驱动器的输出数量，如下所示： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendLEDdata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LAT_low(); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> k = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { k--; dm_shift16(leds[k]); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_SPI2_(_SPI_SR) &amp; BSY); <span class="hljs-comment"><span class="hljs-comment">// finish transmission LAT_pulse(); }</span></span></code> </pre> <br><p> 但是我们仍然不知道如何拉LAT引脚，因此我们将返回I / O。 </p><br><h3 id="naznachaem-piny"> 分配针脚 </h3><br><p> 在STM32F1中，负责引脚状态的寄存器非常少见。 显然，它们比Atmega还要多，但它们也不同于其他STM芯片。 第9.1节GPIO概述： </p><br><p><img src="https://habrastorage.org/webt/ky/w9/ks/kyw9ksdar6bepxsf1u7kvyejfwm.png"><br>  <sub>每个通用输入/输出端口<em>（GPIO）</em>都有两个32位配置寄存器（GPIOx_CRL和GPIOx_CRH），两个32位数据寄存器（GPIOx_IDR和GPIOx_ODR），一个32位设置/复位寄存器（GPIOx_BSRR），16位复位寄存器（GPIOx_BRR）和32位块寄存器（GPIOx_LCKR）。</sub> </p><br><p> 前两个寄存器不寻常且不方便，因为16个端口引脚散布在它们上面，格式为“每位兄弟四位”。 即 从零到第七的引脚在CRL中，其余的引脚在CRH中。 同时，其余寄存器成功地放入了端口所有引脚的位中-通常只剩下一半“保留”。 </p><br><p> 为简单起见，请从列表末尾开始。 </p><br><p> 我们不需要块寄存器。 </p><br><p> 设置和复位寄存器很有趣，因为它们彼此部分复制：您只能在BSRR中写入所有内容，其中高16位会将引脚复位为零，而低位-设置为1，或者也使用BRR，低16位只能复位引脚。 。 我喜欢第二种选择。 这些寄存器很重要，因为它们提供了对引脚的原子访问： </p><br><p><img src="https://habrastorage.org/webt/tr/g9/tq/trg9tqg8ksmhfiaokjbslfvvhny.png"><br><img src="https://habrastorage.org/webt/yb/dm/da/ybdmdaayb-f0np1pawunxobfbaa.png"><br>  <sub>原子安装或重置</sub> <sub><br></sub>  <sub>在位级别上对GPIOx_ODR进行编程时，您无需禁用中断：您可以通过一个原子写操作APB2来更改一个或多个位。</sub>  <sub>通过向设置/复位寄存器（GPIOx_BSRR或仅用于复位的GPIOx_BRR）中写入要更改的位来实现“ 1”。</sub>  <sub>其他位将保持不变。</sub> </p><br><p> 数据寄存器的名称非常明确-IDR = <em>输入</em>方向寄存器，输入寄存器；  ODR = <em>输出</em>方向寄存器，输出寄存器。 在当前项目中，我们将不需要它们。 </p><br><p> 最后，控制寄存器。 由于我们对第二个SPI的引脚PB13，PB14和PB15感兴趣，因此我们立即查看CRH： </p><br><p><img src="https://habrastorage.org/webt/ei/_v/it/ei_vitm85yhwasuf5zjbhksfsoq.png"></p><br><p> 而且我们看到有必要从20号到31号逐位写一些东西。 </p><br><p> 我们已经弄清楚了想要从引脚获得什么，因此在这里我可以不用截图就可以说MODE设置了方向（输入，如果两个位都设置为0）和引脚速度（我们需要50MHz，即都引脚设置为“ 1”），CNF设置模式：普通的“推-推”-00，“替代”-10。默认情况下，如我们上面所见，所有引脚的底部都是第三个位（CNF0），它将其设置为<em>浮动输入</em>模式。 </p><br><p> 由于我计划对该芯片做其他事情，为简单起见，我为上下控制寄存器定义了所有可能的MODE和CNF值。 </p><br><div class="spoiler">  <b class="spoiler_title">好吧，像这样</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_1 0x20000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_1 0x20000000</span></span></code> </pre> </div></div><br><p> 我们的引脚位于端口B（基本地址为0x40010C00）上，代码： </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _PORTB_(mem_offset) (*(volatile uint32_t *)(0x40010C00 + (mem_offset))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BRR 0x14 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BSRR 0x10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRL 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRH 0x04 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  SPI2: MOSI  B15, CLK  B13 //LAT     MISO – B14 //  ,      _PORTB_ (_CRH) &amp;= ~(CNF15_0 | CNF14_0 | CNF13_0 | CNF12_0); //   MOSI  SCK _PORTB_ (_CRH) |= CNF15_1 | CNF13_1; //50 , MODE = 11 _PORTB_ (_CRH) |= MODE15_1 | MODE15_0 | MODE14_1 | MODE14_0 | MODE13_1 | MODE13_0;</span></span></span></span></code> </pre> <br><p> 并且，因此，您可以为LAT编写定义，这将使寄存器BRR和BSRR跳动： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*** LAT pulse – high, then low */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_pulse() _PORTB_(_BSRR) = (1&lt;&lt;14); _PORTB_(_BRR) = (1&lt;&lt;14) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_low() _PORTB_(_BRR) = (1&lt;&lt;14)</span></span></code> </pre> <br><p>  （LAT_low只是由于惯性而已，某种程度上一直如此，让自己留下来） </p><br><p> 现在一切都已经很好，只是无法正常工作。 因为它是STM32，所以可以节省电力，这意味着您需要为必需的外围设备启用时钟。 </p><br><h2 id="vklyuchaem-taktirovanie"> 开启计时 </h2><br><p> 时钟负责计时，它们也是时钟。 我们已经可以看到缩写RCC。 我们正在文档中寻找它：这是“复位和时钟控制”。 </p><br><p> 如上文所述，幸运的是，STM的人员为我们完成了时间安排主题中最困难的部分，对此他们表示非常感谢（再次，我将提供一个指向<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Di Halt网站</a>的链接，以明确这是多么<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">混乱</a> ）。 我们只需要负责启用外设时钟的寄存器（Peripheral Clock Enable Registers）。 首先，找到RCC的基址，它位于“存储卡”的开头： </p><br><p><img src="https://habrastorage.org/webt/r5/ad/jt/r5adjtnefym8toywwtuxwls-s8e.png"></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _RCC_(mem_offset) (*(volatile uint32_t *)(0x40021000 + (mem_offset)))</span></span></code> </pre> <br><p> 然后，单击链接以尝试在板上找到某些东西，或者，更好的是，从<em>使能寄存器</em>的各部分中对包含寄存器的描述进行遍历。 我们在哪里找到RCC_APB1ENR和RCC_APB2ENR： </p><br><p><img src="https://habrastorage.org/webt/bt/e7/_6/bte7_6icypsiop8tvagswdtfdpe.png"><br><img src="https://habrastorage.org/webt/pr/d0/l1/prd0l1e_vckbrxqk83wso_h9t5k.png"></p><br><p> 其中的位分别包括时钟SPI2，IOPB（I / O端口B）和替代功能（AFIO）。 </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB2ENR 0x18 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB1ENR 0x1C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IOPBEN 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPI2EN 0x4000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AFIOEN 0x0001 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   B  .  _RCC_(_APB2ENR) |= IOPBEN | AFIOEN; //  SPI2 _RCC_(_APB1ENR) |= SPI2EN;</span></span></span></span></code> </pre> <br><p> 最终代码可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到。 </p><br><p> 如果有机会并希望进行测试，则可以将DM634这样连接：DAI到PB15，DCK到PB13，LAT到PB14。 我们从5伏特给驱动器供电，别忘了将地结合起来。 </p><br><p><img src="https://habrastorage.org/webt/sx/bz/va/sxbzvazmpgcgwsl0o5pt90gzlnm.jpeg"></p><br><h1 id="stm8-pwm">  STM8 PWM </h1><br><h1 id="shim-na-stm8">  STM8上的PWM </h1><br><p> 例如，当我计划本文时，我决定尝试仅使用数据表来学习不熟悉的芯片的某些功能，以便在没有引导程序的情况下无法获得引导程序。  STM8非常适合这个角色：首先，我有几块带有STM8S103的中文主板，其次，它不是很流行，因此，在互联网上阅读和查找解决方案的诱惑在于缺乏这些解决方案。 </p><br><p> 该芯片还有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据表</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参考手册RM0016</a> ，第一个是引脚排列，第二个是寄存器地址-其他。  STM8在难看的IDE <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ST Visual Develop</a>中用C <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编程</a> 。 </p><br><h3 id="taktirovanie-i-vvod-vyvod"> 时钟和I / O </h3><br><p> 默认情况下，STM8的工作频率为2 MHz，必须立即将其固定。 </p><br><p><img src="https://habrastorage.org/webt/h-/w7/hc/h-w7hclj1kovrmig-mxtjj-n62k.png"><br>  <sub>HSI时钟（内部速度）</sub> <sub><br></sub>  <sub>HSI时钟从内部带有可编程分频器（1至8）的16 MHz RC振荡器获得。</sub>  <sub>它在时钟分频器的寄存器（CLK_CKDIVR）中设置。</sub> <sub><br></sub>  <sub>注意：首先，选择带分频器8的HSI RC振荡器作为主要时钟源。</sub> </p><br><p> 我们在数据表中找到了寄存器地址，在refman中进行了描述，并看到需要清除寄存器： </p><br><pre> <code class="plaintext hljs">#define CLK_CKDIVR *(volatile uint8_t *)0x0050C6 CLK_CKDIVR &amp;= ~(0x18);</code> </pre> <br><p> 因为我们要启动PWM并连接LED，所以我们看一下引脚： </p><br><p><img src="https://habrastorage.org/webt/uv/ii/kt/uviikt-bigbrftn_ivjxx681d8e.png"></p><br><p> 该芯片很小，许多功能都挂在同一引脚上。 方括号中的内容是“替代功能”，它由“ <em>选项字节</em> ”切换-类似于Atmega的保险丝。 您可以通过编程方式更改其值，但这不是必需的，因为 仅在重新启动后才能激活新功能。 使用ST Visual Programmer（与Visual Develop一起下载）可以更轻松地更改这些字节。 引脚排列显示，第一个计时器的CH1和CH2的结论隐藏在方括号中； 必须将STFR中的AFR1和AFR0位置1，第二个定时器还将第二个定时器的CH1的输出从PD4传输到PC5。 </p><br><p> 因此，有6个引脚将控制LED：第一个计时器为PC6，PC7和PC3，第二个为PC5，PD3和PA3。 </p><br><p> 与STM32相比，在STM8上配置I / O引脚本身更简单，更合理： </p><br><ul><li> 熟悉Atmega <em>数据方向寄存器</em> ：1 =输出； </li><li> 输出端的第一控制寄存器CR1设置推挽模式（1）或开漏（0）； 由于我将LED与带有阴极的芯片相连，因此我在此处保留零。 </li><li> 输出处的第二个控制寄存器CR2设置时钟速度：1 = 10 MHz </li></ul><br><pre> <code class="plaintext hljs">#define PA_DDR *(volatile uint8_t *)0x005002 #define PA_CR2 *(volatile uint8_t *)0x005004 #define PD_DDR *(volatile uint8_t *)0x005011 #define PD_CR2 *(volatile uint8_t *)0x005013 #define PC_DDR *(volatile uint8_t *)0x00500C #define PC_CR2 *(volatile uint8_t *)0x00500E PA_DDR = (1&lt;&lt;3); //output PA_CR2 |= (1&lt;&lt;3); //fast PD_DDR = (1&lt;&lt;3); //output PD_CR2 |= (1&lt;&lt;3); //fast PC_DDR = ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //output PC_CR2 |= ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //fast</code> </pre> <br><h2 id="nastroyka-shim">  PWM设置 </h2><br><p> 首先，让我们定义术语： </p><br><ul><li>  <strong>PWM频率</strong> -计时器滴答的频率； </li><li>  <strong>自动重载，AR-</strong>计时器将计数到的<strong>自动重载</strong>值（脉冲周期）； </li><li>  <strong>UEV更新事件</strong> -计时器计入AR <strong>时发生</strong>的事件； </li><li>  <strong>PWM占空比-PWM</strong>占空比，通常称为“占空比”； </li><li>  <strong>捕获/比较值</strong> - <strong>捕获/比较的值</strong> ，已经计数到定时器<em>将要执行的操作</em> （对于PWM，它将反转输出信号）； </li><li>  <strong>预加载值</strong> -预加载值。 计时器计时时， <em>比较值</em>不能更改，否则PWM周期将中断。 因此，当定时器到达计数结束并复位时，新的发送值将被放入缓冲区并从缓冲区中拉出。 </li><li>  <strong>边缘对齐</strong>和<strong>中心对齐模式</strong> -边界和<strong>中心对齐</strong> ，与Atmelovskie <em>快速PWM</em>和<em>相位校正PWM相同</em> 。 </li><li>  <strong>OCiREF，输出比较参考信号</strong> -实际上，PWM模式下的参考输出信号位于相应的引脚上。 </li></ul><br><p> 从引脚上已经可以清楚地看到，两个定时器具有PWM功能-第一个和第二个。 两者均为16位，第一个具有许多附加功能（尤其是它可以向上和向下计数）。 我们两个都需要以相同的方式工作，所以我决定从明显较差的第二个开始，以免意外使用其中没有的东西。 一个问题是，参考手册中所有计时器的PWM功能的描述都在第一个计时器（17.5.7 PWM模式）的章节中，因此您必须在本文档中来回跳转。 </p><br><p>  STM8上的PWM与PWM Atmega相比具有重要优势： </p><br><p><img src="https://habrastorage.org/webt/pk/_-/za/pk_-za7gnzo77lvwyw-gvkts1y0.png"><br>  <sub>具有边缘对齐功能的PWM</sub> <sub><br></sub>  <sub>帐户配置从下到上</sub> <sub><br></sub>  <sub>如果TIM_CR1寄存器中的DIR位被清除，则自下而上的计数有效</sub> <sub><br></sub>  <sub>例子</sub> <sub><br></sub>  <sub>该示例使用第一个PWM模式。</sub>  <sub>TIM1_CNT &lt;TIM1_CCRi时，OCiREF PWM参考信号保持高电平。</sub>  <sub>否则，它会处于较低水平。</sub>  <sub>如果TIM1_CCRi寄存器中的比较值大于启动值（TIM1_ARR寄存器），则OCiREF信号保持为1。 <strong>如果比较值为0，则OCiREF保持为零。</strong></sub>  <sub>...</sub> </p><br><p>  <em>更新事件</em>期间的STM8计时器首先检查<em>比较值</em> ，然后才提供参考信号。  Atmega的计时器先洗牌，然后进行比较，结果，当<code>compare value == 0</code>输出结果导致指针需要进行某种方式的争夺（例如，通过编程求逆逻辑）。 </p><br><p> 因此，我们要做的是：8位PWM（ <code>AR == 255</code> ），我们从下到上考虑沿边界对齐。 由于灯泡是通过阴极连接到芯片的，因此PWM必须在<em>比较值</em>之前输出0（LED点亮），之后再输出1。 </p><br><p> 我们已经阅读了一些<em>PWM模式</em> ，因此可以通过在参考手册中搜索以下短语（18.6.8-TIMx_CCMR1）来找到第二个定时器所需的寄存器： </p><br><p><img src="https://habrastorage.org/webt/tt/_3/7s/tt_37syfd9-bib2-ymdxijus9qi.png"><br>  <sub>110：第一PWM模式-从下至上计数时，当TIMx_CNT &lt;TIMx_CCR1时，第一通道有效。</sub>  <sub>否则，第一个通道将处于非活动状态。</sub>  <sub>[进一步从计时器1复制粘贴文件时出现错误]</sub> <sub><br></sub>  <sub>111：第二个PWM模式-当从下往上计数时，当TIMx_CNT &lt;TIMx_CCR1时，第一个通道无效。</sub>  <sub>否则，第一个通道是活动的。</sub> </p><br><p> 由于LED连接到MK阴极，因此第二种模式适合我们（第一种模式也适用，但我们还不知道）。 </p><br><p><img src="https://habrastorage.org/webt/go/ap/x_/goapx_hk5neeok4phdkas_nnfzu.png"><br>  <sub>Bit 3 OC1PE：使能输出1预载</sub> <sub><br></sub>  <sub>0：TIMx_CCR1关闭时的预加载寄存器。</sub>  <sub>您可以随时写入TIMx_CCR1。</sub>  <sub>新值立即生效。</sub> <sub><br></sub>  <sub>1：使能TIMx_CCR1的预加载寄存器。</sub>  <sub>读/写操作访问预加载寄存器。</sub>  <sub>在每次更新事件期间，预加载的值TIMx_CCR1被加载到影子寄存器中。</sub> <sub><br></sub>  <sub>*注意：为使PWM模式正常工作，必须打开预加载寄存器。</sub> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在单信号模式下（在TIMx_CR1寄存器中将OPM位置1），这不是必需的。</font></font></sub> <br></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 好的，打开第二个计时器的三个通道所需的一切： </font></font></p><br><pre> <code class="plaintext hljs">#define TIM2_CCMR1 *(volatile uint8_t *)0x005307 #define TIM2_CCMR2 *(volatile uint8_t *)0x005308 #define TIM2_CCMR3 *(volatile uint8_t *)0x005309 #define PWM_MODE2 0x70 //PWM mode 2, 0b01110000 #define OCxPE 0x08 //preload enable TIM2_CCMR1 = (PWM_MODE2 | OCxPE); TIM2_CCMR2 = (PWM_MODE2 | OCxPE); TIM2_CCMR3 = (PWM_MODE2 | OCxPE);</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AR由两个八位寄存器组成，一切都很简单： </font></font></p><br><pre> <code class="plaintext hljs">#define TIM2_ARRH *(volatile uint8_t *)0x00530F #define TIM2_ARRL *(volatile uint8_t *)0x005310 TIM2_ARRH = 0; TIM2_ARRL = 255;</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二个计时器只能从下往上计数，沿边框对齐，无需更改任何内容。</font><font style="vertical-align: inherit;">将分频器设置为例如256。对于第二个计时器，分频器在TIM2_PSCR寄存器中设置，代表2的幂：</font></font></p><br><pre> <code class="plaintext hljs">#define TIM2_PSCR *(volatile uint8_t *)0x00530E TIM2_PSCR = 8;</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">剩下的就是结论和第二个计时器本身。</font><font style="vertical-align: inherit;">第一个任务由</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">捕获/比较</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使能</font></font></strong></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">寄存器解决</font><font style="vertical-align: inherit;">：沿它们有两个，三个通道不对称分散。</font><font style="vertical-align: inherit;">在这里我们还可以发现您可以更改信号的极性，即 </font><font style="vertical-align: inherit;">原则上，您可以使用PWM模式1。</font></font></p><br><pre> <code class="plaintext hljs">#define TIM2_CCER1 *(volatile uint8_t *)0x00530A #define TIM2_CCER2 *(volatile uint8_t *)0x00530B #define CC1E (1&lt;&lt;0) // CCER1 #define CC2E (1&lt;&lt;4) // CCER1 #define CC3E (1&lt;&lt;0) // CCER2 TIM2_CCER1 = (CC1E | CC2E); TIM2_CCER2 = CC3E;</code> </pre> <br><p>  , ,     TIMx_CR1: </p><br><p><img src="https://habrastorage.org/webt/u8/rj/5v/u8rj5vb2h3oxtgnoe1zzz90fnfm.png"></p><br><pre> <code class="plaintext hljs">#define TIM2_CR1 *(volatile uint8_t *)0x005300 TIM2_CR1 |= 1;</code> </pre> <br><p>    AnalogWrite(),        .    <em>Capture/Compare registers</em> ,      :  8   TIM2_CCRxL    TIM2_CCRxH.    8- ,     : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCR1L *(volatile uint8_t *)0x005312 #define TIM2_CCR2L *(volatile uint8_t *)0x005314 #define TIM2_CCR3L *(volatile uint8_t *)0x005316 void setRGBled(uint8_t r, uint8_t g, uint8_t b) { TIM2_CCR1L = r; TIM2_CCR2L = g; TIM2_CCR3L = b; }</code> </pre> <br><p>   ,       ,   100%  (   255      ).      ,      ,   . </p><br><p>     ,   . </p><br><p>            (  ,   «»   ,        ).            .      , ..       ,   16-     <em>Prescaler High</em>  <em>Low</em> .   …    .   ? </p><br><p>             1,   ,     .  <em>17.7.30 Break register (TIM1_BKR)</em> ,    : </p><br><p><img src="https://habrastorage.org/webt/kb/h8/ue/kbh8ueavruur-vxcqo4fe0c2pdy.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM1_BKR *(volatile uint8_t *)0x00526D TIM1_BKR = (1&lt;&lt;7);</code> </pre> <br><p>    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> . </p><br><p><img src="https://habrastorage.org/webt/b9/hb/tn/b9hbtn6retrnp1vpnzxjsjaayoq.jpeg"></p><br><h1 id="stm8-multiplex"> STM8 Multiplex </h1><br><h1 id="multipleksing-na-stm8">   STM8 </h1><br><p>  -   ,          RGB-      .   –  LED-,   ,   -     ,   ,     ( <em>persistence of vision</em> ,   ). -   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-   </a> . </p><br><p>    : </p><br><ul><li>    RGB LED; </li><li>  ,     ; </li><li>    ; </li><li>    RGB LED; </li><li>  ... </li></ul><br><p>   .. ,    ,     «»   .   .   ,    ,         ,   UEV          RGB-. </p><br><p>   LED  ,   «»,      .   : </p><br><pre> <code class="plaintext hljs">uint8_t colors[8][3];</code> </pre> <br><p>  ,     ,        .         </p><br><pre> <code class="plaintext hljs">uint8_t cnt;</code> </pre> <br><h3 id="demuks">  </h3><br><p>     ,   ,  CD74HC238.  – ,    <code>&lt;&lt;</code> .     ( 0, 1  2)      X,        ( <code>1&lt;&lt;X</code> ).        .            ,     –      ,  ,    .   ,       . </p><br><p> CD74HC238      ,       .           P-MOSFET,       , ..   20 ,  <em>absolute maximum ratings</em>  .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> CD74HC238</a>       : </p><br><p><img src="https://habrastorage.org/webt/b3/lz/rv/b3lzrv4xyavibkiwekm3lbvkays.png"><br> <sub>H =   , L =   , X –  </sub> </p><br><p>  E2  E1  , E3, A0, A1  A3   PD5, PC3, PC4  PC5 STM8.      ,   ,     push-pull . </p><br><h2 id="shim">  </h2><br><p>       ,    ,   : </p><br><p> -,      <em>Update Event</em> (UEV),    ,   LED.     <em>Update Interrupt Enable</em>      </p><br><p><img src="https://habrastorage.org/webt/me/kx/6p/mekx6pckxk6qmhkegaudnneach4.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM2_IER *(volatile uint8_t *)0x005303 //enable interrupt TIM2_IER = 1;</code> </pre> <br><p>       ,  <em>ghosting</em> –   .       - ,  ,    UEV,   ,       LED      -   .        (0 =  , 255 =   )      . 即  ,   UEV       . </p><br><p>  : </p><br><pre> <code class="plaintext hljs">//set polarity TIM2_CCER1 |= (CC1P | CC2P); TIM2_CCER2 |= CC3P;</code> </pre> <br><p>   r, g  b  255       . </p><br><h3 id="preryvaniya">  </h3><br><p>    ,            -  .   -    ,     . </p><br><p>         ST Visual Develop,   <code>main.c</code>       <code>stm8_interrupt_vector.c</code> ,    .         <code>NonHandledInterrupt</code> .        . </p><br><p>      ,    : </p><br><p><img src="https://habrastorage.org/webt/ly/ra/gy/lyragyga5skmcrzjojlftjit1qg.png"><br> <sub>13 TIM2 / <br> 14 TIM2 /</sub> </p><br><p>    LED  UEV,     №13. </p><br><p> , -,   <code>stm8_interrupt_vector.c</code>   ,    №13 (IRQ13)    : </p><br><pre> <code class="plaintext hljs">{0x82, TIM2_Overflow}, /* irq13 */</code> </pre> <br><p> -,     <code>main.h</code>  : </p><br><pre> <code class="plaintext hljs">#ifndef __MAIN_H #define __MAIN_H @far @interrupt void TIM2_Overflow (void); #endif</code> </pre> <br><p>  , ,      <code>main.c</code> : </p><br><pre> <code class="plaintext hljs">@far @interrupt void TIM2_Overflow (void) { PD_ODR &amp;= ~(1&lt;&lt;5); //   PC_ODR = (cnt&lt;&lt;3); //      PD_ODR |= (1&lt;&lt;5); //   TIM2_SR1 = 0; //   Update Interrupt Pending cnt++; cnt &amp;= 7; //   LED TIM2_CCR1L = ~colors[cnt][0]; //      TIM2_CCR2L = ~colors[cnt][1]; //     TIM2_CCR3L = ~colors[cnt][2]; // return; }</code> </pre> <br><p>   .     <code>rim</code> –     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Programming Manual</a> : </p><br><pre> <code class="plaintext hljs">//enable interrupts _asm("rim");</code> </pre> <br><p>    – <code>sim</code> –  .          «»,         . </p><br><p>   – <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> . </p><br><p><img src="https://habrastorage.org/webt/ri/ul/qs/riulqsjmsnehvg5fb_iofcnjl3u.jpeg"></p><br><p>   -   , ,     .     ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN456094/">https://habr.com/ru/post/zh-CN456094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN456084/index.html">Kubernetes 1.15：亮点概述</a></li>
<li><a href="../zh-CN456086/index.html">iOS故事板：优缺点分析，最佳做法</a></li>
<li><a href="../zh-CN456088/index.html">大数据分析问题</a></li>
<li><a href="../zh-CN456090/index.html">Unity中的单元测试简介</a></li>
<li><a href="../zh-CN456092/index.html">七个令人不安的迹象表明您依赖天气，即使您不这样认为</a></li>
<li><a href="../zh-CN456096/index.html">极客时间平均读者在云中徘徊时的行为</a></li>
<li><a href="../zh-CN456100/index.html">现在采用新包装-M.2格式的金士顿A400急于上市</a></li>
<li><a href="../zh-CN456102/index.html">易于在C / C ++中进行报告</a></li>
<li><a href="../zh-CN456104/index.html">Ezblock Pi-无需编程即可编程，这次是针对Raspberry Pi爱好者</a></li>
<li><a href="../zh-CN456106/index.html">我们更快地划分功能。 Badoo的Android开发经验</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>