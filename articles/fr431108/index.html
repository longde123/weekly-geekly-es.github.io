<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüè´ üë©üèª‚Äçüîß üõ∏ Comment transformer l'imagerie satellite en cartes. Vision par ordinateur dans Yandex üë®üèø‚Äçüî¨ ü•§ üçÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'imagerie satellite est l'une des principales sources de donn√©es du service Yandex.Maps. Afin de faciliter le travail avec la carte, les objets sont ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment transformer l'imagerie satellite en cartes. Vision par ordinateur dans Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/431108/">  L'imagerie satellite est l'une des principales sources de donn√©es du service Yandex.Maps.  Afin de faciliter le travail avec la carte, les objets sont marqu√©s de polygones sur les photographies: for√™ts, √©tangs, rues, maisons, etc. Habituellement, les cartographes sont engag√©s dans le marquage.  Nous avons d√©cid√© de les aider et d'apprendre √† l'ordinateur √† ajouter des polygones de maisons sans intervention humaine. <br><br>  Pour les op√©rations avec images rencontre le domaine de l'informatique, qui est appel√© vision par ordinateur.  Au cours des derni√®res ann√©es, la plupart des t√¢ches dans ce domaine ont √©t√© r√©solues avec succ√®s en utilisant des r√©seaux de neurones.  Aujourd'hui, nous parlerons aux lecteurs de Habr de notre exp√©rience de l'utilisation des r√©seaux de neurones dans la cartographie. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/xz/e2/rnxze2-1b6bobojodppliybmehe.jpeg"></div><a name="habracut"></a><br>  Tout d'abord, nous allons former une grille neuronale, qui va s'engager dans la segmentation s√©mantique, c'est-√†-dire d√©terminer si chaque point de l'image satellite est li√© √† la maison.  Pourquoi la segmentation s√©mantique et pas seulement la d√©tection d'objets?  Lorsque le probl√®me de d√©tection sera r√©solu, on obtiendra en sortie un ensemble de rectangles, d'ailleurs sp√©cifiques: deux c√¥t√©s sont verticaux, deux horizontaux.  Et les maisons sont g√©n√©ralement tourn√©es par rapport aux axes de l'image, et certains b√¢timents ont √©galement une forme complexe. <br><br>  La t√¢che de segmentation s√©mantique est d√©sormais r√©solue par diff√©rents r√©seaux ( <a href="">FCN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SegNet</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UNet</a> , etc.).  Il vous suffit de choisir celui qui nous convient le mieux. <br><br>  Apr√®s avoir re√ßu le masque de l'image satellite, nous s√©lectionnons des groupes de points suffisamment grands appartenant aux maisons, les collectons dans les zones connect√©es et pr√©sentons les limites des zones sous forme vectorielle sous forme de polygones. <br><br>  Il est clair que le masque ne sera pas absolument pr√©cis, ce qui signifie que les maisons voisines peuvent rester ensemble dans une zone connect√©e.  Pour faire face √† ce probl√®me, nous avons d√©cid√© de poursuivre la formation du r√©seau.  Elle trouvera dans l'image les nervures (les limites des maisons) et s√©parera les b√¢timents coll√©s. <br><br>  Donc, un tel sch√©ma se profilait: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7z/dw/lt/7zdwlt1z0orhy2i9fhkgifjwkcw.jpeg"></div><br>  Nous n'avons pas compl√®tement √©limin√© les r√©seaux de d√©tection et essay√© le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">masque R-CNN</a> .  Son avantage par rapport √† la segmentation habituelle est que le masque R-CNN d√©tecte des objets et g√©n√®re un masque, il n'est donc pas n√©cessaire de bricoler en divisant le masque commun en zones connect√©es.  Eh bien, moins (comme sans lui) dans la r√©solution fixe du masque de chaque objet, c'est-√†-dire pour les grandes maisons avec une bordure complexe, cette bordure se r√©v√©lera √©videmment simplifi√©e. <br><br><h2>  Les outils </h2><br>  Ensuite, il a fallu d√©cider des outils.  Tout √©tait assez √©vident ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenCV</a> est le mieux adapt√© aux t√¢ches de vision par ordinateur.  Le choix des r√©seaux de neurones est un peu plus large.  Nous nous sommes install√©s sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tensorflow</a> .  Ses avantages: <br><br><ul><li>  un ensemble assez d√©velopp√© de ¬´cubes¬ª pr√™ts √† l'emploi √† partir desquels vous pouvez assembler vos r√©seaux; </li><li>  API Python, pratique pour cr√©er rapidement une structure de r√©seau et pour la formation; </li><li>  Un r√©seau form√© peut √™tre utilis√© dans votre programme via une interface C ++ (tr√®s pauvre en comparaison avec la partie Python, mais tout √† fait suffisant pour ex√©cuter des r√©seaux pr√™ts √† l'emploi). </li></ul><br>  Pour la formation et autres calculs lourds, nous avions pr√©vu d'utiliser Nirvana - la merveilleuse plateforme Yandex <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dont nous avons d√©j√† parl√©</a> . <br><br><h2>  Datacet </h2><br>  Quatre-vingt pour cent de r√©ussite dans l'utilisation d'un r√©seau de neurones consiste en un bon ensemble de donn√©es.  Donc, pour commencer, nous aurions d√ª assembler un tel ensemble de donn√©es.  Yandex poss√®de un grand nombre d'images satellites avec des objets d√©j√† marqu√©s.  Tout semble simple: il suffit de t√©l√©charger ces donn√©es et de les collecter dans un ensemble de donn√©es.  Cependant, il y a une mise en garde. <br><br><h3>  Affiner l'ensemble de donn√©es </h3><br>  Lorsqu'une personne recherche une maison sur une image satellite, la premi√®re chose qu'elle voit est le toit.  Mais la hauteur des maisons varie, le satellite peut prendre le m√™me terrain sous diff√©rents angles - et si nous pla√ßons un polygone correspondant au toit sur la carte vectorielle, rien ne garantit que le toit ne partira pas lorsque l'image sera mise √† jour.  Mais la fondation est enfouie dans le sol et, quel que soit l'angle sous lequel vous la retirez, elle reste tout le temps au m√™me endroit.  C'est pourquoi les maisons sur le vecteur Yandex.Map sont marqu√©es "sur les fondations".  C'est exact, mais pour la t√¢che de segmentation des images, il est pr√©f√©rable d'apprendre au r√©seau √† rechercher des toits: l'espoir que le r√©seau soit form√© pour reconna√Ætre les fondations est tr√®s faible.  Par cons√©quent, dans l'ensemble de donn√©es, tout doit √™tre marqu√© sur les toits.  Donc, pour cr√©er un bon ensemble de donn√©es, nous devons apprendre √† d√©placer la disposition vectorielle des maisons des fondations aux toits. <br><br>  <i>Nous avons essay√© de ne pas bouger, mais la qualit√© n'√©tait pas tr√®s bonne, et cela est compr√©hensible: les angles de prise de vue du satellite sont diff√©rents, les hauteurs des maisons sont diff√©rentes, en cons√©quence, sur les photographies, la fondation a √©t√© d√©plac√©e dans diff√©rentes directions et √† diff√©rentes distances du toit.</i>  <i>Le r√©seau est perdu d'une telle vari√©t√© et, au mieux, s'entra√Æne pour quelque chose entre les deux, au pire - pour quelque chose d'incompr√©hensible.</i>  <i>De plus, le r√©seau de segmentation s√©mantique produit un r√©sultat similaire √† quelque chose d'acceptable, mais lors de la recherche de bords, la qualit√© chute consid√©rablement.</i> <br><br><h4>  Approche raster </h4><br>  Depuis que nous sommes entr√©s dans le domaine de la vision par ordinateur, la premi√®re chose que nous avons faite a √©t√© d'essayer une approche pertinente √† cette vision par ordinateur.  Tout d'abord, la carte vectorielle est tram√©e (les polygones des maisons sont dessin√©s avec des lignes blanches sur fond noir), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le filtre Sobel</a> s√©lectionne les bords de l'image satellite.  Et puis il y a un d√©calage de deux images l'une par rapport √† l'autre, ce qui maximise la corr√©lation entre elles.  Les bords apr√®s le filtre Sobel sont assez bruyants, par cons√©quent, si cette approche est appliqu√©e √† un b√¢timent, un r√©sultat acceptable n'est pas toujours obtenu.  Cependant, la m√©thode fonctionne bien dans les territoires avec des b√¢timents de m√™me hauteur: si vous recherchez un d√©calage imm√©diatement sur une grande zone de l'image, le r√©sultat sera plus stable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7q/re/nq/7qrenqshfovrbc1y84j0y_5q7do.jpeg"></div><br><h4>  Approche "g√©om√©trique" </h4><br>  Si le territoire n'est pas construit avec le m√™me type, mais avec diff√©rentes maisons, la m√©thode pr√©c√©dente ne fonctionnera pas.  Heureusement, nous connaissons parfois la hauteur des b√¢timents sur la carte vectorielle Yandex et la position du satellite lors du tournage.  Ainsi, nous pouvons utiliser les connaissances scolaires de la g√©om√©trie et calculer o√π et √† quelle distance le toit se d√©placera par rapport √† la fondation.  Cette m√©thode a am√©lior√© l'ensemble de donn√©es dans les zones avec des immeubles de grande hauteur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/in/v3/wp/inv3wppmsi5dhhk5jcbmiwymqas.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/kj/_h/yqkj_h0okr891jlbdoaljqfhfsu.jpeg"></div><br><h4>  Approche "manuelle" </h4><br>  Le moyen le plus long: retroussez vos manches, d√©couvrez la souris, regardez le moniteur et d√©placez manuellement la disposition vectorielle des maisons des fondations aux toits.  La technique apporte un r√©sultat tout simplement incroyable en qualit√©, mais il n'est pas recommand√© de l'utiliser en grande quantit√©: les d√©veloppeurs qui sont engag√©s dans de telles t√¢ches tombent rapidement dans l'apathie et perdent tout int√©r√™t pour la vie. <br><br><h4>  R√©seau de neurones </h4><br>  Au final, nous avons obtenu suffisamment d'images satellites bien marqu√©es sur les toits.  Ainsi, il y avait une chance de former le r√©seau neuronal (pour l'instant, cependant, pas pour la segmentation, mais pour am√©liorer la disposition d'autres images satellite).  Et nous l'avons fait. <br><br>  Les donn√©es d'entr√©e du r√©seau neuronal convolutif √©taient une image satellite et un marquage tram√© d√©cal√©.  En sortie, nous avons re√ßu un vecteur bidimensionnel: les d√©placements verticaux et horizontaux. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ad/qy/i9/adqyi95ityf_cueqvd-f2krrknk.png"></div><br>  A l'aide d'un r√©seau neuronal, nous avons trouv√© le d√©placement n√©cessaire, ce qui nous a permis d'obtenir de bons r√©sultats sur des b√¢timents dont la hauteur n'est pas indiqu√©e.  Par cons√©quent, nous avons consid√©rablement r√©duit la correction manuelle du balisage. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s6/tj/v1/s6tjv13fffnmhkxrs7etzhiv1g0.jpeg"></div><br><h3>  Diff√©rents territoires - diff√©rentes maisons </h3><br>  Il existe de nombreux territoires et √âtats int√©ressants sur Yandex.Maps.  Mais m√™me en Russie, les maisons sont extr√™mement diverses, ce qui affecte leur apparence dans l'imagerie satellite.  Vous devez donc refl√©ter la diversit√© de l'ensemble de donn√©es.  Et au d√©but, nous ne comprenions pas vraiment comment faire face √† toute cette splendeur.  Collecter un √©norme ensemble de donn√©es puis former un r√©seau dessus?  Cr√©er votre propre ensemble de donn√©es pour chaque type de d√©veloppement (conditionnel) et former un r√©seau distinct?  Former un certain r√©seau central puis le former √† un type de d√©veloppement sp√©cifique? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ny/pa/fd/nypafdcjqd3vny1_uqpujrfn0ci.jpeg"></div><br>  Empiriquement, nous avons constat√© que: <br><br><ol><li>  Sans aucun doute, il est n√©cessaire d'√©largir l'ensemble de donn√©es pour diff√©rents types de b√¢timents sur lesquels il est pr√©vu d'utiliser l'outil.  Un r√©seau form√© sur un type est capable de distinguer des b√¢timents d'un autre type, bien que tr√®s mal. </li><li>  Il est pr√©f√©rable de former un grand r√©seau sur l'ensemble des donn√©es.  Il se g√©n√©ralise assez bien √† divers territoires.  Si vous formez des r√©seaux distincts pour chaque type de d√©veloppement, la qualit√© restera la m√™me ou s'am√©liorera √† peine.  Il est donc inutile de mettre en ≈ìuvre diff√©rents r√©seaux pour diff√©rents territoires.  De plus, cela n√©cessite plus de donn√©es et un classificateur suppl√©mentaire de type de d√©veloppement. </li><li>  Si vous utilisez d'anciens r√©seaux lors de l'ajout de nouveaux territoires aux donn√©es, les r√©seaux apprennent beaucoup plus rapidement.  Le recyclage des anciens r√©seaux sur des donn√©es √©tendues conduit √† peu pr√®s au m√™me r√©sultat que la formation d'un r√©seau √† partir de z√©ro, mais cela n√©cessite beaucoup moins de temps. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vk/_v/zq/vk_vzq0fxfhcjlusrbqjjqhnfre.jpeg"></div><br><h2>  Options de solution </h2><br><h3>  Segmentation s√©mantique </h3><br>  La segmentation s√©mantique est une t√¢che assez bien √©tudi√©e.  Apr√®s la parution de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©seaux enti√®rement convolutionnels</a> , il est principalement r√©solu √† l'aide de r√©seaux de neurones.  Il ne reste plus qu'√† choisir un r√©seau (nous avons consid√©r√© <a href="">FCN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SegNet</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UNet</a> ), √† r√©fl√©chir si nous avons besoin de trucs suppl√©mentaires comme CRF √† la sortie, et √† d√©cider comment et avec quelle fonction d'erreur la formation sera form√©e. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/un/ay/gn/unaygnyzsdhk_2dbk4qq2-2m340.png"></div><br>  En cons√©quence, nous avons opt√© pour une architecture de type U-Net avec une fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">g√©n√©ralis√©e d'intersection sur union</a> comme fonction d'erreur.  Pour la formation, nous avons d√©coup√© des images satellites et leurs marquages ‚Äã‚Äãcorrespondants (bien s√ªr, tram√©es) en carr√©s et assembl√©s en ensembles de donn√©es.  Cela s'est av√©r√© assez agr√©able, et parfois tr√®s bien. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z1/rv/ub/z1rvubhjv5xcruynmvarimca3zy.jpeg"></div><br>  Dans les territoires √† b√¢timents uniques, la segmentation s√©mantique √©tait suffisante pour passer √† l'√©tape suivante - la vectorisation.  Lorsque le b√¢timent est dense, les maisons sont parfois coll√©es ensemble dans une zone coh√©sive.  Il a fallu les s√©parer. <br><br><h3>  D√©tection des contours </h3><br>  Pour faire face √† cette t√¢che, vous pouvez trouver les bords de l'image.  Pour d√©tecter les bords, nous avons √©galement d√©cid√© de former le r√©seau (les algorithmes de recherche de bords qui n'utilisent pas de r√©seaux de neurones appartiennent clairement au pass√©).  Formation d'un r√©seau de type HED, qui est d√©crit dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Holistically-Nested Edge Detection</a> .  Dans l'article d'origine, le r√©seau a √©t√© form√© sur l'ensemble de donn√©es BSDS-500, dans lequel tous les bords sont marqu√©s sur les images.  Un r√©seau form√© trouve tous les bords prononc√©s: les limites des maisons, des routes, des lacs, etc. C'est d√©j√† suffisant pour s√©parer les b√¢timents voisins.  Mais nous avons d√©cid√© d'aller plus loin et d'utiliser le m√™me ensemble de donn√©es pour la formation que pour la segmentation s√©mantique, mais lors de la pixellisation, ne peignez pas tous les polygones des b√¢timents, mais dessinez uniquement leurs limites. <br><br>  Le r√©sultat √©tait si incroyablement beau que nous avons d√©cid√© de vectoriser les b√¢timents directement par les bords re√ßus du r√©seau.  Et c'est tout √† fait arriv√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/am/uz/h-/amuzh-xo7mzssz9jtzkppm3_nag.jpeg"></div><br><h3>  D√©tection de sommet </h3><br>  Puisqu'un r√©seau comme HED a donn√© un excellent r√©sultat sur les bords, nous avons d√©cid√© de l'entra√Æner √† d√©tecter les sommets.  En fait, nous avons un r√©seau avec des poids g√©n√©raux sur les couches convolutives.  Elle avait deux sorties en m√™me temps: pour les bords et pour les pics.  En cons√©quence, nous avons fait une autre version de la vectorisation des b√¢timents, et dans certains cas, elle a donn√© des r√©sultats assez raisonnables. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fj/50/wl/fj50wlerknjc02f8cnhgguizu2o.jpeg"></div><br><h3>  Masque r-cnn </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mask R-CNN</a> est une extension relativement nouvelle de r√©seaux tels que Faster R-CNN.  Masque R-CNN recherche des objets et s√©lectionne un masque pour chacun d'eux.  En cons√©quence, pour les maisons, nous obtenons non seulement des rectangles de d√©limitation, mais √©galement une structure raffin√©e.  Cette approche se compare favorablement √† la d√©tection simple (nous ne savons pas comment le b√¢timent est situ√© √† l'int√©rieur du rectangle) et √† la segmentation normale (plusieurs maisons peuvent se coller en une seule, et il n'est pas clair comment les s√©parer).  Avec Mask R-CNN, plus besoin de penser √† des astuces suppl√©mentaires: il suffit de vectoriser la bordure du masque pour chaque objet et d'obtenir imm√©diatement le r√©sultat.  Il y a aussi un inconv√©nient: la taille du masque pour l'objet est toujours fixe, c'est-√†-dire que pour les grands b√¢timents, la pr√©cision de la disposition des pixels sera faible.  Le r√©sultat du masque R-CNN ressemble √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/it/8v/4w/it8v4wy0axix-hpi2gfxkomo3nk.jpeg"></div><br>  Nous avons essay√© le Mask R-CNN en dernier et nous nous sommes assur√©s que pour certains types de b√¢timents, cette approche surpasse d'autres. <br><br><h2>  Vectorisation </h2><br><h3>  Vectorisation rectangle </h3><br>  Avec toute la diversit√© architecturale moderne, les maisons sur images satellite ressemblent encore le plus souvent √† des rectangles.  De plus, pour la masse des territoires, le marquage avec des polygones complexes n'est pas n√©cessaire.  Mais je veux quand m√™me que les maisons sur la carte soient marqu√©es.  (Eh bien, par exemple, un partenariat horticole: il y a g√©n√©ralement beaucoup de maisons l√†-bas, le marquage manuel n'est pas si important, mais le marquage avec des rectangles sur la carte est tr√®s bon.) Par cons√©quent, la premi√®re approche de la vectorisation √©tait extr√™mement simple. <br><br><ol><li>  Prenez la r√©gion raster correspondant √† la "maison". </li><li>  Recherchez le rectangle de la zone minimale qui contient cette zone (par exemple, comme ceci: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenCV :: minAreaRect</a> ).  Le probl√®me est r√©solu. </li></ol><br>  Il est clair que la qualit√© de cette approche est loin d'√™tre id√©ale.  Cependant, l'algorithme est assez simple et fonctionne dans de nombreux cas. <br><br><h3>  Vectorisation de polygone </h3><br>  Si la qualit√© de la segmentation est assez bonne, vous pouvez recr√©er plus pr√©cis√©ment le contour de la maison.  Dans la plupart des b√¢timents de forme complexe, les angles sont g√©n√©ralement droits, nous avons donc d√©cid√© de r√©duire le probl√®me √† la construction d'un polygone √† c√¥t√©s orthogonaux.  Pour le r√©soudre, nous voulons atteindre deux objectifs √† la fois: trouver le polygone le plus simple et r√©p√©ter la forme des b√¢timents aussi pr√©cis√©ment que possible.  Ces objectifs sont en conflit les uns avec les autres, vous devez donc introduire des conditions suppl√©mentaires: pour limiter la longueur minimale des murs, l'√©cart maximal par rapport √† la zone raster, etc. <br><br>  L'algorithme qui nous est venu √† l'esprit pour la premi√®re fois √©tait bas√© sur la construction de la projection de points sur des lignes droites: <br><br><ol><li>  Trouvez le contour de la r√©gion raster correspondant √† une maison. </li><li>  R√©duisez le nombre de points dans le circuit en le simplifiant, par exemple, avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'algorithme Douglas-Pecker</a> . </li><li>  Trouvez le c√¥t√© le plus long dans le contour.  C'est son angle d'inclinaison qui d√©terminera l'angle de tout le futur polygone orthogonal. </li><li>  Construisez une projection du point de contour suivant au c√¥t√© pr√©c√©dent. </li><li>  √âtendez le c√¥t√© jusqu'au point de projection.  Si la distance entre le point et sa projection est sup√©rieure au mur le plus court du b√¢timent, ajoutez le segment r√©sultant au contour du b√¢timent. </li><li>  R√©p√©tez les √©tapes 4 et 5 jusqu'√† la fermeture du circuit. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/ok/y5/eyoky5b1d4ayzcflogdwsxfyi8g.png"></div><br>  Cet algorithme est extr√™mement simple et donne rapidement des r√©sultats, mais le contour du b√¢timent se r√©v√®le cependant parfois assez bruyant.  En essayant de faire face √† ce probl√®me, nous sommes tomb√©s sur une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">solution</a> plut√¥t int√©ressante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">au</a> probl√®me, qui utilise une grille carr√©e dans l'espace pour approximer le polygone.  En bref, l'algorithme se compose de trois actions: <br><br><ol><li>  Construisez une grille carr√©e dans l'espace centr√©e sur z√©ro. </li><li>  Aux points de la grille situ√©s √† une certaine distance du contour d'origine, construisez diff√©rents polygones. </li><li>  S√©lectionnez un polygone avec un nombre minimum de sommets. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5f/em/ti/5femtieuuectay9wjhoncxi2rh4.png"></div><br>  L'angle de rotation requis de la grille n'√©tant pas connu √† l'avance, il est n√©cessaire de trier plusieurs valeurs, ce qui affecte mal les performances.  Cependant, l'algorithme vous permet d'obtenir des r√©sultats visuellement plus beaux. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yz/rb/u1/yzrbu1in149ocfxxmdv_h6gctug.jpeg"></div><br><h2>  Am√©lioration de la vectorisation </h2><br>  Alors que nous travaillions avec chaque maison s√©par√©ment.  Lorsque la premi√®re √©tape est termin√©e, vous pouvez d√©j√† travailler avec l'image dans son ensemble et am√©liorer le r√©sultat.  Pour cela, un algorithme de post-traitement d'un ensemble de polygones a √©t√© ajout√©.  Nous avons utilis√© les heuristiques suivantes: <br><br><ul><li>  Habituellement, les murs des maisons adjacentes sont parall√®les.  De plus: le plus souvent, les maisons peuvent √™tre combin√©es en ensembles, √† l'int√©rieur desquels tous les √©l√©ments sont align√©s. </li><li>  Si les rues sont d√©j√† marqu√©es sur l'image, il est tr√®s probable que les c√¥t√©s des polygones soient parall√®les aux rues. </li><li>  Si les polygones se croisent, il est tr√®s probable qu'il soit logique de d√©placer les murs afin que l'intersection disparaisse. </li></ul><br>  En cons√©quence, l'algorithme suivant est apparu: <br><br><ol><li>  Nous regroupons les maisons trouv√©es par la distance entre elles et l'angle de rotation.  Nous faisons la moyenne des tours de b√¢timents dans chaque cluster.  Nous r√©p√©tons jusqu'√† ce que la position des b√¢timents cesse de changer ou jusqu'√† ce que les maisons commencent √† s'√©carter trop de la position initiale. </li><li>  Nous choisissons des maisons pr√®s des routes, nous trouvons les plus longues et les plus proches du bord de la route.  Nous transformons la maison au parall√©lisme du c√¥t√© s√©lectionn√© et de la route. </li><li>  Nous supprimons les intersections entre les polygones, en d√©calant les c√¥t√©s de deux b√¢timents qui se croisent proportionnellement √† la taille des c√¥t√©s. </li></ol><br><h2>  R√©sultat </h2><br>  En cons√©quence, nous avons obtenu un outil qui peut reconna√Ætre les b√¢timents de diff√©rents types de b√¢timents.  Il aide les cartographes dans leur travail acharn√©: acc√©l√®re consid√©rablement la recherche de maisons manquantes et remplit de nouvelles zones non encore cultiv√©es.  Actuellement, plus de 800 000 nouveaux objets ont √©t√© ajout√©s √† la carte des personnes √† l'aide de cet outil. <br><br>  Ci-dessous, vous verrez quelques exemples de reconnaissance. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bn/pk/o0/bnpko0puk1vcvnd1oxanqo7pvty.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nr/qi/q5/nrqiq5mdh2wl8fjaqmr28sn0oys.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xz/3a/iw/xz3aiwhlc_g1lo_huyb8yml_6ms.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/xz/e2/rnxze2-1b6bobojodppliybmehe.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jm/_j/cv/jm_jcvdv8pxm60tlwmoj2hmcgjc.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9x/k_/u3/9xk_u3nlc82ymdbtht8ebtbx6ue.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mw/zk/8g/mwzk8g2ga_798vg986flckxculo.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/37/gu/ue37gu16xwfvt3zqh0akmtmxnyi.jpeg"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431108/">https://habr.com/ru/post/fr431108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431096/index.html">Comment cr√©er un produit de chat bot</a></li>
<li><a href="../fr431098/index.html">M√™me un incendie n'est pas un obstacle, ou Zimbra Speed ‚Äã‚ÄãRecovery apr√®s une catastrophe</a></li>
<li><a href="../fr431102/index.html">Comment l'adresse physique est affich√©e dans les cha√Ænes DRAM et les banques</a></li>
<li><a href="../fr431104/index.html">Comment nous, chez Neoflex, d√©veloppons l'expertise DevOps</a></li>
<li><a href="../fr431106/index.html">Combien d'argent les Am√©ricains ont d√©pens√© ce Black Friday et qu'est-ce que les smartphones ont √† voir avec √ßa?</a></li>
<li><a href="../fr431110/index.html">Arr√™tez de nourrir les √©diteurs. L'UE √©labore des r√®gles pour le libre acc√®s obligatoire √† la recherche</a></li>
<li><a href="../fr431112/index.html">Comment utiliser les m√©thodes des moindres carr√©s pour √©valuer les ressources et surveiller les bases de donn√©es Oracle</a></li>
<li><a href="../fr431116/index.html">Envie d'√©trange: bilan de la prochaine conf√©rence DartUP √† Saint-P√©tersbourg</a></li>
<li><a href="../fr431118/index.html">Toute la v√©rit√© sur RTOS. Article # 22. Bo√Ætes aux lettres: services auxiliaires et structures de donn√©es</a></li>
<li><a href="../fr431120/index.html">La souffrance au travail n'est pas n√©cessaire</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>