<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé∑ üëÉ ü§¶üèø Cr√©ation d'un jeu pour Game Boy üñïüèº üêÑ üç¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques semaines, j'ai d√©cid√© de travailler sur un jeu pour Game Boy, dont la cr√©ation m'a fait grand plaisir. Son nom de travail est Aqua and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ation d'un jeu pour Game Boy</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436330/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/913/597/052/91359705210df58524bc0e6c9e9955a8.png" alt="image"></div><br>  Il y a quelques semaines, j'ai d√©cid√© de travailler sur un jeu pour Game Boy, dont la cr√©ation m'a fait grand plaisir.  Son nom de travail est Aqua and Ashes.  Le jeu est open source et est publi√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . <br><br><h2>  Comment cette id√©e m'est venue √† l'esprit </h2><br>  J'ai r√©cemment obtenu un stage en cr√©ant un backend en PHP et Python pour le site Web de mon universit√©.  C'est un bon travail int√©ressant, pour lequel je suis tr√®s reconnaissant.  Mais ... en m√™me temps, tout ce code de d√©veloppement Web de haut niveau m'a infect√© d'un d√©sir insatiable.  Et c'√©tait le d√©sir d'un travail de bas niveau avec des bits. <br><br>  J'ai re√ßu un r√©sum√© hebdomadaire de itch.io sur les jams de jeu par la poste, qui annon√ßait le d√©but de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mini Jam 4</a> .  C'√©tait un jam de 48 heures (enfin, en fait un peu plus gros), dans lequel la limitation √©tait de cr√©er des graphismes dans le style de Game Boy.  Ma premi√®re r√©action logique a √©t√© de cr√©er un jeu homebrew pour Game Boy.  Le th√®me de la confiture √©tait ¬´saisons¬ª et ¬´flammes¬ª. <br><br>  Apr√®s avoir r√©fl√©chi un peu √† l'intrigue et √† la m√©canique qui peuvent √™tre mises en ≈ìuvre en 48 heures et s'adapter aux limites du sujet, j'ai trouv√© un <s>clone d'une</s> nouvelle interpr√©tation du niveau du jeu SNES 1993 Tiny Toon Adventures: Buster Busts Loose!, Dans lequel le joueur dans le r√¥le de Baster joue au football am√©ricain . <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XmyJZkJ-zeA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  J'ai toujours aim√© la fa√ßon dont les cr√©ateurs de ce niveau ont pris un sport incroyablement complexe, se sont d√©barrass√©s de tous les trucs, positions et √©l√©ments strat√©giques, gr√¢ce √† l'obtention d'un jeu extr√™mement int√©ressant et facile.  De toute √©vidence, une telle vision simplifi√©e du football am√©ricain ne remplacera pas Madden, tout comme NBA Jam (une id√©e similaire: seulement 4 joueurs sur un terrain beaucoup plus petit avec un gameplay plus simple que dans un jeu r√©gulier) ne remplacera pas la s√©rie 2K.  Mais cette id√©e a un certain charme, et les chiffres de vente de NBA Jam le confirment. <br><br>  Comment tout cela se rapporte-t-il √† mon id√©e?  J'ai d√©cid√© de prendre ce niveau de football et de le refaire pour qu'il reste similaire √† l'original et en m√™me temps frais.  Premi√®rement, j'ai r√©duit le jeu √† seulement quatre joueurs - un d√©fenseur et un attaquant.  Cela a √©t√© principalement fait en raison des limitations du mat√©riel, mais en m√™me temps, cela me permettra d'exp√©rimenter un peu avec une IA plus intelligente, non limit√©e au principe de "courir √† gauche et parfois sauter" de jouer sur SNES. <br><br>  Par souci de conformit√© avec le sujet, je remplacerai les portes par des colonnes en feu, ou par des feux de joie, ou par quelque chose comme √ßa (je n'ai pas encore d√©cid√©), et un ballon de football avec des torches et des seaux d'eau.  Le gagnant sera l'√©quipe qui contr√¥le les deux feux de joie, et autour de ce concept simple, vous pouvez facilement trouver un complot.  Les saisons sont √©galement prises en compte: j'ai d√©cid√© que les saisons changeraient √† chaque tour, afin que l'√©quipe de pompiers obtienne un avantage en √©t√© et l'√©quipe de pompiers en hiver.  Cet avantage ressemble √† des obstacles sur le terrain qui n'interf√®rent qu'avec l'√©quipe adverse. <br><br>  Bien s√ªr, lors de la cr√©ation de deux √©quipes, il fallait deux animaux qui aiment et n'aiment pas le feu.  Au d√©but, j'ai pens√© aux fourmis rouges et √† certains insectes aquatiques, aux mantes religieuses et autres, mais apr√®s avoir √©tudi√© la question, je n'ai trouv√© aucun insecte actif en hiver, alors je les ai remplac√©s par des renards polaires et des geckos.  Les renards polaires aiment la neige, les geckos aiment se coucher au soleil, donc tout semble logique.  Au final, ce n'est qu'un jeu pour Game Boy. <br><br>  De plus, au cas o√π cela serait encore incompr√©hensible, √† la fin du jam, le jeu n'√©tait pas pr√®s d'√™tre termin√©.  Quoi qu'il en soit, c'√©tait amusant de toute fa√ßon. <br><br><h2>  Formation Game Boy </h2><br>  Vous devez d'abord d√©terminer les exigences.  J'ai d√©cid√© d'√©crire pour DMG (nom interne du mod√®le Game Boy, abr√©viation de Dot Matrix Game).  Surtout pour r√©pondre aux exigences d'un jam de jeu, mais aussi parce que je le voulais vraiment.  Personnellement, je n'ai jamais eu de jeux pour DMG (bien qu'il existe plusieurs jeux pour Game Boy Color), mais je trouve que l'esth√©tique 2 bits est une limitation tr√®s agr√©able et int√©ressante pour les exp√©riences.  J'ajouterai peut-√™tre des couleurs suppl√©mentaires pour SGB et CGB, mais jusqu'√† pr√©sent je n'y ai pas pens√©. <br><br>  J'ai √©galement d√©cid√© d'utiliser une cartouche avec 32K ROM + sans RAM, juste au cas o√π je voudrais cr√©er une copie physique du jeu.  CatSkull, qui a publi√© plusieurs jeux Game Boy, tels que Sheep it Up !, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en vente des cartouches flash de 32 kilo-octets tr√®s bon march√©</a> qui sont parfaites pour moi.  C'est une autre limitation suppl√©mentaire, mais je ne pense pas que dans un avenir proche je puisse surmonter le volume 32K avec un jeu aussi simple.  Le plus dur sera avec les graphismes, et si tout est compl√®tement mauvais, je vais essayer de le compresser. <br><br>  Quant au travail de Game Boy, alors tout est assez compliqu√©.  Cependant, pour √™tre honn√™te, de toutes les r√©tro-consoles avec lesquelles je devais travailler, Game Boy √©tait le plus agr√©able.  J'ai commenc√© avec un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">excellent tutoriel</a> (au moins pour la premi√®re fois, car il n'a jamais √©t√© termin√©) par l'auteur de AssemblyDigest.  Je savais qu'il est pr√©f√©rable d'√©crire en ASM, m√™me si cela peut parfois √™tre douloureux, car le mat√©riel n'est pas con√ßu pour C, et je n'√©tais pas s√ªr que le langage cool Wiz mentionn√© dans le tutoriel conviendrait √† long terme.  De plus, je le fais principalement parce que <em>je peux</em> travailler avec ASM. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V√©rifiez le commit 8c0a4ea</a> <br><br>  La premi√®re chose √† faire √©tait de faire d√©marrer le Game Boy.  Si le logo Nintendo n'est pas trouv√© √† un d√©calage de <code>$104</code> et que le reste de l'en-t√™te n'est pas configur√© correctement, l'√©quipement Game Boy supposera que la cartouche n'est pas ins√©r√©e correctement et refusera de la charger.  Pour r√©soudre ce probl√®me est tr√®s simple, car de nombreux tutoriels ont d√©j√† √©t√© √©crits √† ce sujet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici comment j'ai r√©solu le probl√®me de cap.</a>  Rien ne m√©rite une attention particuli√®re. <br><br>  Il sera plus difficile d'effectuer des actions significatives apr√®s le chargement.  Il est tr√®s simple de faire entrer le syst√®me dans un cycle occup√© infini dans lequel il ex√©cute une ligne de code encore et encore.  L'ex√©cution du code commence par le libell√© <code>main</code> (o√π le saut √† l'adresse <code>$100</code> indique), vous devez donc y ins√©rer du code simple.  Par exemple: <br><br><pre> <code class="hljs pgsql">main: .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>: halt jr .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span></code> </pre> <br>  et il ne fait absolument rien d'autre qu'attendre le d√©but de l'interruption, apr√®s quoi il revient √† l'√©tiquette <code>.loop</code> .  (Ci-apr√®s, je vais omettre une description d√©taill√©e d'ASM. Si vous vous trompez, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">consultez la documentation de l'assembleur que j'utilise</a> .) Vous pouvez √™tre curieux de savoir pourquoi je ne reviens tout simplement pas √† l'√©tiquette <code>main</code> .  C'est parce que je veux que tout ce qui pr√©c√®de le label <code>.loop</code> soit l'initialisation du programme, et tout ce qui se passe apr√®s chaque image.  Ainsi, je n'ai pas √† contourner le cycle de chargement des donn√©es de la cartouche et √† vider la m√©moire dans chaque trame. <br><br>  Faisons un pas de plus.  Le package assembleur RGBDS que j'utilise contient un convertisseur d'image.  Comme √† ce stade, je n'ai pas encore tir√© de ressources pour le jeu, j'ai d√©cid√© d'utiliser le bouton monochrome de ma page √Ä propos comme bitmap de test.  En utilisant RGBGFX, je l'ai converti au format Game Boy et j'ai utilis√© la commande assembleur .incbin pour l'ins√©rer apr√®s la fonction <code>main</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26e/1d4/8b2/26e1d48b29e761edb6df6c6a3a3d035b.png" alt="image"></div><br>  Pour l'afficher √† l'√©cran, j'ai besoin des √©l√©ments suivants: <br><br><ol><li>  LCD √©teint </li><li>  D√©finir la palette </li><li>  D√©finir la position de d√©filement </li><li>  Effacer la m√©moire vid√©o (VRAM) </li><li>  Charger des graphiques de tuiles dans VRAM </li><li>  T√©l√©charger la carte d'arri√®re-plan des tuiles VRAM </li><li>  Rallumez l'√©cran LCD </li></ol><br><h3>  LCD √©teint </h3><br>  Pour les d√©butants, cela devient l'obstacle le plus s√©rieux.  Sur le premier Game Boy, il est impossible d'√©crire simplement des donn√©es sur VRAM √† tout moment.  Il faut attendre le moment o√π le syst√®me ne dessine rien.  Imitant la lueur du phosphore dans les anciens t√©l√©viseurs CRT, l'intervalle entre chaque image lorsque la VRAM est ouverte est appel√© Vertical-Blank, ou VBlank (dans CRT, c'est une impulsion pour masquer le faisceau du kin√©scope lors d'un balayage invers√©).  (Il y a aussi HBlank entre chaque ligne de l'√©cran, mais il est tr√®s court.) Cependant, nous pouvons contourner ce probl√®me en √©teignant l'√©cran LCD, c'est-√†-dire que nous <em>pouvons</em> enregistrer en VRAM ind√©pendamment de l'emplacement de la "trace de phosphore" de l'√©cran CRT. <br><br>  Si vous √™tes confus, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet examen devrait vous expliquer beaucoup de choses</a> .  Dans ce document, la question est consid√©r√©e du point de vue de la SNES, alors n'oubliez pas qu'il n'y a pas de faisceau d'√©lectrons et que les nombres sont diff√©rents, mais dans tout le reste, c'est tout √† fait applicable.  Essentiellement, nous devons d√©finir le drapeau FBlank. <br><br>  Cependant, l'astuce du Game Boy est que vous ne pouvez √©teindre l'√©cran LCD que pendant VBlank.  Autrement dit, nous devons attendre VBlank.  Pour ce faire, utilisez des interruptions.  Les interruptions sont des signaux que le Game Boy envoie du mat√©riel au CPU.  Si le gestionnaire d'interruption est d√©fini, le processeur arr√™te son travail et appelle le gestionnaire.  Game Boy prend en charge cinq interruptions, et l'une d'elles d√©marre lorsque VBlank d√©marre. <br><br>  Les interruptions peuvent √™tre trait√©es de deux mani√®res diff√©rentes.  La premi√®re et la plus courante est la t√¢che d' <em>un gestionnaire d'interruption</em> qui fonctionne comme je l'ai expliqu√© ci-dessus.  Cependant, nous pouvons activer une interruption sp√©cifique et d√©sactiver tous les gestionnaires en d√©finissant l'indicateur d'activation de cette interruption et en utilisant le <code>di</code> opcode.  Il ne fait g√©n√©ralement rien, mais a pour effet secondaire de quitter l'opcode HALT, qui arr√™te le CPU avant qu'une interruption ne se produise.  (Cela se produit √©galement lorsque les gestionnaires sont activ√©s, ce qui nous permet de quitter le cycle HALT en g√©n√©ral.) Si vous √™tes int√©ress√©, nous cr√©erons √©galement un gestionnaire VBlank au fil du temps, mais cela d√©pendra en grande partie de certaines valeurs √† certaines adresses.  √âtant donn√© que rien n'a √©t√© d√©fini dans la RAM jusqu'√† pr√©sent, une tentative d'appeler le gestionnaire VBlank peut entra√Æner une panne du syst√®me. <br><br>  Pour d√©finir les valeurs, nous devons envoyer des commandes aux registres mat√©riels de Game Boy.  Il existe des adresses m√©moire sp√©ciales qui sont directement li√©es √† diff√©rentes parties de l'√©quipement, dans notre cas, le CPU, ce qui vous permet de changer son fonctionnement.  Nous sommes particuli√®rement int√©ress√©s par les adresses <code>$FFFF</code> (champ de bit d'activation d'interruption), <code>$FF0F</code> (champ de bit d'interruption activ√© mais non g√©r√©) et <code>$FF40</code> (contr√¥le LCD).  Une liste de ces registres se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur les pages</a> associ√©es √† la section ¬´Documentation¬ª de la liste Awesome Game Boy Development. <br><br>  Pour d√©sactiver l'√©cran LCD, nous activons uniquement l'interruption VBlank, en affectant √† <code>$FFFF</code> valeur <code>$01</code> , en ex√©cutant HALT jusqu'√† ce que la condition <code>$FF0F == $01</code> satisfaite, puis en affectant le bit 7 de l'adresse <code>$FF40</code> √† 0. <br><br><h3>  D√©finition de la palette et de la position du d√©filement </h3><br>  C'est facile √† faire.  Maintenant que l'√©cran LCD est √©teint, nous n'avons plus √† nous soucier de VBlank.  Pour r√©gler la position de d√©filement, il suffit de mettre les registres X et Y √† 0. Avec la palette, tout est un peu plus d√©licat.  Dans Game Boy, vous pouvez attribuer des nuances du premier au quatri√®me graphisme de l'une des 4 nuances de gris (ou vert marais, si vous le souhaitez), ce qui est utile pour effectuer des transitions et autres.  J'ai d√©fini un d√©grad√© simple comme une palette, d√©finie comme une liste de bits <code>%11100100</code> . <br><br><h3>  Effacement de la VRAM et chargement des graphiques en mosa√Øque </h3><br>  Lors du lancement, toutes les donn√©es graphiques et la carte d'arri√®re-plan ne seront constitu√©es que d'un logo Nintendo d√©filant, qui s'affiche au d√©marrage du syst√®me.  Si j'active les sprites (ils sont d√©sactiv√©s par d√©faut), ils seront √©parpill√©s sur l'√©cran.  Vous devez vider la m√©moire vid√©o pour recommencer √† z√©ro. <br><br>  Pour ce faire, j'ai besoin d'une fonction comme <code>memset</code> de C. (J'ai √©galement besoin d'une <code>memcpy</code> analogique pour copier les donn√©es graphiques.) La fonction <code>memset</code> d√©finit le fragment de m√©moire sp√©cifi√© sur un certain octet.  Il sera facile pour moi de l'impl√©menter moi-m√™me, mais le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tutoriel AssemblyDigest</a> a d√©j√† ces fonctions, donc je les utilise. <br><br>  √Ä ce stade, je peux effacer la VRAM avec <code>memset</code> en y √©crivant <code>$00</code> (bien que le premier commit ait utilis√© la valeur <code>$FF</code> , qui convenait √©galement), puis charger les graphiques de tuiles dans VRAM en utilisant <code>memcpy</code> .  Plus pr√©cis√©ment, je dois le copier √† l'adresse <code>$9000</code> , car ce sont des tuiles utilis√©es uniquement pour les graphiques d'arri√®re-plan.  (Les adresses <code>$8000-$87FF</code> sont utilis√©es uniquement pour les carreaux de sprite, et les adresses <code>$8800-$8FFF</code> sont courantes pour les deux types.) <br><br><h3>  R√©glage de la carte des tuiles </h3><br>  Game Boy a une couche d'arri√®re-plan, divis√©e en tuiles 8x8.  Le calque d'arri√®re-plan lui-m√™me prend environ 32x32 tuiles, c'est-√†-dire qu'il a une taille totale de 256x256.  (A titre de comparaison: l'√©cran de la console a une r√©solution de 160x144.) J'avais besoin d'indiquer manuellement les tuiles qui composent mon image ligne par ligne.  Heureusement, toutes les tuiles ont √©t√© organis√©es dans l'ordre, il me fallait donc remplir chaque ligne avec des valeurs de <code>N*11</code> √† <code>N*11 + 10</code> , o√π <code>N</code> est le num√©ro de ligne, et les 22 √©l√©ments de tuiles restants remplissaient <code>$FF</code> . <br><br><h3>  Allumer l'√©cran LCD </h3><br>  Ici, nous n'avons pas besoin d'attendre VBlank, car l'√©cran ne s'allumera toujours pas avant VBlank, je viens donc d'√©crire √† nouveau sur le registre de contr√¥le LCD.  J'ai √©galement inclus des couches d'arri√®re-plan et de sprite, et indiqu√© √©galement les adresses correctes de la carte des tuiles et des graphiques des tuiles.  Apr√®s cela, j'ai obtenu les r√©sultats suivants.  J'ai √©galement r√©activ√© les gestionnaires d'interruption √† l'aide de l'opcode <code>ei</code> . <br><br>  √Ä ce stade, pour le rendre encore plus int√©ressant, j'ai √©crit un gestionnaire d'interruption tr√®s simple pour VBlank.  En ajoutant l'opcode de transition √† <code>$40</code> , je peux faire du gestionnaire n'importe quelle fonction dont j'ai besoin.  Dans ce cas, j'ai √©crit une fonction simple qui fait d√©filer l'√©cran de haut en bas. <br><br>  Voici les r√©sultats finis.  [Addition: Je viens de r√©aliser que le GIF n'est pas boucl√© correctement, il doit constamment transf√©rer l'image.] <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd0/c84/9db/fd0c849dbe3bc68910d186b1ef014c66.gif"></div><br>  Jusqu'√† pr√©sent, rien de particuli√®rement surprenant, mais c'est quand m√™me cool que th√©oriquement je puisse r√©cup√©rer mon ancienne Game Boy Color et voir comment mon propre code est ex√©cut√© dessus. <br><br><h2>  Amusez-vous avec des draps √† carreaux </h2><br>  Pour dessiner quelque chose √† l'√©cran, j'ai naturellement besoin d'une sorte de sprite.  Apr√®s avoir √©tudi√© le PPU (Picture Processing Unit) de la console Game Boy, j'ai d√©cid√© de me concentrer sur les sprites 8x8 ou 8x16.  Probablement, j'aurai besoin de la derni√®re option, mais juste pour sentir la taille, j'ai rapidement griffonn√© une capture d'√©cran du jeu √† l'√©chelle 1: 8 sur du papier quadrill√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/b5b/ece/887b5becec39b13f2fd167e9436c63e5.jpg"></div><br>  Je voulais laisser le haut de l'√©cran sous le HUD.  Il me semblait que cela aurait l'air plus naturel que d'en bas, car quand il est en place, alors si les personnages ont besoin de bloquer temporairement le HUD, comme dans Super Mario Bros, ils peuvent le faire.  Ce jeu n'aura pas de plateforme complexe, et en fait le level design aussi, donc je n'ai pas besoin de montrer une vue tr√®s g√©n√©rale du terrain.  La position des personnages √† l'√©cran et, √©ventuellement, les obstacles qui apparaissent de temps en temps seront bien suffisants.  Par cons√©quent, je peux me permettre des sprites assez grands. <br><br>  Donc, si un carr√© √©tait une tuile 8x8, alors un sprite <em>ne</em> suffira pas, quelle que soit la taille que je choisis.  Cela est particuli√®rement vrai √©tant donn√© qu'il n'y aura presque pas de mouvement vertical dans le jeu, √† l'exception des sauts.  J'ai donc d√©cid√© de cr√©er des sprites √† partir de quatre sprites 8x16.  L'exception √©tait la queue du renard, qui occupe deux sprites 8x16.  Apr√®s de simples calculs, il est devenu clair que deux renards et deux geckos occuperont 20 des 40 sprites, c'est-√†-dire qu'il sera possible d'ajouter beaucoup plus de sprites suppl√©mentaires.  (Les sprites 8x8 manqueraient rapidement de ma limite, ce que je ne veux pas faire dans les premiers stades de d√©veloppement.) <br><br>  Pour l'instant, je n'ai besoin que de dessiner des sprites.  Vous trouverez ci-dessous des croquis approximatifs sur papier quadrill√©.  J'ai un sprite en attente, un sprite "pensant" pour choisir de passer ou de courir, comme dans un jeu SNES ... et c'est tout.  J'ai √©galement pr√©vu de cr√©er des sprites de personnages en cours d'ex√©cution, de personnages sauteurs et de personnages que les adversaires attraperont.  Mais pour commencer, je n'ai dessin√© que des sprites d'attente et de r√©flexion, afin de ne pas compliquer.  Je n'ai toujours pas fait le reste, je dois le faire. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/623/20c/124/62320c12434cacf0c0ca06a2aad33fae.jpg"></div><br>  Oui, je sais, je ne dessine pas tr√®s bien.  La perspective est une chose d√©licate.  (Oui, et ce visage de renard polaire est terrible.) Mais cela me convient parfaitement.  La conception des personnages n'a pas de caract√©ristiques sp√©ciales, mais convient √† la confiture de jeux.  Bien s√ªr, j'ai utilis√© de vrais geckos et renards polaires comme r√©f√©rences.  Est-ce imperceptible? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fe/b2e/936/1feb2e936415aeceaf8cd35596d7e55d.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/215/cc8/568/215cc856884bb518df111799d6e10a87.jpg"></div><br>  Vous ne pouvez pas le dire.  (Pour m√©moire: apr√®s avoir √† nouveau regard√© ces photos, j'ai r√©alis√© qu'il y a une √©norme diff√©rence entre les geckos et les l√©zards. Je ne sais pas quoi faire avec √ßa, sauf pour me consid√©rer stupide ...) Je pense que vous pouvez deviner que la source d'inspiration pour Blaze the Cat de la s√©rie de jeux Sonic a servi de t√™te au renard. <br><br>  Au d√©part, je voulais que les d√©fenseurs et les attaquants de chaque √©quipe soient de sexes diff√©rents et il √©tait plus facile de les distinguer.  (J'allais √©galement laisser les joueurs choisir le sexe de leur personnage.) Cependant, cela n√©cessiterait beaucoup plus de dessin.  J'ai donc choisi des geckos m√¢les et des renards femelles. <br><br>  Et enfin, j'ai dessin√© un √©cran de d√©marrage car il y avait de la place sur un morceau de papier quadrill√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c67/5ac/30a/c675ac30af04025014da7eee842d285d.jpg"></div><br>  Oui, les poses d'action sont encore loin d'√™tre id√©ales.  Le renard polaire devrait √™tre plus boulevers√© et courir, et le gecko devrait avoir l'air mena√ßant.  Defender Fox en arri√®re-plan - une r√©f√©rence amusante √† l'art sur la bo√Æte Doom. <br><br><h2>  Num√©risation des sprites </h2><br>  Puis j'ai commenc√© √† transformer des dessins sur papier en sprites.  Pour cela, j'ai utilis√© le programme GraphicsGale, qui a r√©cemment √©t√© rendu gratuit.  (Je sais que vous pouvez utiliser asesprite, mais je pr√©f√®re GraphicsGale.) Le travail sur les sprites s'est av√©r√© √™tre beaucoup plus compliqu√© que ce √† quoi je m'attendais.  Chacun de ces carr√©s des images-objets ci-dessus prend jusqu'√† 4 pixels dans une grille 2x2.  Et ces carr√©s avaient souvent BEAUCOUP plus de d√©tails que 4 pixels.  J'ai donc d√ª me d√©barrasser de nombreux d√©tails des croquis.  Parfois, il √©tait m√™me difficile d'adh√©rer √† une forme simple, car il fallait laisser un endroit acceptable pour les yeux ou le nez.  Mais il me semble que tout a l'air bien, m√™me si le sprite est devenu compl√®tement diff√©rent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39f/789/d16/39f789d16e3c10c85fa4f0613a0cf571.png"></div><br>  Les yeux du renard ont perdu leur forme d'amande et se sont transform√©s en une ligne de deux pixels de haut.  Les yeux du gecko ont conserv√© leur rondeur.  La t√™te du gecko a d√ª √™tre agrandie, en se d√©barrassant des larges √©paules, et tous les virages que le renard aurait pu √™tre ont √©t√© consid√©rablement liss√©s.  Mais honn√™tement, tous ces changements faciles ne sont pas si mauvais.  Parfois, je pouvais √† peine choisir laquelle des variations est la meilleure. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/32f/d71/a5232fd71193a02dfaebdc2c043edbe5.png"></div><br>  GraphicsGale poss√®de √©galement des fonctions pratiques pour les calques et les animations.  Cela signifie que je peux animer la queue du renard s√©par√©ment de son corps.  Cela aide beaucoup √† √©conomiser un pr√©cieux espace VRAM car je n'ai pas besoin de dupliquer la queue dans chaque image.  De plus, cela signifiait que vous pouviez remuer la queue √† une vitesse variable, ralentir lorsque le personnage √©tait debout et acc√©l√©rer en courant.  Cependant, cela rend la programmation un peu plus compliqu√©e.  Mais je continuerai cette t√¢che.  Je me suis install√© sur 4 images d'animation, car cela suffit. <br><br>  Vous remarquerez peut-√™tre que le renard polaire utilise les trois nuances de gris les plus claires, tandis que le gecko utilise les trois nuances de gris les plus fonc√©es.  Sur GameBoy, cela est acceptable, car bien qu'il ne puisse y avoir que trois couleurs dans un sprite, la console vous permet de sp√©cifier deux palettes.  J'ai fait en sorte que la palette 0 soit utilis√©e pour les renards et la palette 1 pour les geckos. C'est tout l'ensemble de palettes disponible, mais je ne pense pas en avoir besoin d'autres. <br><br>  J'avais √©galement besoin de prendre soin de l'arri√®re-plan.  Je n'ai pas pris la peine de faire ses croquis, car j'avais pr√©vu que ce serait une couleur unie ou un simple motif g√©om√©trique.  Je n'ai pas encore num√©ris√© l'√©conomiseur d'√©cran, car je n'ai pas eu assez de temps. <br><br><h2>  Chargement des sprites dans le jeu </h2><br>  V√©rifiez avec le commit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">be99d97</a> . <br><br>  Apr√®s avoir enregistr√© chaque image individuelle des graphiques des personnages, il √©tait possible de commencer √† les convertir au format GameBoy.  Il s'est av√©r√© que dans RGBDS il y a un utilitaire tr√®s pratique pour cela appel√© RGBGFX.  Vous pouvez l'appeler avec la commande <code>rgbgfx -h -o output.bin input.png</code> et cela cr√©era un ensemble de tuiles compatibles avec GameBoy.  (Le commutateur -h sp√©cifie un mode de tuile compatible avec 8x16 afin que la conversion soit effectu√©e de haut en bas, et non de gauche √† droite.) Cependant, il ne fournit pas de liaisons et ne peut pas suivre les tuiles en double lorsque chaque image est une image distincte.  Mais nous laisserons ce probl√®me pour plus tard. <br><br>  Apr√®s avoir g√©n√©r√© les fichiers de sortie .bin, ajoutez-les simplement dans l'assembleur en utilisant <code>incbin "output.bin"</code> .  Pour tout garder ensemble, j'ai cr√©√© un fichier commun ¬´gfxinclude.z80¬ª, qui contient tous les graphiques √† ajouter. <br><br>  Cependant, il √©tait tr√®s ennuyeux de r√©g√©n√©rer manuellement les graphiques chaque fois que quelque chose changeait.  J'ai donc √©dit√© le fichier build.bat, en ajoutant la ligne <code>for %%f in (gfx/*.png) do rgbds\rgbgfx -h -o gfx/bin/%%f.bin gfx/%%f</code> , qui convertit chaque fichier. png dans le dossier gfx / dans le fichier bin et l'enregistre dans gfx / bin.  Cela a grandement simplifi√© ma vie. <br><br>  Pour cr√©er des graphiques d'arri√®re-plan, j'ai utilis√© une m√©thode <em>beaucoup</em> plus paresseuse.  RGBASM a une directive <code>dw `</code> .  Il est suivi d'une ligne de 8 valeurs de 0 √† 4 √©gales √† une ligne de donn√©es de pixels.  Comme les sprites d'arri√®re-plan √©taient tr√®s simples, il s'est av√©r√© plus facile de copier et coller un motif g√©om√©trique simple pour cr√©er un motif solide, ray√© ou en damier.  Ici, par exemple, ressemble √† une tuile terrestre. <br><br><pre> <code class="hljs powershell">bg_dirt: dw `00110011 dw `00000000 dw `01100110 dw `00000000 dw `11001100 dw `00000000 dw `10011001 dw `00000000</code> </pre> <br>  Il cr√©e une s√©rie de rayures d√©cal√©es avec l'illusion de la perspective.  Il s'agit d'une approche simple mais intelligente.  Avec l'herbe, c'√©tait un peu plus compliqu√©.  Au d√©part, c'√©tait un groupe de lignes horizontales de 2 pixels de haut, mais j'ai ajout√© manuellement quelques pixels qui ajoutent un peu de bruit qui rend l'herbe plus belle: <br><br><pre> <code class="hljs powershell">bg_grass: dw `12121112 dw `12121212 dw `22112211 dw `11121212 dw `22112211 dw `21212121 dw `12121212 dw `12211222</code> </pre> <br><h2>  Rendu graphique </h2><br>  Dans GameBoy, les sprites sont stock√©s dans une zone appel√©e OAM, ou Object Attribute Memory.  Il ne contient que des attributs (direction, palette et priorit√©), ainsi que le num√©ro de tuile.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il me suffisait de remplir cette zone de m√©moire pour afficher les sprites √† l'√©cran. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien qu'il y ait de petites fonctionnalit√©s. Tout d'abord, vous devez charger les graphiques de la ROM dans la VRAM. GameBoy ne peut rendre que les tuiles stock√©es dans une zone de m√©moire sp√©ciale appel√©e VRAM. Heureusement, pour copier de la ROM vers la VRAM, il suffit de l'ex√©cuter </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au stade de l'initialisation du programme. Il s'est av√©r√© qu'avec seulement 6 sprites de caract√®res et 4 tuiles de queue, j'ai d√©j√† pris un quart de la zone VRAM allou√©e aux sprites. (La VRAM est g√©n√©ralement divis√©e en zones d'arri√®re-plan et d'images-objets, et 128 octets leur sont communs.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, l'acc√®s √† OAM n'est possible que pendant VBlank. J'ai commenc√© par dire que VBlank attendait les calculs de sprite, mais j'ai rencontr√© des probl√®mes car les calculs de sprite ont dur√© tout le temps allou√© par VBlank et il √©tait impossible de les terminer. La solution ici consiste √† √©crire dans une </font><font style="vertical-align: inherit;">zone de m√©moire </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distincte en</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dehors de VBlank et √† les copier simplement dans OAM pendant VBlank. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'est av√©r√© que GameBoy a une proc√©dure de copie mat√©rielle sp√©ciale, une sorte de DMA (acc√®s direct √† la m√©moire, acc√®s direct √† la m√©moire) qui fait exactement cela. En √©crivant dans un registre sp√©cifique et en passant au cycle occup√© dans HiRAM (car la ROM n'est pas disponible pendant DMA), vous pouvez copier les donn√©es de la RAM vers OAM beaucoup plus rapidement qu'en utilisant la fonction</font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si vous √™tes int√©ress√©, des d√©tails juteux peuvent √™tre trouv√©s </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, je n'ai pu cr√©er qu'une proc√©dure qui d√©termine </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce qui</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sera finalement √©crit dans le DMA. </font><font style="vertical-align: inherit;">Pour ce faire, j'avais besoin de stocker l'√©tat des objets ailleurs. </font><font style="vertical-align: inherit;">Au minimum, les √©l√©ments suivants √©taient requis:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Type (gecko, renard polaire ou objet de transport d'une des √©quipes) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Direction </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Position X </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Position Y </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cadre d'animation </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Minuterie d'animation </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la premi√®re d√©cision, tr√®s d√©labr√©e, j'ai v√©rifi√© le type de l'objet, et en fonction de lui, je suis pass√© √† une proc√©dure qui dessine de mani√®re sprite ce type d'objet. La proc√©dure du renard polaire, par exemple, a pris une position en X, selon la direction, a ajout√© ou soustrait 16, a ajout√© deux sprites de queue, puis a mont√© et descendu le sprite principal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici une capture d'√©cran de l'apparence du sprite dans VRAM lors du rendu √† l'√©cran. La partie gauche est constitu√©e de sprites individuels, de nombres hexad√©cimaux √† c√¥t√© d'eux, de haut en bas - position verticale et horizontale, pav√© et drapeaux d'attribut. Sur la droite, vous pouvez voir comment tout s'est pass√© apr√®s l'assemblage.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e9/e7d/240/8e9e7d2401e1a07d0c77e2f0c6c99e3d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec l'animation de queue, c'√©tait un peu plus compliqu√©. Dans la premi√®re solution, j'ai simplement effectu√© un incr√©ment du temporisateur d'animation dans chaque image et en ai produit un logique </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec une valeur </font></font><code>%11</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour obtenir le num√©ro de l'image. Ensuite, vous pouvez simplement ajouter 4 * le num√©ro de la trame (chaque trame d'animation se compose de 4 tuiles) √† la premi√®re tuile arri√®re de la VRAM pour obtenir 4 images diff√©rentes stock√©es dans la VRAM. Cela a fonctionn√© (en particulier celui avec la recherche de tuiles de queue), mais la queue a remu√© </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incroyablement</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vite, et j'avais besoin de trouver un moyen de la ralentir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la seconde, meilleure solution, j'ai effectu√© un incr√©ment du </font><font style="vertical-align: inherit;">temporisateur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">global</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans chaque trame </font><font style="vertical-align: inherit;">, et lorsque la valeur de l'op√©ration </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elle</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le degr√© de deux que j'ai choisi √©tait 0, l'incr√©mentation de la minuterie d'objet a √©t√© effectu√©e. Ainsi, chaque objet individuel pouvait d√©compter son minuteur d'animation √† la vitesse dont il avait besoin. Cela a parfaitement fonctionn√© et m'a permis de ralentir la queue √† un niveau raisonnable.</font></font><br><br><h2>  Des difficult√©s </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais si tout √©tait si simple. N'oubliez pas que j'ai g√©r√© tout cela dans le code, en utilisant ma propre sous-proc√©dure pour chaque objet, et si vous deviez continuer, vous devez le faire dans chaque cadre. J'ai d√ª sp√©cifier comment proc√©der pour le sprite suivant, ainsi que la tuile qui le compose, en manipulant manuellement les registres. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'√©tait un syst√®me compl√®tement instable. Pour dessiner une trame, il fallait jongler avec un nombre suffisamment important de registres et de temps CPU. Il √©tait presque impossible d'ajouter un support pour les autres membres du personnel, et m√™me si je r√©ussissais, le support du syst√®me serait tr√®s douloureux. </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Croyez-moi, c'√©tait un vrai chaos.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'avais besoin d'un syst√®me dans lequel le code de rendu des sprites serait g√©n√©ralis√© et simple, de sorte qu'il ne s'agirait pas d'une imbrication de conditions, d'une manipulation de registres et d'op√©rateurs math√©matiques. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment ai-je r√©solu ce probl√®me? </font><font style="vertical-align: inherit;">J'en parlerai dans la prochaine partie de l'article.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47d/f64/3a2/47df643a2bd620cf8899b3601162748b.gif" alt="image"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436330/">https://habr.com/ru/post/fr436330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436320/index.html">De nombreuses propri√©t√©s ou propri√©t√©-objet: crit√®res de s√©lection</a></li>
<li><a href="../fr436322/index.html">@Pythonetc d√©cembre 2018</a></li>
<li><a href="../fr436324/index.html">Trucs et astuces de ma cha√Æne Telegram @pythonetc, d√©cembre 2018</a></li>
<li><a href="../fr436326/index.html">Re-d√©centralisation du web. Pour toujours cette fois</a></li>
<li><a href="../fr436328/index.html">PVS-Studio 7.00</a></li>
<li><a href="../fr436332/index.html">PVS-Studio 7.00</a></li>
<li><a href="../fr436334/index.html">Apprentissage de concepts par interaction sensorimotrice</a></li>
<li><a href="../fr436338/index.html">Comment fonctionne l'a√©roport de Vnoukovo</a></li>
<li><a href="../fr436340/index.html">Niveau de journalisation distinct pour chaque demande</a></li>
<li><a href="../fr436342/index.html">Une introduction √† l'optimisation robuste [... et une petite liste de courses que j'ai oubli√© ...]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>