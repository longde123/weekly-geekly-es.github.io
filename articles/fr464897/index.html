<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌 🉐 🛌🏾 Vous construisez XPath? XPath algorithmique? Rien que XPath 🉑 ✋🏽 👨‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour chers lecteurs. Ce post se concentrera sur les applications légèrement non standard d'un formalisme aussi connu que XPath. Tout le monde sait ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vous construisez XPath? XPath algorithmique? Rien que XPath</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464897/">  Bonjour chers lecteurs.  Ce post se concentrera sur les applications légèrement non standard d'un formalisme aussi connu que XPath.  Tout le monde sait qu'il est très pratique d'extraire des informations à partir de XML ou HTML ou d'autres documents * ML (à la fois du texte brut et des documents virtuels, qui sont la couche supérieure de la représentation de toute information complexe), puis il y a afin de poser ces documents des questions.  Cependant, on sait que mieux la question est formulée, plus elle contient déjà une partie de la réponse.  Par conséquent, une pensée simple se suggère: est-il possible d'utiliser des expressions écrites dans XPath comme affirmant, c'est-à-dire de construire un document pour que cette expression XPath soit vraie?  Je pense que c'est possible, et c'est la première chose qui sera discutée ici.  Et le second - si nous apprenons à créer directement de nouveaux éléments dans un document en utilisant directement XPath, est-il possible de transformer XPath en un langage de programmation algorithmique simple?  En fait, il sait accéder aux données, il sait créer des données.  Il est facile d'imaginer comment décrire la séquence d'opérateurs et l'opérateur de branche sur elle, il reste à penser aux cycles qu'elle contient et aux fonctions.  C'est intéressant, du moins théoriquement.  Et cela sera également discuté. <br><a name="habracut"></a><br><h1>  Construire XPath </h1><br>  Ainsi, XPath ordinaire décrit une séquence d'étapes pour se déplacer dans une arborescence de documents, et une condition de filtre peut être imposée à chaque étape (un prédicat écrit entre crochets).  En conséquence, nous obtenons un ensemble fini de nœuds ou un nombre ou une chaîne ou une valeur logique.  Nous nous intéressons principalement au cas des nœuds multiples.  XPath normal produit des nœuds qui existent déjà dans le document.  Considérons une hypothétique construction XPath qui non seulement renverra des nœuds existants, mais construira également de nouveaux nœuds de manière à ce qu'ils correspondent pleinement à la requête. <br><br>  L'idée est très simple - à l'étape suivante de la requête XPath, nous analyserons le prédicat de filtre et compilerons les variantes de données qui relèvent de ce filtre.  Et puis nous vérifierons laquelle de ces options existe déjà et terminerons la construction de celles qui n'existent pas. <br><br>  Par exemple, voici une requête: <br><br><pre><code class="plaintext hljs">/OBJS/Var[@A=1 and @B=1 or @A=2 or @A=3]/X</code> </pre> <br>  Si nous le considérons comme une construction, nous allons tout d'abord vérifier si l'élément racine &lt;OBJS&gt; existe, et sinon, le créer.  Vient ensuite l'étape Var avec un filtre.  Je ne décrirai pas les règles selon lesquelles le filtre de prédicat est traité afin de ne pas compliquer la présentation, je dirai seulement que ce filtre décrit clairement les trois ensembles de données sur lesquels il est vrai: <br><br><ol><li>  &lt;Var A = ”1” B = ”1” /&gt; </li><li>  &lt;Var A = ”2” /&gt; </li><li>  &lt;Var A = ”3” /&gt; </li></ol><br>  Nous devons donc nous assurer que l'élément &lt;OBJS&gt; a des éléments enfants &lt;Var&gt; avec de telles données.  Et, enfin, l'étape suivante est X sans condition - cela signifie qu'il est nécessaire que chaque élément Var ait un élément enfant &lt;X&gt;. <br><br>  Donc, tout est simple.  À la suite de l'application d'un tel XPath de construction, par exemple, à un document <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">OBJS</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">A</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”2”</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">OBJS</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  on obtient le document de sortie: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">OBJS</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">A</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”2”</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">X</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Var</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">A</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”1”</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">B</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”1”</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">X</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Var</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">A</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”3”</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">X</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Var</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">OBJS</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Et en même temps, nous avons géré exclusivement avec XPath, sans XSL ou quelque chose comme ça. <br><br><h1>  XPath algorithmique </h1><br>  Nous avons donc appris à XPath comment créer des données.  Maintenant, apprenez-lui (un peu) à les traiter de façon algorithmique. <br><br>  La séquence d'opérateurs peut être décrite par une expression ET logique habituelle.  Il est calculé strictement de gauche à droite, c'est ce dont vous avez besoin.  S'il doit être entièrement implémenté, il vous suffit de vous assurer que tous ses éléments renvoient une véritable expression. <br><br><pre> <code class="plaintext hljs">A and B and C … and Z</code> </pre><br>  Un opérateur conditionnel de la forme <strong>if (A) puis B else C</strong> , bien sûr (et je ne dirai rien de nouveau ici), peut être décrit par une expression logique <br><pre> <code class="plaintext hljs">A and B or C</code> </pre><br>  Tout est un peu plus compliqué avec la boucle.  Je ne voulais tout simplement pas l'introduire comme ça, alors j'ai décidé de simplement introduire le concept d'une fonction XPath, qui peut être récursive.  Et puis tout cycle peut être représenté comme une chaîne d'appels récursifs avec vérification de la condition de fin. <br><br>  En principe, c'est presque tout (dans la version minimale).  Même les variables ne sont pas nécessaires - elles sont remplacées par des éléments du document actuel.  Seuls les arguments de fonction nommés sont requis. <br><br>  Je vais vous donner un exemple.  Supposons que nous ayons un document contenant deux listes de nombres décrites par une série d'éléments &lt;list&gt; imbriqués: <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">c</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"3"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"4"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">c</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Soit qu'il soit nécessaire de concaténer des listes de l'élément &lt;b&gt; et de l'élément &lt;c&gt; et de placer le résultat directement dans &lt;a&gt;.  Pour ce faire, trois fonctions XPath doivent être introduites: <br><br><pre> <code class="plaintext hljs">concat_list($#, $##): add_list(#/self::*) and add_list(##/self::*) add_list($#): count(list) = 0 and copy_list(#/self::*) or list[add_list(#/self::*)] or true() copy_list($#): count(#/list) = 0 or create(list[@data = #/list/@data]) and (list[copy_list(#/list)] or true())</code> </pre><br>  et ajoutez-y le XPath appelant: <br><br><pre> <code class="plaintext hljs">concat_list(/a/b,/a/c)</code> </pre><br>  J'espère que, chers lecteurs, il vous sera un peu intéressant de comprendre un tel "code".  La seule chose que je mentionnerai certainement est <strong>create (XPATH)</strong> est une fonction système qui exécute son argument XPATH en mode construction. <br><br>  Et maintenant que tout cela est intéressant, bien sûr, mais la programmation sans variables est encore assez difficile.  Comprenant cela, j'ai introduit des variables à part entière, qui, en fait, dans XPath existent déjà - elles commencent par le signe "$", mais j'ai ajouté la possibilité de leur attribuer des valeurs avec la nouvelle fonction set.  S'il vous plaît, voici un exemple de la fonction depth_list avec deux arguments - une référence à l'élément initial contenant une liste imbriquée d'éléments (comme dans l'exemple ci-dessus), et une variable de sortie qui contient la longueur de la liste: <br><br><pre> <code class="plaintext hljs">depth_list($#, &amp;$OUT1): set($OUT1,0) and (#/list[set($OUT1,1) and depth_list(#/list,$OUT0) and set($OUT1,max($OUT0+1,$OUT1))]) or true()</code> </pre><br><h1>  Conclusion </h1><br>  Dans le micro-langage résultant, que j'ai appelé <strong>XPath Defender</strong> , j'ai ajouté quelques fonctions plus nécessaires et l'ai utilisé dans mon système pour reconnaître et générer des programmes PGEN ++ pour effectuer une tâche aussi importante que l'achèvement automatique du modèle d'un programme présenté comme un document XML.  En d'autres termes, s'il existe une description textuelle d'un problème (pour être définitif, en russe), pour la solution duquel il est nécessaire de générer un programme, alors cette description est reconnue et se transforme en un ensemble ordonné d'éléments d'énoncé de tâche (objets avec paramètres).  Il s'agit de la déclaration initiale, qui ne contient pas encore de plan pour résoudre le problème.  Les éléments reconnus sont placés dans un document XML et les règles leur sont appliquées, écrites à la fois sous forme de délimitation simple ou de génération d'instructions XPath, et sous forme de fragments sur XPath Defender (c'est l'une des options du workflow).  Ces règles valident et complètent le modèle de document XML avec des éléments d'un plan de solution.  Et alors seulement, selon le modèle obtenu, le système construit un programme décisif.  Ce circuit a été testé avec succès sur des problèmes simples de traitement mathématique de données vectorielles. <br><br>  Mais encore, le résultat le plus important, je pense, est le fait qu'il a été possible de prouver qu'il est possible de construire un langage de programmation algorithmique, en utilisant presque exclusivement les moyens de l'habituel et en construisant XPath, il a fallu introduire uniquement des fonctions. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464897/">https://habr.com/ru/post/fr464897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464883/index.html">Vers où se dirige le réseau</a></li>
<li><a href="../fr464887/index.html">Quelques erreurs courantes dans Vue.js (Vuex)</a></li>
<li><a href="../fr464889/index.html">Retour vers le futur des téléphones portables</a></li>
<li><a href="../fr464893/index.html">Nous recherchons des bogues dans le code PHP sans analyseurs statiques</a></li>
<li><a href="../fr464895/index.html">Pourquoi Israël est le moteur du développement de la technologie automobile</a></li>
<li><a href="../fr464899/index.html">L'effondrement d'une ville du Texas qui a manqué de l'argent d'une ferme de bitcoins</a></li>
<li><a href="../fr464901/index.html">Développement du Helpdesk</a></li>
<li><a href="../fr464909/index.html">«Ils nous regardent»: ce qui peut arriver dans une mini-fourgonnette discrète juste sous votre fenêtre</a></li>
<li><a href="../fr464913/index.html">"Know kaizen": quelle est cette philosophie pour améliorer les processus de production</a></li>
<li><a href="../fr464915/index.html">Optimisation de la récursivité de la queue JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>