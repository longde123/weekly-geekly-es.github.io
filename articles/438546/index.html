<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∞Ô∏è üê¨ üè• An√°lisis de los enfoques de enlace de m√≥dulos en Node.js üë®üèΩ‚Äçü§ù‚Äçüë®üèº üñï üíÖüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Muchos desarrolladores de Node.js usan dependencias r√≠gidas de m√≥dulos (exclusivamente) que usan require () para vincular m√≥dulos, pero hay otros enfo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An√°lisis de los enfoques de enlace de m√≥dulos en Node.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438546/"> Muchos desarrolladores de Node.js usan dependencias r√≠gidas de m√≥dulos (exclusivamente) que usan require () para vincular m√≥dulos, pero hay otros enfoques con sus pros y sus contras.  Hablar√© de ellos en este art√≠culo.  Se considerar√°n cuatro enfoques: <br><br><ul><li>  Dependencias duras (require ()) </li><li>  Inyecci√≥n de dependencia </li><li>  Servicio de localizaci√≥n </li><li>  Contenedores de dependencia integrados (contenedor DI) </li></ul><a name="habracut"></a><br><h4>  Un poco sobre m√≥dulos </h4><br>  Los m√≥dulos y la arquitectura modular son la base de Node.js.  Los m√≥dulos proporcionan encapsulaci√≥n (ocultando detalles de implementaci√≥n y abriendo solo la interfaz usando module.exports), reutilizaci√≥n de c√≥digo, divisi√≥n l√≥gica de c√≥digo en archivos.  Casi todas las aplicaciones de Node.js consisten en muchos m√≥dulos que de alguna manera deben interactuar.  Si vincula incorrectamente los m√≥dulos o incluso deja que la interacci√≥n de los m√≥dulos se desv√≠e, entonces puede encontrar r√°pidamente que la aplicaci√≥n comienza a "desmoronarse": los cambios en el c√≥digo en un lugar conducen a una falla en otro, y las pruebas unitarias se vuelven simplemente imposibles.  Idealmente, los m√≥dulos deber√≠an tener una alta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conectividad</a> , pero un bajo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">acoplamiento</a> . <br><br><h2>  Adicciones duras </h2><br>  Se produce una fuerte dependencia de un m√≥dulo con respecto a otro cuando se utiliza require ().  Este es un enfoque efectivo, simple y com√∫n.  Por ejemplo, solo queremos conectar el m√≥dulo responsable de interactuar con la base de datos: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js const db = require('db'); //    ...</span></span></code> </pre> <br><h4>  Pros: </h4><br><ul><li>  Simplicidad </li><li>  Organizaci√≥n visual de los m√≥dulos. </li><li>  Depuraci√≥n f√°cil </li></ul><br><h4>  Contras: </h4><br><ul><li>  Dificultad para reutilizar el m√≥dulo (por ejemplo, si queremos usar nuestro m√≥dulo repetidamente, pero con una instancia diferente de la base de datos) </li><li>  Dificultad para la prueba unitaria (debe crear una instancia de base de datos ficticia y de alguna manera pasarla al m√≥dulo) </li></ul><br><h4>  Resumen: </h4><br>  El enfoque es bueno para peque√±as aplicaciones o prototipos, as√≠ como para conectar m√≥dulos sin estado: f√°bricas, dise√±adores y conjuntos de caracter√≠sticas. <br><br><h2>  Inyecci√≥n de dependencia </h2><br>  La idea principal de la inyecci√≥n de dependencias es transferir dependencias de un componente externo al m√≥dulo.  Por lo tanto, se elimina la dependencia dura en el m√≥dulo y es posible reutilizarlo en diferentes contextos (por ejemplo, con diferentes instancias de base de datos). <br><br>  La inyecci√≥n de dependencias se puede implementar pasando la dependencia en el argumento del constructor o estableciendo las propiedades del m√≥dulo, pero en la pr√°ctica es mejor usar el primer m√©todo.  Apliquemos la implementaci√≥n de dependencias en la pr√°ctica creando una instancia de la base de datos usando la f√°brica y pas√°ndola a nuestro m√≥dulo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js module.exports = (db) =&gt; { //       ... };</span></span></code> </pre> <br>  M√≥dulo externo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dbFactory = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'db'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OurModule = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./ourModule.js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dbInstance = dbFactory.createInstance(<span class="hljs-string"><span class="hljs-string">'instance1'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ourModule = OurModule(dbInstance);</code> </pre> <br>  Ahora no solo podemos reutilizar nuestro m√≥dulo, sino tambi√©n escribir f√°cilmente una prueba unitaria para √©l: simplemente cree un objeto simulado para la instancia de la base de datos y p√°selo al m√≥dulo. <br><br><h4>  Pros: </h4><br><ul><li>  Facilidad de redacci√≥n de pruebas unitarias </li><li>  Aumenta la reutilizaci√≥n de los m√≥dulos. </li><li>  Disminuci√≥n del compromiso, mayor conectividad </li><li>  Cambiar la responsabilidad de crear dependencias a un nivel superior: a menudo esto mejora la legibilidad del programa, ya que las dependencias importantes se recopilan en un solo lugar y no se extienden por m√≥dulos </li></ul><br><h4>  Contras: </h4><br><ul><li>  La necesidad de un dise√±o de dependencia m√°s completo: por ejemplo, se debe seguir un cierto orden de inicializaci√≥n del m√≥dulo </li><li>  La complejidad de la gesti√≥n de dependencias, especialmente cuando hay muchos </li><li>  Deterioro en la comprensibilidad del c√≥digo del m√≥dulo: escribir c√≥digo del m√≥dulo cuando una dependencia proviene del exterior es m√°s dif√≠cil porque no podemos ver directamente esta dependencia. </li></ul><br><h4>  Resumen: </h4><br>  La inyecci√≥n de dependencia aumenta la complejidad y el tama√±o de la aplicaci√≥n, pero a cambio permite la reutilizaci√≥n y facilita las pruebas.  El desarrollador debe decidir qu√© es m√°s importante para √©l en un caso particular: la simplicidad de una dependencia dif√≠cil o las posibilidades m√°s amplias de introducir una dependencia. <br><br><h2>  Servicio de localizaci√≥n </h2><br>  La idea es tener un registro de dependencia que act√∫e como intermediario al cargar una dependencia con cualquier m√≥dulo.  En lugar del enlace r√≠gido, el m√≥dulo solicita dependencias del localizador de servicios.  Obviamente, los m√≥dulos tienen una nueva dependencia: el localizador de servicios en s√≠.  Un ejemplo de un localizador de servicios es el sistema de m√≥dulos Node.js: los m√≥dulos solicitan una dependencia utilizando require ().  En el siguiente ejemplo, crearemos un localizador de servicios, registraremos instancias de bases de datos y nuestro m√≥dulo en √©l. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// serviceLocator.js const dependencies = {}; const factories = {}; const serviceLocator = {}; serviceLocator.register = (name, instance) =&gt; { //[2] dependencies[name] = instance; }; serviceLocator.factory = (name, factory) =&gt; { //[1] factories[name] = factory; }; serviceLocator.get = (name) =&gt; { //[3] if(!dependencies[name]) { const factory = factories[name]; dependencies[name] = factory &amp;&amp; factory(serviceLocator); if(!dependencies[name]) { throw new Error('Cannot find module: ' + name); } } return dependencies[name]; };</span></span></code> </pre> <br>  M√≥dulo externo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> serviceLocator = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./serviceLocator.js'</span></span>)(); serviceLocator.register(<span class="hljs-string"><span class="hljs-string">'someParameter'</span></span>, <span class="hljs-string"><span class="hljs-string">'someValue'</span></span>); serviceLocator.factory(<span class="hljs-string"><span class="hljs-string">'db'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'db'</span></span>)); serviceLocator.factory(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ourModule = serviceLocator.get(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>);</code> </pre> <br>  Nuestro modulo: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js module.exports = (serviceLocator) =&gt; { const db = serviceLocator.get('db'); const someValue = serviceLocator.get('someParameter'); const ourModule = {}; //  ,   ... return ourModule; };</span></span></code> </pre> <br>  Cabe se√±alar que el localizador de servicios almacena f√°bricas de servicios en lugar de instancias, y eso tiene sentido.  Obtuvimos los beneficios de la inicializaci√≥n diferida, y ahora no tenemos que preocuparnos por el orden de inicializaci√≥n de los m√≥dulos: todos los m√≥dulos se inicializar√°n cuando sea necesario.  Adem√°s, tuvimos la oportunidad de almacenar par√°metros en el localizador de servicios (ver "alg√∫n par√°metro"). <br><br><h4>  Pros: </h4><br><ul><li>  Facilidad de redacci√≥n de pruebas unitarias </li><li>  Reutilizar un m√≥dulo es m√°s f√°cil que con una adicci√≥n dif√≠cil </li><li>  Compromiso reducido, mayor conectividad en comparaci√≥n con la adicci√≥n dura </li><li>  Cambiar la responsabilidad de crear dependencias a un nivel superior </li><li>  No es necesario seguir el orden de inicializaci√≥n del m√≥dulo </li></ul><br><h4>  Contras: </h4><br><ul><li>  Reutilizar un m√≥dulo es m√°s dif√≠cil que implementar una dependencia (debido a la dependencia adicional del localizador de servicios) </li><li>  Legibilidad: es a√∫n m√°s dif√≠cil entender qu√© hace la dependencia requerida por el localizador de servicios </li><li>  Mayor compromiso en comparaci√≥n con la inyecci√≥n de dependencia </li></ul><br><h4>  Resumen </h4><br>  En general, un localizador de servicios es similar a la inyecci√≥n de dependencia, de alguna manera es m√°s f√°cil (no hay orden de inicializaci√≥n), en algunos casos es m√°s dif√≠cil (menos que la posibilidad de reutilizar el c√≥digo). <br><br><h2>  Contenedores de dependencia integrados (contenedor DI) </h2><br>  El localizador de servicios tiene un inconveniente debido a que rara vez se aplica en la pr√°ctica: la dependencia de los m√≥dulos del localizador en s√≠.  Los contenedores de dependencia integrados (contenedores DI) no tienen este inconveniente.  De hecho, este es el mismo localizador de servicios con una funci√≥n adicional que determina las dependencias del m√≥dulo antes de crear su instancia.  Puede determinar las dependencias del m√≥dulo analizando y extrayendo argumentos del constructor del m√≥dulo (en JavaScript, puede convertir un enlace a una funci√≥n en una cadena usando toString ()).  Este m√©todo es adecuado si el desarrollo va exclusivamente para el servidor.  Si se escribe el c√≥digo del cliente, a menudo se minimiza y no tendr√° sentido extraer los nombres de los argumentos.  En este caso, la lista de dependencias se puede pasar como una matriz de cadenas (en Angular.js, en funci√≥n del uso de contenedores DI, se utiliza este enfoque).  Implementamos el contenedor DI utilizando el an√°lisis de argumentos de constructor: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fnArgs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'parse-fn-args'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dependencies = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factories = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> diContainer = {}; diContainer.factory = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, factory</span></span></span><span class="hljs-function">) =&gt;</span></span> { factories[name] = factory; }; diContainer.register = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, dep</span></span></span><span class="hljs-function">) =&gt;</span></span> { dependencies[name] = dep; }; diContainer.get = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!dependencies[name]) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factory = factories[name]; dependencies[name] = factory &amp;&amp; diContainer.inject(factory); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!dependencies[name]) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Cannot find module: '</span></span> + name); } } diContainer.inject = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">factory</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args = fnArgs(factory) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dependency</span></span></span><span class="hljs-function"> =&gt;</span></span> diContainer.get(dependency)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, args); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dependencies[name]; };</code> </pre> <br>  En comparaci√≥n con el localizador de servicios, se ha agregado el m√©todo de inyecci√≥n, que determina las dependencias del m√≥dulo antes de crear su instancia.  El c√≥digo del m√≥dulo externo no ha cambiado mucho: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> diContainer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./diContainer.js'</span></span>)(); diContainer.register(<span class="hljs-string"><span class="hljs-string">'someParameter'</span></span>, <span class="hljs-string"><span class="hljs-string">'someValue'</span></span>); diContainer.factory(<span class="hljs-string"><span class="hljs-string">'db'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'db'</span></span>)); diContainer.factory(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ourModule = diContainer.get(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>);</code> </pre> <br>  Nuestro m√≥dulo se ve exactamente igual que con una simple inyecci√≥n de dependencia: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js module.exports = (db) =&gt; { //       ... };</span></span></code> </pre> <br>  Ahora se puede llamar a nuestro m√≥dulo con la ayuda de un contenedor DI y pasarle las instancias de dependencia necesarias directamente, usando una simple inyecci√≥n de dependencia. <br><br><h4>  Pros: </h4><br><ul><li>  Facilidad de redacci√≥n de pruebas unitarias </li><li>  F√°cil reutilizaci√≥n de m√≥dulos. </li><li>  Compromiso reducido, mayor conectividad de m√≥dulos (especialmente en comparaci√≥n con un localizador de servicios) </li><li>  Cambiar la responsabilidad de crear dependencias a un nivel superior </li><li>  No es necesario realizar un seguimiento de la inicializaci√≥n del m√≥dulo </li></ul><br><h4>  El mayor inconveniente: </h4><br><ul><li>  Complicaci√≥n significativa de la l√≥gica de enlace del m√≥dulo </li></ul><br><h4>  Resumen </h4><br>  Este enfoque es m√°s dif√≠cil de entender y contiene un poco m√°s de c√≥digo, pero vale la pena el tiempo dedicado a √©l debido a su poder y elegancia.  En proyectos peque√±os, este enfoque puede ser redundante, pero debe considerarse si se est√° dise√±ando una aplicaci√≥n grande. <br><br><h2>  Conclusi√≥n </h2><br>  Se consideraron los enfoques b√°sicos para el enlace de m√≥dulos en Node.js.  Como suele suceder, la "bala de plata" no existe, pero el desarrollador debe conocer las posibles alternativas y elegir la soluci√≥n m√°s adecuada para cada caso espec√≠fico. <br><br>  El art√≠culo se basa en un cap√≠tulo del libro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Node.js Design Patterns</a> publicado en 2017.  Desafortunadamente, muchas cosas en el libro ya est√°n desactualizadas, por lo que no puedo recomendar al 100% leerlo, pero algunas cosas siguen siendo relevantes hoy. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438546/">https://habr.com/ru/post/438546/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438536/index.html">Bajo el cap√≥ del chatbot: qu√© puede hacer RocketBot y c√≥mo funciona</a></li>
<li><a href="../438538/index.html">Teamlead Conf 2019 Msk: sobre otro formato de comunicaci√≥n</a></li>
<li><a href="../438540/index.html">Tendencias en gesti√≥n de documentos y almacenamiento de datos para 2019</a></li>
<li><a href="../438542/index.html">C√≥mo creamos un servicio de recomendaci√≥n para la selecci√≥n de ropa en redes neuronales</a></li>
<li><a href="../438544/index.html">Vemos pel√≠culas en casa: 10 materiales sobre c√≥mo construir un cine en casa y elegir equipos</a></li>
<li><a href="../438548/index.html">Lombok, sources.jar y depuraci√≥n conveniente</a></li>
<li><a href="../438550/index.html">Otro manifiesto</a></li>
<li><a href="../438554/index.html">Administrar estados y eventos entre componentes en GameObject</a></li>
<li><a href="../438556/index.html">Aserrar datos c√≥modamente</a></li>
<li><a href="../438560/index.html">Escribir XGBoost desde cero - parte 1: √°rboles de decisi√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>