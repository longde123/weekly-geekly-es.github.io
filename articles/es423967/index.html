<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê§ üë©üèº‚Äçüè´ üí≤ Toda la verdad sobre RTOS. Art√≠culo # 10. Programador: funciones avanzadas y preservaci√≥n del contexto üë®üèΩ‚Äçüåæ üêÅ üò¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En un art√≠culo anterior, analizamos los diversos tipos de planificaci√≥n compatibles con RTOS y las capacidades relacionadas en Nucleus SE. En este art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda la verdad sobre RTOS. Art√≠culo # 10. Programador: funciones avanzadas y preservaci√≥n del contexto</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423967/"><img src="https://habrastorage.org/webt/m-/ag/9y/m-ag9yjhbtfwdjmljyermwi6duu.jpeg"><br><br>  En un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior,</a> analizamos los diversos tipos de planificaci√≥n compatibles con RTOS y las capacidades relacionadas en Nucleus SE.  En este art√≠culo, veremos opciones de planificaci√≥n adicionales en Nucleus SE y el proceso de guardar y restaurar el contexto. <br><a name="habracut"></a><br>  Art√≠culos anteriores de la serie: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: implementaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nucleus SE: dise√±o interno y despliegue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N√∫cleo SE: Introducci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otros servicios RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interacci√≥n de tareas y sincronizaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas, cambio de contexto e interrupciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas y planificaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: estructura y modo en tiempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: introducci√≥n.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a> <br><h2>  Caracter√≠sticas opcionales </h2><br>  Durante el desarrollo de Nucleus SE, hice que el n√∫mero m√°ximo de funciones sea opcional, lo que ahorra memoria y / o tiempo. <br><br><h3>  Suspender tareas </h3><br>  Como se mencion√≥ anteriormente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el art√≠culo Planificador: Implementaci√≥n</a> , Nucleus SE admite varias opciones para pausar tareas, pero esta caracter√≠stica es opcional y est√° incluida en el s√≠mbolo <b>NUSE_SUSPEND_ENABLE</b> en <b>nuse_config.h</b> .  Si se establece en <b>TRUE</b> , la estructura de datos se define como <b>NUSE_Task_Status []</b> .  Este tipo de suspensi√≥n se aplica a todas las tareas.  La matriz es del tipo <b>U8</b> , donde se usan 2 nibbles por separado.  Los 4 bits inferiores contienen el estado de la tarea: <br>  <b>NUSE_READY, NUSE_PURE_SUSPEND</b> , <b>NUSE_SLEEP_SUSPEND</b> , <b>NUSE_MAILBOX_SUSPEND</b> , etc.  Si una llamada API suspende una tarea (por ejemplo, <b>NUSE_MAILBOX_SUSPEND</b> ), los 4 bits altos contienen el √≠ndice del objeto en el que se suspende la tarea.  Esta informaci√≥n se usa cuando el recurso est√° disponible y para llamar a la API necesita saber qu√© tareas suspendidas deben reanudarse. <br><br>  Para realizar la suspensi√≥n de la tarea, se utilizan un par de funciones del planificador: <b>NUSE_Suspend_Task ()</b> y <b>NUSE_Wake_Task ()</b> . <br><br>  El c√≥digo <b>NUSE_Suspend_Task ()</b> es el siguiente: <br><br><img src="https://habrastorage.org/webt/ep/1j/gi/ep1jgiocsfdclopsjghruszeggq.png"><br><br>  La funci√≥n guarda el nuevo estado de la tarea (los 8 bits), obtenida como el par√°metro suspend_code.  Cuando habilita el bloqueo (consulte "Bloquear llamadas API" a continuaci√≥n), se <b>guarda el</b> c√≥digo de retorno <b>NUSE_SUCCESS</b> .  A continuaci√≥n, se llama a <b>NUSE_Reschedule ()</b> para transferir el control a la siguiente tarea. <br><br>  El c√≥digo <b>NUSE_Wake_Task ()</b> es bastante simple: <br><br><img src="https://habrastorage.org/webt/br/of/0p/brof0ptcaza3ovc4ykffacmkphy.png"><br><br>  El estado de la tarea se establece en <b>NUSE_READY</b> .  Si no se utiliza el planificador prioritario, la tarea actual contin√∫a ocupando el procesador hasta que llegue el momento de liberar el recurso.  Si se utiliza el planificador prioritario, se llama a <b>NUSE_Reschedule ()</b> con el √≠ndice de tarea como una indicaci√≥n de finalizaci√≥n, ya que la tarea puede tener una prioridad m√°s alta y debe ejecutarse de inmediato. <br><br><h3>  Bloquear llamadas API </h3><br>  Nucleus RTOS admite varias llamadas API con las que un desarrollador puede pausar (bloquear) una tarea si no hay recursos disponibles.  La tarea se reanudar√° cuando los recursos est√©n disponibles nuevamente.  Este mecanismo tambi√©n se implementa en Nucleus SE y es aplicable a varios objetos del n√∫cleo: una tarea puede bloquearse en una secci√≥n de memoria, en un grupo de eventos, buz√≥n, cola, canal o sem√°foro.  Pero, como la mayor√≠a de las herramientas en Nucleus SE, es opcional y se define mediante el s√≠mbolo <b>NUSE_BLOCKING_ENABLE</b> en <b>nuse_config.h</b> .  Si se establece en <b>TRUE</b> , se define la matriz <b>NUSE_Task_Blocking_Return []</b> , que contiene el c√≥digo de retorno para cada tarea;  podr√≠a ser <b>NUSE_SUCCESS</b> o el c√≥digo <b>NUSE_MAILBOX_WAS_RESET</b> , que indica que el objeto se restableci√≥ cuando se bloque√≥ la tarea.  Cuando el bloqueo est√° activado, el c√≥digo correspondiente se incluye en las funciones de la API mediante compilaci√≥n condicional. <br><br><h3>  Contador de horario </h3><br>  Nucleus RTOS calcula cu√°ntas veces se ha programado una tarea desde que se cre√≥ y se restableci√≥ por √∫ltima vez.  Esta caracter√≠stica tambi√©n se implementa en Nucleus SE, pero es opcional y se define mediante el s√≠mbolo <b>NUSE_SCHEDULE_COUNT_SUPPORT</b> en <b>nuse_config.h</b> .  Si se establece en <b>TRUE</b> , se <b>crea</b> una matriz de <b>NUSE_Task_Schedule_Count [] de</b> tipo <b>U16</b> , que almacena el contador de cada tarea en la aplicaci√≥n. <br><br><h3>  Estado inicial de la tarea. </h3><br>  Cuando se crea una tarea en Nucleus RTOS, puede seleccionar su estado: listo o en pausa.  En Nucleus SE, de forma predeterminada, todas las tareas est√°n listas al inicio.  La opci√≥n seleccionada con el s√≠mbolo <b>NUSE_INITIAL_TASK_STATE_SUPPORT</b> en <b>nuse_config.h le</b> permite seleccionar el estado de inicio.  La matriz <b>NUSE_Task_Initial_State []</b> se define en <b>nuse_config.c</b> y requiere la inicializaci√≥n de <b>NUSE_READY</b> o <b>NUSE_PURE_SUSPEND</b> para cada tarea en la aplicaci√≥n. <br><br><h2>  Guardar contexto </h2><br>  La idea de mantener el contexto de una tarea con cualquier tipo de planificador, excepto RTC (Ejecutar hasta su finalizaci√≥n), se present√≥ en el art√≠culo 3 "Tareas y programaci√≥n".  Como ya se mencion√≥, hay varias formas de mantener el contexto.  Dado que Nucleus SE no est√° dise√±ado para procesadores de 32 bits, eleg√≠ usar tablas, no pilas, para mantener el contexto. <br><br>  Se <b>utiliza una</b> matriz bidimensional del tipo <b>ADDR NUSE_Task_Context [] []</b> para guardar el contexto para todas las tareas en la aplicaci√≥n.  Las filas son <b>NUSE_TASK_NUMBER</b> (el n√∫mero de tareas en la aplicaci√≥n), las columnas son <b>NUSE_REGISTERS</b> (el n√∫mero de registros que deben guardarse; depende del procesador y est√° configurado en <b>nuse_types.h)</b> . <br><br>  Por supuesto, mantener el contexto y restaurar el c√≥digo depende del procesador.  Y este es el √∫nico c√≥digo de Nucleus SE vinculado a un dispositivo espec√≠fico (y entorno de desarrollo).  Dar√© un ejemplo del c√≥digo de guardar / restaurar para el procesador ColdFire.  Aunque esta elecci√≥n puede parecer extra√±a debido a un procesador desactualizado, su ensamblador es m√°s f√°cil de leer que los ensambladores de la mayor√≠a de los procesadores modernos.  El c√≥digo es lo suficientemente simple como para usarlo como base para crear un cambio de contexto para otros procesadores: <br><br><img src="https://habrastorage.org/webt/kw/gw/ct/kwgwctpm3q_igjvz2qfhmbi0awm.png"><br><br>  Cuando se requiere el cambio de contexto, este c√≥digo se llama en NUSE_Context_Swap.  Se utilizan dos variables: <b>NUSE_Task_Active</b> , el √≠ndice de la tarea actual, cuyo contexto debe preservarse;  <b>NUSE_Task_Next</b> , el √≠ndice de la tarea cuyo contexto desea cargar (consulte la secci√≥n Datos globales). <br><br>  El proceso de preservaci√≥n del contexto funciona de la siguiente manera: <br><br><ul><li>  Los registros <b>A0</b> y <b>D0 se</b> almacenan temporalmente en la pila; </li><li>  <b>A0 est√°</b> configurado para apuntar a una matriz de bloques de contexto <b>NUSE_Task_Context [] []</b> ; </li><li>  <b>D0 se</b> carga usando <b>NUSE_Task_Active</b> y se multiplica por 72 (ColdFire tiene 18 registros, que requieren 72 bytes para el almacenamiento); </li><li>  entonces <b>D0 se</b> agrega a <b>A0</b> , que ahora apunta a un bloque de contexto para la tarea actual; </li><li>  entonces los registros se almacenan en el bloque de contexto;  primero <b>A0</b> y <b>D0</b> (de la pila), luego <b>D1-D7</b> y <b>A1-A6</b> , luego <b>SR</b> y <b>PC</b> (de la pila, veremos el cambio de contexto iniciado r√°pidamente), y al final se guarda el puntero de la pila. </li></ul><br>  El proceso de carga de contexto es la misma secuencia de acciones en el orden inverso: <br><br><ul><li>  <b>A0 est√°</b> configurado para apuntar a una matriz de bloques de contexto <b>NUSE_Task_Context [] []</b> ; </li><li>  <b>D0 se</b> carga usando <b>NUSE_Task_Active</b> , se incrementa y multiplica por 72; </li><li>  luego <b>D0 se</b> agrega a <b>A0</b> , que ahora apunta al bloque de contexto para la nueva tarea (dado que la carga de contexto debe realizarse en el proceso inverso de guardar la secuencia, primero se requiere el puntero de la pila); </li><li>  entonces los registros se restauran desde el bloque de contexto;  primero, el puntero de la pila, luego <b>PC</b> y <b>SR</b> se <b>insertan</b> en la pila, luego se cargan <b>D1-D7</b> y <b>A1-A6</b> , y al final de <b>D0</b> y <b>A0</b> . </li></ul><br>  La dificultad para implementar el cambio de contexto es que el acceso al registro de estado es dif√≠cil para muchos procesadores (para ColdFire, esto es <b>SR</b> ).  Una soluci√≥n com√∫n es la interrupci√≥n, es decir, la interrupci√≥n del programa o la interrupci√≥n de ramificaci√≥n condicional, lo que hace que el <b>SR se</b> cargue en la pila junto con la <b>PC</b> .  As√≠ es como funciona Nucleus SE en ColdFire.  La macro <b>NUSE_CONTEXT_SWAP ()</b> se establece en <b>nuse_types.h</b> , que se extiende a: <br>  <b>asm ("trampa # 0");</b> <br><br>  El siguiente es el c√≥digo de inicializaci√≥n ( <b>NUSE_Init_Task ()</b> en <b>nuse_init.c</b> ) para bloques de contexto: <br><br><img src="https://habrastorage.org/webt/h7/8n/td/h78ntdz05whdi70d0pkfx-ffnok.png"><br><br>  As√≠ es como se produce la inicializaci√≥n del puntero de la pila, la <b>PC</b> y el <b>SR</b> .  Los dos primeros tienen valores establecidos por el usuario en <b>nuse_config.c</b> .  El valor de <b>SR se</b> define como el car√°cter <b>NUSE_STATUS_REGISTER</b> en <b>nuse_types.h</b> .  Para ColdFire, este valor es <b>0x40002000</b> . <br><br><h2>  Datos globales </h2><br>  El planificador de Nucleus SE requiere muy poca memoria para almacenar datos, pero, por supuesto, utiliza estructuras de datos asociadas con tareas, que se analizar√°n en detalle en los siguientes art√≠culos. <br><br><h3>  Datos de RAM </h3><br>  El planificador no usa los datos ubicados en la ROM, y de 2 a 5 variables globales se colocan en la RAM (todas se configuran en <b>nuse_globals.c</b> ), dependiendo del planificador que se use: <br><br><ul><li>  <b>NUSE_Task_Active</b> : una variable de tipo <b>U8 que</b> contiene el √≠ndice de la tarea actual; </li><li>  <b>NUSE_Task_State</b> : una variable de tipo <b>U8 que</b> contiene un valor que indica el estado del c√≥digo que se est√° ejecutando actualmente, que puede ser una tarea, un controlador de interrupciones o un c√≥digo de inicio;  los valores posibles son: <b>NUSE_TASK_CONTEXT</b> , <b>NUSE_STARTUP_CONTEXT</b> , <b>NUSE_NISR_CONTEXT</b> y <b>NUSE_MISR_CONTEXT</b> ; </li><li>  <b>NUSE_Task_Saved_State</b> : una variable de tipo <b>U8</b> utilizada para proteger el valor de <b>NUSE_Task_State</b> en una interrupci√≥n administrada; </li><li>  <b>NUSE_Task_Next</b> : una variable de tipo <b>U8 que</b> contiene el √≠ndice de la siguiente tarea, que debe programarse para todos los planificadores, excepto RTC; </li><li>  <b>NUSE_Time_Slice_Ticks</b> : una variable de tipo <b>U16 que</b> contiene un contador de <b>segmentos</b> de tiempo;  solo se usa con el planificador de TS. </li></ul><br><h3>  Huella de datos del planificador </h3><br>  El programador de Nucleus SE no utiliza datos de ROM.  La cantidad exacta de datos de RAM var√≠a seg√∫n el planificador utilizado: <br><br><ul><li>  para RTC - 2 bytes ( <b>NUSE_Task_Active</b> y <b>NUSE_Task_State</b> ); </li><li>  para RR y prioridad: 4 bytes ( <b>NUSE_Task_Active</b> , <b>NUSE_Task_State</b> , <b>NUSE_Task_Saved_State</b> y <b>NUSE_Task_Next</b> ); </li><li>  para TS: 6 bytes ( <b>NUSE_Task_Active</b> , <b>NUSE_Task_State</b> , <b>NUSE_Task_Saved_State</b> , <b>NUSE_Task_Next</b> y <b>NUSE_Time_Slice_Ticks</b> ). </li></ul><br><h2>  Implementaci√≥n de otros mecanismos de planificaci√≥n. </h2><br>  A pesar de que Nucleus SE ofrece una opci√≥n de 4 programadores, que cubren la mayor√≠a de los casos, la arquitectura abierta le permite implementar oportunidades para otros casos. <br><br><h3>  Tiempo dividido con tarea en segundo plano </h3><br>  Como ya se describi√≥ en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo n. ¬∞ 3, "Tareas y programaci√≥n", el</a> simple Programador de tiempo de intervalo de tiempo tiene limitaciones porque limita el tiempo m√°ximo que un procesador puede realizar una tarea.  Una opci√≥n m√°s sofisticada ser√≠a agregar soporte para la tarea en segundo plano.  Dicha tarea podr√≠a programarse en cualquier ranura asignada para tareas en pausa y ejecutarse cuando la ranura est√© parcialmente liberada.  Este enfoque le permite programar tareas a intervalos regulares y con un porcentaje predicho del tiempo central del procesador para completar. <br><br><h3>  Prioridad y Round Robin (RR) </h3><br>  En la mayor√≠a de los n√∫cleos en tiempo real, el planificador prioritario admite varias tareas en cada nivel de prioridad, a diferencia de Nucleus SE, donde cada tarea tiene un nivel √∫nico.  Le di preferencia a la √∫ltima opci√≥n, ya que simplifica enormemente las estructuras de datos y, por lo tanto, el c√≥digo del planificador.  Para soportar arquitecturas m√°s complejas, se necesitar√≠an numerosas tablas ROM y RAM. <br><br>  <b>Sobre el autor:</b> Colin Walls ha trabajado en la industria electr√≥nica durante m√°s de treinta a√±os, dedicando la mayor parte de su tiempo al firmware.  Ahora es ingeniero de firmware en Mentor Embedded (una divisi√≥n de Mentor Graphics).  Colin Walls a menudo habla en conferencias y seminarios, autor de numerosos art√≠culos t√©cnicos y dos libros sobre firmware.  Vive en el Reino Unido.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Blog</a> profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de Colin</a> , correo electr√≥nico: colin_walls@mentor.com. <br><br>  <b>Acerca de la traducci√≥n:</b> esta serie de art√≠culos parec√≠a interesante porque, a pesar de los enfoques desactualizados descritos en algunos lugares, el autor, en un lenguaje muy comprensible, presenta al lector poco capacitado las caracter√≠sticas del sistema operativo en tiempo real.  Yo mismo pertenezco al equipo de creadores del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS ruso</a> , que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pretendemos liberar</a> , y espero que el ciclo sea √∫til para los desarrolladores novatos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423967/">https://habr.com/ru/post/es423967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423957/index.html">Generaci√≥n de tr√°fico de espacio de usuario</a></li>
<li><a href="../es423959/index.html">Estuches submarinos: para robots</a></li>
<li><a href="../es423961/index.html">No te pierdas: un nuevo m√©todo para diagnosticar demencia</a></li>
<li><a href="../es423963/index.html">Pr√≥logo de Kelvin Point</a></li>
<li><a href="../es423965/index.html">Usted compr√≥ SIEM y est√° seguro de que SOC est√° en su bolsillo, ¬øverdad?</a></li>
<li><a href="../es423971/index.html">Seminarios web de Skillbox Friday: para desarrolladores de desarrolladores</a></li>
<li><a href="../es423973/index.html">Los creadores de botnets de Mirai ahora luchan contra el crimen del lado del FBI</a></li>
<li><a href="../es423977/index.html">Reuni√≥n con DevOps Deflope en DevOpsConf 2018</a></li>
<li><a href="../es423979/index.html">Panel de biomarcadores de envejecimiento saludable del Reino Unido</a></li>
<li><a href="../es423981/index.html">Libro DDIA (libro con un cerdo) - subir de nivel en la comprensi√≥n de bases de datos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>