<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì≤ ‚òÆÔ∏è üìÅ Conception asynchrone / attente JavaScript: forces, pi√®ges et mod√®les d'utilisation üö£ ü§µüèø üë©üèΩ‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La construction async / wait est apparue dans la norme ES7. Il peut √™tre consid√©r√© comme une am√©lioration remarquable dans le domaine de la programmat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conception asynchrone / attente JavaScript: forces, pi√®ges et mod√®les d'utilisation</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/414373/">  La construction async / wait est apparue dans la norme ES7.  Il peut √™tre consid√©r√© comme une am√©lioration remarquable dans le domaine de la programmation asynchrone en JavaScript.  Il vous permet d'√©crire du code qui ressemble √† synchrone, mais est utilis√© pour r√©soudre des t√¢ches asynchrones et ne bloque pas le thread principal.  Malgr√© le fait que async / attente est une grande nouvelle fonctionnalit√© du langage, son utilisation n'est pas si simple.  Le mat√©riel, dont nous publions la traduction aujourd'hui, est consacr√© √† une √©tude approfondie de l'async / wait et √† une histoire sur la fa√ßon d'utiliser correctement et efficacement ce m√©canisme. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/ea6/61a/e97/ea661ae979bc9999209bca9db6744dc5.png" alt="image"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Points forts de l'async / attente</font> </h2><br>  L'avantage le plus important pour un programmeur utilisant la construction async / wait est qu'il permet d'√©crire du code asynchrone dans un style sp√©cifique au code synchrone.  Comparez le code √©crit en utilisant async / wait avec le code bas√© sur les promesses. <br><br><pre><code class="hljs pgsql">// async/await async getBooksByAuthorWithAwait(authorId) {  const books = await bookModel.fetchAll();  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> books.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(b =&gt; b.authorId === authorId); } //  getBooksByAuthorWithPromise(authorId) {  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bookModel.fetchAll()    .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(books =&gt; books.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(b =&gt; b.authorId === authorId)); }</code> </pre> <br>  Il est facile de remarquer que la version asynchrone / wait de l'exemple est plus compr√©hensible que sa version, dans laquelle la promesse est utilis√©e.  Si vous ne faites pas attention au mot-cl√© <code>await</code> , ce code ressemblera √† un ensemble r√©gulier d'instructions ex√©cut√©es de mani√®re synchrone - comme dans JavaScript familier ou dans tout autre langage synchrone comme Python. <br><br>  L'attractivit√© de async / wait n'est pas seulement due √† une meilleure lisibilit√© du code.  Ce m√©canisme b√©n√©ficie en outre d'une excellente prise en charge du navigateur, qui ne n√©cessite aucune solution de contournement.  Ainsi, aujourd'hui, les fonctions asynchrones prennent enti√®rement en charge tous les principaux navigateurs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b98/324/a94/b98324a94798cf96620a3ed89c88204d.png"></div><br>  <i><font color="#999999">Tous les principaux navigateurs prennent en charge les fonctions asynchrones ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">caniuse.com</a> )</font></i> <br><br>  Ce niveau de support signifie, par exemple, que le code utilisant async / wait n'a pas besoin d'√™tre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">transpos√©</a> .  De plus, il facilite le d√©bogage, ce qui est peut-√™tre encore plus important que l'absence de besoin de transpilation. <br><br>  La figure suivante montre le processus de d√©bogage d'une fonction asynchrone.  Ici, lors de la d√©finition d'un point d'arr√™t sur la premi√®re instruction de la fonction et lors de l'ex√©cution de la commande Step Over, lorsque le d√©bogueur atteint la ligne o√π le mot cl√© <code>await</code> est utilis√©, vous pouvez remarquer comment le d√©bogueur s'arr√™te pendant un certain temps, en attendant que la fonction <code>bookModel.fetchAll()</code> se <code>bookModel.fetchAll()</code> , puis saute √† la ligne o√π la commande <code>.filter()</code> est <code>.filter()</code> !  Un tel processus de d√©bogage semble beaucoup plus simple que les promesses de d√©bogage.  Ici, lors du d√©bogage d'un code similaire, vous devez d√©finir un autre point d'arr√™t dans la ligne <code>.filter()</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23d/bdb/4e0/23dbdb4e062eb7523a1d677e6255e880.gif"><br>  <i><font color="#999999">D√©bogage d'une fonction asynchrone.</font></i>  <i><font color="#999999">Le d√©bogueur attend la fin de la ligne d'attente et passe √† la ligne suivante une fois l'op√©ration termin√©e.</font></i> <br><br>  Une autre force du m√©canisme consid√©r√©, moins √©vidente que ce que nous avons d√©j√† examin√©, est la pr√©sence du mot-cl√© <code>async</code> ici.  Dans notre cas, son utilisation garantit que la valeur retourn√©e par <code>getBooksByAuthorWithAwait()</code> est une promesse.  Par cons√©quent, vous pouvez utiliser en toute s√©curit√© la <code>getBooksByAuthorWithAwait().then(...)</code> ou <code>await getBooksByAuthorWithAwait()</code> construction <code>await getBooksByAuthorWithAwait()</code> dans le code qui appelle cette fonction.  Prenons l'exemple suivant (notez que ce n'est pas recommand√©): <br><br><pre> <code class="hljs javascript">getBooksByAuthorWithPromise(authorId) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!authorId) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bookModel.fetchAll()   .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">books</span></span></span><span class="hljs-function"> =&gt;</span></span> books.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b</span></span></span><span class="hljs-function"> =&gt;</span></span> b.authorId === authorId)); } }</code> </pre> <br>  Ici, la fonction <code>getBooksByAuthorWithPromise()</code> peut, si tout va bien, retourner une promesse ou, si quelque chose s'est mal pass√© - <code>null</code> .  Par cons√©quent, si une erreur se produit, vous ne pouvez pas appeler <code>.then()</code> toute s√©curit√©.  Lors de la d√©claration de fonctions √† l'aide du <code>async</code> erreurs de ce type sont impossibles. <br><br><h2>  <font color="#3AC1EF">√Ä propos de la perception erron√©e de l'async / wait</font> </h2><br>  Dans certaines publications, la construction async / wait est compar√©e aux promesses et repr√©senterait la prochaine g√©n√©ration de l'√©volution de la programmation JavaScript asynchrone.  Sur ce, avec tout le respect que je dois aux auteurs de ces publications, je me permets d'√™tre en d√©saccord.  L'asynchronisation / attente est une am√©lioration, mais ce n'est rien d'autre que du ¬´sucre syntaxique¬ª, dont l'apparence ne conduit pas √† un changement complet du style de programmation. <br><br>  En substance, les fonctions asynchrones sont des promesses.  Avant qu'un programmeur puisse utiliser correctement la construction async / wait, il doit bien √©tudier les promesses.  De plus, dans la plupart des cas, en travaillant avec des fonctions asynchrones, vous devez utiliser des promesses. <br><br>  Jetez un ≈ìil aux fonctions <code>getBooksByAuthorWithAwait()</code> et <code>getBooksByAuthorWithPromises()</code> de l'exemple ci-dessus.  Veuillez noter qu'ils sont identiques non seulement en termes de fonctionnalit√©.  Ils ont √©galement exactement les m√™mes interfaces. <br><br>  Tout cela signifie que si vous appelez directement la fonction <code>getBooksByAuthorWithAwait()</code> , elle renverra la promesse. <br><br>  En fait, l'essence du probl√®me dont nous parlons ici est la perception incorrecte du nouveau design, lorsqu'il cr√©e un sentiment trompeur qu'une fonction synchrone peut √™tre convertie en asynchrone en raison de la simple utilisation de l' <code>async</code> et <code>await</code> mots cl√©s et ne pas penser √† autre chose. <br><br><h2>  <font color="#3AC1EF">Pi√®ges de l'async / attente</font> </h2><br>  Parlons des erreurs les plus courantes qui peuvent √™tre commises en utilisant async / wait.  En particulier, sur l'utilisation irrationnelle d'appels successifs de fonctions asynchrones. <br><br>  Bien que le mot-cl√© <code>await</code> puisse donner au code un aspect synchrone, en l'utilisant, il convient de se rappeler que le code est asynchrone, ce qui signifie que vous devez faire tr√®s attention √† l'appel s√©quentiel des fonctions asynchrones. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getBooksAndAuthor(authorId) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> books = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookModel.fetchAll(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> author = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> authorModel.fetch(authorId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   author,   <span class="hljs-attr"><span class="hljs-attr">books</span></span>: books.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.authorId === authorId), }; }</code> </pre> <br>  Ce code, en termes de logique, semble correct.  Cependant, il y a un s√©rieux probl√®me.  Voil√† comment √ßa marche. <br><br><ol><li>  Les appels syst√®me <code>await bookModel.fetchAll()</code> et attendent la <code>.fetchAll()</code> commande <code>.fetchAll()</code> . </li><li>  Apr√®s avoir re√ßu le r√©sultat de <code>bookModel.fetchAll()</code> <code>await authorModel.fetch(authorId)</code> sera appel√©. </li></ol><br>  Notez que l'appel √† <code>authorModel.fetch(authorId)</code> est ind√©pendant des r√©sultats de l'appel √† <code>bookModel.fetchAll()</code> , et, en fait, ces deux commandes peuvent √™tre ex√©cut√©es en parall√®le.  Cependant, l'utilisation de <code>await</code> entra√Æne l'ex√©cution s√©quentielle de ces deux appels.  Le temps total d'ex√©cution s√©quentielle de ces deux commandes sera plus long que le temps de leur ex√©cution parall√®le. <br><br>  Voici l'approche correcte pour √©crire un tel code: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getBooksAndAuthor(authorId) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bookPromise = bookModel.fetchAll(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> authorPromise = authorModel.fetch(authorId); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> book = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookPromise; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> author = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> authorPromise; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   author,   <span class="hljs-attr"><span class="hljs-attr">books</span></span>: books.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.authorId === authorId), }; }</code> </pre> <br>  Prenons un autre exemple de mauvaise utilisation des fonctions asynchrones.  C'est encore pire que dans l'exemple pr√©c√©dent.  Comme vous pouvez le voir, afin de charger de mani√®re asynchrone une liste de certains √©l√©ments, nous devons compter sur les possibilit√©s de promesses. <br><br><pre> <code class="hljs ruby">async getAuthors(authorIds) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,     /<span class="hljs-regexp"><span class="hljs-regexp">/ const authors = _.map( /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   authorIds, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   id =&gt; await authorModel.fetch(id)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   const promises = _.map(authorIds, id =&gt; authorModel.fetch(id)); const authors = await Promise.all(promises); }</span></span></code> </pre> <br>  En bref, pour utiliser correctement les fonctions asynchrones, vous devez, comme √† un moment o√π cela n'√©tait pas possible, penser d'abord aux op√©rations asynchrones, puis √©crire du code √† l'aide de l' <code>await</code> .  Dans les cas complexes, il sera probablement plus facile d'utiliser directement les promesses. <br><br><h2>  <font color="#3AC1EF">Gestion des erreurs</font> </h2><br>  Lors de l'utilisation de promesses, l'ex√©cution de code asynchrone peut se terminer soit comme pr√©vu - puis ils disent que la promesse est r√©solue avec succ√®s, ou avec une erreur - puis ils disent que la promesse est rejet√©e.  Cela nous permet d'utiliser respectivement <code>.then()</code> et <code>.catch()</code> .  Cependant, la gestion des erreurs √† l'aide du m√©canisme async / attente peut √™tre d√©licate. <br><br><h3>  <font color="#3AC1EF">Construct construction try / catch</font> </h3><br>  La fa√ßon standard de g√©rer les erreurs lors de l'utilisation de async / wait est avec la construction try / catch.  Je recommande d'utiliser cette approche.  Lors d'un appel en attente, la valeur renvoy√©e lorsque la promesse est rejet√©e est pr√©sent√©e comme exception.  Voici un exemple: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookModel</span></span></span><span class="hljs-class"> </span></span>{ fetchAll() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject({<span class="hljs-string"><span class="hljs-string">'error'</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span>}) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>);   }); } } <span class="hljs-comment"><span class="hljs-comment">// async/await async getBooksByAuthorWithAwait(authorId) { try { const books = await bookModel.fetchAll(); } catch (error) { console.log(error);    // { "error": 400 } }</span></span></code> </pre> <br>  L'erreur intercept√©e dans le <code>catch</code> est exactement la valeur obtenue lorsque la promesse est rejet√©e.  Apr√®s avoir intercept√© une exception, nous pouvons appliquer plusieurs approches pour travailler avec elle: <br><br><ul><li>  Vous pouvez g√©rer l'exception et renvoyer la valeur normale.  Si vous n'utilisez pas l'expression de <code>return</code> dans le <code>catch</code> pour renvoyer ce qui est attendu apr√®s l'ex√©cution de la fonction asynchrone, cela √©quivaudra √† utiliser la commande <code>return undefined</code> ;. </li><li>  Vous pouvez simplement transmettre l'erreur √† l'endroit o√π le code qui a √©chou√© a √©t√© appel√© et lui permettre d'y √™tre trait√©.  Vous pouvez lancer une erreur directement en utilisant une commande comme <code>throw error;</code>  , qui vous permet d'utiliser la fonction <code>async getBooksByAuthorWithAwait()</code> dans la cha√Æne de promesses.  Autrement dit, il peut √™tre appel√© √† l'aide de la construction <code>getBooksByAuthorWithAwait().then(...).catch(error =&gt; ...)</code> .  En outre, vous pouvez encapsuler l'erreur dans un objet <code>Error</code> , qui peut ressembler √† <code>throw new Error(error)</code> .  Cela permettra, par exemple, lors de la sortie des informations d'erreur sur la console, d'afficher la pile compl√®te des appels. </li><li>  L'erreur peut √™tre repr√©sent√©e comme une promesse rejet√©e, elle ressemble √† <code>return Promise.reject(error)</code> .  Dans ce cas, cela √©quivaut √† la commande <code>throw error</code> ; cette op√©ration n'est pas recommand√©e. </li></ul><br>  Voici les avantages de l'utilisation de la construction try / catch: <br><br><ul><li>  De tels outils de gestion des erreurs existent en programmation depuis tr√®s longtemps, ils sont simples et compr√©hensibles.  Disons que si vous avez de l'exp√©rience en programmation dans d'autres langages, tels que C ++ ou Java, vous comprendrez facilement le p√©riph√©rique try / catch en JavaScript. </li><li>  Vous pouvez placer plusieurs appels en attente dans un bloc try / catch, ce qui vous permet de g√©rer toutes les erreurs au m√™me endroit si vous n'avez pas besoin de g√©rer s√©par√©ment les erreurs √† chaque √©tape de l'ex√©cution du code. </li></ul><br>  Il convient de noter qu'il existe un inconv√©nient dans le m√©canisme try / catch.  √âtant donn√© que try / catch intercepte toutes les exceptions qui se produisent dans le bloc <code>try</code> , les exceptions qui ne sont pas li√©es aux promesses entreront √©galement dans le gestionnaire de <code>catch</code> .  Jetez un oeil √† cet exemple. <br><br><pre> <code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookModel</span></span></span></span> { fetchAll() {   cb();    //    ,   `cb`  ,       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'/books'</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { bookModel.fetchAll(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(error) { console.log(error);  //       <span class="hljs-string"><span class="hljs-string">"cb is not defined"</span></span> }</code> </pre> <br>  Si vous ex√©cutez ce code, vous verrez le message d'erreur <code>ReferenceError: cb is not defined</code> dans la console.  Ce message est <code>console.log()</code> par la commande <code>console.log()</code> du <code>catch</code> , et non par JavaScript lui-m√™me.  Dans certains cas, de telles erreurs entra√Ænent de graves cons√©quences.  Par exemple, si vous appelez <code>bookModel.fetchAll();</code>  cach√© au fond d'une s√©rie d'appels de fonction et l'un des appels "avalera" une erreur, il sera tr√®s difficile de d√©tecter une telle erreur. <br><br><h3>  <font color="#3AC1EF">‚ñç Fonction retour de deux valeurs</font> </h3><br>  L'inspiration pour la prochaine fa√ßon de g√©rer les erreurs dans le code asynchrone est Go.  Il permet aux fonctions asynchrones de renvoyer √† la fois une erreur et un r√©sultat.  En savoir plus √† ce sujet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  En r√©sum√©, les fonctions asynchrones, avec cette approche, peuvent √™tre utilis√©es comme ceci: <br><br><pre> <code class="hljs powershell">[<span class="hljs-type"><span class="hljs-type">err</span></span>, <span class="hljs-type"><span class="hljs-type">user</span></span>] = await to(UserModel.findById(<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br>  Personnellement, je n'aime pas cela, car cette m√©thode de gestion des erreurs introduit le style de programmation Go dans JavaScript, ce qui ne semble pas naturel, bien que, dans certains cas, cela puisse √™tre tr√®s utile. <br><br><h3>  <font color="#3AC1EF">‚ñçUtilisation de .catch</font> </h3><br>  La derni√®re fa√ßon de g√©rer les erreurs, dont nous parlerons, est d'utiliser <code>.catch()</code> . <br><br>  Pensez √† la fa√ßon dont l' <code>await</code> fonctionne.  √Ä savoir, l'utilisation de ce mot cl√© fait attendre le syst√®me jusqu'√† ce que la promesse termine son travail.  N'oubliez pas non plus qu'une commande de la forme <code>promise.catch()</code> renvoie √©galement une promesse.  Tout cela sugg√®re que les erreurs de fonction asynchrones peuvent √™tre trait√©es comme ceci: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> books   <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>   , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>     let books = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookModel.fetchAll() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); });</code> </pre> <br>  Deux petits probl√®mes caract√©risent cette approche: <br><br><ul><li>  Il s'agit d'un m√©lange de promesses et de fonctions asynchrones.  Pour l'utiliser, il est n√©cessaire, comme dans d'autres cas similaires, de comprendre les caract√©ristiques du travail des promesses. </li><li>  Cette approche n'est pas intuitive, car la gestion des erreurs est effectu√©e dans un endroit inhabituel. </li></ul><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  La construction async / attendent, qui a √©t√© introduite dans ES7, est certainement une am√©lioration des m√©canismes de programmation asynchrone JavaScript.  Cela peut faciliter la lecture et le d√©bogage du code.  Cependant, afin d'utiliser correctement async / wait, une compr√©hension approfondie des promesses est n√©cessaire, car async / wait n'est qu'un ¬´sucre syntaxique¬ª bas√© sur des promesses. <br><br>  Nous esp√©rons que ce mat√©riel vous a permis de vous familiariser avec async / wait, et ce que vous avez appris ici vous √©vitera quelques erreurs courantes qui surviennent lors de l'utilisation de cette construction. <br><br>  <b>Chers lecteurs!</b>  Utilisez-vous la construction async / wait en JavaScript?  Dans l'affirmative, veuillez nous indiquer comment vous g√©rez les erreurs dans le code asynchrone. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414373/">https://habr.com/ru/post/fr414373/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414361/index.html">Unity3D: architecture de jeu, objets scriptables, singletones</a></li>
<li><a href="../fr414363/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 319 (11-17 juin 2018)</a></li>
<li><a href="../fr414367/index.html">Galop en trois ans: ce qui peut √™tre int√©ressant √† relire sur le blog HashFlare</a></li>
<li><a href="../fr414369/index.html">Serveur d'impression √† tol√©rance de pannes Windows</a></li>
<li><a href="../fr414371/index.html">Classe d'√©cole et un petit croquis de l'ing√©nierie sociale</a></li>
<li><a href="../fr414375/index.html">Commandes pour travailler avec la console JavaScript dans les navigateurs et augmenter la productivit√© du programmeur</a></li>
<li><a href="../fr414377/index.html">Innovations des litt√©raux d'objets dans JavaScript ES6</a></li>
<li><a href="../fr414379/index.html">¬´Ceux qui sont pr√™ts √† √©changer la libert√© contre la s√©curit√© ne sont dignes ni de libert√© ni de s√©curit√©¬ª (source originale)</a></li>
<li><a href="../fr414381/index.html">V√©lo √©lectrique Airwheel R8: sous-pilote ou re-bike</a></li>
<li><a href="../fr414383/index.html">Les c√¢bles sous-marins √† fibres optiques peuvent √©galement servir de sismographes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>