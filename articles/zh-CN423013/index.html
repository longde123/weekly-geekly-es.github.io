<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧 🐺 👩‍🌾 如何在Vue应用程序中组织依赖关系 🧚🏼 🌒 👫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="每个熟悉Vue的人都知道Vue应用程序只有一个入口点main.js文件。 除了创建Vue实例外，还存在所有全局依赖项（指令，组件，插件）的导入和一种依赖项注入。 项目越大，依赖项就越多，此外，每个依赖项都有自己的配置。 结果，我们得到了一个包含所有配置的巨大文件。 
 本文将讨论如何组织全局依赖性以...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何在Vue应用程序中组织依赖关系</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423013/">每个熟悉Vue的人都知道Vue应用程序只有一个入口点<code>main.js</code>文件。 除了创建Vue实例外，还存在所有全局依赖项（指令，组件，插件）的导入和一种依赖项注入。 项目越大，依赖项就越多，此外，每个依赖项都有自己的配置。 结果，我们得到了一个包含所有配置的巨大文件。 <br> 本文将讨论如何组织全局依赖性以避免这种情况。 <br><br><img src="https://habrastorage.org/webt/sv/fa/xn/svfaxnl2uh7vozipy4n5to6qpqm.png"><br><a name="habracut"></a><br><h2> 为什么要自己写？ </h2><br> 许多人可能会认为-如果有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nuxt</a> ，这为什么有必要为您解决？ 在我的项目中，我也使用了它，但是在简单的项目中，这可能是多余的。 此外，还没有人取消那些遗留在您身上的遗留代码的项目，就像您的头上积雪一样。 并在那里连接框架-实际上是从头开始。 <br><br><h2> 策划者 </h2><br> 这种组织的组织者是Nuxt。 我在Vue的一个大型项目中使用了它。 <br>  Nuxt有一个很棒的功能-插件。 每个插件都是一个导出函数的文件。 配置被传递给函数，在创建实例以及整个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">商店</a>时，也将传递给Vue构造函数。 <br><br> 此外，每个插件都提供了一个非常有用的功能– <code>inject</code> 。 它对Vue的根实例和<code>store</code>对象进行依赖注入。 这意味着在每个组件，每个存储功能中，指定的依赖项将通过<code>this</code> 。 <br><br><h2> 这可以派上用场吗？ </h2><br> 除了<code>main.js</code>明显“失重”这一事实<code>main.js</code> ，您还将有机会在应用程序中的任何位置使用依赖项，而无需不必要的导入。 <br><br> 依赖注入的主要示例是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">vue-router</a> 。 它并不经常使用-获取当前路由的参数，进行重定向，但这是全局依赖项。 如果它可以在任何组件中派上用场，那么为什么不将其全局化呢？ 另外，由于这个原因，它的状态也将被全局存储并在整个应用程序中改变。 <br><br> 另一个例子是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">vue-wait</a> 。 该插件的开发人员走得更远，不仅将<code>$wait</code>属性添加到Vue实例，还添加到vuex存储。 给定插件的细节，这被证明是非常有用的。 例如，商店具有在多个组件上调用的动作。 在每种情况下，您都需要在某些元素上显示加载程序。 不必在每次操作调用之前和之后调用<code>$wait.start('action')</code>和<code>$wait.end('action')</code> ，只需在操作本身中一次调用这些方法即可。 而且这比<code>dispatch('wait/start', 'action' {root: true})</code>更具可读性，也较省时。 就存储而言，这是语法糖。 <br><br><h2> 从文字到代码 </h2><br><h3> 项目的基本结构 </h3><br> 让我们看看项目现在的样子： <br> <code>src <br> - store <br> - App.vue <br> - main.js <br></code> <br>  <code>main.js</code>看起来像这样： <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App.vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> store <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./store'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vue({ <span class="hljs-attr"><span class="hljs-attr">render</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">h</span></span></span><span class="hljs-function"> =&gt;</span></span> h(App), store }).$mount(<span class="hljs-string"><span class="hljs-string">'#app'</span></span>);</code> </pre><br><br><h3> 我们联系第一个依赖 </h3><br> 现在，我们想将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">axios</a>连接到我们的项目并为其创建某种配置。 我遵循了Nuxt的术语，并在<code>src</code>创建了一个<code>plugins</code>目录。 目录内有<code>index.js</code>和<code>axios.js</code> 。 <br><br> <code>src <br> - plugins <br> -- index.js <br> -- axios.js <br> - store <br> - App.vue <br> - main.js <br></code> <br> 如上所述，每个插件都必须导出一个函数。 同时，在函数内部，我们要访问存储，然后要访问<code>inject</code>函数。 <br><br> <code>axios.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> axios <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'axios'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">app</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       – , , interceptors  .. axios.defaults.baseURL = process.env.API_BASE_URL; axios.defaults.headers.common['Accept'] = 'application/json'; axios.defaults.headers.post['Content-Type'] = 'application/json'; axios.interceptors.request.use(config =&gt; { ... return config; }); }</span></span></code> </pre><br>  <code>index.js</code> ： <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> axios <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./axios'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">app</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inject = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {}; <span class="hljs-comment"><span class="hljs-comment">//   inject,        Dependency Injection axios(app, inject); //       Vue    }</span></span></code> </pre><br><br> 如您所见， <code>index.js</code>文件还导出了该函数。 这样做是为了能够在其中传递<code>app</code>对象。 现在让我们<code>main.js</code>修改<code>main.js</code>并调用此函数。 <br><br>  <code>main.js</code> ： <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App.vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> store <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./store'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> initPlugins <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./plugins'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    // ,    Vue,  ,     initPlugins const app = { render: h =&gt; h(App), store }; initPlugins(app); new Vue(app).$mount('#app'); //   initPlugins   </span></span></code> </pre><br><br><h3> 结果 </h3><br> 在这一阶段，我们已经实现了将插件配置从<code>main.js</code>中删除的单独文件中。 <br><br> 顺便说一句，将<code>app</code>对象传递给我们所有插件的好处是，我们现在可以在每个插件内部访问商店。 您可以通过调用<code>commit</code> ， <code>dispatch</code>以及访问<code>store.state</code>和<code>store.getters</code>来自由使用它。 <br><br> 如果您喜欢ES6风格，则可以执行以下操作： <br><br> <code>axios.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> axios <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'axios'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{store: {dispatch, commit, state, getters}}</span></span></span><span class="hljs-function">) </span></span>{ ... }</code> </pre><br><h2> 第二阶段-依赖注入 </h2><br> 我们已经创建了第一个插件，现在我们的项目如下所示： <br><br> <code>src <br> - plugins <br> -- index.js <br> -- axios.js <br> - store <br> - App.vue <br> - main.js <br></code> <br> 由于在大多数确实需要的库中，已经使用<code>Vue.use</code>实现了依赖注入，因此我们将创建自己的简单插件。 <br><br> 例如，尝试重复<code>vue-wait</code>操作。 这是一个相当繁重的库，因此如果要在一对按钮上显示加载程序，最好放弃它。 但是，我无法抗拒它的便利性，并在其项目中重复了其基本功能，包括商店中的语法糖。 <br><br><h3> 等待插件 </h3><br> 在<code>plugins</code>目录中创建另一个文件<code>wait.js</code> <br><br> 我已经有一个vuex模块，我也称它为<code>wait</code> 。 他执行三个简单步骤： <br><br>  -start-将名为<code>action</code>的对象的state属性设置为<code>true</code> <br>  -end-从状态中删除名为<code>action</code>的对象的属性 <br>  - <code>is</code> -从状态获取名为<code>action</code>的对象的属性 <br><br> 在这个插件中，我们将使用它。 <br><br> <code>wait.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{store: {dispatch, getters}}, inject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = { <span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> dispatch(<span class="hljs-string"><span class="hljs-string">'wait/start'</span></span>, action), <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> dispatch(<span class="hljs-string"><span class="hljs-string">'wait/end'</span></span>, action), <span class="hljs-attr"><span class="hljs-attr">is</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> getters[<span class="hljs-string"><span class="hljs-string">'wait/waiting'</span></span>](action) }; inject(<span class="hljs-string"><span class="hljs-string">'wait'</span></span>, wait); }</code> </pre><br><br> 并连接我们的插件： <br><br>  <code>index.js</code> ： <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> axios <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./axios'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wait <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./wait'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">app</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inject = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {}; Injection axios(app, inject); wait(app, inject); }</code> </pre><br><br><h3> 进样功能 </h3><br> 现在我们实现<code>inject</code>功能。 <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   2 : // name – ,       this.  ,   Vue        Dependency Injection // plugin – ,       this.  ,  ,           let inject = (name, plugin) =&gt; { let key = `$${name}`; //      app[key] = plugin; //     app app.store[key] = plugin; //     store //  Vue.prototype Vue.use(() =&gt; { if (Vue.prototype.hasOwnProperty(key)) { return; } Object.defineProperty(Vue.prototype, key, { get () { return this.$root.$options[key]; } }); }); };</span></span></code> </pre><br><br><h4>  Vue.prototype的魔力 </h4><br> 现在关于魔术。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Vue文档</a>说编写<code>Vue.prototype.$appName = ' ';</code>就足够了<code>Vue.prototype.$appName = ' ';</code> 和<code>$appName</code>将在<code>this</code>可用。 <br><br> 但是，事实证明事实并非如此。 由于谷歌搜索，没有答案为什么这样的设计不起作用。 因此，我决定与已经实现此功能的插件作者联系。 <br><br><h4> 全局混合 </h4><br> 在我们的示例中，我查看了<code>vue-wait</code>插件代码。 他们提供了这样的实现（为清晰起见，清除了源代码）： <br><br><pre> <code class="javascript hljs">Vue.mixin({ beforeCreate() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { wait, store } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$options; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> instance = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; instance.init(Vue, store); <span class="hljs-comment"><span class="hljs-comment">// inject to store this.$wait = instance; // inject to app } });</span></span></code> </pre><br> 建议使用全局混合来代替原型。 效果可能基本相同，除了一些细微差别。 但是，鉴于注入是在此处的商店中完成的，因此看起来并不太正确，并且根本与文档不符。 <br><br><h4> 但是，如果原型呢？ </h4><br> 用于<code>inject</code>函数<code>inject</code>的原型解决方案背后的思想是从Nuxt借来的。 它看起来比全局mixin正确得多，所以我选择了它。 <br><br><pre> <code class="javascript hljs"> Vue.use(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,        if (Vue.prototype.hasOwnProperty(key)) { return; } //    ,         app  Object.defineProperty(Vue.prototype, key, { get () { return this.$root.$options[key]; //  ,    this } }); });</span></span></code> </pre><br><br><h3> 结果 </h3><br> 完成这些操作后，我们将有机会访问<code>this.$wait</code>从任何组件以及商店中的任何方法<code>this.$wait</code> 。 <br><br><h2> 发生什么事了 </h2><br> 项目结构： <br><br> <code>src <br> - plugins <br> -- index.js <br> -- axios.js <br> -- wait.js <br> - store <br> - App.vue <br> - main.js <br></code> <br><br>  <code>index.js</code> ： <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> axios <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./axios'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wait <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./wait'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">app</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inject = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, plugin</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-string"><span class="hljs-string">`$</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">`</span></span>; app[key] = plugin; app.store[key] = plugin; Vue.use(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vue.prototype.hasOwnProperty(key)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(Vue.prototype, key, { get () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$root.$options[key]; } }); }); }; axios(app, inject); wait(app, inject); }</code> </pre><br><br> <code>wait.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{store: {dispatch, getters}}, inject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = { <span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> dispatch(<span class="hljs-string"><span class="hljs-string">'wait/start'</span></span>, action), <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> dispatch(<span class="hljs-string"><span class="hljs-string">'wait/end'</span></span>, action), <span class="hljs-attr"><span class="hljs-attr">is</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> getters[<span class="hljs-string"><span class="hljs-string">'wait/waiting'</span></span>](action) }; inject(<span class="hljs-string"><span class="hljs-string">'wait'</span></span>, wait); }</code> </pre><br><br> <code>axios.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> axios <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'axios'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">app</span></span></span><span class="hljs-function">) </span></span>{ axios.defaults.baseURL = process.env.API_BASE_URL; axios.defaults.headers.common[<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>] = <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>; axios.defaults.headers.post[<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>] = <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>; }</code> </pre><br><br>  <code>main.js</code> ： <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App.vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> store <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./store'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> initPlugins <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./plugins'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = { <span class="hljs-attr"><span class="hljs-attr">render</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">h</span></span></span><span class="hljs-function"> =&gt;</span></span> h(App), store }; initPlugins(app); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vue(app).$mount(<span class="hljs-string"><span class="hljs-string">'#app'</span></span>);</code> </pre><br><h2> 结论 </h2><br> 通过这些操作，我们在<code>main.js</code>文件中收到了一个导入和一个函数调用。 现在，可以立即清楚地在哪里找到每个插件和每个全局依赖项的配置。 <br><br> 添加新插件时，您只需要创建一个导出函数的文件，然后将其导入<code>index.js</code>并调用此函数即可。 <br><br> 在我的实践中，这种结构被证明非常方便，而且很容易在项目之间转移。 现在，如果您需要进行依赖注入或配置其他插件，则无需担心。 <br><br> 在评论中分享您对依赖管理的经验。 成功的项目！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN423013/">https://habr.com/ru/post/zh-CN423013/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN422999/index.html">创建自己的外星数据集</a></li>
<li><a href="../zh-CN423005/index.html">WordPress缓存插件和托管服务Yandex.Zen如何增强我的压力</a></li>
<li><a href="../zh-CN423007/index.html">“ Malyavki，但很好”：我们如何带学生练习</a></li>
<li><a href="../zh-CN423009/index.html">SENS诊断。 蛋白质糖化生物标志物</a></li>
<li><a href="../zh-CN423011/index.html">使用Kubernetes和Istio进行微服务管理</a></li>
<li><a href="../zh-CN423015/index.html">Git：常见错误以及如何修复</a></li>
<li><a href="../zh-CN423017/index.html">Bobbiniki：十个邪教磁带录音机-讲述和展示</a></li>
<li><a href="../zh-CN423021/index.html">Naviaddress在线黑客马拉松</a></li>
<li><a href="../zh-CN423023/index.html">为什么开发人员需要教学</a></li>
<li><a href="../zh-CN423025/index.html">现金计划如何节省分析费用？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>