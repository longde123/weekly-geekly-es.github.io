<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍩 🧘 👨🏾‍🏭 Parsing dan bekerja dengan Codable di Swift 4 🌙 👎🏻 🤡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Format JSON telah mendapatkan popularitas besar, biasanya digunakan untuk transfer data dan eksekusi permintaan dalam aplikasi client-server. Pengurai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Parsing dan bekerja dengan Codable di Swift 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414221/"><img src="https://habrastorage.org/webt/ps/2a/r0/ps2ar08o0byyxycknlktyhdafoq.jpeg"><br><br>  Format JSON telah mendapatkan popularitas besar, biasanya digunakan untuk transfer data dan eksekusi permintaan dalam aplikasi client-server.  Penguraian JSON membutuhkan alat pengodean / dekode format ini, dan Apple baru-baru ini memperbaruinya.  Pada artikel ini, kita akan melihat metode parsing JSON menggunakan protokol <i>Decodable</i> , membandingkan protokol <i>Codable</i> baru dengan pendahulu <i>NSCoding</i> , mengevaluasi kelebihan dan kekurangan, menganalisis segala sesuatu dengan contoh-contoh spesifik, dan juga mempertimbangkan beberapa fitur yang ditemukan ketika mengimplementasikan protokol. <br><a name="habracut"></a><br><br>  <b>Apa itu Codable?</b> <br><br>  Di WWDC2017, bersama dengan versi baru Swift 4, Apple memperkenalkan alat pengodean / dekode data baru yang diimplementasikan oleh tiga protokol berikut: <br><br>  - <b>Codable</b> <br>  - <b>Dikodekan</b> <br>  - Dapat <b>diterjemahkan</b> <br><br>  Dalam kebanyakan kasus, protokol ini digunakan untuk bekerja dengan JSON, tetapi selain itu mereka juga digunakan untuk menyimpan data ke disk, transfer melalui jaringan, dll.  Encodable digunakan untuk mengonversi struktur data Swift ke objek JSON, sementara Decodable, sebaliknya, membantu mengubah objek JSON menjadi model data Swift.  Protokol Codable menggabungkan dua sebelumnya dan tipikanya: <br><br><pre><code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Codable</span></span> = <span class="hljs-type"><span class="hljs-type">Encodable</span></span> &amp; <span class="hljs-type"><span class="hljs-type">Decodable</span></span></code> </pre> <br><br>  Untuk mematuhi protokol ini, tipe data harus menerapkan metode berikut: <br><br>  <i>Dikodekan</i> <br>  encode (to :) - mengkodekan model data ke dalam tipe encoder yang diberikan <br><br>  <i>Diterjemahkan</i> <br>  init (from :) - menginisialisasi model data dari dekoder yang disediakan <br><br>  <i>Codable</i> <br>  encode (ke :) <br>  init (dari :) <br><br>  <b>Kasing sederhana</b> <br><br>  Sekarang perhatikan contoh sederhana menggunakan <i>Codable</i> , karena mengimplementasikan <i>Encodable</i> dan <i>Decodable</i> , dalam contoh ini Anda dapat langsung melihat semua fungsi protokol.  Katakanlah kita memiliki struktur data JSON yang paling sederhana: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Nike shoes"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price"</span></span>: <span class="hljs-number"><span class="hljs-number">10.5</span></span>, <span class="hljs-attr"><span class="hljs-attr">"quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br><br>  Model data untuk bekerja dengan JSON ini akan terlihat seperti ini: <br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title:<span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price:<span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> quantity:<span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> price <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> quantity } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to encoder: Encoder)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = encoder.container(keyedBy: <span class="hljs-type"><span class="hljs-type">CodingKeys</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.encode(title, forKey: .title) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.encode(price, forKey: .price) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.encode(quantity, forKey: .quantity) } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from decoder: <span class="hljs-type"><span class="hljs-type">Decoder</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.container(keyedBy: <span class="hljs-type"><span class="hljs-type">CodingKeys</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) title = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .title) price = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode(<span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .price) quantity = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode(<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .quantity) } }</code> </pre><br><br>  Kedua metode yang diperlukan diimplementasikan, enumerasi juga dijelaskan untuk menentukan daftar bidang encoding / decoding.  Bahkan, menulis dapat sangat disederhanakan karena <i>Codable</i> mendukung <i>pembuatan kode secara</i> otomatis (ke :) dan init (dari :), serta enumerasi yang diperlukan.  Artinya, dalam hal ini, Anda dapat menulis struktur sebagai berikut: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title:<span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price:<span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> quantity:<span class="hljs-type"><span class="hljs-type">Int</span></span> }</code> </pre> <br><br>  Sangat sederhana dan minimalis.  Hanya saja, jangan lupa bahwa rekaman singkat seperti itu tidak akan berfungsi jika: <br><br>  - <i>struktur model data Anda berbeda dari yang Anda ingin encode / decode</i> <br><br>  - <i>Anda mungkin perlu menyandikan / mendekode properti tambahan di samping properti model data Anda</i> <br><br>  - <i>Beberapa properti model data Anda mungkin tidak mendukung protokol Codable.</i>  <i>Dalam hal ini, Anda harus mengonversinya dari / ke protokol Codable</i> <br><br>  - <i>seandainya nama variabel dalam model data dan nama bidang dalam wadah tidak cocok dengan Anda</i> <br><br>  Karena kami telah mempertimbangkan definisi paling sederhana dari suatu model data, ada baiknya untuk memberikan contoh kecil penggunaan praktisnya: <br><br>  Jadi, dalam satu baris, Anda dapat mem-parsing respons server dalam format JSON: <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> product: <span class="hljs-type"><span class="hljs-type">Product</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>! <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>().decode(<span class="hljs-type"><span class="hljs-type">Product</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: data)</code> </pre> <br><br>  Dan kode berikut, sebaliknya, akan membuat objek JSON dari model data: <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> productObject = <span class="hljs-type"><span class="hljs-type">Product</span></span>(title: <span class="hljs-string"><span class="hljs-string">"Cheese"</span></span>, price: <span class="hljs-number"><span class="hljs-number">10.5</span></span>, quantity: <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> encodedData = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">JSONEncoder</span></span>().encode(productObject)</code> </pre> <br><br>  Semuanya sangat mudah dan cepat.  <i>Setelah</i> mendeskripsikan model data dengan benar dan menjadikannya <i>Codable</i> , Anda dapat secara harfiah menyandikan / mendekode data dalam satu baris.  Tapi kami menganggap model data paling sederhana yang berisi sejumlah kecil bidang tipe sederhana.  Pertimbangkan masalah yang mungkin terjadi: <br><br>  <b>Tidak semua bidang dalam model data adalah Codable.</b> <br><br>  Agar model data Anda menerapkan protokol <i>Codable,</i> semua bidang model harus mendukung protokol ini.  Secara default, protokol <i>Codable</i> mendukung tipe data berikut: <i>String, Int, Double, Data, URL</i> .  <i>Codable</i> juga mendukung <i>Array, Kamus, Opsional</i> , tetapi hanya jika mengandung jenis <i>Codable</i> .  Jika beberapa properti model data tidak sesuai dengan <i>Codable</i> , maka mereka harus dibawa ke sana. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> age: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type: <span class="hljs-type"><span class="hljs-type">PetType</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> age <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> type } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from decoder: <span class="hljs-type"><span class="hljs-type">Decoder</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to encoder: Encoder)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { . . . } }</code> </pre> <br><br>  Jika dalam <i>model</i> data <i>Codable</i> kami, kami menggunakan tipe khusus, misalnya, seperti <i>PetType</i> , dan ingin menyandikan / mendekodekannya, maka ia juga harus mengimplementasikan init dan menyandikannya juga. <br><br>  <b>Model data tidak cocok dengan bidang JSON</b> <br><br>  Jika dalam bidang data model 3 Anda didefinisikan, misalnya, dan dalam objek JSON Anda mendapatkan 5 bidang, 2 di antaranya merupakan tambahan untuk 3 bidang tersebut, maka tidak ada yang akan berubah dalam penguraian, Anda hanya mendapatkan 3 bidang dari 5 bidang tersebut. Jika sebaliknya terjadi situasi dan dalam objek JSON akan ada setidaknya satu bidang model data, kesalahan run-time akan terjadi. <br>  Jika beberapa bidang mungkin opsional dan secara berkala tidak ada dalam objek JSON, maka dalam hal ini perlu untuk menjadikannya opsional: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productTypeId: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> art: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currencyId: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brandId: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brand: <span class="hljs-type"><span class="hljs-type">Brand?</span></span> }</code> </pre> <br><br>  <b>Menggunakan struktur JSON yang lebih kompleks</b> <br><br>  Seringkali respons server adalah array entitas, yaitu, Anda meminta, misalnya, daftar toko dan mendapatkan jawaban dalam bentuk: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"link"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://www.youtube.com/watch?v=Myp6rSeCMUw"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"created_at"</span></span>: <span class="hljs-number"><span class="hljs-number">1497868174</span></span>, <span class="hljs-attr"><span class="hljs-attr">"previewImage"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://img.youtube.com/vi/Myp6rSeCMUw/mqdefault.jpg"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"  2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"link"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://www.youtube.com/watch?v=wsCEuNJmvd8"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"created_at"</span></span>: <span class="hljs-number"><span class="hljs-number">1525952040</span></span>, <span class="hljs-attr"><span class="hljs-attr">"previewImage"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://img.youtube.com/vi/wsCEuNJmvd8/mqdefault.jpg"</span></span> } ] }</code> </pre><br>  Dalam hal ini, Anda dapat menulis dan mendekodekanya hanya sebagai array entitas <i>Shop</i> . <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShopListResponse</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decodable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> items } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> items: [<span class="hljs-type"><span class="hljs-type">Shop</span></span>] }</code> </pre> <br><br>  Dalam contoh ini, fungsi otomatis <i>init</i> akan berfungsi, tetapi jika Anda ingin menulis dekode sendiri, Anda harus menentukan jenis yang didekodekan sebagai array: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.items = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode([<span class="hljs-type"><span class="hljs-type">Shop</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .items)</code> </pre> <br><br>  Struktur <i>Shop</i> juga harus mengimplementasikan protokol <i>Decodable.</i> <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shop</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decodable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> address: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shortAddress: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createdAt: <span class="hljs-type"><span class="hljs-type">Date?</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> address <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> shortAddress = <span class="hljs-string"><span class="hljs-string">"short_address"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> createdAt = <span class="hljs-string"><span class="hljs-string">"created_at"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from decoder: <span class="hljs-type"><span class="hljs-type">Decoder</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.container(keyedBy: <span class="hljs-type"><span class="hljs-type">CodingKeys</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.id = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .id) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.title = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .title) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.address = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .address) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.shortAddress = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .shortAddress) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.createdAt = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">Date</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .createdAt) } }</code> </pre> <br><br>  Parsing array elemen ini akan terlihat seperti ini: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parsedResult: <span class="hljs-type"><span class="hljs-type">ShopListResponse</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>().decode(<span class="hljs-type"><span class="hljs-type">ShopListResponse</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: data)</code> </pre> <br><br>  Dengan demikian, Anda dapat dengan mudah bekerja dengan array model data dan menggunakannya di dalam model lain. <br><br>  <b>Format tanggal</b> <br><br>  Dalam contoh ini, ada satu lagi nuansa, di sini kita pertama kali menemukan penggunaan tipe <i>Date</i> .  Saat menggunakan tipe ini, mungkin ada masalah dengan pengkodean tanggal, dan biasanya masalah ini konsisten dengan backend.  Format default adalah <i>.deferToDate</i> : <br><br><pre> <code class="hljs vbscript">struct MyDate : Encodable { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myDate = MyDate(<span class="hljs-built_in"><span class="hljs-built_in">date</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>()) try! encoder.encode(foo)</code> </pre> <br><br>  <i>myDate</i> akan terlihat seperti ini: <br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"date"</span></span> : <span class="hljs-number"><span class="hljs-number">519751611.12542897</span></span> }</code> </pre> <br><br>  Jika kita perlu menggunakan, misalnya, format <i>.iso8601</i> , maka kita dapat dengan mudah mengubah format menggunakan properti <i>dateEncodingStrategy</i> : <br><br><pre> <code class="hljs">encoder.dateEncodingStrategy = .iso8601</code> </pre> <br><br>  Sekarang tanggalnya akan terlihat seperti ini: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"date"</span></span> : <span class="hljs-string"><span class="hljs-string">"2017-06-21T15:29:32Z"</span></span> }</code> </pre><br>  Anda juga dapat menggunakan format tanggal khusus atau bahkan menulis dekoder tanggal Anda sendiri menggunakan opsi pemformatan berikut: <br><br>  <i>.formatted (DateFormatter)</i> - format dekoder tanggalnya sendiri <br>  <i>.custom ((Date, Encoder) throws -&gt; Void)</i> - buat format decoding tanggal Anda sendiri sepenuhnya <br><br>  <b>Parsing Objek Bersarang</b> <br><br>  Kami telah memeriksa bagaimana Anda dapat menggunakan model data di dalam model lain, tetapi kadang-kadang perlu untuk menguraikan bidang JSON yang termasuk dalam bidang lain tanpa menggunakan model data terpisah.  Masalahnya akan lebih jelas jika kita mempertimbangkannya dengan sebuah contoh.  Kami memiliki JSON berikut: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">349</span></span>, <span class="hljs-attr"><span class="hljs-attr">"art"</span></span>: <span class="hljs-string"><span class="hljs-string">"M0470500"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"- Vichy 50 "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ratings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"average_rating"</span></span>: <span class="hljs-number"><span class="hljs-number">4.1034</span></span>, <span class="hljs-attr"><span class="hljs-attr">"votes_count"</span></span>: <span class="hljs-number"><span class="hljs-number">29</span></span> } }</code> </pre> <br><br>  Kita perlu menguraikan bidang <i>"rata-rata"</i> dan <i>"suara_kount"</i> , ini dapat diselesaikan dengan dua cara, baik membuat model data Peringkat dengan dua bidang dan menyimpan data ke dalamnya, atau Anda dapat menggunakan <i>nestedContainer</i> .  Kami sudah membahas kasus pertama, dan penggunaan yang kedua akan terlihat seperti ini: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decodable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> art: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> votesCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> averageRating: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> art <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ratings } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RatingsCodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> votesCount = <span class="hljs-string"><span class="hljs-string">"votes_count"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> averageRating = <span class="hljs-string"><span class="hljs-string">"average_rating"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from decoder: <span class="hljs-type"><span class="hljs-type">Decoder</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.container(keyedBy: <span class="hljs-type"><span class="hljs-type">CodingKeys</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.id = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode(<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .id) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.art = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .art) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.title = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .title) <span class="hljs-comment"><span class="hljs-comment">// Nested ratings let ratingsContainer = try container.nestedContainer(keyedBy: RatingsCodingKeys.self, forKey: .ratings) self.votesCount = try ratingsContainer.decode(Int.self, forKey: .votesCount) self.averageRating = try ratingsContainer.decode(Double.self, forKey: .averageRating) } }</span></span></code> </pre> <br><br>  Artinya, masalah ini diselesaikan dengan membuat wadah tambahan lain menggunakan <i>nestedContainter</i> dan penguraian selanjutnya.  Opsi ini nyaman jika jumlah bidang bersarang tidak begitu besar, jika tidak lebih baik menggunakan model data tambahan. <br><br>  <b>Ketidakcocokan nama bidang JSON dan properti model data</b> <br><br>  Jika Anda memperhatikan bagaimana enumerasi didefinisikan dalam model data kami, Anda dapat melihat bahwa elemen enumerasi kadang-kadang diberikan string yang mengubah nilai default, misalnya: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RatingsCodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> votesCount = <span class="hljs-string"><span class="hljs-string">"votes_count"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> averageRating = <span class="hljs-string"><span class="hljs-string">"average_rating"</span></span> }</code> </pre> <br><br>  Ini dilakukan agar sesuai dengan nama-nama variabel model dan bidang JSON.  Ini biasanya diperlukan untuk bidang yang namanya terdiri dari beberapa kata, dan di JSON mereka dipisahkan oleh garis bawah.  Pada prinsipnya, pendefinisian ulang pencacahan adalah yang paling populer dan terlihat sederhana, tetapi bahkan saat itu Apple datang dengan solusi yang lebih elegan.  Masalah ini dapat diselesaikan dalam satu baris menggunakan <i>keyDecodingStrategy</i> .  Fitur ini muncul di Swift 4.1 <br><br>  Katakanlah Anda memiliki JSON formulir: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> jsonString = <span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">" [ { "</span></span>name<span class="hljs-string"><span class="hljs-string">": "</span></span>MacBook Pro<span class="hljs-string"><span class="hljs-string">", "</span></span>screen_size<span class="hljs-string"><span class="hljs-string">": 15, "</span></span>cpu_count<span class="hljs-string"><span class="hljs-string">": 4 }, { "</span></span>name<span class="hljs-string"><span class="hljs-string">": "</span></span>iMac Pro<span class="hljs-string"><span class="hljs-string">", "</span></span>screen_size<span class="hljs-string"><span class="hljs-string">": 27, "</span></span>cpu_count<span class="hljs-string"><span class="hljs-string">": 18 } ] "</span></span><span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> jsonData = Data(jsonString.utf8)</code> </pre> <br><br>  Mari kita buat model data untuk itu: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mac</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> screenSize: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cpuCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> }</code> </pre><br>  Variabel dalam model dicatat sesuai dengan perjanjian, mulai dengan huruf kecil dan kemudian setiap kata dimulai dengan huruf kapital (yang disebut <i>camelCase</i> ).  Tetapi dalam JSON, bidang ditulis dengan garis bawah (yang disebut <i>snake_case</i> ).  Sekarang, agar parsing berhasil, kita perlu mendefinisikan enumerasi dalam model data di mana kita akan menetapkan korespondensi nama-nama bidang JSON dengan nama-nama variabel, atau kita akan mendapatkan kesalahan runtime.  Tapi sekarang mungkin untuk hanya mendefinisikan <i>keyDecodingStrategy</i> <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> decoder = <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>() decoder.keyDecodingStrategy = .convertFromSnakeCase <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> macs = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.decode([<span class="hljs-type"><span class="hljs-type">Mac</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: jsonData) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error.localizedDescription) }</code> </pre> <br><br>  Untuk fungsi <i>penyandian</i> , Anda dapat menggunakan transformasi terbalik: <br><br><pre> <code class="hljs">encoder.keyEncodingStrategy = .convertToSnakeCase</code> </pre> <br><br>  Dimungkinkan juga untuk menyesuaikan <i>keyDecodingStrategy</i> menggunakan penutupan berikut: <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> jsonDecoder = JSONDecoder() jsonDecoder.keyDecodingStrategy = .custom { keys -&gt; CodingKey <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = keys.last!.stringValue.split(separator: <span class="hljs-string"><span class="hljs-string">"-"</span></span>).joined() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PersonKey(stringValue: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(key))! }</code> </pre> <br><br>  Entri ini, misalnya, memungkinkan penggunaan pemisah "-" untuk JSON.  Contoh JSON yang digunakan: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"first-Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Taylor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"last-Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Swift"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"age"</span></span>: <span class="hljs-number"><span class="hljs-number">28</span></span> }</code> </pre><br>  Dengan demikian, definisi tambahan enumerasi seringkali dapat dihindari. <br><br>  <b>Menangani kesalahan</b> <br><br>  Saat mem-parsing JSON dan mengonversi data dari satu format ke format lain, kesalahan tidak bisa dihindari, jadi mari kita lihat opsi untuk menangani berbagai jenis kesalahan.  Saat mendekode, jenis kesalahan berikut dimungkinkan: <br><br><ul><li>  <i>DecodingError.dataCorrupted (DecodingError.Context)</i> - data rusak.  Biasanya berarti bahwa data yang Anda coba dekode tidak cocok dengan format yang diharapkan, misalnya, alih-alih JSON yang diharapkan, Anda menerima format yang sama sekali berbeda. </li><li>  <i>DecodingError.keyNotFound (CodingKey, DecodingError.Context)</i> - bidang yang diminta tidak ditemukan.  Berarti bidang yang Anda harapkan diterima tidak ada </li><li>  <i>DecodingError.typeMismatch (Any.Type, DecodingError.Context)</i> - ketik ketidakcocokan.  Ketika tipe data dalam model tidak cocok dengan jenis bidang yang diterima </li><li>  <i>DecodingError.valueNotFound (Any.Type, DecodingError.Context)</i> - nilai yang hilang untuk bidang tertentu.  Bidang yang Anda tentukan dalam model data tidak dapat diinisialisasi, mungkin dalam data yang diterima bidang ini nihil.  Kesalahan ini hanya terjadi pada bidang non-opsional, jika bidang tidak harus memiliki nilai, jangan lupa untuk menjadikannya opsional. </li></ul><br><br>  Saat menyandikan data, kesalahan mungkin terjadi: <br><br>  <i>EncodingError.invalidValue (Any.Type, DecodingError.Context)</i> - gagal mengubah model data ke format tertentu <br><br>  Contoh penanganan kesalahan saat mem-parsing JSON: <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> decoder = <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>() <span class="hljs-number"><span class="hljs-number">_</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.decode(businessReviewResponse.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: data) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.dataCorrupted(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.dataCorrupted(context)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.keyNotFound(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.keyNotFound(key,context)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.typeMismatch(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.typeMismatch(type,context)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.valueNotFound(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.valueNotFound(value,context)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error{ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error) }</code> </pre> <br><br>  Pemrosesan kesalahan tentu saja lebih baik untuk dimasukkan ke dalam fungsi yang terpisah, tetapi di sini, untuk kejelasan, analisis kesalahan dilakukan bersama dengan penguraian.  Misalnya, output kesalahan jika tidak ada nilai untuk bidang "produk" akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/vs/1k/ej/vs1kejm3b5lnxigx-aulilgvvqu.jpeg" alt="gambar"><br><br>  <b>Perbandingan Codable dan NSCoding</b> <br><br>  Tentu saja, protokol Codable adalah langkah besar ke depan dalam pengodean / dekode data, tetapi protokol NSCoding ada sebelum itu.  Mari kita coba membandingkannya dan melihat apa manfaat Codable: <br><br><ul><li>  Saat menggunakan protokol <i>NSCoding</i> , objek harus berupa subkelas dari <i>NSObject</i> , yang secara otomatis menyiratkan bahwa model data kami harus kelas.  Dalam <i>Codable</i> , masing-masing tidak perlu pewarisan, model data dapat berupa <i>kelas, dan struct dan enum</i> . </li><li>  Jika Anda memerlukan fungsi enkode dan dekode terpisah, seperti, misalnya, dalam penguraian data JSON yang diterima melalui API, Anda hanya dapat menggunakan satu protokol yang dapat <i>didekodekan</i> .  Artinya, tidak perlu menerapkan <i>init</i> atau metode <i>penyandian yang</i> terkadang tidak perlu. </li><li>  Codable dapat secara otomatis menghasilkan metode <i>init</i> dan <i>enkode yang</i> diperlukan, serta enumerasi <i>CodingKeys</i> opsional.  Ini, tentu saja, hanya berfungsi jika Anda memiliki bidang sederhana dalam struktur data, jika tidak, penyesuaian tambahan akan diperlukan.  Dalam kebanyakan kasus, terutama untuk struktur data dasar, Anda dapat menggunakan pembuatan otomatis, terutama jika Anda mendefinisikan kembali <i>keyDecodingStrategy</i> , ini nyaman dan mengurangi beberapa kode yang tidak perlu. </li></ul><br><br>  <i>Protokol Codable, Decodable,</i> dan <i>Encodable</i> memungkinkan kami untuk mengambil langkah lain menuju kenyamanan konversi data, alat parsing baru yang lebih fleksibel muncul, jumlah kode dikurangi, dan sebagian proses konversi diotomatiskan.  Protokol secara asli diimplementasikan dalam Swift 4 dan memungkinkan untuk mengurangi penggunaan perpustakaan pihak ketiga, seperti <i>SwiftyJSON</i> , sambil mempertahankan kegunaan.  Protokol juga memungkinkan untuk mengatur struktur kode dengan benar dengan memisahkan model data dan metode untuk bekerja dengannya menjadi modul terpisah. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414221/">https://habr.com/ru/post/id414221/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414211/index.html">Pengembangan server TELNET berbasis W5500 dan ATMEGA8</a></li>
<li><a href="../id414213/index.html">Satu, Dua, Tiga! Chatbot dari Google Sheets menggunakan contoh game PvP untuk Alice</a></li>
<li><a href="../id414215/index.html">Blok Kustom dalam Keripik (Silicon IP): Cara Kerja</a></li>
<li><a href="../id414217/index.html">Vertex smartphone lokal: pertama dalam kualitas, pertama dalam chip, pertama dalam desain</a></li>
<li><a href="../id414219/index.html">Pengalaman menggunakan energi surya di wilayah Moskow: untuk, melawan, dan siapa yang membutuhkannya</a></li>
<li><a href="../id414223/index.html">C #: kompatibilitas ke belakang dan kelebihan beban</a></li>
<li><a href="../id414225/index.html">Membuat jaringan sendiri perangkat buatan sendiri berdasarkan Arduino (Bagian 1)</a></li>
<li><a href="../id414227/index.html">Sebuah studi baru tentang indikator Telegram setelah pemblokiran: pelanggan tumbuh, cakupan menurun</a></li>
<li><a href="../id414229/index.html">Analisis berbagai metode pelatihan TI</a></li>
<li><a href="../id414231/index.html">Bagaimana saya membuat komputer yang benar-benar hening</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>