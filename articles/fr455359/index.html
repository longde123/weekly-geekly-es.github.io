<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖüèº üìø üë©üèø‚Äçüíª Swift fonctionnel est facile üòÅ üë®üèø‚Äçü§ù‚Äçüë®üèæ üôãüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les articles sur la programmation fonctionnelle √©crivent beaucoup sur la fa√ßon dont l'approche FP am√©liore le d√©veloppement: il devient facile d'√©crir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift fonctionnel est facile</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/455359/"><p><img src="https://habrastorage.org/webt/ly/by/ev/lybyevylxskr_odybeuhzn4ywa4.jpeg" alt="image"></p><br><p>  Les articles sur la programmation fonctionnelle √©crivent beaucoup sur la fa√ßon dont l'approche FP am√©liore le d√©veloppement: il devient facile d'√©crire, de lire, de diffuser, de coder, de tester, de construire une architecture m√©diocre <del>  et les cheveux deviennent doux et soyeux </del>  . </p><br><p>  Un inconv√©nient est le seuil d'entr√©e √©lev√©.  En essayant de comprendre la FP, je suis tomb√© sur une √©norme quantit√© de th√©orie, de foncteurs, de monades, de th√©orie des cat√©gories et de types de donn√©es alg√©briques.  Et comment appliquer la FA dans la pratique n'√©tait pas claire.  De plus, des exemples ont √©t√© donn√©s dans des langues que je ne connais pas - le haskell et le rock. </p><br><p>  Ensuite, j'ai d√©cid√© de comprendre le FP d√®s le d√©but.  J'ai compris et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dit √† codefest</a> que FP est vraiment juste que nous l'utilisons d√©j√† dans Swift et que nous pouvons l'utiliser encore plus efficacement. </p><a name="habracut"></a><br><h2 id="funkcionalnoe-programmirovanie-chistye-funkcii-i-otsutstvie-sostoyaniy">  Programmation fonctionnelle: fonctions pures et manque d'√©tats </h2><br><p>  D√©terminer ce que signifie √©crire dans un paradigme particulier n'est pas une t√¢che facile.  Les paradigmes ont √©t√© form√©s pendant des d√©cennies par des personnes aux visions diff√©rentes, incarn√©s dans des langues aux approches diff√©rentes, et sont entour√©s d'outils.  Ces outils et approches sont consid√©r√©s comme faisant partie int√©grante des paradigmes, mais en r√©alit√© ils ne le sont pas. </p><br><p>  Par exemple, on pense que la programmation orient√©e objet repose sur trois piliers - h√©ritage, encapsulation et polymorphisme.  Mais l'encapsulation et le polymorphisme sont mis en ≈ìuvre sur les fonctions avec la m√™me facilit√© que sur les objets.  Ou fermetures - ils sont n√©s dans des langages fonctionnels purs, mais ont migr√© si longtemps vers des langages industriels qu'ils ont cess√© d'√™tre associ√©s √† la PF.  Les monades p√©n√®trent √©galement dans les langages industriels, mais n'ont pas encore perdu leur appartenance au Haskell conditionnel dans l'esprit des gens. </p><br><p>  En cons√©quence, il s'av√®re qu'il est impossible de d√©terminer clairement ce qu'est un paradigme particulier.  Encore une fois, je suis tomb√© sur cela au codefest 2019, o√π tous les experts de la FP, parlant du paradigme fonctionnel, ont appel√© des choses diff√©rentes. </p><br><p>  Personnellement, j'ai aim√© la d√©finition du wiki: </p><br><p>  "La programmation fonctionnelle est une section de math√©matiques discr√®tes et un paradigme de programmation dans lequel le processus de calcul est trait√© comme calculant les valeurs des fonctions dans la compr√©hension math√©matique de ces derni√®res (par opposition aux fonctions comme sous-programmes dans la programmation proc√©durale)." </p><br><p>  Qu'est-ce qu'une fonction math√©matique?  Il s'agit d'une fonction dont le r√©sultat ne d√©pend que des donn√©es auxquelles il est appliqu√©. </p><br><p>  Un exemple de fonction math√©matique sur quatre lignes de code ressemble √† ceci: </p><br><pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Int, b: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = summ(a: <span class="hljs-number"><span class="hljs-number">2</span></span>, b: <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><p>  En appelant la fonction somm avec les arguments d'entr√©e 2 et 3, nous obtenons 5. Ce r√©sultat est inchang√©.  Modifiez le programme, le thread, le lieu d'ex√©cution - le r√©sultat restera le m√™me. </p><br><p>  Et une fonction non math√©matique est lorsqu'une variable globale est d√©clar√©e quelque part. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> z = <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br><p>  La fonction somme ajoute maintenant les arguments d'entr√©e et la valeur de z. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Int, b: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b + z } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = summ(a: <span class="hljs-number"><span class="hljs-number">2</span></span>, b: <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><p>  D√©pendance suppl√©mentaire √† l'√©gard de l'√©tat global.  Il est maintenant impossible de pr√©dire sans ambigu√Øt√© la valeur de x.  Il changera constamment en fonction du moment o√π la fonction a √©t√© appel√©e.  Nous appelons la fonction 10 fois de suite, et chaque fois nous pouvons obtenir un r√©sultat diff√©rent. </p><br><p>  Une autre version de la fonction non math√©matique: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Int, b: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { z = b - a <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b }</code> </pre> <br><p>  En plus de renvoyer la somme des arguments d'entr√©e, la fonction modifie la variable globale z.  Cette fonctionnalit√© a un effet secondaire. </p><br><p>  La programmation fonctionnelle a un terme sp√©cial pour les fonctions math√©matiques - les fonctions pures.  Une fonction pure est une fonction qui renvoie le m√™me r√©sultat pour le m√™me ensemble de valeurs d'entr√©e et n'a pas d'effets secondaires. </p><br><p>  Les fonctions pures sont la pierre angulaire de la FP, tout le reste est secondaire.  On suppose que, suivant ce paradigme, nous les utilisons uniquement.  Et si vous ne travaillez pas avec des √©tats globaux ou modifiables, ils ne seront pas dans l'application. </p><br><h2 id="klassy-i-struktury-v-funkcionalnoy-paradigme">  Classes et structures dans un paradigme fonctionnel </h2><br><p>  Au d√©part, je pensais que FP ne concernait que les fonctions, et les classes et les structures ne sont utilis√©es qu'en POO.  Mais il s'est av√©r√© que les cours s'inscrivent √©galement dans le concept de FP.  Seulement, ils devraient √™tre, disons, ¬´propres¬ª. </p><br><p>  Une classe ¬´pure¬ª est une classe dont toutes les m√©thodes sont des fonctions pures et les propri√©t√©s sont immuables.  (Il s'agit d'un terme non officiel, invent√© en pr√©paration du rapport). </p><br><p>  Jetez un oeil √† cette classe: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> surname: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> email: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFullname</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name + <span class="hljs-string"><span class="hljs-string">" "</span></span> + surname } }</code> </pre> <br><p>  Elle peut √™tre consid√©r√©e comme une encapsulation de donn√©es ... </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> surname: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> email: <span class="hljs-type"><span class="hljs-type">String</span></span> }</code> </pre><br><p>  et des fonctions pour travailler avec eux. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFullname</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name + <span class="hljs-string"><span class="hljs-string">" "</span></span> + surname }</code> </pre> <br><p>  Du point de vue de FP, l'utilisation de la classe User n'est pas diff√©rente de l'utilisation de primitives et de fonctions. </p><br><p>  D√©clarez la valeur - utilisateur Vanya. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ivan = <span class="hljs-type"><span class="hljs-type">User</span></span>( name: <span class="hljs-string"><span class="hljs-string">""</span></span>, surname: <span class="hljs-string"><span class="hljs-string">""</span></span>, email: <span class="hljs-string"><span class="hljs-string">"ivanov@example.com"</span></span> )</code> </pre> <br><p>  Appliquez-lui la fonction getFullname. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fullName = ivan.getFullname()</code> </pre> <br><p>  En cons√©quence, nous obtenons une nouvelle valeur - le nom d'utilisateur complet.  Comme vous ne pouvez pas modifier les param√®tres de la propri√©t√© ivan, le r√©sultat de l'appel √† getFullname est inchang√©. </p><br><p>  Bien s√ªr, un lecteur attentif peut dire: ¬´Attendez une minute, la m√©thode getFullname renvoie le r√©sultat en fonction de ses valeurs globales - les propri√©t√©s de classe, pas les arguments.  Mais en r√©alit√©, une m√©thode n'est qu'une fonction dans laquelle un objet est pass√© en argument. </p><br><p>  Swift prend m√™me explicitement en charge cette entr√©e: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fullName = <span class="hljs-type"><span class="hljs-type">User</span></span>.getFullname(ivan)()</code> </pre> <br><p>  Si nous devons modifier une valeur de l'objet, par exemple un e-mail, nous devrons cr√©er un nouvel objet.  Cela peut √™tre fait par la m√©thode appropri√©e. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> surname: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> email: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(email: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">User</span></span>(name: name, surname: surname, email: email) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newIvan = ivan.change(email: <span class="hljs-string"><span class="hljs-string">"god@example.com"</span></span>)</code> </pre> <br><h2 id="funkcionalnye-atributy-v-swift">  Attributs fonctionnels dans Swift </h2><br><p>  J'ai d√©j√† √©crit que de nombreux outils, impl√©mentations et approches qui sont consid√©r√©s comme faisant partie d'un paradigme peuvent en fait √™tre utilis√©s dans d'autres paradigmes.  Par exemple, les monades, les types de donn√©es alg√©briques, l'inf√©rence de type automatique, le typage strict, les types d√©pendants, la v√©rification de l'exactitude du programme pendant la compilation sont consid√©r√©s comme faisant partie du FP.  Mais beaucoup de ces outils que nous pouvons trouver dans Swift. </p><br><p>  La frappe forte et l'inf√©rence de type font partie de Swift.  Ils n'ont pas besoin d'√™tre compris ou introduits dans le projet, nous les avons juste. </p><br><p>  Il n'y a pas de types d√©pendants, m√™me si je ne refuserais pas de v√©rifier la cha√Æne par le compilateur que c'est un email, un tableau, qu'il n'est pas vide, un dictionnaire, qu'il contient la cl√© apple.  Soit dit en passant, il n'y a pas non plus de types d√©pendants dans Haskell. </p><br><p>  Les types de donn√©es alg√©briques sont disponibles, et c'est une chose math√©matique cool, mais difficile √† comprendre.  La beaut√© est qu'il n'a pas besoin d'√™tre compris math√©matiquement pour pouvoir l'utiliser.  Par exemple, Int, enum, Facultatif, Hashable sont des types alg√©briques.  Et si Int est dans de nombreux langages et que Protocol est en Objective-C, alors l'√©num√©ration avec les valeurs associ√©es, les protocoles avec impl√©mentation par d√©faut et les types associatifs sont loin d'√™tre partout. </p><br><p>  La validation de la compilation est souvent mentionn√©e lorsque l'on parle de langues comme la rouille ou le haskell.  Il est entendu que le langage est si expressif qu'il vous permet de d√©crire tous les cas limites afin qu'ils soient v√©rifi√©s par le compilateur.  Donc, si le programme a √©t√© compil√©, il fonctionnera certainement.  Personne ne conteste qu'il puisse contenir des erreurs dans la logique, car vous avez incorrectement filtr√© les donn√©es √† afficher pour l'utilisateur.  Mais cela ne tombera pas, car vous n'avez pas re√ßu de donn√©es de la base de donn√©es, le serveur a renvoy√© la mauvaise r√©ponse pour laquelle vous vous attendiez, ou l'utilisateur a entr√© sa date de naissance sous la forme d'une cha√Æne, pas d'un nombre. </p><br><p>  Je ne peux pas dire que la compilation de code rapide peut attraper tous les bogues: par exemple, il est facile d‚Äô√©viter une fuite de m√©moire.  Mais une frappe forte et une protection facultative contre de nombreuses erreurs stupides.  L'essentiel est de limiter l'extraction forc√©e. </p><br><h2 id="monady-ne-chast-paradigmy-fp-a-instrument-neobyazatelnyy">  Monades: ne fait pas partie du paradigme de la PF, mais un outil (facultatif) </h2><br><p>  Assez souvent, les FP et les monades sont utilis√©s dans la m√™me application.  √Ä un moment donn√©, je pensais m√™me que les monades sont une programmation fonctionnelle.  Quand je les ai compris (mais ce n'est pas exact), j'ai tir√© plusieurs conclusions: </p><br><ul><li>  ils sont simples; </li><li>  ils sont confortables; </li><li>  les comprendre √©ventuellement, il suffit de pouvoir postuler; </li><li>  vous pouvez facilement vous en passer. </li></ul><br><p>  Swift a d√©j√† deux monades standard - facultative et r√©sultat.  Les deux sont n√©cessaires pour faire face aux effets secondaires.  En option prot√®ge contre z√©ro possible.  R√©sultat - de diverses situations exceptionnelles. </p><br><p>  Prenons l'exemple amen√© au point d'absurdit√©.  Supposons que nous ayons des fonctions qui renvoient un entier de la base de donn√©es et du serveur.  La seconde peut retourner nil, mais nous utilisons l'extraction implicite pour obtenir le comportement Objective-C-time. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int!</span></span></code> </pre> <br><p>  Nous continuons d'ignorer Facultatif et impl√©mentons une fonction pour additionner ces nombres. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int!</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromDB = getIntFromDB() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = getIntFromServer()! <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> summ = intFromDB + intFromServer <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summ }</code> </pre> <br><p>  Nous appelons la fonction finale et utilisons le r√©sultat. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result)</code> </pre> <br><p>  Cet exemple fonctionnera-t-il?  Eh bien, il se compile d√©finitivement, mais personne ne sait si nous obtenons le crash au moment de l'ex√©cution.  Ce code est bon, il montre parfaitement nos intentions (nous avons besoin de la somme de deux nombres environ) et il ne contient rien de superflu.  Mais il est dangereux.  Par cons√©quent, seuls les juniors et les personnes confiantes √©crivent de cette fa√ßon. </p><br><p>  Modifiez l'exemple pour le rendre s√ªr. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromDB = getIntFromDB() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = getIntFromServer() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = intFromServer { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> summ = intFromDB + intFromServer <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre> <br><p>  Ce code est bon, il est s√ªr.  En utilisant une extraction explicite, nous nous sommes d√©fendus contre un z√©ro possible.  Mais cela est devenu lourd, et parmi les contr√¥les s√ªrs, il est d√©j√† difficile de discerner notre intention.  Nous avons encore besoin de la somme de deux chiffres, pas d'un contr√¥le de s√©curit√©. </p><br><p>  Dans ce cas, Optional a une m√©thode de mappage, h√©rit√©e du type Maybe de Haskell.  Nous l'appliquons et l'exemple va changer. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromDB = getIntFromDB() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = getIntFromServer() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intFromServer.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x + intFromDB } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre> <br><p>  Ou encore plus compact. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getintFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getintFromServer().<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span> + getIntFromDB() } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre> <br><p>  Nous avons utilis√© map pour convertir intFromServer au r√©sultat dont nous avons besoin sans extraction. </p><br><p>  Nous nous sommes d√©barrass√©s du ch√®que √† l'int√©rieur des sommets, mais nous l'avons laiss√© au niveau sup√©rieur.  Cela se fait intentionnellement, car √† la fin de la cha√Æne de calcul, nous devons choisir une m√©thode pour traiter le manque de r√©sultat. </p><br><p>  √âjecter </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre><br><p>  Utiliser la valeur par d√©faut </p><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result ?? <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p>  Ou affichez un avertissement si les donn√©es ne sont pas re√ßues. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>) }</code> </pre> <br><p>  Maintenant, le code dans l'exemple ne contient pas trop, comme dans le premier exemple, et est s√ªr, comme dans le second. </p><br><p>  Mais la carte ne fonctionne pas toujours comme il se doit </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">String?</span></span> = <span class="hljs-string"><span class="hljs-string">"7"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = a.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-type"><span class="hljs-type">Int</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>) } type(of: b)<span class="hljs-comment"><span class="hljs-comment">//Optional&lt;Optional&lt;Int&gt;&gt;</span></span></code> </pre> <br><p>  Si nous transmettons une fonction √† la carte dont le r√©sultat est facultatif, nous obtenons un double facultatif.  Mais nous n'avons pas besoin d'une double protection contre z√©ro.  Un suffit.  La m√©thode flatMap permet de r√©soudre le probl√®me, c'est un analogue de carte √† une diff√©rence pr√®s, elle d√©ploie les poup√©es gigognes. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">String?</span></span> = <span class="hljs-string"><span class="hljs-string">"7"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = a.flatMap { <span class="hljs-type"><span class="hljs-type">Int</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>) } type(of: b)<span class="hljs-comment"><span class="hljs-comment">//Optional&lt;Int&gt;.</span></span></code> </pre> <br><p>  Un autre exemple o√π map et flatMap ne sont pas tr√®s pratiques √† utiliser. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = a.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span> + b! }</code> </pre><br><p>  Et si une fonction prend deux arguments et qu'ils sont tous les deux optionnels?  Bien s√ªr, FP a une solution - il s'agit d'un foncteur applicatif et d'un curry.  Mais ces outils semblent plut√¥t maladroits sans utiliser d'op√©rateurs sp√©ciaux qui ne sont pas dans notre langue, et √©crire des op√©rateurs personnalis√©s est consid√©r√© comme une mauvaise forme.  Par cons√©quent, nous consid√©rons une mani√®re plus intuitive: nous √©crivons une fonction sp√©ciale. </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@discardableResult</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perform</span></span></span><span class="hljs-function">&lt;Result, U, Z&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> transform: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(U, Z)</span></span></span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> optional1: <span class="hljs-type"><span class="hljs-type">U?</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> optional2: <span class="hljs-type"><span class="hljs-type">Z?</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">rethrows</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> optional1 = optional1, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> optional2 = optional2 <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> transform(optional1, optional2) }</code> </pre> <br><p>  Il prend deux valeurs facultatives comme arguments et une fonction avec deux arguments.  Si les deux options ont des valeurs, une fonction leur est appliqu√©e. <br>  Maintenant, nous pouvons travailler avec plusieurs options sans les d√©ployer. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = perform(+, a, b)</code> </pre> <br><p>  La deuxi√®me monade, Result, a √©galement des m√©thodes map et flatMap.  Vous pouvez donc travailler avec lui exactement de la m√™me mani√®re. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">ServerError</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">ServerError</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromDB = getIntFromDB() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = getIntFromServer() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intFromServer.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x + intFromDB } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .success(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result) = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre> <br><p>  En fait, c'est ce qui rassemble les monades - la possibilit√© de travailler avec la valeur √† l'int√©rieur du conteneur sans l'enlever.  √Ä mon avis, cela rend le code concis.  Mais si vous ne l'aimez pas, utilisez simplement des extraits explicites, cela ne contredit pas le paradigme FP. </p><br><h2 id="primer-sokraschaem-chislo-gryaznyh-funkciy">  Exemple: r√©duction du nombre de fonctions sales </h2><br><p>  Malheureusement, dans les programmes r√©els, les √©tats globaux et les effets secondaires sont partout - demandes de r√©seau, sources de donn√©es, interfaces utilisateur.  Et seules les fonctions pures ne peuvent √™tre supprim√©es.  Mais cela ne veut pas dire que le FP nous est compl√®tement inaccessible: on peut essayer de r√©duire le nombre de fonctions sales, qui sont g√©n√©ralement tr√®s nombreuses. </p><br><p>  Regardons un petit exemple proche du d√©veloppement de la production.  Cr√©ez une interface utilisateur, en particulier un formulaire d'inscription.  Le formulaire pr√©sente certaines limites: </p><br><p>  1) Connectez-vous pas moins de 3 caract√®res <br>  2) Mot de passe d'au moins 6 caract√®res <br>  3) Le bouton ¬´Connexion¬ª est actif si les deux champs sont valides. <br>  4) La couleur du cadre de champ refl√®te son √©tat, noir - est valide, rouge - n'est pas valide </p><br><p>  Le code d√©crivant ces restrictions peut ressembler √† ceci: </p><br><p>  G√©rer toute entr√©e utilisateur </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textFieldTextDidChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1.     // 2.   guard let login = loginView.text, let password = passwordView.text else { // 3. - loginButton.isEnabled = false return } let loginIsValid = login.count &gt; constants.loginMinLenght if loginIsValid { // 4. - loginView.layer.borderColor = constants.normalColor } let passwordIsValid = password.count &gt; constants.passwordMinLenght if passwordIsValid { // 5. - passwordView.layer.borderColor = constants.normalColor } // 6. - loginButton.isEnabled = loginIsValid &amp;&amp; passwordIsValid }</span></span></code> </pre> <br><p>  Traitement de l'ach√®vement de la connexion: </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginDidEndEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: <span class="hljs-type"><span class="hljs-type">CGColor</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1.     // 2.   if let login = loginView.text, login.count &gt; 3 { color = constants.normalColor } else { color = constants.errorColor } // 3.   loginView.layer.borderColor = color }</span></span></code> </pre> <br><p>  Traitement de l'ach√®vement du mot de passe: </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">passwordDidEndEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: <span class="hljs-type"><span class="hljs-type">CGColor</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1.     // 2.   if let password = passwordView.text, password.count &gt; 6 { color = constants.normalColor } else { color = constants.errorColor } // 3. - passwordView.layer.borderColor = color }</span></span></code> </pre> <br><p>  En appuyant sur le bouton Entr√©e: </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1.     // 2.   guard let login = loginView.text, let password = passwordView.text else { return } auth(login: login, password: password) { [weak self] user, error in if let user = user { /*  */ } else if error is AuthError { guard let `self` = self else { return } // 3. - self.passwordView.layer.borderColor = self.constants.errorColor // 4. - self.loginView.layer.borderColor = self.constants.errorColor } else { /*   */ } } }</span></span></code> </pre> <br><p>  Ce code n'est peut-√™tre pas le meilleur, mais dans l'ensemble, il est bon et fonctionne.  Certes, il a un certain nombre de probl√®mes: </p><br><ul><li>  4 extraits explicites; </li><li>  4 d√©pendances de l'√©tat global; </li><li>  8 effets secondaires; </li><li>  √©tats finaux non √©vidents; </li><li>  √©coulement non lin√©aire. </li></ul><br><p>  Le principal probl√®me est que vous ne pouvez pas simplement prendre et dire ce qui se passe avec notre √©cran.  En regardant une m√©thode, nous voyons ce qu'elle fait avec un √©tat global, mais nous ne savons pas qui, o√π et quand elle touche l'√©tat.  Par cons√©quent, pour comprendre ce qui se passe, vous devez trouver tous les points de travail avec les vues et comprendre dans quel ordre les influences se produisent.  Garder tout cela √† l'esprit est tr√®s difficile. </p><br><p>  Si le processus de changement d'√©tat est lin√©aire, vous pouvez l'√©tudier √©tape par √©tape, ce qui r√©duira la charge cognitive du programmeur. </p><br><p>  Essayons de changer l'exemple pour le rendre plus fonctionnel. </p><br><p>  Tout d'abord, nous d√©finissons un mod√®le qui d√©crit l'√©tat actuel de l'√©cran.  Cela vous permettra de savoir exactement quelles informations sont n√©cessaires pour le travail. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginOutputModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> login: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> password: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loginIsValid: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> login.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> &gt; <span class="hljs-number"><span class="hljs-number">3</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> passwordIsValid: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> password.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> &gt; <span class="hljs-number"><span class="hljs-number">6</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isValid: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loginIsValid &amp;&amp; passwordIsValid } }</code> </pre> <br><p>  Un mod√®le qui d√©crit les changements appliqu√©s √† l'√©cran.  Elle a besoin de savoir exactement ce que nous allons changer. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginInputModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> loginBorderColor: <span class="hljs-type"><span class="hljs-type">CGColor?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> passwordBorderColor: <span class="hljs-type"><span class="hljs-type">CGColor?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> loginButtonEnable: <span class="hljs-type"><span class="hljs-type">Bool?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> popupErrorMessage: <span class="hljs-type"><span class="hljs-type">String?</span></span> }</code> </pre> <br><p>  √âv√©nements pouvant conduire √† un nouvel √©tat d'√©cran.  Nous saurons donc exactement quelles actions changent l'√©cran. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> textFieldTextDidChange <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> loginDidEndEdit <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> passwordDidEndEdit <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> loginPressed <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> authFailure(<span class="hljs-type"><span class="hljs-type">Error</span></span>) }</code> </pre> <br><p>  Nous d√©crivons maintenant la principale m√©thode de changement.  Cette fonction pure, bas√©e sur l'√©v√©nement d'√©tat actuel, collecte un nouvel √©tat de l'√©cran. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeInputModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( event: Event, outputModel: LoginOutputModel?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> event { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .textFieldTextDidChange: <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mapValidToColor: (<span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">CGColor?</span></span> = { $<span class="hljs-number"><span class="hljs-number">0</span></span> ? normalColor : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>( loginBorderColor: outputModel .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.loginIsValid } .flatMap(mapValidToColor), passwordBorderColor: outputModel .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.passwordIsValid } .flatMap(mapValidToColor), loginButtonEnable: outputModel?.passwordIsValid ) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .loginDidEndEdit: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .passwordDidEndEdit: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .loginPressed: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .authFailure(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> error <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">AuthError</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .authFailure: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) } }</code> </pre> <br><p>  La chose la plus importante est que cette m√©thode est la seule autoris√©e √† s'engager dans la construction d'un nouvel √âtat - et c'est propre.  Il peut √™tre √©tudi√© √©tape par √©tape.  Voyez comment les √©v√©nements transforment l'√©cran du point A au point B. Si quelque chose se brise, le probl√®me est exactement l√†.  Et c'est facile √† tester. </p><br><p>  Ajoutez une propri√©t√© auxiliaire pour obtenir l'√©tat actuel, c'est la seule m√©thode qui d√©pend de l'√©tat global. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outputModel: <span class="hljs-type"><span class="hljs-type">LoginOutputModel?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> perform(<span class="hljs-type"><span class="hljs-type">LoginOutputModel</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>, loginView.text, passwordView.text) }</code> </pre> <br><p>  Ajoutez une autre m√©thode ¬´sale¬ª pour cr√©er les effets secondaires du changement d'√©cran. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event: Event)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inputModel = makeInputModel(event: event, outputModel: outputModel) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color = inputModel.loginBorderColor { loginView.layer.borderColor = color } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color = inputModel.passwordBorderColor { passwordView.layer.borderColor = color } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isEnable = inputModel.loginButtonEnable { loginButton.isEnabled = isEnable } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = inputModel.popupErrorMessage { showPopup(error) } }</code> </pre> <br><p>  Bien que la m√©thode updateView ne soit pas propre, c'est le seul endroit o√π les propri√©t√©s de l'√©cran changent.  Premier et dernier √©l√©ment de la cha√Æne de calculs.  Et si quelque chose a mal tourn√©, c'est l√† que le point d'arr√™t sera. </p><br><p>  Il ne reste plus qu'√† d√©marrer la conversion aux bons endroits. </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textFieldTextDidChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { updateView(.textFieldTextDidChange) } <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginDidEndEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { updateView(.loginDidEndEdit) } <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">passwordDidEndEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { updateView(.passwordDidEndEdit) }</code> </pre> <br><p>  La m√©thode loginPressed est sortie un peu unique. </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { updateView(.loginPressed) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> completion: (<span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">User</span></span>, <span class="hljs-type"><span class="hljs-type">Error</span></span>&gt;) -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> result { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .success(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user): <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .failure(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error): <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.updateView(.authFailure(error)) } } outputModel.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { auth(login: $<span class="hljs-number"><span class="hljs-number">0</span></span>.login, password: $<span class="hljs-number"><span class="hljs-number">0</span></span>.password, completion: completion) } }</code> </pre> <br><p>  Le fait est que cliquer sur le bouton ¬´Connexion¬ª lance deux cha√Ænes de calculs, ce qui n'est pas interdit. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Avant d'√©tudier la PF, j'ai mis un fort accent sur les paradigmes de programmation.  Il √©tait important pour moi que le code suive la POO, je n'aimais pas les fonctions statiques ou les objets sans √©tat, je n'√©crivais pas les fonctions globales. </p><br><p>  Maintenant, il me semble que toutes ces choses que je consid√©rais comme faisant partie d'un paradigme sont plut√¥t arbitraires.  L'essentiel est un code propre et compr√©hensible.  Pour atteindre cet objectif, vous pouvez utiliser tout ce qui est possible: fonctions pures, classes, monades, h√©ritage, composition, inf√©rence de type.  Ils s'entendent tous bien et am√©liorent le code - il suffit de les appliquer √† l'endroit. </p><br><h2 id="chto-esche-pochitat-po-teme">  Quoi d'autre √† lire sur le sujet </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©finition de la programmation fonctionnelle de Wikipedia</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Livre de d√©marrage Haskell</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Explication des foncteurs, monades et foncteurs applicatifs sur les doigts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Livre Haskell sur les pratiques d'utilisation de Maybe (facultatif)</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Livre sur la nature fonctionnelle de Swift</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©finir des types de donn√©es alg√©briques √† partir d'un wiki</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un article sur les types de donn√©es alg√©briques</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un autre article sur les types de donn√©es alg√©briques</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rapport Yandex sur la programmation fonctionnelle sur Swift</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impl√©mentation de la biblioth√®que standard Prelude (Haskell) sur Swift</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Biblioth√®que avec des outils fonctionnels sur Swift</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une autre biblioth√®que</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Et un de plus</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455359/">https://habr.com/ru/post/fr455359/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455345/index.html">Attention docteur</a></li>
<li><a href="../fr455347/index.html">Interfaces fonctionnelles ... en VBA</a></li>
<li><a href="../fr455351/index.html">VMware EMPOWER 2019 - les principales annonces et conclusions de la conf√©rence</a></li>
<li><a href="../fr455353/index.html">Acc√©l√©ration mat√©rielle des r√©seaux de neurones profonds: GPU, FPGA, ASIC, TPU, VPU, IPU, DPU, NPU, RPU, NNP et autres lettres</a></li>
<li><a href="../fr455355/index.html">R√©seaux de t√©l√©vision par c√¢ble pour les plus petits. Partie 8: r√©seau dorsal optique</a></li>
<li><a href="../fr455361/index.html">Nous faisons une extension de navigateur qui v√©rifie les r√©sultats de l'examen</a></li>
<li><a href="../fr455369/index.html">Certification des administrateurs de bases de donn√©es et bien plus encore lors de l'anniversaire DevConfX (21-22 juin √† Moscou)</a></li>
<li><a href="../fr455371/index.html">Source de courant stable de 5 ŒºA √† 20 mA</a></li>
<li><a href="../fr455373/index.html">Comment ajuster la loi du printemps pour qu'elle devienne porteuse pour les petits prestataires? L'annuler</a></li>
<li><a href="../fr455375/index.html">Ecrire UDR en Pascal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>