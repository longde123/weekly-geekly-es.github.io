<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ’¾ ğŸšµğŸ¿ API Kontrak WG: kebun binatang layanan ğŸ˜ ğŸ•• ğŸ‘¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dengan meningkatnya jumlah komponen dalam sistem perangkat lunak, jumlah orang yang berpartisipasi dalam pengembangannya biasanya juga bertambah. Akib...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>API Kontrak WG: kebun binatang layanan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wargaming/blog/441708/"><img src="https://habrastorage.org/webt/iz/gg/o8/izggo8dsjxgjso5tku-q65ezmwq.jpeg"><br><br>  Dengan meningkatnya jumlah komponen dalam sistem perangkat lunak, jumlah orang yang berpartisipasi dalam pengembangannya biasanya juga bertambah.  Akibatnya, untuk mempertahankan laju pengembangan dan kemudahan pemeliharaan, pendekatan pada organisasi API harus menjadi subjek perhatian khusus. <br><br>  Jika Anda ingin melihat lebih dekat bagaimana tim Platform Wargaming mengatasi kompleksitas sistem lebih dari seratus layanan web yang saling berinteraksi, maka selamat datang di cat. <br><a name="habracut"></a><br>  Halo semuanya!  Nama saya Valentine dan saya seorang insinyur di Platform di Wargaming.  Bagi mereka yang tidak tahu apa platform itu dan apa fungsinya, saya akan meninggalkan di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ke publikasi terbaru dari salah satu kolega saya - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">max_posedon</a> <br><br>  Saat ini, saya telah bekerja di perusahaan selama lebih dari lima tahun dan sebagian menemukan periode pertumbuhan aktif World of Tanks.  Untuk mengungkap masalah yang diangkat dalam artikel ini, saya harus mulai dengan penyimpangan singkat ke dalam sejarah Platform Wargaming. <br><br><h2>  Sedikit sejarah </h2><br>  Semakin populernya "tank" ternyata seperti longsoran salju, dan seperti biasanya dalam kasus seperti itu, infrastruktur di sekitar permainan mulai berkembang pesat.  Akibatnya, permainan dengan cepat bertambah dengan berbagai layanan web, dan pada saat saya bergabung dengan tim, skor mereka sudah mencapai puluhan (sekarang, omong-omong, lebih dari 100 komponen platform bekerja dan menguntungkan perusahaan). <br><br>  Seiring berjalannya waktu, game-game baru muncul, dan memahami seluk-beluk integrasi antara layanan web tidak lagi mudah.  Situasi hanya memburuk ketika tim dari kantor Wargaming lain bergabung dengan pengembangan platform.  Perkembangan telah didistribusikan, dengan semua konsekuensi dalam bentuk jarak, zona waktu dan hambatan bahasa.  Dan ada lebih banyak layanan.  Menemukan seseorang yang mengerti bagaimana platform bekerja secara keseluruhan tidaklah mudah.  Informasi sering kali harus dikumpulkan sebagian dari sumber yang berbeda. <br><br>  Antarmuka berbagai layanan web dapat sangat berbeda dalam kinerja gaya, yang membuat proses integrasi dengan platform lebih sulit.  Dan dependensi antar-komponen langsung mengurangi fleksibilitas pengembangan dengan menyulitkan dekomposisi fungsi dalam platform.  Yang membuat segalanya menjadi lebih buruk, game - klien platform - mengetahui topologi kami dengan baik, karena mereka harus berintegrasi langsung dengan setiap layanan platform.  Ini memberi mereka kesempatan, menggunakan koneksi horisontal, untuk melobi pelaksanaan perbaikan tertentu secara langsung dalam komponen yang mereka integrasikan.  Hal ini menyebabkan munculnya fungsi duplikat di berbagai komponen platform, serta ketidakmampuan untuk memperluas fungsionalitas yang ada ke game lain.  Menjadi jelas bahwa untuk terus membangun platform di sekitar setiap game tertentu adalah cabang buntu pengembangan.  Kami membutuhkan perubahan teknis dan organisasi, sebagai hasilnya kami dapat mengendalikan kompleksitas yang berkembang dari sistem yang berkembang pesat dan membuat semua fungsionalitas platform sesuai untuk digunakan oleh game mana pun. <br><br>  Dengan ini saya ingin menyelesaikan perjalanan sejarah dan, akhirnya, berbicara tentang salah satu solusi teknis kami, yang membantu untuk tetap mengendalikan kompleksitas yang disebabkan oleh jumlah layanan yang semakin meningkat.  Selain itu, ini mengurangi biaya pengembangan fungsionalitas baru dan sangat menyederhanakan integrasi dengan platform. <br><br><h2>  Memenuhi API Kontrak </h2><br>  Di dalam platform, kami menyebutnya API Kontrak.  Pada intinya, ini adalah kerangka kerja integrasi yang diwakili oleh seperangkat dokumentasi dan pustaka klien untuk setiap teknologi dari tumpukan kami (Erlang / Elixir, Java / Scala, Python).  Ini sedang dikembangkan, pertama-tama, untuk menyederhanakan integrasi komponen platform satu sama lain.  Kedua, untuk membantu kami memecahkan sejumlah masalah berikut: <br><br><ul><li>  perbedaan gaya antarmuka program </li><li>  adanya ketergantungan antar-komponen langsung </li><li>  menjaga dokumentasi tetap terbaru </li><li>  introspeksi dan debugging fungsi ujung ke ujung </li></ul><br>  Jadi, hal pertama yang pertama. <br><br><h2>  Perbedaan gaya dalam antarmuka perangkat lunak </h2><br>  Menurut pendapat saya, masalah ini muncul sebagai akibat dari kombinasi beberapa faktor: <br><br><ul><li>  <b>Kurangnya standar ketat tentang bagaimana seharusnya API.</b>  Serangkaian rekomendasi sering tidak memiliki efek yang diinginkan, API masih berbeda.  Terutama jika pengembangan dilakukan oleh tim dari berbagai kantor perusahaan.  Setiap tim memiliki kebiasaan dan praktiknya sendiri.  Secara kolektif, API semacam itu seringkali tidak terlihat seperti bagian dari keseluruhan. </li><li>  <b>Kurangnya direktori tunggal dengan nama dan format entitas khusus bisnis.</b>  Sebagai aturan, Anda tidak dapat mengambil entitas dari hasil satu API dan meneruskannya ke API layanan lain.  Ini membutuhkan transformasi. </li><li>  <b>Kurangnya sistem peninjauan terpusat wajib untuk API.</b>  Selalu ada tenggat waktu dan tidak ada waktu untuk mengumpulkan pembaruan dan, terlebih lagi, membuat perubahan pada API, yang pada kenyataannya seringkali ternyata sudah setengah diuji. </li></ul><br>  Hal pertama yang kami lakukan ketika mendesain API Kontrak adalah untuk mengatakan bahwa mulai sekarang API milik platform, dan bukan ke satu komponen.  Ini mengarah pada fakta bahwa pengembangan fungsionalitas baru dimulai dengan permintaan tarik ke API penyimpanan terpusat.  Saat ini, kami menggunakan repositori GIT sebagai penyimpanan.  Untuk kenyamanan, kami membagi seluruh API menjadi fungsi bisnis yang terpisah, memformalkan struktur fungsi ini dan menyebutnya Kontrak. <br><br>  Sejak itu, setiap fungsi bisnis baru di API kontrak kami harus diuraikan dalam format khusus dan melalui permintaan tarik dengan peninjauan wajib.  Tidak ada cara lain untuk menerbitkan API baru ke API Kontrak.  Dalam repositori yang sama, kami mendefinisikan direktori entitas khusus bisnis dan menyarankan agar pengembang kontrak menggunakannya kembali alih-alih mendeskripsikan entitas ini sendiri. <br><br>  Jadi kami mendapat platform API terintegrasi secara konseptual yang tampak seperti produk tunggal, meskipun faktanya sebenarnya diimplementasikan pada banyak komponen platform menggunakan berbagai tumpukan teknologi. <br><br><h2>  Adanya dependensi antar-komponen langsung </h2><br>  Masalah kita ini memanifestasikan dirinya dalam kenyataan bahwa setiap komponen platform diperlukan untuk mengetahui siapa yang secara spesifik melayani fungsionalitas yang dibutuhkannya. <br><br>  Dan itu bahkan bukan kesulitan mempertahankan direktori ini mutakhir, tetapi fakta bahwa ketergantungan langsung secara signifikan mempersulit migrasi fungsionalitas bisnis dari satu komponen platform ke yang lain.  Masalahnya sangat akut ketika kami memulai dekomposisi monolit kami menjadi komponen yang lebih kecil.  Ternyata meyakinkan klien untuk mengganti integrasi kerja dengan fungsionalitas apa pun dengan yang sama dari sudut pandang bisnis, tetapi yang lain dari sudut pandang teknis, bukanlah tugas manajemen yang sepele.  Klien sama sekali tidak mengerti maksudnya, karena semuanya berjalan baik baginya.  Akibatnya, lapisan backward berbau busuk ditulis yang hanya mempersulit dukungan platform dan berdampak buruk pada kualitas layanan.  Dan karena kami sudah membuat standardisasi platform API, maka perlu untuk secara bersamaan menyelesaikan masalah ini. <br><br>  Kami menghadapi beberapa pilihan.  Dari jumlah tersebut, kami secara khusus mempertimbangkan: <br><br><ul><li>  Implementasi protokol <i>penemuan layanan</i> pada masing-masing komponen. </li><li>  Menggunakan mediator untuk mengarahkan permintaan klien ke komponen platform yang benar. </li><li>  Menggunakan <i>broker pesan</i> sebagai bus perpesanan. </li></ul><br>  Sebagai hasil dari beberapa pemikiran dan percobaan, pilihan jatuh pada broker pesan, terlepas dari kenyataan bahwa ia melihat kami sebagai satu-satunya titik kegagalan dan meningkatkan overhead pengoperasian platform.  Peran penting dalam pemilihan dimainkan oleh fakta bahwa platform pada waktu itu sudah memiliki keahlian dalam bekerja dengan RabbitMQ.  Dan broker itu sendiri berskala baik dan memiliki mekanisme bawaan untuk memastikan toleransi kesalahan.  Sebagai bonus, kami mendapat kesempatan untuk mengimplementasikan <i>arsitektur berbasis-event</i> ( <i>event-driven architecture</i> atau <i>EDA</i> ) "di bawah tenda".  Yang kemudian terbuka di hadapan kita kemungkinan yang lebih luas dari interaksi antar layanan, dibandingkan dengan interaksi point-to-point. <br><br>  Jadi, secara topologi, platform mulai berubah dari grafik dengan konektivitas acak menjadi bintang.  Dan komponen platform membalikkan dependensi mereka dan mendapat kesempatan untuk berinteraksi satu sama lain secara eksklusif melalui kontrak yang terdaftar di repositori terpusat, tanpa perlu tahu siapa yang secara spesifik mengimplementasikan kontrak tertentu.  Dengan kata lain, semua komponen dalam platform dapat berinteraksi satu sama lain menggunakan titik integrasi tunggal, yang sangat menyederhanakan kehidupan pengembang. <br><br><h2>  Menjaga dokumentasi tetap mutakhir </h2><br>  Masalah yang terkait dengan kurangnya dokumentasi atau hilangnya relevansinya hampir selalu ditemui.  Dan semakin tinggi laju perkembangan, semakin sering ia memanifestasikan dirinya.  Dan setelah itu, mengumpulkan semua spesifikasi API di satu tempat dan format untuk lebih dari seratus layanan dalam tim yang terdistribusi dan multinasional adalah tugas yang sulit. <br><br>  Saat mengembangkan API Kontrak, kami juga menetapkan tujuan untuk menyelesaikan masalah ini.  Dan kami berhasil.  Format yang ditentukan secara ketat untuk deskripsi kontrak memungkinkan kami untuk membangun proses yang sesuai dengan itu, segera setelah munculnya kontrak baru, perakitan dokumentasi otomatis dimulai.  Ini memberi kami keyakinan bahwa dokumentasi API kami selalu terbarui.  Proses ini sepenuhnya otomatis dan tidak memerlukan upaya pengembangan atau pengelolaan. <br><br><h2>  Introspeksi dan debugging fungsi ujung ke ujung </h2><br>  Ketika kami membagi monolit kami menjadi komponen yang lebih kecil, secara alami, kesulitan mulai timbul dalam debugging fungsi ujung ke ujung.  Jika layanan fungsi bisnis didistribusikan di beberapa komponen platform, maka seringkali untuk melokalisasi dan men-debug masalah, orang harus mencari perwakilan dari masing-masing komponen.  Yang kadang-kadang dapat dicapai dengan kesulitan, mengingat perbedaan waktu 11 jam dengan beberapa rekan kami. <br><br>  Dengan munculnya API Kontrak, dan khususnya terima kasih kepada pialang pesan yang mendasarinya, kami dapat menerima salinan pesan yang terlibat dalam pelaksanaan fungsi bisnis, tanpa efek samping pada peserta interaksi.  Untuk melakukan ini, bahkan tidak perlu mengetahui komponen dari platform mana yang bertanggung jawab untuk memproses kontrak tertentu.  Dan setelah lokalisasi masalah, kita bisa mendapatkan pengenal komponen yang rusak dari metadata dari pesan masalah. <br><br><h2>  Apa lagi yang kami kembangkan di atas API Kontrak </h2><br>  Selain tujuan utamanya dan menyelesaikan masalah di atas, API Kontrak memungkinkan kami untuk mengimplementasikan sejumlah layanan yang bermanfaat. <br><br><h3>  Gerbang untuk mengakses fungsionalitas platform </h3><br>  Standarisasi API dalam bentuk kontrak memungkinkan kami untuk mengembangkan satu titik akses ke fungsionalitas platform melalui HTTP.  Selain itu, dengan munculnya fungsionalitas baru (kontrak), kita tidak perlu mengubah jalur akses ini dengan cara apa pun.  Ini maju kompatibel dengan semua kontrak masa depan.  Ini memungkinkan Anda untuk bekerja dengan platform sebagai produk tunggal menggunakan antarmuka HTTP biasa. <br><br><h3>  Layanan Operasi Massal </h3><br>  Setiap kontrak dapat diluncurkan sebagai bagian dari operasi massal, dengan kemampuan untuk melacak statusnya dan kemudian menerima laporan tentang hasil operasi ini.  Layanan ini, seperti yang sebelumnya, kompatibel dengan semua kontrak di masa depan. <br><br><h3>  Penanganan kesalahan platform terpadu </h3><br>  Protokol Kontrak API juga membakukan kesalahan.  Ini memungkinkan kami untuk mengimplementasikan pencegat kesalahan, yang menganalisis tingkat keparahannya dan memberi tahu sistem pemantauan tentang potensi masalah pada komponen platform.  Dan di masa depan, ia akan dapat secara mandiri memutuskan penemuan bug pada komponen platform.  Pencegat kesalahan menangkap mereka langsung dari pialang pesan dan tidak tahu apa-apa tentang tujuan kontrak atau kesalahan, hanya bertindak berdasarkan meta-informasi.  Ini memungkinkannya, serta semua layanan yang dijelaskan dalam bagian ini, untuk maju kompatibel dengan semua kontrak masa depan. <br><br><h3>  Auto Hasilkan Antarmuka Pengguna </h3><br>  Kontrak yang diformalkan dengan ketat memungkinkan Anda membangun komponen antarmuka pengguna secara otomatis.  Kami telah mengembangkan layanan yang memungkinkan Anda untuk menghasilkan antarmuka administratif berdasarkan kumpulan kontrak, dan kemudian menyematkan antarmuka ini di salah satu alat platform kami.  Dengan demikian, admin yang sebelumnya kami tulis dengan tangan kami sekarang dapat dihasilkan (walaupun hanya sebagian sejauh ini) dalam mode otomatis. <br><br><h3>  Pencatatan Platform </h3><br>  Komponen ini belum diimplementasikan dan sedang dikembangkan.  Tetapi di masa depan, itu akan memungkinkan "on the fly" untuk menghidupkan dan mematikan pencatatan fungsi bisnis apa pun di platform, mengekstraksi informasi ini langsung dari broker pesan, tanpa efek samping apa pun yang berdampak buruk terhadap komponen yang berinteraksi. <br><br><h2>  Tujuan utama API Kontrak </h2><br>  Tapi tetap saja, tujuan utama API Kontrak adalah untuk mengurangi biaya mengintegrasikan komponen platform. <br><br>  Pengembang disarikan dari tingkat transportasi oleh perpustakaan yang kami kembangkan untuk setiap tumpukan teknologi kami.  Ini memberi kita ruang untuk bermanuver jika kita harus mengubah broker pesan atau bahkan beralih ke interaksi point-to-point.  Antarmuka eksternal perpustakaan akan tetap tidak berubah. <br><br>  Perpustakaan di bawah tenda menghasilkan pesan sesuai dengan aturan tertentu dan mengirimkannya ke broker, setelah itu, setelah menunggu pesan tanggapan, ia mengembalikan hasilnya kepada pengembang.  Di luar, sepertinya permintaan sinkron (atau asinkron, tergantung pada implementasi) biasa.  Sebagai demonstrasi, saya akan memberikan beberapa contoh. <br><br>  Contoh panggilan kontrak python <br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> platform_client <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Client client = Client(contracts_path=CONTRACTS_PATH, url=AMQP_URL, app_id=<span class="hljs-string"><span class="hljs-string">'client'</span></span>) client.call(<span class="hljs-string"><span class="hljs-string">"ban-management.create-ban.v1"</span></span>, { <span class="hljs-string"><span class="hljs-string">"wgid"</span></span>: <span class="hljs-number"><span class="hljs-number">1234567890</span></span>, <span class="hljs-string"><span class="hljs-string">"reason"</span></span>: <span class="hljs-string"><span class="hljs-string">"Fraudulent activity"</span></span>, <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru.wot"</span></span>, <span class="hljs-string"><span class="hljs-string">"component"</span></span>: <span class="hljs-string"><span class="hljs-string">"game"</span></span>, <span class="hljs-string"><span class="hljs-string">"bantype"</span></span>: <span class="hljs-string"><span class="hljs-string">"access_denied"</span></span>, <span class="hljs-string"><span class="hljs-string">"author_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"v_nikonovich"</span></span>, <span class="hljs-string"><span class="hljs-string">"expires_at"</span></span>: <span class="hljs-string"><span class="hljs-string">"2038-01-19 03:14:07Z"</span></span> }) { <span class="hljs-string"><span class="hljs-string">u'ban_id'</span></span>: <span class="hljs-number"><span class="hljs-number">31415926</span></span>, <span class="hljs-string"><span class="hljs-string">u'wgid'</span></span>: <span class="hljs-number"><span class="hljs-number">1234567890</span></span>, <span class="hljs-string"><span class="hljs-string">u'title'</span></span>: <span class="hljs-string"><span class="hljs-string">u'ru.wot'</span></span>, <span class="hljs-string"><span class="hljs-string">u'component'</span></span>: <span class="hljs-string"><span class="hljs-string">u'game'</span></span>, <span class="hljs-string"><span class="hljs-string">u'reason'</span></span>: <span class="hljs-string"><span class="hljs-string">u'Fraudulent activity'</span></span>, <span class="hljs-string"><span class="hljs-string">u'bantype'</span></span>: <span class="hljs-string"><span class="hljs-string">u'access_denied'</span></span>, <span class="hljs-string"><span class="hljs-string">u'status'</span></span>: <span class="hljs-string"><span class="hljs-string">u"active"</span></span>, <span class="hljs-string"><span class="hljs-string">u'started_at'</span></span>: <span class="hljs-string"><span class="hljs-string">u"2019-02-15T15:15:15Z"</span></span>, <span class="hljs-string"><span class="hljs-string">u'expires_at'</span></span>: <span class="hljs-string"><span class="hljs-string">u"2038-01-19 03:14:07Z"</span></span> }</code> </pre> <br>  Panggilan kontrak yang sama, tetapi menggunakan Elixir <br><pre> <code class="plaintext hljs">:platform_client.call("ban-management.create-ban.v1", %{ "wgid" =&gt; 1234567890, "reason" =&gt; "Fraudulent activity", "title" =&gt; "ru.wot", "component" =&gt; "game", "bantype" =&gt; "access_denied", "author_id" =&gt; "v_nikonovich", "expires_at" =&gt; "2038-01-19 03:14:07Z" }) {:ok, %{ "ban_id" =&gt; 31415926, "wgid" =&gt; 1234567890, "title" =&gt; "ru.wot", "conponent" =&gt; "game", "reason" =&gt; "Fraudulent activity", "bantype" =&gt; "access_denied", "status" =&gt; "active", "started_at" =&gt; "2019-02-15T15:15:15Z", "expires_at" =&gt; "2038-01-19 03:14:07Z" }}</code> </pre><br>  Di tempat kontrak "ban-management.create-ban.v1" dapat ada fungsionalitas platform lainnya, misalnya: "akun-management.rename-account.v1" atau "notification-center.create-sms-notification.v1".  Dan semuanya akan tersedia melalui titik integrasi dengan platform ini. <br><br>  Tinjauan umum tidak akan lengkap jika Anda tidak menunjukkan API Kontrak dari sudut pandang pengembang server.  Pertimbangkan situasi di mana pengembang perlu menerapkan penangan untuk kontrak ban-management.create-ban.v1 yang sama. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> platform_server <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BlockingServer, handler <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomServer</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BlockingServer)</span></span></span><span class="hljs-class">:</span></span> @handler(<span class="hljs-string"><span class="hljs-string">'ban-management.create-ban.v1'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_create_ban</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, params, context)</span></span></span><span class="hljs-function">:</span></span> response = do_some_usefull_job(params) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response d = CustomServer(app_id=<span class="hljs-string"><span class="hljs-string">"server"</span></span>, amqp_url=AMQP_URL, contracts_path=CONTRACTS_PATH) d.serve()</code> </pre><br>  Kode ini akan cukup untuk mulai melayani kontrak yang diberikan.  Pustaka server akan membongkar dan memeriksa parameter permintaan untuk kebenaran, dan kemudian memanggil penangan kontrak dengan parameter permintaan siap untuk diproses.  Dengan demikian, pengembang server dilindungi oleh perpustakaan, yang, dalam hal menerima parameter permintaan yang salah, itu sendiri akan mengirim kesalahan validasi kepada klien dan mendaftarkan fakta masalah. <br><br>  Karena kenyataan bahwa di bawah tenda API Kontrak diimplementasikan berdasarkan peristiwa, kami mendapatkan kesempatan untuk melampaui ruang lingkup skrip Permintaan / Respons dan menerapkan serangkaian interaksi antar-layanan yang lebih luas. <br><br>  Sebagai contoh: <br><br><ul><li>  membuat permintaan dan melupakan (tanpa menunggu jawaban) </li><li>  membuat permintaan ke beberapa kontrak secara bersamaan (bahkan tanpa menggunakan loop acara) </li><li>  membuat permintaan dan menerima jawaban dari beberapa penangan sekaligus (jika disediakan oleh skrip integrasi) </li><li>  mendaftarkan penangan respons (dipicu jika penangan kontrak melaporkan penyelesaian, menerima hasil pekerjaan penangan kontrak, yaitu tanggapannya) </li></ul><br>  Dan ini bukan daftar skenario lengkap yang dapat diekspresikan melalui model peristiwa interaksi.  Ini adalah daftar yang sedang kami gunakan. <br><br><h2>  Alih-alih sebuah kesimpulan </h2><br>  Kami telah menggunakan API Kontrak selama beberapa tahun.  Oleh karena itu, tidak mungkin untuk berbicara tentang semua skenario penggunaannya dalam kerangka satu artikel ulasan.  Untuk alasan yang sama, saya tidak membebani artikel dengan detail teknis.  Dia sudah menjadi sangat produktif.  Ajukan pertanyaan, dan saya akan mencoba menjawabnya langsung di komentar.  Jika suatu topik sangat menarik, akan mungkin untuk mengungkapkannya secara lebih rinci dalam artikel terpisah. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441708/">https://habr.com/ru/post/id441708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441698/index.html">Disconnection: apa yang terjadi ketika Facebook ditinggalkan?</a></li>
<li><a href="../id441700/index.html">Bagaimana teka-teki anak-anak membantu mengungkap rahasia magnetisme</a></li>
<li><a href="../id441702/index.html">Pada penyimpanan data pribadi, Roskomnadzor dan situs kencan</a></li>
<li><a href="../id441704/index.html">Mengapa Anda tidak harus menunggu manifestasi moral dari robomobiles</a></li>
<li><a href="../id441706/index.html">Selusin perusahaan terkemuka sedang mencoba untuk membuat Lidar yang kuat dan murah</a></li>
<li><a href="../id441710/index.html">Game seluler browser menantang Anda</a></li>
<li><a href="../id441712/index.html">Solusi matematika untuk masalah relativitas</a></li>
<li><a href="../id441714/index.html">Bagaimana lokomotif uap diatur?</a></li>
<li><a href="../id441716/index.html">Pemrograman untuk yang bukan pemrogram. Biografi Juni</a></li>
<li><a href="../id441718/index.html">Minggu Keamanan 09: kerentanan 19-tahun di WinRAR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>