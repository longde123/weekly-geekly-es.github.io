<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛳️ ⛏️ 👇🏻 C＃是低级语言吗？ 🥞 📀 ⌚️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我是Fabien Sanglard所做的一切的忠实拥护者 ，我喜欢他的博客，并且阅读了他的两本书封面（在最近的Hansleminutes播客中对此进行了介绍）。 

 Fabien最近写了一篇很棒的文章，他解密了一个微型射线追踪器，对代码进行了模糊处理，并以奇妙的方式很好地解释了数学。 我真的建议您...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C＃是低级语言吗？</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443804/">我是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Fabien Sanglard</a>所做的一切的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">忠实拥护者</a> ，我喜欢他的博客，并且阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了</a>他的两<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本书</a>封面（在最近的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hansleminutes播客中对此</a>进行了介绍）。 <br><br>  Fabien最近写了一篇很棒的文章，他<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">解密了一个微型</a>射线追踪器，对代码进行了模糊处理，并以奇妙的方式很好地解释了数学。 我真的建议您花时间阅读本文！ <br><br> 但这使我怀疑<i><b>是否可以将C ++代码移植到C＃</b></i> ？ 由于最近我在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">主要工作中</a>写了很多C ++，所以我认为我可以尝试。 <br><br> 但更重要的是，我想更好地了解<b>C＃是否为低级语言</b> ？ <br><a name="habracut"></a><br> 一个稍有不同但相关的问题：C＃适合“系统编程”多少？ 关于这个主题，我真的推荐<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Joe Duffy从2013年开始的出色文章</a> 。 <br><br><h1> 线路端口 </h1><br> 我首先简单地将经过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">混淆的C ++代码</a>逐行移植到C＃。 这非常简单：似乎仍然在说C＃是C ++++！ <br><br> 该示例显示了主要数据结构-'vector'，这是一个比较，左侧为C ++，右侧为C＃： <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f14/ecc/cbd/f14ecccbd0091486caf57fc43fb2ac7f.png"></a> <br><br> 因此，在语法上有一些区别，但是由于.NET允许您定义<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自己的值类型</a> ，因此我能够获得相同的功能。 这很重要，因为将“向量”视为一种结构意味着我们可以获得更好的“数据局部性”，并且我们不需要涉及.NET垃圾收集器，因为数据将被压入堆栈（是的，我知道这是一个实现细节）。 <br><br> 有关.NET中的<code>structs</code>或“值类型”的更多信息，请参见此处： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">堆与堆栈，值类型与引用类型</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">值类型与引用类型</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">.NET中的内存：在哪里</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于价值类型的真相</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">堆栈是实现细节，第一部分</a> </li></ul><br> 特别是，在埃里克·利珀特（Eric Lippert）的上一篇文章中，我们找到了这样一个有用的报价，它使“值类型”的真正含义清楚： <br><br><blockquote> 当然，关于值的类型的最重要的事实<b>不是实现细节， <i>如何分配它们</i></b> ，而是“值的类型”的<i>原始语义</i> ， <b>即，它<i>总是“按值”复制</i></b> 。 如果分配信息很重要，我们将其称为“堆类型”和“堆栈类型”。 但在大多数情况下，这并不重要。 大多数时候，复制和标识的语义是相关的。 </blockquote><br> 现在，让我们看一下比较中的其他一些方法（再次是C ++，左边是C＃），首先是<code>RayTracing(..)</code> ： <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4d0/3c5/277/4d03c5277ffa4f1e73462dab4edc7dd0.png"></a> <br><br> 然后<code>QueryDatabase (..)</code> ： <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/2fc/c17/839/2fcc17839a00bfc619e14c7323e28f52.png"></a> <br><br>  （有关这两个功能的解释，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Fabian的帖子</a> ） <br><br> 但是，事实再次是，C＃使编写C ++代码变得非常容易！ 在这种情况下， <code>ref</code>关键字对我们的帮助最大，这使我们可以通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">reference</a>传递<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">值</a> 。 我们已经在方法调用中使用<code>ref</code>了很长一段时间，但是最近，我们努力在其他地方解析<code>ref</code> ： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参考返回和参考本地</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C＃7系列，第9部分：引用结构</a> </li></ul><br> 现在<i>有时</i>使用<code>ref</code>可以提高性能，因为不需要复制该结构，有关更多信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Adam Stinix</a>在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">帖子中</a>的基准测试和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Performance traps ref locals and ref</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">return</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">in C＃”</a> 。 <br><br> 但是最重​​要的是，这样的脚本为我们的C＃端口提供了与C ++源代码相同的行为。 尽管我想指出的是，所谓的“托管链接”与“指针”并不完全相同，特别是，您无法对其进行算术运算，请参见此处： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ref return不是指针</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">托管指针</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接不是地址</a> </li></ul><br><h2> 性能表现 </h2><br> 因此，代码移植得很好，但是性能也很重要。 特别是在光线跟踪器中，它可以计算几分钟的帧。  C ++代码包含变量<code>sampleCount</code> ，它控制最终的图像质量，其中<code>sampleCount = 2</code>如下： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10a/17e/e2d/10a17ee2df5205f5fa8bd138693bc4a6.png"><br><br> 显然不是很现实！ <br><br> 但是，当您达到<code>sampleCount = 2048</code> ，一切看起来<i>会</i>好得多： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/304/4b2/14d/3044b214da9027dd34dcbc19fdc75d2f.png"><br><br> 但是从<code>sampleCount = 2048</code>开始<b>非常</b>耗时，因此所有其他运行都以<code>2</code>值执行，至少需要一分钟。 更改<code>sampleCount</code>仅影响最外层代码循环的迭代次数，有关说明，请参见此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">要点</a> 。 <br><br><h3>  “天真”线路端口后的结果 </h3><br> 为了实质性地比较C ++和C＃，我使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">time-windows</a>工具，这是<code>time</code> unix命令的端口。 初始结果如下所示： <br><br><table><thead><tr><th></th><th>  C ++（VS 2017） </th><th>  .NET Framework（4.7.2） </th><th>  .NET Core（2.2） </th></tr></thead><tbody><tr><td> 时间（秒） </td><td>  47.40 </td><td>  80.14 </td><td>  78.02 </td></tr><tr><td> 核心（秒） </td><td>  0.14（0.3％） </td><td>  0.72（0.9％） </td><td>  0.63（0.8％） </td></tr><tr><td> 在用户空间（秒） </td><td>  43.86（92.5％） </td><td>  73.06（91.2％） </td><td>  70.66（90.6％） </td></tr><tr><td> 页面错误错误数 </td><td>  1143 </td><td>  4818 </td><td>  5945 </td></tr><tr><td> 工作集（KB） </td><td>  4232 </td><td>  13624 </td><td>  17052 </td></tr><tr><td> 扩展内存（KB） </td><td>  95 </td><td>  172 </td><td>  154 </td></tr><tr><td> 非抢先内存 </td><td>  7 </td><td>  14 </td><td>  16 </td></tr><tr><td> 交换文件（KB） </td><td>  1460 </td><td>  10936 </td><td>  11024 </td></tr></tbody></table><br> 最初，我们看到C＃代码比C ++版本稍慢一些，但是越来越好（见下文）。 <br><br> 但是，让我们首先看看.NET JIT甚至通过这个“天真”的逐行端口对我们的作用。 首先，它很好地嵌入了较小的辅助方法。 这可以在出色的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Inlining分析器</a>工具的输出中看到（绿色=内置）： <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cc/484/0a5/4cc4840a53f18362d3b4f3a4249fb2d5.png"></a> <br><br> 但是，它不会嵌入所有方法，例如，由于复杂性， <code>QueryDatabase(..)</code>跳过<code>QueryDatabase(..)</code> ： <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9e2/648/da2/9e2648da2a8ae7df5f94ceb77771c0ab.png"></a> <br><br>  .NET即时（JIT）编译器的另一个功能是将特定的方法调用转换为相应的CPU指令。 我们可以在<code>sqrt</code> shell函数中看到这一点，这里是C＃源代码（请注意对<code>Math.Sqrt</code>的调用）： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); }</span></span></code> </pre> <br> 这是.NET JIT生成的汇编代码：没有对<code>Math.Sqrt</code>调用，而使用了处理器指令<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">vsqrtsd</a> ： <br><br><pre> <code class="plaintext hljs">; Assembly listing for method Program:sqrtf(float):float ; Emitting BLENDED_CODE for X64 CPU with AVX - Windows ; Tier-1 compilation ; optimized code ; rsp based frame ; partially interruptible ; Final local variable assignments ; ; V00 arg0 [V00,T00] ( 3, 3 ) float -&gt; mm0 ;# V01 OutArgs [V01 ] ( 1, 1 ) lclBlk ( 0) [rsp+0x00] "OutgoingArgSpace" ; ; Lcl frame size = 0 G_M8216_IG01: vzeroupper G_M8216_IG02: vcvtss2sd xmm0, xmm0 vsqrtsd xmm0, xmm0 vcvtsd2ss xmm0, xmm0 G_M8216_IG03: ret ; Total bytes of code 16, prolog size 3 for method Program:sqrtf(float):float ; ============================================================</code> </pre> <br>  （要获取此问题，请遵循<a href="">以下说明</a> ，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Disasmo” VS2019附加组件</a>或查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SharpLab.io</a> ） <br><br> 这些替换也称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内在函数</a> ，在下面的代码中，我们可以看到JIT如何生成它们。 该代码段仅显示了<code>AMD64</code>的映射，但是JIT还针对<code>X86</code> ， <code>ARM</code>和<code>ARM64</code> （ <a href="">此处</a>的完整方法）。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Compiler::IsTargetIntrinsic(CorInfoIntrinsics intrinsicId) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_TARGET_AMD64_) || (defined(_TARGET_X86_) &amp;&amp; !defined(LEGACY_BACKEND)) switch (intrinsicId) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// AMD64/x86 has SSE2 instructions to directly compute sqrt/abs and SSE4.1 // instructions to directly compute round/ceiling/floor. // // </span></span><span class="hljs-doctag"><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span></span><span class="hljs-meta"><span class="hljs-comment"> Because the x86 backend only targets SSE for floating-point code, // it does not treat Sine, Cosine, or Round as intrinsics (JIT32 // implemented those intrinsics as x87 instructions). If this poses // a CQ problem, it may be necessary to change the implementation of // the helper calls to decrease call overhead or switch back to the // x87 instructions. This is tracked by #7097. case CORINFO_INTRINSIC_Sqrt: case CORINFO_INTRINSIC_Abs: return true; case CORINFO_INTRINSIC_Round: case CORINFO_INTRINSIC_Ceiling: case CORINFO_INTRINSIC_Floor: return compSupports(InstructionSet_SSE41); default: return false; } ... }</span></span></span></span></code> </pre> <br> 如您所见，实现了一些方法，例如<code>Sqrt</code>和<code>Abs</code> ，而其他方法则使用C ++运行时函数，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">powf</a> 。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“如何在.NET Framework中实现Math.Pow（）？”一</a>文中对整个过程进行了很好的解释。  ，也可以在CoreCLR源代码中看到： <br><br><ul><li>  <code><a href="">COMSingle::Pow</a></code>实现，即从C＃代码调用<code>MathF.Pow(..)</code>执行的方法 <br></li><li> 在<a href="">C运行时方法</a>的<a href="">实现中进行</a>映射 <br></li><li>  <a href="">powf实现的</a>跨平台版本<a href="">，</a>在整个OS上提供相同的行为 </li></ul><br><h3> 简单的性能改进后的结果 </h3><br> 我想知道您是否可以立即改进朴素的逐端口端口。 经过一些分析后，我进行了两项重大更改： <br><br><ul><li> 删除内联数组初始化 </li><li> 用<code>Math.XXX(..)</code>的类似物代替<code>Math.XXX(..)</code>的功能 </li></ul><br> 这些更改将在下面更详细地说明。 <br><br><h4> 删除内联数组初始化 </h4><br> 有关为什么需<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">要这样做的</a>更多信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Andrei Akinshin提供的</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">出色的Stack Overflow答案</a>以及基准和汇编代码。 他得出以下结论： <br><br><blockquote>  <b>结论</b> <br><br><ul><li>  <i><b>.NET是否缓存硬编码的本地数组？</b></i> 就像将Roslyn编译器放入元数据的代码一样。 </li><li>  <i><b>在这种情况下，会有开销吗？</b></i> 不幸的是，是的：对于每次调用，JIT都会从元数据中复制数组的内容，与静态数组相比，这会花费额外的时间。 运行时还选择对象并在内存中创建流量。 </li><li>  <i><b>有什么需要担心的吗？</b></i> 可能吧 如果这是一个热门方法，并且您想要实现良好的性能水平，则需要使用静态数组。 如果这是不影响应用程序性能的冷方法，则可能需要编写“良好”源代码并将该数组放置在方法区域中。 </li></ul></blockquote><br> 您可以看到在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此diff中</a>所做的更改。 <br><br><h4> 使用MathF函数代替数学 </h4><br> 其次，也是最重要的是，通过进行以下更改，我显着提高了性能： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> NETSTANDARD2_1 || NETCOREAPP2_0 || NETCOREAPP2_1 || NETCOREAPP2_2 || NETCOREAPP3_0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / MathF.Sqrt(q % q)); } #else public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); } #endif</span></span></span></span></code> </pre> <br> 从.NET Standard 2.1开始，存在<code>float</code>通用数学函数的具体实现。 它们位于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">System.MathF</a>类中。 有关此API及其实现的更多信息，请参见此处： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单精度的新数学API</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单精度添加数学函数</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为新的单精度数学API提供单元测试套件</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">System.Math和System.MathF应该在托管代码中实现，而不是C运行时的FCALL</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">移动Math.Abs​​（double）和Math.Abs​​（float）以在托管代码中实现</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">向.NET添加特定于平台的嵌入式工具的设计和过程</a> </li></ul><br> 经过这些更改后，C＃和C ++代码性能的差异减少到大约10％： <br><br><table><thead><tr><th></th><th>  C ++（VS C ++ 2017） </th><th>  .NET Framework（4.7.2） </th><th>  .NET Core（2.2）TC关闭 </th><th>  .NET Core（2.2）TC开 </th></tr></thead><tbody><tr><td> 时间（秒） </td><td>  41.38 </td><td>  58.89 </td><td>  46.04 </td><td>  44.33 </td></tr><tr><td> 核心（秒） </td><td>  0.05（0.1％） </td><td>  0.06（0.1％） </td><td>  0.14（0.3％） </td><td>  0.13（0.3％） </td></tr><tr><td> 在用户空间（秒） </td><td>  41.19（99.5％） </td><td>  58.34（99.1％） </td><td>  44.72（97.1％） </td><td>  44.03（99.3％） </td></tr><tr><td> 页面错误错误数 </td><td>  1119 </td><td>  4749 </td><td>  5776 </td><td>  5661 </td></tr><tr><td> 工作集（KB） </td><td>  4136 </td><td>  13,440 </td><td>  16,788 </td><td>  16,652 </td></tr><tr><td> 扩展内存（KB） </td><td>  89 </td><td>  172 </td><td>  150 </td><td>  150 </td></tr><tr><td> 非抢先内存 </td><td>  7 </td><td>  13 </td><td>  16 </td><td>  16 </td></tr><tr><td> 交换文件（KB） </td><td>  1428 </td><td>  10 904 </td><td>  10960 </td><td>  11044 </td></tr></tbody></table><br>  TC多级编译， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分层编译</a> （ <i>我想</i>默认它将在.NET Core 3.0中启用） <br><br> 为了完整起见，以下是几次运行的结果： <br><br><table><thead><tr><th> 跑 </th><th>  C ++（VS C ++ 2017） </th><th>  .NET Framework（4.7.2） </th><th>  .NET Core（2.2）TC关闭 </th><th>  .NET Core（2.2）TC开 </th></tr></thead><tbody><tr><td>  TestRun-01 </td><td>  41.38 </td><td>  58.89 </td><td>  46.04 </td><td>  44.33 </td></tr><tr><td>  TestRun-02 </td><td>  41.19 </td><td>  57.65 </td><td>  46.23 </td><td>  45.96 </td></tr><tr><td>  TestRun-03 </td><td>  42.17 </td><td>  62.64 </td><td>  46.22 </td><td>  48.73 </td></tr></tbody></table><br>  <b>注意</b> ：.NET Core和.NET Framework之间的差异是由于.NET Framework 4.7.2中缺少MathF API，有关更多信息，请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">支持票证.Net Framework（4.8？）对于netstandard 2.1</a> 。 <br><br><h1> 进一步提高生产力 </h1><br> 我确信代码仍可以改进！ <br><br> 如果您有兴趣解决性能差异，那么<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里是C＃代码</a> 。 为了进行比较，您可以从出色的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Compiler Explorer</a>服务中观看C ++汇编程序代码。 <br><br> 最后，如果有帮助，这是带有“热路径”显示的Visual Studio探查器输出（在上述性能改进之后）： <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b78/3df/2e6/b783df2e692b62f492b78c8e7affcbf4.png"></a> <br><br><h1>  C＃是低级语言吗？ </h1><br> 或更具体地说： <br><br><blockquote>  <b><b>C＃/ F＃/ VB.NET或BCL /运行时功能的哪些语言功能意味着“低级” *编程？</b></b> </blockquote><br>  *是的，我知道“低级”是一个主观术语。 <br><br>  <b>注意：</b>每个C＃开发人员都有自己的“低级”概念，这些功能将被C ++或Rust程序员视为理所当然。 <br><br> 这是我列出的清单： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ref返回和ref当地人</a> <br><ul><li>  “通过引用返回并避免复制大型结构。 安全的类型和内存甚至比不安全的还<b>快</b> ！” </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">.NET中不安全的代码</a> <br><ul><li>  “在前几章中定义的核心C＃语言与C和C ++有很大不同，因为它缺少指针作为数据类型。 相反，C＃提供了链接，并提供了创建由垃圾收集器控制的对象的功能。 这种设计与其他功能的结合，使C＃语言比C或C ++安全得多。” </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">.NET中的托管指针</a> <br><ul><li>  “ CLR中还有另一种类型的指针-托管指针。 可以将其定义为一种更通用的链接类型，它可以指向其他位置，而不仅仅是指向对象的开头。” </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C＃7系列，第10部分：跨度&lt;T&gt;和通用内存管理</a> <br><ul><li>  “ System.Span &lt;T&gt;只是包装所有内存访问模式的堆栈类型（ <code>ref struct</code> ）；它是用于通用连续内存访问的类型。 我们可以想象一个Span实现，它具有一个虚拟引用，并且其长度可以接受所有三种类型的内存访问。” </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">兼容性（“ C＃编程指南”）</a> <br><ul><li>  “ .NET Framework通过平台调用服务， <code>System.Runtime.InteropServices</code> ，C ++兼容性和COM（COM互操作性）兼容性，提供了与非托管代码的互操作性。” </li></ul></li></ul><br> 我还在Twitter上大喊一声，并获得了更多加入列表的选项： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ben Adams</a> ：“用于平台的内置工具（CPU指令）” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">马克·格雷韦尔</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mark Gravell）</a> ：“通过Vector进行SIMD（与Span配合得很好）*很低*；  .NET Core应该（很快吗？）提供直接的CPU嵌入式工具，以便更明确地使用特定的CPU指令” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mark Gravell</a> ：“强大的JIT：诸如数组/间隔上的范围省略之类的东西，以及使用按结构T的规则删除JIT知道的大段代码，以确保它们不适用于该T或您的特定对象CPU（BitConverter.IsLittleEndian，Vector.IsHardwareAccelerated等）“ <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">凯文·琼斯</a> ：“我特别要提到<code>MemoryMarshal</code>和<code>Unsafe</code>类，以及<code>System.Runtime.CompilerServices</code>中的其他一些东西，” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Theodoros Chatsigiannakis</a> ：“您还可以包括<code>__makeref</code>和其余的内容” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Damageboy</a> ：“能够动态生成与预期输入完全匹配的代码的功能，假设后者只能在运行时知道并且可能会定期更改？” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">罗伯特·哈肯（Robert Hacken）</a> ：“ IL的动态排放” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Victor Baybekov</a> ：“未提及Stackalloc。 也可以编写纯IL（不是动态的，因此将其保存在函数调用中），例如，使用缓存的<code>ldftn</code>并通过<code>calli</code>对其进行调用。  VS2017中有一个proj模板，可通过重写方法extern + MethodImplOptions.ForwardRef + ilasm.ex来简化此工作» <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Victor Baybekov</a> ：“ MethodImplOptions.AggressiveInlining也“激活了低级编程”，因为它允许您使用许多小的方法编写高级代码，并且仍然控制JIT的行为以获得最佳结果。 否则，将复制粘贴数百种LOC方法...” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ben Adams</a> ：“使用与基本平台相同的调用约定（ABI），并且p /调用进行交互吗？” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Victor Baibekov</a> ：“此外，由于您提到了#fsharp-它具有一个<code>inline</code> ，该<code>inline</code>在IL级别直到JIT都有效，因此在语言级别上被认为很重要。  C＃到目前为止，对于lambda来说，这还远远不够，因为lambda始终是虚拟调用，解决方法通常很奇怪（有限的泛型）” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Alexandre Mutel</a> ：“新的嵌入式SIMD，对Unsafe Utility类/ IL（例如，自定义，Fody等）进行后处理。 对于C＃8.0，即将发布的函数指针... <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Alexandre Mutel</a> ：“例如，关于IL，F＃直接支持某种语言的IL” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OmariO</a> ：“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BinaryPrimitives</a> 。 级别低，但很安全” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">松井晃司</a> ：“您自己的内置汇编程序怎么样？ 这对工具包和运行时都非常困难，但是它可以替代当前的p / invoke解决方案并实现嵌入式代码（如果有的话） <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">弗兰克·A·克鲁格（Frank A. Kruger）</a> ：“ Ldobj，stobj，initobj，initblk，cpyblk” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">康拉德·椰子（Conrad Coconut）</a> ：“也许可以流式传输本地存储？ 固定大小的缓冲区？ 您可能应该提到非托管约束和可绑定类型：)” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sebastiano Mandala</a> ：“只说了几句话：简单的事情（例如安排结构）以及填充和对齐内存以及字段顺序如何影响缓存性能？ 这是我自己必须探索的东西。” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nino Floris</a> ：“通过readspanspan，stackalloc，finalizers，WeakReference，开放委托，MethodImplOptions，MemoryBarriers，TypedReference，varargs，SIMD，Unsafe.AsRef嵌入的常量可以完全根据布局（用于TaskAwaiter及其版本）设置结构的类型” </li></ul><br>  <b>因此，最后，我要说的是，C＃当然允许您编写类似于C ++的代码，并且结合运行时库和基类库提供了许多底层函数。</b> <br><br><h1> 进一步阅读 </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">高性能C＃的模板。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">费德里科·安德烈斯·路易斯</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">性能测验＃6-汉英词典</a> （自2005年以来，两名Microsoft博主一直在与C＃的性能对抗C＃进行斗争） <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">性能测验＃6-结论，太空探索</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++比C＃快多少？</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">优化托管C＃和本机C ++代码</a> （2005） </li></ul><br>  Unity Burst编译器： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Unity如何使C＃（一个子集）与C ++一样快</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Unity Burst编译器：轻松优化性能</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">每日Pathtracer，第3部分：C＃和Unity Burst</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++，C＃和Unity</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">深入了解Burst编译器-Unite LA</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN443804/">https://habr.com/ru/post/zh-CN443804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN443788/index.html">Mikrotik RouterOS中静态路由的基础</a></li>
<li><a href="../zh-CN443790/index.html">幸存者的错误</a></li>
<li><a href="../zh-CN443792/index.html">使用PostgreSQL时的典型错误。 第二部分</a></li>
<li><a href="../zh-CN443794/index.html">房地产销售领域中IT初创公司的主要方向</a></li>
<li><a href="../zh-CN443798/index.html">Zotero hacks：无限的同步存储及其与rmarkdown的平滑使用</a></li>
<li><a href="../zh-CN443808/index.html">对社会责任感低的女孩进行分析（由Power BI，Qlik Sense，Tableau收费）</a></li>
<li><a href="../zh-CN443810/index.html">2018年，具有不同资格的开发人员能赚多少钱</a></li>
<li><a href="../zh-CN443812/index.html">如何在JavaScript中实现编程语言。 第2部分：翻译</a></li>
<li><a href="../zh-CN443814/index.html">奉献是我的“老生意”</a></li>
<li><a href="../zh-CN443816/index.html">通信部坚持只有一个5G运营商</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>