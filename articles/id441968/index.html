<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦍 🦈 🦇 Pengembangan cabang produk baru: cara menyingkirkan tidak praktis dan tetap bermanfaat 📣 🐐 ⛪️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Nama saya Dmitry, saya seorang pengembang di ISPsystem. Baru-baru ini, kami merilis pengujian beta versi baru dari panel kontrol mesin vir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan cabang produk baru: cara menyingkirkan tidak praktis dan tetap bermanfaat</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ispsystem/blog/441968/"><img src="https://habrastorage.org/webt/y1/x1/ec/y1x1ece2ww4irdsajxg6qeme6bw.jpeg"><br><br>  Halo, Habr!  Nama saya Dmitry, saya seorang pengembang di ISPsystem.  Baru-baru ini, kami merilis pengujian beta versi baru dari panel kontrol mesin virtual.  Hari ini saya akan memberi tahu Anda bagaimana kami memutuskan apa yang akan diambil dari produk lama, dan apa yang lebih baik untuk ditolak.  Saya akan membahas masalah yang paling penting bagi kami: perpustakaan untuk bekerja dengan libvirt, dukungan untuk berbagai sistem operasi selama instalasi produk, transisi dari monolit ke layanan mikro, dan penyebaran mesin virtual. <br><br>  Artikel ini tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VMmanager</a> .  Ini adalah sistem untuk mengelola, menyebarkan dan memonitor mesin virtual berdasarkan virtualisasi KVM dan OVZ.  Generasi kelima keluar pada 2012.  Sejak itu, antarmuka sangat ketinggalan jaman, dan arsitektur terpusat telah mencegah pengembangan produk.  Saatnya membuat versi baru. <br><a name="habracut"></a><br><h2>  Kisah pertama.  Kami menggunakan pekerjaan peri rumah <br></h2><h5>  <font color="#787979">Bekerja dengan libvirt: pertimbangkan opsi, pilih perpustakaan</font> </h5><br>  Sebagai alat untuk mengelola virtualisasi KVM, produk kami menggunakan libvirt.  Pada 2012, perpustakaan yang ditulis dalam C dipilih untuk bekerja dengannya, jadi lebih nyaman bagi tim pengembangan itu.  Akibatnya - sejumlah besar kode ditulis dalam C ++, memanggil C-library, yang mengimplementasikan kerja langsung dengan libvirt. <br><br>  Dan sekarang, di ambang proyek baru, kita melihat ke belakang dan memeriksa produk kita, menimbang apakah layak mengambil solusi / teknologi tertentu;  apa yang telah membuktikan dirinya dan apa yang perlu diingat dan tidak pernah diulang. <br><br>  Kami duduk dan melakukan retrospeksi bertahun-tahun bekerja pada versi produk sebelumnya.  Kami bersabar, mengambil stiker dan menulis tiga jenis kertas: <br><ol><li>  Apa yang berhasil dalam produk?  Apa yang dipuji pengguna?  Apa yang belum pernah mendengar keluhan?  Apa yang kamu sukai dari dirimu? </li><li>  Apa yang gagal?  Apa masalahnya secara konstan?  Apa yang menghambat pekerjaan itu, dan mengapa mereka memulai cabang baru? </li><li>  Apa yang bisa diubah?  Apa yang diminta pengguna?  Apa yang ingin diubah oleh anggota tim? </li></ol><br>  Kelompok orang yang dengan bersemangat merusak kertas harus mencakup mereka yang telah melakukan kontak dekat dengan produk selama berabad-abad, dan mereka yang dapat memiliki pandangan baru pada produk tersebut.  Jangan lupa Permintaan Fitur dan manajer produk.  Stiker yang sudah jadi ditempelkan pada papan, mereka pasti akan membantu kita. <br><img src="https://habrastorage.org/webt/u8/wv/dp/u8wvdprmraomcmn1ykdj7fhht7i.png"><br>  Kembali ke cerita.  Kami memeriksa sepotong kode di mana standar C ++ 98 secara damai hidup berdampingan dengan panggilan C-library.  Kita ingat bahwa tahun 2018 adalah tahun dan memutuskan untuk meninggalkannya sendirian.  Tetapi bagaimana cara mengulang fungsi bekerja dengan mesin virtual (VM), membuat kode lebih kompak dan nyaman untuk bekerja? <br><br>  Kami mempelajari masalah ini, memahami bahwa apa pun solusi dan dalam bahasa apa yang kami pilih, itu akan menjadi penutup C-library.  Sebagai opsi yang menarik, perlu diperhatikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan di Go dari DigitalOcean</a> , ia menggunakan protokol RPC untuk berkomunikasi dengan libvirt secara langsung, tetapi ia memiliki kekurangannya.  Kami menetap di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan Python</a> . <br><br>  Hasilnya, kami mendapatkan kecepatan menulis kode, kemudahan penggunaan, dan membaca.  Perlu menjelaskan kata-kata indah ini. <br><ul><li>  <b>Kecepatan</b> .  Sekarang kita dapat dengan cepat membuat prototipe bagian tertentu dari pekerjaan dengan domain langsung dari konsol pada server debug, tanpa membangun kembali aplikasi utama. </li><li>  <b>Kesederhanaan</b> .  Alih-alih memanggil banyak metode C ++ di penangan tertentu, kami memiliki panggilan skrip Python dengan melewati parameter. </li><li>  <b>Debugging</b> juga secepat dan tidak menyakitkan mungkin.  Menurut pendapat saya, dalam jangka panjang ini bisa membawa pengalaman pengguna yang menarik.  Bayangkan, administrator sistem, tidak senang bahwa mesin virtualnya menunggu untuk dimatikan sebelum dihancurkan, pergi dan mendefinisikan ulang skrip untuk metode host_stop.  <s>Bisakah saya juga menulis panel untuk Anda?</s> </li></ul><br>  Sebagai hasilnya, kami mendapat alat sederhana dan nyaman untuk bekerja dengan mesin virtual di tingkat server. <br><br><h2>  Kisah kedua.  Produk yang dikemas dengan baik tidak membutuhkan belaian tambahan <br></h2><h5>  <font color="#787979">Distribusi produk: kami menolak dari banyak paket dan kami beralih ke Docker</font> </h5><br><img src="https://habrastorage.org/webt/dr/ow/wm/drowwmt-ru8iwccg64mlsjmmc8y.png"><br>  VMmanager 5 didistribusikan sebagai satu set paket linux.  CentOS 6/7 dan, sampai saat ini, Debian 7. didukung. Apa artinya ini?  Ini berarti lebih banyak membangun server untuk CI / CD, lebih banyak pengujian, lebih banyak perhatian pada kode.  Kita harus ingat bahwa ketika dalam repositori resmi CentOS 7 qemu versi 1.5.3, dalam CentOS 6 itu adalah 0.12.1.  Pada saat yang sama, pengguna dapat menggunakan repositori di mana versi paket ini jauh lebih tinggi.  Ini berarti bahwa Anda perlu mendukung versi api yang berbeda ketika bekerja dengan VM, khususnya, selama migrasi.  Kita harus ingat perbedaan antara inisialisasi (init, systemd), memperhitungkan perbedaan dalam nama paket dan utilitas.  Utilitas yang bekerja pada CentOS tidak akan berfungsi pada Debian, atau versinya dalam repositori resmi sangat bervariasi.  Untuk setiap dorongan, Anda perlu mengumpulkan paket untuk semua versi, dan disarankan untuk tidak lupa mengujinya juga. <br><br>  Semua ini dalam produk baru tidak cocok untuk kita.  Agar tidak mendukung logika yang berbeda, kami meninggalkan beberapa sistem dan hanya menyisakan CentOS 7. Apakah masalah teratasi?  Tidak juga. <br><br>  Kami juga tidak ingin memeriksa versi sistem operasi sebelum instalasi, apakah utilitas yang diperlukan tersedia, aturan apa yang diinstal di SELinux, dan kami tidak ingin mengkonfigurasi ulang daftar firewall dan repositori.  Saya ingin sekali - dan itu saja, dengan mengklik untuk <s>menghancurkan setiap detik untuk</s> menyebarkan seluruh lingkungan dan produk itu sendiri.  Dikatakan - selesai, proyek ini dibungkus dalam wadah buruh pelabuhan. <br><br>  Sekarang cukup untuk melakukan: <br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker pull vmmanager # docker run -d vmmanager:latest</span></span></code> </pre> <br>  Panel menyala dan berjalan. <br><br>  Tentu saja, saya melebih-lebihkan, pengguna harus menginstal Docker untuk dirinya sendiri, dan kami memiliki lebih dari satu kontainer, dan saat ini VMmanager berjalan dalam mode swarm sebagai layanan SaaS.  Tentang apa yang kami temui ketika memilih Docker, dan bagaimana mengatasinya, Anda dapat menulis artikel terpisah. <br><br>  Faktanya adalah betapa pentingnya untuk menyederhanakan pengembangan, dan yang paling penting, penyebaran produk Anda, instal.sh yang pernah menempati <a href="">2097 baris</a> . <br><br>  Sebagai hasilnya: <br><ol><li>  Lingkungan pemasangan produk yang homogen menyederhanakan kode program dan mengurangi biaya perakitan dan pengujian. </li><li>  Mendistribusikan aplikasi sebagai wadah buruh pelabuhan membuat penyebaran mudah dan dapat diprediksi. </li></ol><br><h2>  Cerita ketiga.  Hubungan pertama dengan layanan mikro <br></h2><h5>  <font color="#787979">Arsitektur: kita meninggalkan monolit demi layanan-layanan microser, atau tidak</font> </h5><br><img src="https://habrastorage.org/webt/h0/x5/hv/h0x5hv2builkoorlw3wxiheknru.png"><br>  Versi kelima dari produk ini adalah sistem monolitik besar dengan standar C ++ yang ketinggalan zaman.  Akibatnya, implementasi teknologi baru yang bermasalah dan sulitnya refactoring kode lama, penskalaan horisontal yang buruk.  Di cabang baru, mereka memutuskan untuk menggunakan pendekatan microservice sebagai salah satu cara untuk menghindari masalah tersebut. <br><br>  Layanan mikro adalah tren modern yang memiliki kelebihan dan kekurangan.  Saya akan mencoba untuk mempresentasikan visi saya tentang kekuatan arsitektur ini dan berbicara tentang menyelesaikan masalah yang ditimbulkannya pada proyek.  Perlu dicatat bahwa ini akan menjadi tampilan pertama pada arsitektur microservice dalam praktiknya dari sisi pengembang biasa.  Aspek-aspek yang mungkin tidak akan saya sebutkan tercakup dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ulasan yang bagus</a> . <br><br><h3>  Sisi positif </h3><br>  <b>Layanan kecil memberi banyak peluang.</b> <br>  Selain kenyamanan penulisan, pengujian dan debugging, layanan microser memperkenalkan bahasa pemrograman baru ke proyek.  Ketika proyek Anda adalah monolit, sulit untuk membayangkan bahwa suatu hari Anda akan mencoba untuk menulis ulang sebagian dari itu dalam bahasa lain yang menarik minat Anda.  Dalam arsitektur microservice - silakan.  Selain bahasa pemrograman, Anda juga dapat mencoba teknologi baru, dengan satu-satunya peringatan bahwa semua ini akan dibenarkan untuk bisnis.  Sebagai contoh, kami menulis beberapa layanan microsoft di Golang, sambil menghemat waktu yang cukup lama. <br><br>  <b>Penskalaan tim</b> <br>  Kita dapat membagi banyak orang yang dulu berkomitmen pada satu repositori dan mencoba menjaga struktur monolith di kepala mereka menjadi beberapa tim.  Setiap tim akan terlibat dalam layanannya.  Selain itu, masuknya orang baru ke dalam pekerjaan jauh lebih sederhana dan lebih cepat, karena konteks yang terbatas di mana ia akan bekerja.  Di sisi lain, ada lebih sedikit orang-pengumpul pengetahuan dunia, yang selalu dapat ditemukan tentang aspek apa pun dari sistem besar.  Mungkin pada saatnya saya akan mempertimbangkan kembali sikap saya sampai titik ini. <br><br>  <b>Degradasi independen</b> <br>  Saya akan mengaitkan degradasi independen ke sisi positif dan negatif dari layanan microser, karena siapa yang membutuhkan aplikasi Anda jika, misalnya, terletak layanan otorisasi?  Namun, ini masih sisi positif.  Sebelumnya, mengumpulkan statistik dari beberapa ratus mesin virtual membuat monolith kami bekerja keras, pada saat beban puncak, menunggu permintaan pengguna meningkat meningkat secara signifikan.  Layanan pengumpulan statistik terpisah dapat mengumpulkannya tanpa memengaruhi layanan lain, sementara itu masih dapat ditingkatkan dengan menambahkan perangkat keras baru atau dengan meningkatkan jumlah kolektor dari statistik yang sama.  Dan kita bahkan dapat memilih server terpisah untuk Graphite, tempat layanan ini mencatat statistik.  Dengan monolit, di mana ada satu basis, ini tidak mungkin. <br><br><h3>  Sisi negatif </h3><br>  <b>Konteks permintaan</b> <br>  Semua debug saya di monolith turun ke dua pertanyaan di konsol: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># tail -n 460 var/vmmgr.log | grep ERR # tail -n 460 var/vmmgr.log | grep thread_id_with_err</span></span></code> </pre> <br>  Selesai!  Saya dapat melacak seluruh permintaan, mulai dari tanda terima hingga sistem hingga terjadi kesalahan. <br><br>  Tapi bagaimana dengan sekarang, ketika permintaan berpindah dari microservice ke microservice, disertai dengan panggilan tambahan ke layanan tetangga dan catatan di berbagai database?  Untuk melakukan ini, kami mengimplementasikan info permintaan, yang berisi pengidentifikasi permintaan dan informasi tentang pengguna atau layanan yang menghasilkannya.  Jadi menjadi lebih mudah untuk melacak seluruh rantai peristiwa, tetapi keinginan datang untuk menulis layanan agregasi log, karena kita, setelah semua, memiliki arsitektur layanan mikro.  Anda juga dapat melihat ke Elasticsearch, masalah ini terbuka dan akan segera diatasi. <br><br>  <b>Ketidakkonsistenan data</b> <br>  Data dalam layanan mikro didesentralisasi, tidak ada database tunggal di mana semua informasi disimpan.  Merenungkan artikel ini, saya membahas interaksi utama antara layanan-layanan mikro dalam pikiran saya - di mana kami bisa mendapatkan duplikat, di mana kami menggunakan transaksi internetwork - dan saya menyadari bahwa kami memecahkan masalah ketidakkonsistenan dengan monolith. <br><br>  Kami benar-benar membangun sebuah monolith dengan satu basis utama, membungkus sebagian besar tindakan transaksional di dalamnya.  Dan di sekitar monolith, semua layanan mikro dikumpulkan yang tidak memengaruhi konsistensi data utama.  Pengecualian adalah sekelompok otorisasi layanan + monolith.  Masalahnya dalam hal ini adalah bahwa basis data aplikasi dasar tidak mengandung pengguna seperti itu, peran mereka dan parameter tambahan, semua ini ada dalam layanan otorisasi. <br><br>  Pengguna sistem dapat bekerja dengan mesin virtual dalam monolit, sementara di layanan otorisasi haknya dapat berubah, atau ia akan sepenuhnya diblokir.  Sistem harus menanggapi ini tepat waktu.  Dalam situasi ini, konsistensi data dicapai dengan memeriksa parameter pengguna sebelum menjalankan permintaan apa pun. <br><br>  Adapun microservices yang tersisa, ketidakmampuan untuk mendaftar di layanan statistik tidak mempengaruhi operasi mesin virtual, dan tindakan ini selalu dapat diulang.  Kami sedang melakukan layanan pengumpulan statistik.  Tetapi layanan domain define (membuat mesin virtual menggunakan libvirt) tidak akan pernah melihat cahaya, karena siapa yang membutuhkan mesin kosong tanpa keberadaan sebenarnya. <br><br><h2>  Kisah keempat.  Segar adalah musuh orang baik <br></h2><h5>  <font color="#787979">Penyebaran VM: Menginstal dari Gambar alih-alih Menginstal melalui Jaringan</font> </h5><br>  Dalam versi kelima produk, penyebaran mesin virtual membutuhkan waktu yang cukup lama dengan standar nyata.  Alasan untuk ini adalah menginstal sistem operasi melalui jaringan. <br><br>  Untuk Centos, Fedora, RedHat adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode kickstart</a> : <br>  1. Buat file kickstart. <br>  2. Tentukan tautan ke file respons di parameter kernel linux inst.ks = &lt;tautan ke file kickstart&gt;. <br>  3. Jalankan instalasi kickstart. <br><br>  File kickstart cukup fleksibel, di dalamnya Anda dapat menggambarkan semua langkah instalasi, mulai dari metode dan pengaturan zona waktu, diakhiri dengan partisi disk dan pengaturan jaringan.  Parameter url di templat kami menunjukkan bahwa instalasi berasal dari server jarak jauh. <br><br>  Untuk Debian dan Ubuntu, metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">preseed</a> : <br>  Ini mirip dengan yang sebelumnya, metode ini juga dibangun di sekitar file konfigurasi dan isinya.  Di dalamnya, kami juga mengkonfigurasi instalasi melalui jaringan. <br><br>  Instalasi untuk FreeBSD serupa, tetapi alih-alih file kickstart, ada skrip shell dari produksi kami sendiri. <br><br><h3>  Aspek positif dari pendekatan </h3><br>  Opsi instalasi ini memungkinkan Anda untuk menggunakan satu templat di dua produk kami: VMmanager dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DCImanager</a> (manajemen server khusus). <br><br>  Penyebaran mesin virtual cukup fleksibel, administrator panel dapat dengan mudah menyalin templat sistem operasi dan mengubah file konfigurasi sesuai keinginannya. <br><br>  Semua pengguna selalu memiliki versi terbaru dari sistem operasi jika mereka diperbarui secara tepat waktu pada server jarak jauh. <br><br><img src="https://habrastorage.org/webt/8w/z_/bk/8wz_bkz62ncaywrpb3mbd-eoyae.png"><br><br><h3>  Sisi negatif </h3><br>  Seperti yang telah ditunjukkan oleh praktik, fleksibilitas instalasi tidak diperlukan oleh pengguna VMmanager: dibandingkan dengan server khusus, beberapa orang khawatir tentang pengaturan file kickstart tertentu untuk mesin virtual.  Tetapi menunggu instalasi OS benar-benar merupakan kemewahan yang tidak dapat diterima.  Sisi lain dari relevansi sistem operasi adalah bagian dari penginstal ada di jaringan, dan bagian lokal untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">initrd</a> .  Dan versinya harus cocok. <br><br>  Ini adalah masalah yang bisa dipecahkan.  Anda dapat membuat kumpulan mesin yang diinstal dan membuat repositori Anda sendiri untuk sistem operasi, tetapi ini memerlukan biaya tambahan. <br><br>  Bagaimana mengatasi masalah ini tanpa membuat repositori dan kumpulan?  Kami memilih file gambar sistem operasi.  Sekarang proses instalasi terlihat seperti ini: <br>  1. Menyalin gambar OS ke disk mesin virtual. <br>  2. Tambah bagian utama gambar dengan ukuran ruang kosong setelah penyalinan. <br>  3. Pengaturan dasar (pengaturan kata sandi, zona waktu, dll.). <br><br>  Semua yang baru sudah lama terlupakan.  Kami menggunakan gambar OS di VDSmanager-Linux, leluhur dari VMmanager. <br><br>  Tetapi bagaimana dengan fleksibilitas instalasi?  Praktek telah menunjukkan bahwa sebagian besar pengguna tidak tertarik pada pengaturan jaringan spesifik dan pemetaan disk pada mesin virtual. <br>  Dan relevansi data?  Itu dapat dicapai dengan kehadiran gambar dengan versi OS terbaru di repositori, dan pembaruan kecil dapat diinstal pada skrip konfigurasi awal.  Dengan demikian, mesin virtual sudah akan dibuat dan dijalankan, dan pergi ke sana, Anda akan menemukan pembaruan yum bersyarat berjalan. <br><br>  Sebagai imbalannya, kami mendapatkan mesin virtual siap pakai, yang penyebarannya hanya bergantung pada menyalin disk, meningkatkan partisi disk dan memulai sistem operasi.  Implementasi pendekatan ini untuk bekerja dengan mesin memberi kita kesempatan untuk membuat gambar kita sendiri dan membaginya.  Pengguna dapat menginstal bundel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LAMP</a> atau lingkungan kompleks pada mesin virtual, kemudian membuat gambar dari mesin ini.  Sekarang, orang lain tidak perlu membuang waktu untuk menginstal utilitas yang diperlukan. <br><br>  Kami menerapkan konfigurasi dan modifikasi partisi menggunakan utilitas dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">suite libguestfs</a> .  Misalnya, mengubah kata sandi pada mesin linux berubah dari 40 baris kode, yang terdiri dari mount, chroot dan usermod, menjadi satu baris: <br><br><pre> <code class="cpp hljs">command = <span class="hljs-string"><span class="hljs-string">"/usr/bin/virt-customize --root-password password:{password} --domain '{domain_name}'"</span></span>.format(password=args.password, domain_name=args.domain_name)</code> </pre> <br>  Sebagai hasilnya, kami membuat mendapatkan mesin virtual jadi secepat mungkin.  Perlu membuat pernyataan bahwa dengan pengaturan jaringan dan pemasangan skrip internal, waktu penyebaran sedikit meningkat.  Kami memecahkan masalah ini dengan menampilkan langkah-langkah pemasangan di ujung depan, sehingga mengisi jeda yang terbentuk antara kreasi dan kesiapan lengkap mesin. <br><br>  Kami juga mendapat pendekatan yang lebih fleksibel untuk menggunakan mesin virtual, berdasarkan pada mana nyaman untuk membuat gambar Anda sendiri dengan lingkungan yang diperlukan. <br><br><h2>  Apa yang berhasil Anda lakukan </h2><br>  Dalam versi keenam produk, kami mencoba memperhitungkan kelemahan utama yang kelima: kompleksitas interaksi pengguna dengan produk.  Kami telah mengurangi waktu tunggu untuk tindakan utama.  Bersama-sama dengan antarmuka yang tidak menghalangi, ini memungkinkan untuk bekerja dengan panel tanpa harus menunggu dengan paksa.  Kontainer membuat proses instalasi produk lebih mudah dan nyaman.  Penggunaan teknologi modern dan berbagai bahasa pemrograman telah menyederhanakan dukungan dan pemeliharaan untuk programmer dan spesialis dukungan teknis.  Beralih ke layanan microser memungkinkan penambahan fitur baru dengan cepat dan dengan batasan kecil. <br><br>  Sebagai kesimpulan, saya ingin mengatakan bahwa produk baru ini adalah kesempatan yang baik untuk mencoba pendekatan pengembangan lain, teknologi baru.  Perlu diingat mengapa Anda melakukan ini, hal baru apa yang akan dibawanya kepada Anda dan pengguna Anda.  Lakukan itu! <br><br><blockquote>  Kami mengundang komunitas Habr untuk melihat versi beta VMmanager 6 dan meninggalkan umpan balik Anda.  Untuk melakukan ini, buka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">my.saasvm.com</a> , masuk dan sambungkan server khusus (CentOS 7 x64, akses Internet, alamat IP publik). <br><br>  Jika Anda tidak memiliki server, <a href="">kirimkan</a> kepada kami di <a href="">help@ispsystem.com</a> atau mengobrol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di situs</a> , kami akan menyediakan peralatan pengujian dari mitra kami, Selectel. <br><br>  Baca lebih lanjut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di berita di situs web ISPsystem</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441968/">https://habr.com/ru/post/id441968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441954/index.html">Hadiah pengguna untuk penulis Habr</a></li>
<li><a href="../id441956/index.html">Penanganan kesalahan terpadu (opsi C ++ untuk mikrokontroler)</a></li>
<li><a href="../id441962/index.html">Indeks dalam PostgreSQL - 1</a></li>
<li><a href="../id441964/index.html">Kiat & trik Kubernetes: memindahkan sumber daya kluster ke Helm 2</a></li>
<li><a href="../id441966/index.html">Kit Pemula Pengujian Keamanan Web</a></li>
<li><a href="../id441970/index.html">Analisis FinFisher Butkit</a></li>
<li><a href="../id441972/index.html">Invidious - frontend YouTube alternatif</a></li>
<li><a href="../id441974/index.html">Jalan sejarawan dari HR ke programmer Java: sedikit keberuntungan dan ketekunan</a></li>
<li><a href="../id441976/index.html">Dengan Anda FizTech.Science: kami mencari parameter tersembunyi dan terjun ke dunia kuantum yang luar biasa</a></li>
<li><a href="../id441978/index.html">Pengujian fungsional keterampilan Yandex Alice di Node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>