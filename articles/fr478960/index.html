<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèº üòê üâê Mini capteur de lumi√®re et de choc | nRF52840 üç∫ üì¢ üè§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans l'article d'aujourd'hui, je veux parler d'un nouveau capteur de lumi√®re et de vibrations. Le capteur fonctionne sur le module E73-2G4M08S1C (nRF5...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mini capteur de lumi√®re et de choc | nRF52840</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478960/">  Dans l'article d'aujourd'hui, je veux parler d'un nouveau capteur de lumi√®re et de vibrations.  Le capteur fonctionne sur le module E73-2G4M08S1C (nRF52840).  La raison du d√©veloppement de MK √©tait l'ajout assez simple de support √† l'Arduino IDE bas√© sur la biblioth√®que Sandeep Mistry, son faible co√ªt, ses excellentes fonctionnalit√©s et la possibilit√© de passer ensuite de mani√®re transparente de MySensors √† ZigBee par exemple :) <br><br><img src="https://habrastorage.org/webt/dm/b0/dt/dmb0dtvbakfgj_pgye8k_wjlmdc.jpeg"><br><a name="habracut"></a><br>  La n√©cessit√© d'un tel projet est apparue avec l'av√®nement d'un store √† enrouleur dans ma maison :).  Il √©tait n√©cessaire que le contr√¥leur de volet roulant re√ßoive des donn√©es sur le niveau d'√©clairage directement √† partir de la fen√™tre sur laquelle le rideau est contr√¥l√© par le contr√¥leur. <br><br>  Initialement, j'avais pr√©vu d'utiliser le capteur BH1750FVI, les caract√©ristiques de ce capteur √©taient fines, il a √©t√© utilis√© plus d'une fois dans mes autres projets de bricolage.  Mais √† un moment donn√©, en discutant de toutes sortes de capteurs, quelqu'un a sugg√©r√© de regarder de plus pr√®s le capteur MAX44009.  J'ai regard√© de pr√®s et √† partir de ce moment, je ne me suis plus jamais souvenu du BH1750FVI. <br><br><img src="https://habrastorage.org/webt/d7/bg/a_/d7bga_4sti9_x359xlgirab0egk.jpeg"><br><br>  <b>Sp√©cifications du MAX44009:</b> <br><br><ul><li>  Plage de tension d'alimentation 1,7-3,6 V, </li><li>  Courant de fonctionnement ultra-faible - 0,65 ŒºA (inf√©rieur au courant en mode Power Down pour de nombreux produits similaires), </li><li>  Large plage dynamique 22 bits 0,045-188000, </li><li>  La pr√©sence de la fonction d'interruption, la possibilit√© de surveiller en continu le niveau d'√©clairage et de g√©n√©rer un signal d'interruption pour le MC en cas de d√©passement des seuils sp√©cifi√©s. </li></ul><br>  Je voulais aussi l'universalit√© ou une sorte de fonctionnalit√© avanc√©e, apr√®s un peu de r√©flexion, j'ai d√©cid√© d'ajouter un acc√©l√©rom√®tre au projet qui fonctionnerait comme un capteur de vibrations.  Cela ajoutera des fonctionnalit√©s de s√©curit√© au capteur.  Dans mon cas, sur la base de l'√©v√©nement, un script en UD sera d√©clench√© √† partir du capteur qui simule la pr√©sence dans la maison (allumez la lumi√®re dans les pi√®ces), lorsqu'il est activ√©, personne n'est √† la maison.  En g√©n√©ral, le capteur peut √©galement √™tre utilis√© comme capteur autonome de vibrations et de chocs, seul un capteur de lumi√®re ou uniquement un acc√©l√©rom√®tre peut √™tre soud√©.  L'acc√©l√©rom√®tre peut √©galement √™tre reprogramm√© pour reconna√Ætre les tapas, les virages, etc. <br><br>  Comme acc√©l√©rom√®tre, c'est le capteur LIS2DW12 qui a √©t√© choisi, c'est l'un des acc√©l√©rom√®tres les plus √©conomiques du march√©, sinon le plus √©conomique. <br><br><img src="https://habrastorage.org/webt/ex/jc/op/exjcop6l77shvd-ietzkuksg5hq.jpeg"><br><br>  <b>Caract√©ristiques de LIS2DW12:</b> <br><br><ul><li>  Plage de tension d'alimentation 1,62-3,6 V, </li><li>  50 nA en mode veille </li><li>  1 ŒºA en mode basse consommation, </li><li>  La pr√©sence de la fonction d'interruption, la possibilit√© d'un fonctionnement continu du capteur et la formation d'un signal d'interruption pour le MC en cas de d√©passement des seuils sp√©cifi√©s. </li></ul><br>  Anticipant d'√©ventuels probl√®mes pour les fr√®res Arduino avec le lancement de ce mod√®le d'acc√©l√©rom√®tre en raison du manque total de biblioth√®ques Arduino pr√™tes √† l'emploi pour LIS2DW12, un support a ensuite √©t√© ajout√© pour un autre mod√®le d'acc√©l√©rom√®tre LIS2DH12 avec des caract√©ristiques similaires, mais une consommation plus √©lev√©e en mode basse consommation - 2 ŒºA.  Pour les acc√©l√©rom√®tres LIS2DH12, il existe de tr√®s bonnes biblioth√®ques Arduino. <br><br>  Le capteur de lumi√®re est aliment√© par une pile CR2032. <br><br><img src="https://habrastorage.org/webt/bd/z3/lf/bdz3lfe167cepe3m-5vvg0fc5-0.jpeg"><br><br>  Beaucoup de ceux qui utilisent d√©j√† le projet MySensors pour construire leur maison intelligente connaissent probablement la logique non optimale de MySensors sur les appareils √† batterie.  Envoi constant de pr√©sentations lors du red√©marrage de l'appareil, mode sous-optimal de r√©cup√©ration automatique des appareils sur le r√©seau, consommation sous-optimale avec des interruptions activ√©es dans la fonction sommeil, en g√©n√©ral, la pr√©sence m√™me de seulement deux interruptions dans un r√™ve.  Toutes les circonstances sugg√®rent que les fondateurs du projet Maysensors ont une mauvaise attitude envers les batteries :) <br><br>  Dans ce projet, j'ai essay√© de minimiser ces lacunes. <br><br>  La chose la plus fondamentale √† laquelle je voulais faire face √©tait les interruptions.  En r√®gle g√©n√©rale, lorsque des interruptions sont activ√©es dans la fonction de veille, le nRF52 MK commence √† consommer + 10 mKA par rapport √† la consommation du MK lui-m√™me (de 1,4 ŒºA pour nRF52810-52811 et jusqu'√† 4,7 ŒºA pour nRF52832-52840).  Un total de 2 interruptions sont disponibles. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> sleep(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> interrupt1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> mode1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> interrupt2, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> mode2, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> sleepingMS = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> smartSleep = <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br>  Plus t√¥t dans la recherche de solutions pour optimiser la consommation dans un r√™ve, la possibilit√© d'utiliser des interruptions sur le comparateur int√©gr√© √† faible consommation a √©t√© r√©alis√©e, la consommation dans un r√™ve n'√©tait plus de + 10 ŒºA, mais de l'ordre de +1 ŒºA, mais il n'√©tait possible d'utiliser qu'une seule interruption.  En principe, en dehors des inconv√©nients du code (traitement des signaux provenant de broches suppl√©mentaires) et des √©l√©ments suppl√©mentaires sur la carte (diodes), c'√©tait une bonne solution.  Mais je le voulais encore mieux. <br><br>  √Ä cette √©poque, j'√©tais d√©j√† un peu familier :) avec le SDK nRF5, donc apr√®s avoir √©tudi√© le forum mysensors.org (astuces, conseils :)), j'ai d√©cid√© de chercher la solution dans le SDK nRF5 ... et je l'ai trouv√©e.  Maintenant, un nombre illimit√© d'interruptions est disponible qui ne consomme pratiquement rien de plus.  La principale chose √† faire est d'apporter une petite modification au code de la biblioth√®que Sandeepmistry nRF5, au fichier WInterrupts. Avant la fonction GPIOTE_IRQHandler () ajoutez l'attribut "faible" qui vous permettra de red√©finir cette fonction de biblioth√®que en code utilisateur - __attribute__ ((faible)) <br><br><img src="https://habrastorage.org/webt/s5/sf/oy/s5sfoy5fdmvjiu16afhtkcrxkjg.png"><br><br>  Le fichier se trouve sur le chemin - C: \ Users \ COMPUTER_USER \ AppData \ Local \ Arduino15 \ packages \ sandeepmistry \ <br>  mat√©riel \ nRF5 \ 0.6.0 \ cores \ nRF5 \ <br>  Les fichiers qui doivent √™tre ajout√©s au projet se trouvent sur ma Gita dans le dossier EFEKTA-LIS2DW12-MAX44009-E73C / SOURCE CODE / ARDUINO /, un exemple d'utilisation est dans l'esquisse EFEKTA-LIS2DW12-MAX44009-E73C / SOURCE CODE / ARDUINO / vibro_ambi1_ino <br><br>  La prochaine chose que je voulais finaliser √©tait la biblioth√®que Sandeepmistry nRF5 elle-m√™me, ce qui serait pratique pour travailler avec les nouveaux MK nRF52840, nRF52811 et anciens, mais pour une raison quelconque, sans ajouter sans raison nRF52810 (apr√®s tout, 1,4 ŒºA dans un r√™ve n'est pas pour vous :)).  Bien s√ªr, vous pouvez travailler avec nRF52840 dans l'IDE Arduino et sous nRF52832, mais ... je voulais le rendre plus confortable.  Ci-dessus, j'ai √©crit qu'il y avait un int√©r√™t √† faire quelque chose sur le Nordic SDK, en particulier Segger Embedded Studio est gratuit lorsque vous travaillez avec MK nRF5.  La prise en charge de toutes les cartes qui m'int√©ressent a √©t√© prise du SDK et transf√©r√©e √† Arduino (jusqu'√† pr√©sent sans softdevice, et ce n'est pas n√©cessaire avec mysensors).  De nouvelles cartes ont √©galement √©t√© ajout√©es √† la biblioth√®que MySensors. <br><br><img src="https://habrastorage.org/webt/xc/hy/dy/xchydy8gbj0ld1tcvtyjiqbu70o.png"><br><br>  <a href="https://github.com/smartboxchannel/arduino-nRF5" rel="nofollow">github.com/smartboxchannel/arduino-nRF5</a> <br>  <a href="https://github.com/smartboxchannel/MySensors" rel="nofollow">github.com/smartboxchannel/MySensors</a> <br><br>  Si l'un des lecteurs conna√Æt d√©j√† mes articles pr√©c√©dents, vous ne serez probablement pas surpris que j'ai, comme auparavant, fabriqu√© une imprimante √† polym√®re liquide sur le SLA avec un √©tui pour un capteur de lumi√®re.  Les avantages de l'impression sur cette technologie sont sa grande pr√©cision.  Mais bien s√ªr, il y a aussi des inconv√©nients, les polym√®res avec lesquels les imprimantes SLA domestiques sont capables de travailler sont toujours de r√©sistance inf√©rieure aux plastiques pour FDM.Le mod√®le 3D du bo√Ætier se compose de 2 parties, chaque moiti√© a √©t√© imprim√©e pendant 40 minutes (√©paisseur de couche 50 microns).  Surtout, il n'est probablement pas n√©cessaire de s'arr√™ter l√†, juste quelques images du processus de d√©veloppement dans un √©diteur 3D. <br><br><img src="https://habrastorage.org/webt/a0/x0/qt/a0x0qtl5jiglsmcidmbjibr_5wi.png"><br><br><img src="https://habrastorage.org/webt/by/cz/rk/byczrkmuesyuzijn5yyvv71uroa.png"><br><br><img src="https://habrastorage.org/webt/i4/ct/qc/i4ctqcrbeduw2p4an1a1jpkie9s.png"><br><br>  Le programme du capteur a impl√©ment√© un red√©marrage de l'appareil sans envoyer de pr√©sentations.  Cela fonctionne comme ceci: alors que l'appareil est nouveau et non ajout√© √† votre r√©seau, lorsqu'il est ajout√© au r√©seau pour la premi√®re fois, il enregistrera et terminera la pr√©sentation, une fois l'enregistrement r√©ussi, l'appareil qui a re√ßu l'identifiant n'enverra plus la pr√©sentation, mais vous pouvez envoyer la pr√©sentation en cliquant sur le bouton du capteur (ce n√©cessaire, par exemple, si tous les capteurs n'ont pas √©t√© pr√©sent√©s avec succ√®s imm√©diatement).  De plus, le programme d√©sactive la possibilit√© d'une r√©cup√©ration automatique standard de l'activit√© r√©seau (si le capteur perd le r√©seau), sa propre option non standard a √©t√© invent√©e :).  Cela fonctionne comme ceci: si le capteur d√©tecte plus de 5 tentatives (ce qui est configurable) infructueuses pour envoyer des messages dans une rang√©e, l'appareil cesse d'envoyer des donn√©es √† partir des capteurs et commence √† envoyer un message de recherche r√©seau avec un intervalle initialement √©gal √† l'intervalle d'envoi depuis / 2 capteurs et en augmentant p√©riodiquement cet intervalle c chaque envoi, entre envois un r√™ve sain.  Tout cela vous permet d'√©conomiser consid√©rablement la batterie. <br><br><div class="spoiler">  <b class="spoiler_title">Code de test</b> <div class="spoiler_text"><pre> <code class="css hljs">// <span class="hljs-selector-tag"><span class="hljs-selector-tag">SDK</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PORT</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">extern</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span>" { #include "app_gpiote.h" #include "nrf_gpio.h" } <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">APP_GPIOTE_MAX_USERS</span></span> 1 <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">LIS2DW12Sensor</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">MAX44009</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; //<span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_DEBUG</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_RADIO_NRF5_ESB</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_DISABLED_SERIAL</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mtwr</span></span>; <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_TRANSPORT_WAIT_READY_MS</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">mtwr</span></span>) <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_NRF5_ESB_PA_LEVEL</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">NRF5_PA_MAX</span></span>) <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">MySensors</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SN</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">LUX</span></span> &amp; <span class="hljs-selector-tag"><span class="hljs-selector-tag">VIBRO</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SENS</span></span>" <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SV</span></span> "1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>" <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_SENS_CHILD_ID</span></span> 1 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LUX_SENS_CHILD_ID</span></span> 2 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">WPM_SENS_CHILD_ID</span></span> 3 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">INTERVAL_R_LUX_CHILD_ID</span></span> 220 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LEVEL_SENSIV_V_SENS_CHILD_ID</span></span> 230 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ENABLE_WPM_SENS_CHILD_ID</span></span> 240 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SIGNAL_Q_ID</span></span> 253 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">TEMP_CHILD_ID</span></span> 254 //<span class="hljs-selector-tag"><span class="hljs-selector-tag">for</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">any</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tests</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">MySensors</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vibroMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">V_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_TRIPPED</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">brightMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">LUX_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_LEVEL</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">wpmMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">WPM_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_LEVEL</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">conf_wpmMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">ENABLE_WPM_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_VAR1</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">conf_vsensMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">LEVEL_SENSIV_V_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_VAR1</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">conf_interv_rluxMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">INTERVAL_R_LUX_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_VAR1</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tempMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TEMP_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_VAR1</span></span>); //<span class="hljs-selector-tag"><span class="hljs-selector-tag">for</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">any</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tests</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">nosleep</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">button_flag</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">configMode</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">wpm_enable</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">onoff</span></span> = 1; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_update_transport_param</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_sendRoute_parent</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_no_present</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_nogateway_mode</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_find_parent_process</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_fcount</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Ack_TL</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Ack_FP</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PRESENT_ACK</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">conf_vibro_set</span></span> = 1; <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">interval_reading_lux</span></span> = 10; <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">err_delivery_beat</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">problem_mode_count</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint8_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">countbatt</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint8_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">batt_cap</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint8_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">old_batt_cap</span></span> = 100; //<span class="hljs-selector-tag"><span class="hljs-selector-tag">unsigned</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">long</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BATT_TIME</span></span> = 43200000; //12 <span class="hljs-selector-tag"><span class="hljs-selector-tag">hours</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BATT_TIME</span></span> = 7200000; //12 <span class="hljs-selector-tag"><span class="hljs-selector-tag">hours</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SLEEP_TIME_TEMP</span></span> = 60000; //1 <span class="hljs-selector-tag"><span class="hljs-selector-tag">minute</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SLEEP_TIME</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">C_BATT_TIME</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">oldmillis</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">newmillis</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">previousMillis</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lightMillisR</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">configMillis</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">interrupt_time</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SLEEP_TIME_W</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">axel_time</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">result</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">brightness</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lastbrightness</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">brightThreshold</span></span> = 25; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">myid</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mypar</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">old_mypar</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">-1</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">master_id</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Wpm</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_1Hz6_LP_ONLY</span></span> = 1<span class="hljs-selector-class"><span class="hljs-selector-class">.6f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_12Hz5</span></span> = 12<span class="hljs-selector-class"><span class="hljs-selector-class">.5f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_25Hz</span></span> = 25<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_50Hz</span></span> = 50<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_100Hz</span></span> = 100<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_200Hz</span></span> = 200<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vibro</span></span> = 1; <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">app_gpiote_user_id_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">m_gpiote_user_id</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PIN_BUTTON1_MASK</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">AXEL_INT1_MASK</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">volatile</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">axelInt1Status</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">volatile</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">buttInt1Status</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">batteryVoltage</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">linkQuality</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">old_linkQuality</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">LIS2DW12Sensor</span></span> *<span class="hljs-selector-tag"><span class="hljs-selector-tag">lis2</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">MAX44009</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">light</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">preHwInit</span></span>() { board_Init(); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">before</span></span>() { blinky(1, 1, GREEN_LED); wait(1000); nRF_Init(); device_Conf(); happy_init(); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">setup</span></span>() { interrupt_Init(); sensors_Init(); config_Happy_node(); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">presentation</span></span>() { if (!sendSketchInfo(SN, SV)) { _transportSM.failedUplinkTransmissions = 0; sleep(1000); wait(50); if (!sendSketchInfo(SN, SV)) { _transportSM.failedUplinkTransmissions = 0; } } <span class="hljs-selector-tag"><span class="hljs-selector-tag">present</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">V_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">S_VIBRATION</span></span>, "<span class="hljs-selector-tag"><span class="hljs-selector-tag">STATUS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">VIBRO</span></span>", 1); <span class="hljs-selector-tag"><span class="hljs-selector-tag">wait</span></span>(2500, <span class="hljs-selector-tag"><span class="hljs-selector-tag">C_PRESENTATION</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">S_VIBRATION</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">CORE_DEBUG</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">PSTR</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">MyS</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">TEST</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">WAIT</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">AFTER</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PRESENT</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SENSOR</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span>")); <span class="hljs-selector-tag"><span class="hljs-selector-tag">if</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">PRESENT_ACK</span></span> == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(V_SENS_CHILD_ID, S_VIBRATION, "STATUS VIBRO", 1); wait(2500, C_PRESENTATION, S_VIBRATION); CORE_DEBUG(PSTR("<span class="hljs-attribute"><span class="hljs-attribute">MyS</span></span>: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(LUX_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span></span>LUX<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_LIGHT_LEVEL); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(LUX_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span></span>LUX<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_LIGHT_LEVEL); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(WPM_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span></span>W/M^<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_LIGHT_LEVEL); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(WPM_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span></span>W/M^<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_LIGHT_LEVEL); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(SIGNAL_Q_ID, S_CUSTOM, "</span></span>SIGNAL QUALITY<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(SIGNAL_Q_ID, S_CUSTOM, "</span></span>SIGNAL QUALITY<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(ENABLE_WPM_SENS_CHILD_ID, S_CUSTOM, "</span></span>ON|OFF WPM<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(ENABLE_WPM_SENS_CHILD_ID, S_CUSTOM, "</span></span>ON|OFF WPM<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(LEVEL_SENSIV_V_SENS_CHILD_ID, S_CUSTOM, "</span></span>SENS LEVEL VIBRO<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(LEVEL_SENSIV_V_SENS_CHILD_ID, S_CUSTOM, "</span></span>SENS LEVEL VIBRO<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(INTERVAL_R_LUX_CHILD_ID, S_CUSTOM, "</span></span>INTERVAL RLUX|MIN<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(INTERVAL_R_LUX_CHILD_ID, S_CUSTOM, "</span></span>INTERVAL RLUX|MIN<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } send(conf_wpmMsg.set(wpm_enable), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (Ack_TL == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); send(conf_wpmMsg.set(wpm_enable), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { Ack_TL = 0; } send(conf_vsensMsg.set(conf_vibro_set), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (Ack_TL == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); send(conf_vsensMsg.set(conf_vibro_set), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { Ack_TL = 0; } send(conf_interv_rluxMsg.set(interval_reading_lux), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (Ack_TL == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); send(conf_interv_rluxMsg.set(interval_reading_lux), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { Ack_TL = 0; } } void loop() { if (flag_update_transport_param == 1) { update_Happy_transport(); } if (flag_sendRoute_parent == 1) { present_only_parent(); } if (isTransportReady() == true) { if (flag_nogateway_mode == 0) { if (flag_find_parent_process == 1) { find_parent_process(); } if (configMode == 0) { if ((axelInt1Status == AXEL_INT1) || (buttInt1Status == PIN_BUTTON1)) { if (axelInt1Status == AXEL_INT1) { nosleep = 1; send_Axel(); axelInt1Status = 0; newmillis = millis(); interrupt_time = newmillis - oldmillis; SLEEP_TIME_W = SLEEP_TIME_W - interrupt_time; if (SLEEP_TIME_W &lt; 5000) { SLEEP_TIME_W = SLEEP_TIME; send_Brigh(1); countbatt++; if (countbatt == C_BATT_TIME) { sendBatteryStatus(1); countbatt = 0; } } nosleep = 0; } if (buttInt1Status == PIN_BUTTON1) { if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 0) { button_flag = 1; nosleep = 1; previousMillis = millis(); ledsOff(); } if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 1) { if ((millis() - previousMillis &gt; 0) &amp;&amp; (millis() - previousMillis &lt;= 1750)) { if (millis() - lightMillisR &gt; 25) { lightMillisR = millis(); onoff = !onoff; digitalWrite(GREEN_LED, onoff); } } if ((millis() - previousMillis &gt; 1750) &amp;&amp; (millis() - previousMillis &lt;= 2000)) { ledsOff(); } if ((millis() - previousMillis &gt; 2000) &amp;&amp; (millis() - previousMillis &lt;= 4000)) { if (millis() - lightMillisR &gt; 25) { lightMillisR = millis(); onoff = !onoff; digitalWrite(BLUE_LED, onoff); } } if ((millis() - previousMillis &gt; 4000) &amp;&amp; (millis() - previousMillis &lt;= 4250)) { ledsOff(); } if ((millis() - previousMillis &gt; 4250) &amp;&amp; (millis() - previousMillis &lt;= 6250)) { if (millis() - lightMillisR &gt; 25) { lightMillisR = millis(); onoff = !onoff; digitalWrite(RED_LED, onoff); } } if ((millis() - previousMillis &gt; 6250) &amp;&amp; (millis() - previousMillis &lt;= 6500)) { ledsOff(); } if ((millis() - previousMillis &gt; 6500) &amp;&amp; (millis() - previousMillis &lt;= 8500)) { if (millis() - lightMillisR &gt; 50) { lightMillisR = millis(); onoff = !onoff; digitalWrite(RED_LED, onoff); } } if (millis() - previousMillis &gt; 8500) { ledsOff(); } } if (digitalRead(PIN_BUTTON1) == 1 &amp;&amp; button_flag == 1) { if (millis() - previousMillis &lt;= 2000) { ledsOff(); send_Brigh(0); nosleep = 0; button_flag = 0; buttInt1Status = 0; } if ((millis() - previousMillis &gt; 2000) &amp;&amp; (millis() - previousMillis &lt;= 4000)) { ledsOff(); configMode = 1; button_flag = 0; configMillis = millis(); } if ((millis() - previousMillis &gt; 4250) &amp;&amp; (millis() - previousMillis &lt;= 6250)) { ledsOff(); blinky(2, 2, RED_LED); button_flag = 0; buttInt1Status = 0; presentation(); nosleep = 0; } if ((millis() - previousMillis &gt; 6500) &amp;&amp; (millis() - previousMillis &lt;= 8500)) { ledsOff(); blinky(3, 3, RED_LED); new_device(); } if (((millis() - previousMillis &gt; 1750) &amp;&amp; (millis() - previousMillis &lt;= 2000)) || ((millis() - previousMillis &gt; 4000) &amp;&amp; (millis() - previousMillis &lt;= 4250)) || ((millis() - previousMillis &gt; 6250) &amp;&amp; (millis() - previousMillis &lt;= 6500)) || ((millis() - previousMillis &gt; 8500))) { ledsOff(); blinky(1, 2, GREEN_LED); nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } } else { SLEEP_TIME_W = SLEEP_TIME; send_Brigh(1); countbatt++; if (countbatt == C_BATT_TIME) { sendBatteryStatus(1); countbatt = 0; } nosleep = 0; } } else { if (millis() - configMillis &gt; 30000) { blinky(3, 3, GREEN_LED); configMode = 0; nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } else { if (buttInt1Status == PIN_BUTTON1) { if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 0) { button_flag = 1; nosleep = 1; previousMillis = millis(); ledsOff(); } if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 1) { if ((millis() - previousMillis &gt; 0) &amp;&amp; (millis() - previousMillis &lt;= 500)) { ledsOff(); } if ((millis() - previousMillis &gt; 500) &amp;&amp; (millis() - previousMillis &lt;= 2500)) { lightMillisR = millis(); onoff = !onoff; digitalWrite(BLUE_LED, onoff); } if ((millis() - previousMillis &gt; 2500) &amp;&amp; (millis() - previousMillis &lt;= 2750)) { ledsOff(); } if ((millis() - previousMillis &gt; 2750) &amp;&amp; (millis() - previousMillis &lt;= 4750)) { if (millis() - lightMillisR &gt; 50) { lightMillisR = millis(); onoff = !onoff; digitalWrite(RED_LED, onoff); } } if (millis() - previousMillis &gt; 4750) { ledsOff(); blinky(3, 1, GREEN_LED); button_flag = 0; nosleep = 0; buttInt1Status = 0; } } if (digitalRead(PIN_BUTTON1) == 1 &amp;&amp; button_flag == 1) { if (millis() - previousMillis &lt;= 500) { ledsOff(); button_flag = 0; nosleep = 0; buttInt1Status = 0; } if ((millis() - previousMillis &gt; 500) &amp;&amp; (millis() - previousMillis &lt;= 2500)) { ledsOff(); blinky(1, 1, BLUE_LED); check_parent(); button_flag = 0; nosleep = 0; buttInt1Status = 0; } if ((millis() - previousMillis &gt; 2500) &amp;&amp; (millis() - previousMillis &lt;= 2750)) { ledsOff(); button_flag = 0; nosleep = 0; buttInt1Status = 0; } if ((millis() - previousMillis &gt; 2750) &amp;&amp; (millis() - previousMillis &lt;= 4750)) { ledsOff(); blinky(3, 3, RED_LED); new_device(); } if (millis() - previousMillis &gt; 4750) { ledsOff(); button_flag = 0; nosleep = 0; buttInt1Status = 0; } } } else { check_parent(); } } } if (_transportSM.failureCounter &gt; 0) { _transportConfig.parentNodeId = loadState(101); _transportConfig.nodeId = myid; _transportConfig.distanceGW = loadState(103); mypar = _transportConfig.parentNodeId; nosleep = 0; flag_fcount = 1; err_delivery_beat = 5; happy_node_mode(); gateway_fail(); } if (configMode == 0) { if (nosleep == 0) { oldmillis = millis(); axelInt1Status = 0; buttInt1Status = 0; wait(100); sleep(SLEEP_TIME_W, false); wait(50); nosleep = 1; } } } float GetWpm() { float SunLuxCoef = 0.0079; float Wpm_temp = 0; Wpm_temp = (float)brightness; Wpm_temp *= SunLuxCoef; return Wpm_temp; } void blinky(uint8_t pulses, uint8_t repit, uint8_t ledColor) { for (int x = 0; x &lt; repit; x++) { if (x &gt; 0) { sleep(300); } for (int i = 0; i &lt; pulses; i++) { if (i &gt; 0) { sleep(80); } digitalWrite(ledColor, LOW); sleep(20); digitalWrite(ledColor, HIGH); } } } void ledsOff() { digitalWrite(RED_LED, HIGH); digitalWrite(GREEN_LED, HIGH); digitalWrite(BLUE_LED, HIGH); } void nRF_Init() { NRF_POWER-&gt;DCDCEN = 1; NRF_NFCT-&gt;TASKS_DISABLE = 1; NRF_NVMC-&gt;CONFIG = 1; NRF_UICR-&gt;NFCPINS = 0; NRF_NVMC-&gt;CONFIG = 0; NRF_SAADC -&gt;ENABLE = 0; NRF_PWM0 -&gt;ENABLE = 0; NRF_PWM1 -&gt;ENABLE = 0; NRF_PWM2 -&gt;ENABLE = 0; NRF_TWIM1 -&gt;ENABLE = 0; NRF_TWIS1 -&gt;ENABLE = 0; NRF_RADIO-&gt;TXPOWER = 8; } void sensors_Init() { Wire.begin(); wait(100); light.begin(); wait(100); lis2 = new LIS2DW12Sensor (&amp;Wire); vibro_Init(); if (isTransportReady() == true) { blinky(3, 1, BLUE_LED); wait(200); blinky(3, 1, GREEN_LED); wait(200); blinky(3, 1, RED_LED); SLEEP_TIME_W = SLEEP_TIME; send_Brigh(0); wait(50); sendBatteryStatus(0); axel_time = millis(); } else { blinky(5, 3, RED_LED); } } void vibro_Init() { if (conf_vibro_set == 1) { lis2-&gt;ODRTEMP = ODR_1Hz6_LP_ONLY; } if (conf_vibro_set == 2) { lis2-&gt;ODRTEMP = ODR_12Hz5; } if (conf_vibro_set == 3) { lis2-&gt;ODRTEMP = ODR_25Hz; } if (conf_vibro_set == 4) { lis2-&gt;ODRTEMP = ODR_100Hz; } if (conf_vibro_set == 5) { lis2-&gt;ODRTEMP = ODR_200Hz; } lis2-&gt;Enable_X(); wait(50); lis2-&gt;Enable_Wake_Up_Detection(); wait(50); } void board_Init() { pinMode(PIN_BUTTON1, INPUT); pinMode(AXEL_INT1, INPUT); pinMode(AXEL_INT2, INPUT); pinMode(AMBI_INT, INPUT); pinMode(RED_LED, OUTPUT); pinMode(GREEN_LED, OUTPUT); pinMode(BLUE_LED, OUTPUT); ledsOff(); } void send_Axel() { if (millis() - axel_time &gt;= 5000) { blinky(6, 1, RED_LED); lis2-&gt;Disable_Wake_Up_Detection(); wait(100); if (_transportConfig.parentNodeId == 0) { if (send(vibroMsg.set(vibro))) { wait(100); err_delivery_beat = 0; if (flag_nogateway_mode == 1) { flag_nogateway_mode = 0; CORE_DEBUG(PSTR("</span></span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; } } else { _transportSM.failedUplinkTransmissions = 0; if (err_delivery_beat &lt; 5) { err_delivery_beat++; } if (err_delivery_beat == 4) { if (flag_nogateway_mode == 0) { gateway_fail(); CORE_DEBUG(PSTR("</span></span>MyS: LOST GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); } } } lis2-&gt;Enable_Wake_Up_Detection(); wait(100); axel_time = millis(); nosleep = 0; } if (_transportConfig.parentNodeId &gt; 0) { send(vibroMsg.set(vibro), 1); wait(2500, C_SET, V_TRIPPED); if (Ack_TL == 1) { Ack_TL = 0; err_delivery_beat = 0; //sleep_flag = 0; if (flag_nogateway_mode == 1) { flag_nogateway_mode = 0; CORE_DEBUG(PSTR("</span></span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; } } else { _transportSM.failedUplinkTransmissions = 0; if (err_delivery_beat &lt; 5) { err_delivery_beat++; } if (err_delivery_beat == 4) { if (flag_nogateway_mode == 0) { gateway_fail(); CORE_DEBUG(PSTR("</span></span>MyS: LOST GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); } } } lis2-&gt;Enable_Wake_Up_Detection(); wait(100); axel_time = millis(); nosleep = 0; } } else { nosleep = 0; } } void send_Brigh(bool start) { brightness = light.get_lux() * 2; wait(50); if (start == 1) { if (abs(brightness - lastbrightness) &gt;= brightThreshold) { if (_transportConfig.parentNodeId == 0) { if (send(brightMsg.set(brightness, 0))) { err_delivery_beat = 0; if (flag_nogateway_mode == 1) { flag_nogateway_mode = 0; CORE_DEBUG(PSTR("</span></span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; } lastbrightness = brightness; if (wpm_enable == 1) { Wpm = GetWpm(); wait(100); send(wpmMsg.set(Wpm, 0)); } wait(50); blinky(2, 2, BLUE_LED); } else { _transportSM.failedUplinkTransmissions = 0; if (err_delivery_beat &lt; 5) { err_delivery_beat++; } if (err_delivery_beat == 4) { if (flag_nogateway_mode == 0) { gateway_fail(); CORE_DEBUG(PSTR("</span></span>MyS: LOST GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); } } } } if (_transportConfig.parentNodeId &gt; 0) { send(brightMsg.set(brightness, 0), 1); wait(2500, C_SET, V_LEVEL); if (Ack_TL == 1) { Ack_TL = 0; err_delivery_beat = 0; if (flag_nogateway_mode == 1) { flag_nogateway_mode = 0; CORE_DEBUG(PSTR("</span></span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; } lastbrightness = brightness; if (wpm_enable == 1) { Wpm = GetWpm(); wait(100); send(wpmMsg.set(Wpm, 0)); } wait(50); blinky(2, 2, BLUE_LED); } else { _transportSM.failedUplinkTransmissions = 0; if (err_delivery_beat &lt; 5) { err_delivery_beat++; } if (err_delivery_beat == 4) { if (flag_nogateway_mode == 0) { gateway_fail(); CORE_DEBUG(PSTR("</span></span>MyS: LOST GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); } } } } } } else { send(brightMsg.set(brightness, 0)); lastbrightness = brightness; if (wpm_enable == 1) { Wpm = GetWpm(); wait(100); send(wpmMsg.set(Wpm, 0)); } wait(50); blinky(2, 2, BLUE_LED); } } void interrupt_Init() { //*** //SET //NRF_GPIO_PIN_NOPULL //NRF_GPIO_PIN_PULLUP //NRF_GPIO_PIN_PULLDOWN //*** nrf_gpio_cfg_input(PIN_BUTTON1, NRF_GPIO_PIN_PULLUP); nrf_gpio_cfg_input(AXEL_INT1, NRF_GPIO_PIN_NOPULL); APP_GPIOTE_INIT(APP_GPIOTE_MAX_USERS); PIN_BUTTON1_MASK = 1 &lt;&lt; PIN_BUTTON1; AXEL_INT1_MASK = 1 &lt;&lt; AXEL_INT1; // app_gpiote_user_register(p_user_id, pins_low_to_high_mask, pins_high_to_low_mask, event_handler) app_gpiote_user_register(&amp;m_gpiote_user_id, AXEL_INT1_MASK, PIN_BUTTON1_MASK, gpiote_event_handler); app_gpiote_user_enable(m_gpiote_user_id); axelInt1Status = 0; buttInt1Status = 0; } void gpiote_event_handler(uint32_t event_pins_low_to_high, uint32_t event_pins_high_to_low) { MY_HW_RTC-&gt;CC[0] = (MY_HW_RTC-&gt;COUNTER + 2); if (PIN_BUTTON1_MASK &amp; event_pins_high_to_low) { if ((buttInt1Status == 0) &amp;&amp; (axelInt1Status == 0)) { buttInt1Status = PIN_BUTTON1; } } if (flag_nogateway_mode == 0) { if (configMode == 0) { if (AXEL_INT1_MASK &amp; event_pins_low_to_high) { if ((axelInt1Status == 0) &amp;&amp; (buttInt1Status == 0)) { axelInt1Status = AXEL_INT1; } } } } /*** if ((PIN_BUTTON_MASK &amp; event_pins_low_to_high) || (PIN_BUTTON1_MASK &amp; event_pins_high_to_low)) ***/ } void device_Conf() { conf_vibro_set = loadState(230); if ((conf_vibro_set &gt; 5) || (conf_vibro_set == 0)) { conf_vibro_set = 1; saveState(230, conf_vibro_set); } wpm_enable = loadState(240); if (wpm_enable &gt; 1) { wpm_enable = 0; saveState(240, wpm_enable); } interval_reading_lux = loadState(220); if (interval_reading_lux &gt; 60) { interval_reading_lux = 60; saveState(230, interval_reading_lux); } else if (interval_reading_lux &lt; 1) { interval_reading_lux = 1; saveState(230, interval_reading_lux); } SLEEP_TIME = SLEEP_TIME_TEMP * interval_reading_lux; C_BATT_TIME = BATT_TIME / SLEEP_TIME; } void sendBatteryStatus(bool start) { sleep(5000); wait(200); batteryVoltage = hwCPUVoltage(); wait(10); batt_cap = battery_level_in_percent(batteryVoltage); if (start == 1) { if (batt_cap &lt; old_batt_cap) { sendBatteryLevel(battery_level_in_percent(batteryVoltage), 1); wait(2500, C_INTERNAL, I_BATTERY_LEVEL); old_batt_cap = batt_cap; } } else { sendBatteryLevel(battery_level_in_percent(batteryVoltage), 1); wait(2500, C_INTERNAL, I_BATTERY_LEVEL); } linkQuality = calculationRxQuality(); if (linkQuality != old_linkQuality) { wait(10); sendSignalStrength(linkQuality); wait(50); old_linkQuality = linkQuality; } } bool sendSignalStrength(const int16_t level, const bool ack) { return _sendRoute(build(_msgTmp, GATEWAY_ADDRESS, SIGNAL_Q_ID, C_SET, V_VAR1, ack).set(level)); } int16_t calculationRxQuality() { int16_t nRFRSSI_temp = transportGetReceivingRSSI(); int16_t nRFRSSI = map(nRFRSSI_temp, -85, -40, 0, 100); if (nRFRSSI &lt; 0) { nRFRSSI = 0; } if (nRFRSSI &gt; 100) { nRFRSSI = 100; } return nRFRSSI; } void happy_init() { //hwWriteConfig(EEPROM_NODE_ID_ADDRESS, 255); // ******************** checking the node config reset ************************* if (hwReadConfig(EEPROM_NODE_ID_ADDRESS) == 0) { hwWriteConfig(EEPROM_NODE_ID_ADDRESS, 255); } if (loadState(100) == 0) { saveState(100, 255); } CORE_DEBUG(PSTR("</span></span>EEPROM NODE ID: %d\n<span class="hljs-string"><span class="hljs-string">"), hwReadConfig(EEPROM_NODE_ID_ADDRESS)); CORE_DEBUG(PSTR("</span></span>USER MEMORY SECTOR NODE ID: %d\n<span class="hljs-string"><span class="hljs-string">"), loadState(100)); if (hwReadConfig(EEPROM_NODE_ID_ADDRESS) == 255) { mtwr = 0; } else { mtwr = 10000; no_present(); } CORE_DEBUG(PSTR("</span></span>MY_TRANSPORT_WAIT_MS: %d\n<span class="hljs-string"><span class="hljs-string">"), mtwr); } void new_device() { hwWriteConfig(EEPROM_NODE_ID_ADDRESS, 255); saveState(100, 255); wdt_enable(WDTO_15MS); } void config_Happy_node() { if (mtwr == 0) { myid = getNodeId(); saveState(100, myid); mypar = _transportConfig.parentNodeId; old_mypar = mypar; master_id = 0; // *************************** master slave mode is not initialized in this example, ..stub ******************************* saveState(101, mypar); saveState(102, _transportConfig.distanceGW); } if (mtwr != 0) { myid = getNodeId(); if (myid != loadState(100)) { saveState(100, myid); } if (isTransportReady() == true) { mypar = _transportConfig.parentNodeId; master_id = 0; // *************************** master slave mode is not initialized in this example, ..stub ******************************* if (mypar != loadState(101)) { saveState(101, mypar); } if (_transportConfig.distanceGW != loadState(102)) { saveState(102, _transportConfig.distanceGW); } present_only_parent(); } if (isTransportReady() == false) { no_present(); flag_fcount = 1; err_delivery_beat = 5; _transportConfig.nodeId = myid; _transportConfig.parentNodeId = loadState(101); _transportConfig.distanceGW = loadState(102); mypar = _transportConfig.parentNodeId; happy_node_mode(); gateway_fail(); } } } void no_present() { _coreConfig.presentationSent = true; _coreConfig.nodeRegistered = true; } void happy_node_mode() { _transportSM.findingParentNode = false; _transportSM.transportActive = true; _transportSM.uplinkOk = true; _transportSM.pingActive = false; transportSwitchSM(stReady); _transportSM.failureCounter = 0; } void gateway_fail() { flag_nogateway_mode = 1; flag_update_transport_param = 0; SLEEP_TIME_W = SLEEP_TIME / 2; lis2-&gt;Disable_Wake_Up_Detection(); } void find_parent_process() { flag_update_transport_param = 1; flag_find_parent_process = 0; CORE_DEBUG(PSTR("</span></span>MyS: STANDART TRANSPORT MODE IS RESTORED\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; lis2-&gt;Enable_Wake_Up_Detection(); } void update_Happy_transport() { CORE_DEBUG(PSTR("</span></span>MyS: UPDATE TRANSPORT CONFIGURATION\n<span class="hljs-string"><span class="hljs-string">")); mypar = _transportConfig.parentNodeId; master_id = 0; // *************************** master slave mode is not initialized in this example, ..stub ******************************* if (mypar != loadState(101)) { saveState(101, mypar); } if (_transportConfig.distanceGW != loadState(102)) { saveState(102, _transportConfig.distanceGW); } present_only_parent(); wait(50); nosleep = 0; flag_update_transport_param = 0; } void present_only_parent() { if (old_mypar != mypar) { CORE_DEBUG(PSTR("</span></span>MyS: SEND LITTLE PRESENT:) WITH PARENT ID\n<span class="hljs-string"><span class="hljs-string">")); if (_sendRoute(build(_msgTmp, 0, NODE_SENSOR_ID, C_INTERNAL, 6).set(mypar))) { flag_sendRoute_parent = 0; old_mypar = mypar; } else { flag_sendRoute_parent = 1; } } } void check_parent() { _transportSM.findingParentNode = true; CORE_DEBUG(PSTR("</span></span>MyS: SEND FIND PARENT REQUEST, WAIT RESPONSE\n<span class="hljs-string"><span class="hljs-string">")); _sendRoute(build(_msg, 255, NODE_SENSOR_ID, C_INTERNAL, 7).set("</span></span><span class="hljs-string"><span class="hljs-string">")); wait(1500, C_INTERNAL, 8); if (_msg.sensor == 255) { if (mGetCommand(_msg) == 3) { if (_msg.type == 8) { Ack_FP = 1; CORE_DEBUG(PSTR("</span></span>MyS: PARENT RESPONSE FOUND\n<span class="hljs-string"><span class="hljs-string">")); } } } if (Ack_FP == 1) { CORE_DEBUG(PSTR("</span></span>MyS: FIND PARENT PROCESS\n<span class="hljs-string"><span class="hljs-string">")); Ack_FP = 0; transportSwitchSM(stParent); flag_nogateway_mode = 0; flag_find_parent_process = 1; SLEEP_TIME_W = SLEEP_TIME; problem_mode_count = 0; } else { _transportSM.findingParentNode = false; CORE_DEBUG(PSTR("</span></span>MyS: PARENT RESPONSE NOT FOUND\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; nosleep = 0; if (problem_mode_count &lt; 24) { CORE_DEBUG(PSTR("</span></span>PROBLEM MODE COUNTER: %d\n<span class="hljs-string"><span class="hljs-string">"), problem_mode_count); problem_mode_count++; SLEEP_TIME_W = SLEEP_TIME / 100 * 120; } else if (problem_mode_count == 24) { SLEEP_TIME_W = SLEEP_TIME * 30; CORE_DEBUG(PSTR("</span></span>PROBLEM MODE COUNTER: %d\n<span class="hljs-string"><span class="hljs-string">"), problem_mode_count); } } } void receive(const MyMessage &amp; message) { if (message.sensor == ENABLE_WPM_SENS_CHILD_ID) { if (message.type == V_VAR1) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } else { wpm_enable = message.getBool(); saveState(240, wpm_enable); wait(10); send(conf_wpmMsg.set(wpm_enable)); wait(50); blinky(3, 3, GREEN_LED); configMode = 0; nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } } if (message.sensor == LEVEL_SENSIV_V_SENS_CHILD_ID) { if (message.type == V_VAR1) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } else { conf_vibro_set = message.getByte(); vibro_Init(); saveState(230, conf_vibro_set); wait(10); send(conf_vsensMsg.set(conf_vibro_set)); wait(50); blinky(3, 3, GREEN_LED); configMode = 0; nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } } if (message.sensor == INTERVAL_R_LUX_CHILD_ID) { if (message.type == V_VAR1) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } else { interval_reading_lux = message.getByte(); SLEEP_TIME = SLEEP_TIME_TEMP * interval_reading_lux; C_BATT_TIME = BATT_TIME / SLEEP_TIME; saveState(220, interval_reading_lux); wait(10); send(conf_interv_rluxMsg.set(interval_reading_lux)); wait(50); blinky(3, 3, GREEN_LED); configMode = 0; nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } } if (message.sensor == LUX_SENS_CHILD_ID) { if (message.type == V_LEVEL) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } } } } if (message.sensor == V_SENS_CHILD_ID) { if (message.type == V_TRIPPED) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } } } } if (mGetCommand(message) == 0) { PRESENT_ACK = 1; CORE_DEBUG(PSTR("</span></span>MyS: !!!ACK OF THE PRESENTATION IN THE FUNCTION RECEIVE RECEIVED!!!\n<span class="hljs-string"><span class="hljs-string">")); } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projet github (biblioth√®ques suppl√©mentaires, sources de projet, sch√©mas, gerberas, nomenclature): </font></font><br> <a href="https://github.com/smartboxchannel/EFEKTA-LIS2DW12-MAX44009-E73C" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/smartboxchannel/EFEKTA-LIS2DW12-MAX44009-E73C </font></font></a> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caract√©ristiques du capteur:</font></font></b> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plage de tension de fonctionnement 2-3 V, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6,7 ŒºA en mode veille, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8mA en mode r√©seau, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E73-2G4M08S1C nRF52840, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Capteur de lumi√®re ambiante MAX44009, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acc√©l√©rom√®tre MEMS 3 axes LIS2DW12 \ LIS2DH12, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LED RGB </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisateur botton, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Port de programmation SWD + s√©rie. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ci-dessous est un exemple du fonctionnement du capteur dans le syst√®me Majordomo UD, il fonctionnera naturellement dans tout UD dans lequel le support du protocole MySensors est ajout√©, et c'est presque tout connu. </font></font><br><br><img src="https://habrastorage.org/webt/bm/xj/zj/bmxjzjfpzn0wuvccte-w5xqtn3e.png"><br><br><img src="https://habrastorage.org/webt/5t/9k/xr/5t9kxrdt4agswilm1yukte51m4g.jpeg"><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vid√©o avec l'int√©rieur de la carte, un exemple de capteur, un exemple de param√®tres</font></font></b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/I2ywIxp-RsE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Photo du capteur</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wc/xl/hk/wcxlhkb-zb-paorsmpqx4jwkg-4.jpeg"><br><br><img src="https://habrastorage.org/webt/mh/f-/ak/mhf-akawv5xgbnuijpdv0edgcoo.jpeg"><br><br><img src="https://habrastorage.org/webt/ie/1q/ig/ie1qign_51mb0ya5ysfiurmdgkm.jpeg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je vais probablement terminer l√†-dessus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un endroit o√π vous √™tes toujours heureux d'aider tous ceux qui veulent faire connaissance avec MYSENSORS (installer des cartes, travailler avec des microcontr√¥leurs nRF5 dans l'environnement Arduino IDE, des conseils pour travailler avec le protocole mysensors, discuter de projets - chat t√©l√©gramme </font></font><a href="https://tgclick.com/mysensors_rus" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@mysensors_rus</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bonne chance et bonne chance dans vos projets! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS / Partager avec des plans imm√©diats, bient√¥t un article sera publi√© sur une version mise √† jour </font></font><a href="https://habr.com/ru/post/452532/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mon capteur de temp√©rature et d'humidit√© avec un √©cran √† encre √©lectronique, enfin maintenant c'est un appareil fini et non un module, il y aura aussi un article sur un capteur ouvert / ferm√© avec un interrupteur √† lames, un acc√©l√©rom√®tre et un capteur </font><font style="vertical-align: inherit;">champ magn√©tique et encodeur sur nRF52811 Photos et vid√©o ci-dessous dans le spoiler.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/T66y83lF-xg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><img src="https://habrastorage.org/webt/rg/dh/u2/rgdhu2htxcazyavpoh5mgf71hfo.jpeg"><br><br><img src="https://habrastorage.org/webt/uz/mx/_n/uzmx_nvuyazh3nihtfjxgb_tkpi.jpeg"><br><br><img src="https://habrastorage.org/webt/xn/7s/a2/xn7sa2lbrn3g2jvje5mr1wbcuh8.jpeg"><br><br><img src="https://habrastorage.org/webt/4y/-s/la/4y-slajjmwr_ydmqdq0v2vcify4.jpeg"><br><br><img src="https://habrastorage.org/webt/90/ub/i7/90ubi72wfku6mlf7dshkfl2nqfo.jpeg"><br><br><img src="https://habrastorage.org/webt/p9/fe/9e/p9fe9ehr29jqggmkhutdipmqygu.jpeg"><br><br><img src="https://habrastorage.org/webt/sn/gm/ou/sngmou0381zr6ias3gbtsfez3lg.jpeg"><br><br><img src="https://habrastorage.org/webt/o5/t2/j-/o5t2j-gncldts6gsxg7kxl26dce.jpeg"><br><br><img src="https://habrastorage.org/webt/jt/vl/ro/jtvlrov-l3qclnkgilhu7aqpls4.jpeg"><br><br><img src="https://habrastorage.org/webt/be/3v/je/be3vjejo_xhuxhpc_hyg9fmz4ns.jpeg"><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr478960/">https://habr.com/ru/post/fr478960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr478950/index.html">Les r√©sultats de la semaine: Huawei s'adapte aux sanctions, Poutine signe des lois sensationnelles et en Russie, il bloque ShutterStock</a></li>
<li><a href="../fr478952/index.html">Un mois avec Onyx Boox Note Pro</a></li>
<li><a href="../fr478954/index.html">RE: Peur et d√©go√ªt en informatique</a></li>
<li><a href="../fr478956/index.html">Pr√©sentation de 3CX V16 Update 4 Beta avec un client VoIP Chrome et une application vid√©o pour Android</a></li>
<li><a href="../fr478958/index.html">Guide de mise √† niveau complet de Windows 10 pour les entreprises de toute taille</a></li>
<li><a href="../fr478962/index.html">Ilya Yakyamsev: l'efficacit√© ne fonctionne pas</a></li>
<li><a href="../fr478966/index.html">Comment survivre et devenir d√©veloppeur front-end dans le monde moderne?</a></li>
<li><a href="../fr478968/index.html">SpaceX lance Nanoracks pour cr√©er des stations orbitales de d√©bris spatiaux</a></li>
<li><a href="../fr478970/index.html">Bouton d'appel bricolage partie 2. Vid√©ophone de Raspberry Pi</a></li>
<li><a href="../fr478972/index.html">Gagnants du concours Miro Platform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>