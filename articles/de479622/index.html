<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèΩ‚Äçü§ù‚Äçüßëüèº üßïüèæ üëö So funktioniert der Prototyp anonymer Transaktionen in der Waves-Blockchain üì° üö∑ ‚ô®Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben einen Prototyp anonymer Transaktionen implementiert , der auf zkSNARK basiert, um vertrauliche Transaktionen in der Waves-Blockchain sicherz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So funktioniert der Prototyp anonymer Transaktionen in der Waves-Blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/479622/"><p><img src="https://habrastorage.org/getpro/habr/post_images/fe6/1b5/5b2/fe61b55b2ceafb966bd362ba1d87e5f2.jpg" alt="Bild"></p><br><p>  Wir haben einen <a href="https://github.com/wavesplatform/anonymous-transactions-prototype">Prototyp anonymer Transaktionen</a> implementiert <a href="https://github.com/wavesplatform/anonymous-transactions-prototype">,</a> der auf zkSNARK basiert, um vertrauliche Transaktionen in der Waves-Blockchain sicherzustellen.  In unserer Implementierung verwenden wir das Groth16-Evidenzsystem f√ºr die BN254-Kurve und DSL- <a href="https://github.com/iden3/circom">Circom</a> . <br>  Wir erkl√§ren, wie es funktioniert. </p><a name="habracut"></a><br><h2 id="zksnarks">  zkSNARKs </h2><br><p>  <em>zkSNARK</em> ist ein kryptografisches <em>Grundelement</em> , das die Kenntnis eines speziellen Datensatzes (Evidence) best√§tigt, der dem Satz der folgenden Gleichungen entspricht (Constraint-System): </p><br><pre><code class="plaintext hljs">‚ü®ai,w‚ü©‚ü®bi,w‚ü©+‚ü®ci,w‚ü©=0</code> </pre> <br><p>  Ein Teil der Beweise ist privat.  Mit dieser Konstruktion k√∂nnen wir beispielsweise die Kenntnis des Hash-Invers-Bildes nachweisen, ohne das Invers-Bild preiszugeben.  Sie kann auch im privaten Transaktionsmechanismus f√ºr das <em>UTXO-Modell</em> (Unspent Transaction (TX) Output) verwendet werden, bei dem nur UTXO-Hashes ver√∂ffentlicht werden und die G√ºltigkeit der Transaktion in zkSNARK nachgewiesen wird (Eigentumsnachweis, Nachweis des Speicherns des Betrags). <br>  zkSNARK ist eine nicht interaktive Technologie ohne Offenlegung, dh es handelt sich nicht um ein Protokoll der Interaktion zwischen Teilnehmern, das zum Nachweis von Wissen implementiert wird.  In der zkSNARK-Technologie erstellt der Pr√ºfer den Beweis und sendet ihn an den Pr√ºfer - es sind keine zus√§tzlichen Interaktionen erforderlich.  Der Pr√ºfer kann die Richtigkeit und Richtigkeit der Verwendung von Beweisdaten √ºberpr√ºfen, ohne auf zus√§tzliche Informationen zur√ºckgreifen zu m√ºssen.  Urspr√ºnglich wurden zkSNARKs als Protokoll f√ºr ‚Äûvertrauliches Rechnen‚Äú erstellt: Bei der Berechnung des Ergebnisses werden die an den Berechnungen beteiligten Daten nicht bekannt gegeben. <br>  Mit der zkSNARK-Technologie kann ein Schema zur Festschreibung implementiert werden: Der Pr√ºfer berechnet den Hash, gibt ihn dem Pr√ºfer und f√ºhrt einen speziellen Beweis durch, dass er das umgekehrte Bild des Hash x kennt.  Durch Einsetzen der Werte von x und Hash in die Formel und √úbergeben dieser Formel und des Beweises an den Pr√ºfer kann der Pr√ºfer sicherstellen, dass der Pr√ºfer x kennt.  Dies ist die Basis f√ºr anonyme Transaktionen: Wir kennen den privaten Schl√ºssel und eine bestimmte Eingabe (nicht ausgegebenes UTXO) mit einem bestimmten Betrag, den der Benutzer im Smart-Vertrag erstellt hat.  Ohne Offenlegung dieser Daten kann der Nutzer mit einem Smart-Vertrag best√§tigen, dass dies seine Eingabe ist, dass er dar√ºber verf√ºgen und sie jemandem zur Verwendung geben kann. <br>  Jetzt wird die Technologie nicht √ºberall verwendet, da der Proof f√ºr mehrere Minuten erstellt wird, was f√ºr den Benutzer nicht sehr praktisch ist. <br>  Weitere Informationen zur zkSNARK-Programmierung finden Sie in Vitalik Buterins Artikel <a href="https://medium.com/%40VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649">‚ÄûQuadratische Arithmetikprogramme: von Null bis Held‚Äú</a> und in <a href="https://medium.com/%40VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649">Iden3s Artikel</a> zum Entwurf von Circom-Schaltkreisen. </p><br><h2 id="akkauntnaya-model">  Kontomodell </h2><br><p>  F√ºr Transaktionen in Waves werden normalerweise Schl√ºssel und Adressen verwendet, die auf <code>curve25519</code> basieren.  Diese Kurve ist nicht zkSNARK-freundlich, daher verwenden wir f√ºr anonyme Transaktionen die Edwards-Untergruppe der verdrehten Kurven von <code>BabyJubJub</code> .  Au√üerdem verwenden wir √∂ffentliche Schl√ºssel als Adressen, da Sie beim Senden die Daten f√ºr den Empf√§nger verschl√ºsseln m√ºssen. </p><br><h2 id="utxo-model">  UTXO-Modell </h2><br><p>  In unserem Modell wird UTXO durch einen Satz von 3 Parametern dargestellt: Balance, √∂ffentlicher Schl√ºssel des Besitzers und eindeutiges Geheimnis.  Die Blockchain enth√§lt nur Hashes ohne zus√§tzliche Verschl√ºsselung.  Der Eigent√ºmer wird durch einen √∂ffentlichen Schl√ºssel dargestellt. Wie bereits erw√§hnt, verwenden wir √∂ffentliche Schl√ºssel nicht f√ºr die Kurve <code>curve25519</code> , sondern f√ºr die zkSNARK-freundliche <code>BabyJubJub</code> Kurve.  Die UTXO-ID sollte zuf√§llig generiert werden, da der Benutzer, wenn er zwei identische IDs angibt, UTXO nur f√ºr eine davon abholen (ausgeben) kann.  In diesem Fall wird nur UTXO mit der entsprechenden ID f√ºr den aktuellen Benutzer blockiert, nicht jedoch f√ºr den Rest.  Es liegt im Interesse des Benutzers, ID mithilfe eines Zufallszahlengenerators auszuw√§hlen (253 Bits werden ID zugewiesen, sodass es schwierig ist, eine Kollision zu erhalten). <br>  Um UTXO auszugeben, m√ºssen Sie einen Nullifier ver√∂ffentlichen, eine deterministische Funktion von UTXO, definiert als Hash (secret, owner_privkey).  Dieser Wert ist deterministisch und f√ºr jedes UTXO eindeutig, nur der Eigent√ºmer kennt ihn.  Abgesehen vom Eigent√ºmer kann niemand UTXO mit dem entsprechenden Nullifier verkn√ºpfen. <br>  UTXOs werden in der dApp-Hash-Map gespeichert, d. H. Im Vertragsstil.  In der Blockchain werden UTXOs verschl√ºsselt.  Um sein Geld zu erhalten, muss der Benutzer die Blockchain scannen und versuchen, jedes UTXO zu entschl√ºsseln. </p><br><h2>  Zustand dapp </h2><br><p>  Der dApp-Stil enth√§lt Hash-Maps, die zwei Gruppen darstellen: </p><br><ul><li>  Utxo-Hashes </li><li>  Nullifizierer </li></ul><br><p>  Auf diese Weise kann dApp die Existenz einer anonymen UTXO-Menge und die Eindeutigkeit von Nullen √ºberpr√ºfen.  Dies reicht aus, um anonyme √úberweisungen mit dem Schutz vor F√§lschung neuer Verm√∂genswerte und doppelten Ausgaben zu verarbeiten. <br>  DApp verf√ºgt √ºber drei Methoden, die den grundlegenden Arten von Transaktionen entsprechen: </p><br><ul><li>  Einzahlung </li><li>  √úbertragen </li><li>  Fazit </li></ul><br><p>  F√ºr die √úberweisung und Auszahlung von Geldern verwenden wir unsere eigenen Pr√ºfer, die die Interaktion von dApp mit speziellen anonymen Konten auf der Grundlage der BabyJubJub-Kurve sicherstellen.  Einzahlungen werden von regul√§ren Waves-Konten verarbeitet. </p><br><h2 id="komissii">  Provisionen </h2><br><p>  F√ºr die Auff√ºllung des Kontos wird eine Geb√ºhr vom <code>curve25519</code> Konto erhoben.  Bei √úberweisungen und Abhebungen wird die Provision vom anonymen Konto abgebucht.  Auf der dApp-Ebene sieht es so aus: <br>  dApp zahlt f√ºr die Transaktion selbst, dh das native Token, das f√ºr die Zahlung der Provision ausgegeben wird, wird von seinem Guthaben abgebucht <br>  Zwischen den Ein- und Ausg√§ngen wird ein Teil der Provision verbrannt, um die Verm√∂genswerte zu annullieren, die den tats√§chlichen Verm√∂genswerten des Smart-Vertrags entsprechen <br>  Auf UTXO-Ebene verbrennen wir bei der Abwicklung einer Transaktion einen bestimmten Betrag als Provision. </p><br><h2 id="tranzakcii">  Transaktionen </h2><br><p>  <strong>Eine Einzahlung</strong> ist ein einfacher Vorgang. Jede Einzahlung f√ºgt UTXO ein neues Element hinzu. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fc5/2f0/439/fc52f04398a60665021d26b4da4e4c8d.svg" alt="Bild"></p><br><p>  <strong>√úbertragungen</strong> basieren auf dem 2-zu-2-√úbersetzungsprimitiv. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/47d/55e/9d3/47d55e9d3446e135ef5595a71c2fc8e7.svg" alt="Bild"></p><br><p>  Einige Ein- und Ausg√§nge k√∂nnen Null sein.  Als Teilbeispiel einer solchen Konstruktion kann jede Art von einfacher √úbersetzung dargestellt werden (Join-, Split- und andere √úbertragungen mit Ausnahme von Atom-Swaps). </p><br><p>  <strong>Schlussfolgerungen</strong> funktionieren wie andere Transaktionen, nur dass der Benutzer anstelle eines zweiten UTXOs sein UTXO aus dApp entfernen kann.  Es k√∂nnen auch zwei UTXOs am ‚Äã‚ÄãEingang vorhanden sein, UTXOs am ‚Äã‚ÄãAusgang mit dem Rest der Geldmittel und Abhebungen, die in der Blockchain ver√∂ffentlicht sind. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8b3/f94/b3b/8b3f94b3b903188643b3139319587372.svg" alt="Bild"></p><br><p>  Beim Zur√ºckziehen oder √úbertragen √ºberpr√ºft dApp, ob die entsprechenden Nullifier noch nicht in seinem Stack gefunden wurden. <br>  Mit zkSNARK k√∂nnen wir berechnen, dass die Summe der Transaktionseingaben der Summe der Ausgaben entspricht.  Wenn wir eine Transaktion ausf√ºhren, geben wir sie f√ºr UTXO und eine andere Null-UTXO aus, die sich nicht im Merkle-Baum befindet.  Um UTXO ausgeben zu k√∂nnen, m√ºssen Sie den privaten Schl√ºssel seines Besitzers nachweisen.  √úberpr√ºfen Sie, ob der private Schl√ºssel bei Multiplikation mit dem Gruppengenerator einen √∂ffentlichen Schl√ºssel ergibt.  Ohne Kenntnis des privaten Schl√ºssels kann daher eine Transaktion nicht abgeschlossen werden. </p><br><h2 id="anonimnoe-mnozhestvo">  Anonymes Set </h2><br><p>  Wir verwenden eine anonyme Menge von 8 Elementen.  Das Zielelement wird privat aus der Menge ausgew√§hlt, die in der √∂ffentlichen zkSNARK-Eingabe dargestellt ist.  Mit dieser Methode k√∂nnen Sie das Transaktionsdiagramm verschleiern (wenn es m√∂glich ist, das UTXO-Interaktionsdiagramm wiederherzustellen, besteht die M√∂glichkeit, Transaktionen zu dekanonymisieren). <br>  Ferner kann ein einfacher Sammler von 8 Elementen durch einen Sammler von Merkle-B√§umen ersetzt werden.  Der Ansatz verbirgt das Transaktionsdiagramm. <br>  Um eine g√ºltige Transaktion zu erstellen, beweisen wir, dass wir etwas UTXO aus der Menge von UTXO ausgeben.  Wir setzen zkSNARK-Merkle-Proofs und UTXO-Daten in private Eingaben und Root-Hash in den √∂ffentlichen Eingang.  Mit SNARK beweisen wir also, dass wir UTXO kennen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b7c/92a/4a3/b7c92a4a3e158862d0fdb32e810cc98d.svg" alt="Bild"></p><br><h2 id="zaschita-ot-dvoynogo-rashodovaniya">  Doppelter Ausgabenschutz </h2><br><p>  Zum Schutz vor doppelten Ausgaben verwenden wir Nullifier - deterministische Funktionen, die nicht direkt vom UTXO-Hash abh√§ngen.  Um den Nullifier zu berechnen, nehmen wir die Funktion vom privaten Schl√ºssel, es wird nachgewiesen, dass sie dem √∂ffentlichen Schl√ºssel, der ID und dem UTXO-Hash entspricht.  F√ºr jede UTXO gibt es nur einen Nuller. </p><br><p>  F√ºr jede Transaktion sollte der Nuller der ausgegebenen UTXO-Ausgaben als √∂ffentlicher Eintrag f√ºr zkSNARK dargestellt werden.  Innerhalb der zkSNARK-Schaltung muss au√üerdem best√§tigt werden, dass sie zu verbrauchtem UTXO geh√∂rt. </p><br><p>  Wenn der dApp-Vertrag einen nicht eindeutigen Nullwert erh√§lt, wird die Transaktion abgelehnt.  Somit ist garantiert, dass jede UTXO einmal ausgegeben wird. </p><br><p>  Nachdem sie UTXO ausgegeben haben, wird der Nullifier in der Liste der ausgegebenen Nullifier im dApp-Artikel ver√∂ffentlicht.  Das hei√üt, in der Hash-Map gegen√ºber diesem Nullifier wird "true" gesetzt.  Bevor wir den Nullifier im Artikel ver√∂ffentlichen, pr√ºfen wir, ob dieser Nullifier noch nicht verwendet wurde, was bedeutet, dass UTXO mit dieser ID ausgegeben werden kann. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479622/">https://habr.com/ru/post/de479622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479598/index.html">Katze und Hund f√ºttern den Roboter</a></li>
<li><a href="../de479600/index.html">Ein weiteres DSL zur Validierung</a></li>
<li><a href="../de479602/index.html">Was ist das vollst√§ndige Genom und warum wird es ben√∂tigt?</a></li>
<li><a href="../de479618/index.html">Postgres Pro Standard 12.1 ver√∂ffentlicht</a></li>
<li><a href="../de479620/index.html">Umgekehrte Logik</a></li>
<li><a href="../de479624/index.html">Postgres-Profi-Gendar Oleg Bartunov informiert Faride Roslovets √ºber PostgreSQL und das Gesch√§ft in Russland</a></li>
<li><a href="../de479626/index.html">Resonator mit einer Wendung, die Physiker nicht kennen</a></li>
<li><a href="../de479630/index.html">K√§mpfe um Aufmerksamkeit</a></li>
<li><a href="../de479636/index.html">Eigener Navigationsstack. Besser als ROS?</a></li>
<li><a href="../de479642/index.html">Wie dumme Entscheidungen beim Entwerfen eines Flugzeugs aus dem Zweiten Weltkrieg zur Schaffung des Macintosh f√ºhrten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>