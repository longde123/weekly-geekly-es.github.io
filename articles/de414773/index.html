<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôçüèª üåá üò¥ ActionViews oder wie ich Boilerplate seit meiner Kindheit nicht mehr mag üßõüèΩ üêß üßò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! In diesem Artikel m√∂chte ich die Erfahrung beim Erstellen eines eigenen Mechanismus zur Automatisierung der Anzeige verschiedener Ansichts...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ActionViews oder wie ich Boilerplate seit meiner Kindheit nicht mehr mag</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/414773/"><p>  Hallo Habr!  In diesem Artikel m√∂chte ich die Erfahrung beim Erstellen eines eigenen Mechanismus zur Automatisierung der Anzeige verschiedener Ansichtstypen teilen: ContentView, LoadingView, NoInternetView, EmptyContentView, ErrorView. </p><br><img src="https://habrastorage.org/webt/ir/qr/we/irqrwe-ha4rx0zfqirxm1vhtlem.jpeg"><a name="habracut"></a><br><hr><br><p>  Es war ein langer Weg.  Der Weg des Versuchs und Irrtums, die Aufz√§hlung von Methoden und Optionen, schlaflose N√§chte und unsch√§tzbare Erfahrungen, die ich teilen und Kritik h√∂ren m√∂chte, die ich auf jeden Fall ber√ºcksichtigen werde. </p><br><p>  Ich werde sofort sagen, dass ich √ºberlegen werde, an RxJava zu arbeiten, da ich bei Coroutinen keinen solchen Mechanismus angewendet habe - meine H√§nde haben nicht erreicht.  Und f√ºr andere √§hnliche Tools (Loader, AsyncTask usw.) macht es keinen Sinn, meinen Mechanismus zu verwenden, da meistens RxJava oder Coroutinen verwendet werden. </p><br><h3 id="actionviews">  Aktionsansichten </h3><br><p>  Ein Kollege von mir sagte, es sei unm√∂glich, das Verhalten von View zu standardisieren, aber ich habe es trotzdem versucht.  Und hat es getan. </p><br><p>  Der Standardanwendungsbildschirm, dessen Daten vom Server √ºbernommen werden, sollte mindestens 5 Zust√§nde verarbeiten: </p><br><ul><li>  Datenanzeige </li><li>  Laden </li><li>  Fehler - Jeder Fehler, der unten nicht beschrieben wird </li><li>  Der Mangel an Internet ist ein globaler Fehler </li><li>  Leerer Bildschirm - Anfrage bestanden, aber keine Daten </li><li><del>  Ein anderer Zustand ist, dass die Daten aus dem Cache geladen wurden, die Aktualisierungsanforderung jedoch mit einem Fehler zur√ºckgegeben wurde, dh veraltete Daten anzeigt (besser als nichts). </del>  - Die Bibliothek unterst√ºtzt dies nicht. </li></ul><br><p>  Dementsprechend sollte es f√ºr jeden solchen Zustand eine eigene Ansicht geben. </p><br><p>  Ich nenne diese View - <strong>ActionViews</strong> , weil sie auf eine Aktion reagieren.  Wenn Sie genau festlegen k√∂nnen, an welcher Stelle Ihre Ansicht angezeigt werden soll und wann sie ausgeblendet werden soll, kann es sich auch um eine ActionView handeln. </p><br><p> Es gibt eine (oder vielleicht auch keine) Standardmethode, um mit einer solchen Ansicht zu arbeiten. </p><br><p>  In Methoden, die Arbeit mit RxJava enthalten, m√ºssen Sie Eingabeargumente f√ºr alle Arten von ActionViews hinzuf√ºgen und diesen Aufrufen eine Logik hinzuf√ºgen, um ActionViews anzuzeigen und auszublenden, wie hier beschrieben: </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSomeData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LoadingView loadingView, ErrorView errorView, NoInternetView noInternetView, EmptyContentView emptyContentView)</span></span></span><span class="hljs-function"> </span></span>{ mApi.getProjects() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnSubscribe(disposable -&gt; { loadingView.show(); noInternetView.hide(); emptyContentView.hide(); }) .doFinally(loadingView::hide) .flatMap(projectResponse -&gt; { <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> }) .subscribe( response -&gt; {<span class="hljs-comment"><span class="hljs-comment">/*   */</span></span>}, throwable -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ApiUtils.NETWORK_EXCEPTIONS .contains(throwable.getClass())) noInternetView.show(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> errorView.show(throwable.getMessage()); } ); }</code> </pre> <br><p>  Diese Methode enth√§lt jedoch eine <strong>gro√üe</strong> Menge an Boilerplate, und standardm√§√üig gef√§llt sie uns nicht.  Und so fing ich an, den Routinecode zu reduzieren. </p><br><h3 id="level-up">  Level auf </h3><br><p>  Der erste Schritt bei der Aktualisierung der Standardmethode f√ºr die Arbeit mit ActionViews bestand darin, die Boilerplate zu reduzieren, indem Logik in Dienstprogrammklassen eingef√ºgt wurde.  Der folgende Code wurde nicht von mir erfunden.  Ich bin ein Plagiat und habe einen vern√ºnftigen Kollegen ausspioniert.  Danke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Arutar</a> </p><br><p>  Jetzt sieht unser Code so aus: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSomeData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LoadingView loadingView, ErrorView errorView, NoInternetView noInternetView, EmptyContentView emptyContentView)</span></span></span><span class="hljs-function"> </span></span>{ mApi.getProjects() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .compose(RxUtil::loading(loadingView)) .compose(RxUtil::emptyContent(emptyContentView)) .compose(RxUtil::noInternet(errorView, noInternetView)) .subscribe(response -&gt; { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> }, RxUtil::error(errorView)); }</code> </pre> <br><p>  Der Code, den wir oben sehen, ist zwar ohne Boilerplate-Code, verursacht aber immer noch keine so bezaubernde Freude.  Es ist bereits viel besser geworden, aber es bleibt das Problem, Links zu ActionViews in jeder Methode zu √ºbergeben, in der mit Rx gearbeitet wird.  Und es kann unendlich viele solcher Methoden in einem Projekt geben.  Schreiben Sie auch diese komponieren st√§ndig.  Buueee.  Wer braucht das?  Nur flei√üige, st√∂rrische und nicht faule Leute.  Ich bin nicht so  Ich bin ein Fan von Faulheit und ein Fan von sch√∂nem und praktischem Code, daher wurde eine wichtige Entscheidung getroffen - den Code mit allen Mitteln zu vereinfachen. </p><br><h3 id="tochka-proryva">  Durchbruchspunkt </h3><br><p>  Nach zahlreichen √Ñnderungen des Mechanismus kam ich zu folgender Option: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSomeData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ execute(() -&gt; mApi.getProjects(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseSubscriber&lt;&gt;(response -&gt; { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> })); }</code> </pre> <br><p>  Ich habe meinen Mechanismus ungef√§hr 10-15 Mal umgeschrieben und jedes Mal war er ganz anders als die vorherige Version.  Ich werde Ihnen nicht alle Versionen zeigen, konzentrieren wir uns auf die beiden letzten.  Das erste was du gerade gesehen hast. </p><br><p>  Stimmen Sie zu, es sieht h√ºbsch aus?  Ich w√ºrde sogar sehr h√ºbsch sagen.  Ich habe mich um solche Entscheidungen bem√ºht.  Und absolut alle unsere ActionViews funktionieren zum gew√ºnschten Zeitpunkt korrekt.  Ich konnte dies erreichen, indem ich eine gro√üe Menge nicht des sch√∂nsten Codes schrieb.  Klassen, die einen solchen Mechanismus erlauben, enthalten eine Menge komplexer Logik, und ich mochte es nicht.  Mit einem Wort - S√º√üe, die ein Monster unter der Haube ist. </p><br><img src="https://habrastorage.org/webt/4z/eu/kd/4zeukd8fsc87mpezaq5buigjvvs.jpeg"><br><hr><br><p>  Ein solcher Code wird in Zukunft immer schwieriger zu warten sein und selbst schwerwiegende Nachteile und Probleme enthalten, die kritisch waren: </p><br><ul><li>  Was passiert, wenn Sie mehrere LoadingViews auf dem Bildschirm anzeigen m√ºssen?  Wie trenne ich sie?  Wie kann man verstehen, welche LoadingView wann angezeigt werden soll? </li><li>  Verletzung des Rx-Konzepts - alles sollte in einem Stream (Stream) sein.  Dies ist hier nicht der Fall. </li><li>  Die Komplexit√§t der Anpassung.  Das beschriebene Verhalten und die beschriebene Logik sind f√ºr den Endbenutzer sehr schwer zu √§ndern, und dementsprechend ist es schwierig, neue Verhaltensweisen hinzuzuf√ºgen. </li><li>  Sie m√ºssen die benutzerdefinierte Ansicht verwenden, damit der Mechanismus funktioniert.  Dies ist erforderlich, damit der Mechanismus versteht, welche ActionView zu welchem ‚Äã‚ÄãTyp geh√∂rt.  Wenn Sie beispielsweise die ProgressBar verwenden m√∂chten, muss sie Implementierungen von LoadingView enthalten. </li><li>  Die ID f√ºr unser ActionView muss mit den in den Basisklassen angegebenen √ºbereinstimmen, um die Boilerplate zu entfernen.  Dies ist nicht sehr praktisch, obwohl Sie sich damit abfinden k√∂nnen. </li><li>  Reflexion  Ja, sie war hier und wegen ihr musste der Mechanismus eindeutig optimiert werden. </li></ul><br><p>  Nat√ºrlich hatte ich L√∂sungen f√ºr diese Probleme, aber all diese L√∂sungen f√ºhrten zu anderen Problemen.  Ich habe versucht, das Kritischste so weit wie m√∂glich loszuwerden, und infolgedessen blieben nur die notwendigen Anforderungen f√ºr die Nutzung der Bibliothek √ºbrig. </p><br><h3 id="do-svidaniya-java">  Auf Wiedersehen Java! </h3><br><p>  Nach einiger Zeit sa√ü ich zu Hause, <del>  versuchte es </del>  Ich habe herumgespielt und pl√∂tzlich wurde mir klar, dass ich Kotlin ausprobieren und Erweiterungen, Standardwerte, Lambdas und Delegaten maximieren musste. </p><br><p>  Zuerst sah er nicht sehr aus.  Aber jetzt werden ihm fast alle M√§ngel vorenthalten, die im Prinzip sein k√∂nnen. </p><br><p>  Hier ist unser vorheriger Code, aber in der endg√ºltigen Version: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSomeData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { api.getProjects() .withActionViews(view) .execute(onComplete = { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> }) }</code> </pre> <br><p>  Dank Extensions konnte ich die gesamte Arbeit in einem Thread erledigen, ohne das Grundkonzept der reaktiven Programmierung zu verletzen.  Ich habe auch die M√∂glichkeit gelassen, das Verhalten anzupassen.  Wenn Sie die Aktion zu Beginn oder am Ende der Show √§ndern m√∂chten, k√∂nnen Sie die Funktion einfach an die Methode √ºbergeben und alles funktioniert: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSomeData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { api.getProjects() .withActionViews( view, doOnLoadStart = { <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> }, doOnLoadEnd = { <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> }) .execute(onComplete = { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> }) }</code> </pre> <br><p>  Verhaltens√§nderungen sind auch f√ºr andere ActionViews verf√ºgbar.  Wenn Sie das Standardverhalten verwenden m√∂chten, aber keine Standard-ActionViews haben, k√∂nnen Sie einfach angeben, welche View unsere ActionView ersetzen soll: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSomeData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(projectLoadingView: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">LoadingView</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { mApi.getPosts(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) .withActionViews( view, loadingView = projectLoadingView ) .execute(onComplete = { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> }) }</code> </pre> <br><p>  Ich habe Ihnen die Creme dieses Mechanismus gezeigt, aber er hat auch seinen eigenen Preis. <br>  Zun√§chst m√ºssen Sie benutzerdefinierte Ansichten erstellen, damit dies funktioniert: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SwipeRefreshLayout</span></span></span><span class="hljs-class"> : android.support.v4.widget.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SwipeRefreshLayout</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LoadingView</span></span></span><span class="hljs-class"> { constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Context</span></span></span><span class="hljs-class">) : super(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">) constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Context</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attrs</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AttributeSet</span></span></span><span class="hljs-class">) : super(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attrs</span></span></span><span class="hljs-class">) }</span></span></code> </pre> <br><p>  M√∂glicherweise ist dies nicht einmal erforderlich.  Im Moment sammle ich Feedback und akzeptiere Vorschl√§ge zur Verbesserung dieses Mechanismus.  Der Hauptgrund f√ºr die Verwendung von CustomViews besteht darin, von einer Schnittstelle zu erben, die angibt, zu welcher Art von ActionView sie geh√∂rt.  Dies dient der Sicherheit, da Sie m√∂glicherweise versehentlich einen Fehler machen, wenn Sie den Ansichtstyp in der withActionsViews-Methode angeben. </p><br><p>  So sieht die withActionsViews-Methode aus: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Observable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withActionViews</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ActionsView</span></span></span></span><span class="hljs-function"><span class="hljs-params">, contentView: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = view.contentActionView, loadingView: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">LoadingView</span></span></span></span><span class="hljs-function"><span class="hljs-params">? = view.loadingActionView, noInternetView: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">NoInternetView</span></span></span></span><span class="hljs-function"><span class="hljs-params">? = view.noInternetActionView, emptyContentView: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EmptyContentView</span></span></span></span><span class="hljs-function"><span class="hljs-params">? = view.emptyContentActionView, errorView: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ErrorView</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = view.errorActionView, doOnLoadStart: ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = { doOnLoadSubscribe(contentView, loadingView) }, doOnLoadEnd: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = { doOnLoadComplete(contentView, loadingView) }, doOnStartNoInternet: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = { doOnNoInternetSubscribe(contentView, noInternetView) }, doOnNoInternet: (Throwable) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = { doOnNoInternet(contentView, errorView, noInternetView) }, doOnStartEmptyContent: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = { doOnEmptyContentSubscribe(contentView, emptyContentView) }, doOnEmptyContent: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = { doOnEmptyContent(contentView, errorView, emptyContentView) }, doOnError: (Throwable) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = { doOnError(errorView, it) } ) { <span class="hljs-comment"><span class="hljs-comment">/**/</span></span> }</code> </pre> <br><p>  Es sieht be√§ngstigend aus, aber bequem und schnell!  Wie Sie sehen k√∂nnen, akzeptiert es in den Eingabeparametern loadView: LoadingView? .. Dies versichert uns gegen Fehler mit dem ActionView-Typ. </p><br><p>  Dementsprechend m√ºssen Sie einige einfache Schritte ausf√ºhren, damit der Mechanismus funktioniert: </p><br><ul><li>  F√ºgen Sie unserem Layout unsere benutzerdefinierten ActionViews hinzu.  Ich habe bereits einige davon gemacht, und Sie k√∂nnen sie einfach verwenden. </li><li>  Implementieren Sie die HasActionsView-Schnittstelle und √ºberschreiben Sie die Standardvariablen, die f√ºr ActionViews im Code verantwortlich sind: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentActionView: View <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> mutableLazy { recyclerView } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loadingActionView: LoadingView? <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> mutableLazy { swipeRefreshLayout } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> noInternetActionView: NoInternetView? <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> mutableLazy { noInternetView } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> emptyContentActionView: EmptyContentView? <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> mutableLazy { emptyContentView } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> errorActionView: ErrorView <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> mutableLazy { ToastView(baseActivity) }</code> </pre> </li><li><p>  Oder erben Sie von einer Klasse, in der unsere ActionViews bereits √ºberschrieben wurden.  In diesem Fall m√ºssen Sie die genau angegebene ID in Ihrem Layout verwenden: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActionsFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>(), HasActionsView { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentActionView: View <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> mutableLazy { findViewById&lt;View&gt;(R.id.contentView) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loadingActionView: LoadingView? <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> mutableLazy { findViewByIdNullable&lt;View&gt;(R.id.loadingView) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> LoadingView? } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> noInternetActionView: NoInternetView? <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> mutableLazy { findViewByIdNullable&lt;View&gt;(R.id.noInternetView) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> NoInternetView? } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> emptyContentActionView: EmptyContentView? <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> mutableLazy { findViewByIdNullable&lt;View&gt;(R.id.emptyContentView) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> EmptyContentView? } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> errorActionView: ErrorView <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> mutableLazy { ToastView(baseActivity) } }</code> </pre> <br></li><li>  Genie√üen Sie die Arbeit ohne Heizplatte! </li></ul><br><p>  Wenn Sie Kotlin-Erweiterungen verwenden, vergessen Sie nicht, dass Sie den Import in einen f√ºr Sie geeigneten Namen umbenennen k√∂nnen: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">kotlinx</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.android</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.synthetic</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fr_gifts</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.contentView</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">as</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">recyclerView</span></span></code> </pre> <br><h3 id="chto-dalshe">  Was weiter? </h3><br><p>  Als ich anfing, an diesem Mechanismus zu arbeiten, dachte ich nicht dar√ºber nach, woraus eine Bibliothek entstehen w√ºrde.  Aber so kam es, dass ich meine Kreation teilen wollte, und jetzt wartet das S√º√üeste auf mich - die Bibliothek ver√∂ffentlichen, Probleme sammeln, Feedback erhalten, Funktionen hinzuf√ºgen / verbessern und Fehler beheben. </p><br><h3 id="poka-ya-pisal-statyu">  W√§hrend ich einen Artikel schrieb ... </h3><br><p>  Ich habe es geschafft, alles in Form von Bibliotheken zu ordnen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ActionViews-ViewModel</a> - f√ºr MVVM </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ActionViews-MVP</a> - f√ºr MVP </li></ul><br><p>  Die Bibliothek und der Mechanismus selbst erheben keinen Anspruch darauf, ein Muss in Ihrem Projekt zu sein.  Ich wollte nur meine Idee teilen, Kritik und Kommentare anh√∂ren und meinen Mechanismus verbessern, damit er bequemer, gebrauchter und praktischer wird.  Vielleicht k√∂nnen Sie einen solchen Mechanismus besser machen als ich.  Ich werde nur froh sein.  Ich hoffe aufrichtig, dass mein Artikel Sie dazu inspiriert hat, etwas Eigenes zu kreieren, vielleicht sogar √§hnliches und pr√§gnanteres. </p><br><p>  Wenn Sie Vorschl√§ge und Empfehlungen zur Verbesserung der Funktionalit√§t und Funktionsweise des Mechanismus selbst haben, h√∂re ich ihnen gerne zu.  Willkommen zu den Kommentaren und f√ºr alle F√§lle zu meinem Telegramm: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@tanchuev</a> </p><br><p>  <strong>PS</strong> Ich habe mich sehr dar√ºber gefreut, dass ich mit meinen eigenen H√§nden etwas N√ºtzliches geschaffen habe.  Vielleicht sind ActionViews nicht gefragt, aber Erfahrung und Begeisterung daf√ºr werden nirgendwo hingehen. </p><br><p>  <strong>PPS</strong> Damit ActionViews zu einer vollwertigen gebrauchten Bibliothek wird, m√ºssen Sie Feedback sammeln und m√∂glicherweise die Funktionalit√§t verfeinern oder den Ansatz selbst grundlegend √§ndern, wenn alles wirklich schlecht l√§uft. </p><br><p>  <strong>PPPS</strong> Wenn Sie an meiner Arbeit interessiert sind, k√∂nnen wir sie am 28. September in Moskau auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MBLT DEV 2018</a> International Mobile Developers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Conference</a> pers√∂nlich diskutieren.  Fr√ºhbuchertickets gehen √ºbrigens schon aus! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414773/">https://habr.com/ru/post/de414773/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414761/index.html">5 kreative Nachrichtenseiten in Englisch</a></li>
<li><a href="../de414763/index.html">Vier Arten von Produktmanagerfehlern, die vermieden werden k√∂nnen (und sollten)</a></li>
<li><a href="../de414767/index.html">Implementieren Sie IdM. Wen soll ich gehen, um Probleme zu l√∂sen?</a></li>
<li><a href="../de414769/index.html">Starten Sie das mobile Retargeting mit Appsflyer: Einstellungen, Berichte und Links</a></li>
<li><a href="../de414771/index.html">DevOps on HightLoad ++ Siberia: Mythen entlarven und Tools diskutieren</a></li>
<li><a href="../de414775/index.html">Anatomie der Huawei FusionServer RUVDS-Hosting-Plattform</a></li>
<li><a href="../de414777/index.html">Der Einstieg in die Top-Spotify-Wiedergabelisten bringt Songwritern Zehntausende von US-Dollar</a></li>
<li><a href="../de414779/index.html">Vertex Impress Nero Test: Metall + 18: 9 Bildschirm + 3300 mAh Akku f√ºr 6.990 Rubel</a></li>
<li><a href="../de414785/index.html">Datenvisualisierung mit Angular und D3</a></li>
<li><a href="../de414787/index.html">Das neue Android RAT verwendet das Telegrammprotokoll</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>