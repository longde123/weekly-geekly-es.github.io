<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💨 📦 🗡️ Optimalisasi program untuk Pengumpul Sampah 👨🏻‍⚖️ 💎 🦑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Belum lama ini, sebuah artikel bagus muncul di Habré Optimasi pengumpulan sampah di layanan .NET yang sangat dimuat . Artikel ini sangat menarik karen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimalisasi program untuk Pengumpul Sampah</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/453082/"><p>  Belum lama ini, sebuah artikel bagus muncul di Habré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Optimasi pengumpulan sampah di layanan .NET yang sangat dimuat</a> .  Artikel ini sangat menarik karena penulis, yang dipersenjatai dengan teori, melakukan hal yang mustahil sebelumnya: mereka mengoptimalkan aplikasi mereka menggunakan pengetahuan tentang GC.  Dan jika sebelumnya kita tidak tahu bagaimana GC ini bekerja, sekarang ini disajikan kepada kita di piring perak melalui upaya Konrad Cocos dalam bukunya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pro .NET Memory Management</a> .  Kesimpulan apa yang telah saya buat untuk diri saya sendiri?  Mari kita membuat daftar bidang masalah dan memikirkan cara mengatasinya. </p><br><p>  Pada lokakarya CLRium # 5 baru-baru ini: Pengumpul Sampah, kami berbicara tentang GC sepanjang hari.  Namun, saya memutuskan untuk menerbitkan satu laporan dengan decoding teks.  Ini adalah pembicaraan tentang kesimpulan tentang pengoptimalan aplikasi. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/EduXgLWAhm8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h1 id="snizhayte-krosspokolencheskuyu-svyaznost">  Kurangi Konektivitas Lintas Generasi </h1><br><h3 id="problema">  Masalah </h3><br><p>  Untuk mengoptimalkan kecepatan pengumpulan sampah, GC mengumpulkan generasi muda jika memungkinkan.  Tetapi untuk melakukan ini, ia juga membutuhkan informasi tentang tautan dari generasi yang lebih tua (mereka dalam hal ini bertindak sebagai root tambahan): dari tabel kartu. </p><br><p>  Pada saat yang sama, satu tautan dari generasi yang lebih tua ke generasi yang lebih muda memaksa Anda untuk menutupi area tersebut dengan tabel kartu: </p><br><ul><li>  4 byte tumpang tindih 4 kb atau maks.  320 objek - untuk arsitektur x86 </li><li>  8 byte tumpang tindih 8 kb atau maks.  320 objek - untuk arsitektur x64 </li></ul><br><p>  Yaitu  GC, memeriksa tabel kartu, memenuhi nilai bukan nol di dalamnya, dipaksa untuk memeriksa maksimal 320 objek untuk keberadaan tautan keluar dalam generasi kami. </p><br><p>  Karenanya, tautan yang jarang di generasi muda akan membuat GC lebih memakan waktu </p><br><h3 id="reshenie">  Solusi </h3><br><ul><li>  Temukan objek dengan koneksi di generasi muda - di dekatnya; </li><li>  Jika lalu lintas objek generasi nol seharusnya, gunakan menarik.  Yaitu  membuat kumpulan objek (tidak akan ada yang baru: tidak akan ada objek generasi nol).  Dan selanjutnya, dengan "menghangatkan" kolam dengan dua GC berturut-turut sehingga isinya dijamin gagal pada generasi kedua, Anda karenanya menghindari tautan ke generasi yang lebih muda dan memiliki nol di tabel kartu; </li><li>  Hindari tautan ke generasi muda; </li></ul><br><h1 id="ne-dopuskayte-silnoy-svyaznosti">  Hindari Konektivitas Yang Kuat </h1><br><h3 id="problema-1">  Masalah </h3><br><p>  Sebagai berikut dari algoritma fase kompresi objek dalam SOH: </p><br><ul><li>  Untuk mengompres tumpukan, Anda harus berkeliling pohon dan memeriksa semua tautan, mengoreksi mereka untuk nilai-nilai baru </li><li>  Selain itu, tautan dari tabel kartu memengaruhi seluruh kelompok objek </li></ul><br><p>  Oleh karena itu, konektivitas objek yang kuat secara umum dapat menyebabkan subsidensi selama GC. </p><br><h3 id="reshenie-1">  Solusi </h3><br><ul><li>  Memiliki objek yang terhubung sangat dekat, dalam satu generasi </li><li>  Hindari tautan yang tidak perlu secara umum (misalnya, alih-alih menduplikasi tautan pegangan ini-&gt;, gunakan pegangan yang sudah ada ini-&gt; Layanan-&gt;) </li><li>  Hindari kode dengan konektivitas tersembunyi.  Misalnya, penutupan </li></ul><br><h1 id="monitorte-ispolzovanie-segmentov">  Pantau penggunaan segmen </h1><br><h3 id="problema-2">  Masalah </h3><br><p>  Selama pekerjaan intensif, suatu situasi mungkin muncul ketika alokasi objek baru menyebabkan penundaan: alokasi segmen baru di bawah tumpukan dan selanjutnya mereka menonaktifkan ketika membersihkan sampah </p><br><h3 id="reshenie-2">  Solusi </h3><br><ul><li>  Menggunakan PerfMon / Sysinternal Utilities untuk mengontrol titik pemilihan segmen baru dan pelepasan dan pelepasannya </li><li>  Jika kita berbicara tentang LOH, yang merupakan lalu lintas buffer padat, gunakan ArrayPool </li><li>  Jika kita berbicara tentang SOH, pastikan bahwa objek-objek dengan umur yang sama disorot di dekatnya, memberikan Sweep daripada Collect </li><li>  SOH: gunakan kolam objek </li></ul><br><h1 id="ne-vydelyayte-pamyat-v-nagruzhennyh-uchastkah-koda">  Jangan mengalokasikan memori di bagian kode yang dimuat </h1><br><h3 id="problema-3">  Masalah </h3><br><p>  Bagian kode yang dimuat mengalokasikan memori: </p><br><ul><li>  Akibatnya, GC memilih jendela alokasi bukan dari 1Kb, tetapi 8Kb. </li><li>  Jika jendela kehabisan ruang, ini mengarah ke GC dan perluasan zona tertutup </li><li>  Aliran benda baru yang padat akan membuat benda berumur pendek dari utas lainnya dengan cepat pergi ke generasi yang lebih tua dengan kondisi pengumpulan sampah yang lebih buruk </li><li>  Yang akan menambah waktu pengumpulan sampah </li><li>  Yang akan menyebabkan Stop Dunia lebih lama bahkan dalam mode Bersamaan </li></ul><br><h3 id="reshenie-3">  Solusi </h3><br><ul><li>  Larangan lengkap tentang penggunaan penutupan di bagian kode kritis </li><li>  Larangan tinju sepenuhnya pada bagian-bagian penting dari kode (Anda dapat menggunakan emulasi dengan menarik jika perlu) </li><li>  Di mana perlu untuk membuat objek sementara untuk penyimpanan data, gunakan struktur.  Lebih baik ref struct.  Ketika jumlah bidang lebih dari 2, kirimkan dengan ref </li></ul><br><h1 id="izbegayte-izlishnih-vydeleniy-pamyati-v-loh">  Hindari alokasi memori yang tidak perlu di LOH </h1><br><h3 id="problema-4">  Masalah </h3><br><p>  Menempatkan array di LOH mengarah ke fragmentasi atau pembobotan prosedur GC </p><br><h3 id="reshenie-4">  Solusi </h3><br><ul><li>  Gunakan pembagian array menjadi sub-array dan kelas yang merangkum logika bekerja dengan array seperti itu (yaitu, bukan Daftar &lt;T&gt;, di mana mega-array disimpan, MyList dengan array [] [], membagi array sedikit lebih pendek) <br><ul><li>  Array akan menuju ke SOH </li><li>  Setelah beberapa pengumpulan sampah, mereka akan berbaring di sebelah benda yang selalu hidup dan berhenti mempengaruhi pengumpulan sampah </li></ul></li><li>  Kontrol penggunaan array ganda dengan panjang lebih dari 1000 elemen. </li></ul><br><h1 id="gde-opravdano-i-vozmozhno-ispolzovat-thread-stack">  Jika dibenarkan dan memungkinkan, gunakan tumpukan ulir </h1><br><h3 id="problema-5">  Masalah </h3><br><p>  Ada sejumlah objek ultrashort atau objek yang hidup dalam panggilan metode (termasuk panggilan internal).  Mereka menciptakan lalu lintas objek </p><br><h3 id="reshenie-5">  Solusi </h3><br><ul><li>  Gunakan alokasi memori pada tumpukan jika memungkinkan: <br><ul><li>  Itu tidak memuat banyak </li><li>  Tidak memuat GC </li><li>  Melepaskan Memori - Instan </li></ul></li><li> Gunakan <code>Span T x = stackalloc T[];</code>  bukannya <code>new T[]</code> jika memungkinkan </li><li>  Gunakan <code>Span/Memory</code> jika memungkinkan </li><li>  Konversikan algoritma ke <code>ref stack</code> tipe <code>ref stack</code> (StackList: struct, <a href="">ValueStringBuilder</a> ) </li></ul><br><h1 id="osvobozhdayte-obekty-kak-mozhno-ranshe">  Benda bebas sedini mungkin </h1><br><h3 id="problema-6">  Masalah </h3><br><p>  Dibayangkan sebagai berumur pendek, objek jatuh ke gen1, dan kadang-kadang ke gen2. <br>  Ini menghasilkan GC yang lebih berat yang bertahan lebih lama </p><br><h3 id="reshenie-6">  Solusi </h3><br><ul><li>  Anda harus melepaskan referensi objek sedini mungkin </li><li>  Jika algoritme yang panjang berisi kode yang bekerja dengan objek apa pun, spasi dengan kode.  Tetapi yang dapat dikelompokkan dalam satu tempat, perlu untuk mengelompokkannya, sehingga memungkinkan mereka untuk dikumpulkan sebelumnya. <br><ul><li>  Misalnya, pada baris 10, koleksi dikeluarkan, dan pada baris 120, ia disaring. </li></ul></li></ul><br><h1 id="vyzyvat-gccollect-ne-nuzhno">  Tidak perlu menelepon GC.Collect () </h1><br><h3 id="problema-7">  Masalah </h3><br><p>  Sering terlihat bahwa jika Anda memanggil GC.Collect (), itu akan memperbaiki situasi </p><br><h3 id="reshenie-7">  Solusi </h3><br><ul><li>  Jauh lebih benar untuk mempelajari algoritma operasi GC, lihat aplikasi di bawah ETW dan alat diagnostik lainnya (JetBrains dotMemory, ...) </li><li>  Optimalkan area yang paling bermasalah </li></ul><br><h1 id="izbegayte-pinning">  Hindari Menjepit </h1><br><h3 id="problema-8">  Masalah </h3><br><p>  Pinning menimbulkan sejumlah masalah: </p><br><ul><li>  Pengumpulan sampah yang rumit </li><li>  Membuat ruang memori gratis (node ​​item daftar bebas, meja bata, ember) </li><li>  Dapat meninggalkan beberapa objek di generasi yang lebih muda, sambil membentuk tautan dari tabel kartu </li></ul><br><h3 id="reshenie-8">  Solusi </h3><br><p>  Jika tidak ada jalan keluar lain, gunakan fixed () {}.  Metode komitmen ini tidak membuat komitmen nyata: ini hanya terjadi ketika GC telah bekerja di dalam kurung kurawal. </p><br><h1 id="izbegayte-finalizacii">  Hindari finalisasi </h1><br><h3 id="problema-9">  Masalah </h3><br><p>  Finalisasi tidak disebut secara deterministik: </p><br><ul><li>  Buang Tanpa diundang () menghasilkan finalisasi dengan semua tautan keluar dari objek </li><li>  Objek dependen tertunda lebih lama dari yang direncanakan </li><li>  Penuaan, pindah ke generasi yang lebih tua </li><li>  Jika pada saat yang sama mereka memuat tautan ke tautan yang lebih muda, mereka menghasilkan tautan dari tabel kartu </li><li>  Mempersulit perakitan generasi yang lebih tua, memecah-mecah mereka dan mengarah ke Compacting bukan Sweep </li></ul><br><h3 id="reshenie-9">  Solusi </h3><br><p>  Panggil Buang dengan lembut () </p><br><h1 id="izbegayte-bolshogo-kolichestva-potokov">  Hindari terlalu banyak utas </h1><br><h3 id="problema-10">  Masalah </h3><br><p>  Dengan sejumlah besar utas, konteks alokasi bertambah, seperti  mereka dialokasikan untuk setiap utas: </p><br><ul><li>  Hasilnya, GC.Collect datang lebih cepat. </li><li>  Karena kurangnya ruang di segmen sementara, Kumpulkan akan mengikuti Sapu Kolektif </li></ul><br><h3 id="reshenie-10">  Solusi </h3><br><ul><li>  Kontrol jumlah utas dengan jumlah inti </li></ul><br><h1 id="izbegayte-traffika-obektov-raznogo-razmera">  Hindari lalu lintas benda dengan ukuran berbeda </h1><br><h3 id="problema-11">  Masalah </h3><br><p>  Saat lalu lintas objek dari berbagai ukuran dan masa hidup, fragmentasi terjadi: </p><br><ul><li>  Tingkatkan rasio fragmentasi </li><li>  Koleksi memicu dengan fase perubahan alamat di semua objek referensi </li></ul><br><h3 id="reshenie-11">  Solusi </h3><br><p>  Jika lalu lintas objek dianggap: </p><br><ul><li>  Periksa keberadaan bidang tambahan, kira-kira ukurannya </li><li>  Periksa kurangnya manipulasi string: jika memungkinkan, ganti dengan ReadOnlySpan / ReadOnlyMemory </li><li>  Lepaskan tautan sesegera mungkin </li><li>  Manfaatkan menarik </li><li>  Hangatkan cache dan kolam dengan GC ganda untuk benda padat.  Dengan demikian, Anda menghindari masalah dengan tabel kartu. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453082/">https://habr.com/ru/post/id453082/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453072/index.html">Bagaimana Saya Lulus dari Ujian Sertifikasi Insinyur Data Google Cloud Professional</a></li>
<li><a href="../id453074/index.html">Wolfram Engine sekarang terbuka untuk pengembang (terjemahan)</a></li>
<li><a href="../id453076/index.html">Bisnis sendiri: buku dengan taktik untuk melewati permainan ini</a></li>
<li><a href="../id453078/index.html">Ulasan Peran mereka dalam kehidupan freelancer dan bukan hanya</a></li>
<li><a href="../id453080/index.html">Rumah pintar dengan Alice. Yandex membuka platform untuk semua pengembang</a></li>
<li><a href="../id453084/index.html">Latar belakang: Konflik US-Huawei - garis waktu dan alasan</a></li>
<li><a href="../id453088/index.html">"Organisasi Terbuka": Bagaimana tidak tersesat dalam kekacauan dan mengumpulkan jutaan</a></li>
<li><a href="../id453090/index.html">MERLION menjadi distributor resmi Zextras, pengembang ekstensi global terkemuka untuk server surat Zimbra</a></li>
<li><a href="../id453092/index.html">Menyatukan aplikasi desktop Flutter</a></li>
<li><a href="../id453094/index.html">Analisis frekuensi digit dalam hash MD5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>