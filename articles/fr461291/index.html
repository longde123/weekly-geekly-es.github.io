<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÖ üèÖ üë®üèø‚Äçü§ù‚Äçüë®üèª Golang: probl√®mes de performances sp√©cifiques üìÜ üôÄ üò†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La langue Go gagne en popularit√©. Tellement confiant qu'il y a de plus en plus de conf√©rences, par exemple, GolangConf , et la langue est parmi les di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Golang: probl√®mes de performances sp√©cifiques</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461291/">  La langue Go gagne en popularit√©.  Tellement confiant qu'il y a de plus en plus de conf√©rences, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GolangConf</a> , et la langue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est parmi les dix</a> technologies les mieux pay√©es.  Par cons√©quent, il est d√©j√† judicieux de parler de ses probl√®mes sp√©cifiques, par exemple, les performances.  En plus des probl√®mes communs √† toutes les langues compil√©es, Go a la sienne.  Ils sont associ√©s √† l'optimiseur, √† la pile, au syst√®me de saisie et au mod√®le multit√¢che.  Les moyens de les r√©soudre et les solutions de contournement sont parfois tr√®s sp√©cifiques. <br><br>  <strong>Daniel Podolsky</strong> , bien que l'√©vang√©liste de Go, rencontre √©galement beaucoup de choses √©tranges en lui.  Tout ce qui est √©trange et, surtout, int√©ressant, est collect√© et test√©, puis en parle dans HighLoad ++.  La transcription du rapport comprendra des chiffres, des graphiques, des exemples de code, les r√©sultats du profileur, une comparaison des performances des m√™mes algorithmes dans diff√©rentes langues - et tout le reste, pour lequel nous d√©testons tellement le mot ¬´optimisation¬ª.  Il n'y aura aucune r√©v√©lation dans la transcription - d'o√π viennent-ils dans un langage aussi simple - et tout ce qui peut √™tre lu dans les journaux. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8UESXMJwTpc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  <strong>√Ä propos des conf√©renciers.</strong>  <b>Daniil Podolsky</b> : 26 ans d'exp√©rience, 20 en op√©ration, dont le leader du groupe, 5 ans de programmation sur Go.  <b>Kirill Danshin</b> : cr√©ateur de Gramework, Maintainer, Fast HTTP, Black Go-mage. <br><br>  <em>Le rapport a √©t√© pr√©par√© conjointement par Daniil Podolsky et Kirill Danshin, mais Daniel a fait un rapport et Cyril a aid√© mentalement.</em> <br><br><h2>  Constructions linguistiques </h2><br>  Nous avons une norme de performance - <code>direct</code> .  Il s'agit d'une fonction qui incr√©mente une variable et ne fait plus rien. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   var testInt64 int64 func BenchmarkDirect(b *testing.B) { for i := 0; i &lt; bN; i++ { incDirect() } } func incDirect() { testInt64++ }</span></span></code> </pre> <br>  Le r√©sultat de la fonction est de <b>1,46 ns par op√©ration</b> .  Il s'agit de l'option minimale.  Plus rapide que 1,5 ns par op√©ration, ne fonctionnera probablement pas. <br><br><h3>  Reportez la fa√ßon dont nous l'aimons </h3><br>  Beaucoup savent et aiment utiliser la construction du langage diff√©r√©.  Tr√®s souvent, nous l'utilisons comme √ßa. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDefer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDefer() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incDefer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> incDirect() }</code> </pre> <br>  Mais vous ne pouvez pas l'utiliser comme √ßa!  Chaque report consomme 40 ns par op√©ration. <br><br><pre> <code class="plaintext hljs">//   BenchmarkDirect-4 2000000000 1.46 / // defer BenchmarkDefer-4 30000000 40.70 /</code> </pre> <br>  Je pensais que c'√©tait peut-√™tre √† cause de l'inline?  Peut-√™tre que l'inline est si rapide? <br><br>  Direct est en ligne et la fonction de report ne peut pas √™tre en ligne.  Par cons√©quent, compil√© une fonction de test s√©par√©e sans inline. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectNoInline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDirectNoInline() } } <span class="hljs-comment"><span class="hljs-comment">//go:noinline func incDirectNoInline() { testInt64++ }</span></span></code> </pre> <br>  Rien n'a chang√©, le report a pris les m√™mes 40 ns.  Reportez-vous cher, mais pas catastrophique. <br><br><blockquote>  Lorsqu'une fonction prend moins de 100 ns, vous pouvez le faire sans diff√©rer. </blockquote><br>  Mais l√† o√π la fonction prend plus d'une microseconde, c'est tout de m√™me - vous pouvez utiliser le report. <br><br><h3>  Passer un param√®tre par r√©f√©rence </h3><br>  Consid√©rez un mythe populaire. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectByPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDirectByPointer(&amp;testInt64) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incDirectByPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { *n++ }</code> </pre> <br>  Rien n'a chang√© - rien ne vaut le coup. <br><br><pre> <code class="plaintext hljs">//     BenchmarkDirectByPointer-4 2000000000 1.47 / BenchmarkDeferByPointer-4 30000000 43.90 /</code> </pre> <br>  Sauf pour 3 ns par report, mais ceci est amorti pour les fluctuations. <br><br><h3>  Fonctions anonymes </h3><br>  Parfois, les d√©butants demandent: ¬´Une fonction anonyme co√ªte-t-elle cher?¬ª <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectAnonymous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { testInt64++ }() } }</code> </pre> <br><blockquote>  Une fonction anonyme n'est pas ch√®re, elle prend 40,4 ns. </blockquote><br><h3>  Interfaces </h3><br>  Il existe une interface et une structure qui le mettent en ≈ìuvre. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testTypeInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Inc() } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testTypeStruct <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { n <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *testTypeStruct)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { s.n++ }</code> </pre> <br>  Il existe trois options pour utiliser la m√©thode d'incr√©mentation.  Directement depuis Struct: <code>var testStruct = testTypeStruct{}</code> . <br><br>  Depuis l'interface concr√®te correspondante: <code>var testInterface testTypeInterface = &amp;testStruct</code> . <br><br>  Avec conversion d'interface d'ex√©cution: <code>var testInterfaceEmpty interface{} = &amp;testStruct</code> . <br><br>  Vous trouverez ci-dessous la conversion et l'utilisation de l'interface d'ex√©cution directement. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { testInterface.Inc() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkInterfaceRuntime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { testInterfaceEmpty.(testTypeInterface).Inc() } }</code> </pre> <br><blockquote>  L'interface, en tant que telle, ne co√ªte rien. </blockquote><br><pre> <code class="plaintext hljs">//  BenchmarkStruct-4 2000000000 1.44 / BenchmarkInterface-4 2000000000 1.88 / BenchmarkInterfaceRuntime-4 200000000 9.23 /</code> </pre> <br><br>  La conversion de l'interface d'ex√©cution en vaut la peine, mais pas ch√®re - vous n'avez pas besoin de refuser sp√©cifiquement.  Mais essayez de vous en passer si possible. <br><br>  <b>Mythes:</b> <br><br><ul><li>  D√©r√©f√©rencement - d√©r√©f√©rencement des pointeurs - gratuit. </li><li>  Les fonctionnalit√©s anonymes sont gratuites. </li><li>  Les interfaces sont gratuites. </li><li>  Conversion d'interface d'ex√©cution - NON GRATUIT. </li></ul><br><h3>  Basculer, mapper et d√©couper </h3><br>  Chaque nouveau venu √† Go demande ce qui se passe si vous remplacez le commutateur par une carte.  Sera-ce plus rapide? <br><br>  L'interrupteur est disponible en diff√©rentes tailles.  J'ai test√© sur trois tailles: petite pour 10 caisses, moyenne pour 100 caisses et grande pour 1000 caisses.  Le commutateur pour 1000 cas se trouve dans le code de production r√©el.  Bien s√ªr, personne ne les √©crit avec ses mains.  Il s'agit d'un code g√©n√©r√© automatiquement, g√©n√©ralement un commutateur de type.  Test√© sur deux types: int et string.  Il semblait que cela se r√©v√©lerait plus clairement. <br><br>  <strong>Petit interrupteur.</strong>  L'option la plus rapide est le commutateur r√©el.  La suite va imm√©diatement tranche, o√π l'index entier correspondant contient une r√©f√©rence √† la fonction.  La carte n'est pas un leader sur int ou cha√Æne. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntSmall-4 </td><td>  500000000 </td><td>  3,26 ns / op </td></tr><tr><td>  BenchmarkMapIntSmall-4 </td><td>  100 000 000 </td><td>  11,70 ns / op </td></tr><tr><td>  BenchmarkSliceIntSmall-4 </td><td>  500000000 </td><td>  3,85 ns / op </td></tr><tr><td>  BenchmarkSwitchStringSmall-4 </td><td>  100 000 000 </td><td>  12,70 ns / op </td></tr><tr><td>  BenchmarkMapStringSmall-4 </td><td>  100 000 000 </td><td>  15,60 ns / op </td></tr></tbody></table></div><br>  Activer les cha√Ænes est beaucoup plus lent que sur int.  Si vous pouvez passer non pas √† une cha√Æne, mais √† un int, faites-le. <br><br>  <strong>Interrupteur central.</strong>  Switch lui-m√™me r√®gne toujours int, mais slice l'a un peu d√©pass√©.  La carte est toujours mauvaise.  Mais sur une cl√© de cha√Æne, la carte est plus rapide que le commutateur - comme pr√©vu. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntMedium-4 </td><td>  300000000 </td><td>  4,55 ns / op </td></tr><tr><td>  BenchmarkMapIntMedium-4 </td><td>  100 000 000 </td><td>  17.10 ns / op </td></tr><tr><td>  BenchmarkSliceIntMedium-4 </td><td>  300000000 </td><td>  3,76 ns / op </td></tr><tr><td>  BenchmarkSwitchStringMedium-4 </td><td>  50 000 000 </td><td>  28,50 ns / op </td></tr><tr><td>  BenchmarkMapStringMedium-4 </td><td>  100 000 000 </td><td>  20.30 ns / op </td></tr></tbody></table></div><br>  <strong>Gros interrupteur.</strong>  Un millier de cas t√©moignent de la victoire inconditionnelle de la carte dans la nomination ¬´switch by string¬ª.  Th√©oriquement, la tranche a gagn√©, mais en pratique je vous conseille d'utiliser le m√™me switch ici.  La carte est encore lente, m√™me si la carte a des cl√©s enti√®res avec une fonction de hachage sp√©ciale.  En g√©n√©ral, cette fonction ne fait rien.  L‚Äôint lui-m√™me a un hachage pour int. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntLarge-4 </td><td>  100 000 000 </td><td>  13,6 ns / op </td></tr><tr><td>  BenchmarkMapIntLarge-4 </td><td>  50 000 000 </td><td>  34,3 ns / op </td></tr><tr><td>  BenchmarkSliceIntLarge-4 </td><td>  100 000 000 </td><td>  12,8 ns / op </td></tr><tr><td>  BenchmarkSwitchStringLarge-4 </td><td>  20 000 000 </td><td>  100,0 ns / op </td></tr><tr><td>  BenchmarkMapStringLarge-4 </td><td>  30000000 </td><td>  37,4 ns / op </td></tr></tbody></table></div><br>  <strong>Conclusions</strong>  La carte n'est meilleure que sur de grandes quantit√©s et non sur une condition enti√®re.  Je suis s√ªr que dans toutes les conditions, sauf int, il se comportera de la m√™me mani√®re que sur la cha√Æne.  Slice dirige toujours lorsque les conditions sont enti√®res.  Utilisez-le si vous voulez ¬´acc√©l√©rer¬ª votre programme de 2 ns. <br><br><h2>  Interaction inter-routine </h2><br>  Le sujet est complexe, j'ai effectu√© de nombreux tests et pr√©senterai les plus r√©v√©lateurs.  Nous connaissons les <strong>moyens d'interaction inter-agences suivants</strong> . <br><br><ul><li>  Atomique  Ce sont des moyens d'application limit√©e - vous pouvez remplacer le pointeur ou utiliser int. </li><li>  Mutex est largement utilis√© depuis Java. </li><li>  La cha√Æne est unique √† GO. </li><li>  Canal tamponn√© - canaux tamponn√©s. </li></ul><br>  Bien s√ªr, j'ai test√© sur un nombre beaucoup plus important de goroutins qui se disputent une seule ressource.  Mais il en a choisi trois √† titre indicatif: un peu - 100, un moyen - 1000 et beaucoup - 10000. <br><br>  <strong>Le profil de charge est diff√©rent</strong> .  Parfois, tous les gorutins veulent √©crire dans une variable, mais c'est rare.  Habituellement, apr√®s tout, certains √©crivent, certains lisent.  Parmi les lecteurs, principalement - 90% lisent, parmi ceux qui √©crivent - 90% √©crivent. <br><br>  C'est le code qui est utilis√© pour que le goroutine qui dessert le canal puisse fournir √† la fois la lecture et l'√©criture d'une variable. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> n, ok := &lt;-cw: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { wgc.Done() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } testInt64 += n <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> cr &lt;- testInt64: } } }()</code> </pre> <br>  Si un message nous parvient par le canal par lequel nous √©crivons, nous l'ex√©cutons.  Si le canal est ferm√©, on termine le goroutin.  √Ä tout moment, nous sommes pr√™ts √† √©crire sur le canal qui est utilis√© par d'autres goroutines pour la lecture. <br><div class="scrollable-table"><table><tbody><tr><td>  Benchmarkmutex-4 </td><td>  100 000 000 </td><td>  16.30 ns / op </td></tr><tr><td>  Benchmarkatomic-4 </td><td>  200000000 </td><td>  6,72 ns / op </td></tr><tr><td>  Benchmarkcan-4 </td><td>  5 000 000 </td><td>  239,00 ns / op </td></tr></tbody></table></div><br>  Ce sont des donn√©es pour un goroutine.  Le test de canal est effectu√© sur deux goroutines: l'une traite le canal, l'autre √©crit sur ce canal.  Et ces options ont √©t√© test√©es sur un. <br><br><ul><li>  √âcriture directe dans une variable. </li><li>  Mutex prend un journal, √©crit dans une variable et lib√®re un journal. </li><li>  Atomic √©crit dans une variable via Atomic.  Ce n'est pas gratuit, mais toujours beaucoup moins cher que Mutex sur un garutin. </li></ul><br>  Avec une petite quantit√© de goroutine, l'Atomic est un moyen efficace et rapide de synchroniser, ce qui n'est pas surprenant.  Direct n'est pas l√†, car nous avons besoin d'une synchronisation, qu'il ne fournit pas.  Mais Atomic a des d√©fauts, bien s√ªr. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkMutexFew-4 </td><td>  30000 </td><td>  55894 ns / op </td></tr><tr><td>  BenchmarkAtomicFew-4 </td><td>  100 000 </td><td>  14585 ns / op </td></tr><tr><td>  BenchmarkChanFew-4 </td><td>  5000 </td><td>  323859 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFew-4 </td><td>  5000 </td><td>  341321 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullFew-4 </td><td>  20000 </td><td>  70052 ns / op </td></tr><tr><td>  BenchmarkMutexMostlyReadFew-4 </td><td>  30000 </td><td>  56402 ns / op </td></tr><tr><td>  BenchmarkAtomicMostlyReadFew-4 </td><td>  1 000 000 </td><td>  2094 ns / op </td></tr><tr><td>  BenchmarkChanMostlyReadFew-4 </td><td>  3000 </td><td>  442689 ns / op </td></tr><tr><td>  BenchmarkChanBufferedMostlyReadFew-4 </td><td>  3000 </td><td>  449 666 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullMostlyReadFew-4 </td><td>  5000 </td><td>  442 708 ns / op </td></tr><tr><td>  BenchmarkMutexMostlyWriteFew-4 </td><td>  20000 </td><td>  79708 ns / op </td></tr><tr><td>  BenchmarkAtomicMostlyWriteFew-4 </td><td>  100 000 </td><td>  13358 ns / op </td></tr><tr><td>  BenchmarkChanMostlyWriteFew-4 </td><td>  3000 </td><td>  449 556 ns / op </td></tr><tr><td>  BenchmarkChanBufferedMostlyWriteFew-4 </td><td>  3000 </td><td>  445423 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullMostlyWriteFew-4 </td><td>  3000 </td><td>  414626 ns / op </td></tr></tbody></table></div><br>  La prochaine √©tape est Mutex.  Je m'attendais √† ce que Channel soit aussi rapide que Mutex, mais non. <br><br><blockquote>  Le canal est un ordre de grandeur plus cher que Mutex. </blockquote><br>  De plus, Channel et Channel tamponn√© sortent √† peu pr√®s au m√™me prix.  Et il y a Channel, dans lequel le tampon ne d√©borde jamais.  C'est un ordre de grandeur moins cher que celui dont le tampon d√©borde.  Ce n'est que si le tampon de Channel n'est pas plein, qu'il en co√ªte √† peu pr√®s le m√™me prix par ordre de grandeur que Mutex.  C'est ce que j'attendais du test. <br><br>  Cette image avec la r√©partition de son co√ªt est r√©p√©t√©e sur n'importe quel profil de charge - √† la fois sur MostlyRead et MostlyWrite.  De plus, le canal MostlyRead complet co√ªte le m√™me prix que le canal incomplet.  Et le canal tamponn√© de MostlyWrite, dans lequel le tampon n'est pas plein, co√ªte le m√™me prix que le reste.  Je ne peux pas dire pourquoi il en est ainsi - je n'ai pas encore √©tudi√© cette question. <br><br><h2>  Passer des param√®tres </h2><br>  <strong>Comment passer les param√®tres plus rapidement - par r√©f√©rence ou par valeur?</strong>  Voyons √ßa. <br><br>  J'ai v√©rifi√© comme suit - fait des types imbriqu√©s de 1 √† 10. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TP001 <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { I001 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TV002 <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { I001 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> S001 TV001 I002 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> S002 TV001 }</code> </pre> <br>  Le dixi√®me type imbriqu√© aura 10 champs int64, et les types imbriqu√©s de l'imbrication pr√©c√©dente seront √©galement 10. <br><br>  Il a ensuite √©crit des fonctions qui cr√©ent un type d'imbrication. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTP001</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TP001</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;TP001{ I001: rand.Int63(), } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTV002</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TV002</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TV002{ I001: rand.Int63(), S001: NewTV001(), I002: rand.Int63(), S002: NewTV001(), } }</code> </pre> <br>  Pour les tests, j'ai utilis√© trois options du type: petit avec embo√Ætement 2, moyen avec embo√Ætement 3, grand avec embo√Ætement 5. J'ai d√ª mettre un tr√®s grand test avec embo√Ætement 10 la nuit, mais l√†, l'image est exactement la m√™me que pour 5. <br><br>  <b>Dans les fonctions, le passage par valeur est au moins deux fois plus rapide que le passage par r√©f√©rence</b> .  Cela est d√ª au fait que le passage par la valeur ne charge pas l'analyse d'√©chappement.  En cons√©quence, les variables que nous allouons sont sur la pile.  C'est beaucoup moins cher pour l'ex√©cution, pour le ramasse-miettes.  Bien qu'il n'ait peut-√™tre pas le temps de se connecter.  Ces tests ont dur√© quelques secondes - le ramasse-miettes √©tait probablement encore endormi. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkCreateSmallByValue-4 </td><td>  200 000 </td><td>  8942 ns / op </td></tr><tr><td>  BenchmarkCreateSmallByPointer-4 </td><td>  100 000 </td><td>  15985 ns / op </td></tr><tr><td>  BenchmarkCreateMediuMByValue-4 </td><td>  2000 </td><td>  862317 ns / op </td></tr><tr><td>  BenchmarkCreateMediuMByPointer-4 </td><td>  2000 </td><td>  1228130 ns / op </td></tr><tr><td>  BenchmarkCreateLargeByValue-4 </td><td>  30 </td><td>  47398456 ns / op </td></tr><tr><td>  BenchmarkCreateLargeByPointer-4 </td><td>  20 </td><td>  61928751 ns / op </td></tr></tbody></table></div><br><h2>  Magie noire </h2><br>  Savez-vous ce que ce programme produira? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { a, b <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(A) aa = <span class="hljs-number"><span class="hljs-number">0</span></span> ab = <span class="hljs-number"><span class="hljs-number">1</span></span> z := (*(*<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>)(unsafe.Pointer(a))) fmt.Println(z) }</code> </pre> <br>  Le r√©sultat du programme d√©pend de l'architecture sur laquelle il est ex√©cut√©.  Sur le petit endian, par exemple, AMD64, le programme affiche <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>32</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhjODPUKWfTXdexdP3ahMhWMyXYZ0w#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhjODPUKWfTXdexdP3ahMhWMyXYZ0w#MJMAIN-33"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhjODPUKWfTXdexdP3ahMhWMyXYZ0w#MJMAIN-32" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>32</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> 2 ^ {32} </script>  .  Sur big endian, un.  Le r√©sultat est diff√©rent, car sur le petit endian, cette unit√© appara√Æt au milieu du nombre, et sur le gros endian - √† la fin. <br><br>  Il existe encore des processeurs dans le monde o√π des commutateurs endiens, par exemple, Power PC.  Il sera n√©cessaire de savoir quel endian est configur√© sur votre ordinateur au d√©marrage, avant de faire des inf√©rences sur les astuces dangereuses de ce type.  Par exemple, si vous √©crivez un code Go qui sera ex√©cut√© sur un serveur multiprocesseur IBM. <br><br>  J'ai cit√© ce code pour expliquer pourquoi je consid√®re toute magie noire dangereuse.  Vous n'avez pas besoin de l'utiliser.  Mais Cyril pense que c'est n√©cessaire.  Et voici pourquoi. <br><br>  Il existe une fonction qui fait la m√™me chose que GOB - Go Binary Marshaller.  Ceci est Encoder, mais dangereux. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encodeMut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { sz := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data) * <span class="hljs-number"><span class="hljs-number">8</span></span> dh := (*header)(unsafe.Pointer(&amp;data)) rh := &amp;header{ data: dh.data, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>: sz, <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>: sz, } res = *(*[]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(unsafe.Pointer(&amp;rh)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br>  En fait, il prend un morceau de m√©moire et en tire un tableau d'octets. <br><br>  Ce n'est m√™me pas une commande - ce sont deux commandes.  Par cons√©quent, Cyril Danshin, lorsqu'il √©crit un code performant, n'h√©site pas √† entrer dans les tripes de son programme et √† le rendre dangereux. <br><br><div class="scrollable-table"><table><tbody><tr><td>  Benchmark gob-4 </td><td>  200 000 </td><td>  8466 ns / op </td><td>  120,94 Mo / s </td></tr><tr><td>  BenchmarkUnsafeMut-4 </td><td>  50 000 000 </td><td>  37 ns / op </td><td>  27691.06 Mo / s </td></tr></tbody></table></div><blockquote>  Nous discuterons des caract√©ristiques plus sp√©cifiques de Go le 7 octobre au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GolangConf</a> - une conf√©rence pour ceux qui utilisent Go dans le d√©veloppement professionnel et ceux qui consid√®rent ce langage comme une alternative.  Daniil Podolsky n'est qu'un membre du comit√© du programme, si vous souhaitez discuter de cet article ou r√©v√©ler des probl√®mes connexes - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">soumettez une demande</a> de rapport. <br><br>  Pour tout le reste, en ce qui concerne les hautes performances, bien s√ªr, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HighLoad ++</a> .  Nous acceptons √©galement les candidatures.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Inscrivez-vous</a> √† la newsletter et restez √† jour avec les nouvelles de toutes nos conf√©rences pour les d√©veloppeurs Web. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461291/">https://habr.com/ru/post/fr461291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461281/index.html">Proc√©dure pas √† pas pour configurer un serveur DNS BIND dans un environnement chroot pour Red Hat (RHEL / CentOS) 7</a></li>
<li><a href="../fr461283/index.html">Architecture logicielle et conception de syst√®mes: guide g√©n√©ral et ressources</a></li>
<li><a href="../fr461285/index.html">5 algorithmes d'√©chantillonnage principaux</a></li>
<li><a href="../fr461287/index.html">D√©velopper une IA astucieuse dans un jeu tactique bas√© sur l'heuristique et les mutations</a></li>
<li><a href="../fr461289/index.html">Sortie de CLion 2019.2: support de d√©veloppement int√©gr√©, d√©bogueur pour MSVC, recherche de fichiers d'en-t√™te inutilis√©s</a></li>
<li><a href="../fr461297/index.html">√Ä quoi ressemblent les attaques cibl√©es modernes</a></li>
<li><a href="../fr461299/index.html">Comment le PC a conquis l'industrie des m√©dias avec des logiciels performants: discussion sur Pro Tools et Media Composer</a></li>
<li><a href="../fr461303/index.html">Utilisation de la carte Tro√Øka comme police d'assurance m√©dicale obligatoire</a></li>
<li><a href="../fr461305/index.html">R√©seau d'entreprise et MitM. 2e partie</a></li>
<li><a href="../fr461307/index.html">Nous vous invitons au VK Hackathon 2019. La cagnotte de cette ann√©e est de deux millions de roubles.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>