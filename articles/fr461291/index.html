<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚅 🏅 👨🏿‍🤝‍👨🏻 Golang: problèmes de performances spécifiques 📆 🙀 😠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La langue Go gagne en popularité. Tellement confiant qu'il y a de plus en plus de conférences, par exemple, GolangConf , et la langue est parmi les di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Golang: problèmes de performances spécifiques</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461291/">  La langue Go gagne en popularité.  Tellement confiant qu'il y a de plus en plus de conférences, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GolangConf</a> , et la langue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est parmi les dix</a> technologies les mieux payées.  Par conséquent, il est déjà judicieux de parler de ses problèmes spécifiques, par exemple, les performances.  En plus des problèmes communs à toutes les langues compilées, Go a la sienne.  Ils sont associés à l'optimiseur, à la pile, au système de saisie et au modèle multitâche.  Les moyens de les résoudre et les solutions de contournement sont parfois très spécifiques. <br><br>  <strong>Daniel Podolsky</strong> , bien que l'évangéliste de Go, rencontre également beaucoup de choses étranges en lui.  Tout ce qui est étrange et, surtout, intéressant, est collecté et testé, puis en parle dans HighLoad ++.  La transcription du rapport comprendra des chiffres, des graphiques, des exemples de code, les résultats du profileur, une comparaison des performances des mêmes algorithmes dans différentes langues - et tout le reste, pour lequel nous détestons tellement le mot «optimisation».  Il n'y aura aucune révélation dans la transcription - d'où viennent-ils dans un langage aussi simple - et tout ce qui peut être lu dans les journaux. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8UESXMJwTpc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  <strong>À propos des conférenciers.</strong>  <b>Daniil Podolsky</b> : 26 ans d'expérience, 20 en opération, dont le leader du groupe, 5 ans de programmation sur Go.  <b>Kirill Danshin</b> : créateur de Gramework, Maintainer, Fast HTTP, Black Go-mage. <br><br>  <em>Le rapport a été préparé conjointement par Daniil Podolsky et Kirill Danshin, mais Daniel a fait un rapport et Cyril a aidé mentalement.</em> <br><br><h2>  Constructions linguistiques </h2><br>  Nous avons une norme de performance - <code>direct</code> .  Il s'agit d'une fonction qui incrémente une variable et ne fait plus rien. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   var testInt64 int64 func BenchmarkDirect(b *testing.B) { for i := 0; i &lt; bN; i++ { incDirect() } } func incDirect() { testInt64++ }</span></span></code> </pre> <br>  Le résultat de la fonction est de <b>1,46 ns par opération</b> .  Il s'agit de l'option minimale.  Plus rapide que 1,5 ns par opération, ne fonctionnera probablement pas. <br><br><h3>  Reportez la façon dont nous l'aimons </h3><br>  Beaucoup savent et aiment utiliser la construction du langage différé.  Très souvent, nous l'utilisons comme ça. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDefer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDefer() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incDefer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> incDirect() }</code> </pre> <br>  Mais vous ne pouvez pas l'utiliser comme ça!  Chaque report consomme 40 ns par opération. <br><br><pre> <code class="plaintext hljs">//   BenchmarkDirect-4 2000000000 1.46 / // defer BenchmarkDefer-4 30000000 40.70 /</code> </pre> <br>  Je pensais que c'était peut-être à cause de l'inline?  Peut-être que l'inline est si rapide? <br><br>  Direct est en ligne et la fonction de report ne peut pas être en ligne.  Par conséquent, compilé une fonction de test séparée sans inline. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectNoInline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDirectNoInline() } } <span class="hljs-comment"><span class="hljs-comment">//go:noinline func incDirectNoInline() { testInt64++ }</span></span></code> </pre> <br>  Rien n'a changé, le report a pris les mêmes 40 ns.  Reportez-vous cher, mais pas catastrophique. <br><br><blockquote>  Lorsqu'une fonction prend moins de 100 ns, vous pouvez le faire sans différer. </blockquote><br>  Mais là où la fonction prend plus d'une microseconde, c'est tout de même - vous pouvez utiliser le report. <br><br><h3>  Passer un paramètre par référence </h3><br>  Considérez un mythe populaire. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectByPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDirectByPointer(&amp;testInt64) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incDirectByPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { *n++ }</code> </pre> <br>  Rien n'a changé - rien ne vaut le coup. <br><br><pre> <code class="plaintext hljs">//     BenchmarkDirectByPointer-4 2000000000 1.47 / BenchmarkDeferByPointer-4 30000000 43.90 /</code> </pre> <br>  Sauf pour 3 ns par report, mais ceci est amorti pour les fluctuations. <br><br><h3>  Fonctions anonymes </h3><br>  Parfois, les débutants demandent: «Une fonction anonyme coûte-t-elle cher?» <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectAnonymous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { testInt64++ }() } }</code> </pre> <br><blockquote>  Une fonction anonyme n'est pas chère, elle prend 40,4 ns. </blockquote><br><h3>  Interfaces </h3><br>  Il existe une interface et une structure qui le mettent en œuvre. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testTypeInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Inc() } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testTypeStruct <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { n <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *testTypeStruct)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { s.n++ }</code> </pre> <br>  Il existe trois options pour utiliser la méthode d'incrémentation.  Directement depuis Struct: <code>var testStruct = testTypeStruct{}</code> . <br><br>  Depuis l'interface concrète correspondante: <code>var testInterface testTypeInterface = &amp;testStruct</code> . <br><br>  Avec conversion d'interface d'exécution: <code>var testInterfaceEmpty interface{} = &amp;testStruct</code> . <br><br>  Vous trouverez ci-dessous la conversion et l'utilisation de l'interface d'exécution directement. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { testInterface.Inc() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkInterfaceRuntime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { testInterfaceEmpty.(testTypeInterface).Inc() } }</code> </pre> <br><blockquote>  L'interface, en tant que telle, ne coûte rien. </blockquote><br><pre> <code class="plaintext hljs">//  BenchmarkStruct-4 2000000000 1.44 / BenchmarkInterface-4 2000000000 1.88 / BenchmarkInterfaceRuntime-4 200000000 9.23 /</code> </pre> <br><br>  La conversion de l'interface d'exécution en vaut la peine, mais pas chère - vous n'avez pas besoin de refuser spécifiquement.  Mais essayez de vous en passer si possible. <br><br>  <b>Mythes:</b> <br><br><ul><li>  Déréférencement - déréférencement des pointeurs - gratuit. </li><li>  Les fonctionnalités anonymes sont gratuites. </li><li>  Les interfaces sont gratuites. </li><li>  Conversion d'interface d'exécution - NON GRATUIT. </li></ul><br><h3>  Basculer, mapper et découper </h3><br>  Chaque nouveau venu à Go demande ce qui se passe si vous remplacez le commutateur par une carte.  Sera-ce plus rapide? <br><br>  L'interrupteur est disponible en différentes tailles.  J'ai testé sur trois tailles: petite pour 10 caisses, moyenne pour 100 caisses et grande pour 1000 caisses.  Le commutateur pour 1000 cas se trouve dans le code de production réel.  Bien sûr, personne ne les écrit avec ses mains.  Il s'agit d'un code généré automatiquement, généralement un commutateur de type.  Testé sur deux types: int et string.  Il semblait que cela se révélerait plus clairement. <br><br>  <strong>Petit interrupteur.</strong>  L'option la plus rapide est le commutateur réel.  La suite va immédiatement tranche, où l'index entier correspondant contient une référence à la fonction.  La carte n'est pas un leader sur int ou chaîne. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntSmall-4 </td><td>  500000000 </td><td>  3,26 ns / op </td></tr><tr><td>  BenchmarkMapIntSmall-4 </td><td>  100 000 000 </td><td>  11,70 ns / op </td></tr><tr><td>  BenchmarkSliceIntSmall-4 </td><td>  500000000 </td><td>  3,85 ns / op </td></tr><tr><td>  BenchmarkSwitchStringSmall-4 </td><td>  100 000 000 </td><td>  12,70 ns / op </td></tr><tr><td>  BenchmarkMapStringSmall-4 </td><td>  100 000 000 </td><td>  15,60 ns / op </td></tr></tbody></table></div><br>  Activer les chaînes est beaucoup plus lent que sur int.  Si vous pouvez passer non pas à une chaîne, mais à un int, faites-le. <br><br>  <strong>Interrupteur central.</strong>  Switch lui-même règne toujours int, mais slice l'a un peu dépassé.  La carte est toujours mauvaise.  Mais sur une clé de chaîne, la carte est plus rapide que le commutateur - comme prévu. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntMedium-4 </td><td>  300000000 </td><td>  4,55 ns / op </td></tr><tr><td>  BenchmarkMapIntMedium-4 </td><td>  100 000 000 </td><td>  17.10 ns / op </td></tr><tr><td>  BenchmarkSliceIntMedium-4 </td><td>  300000000 </td><td>  3,76 ns / op </td></tr><tr><td>  BenchmarkSwitchStringMedium-4 </td><td>  50 000 000 </td><td>  28,50 ns / op </td></tr><tr><td>  BenchmarkMapStringMedium-4 </td><td>  100 000 000 </td><td>  20.30 ns / op </td></tr></tbody></table></div><br>  <strong>Gros interrupteur.</strong>  Un millier de cas témoignent de la victoire inconditionnelle de la carte dans la nomination «switch by string».  Théoriquement, la tranche a gagné, mais en pratique je vous conseille d'utiliser le même switch ici.  La carte est encore lente, même si la carte a des clés entières avec une fonction de hachage spéciale.  En général, cette fonction ne fait rien.  L’int lui-même a un hachage pour int. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntLarge-4 </td><td>  100 000 000 </td><td>  13,6 ns / op </td></tr><tr><td>  BenchmarkMapIntLarge-4 </td><td>  50 000 000 </td><td>  34,3 ns / op </td></tr><tr><td>  BenchmarkSliceIntLarge-4 </td><td>  100 000 000 </td><td>  12,8 ns / op </td></tr><tr><td>  BenchmarkSwitchStringLarge-4 </td><td>  20 000 000 </td><td>  100,0 ns / op </td></tr><tr><td>  BenchmarkMapStringLarge-4 </td><td>  30000000 </td><td>  37,4 ns / op </td></tr></tbody></table></div><br>  <strong>Conclusions</strong>  La carte n'est meilleure que sur de grandes quantités et non sur une condition entière.  Je suis sûr que dans toutes les conditions, sauf int, il se comportera de la même manière que sur la chaîne.  Slice dirige toujours lorsque les conditions sont entières.  Utilisez-le si vous voulez «accélérer» votre programme de 2 ns. <br><br><h2>  Interaction inter-routine </h2><br>  Le sujet est complexe, j'ai effectué de nombreux tests et présenterai les plus révélateurs.  Nous connaissons les <strong>moyens d'interaction inter-agences suivants</strong> . <br><br><ul><li>  Atomique  Ce sont des moyens d'application limitée - vous pouvez remplacer le pointeur ou utiliser int. </li><li>  Mutex est largement utilisé depuis Java. </li><li>  La chaîne est unique à GO. </li><li>  Canal tamponné - canaux tamponnés. </li></ul><br>  Bien sûr, j'ai testé sur un nombre beaucoup plus important de goroutins qui se disputent une seule ressource.  Mais il en a choisi trois à titre indicatif: un peu - 100, un moyen - 1000 et beaucoup - 10000. <br><br>  <strong>Le profil de charge est différent</strong> .  Parfois, tous les gorutins veulent écrire dans une variable, mais c'est rare.  Habituellement, après tout, certains écrivent, certains lisent.  Parmi les lecteurs, principalement - 90% lisent, parmi ceux qui écrivent - 90% écrivent. <br><br>  C'est le code qui est utilisé pour que le goroutine qui dessert le canal puisse fournir à la fois la lecture et l'écriture d'une variable. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> n, ok := &lt;-cw: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { wgc.Done() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } testInt64 += n <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> cr &lt;- testInt64: } } }()</code> </pre> <br>  Si un message nous parvient par le canal par lequel nous écrivons, nous l'exécutons.  Si le canal est fermé, on termine le goroutin.  À tout moment, nous sommes prêts à écrire sur le canal qui est utilisé par d'autres goroutines pour la lecture. <br><div class="scrollable-table"><table><tbody><tr><td>  Benchmarkmutex-4 </td><td>  100 000 000 </td><td>  16.30 ns / op </td></tr><tr><td>  Benchmarkatomic-4 </td><td>  200000000 </td><td>  6,72 ns / op </td></tr><tr><td>  Benchmarkcan-4 </td><td>  5 000 000 </td><td>  239,00 ns / op </td></tr></tbody></table></div><br>  Ce sont des données pour un goroutine.  Le test de canal est effectué sur deux goroutines: l'une traite le canal, l'autre écrit sur ce canal.  Et ces options ont été testées sur un. <br><br><ul><li>  Écriture directe dans une variable. </li><li>  Mutex prend un journal, écrit dans une variable et libère un journal. </li><li>  Atomic écrit dans une variable via Atomic.  Ce n'est pas gratuit, mais toujours beaucoup moins cher que Mutex sur un garutin. </li></ul><br>  Avec une petite quantité de goroutine, l'Atomic est un moyen efficace et rapide de synchroniser, ce qui n'est pas surprenant.  Direct n'est pas là, car nous avons besoin d'une synchronisation, qu'il ne fournit pas.  Mais Atomic a des défauts, bien sûr. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkMutexFew-4 </td><td>  30000 </td><td>  55894 ns / op </td></tr><tr><td>  BenchmarkAtomicFew-4 </td><td>  100 000 </td><td>  14585 ns / op </td></tr><tr><td>  BenchmarkChanFew-4 </td><td>  5000 </td><td>  323859 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFew-4 </td><td>  5000 </td><td>  341321 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullFew-4 </td><td>  20000 </td><td>  70052 ns / op </td></tr><tr><td>  BenchmarkMutexMostlyReadFew-4 </td><td>  30000 </td><td>  56402 ns / op </td></tr><tr><td>  BenchmarkAtomicMostlyReadFew-4 </td><td>  1 000 000 </td><td>  2094 ns / op </td></tr><tr><td>  BenchmarkChanMostlyReadFew-4 </td><td>  3000 </td><td>  442689 ns / op </td></tr><tr><td>  BenchmarkChanBufferedMostlyReadFew-4 </td><td>  3000 </td><td>  449 666 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullMostlyReadFew-4 </td><td>  5000 </td><td>  442 708 ns / op </td></tr><tr><td>  BenchmarkMutexMostlyWriteFew-4 </td><td>  20000 </td><td>  79708 ns / op </td></tr><tr><td>  BenchmarkAtomicMostlyWriteFew-4 </td><td>  100 000 </td><td>  13358 ns / op </td></tr><tr><td>  BenchmarkChanMostlyWriteFew-4 </td><td>  3000 </td><td>  449 556 ns / op </td></tr><tr><td>  BenchmarkChanBufferedMostlyWriteFew-4 </td><td>  3000 </td><td>  445423 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullMostlyWriteFew-4 </td><td>  3000 </td><td>  414626 ns / op </td></tr></tbody></table></div><br>  La prochaine étape est Mutex.  Je m'attendais à ce que Channel soit aussi rapide que Mutex, mais non. <br><br><blockquote>  Le canal est un ordre de grandeur plus cher que Mutex. </blockquote><br>  De plus, Channel et Channel tamponné sortent à peu près au même prix.  Et il y a Channel, dans lequel le tampon ne déborde jamais.  C'est un ordre de grandeur moins cher que celui dont le tampon déborde.  Ce n'est que si le tampon de Channel n'est pas plein, qu'il en coûte à peu près le même prix par ordre de grandeur que Mutex.  C'est ce que j'attendais du test. <br><br>  Cette image avec la répartition de son coût est répétée sur n'importe quel profil de charge - à la fois sur MostlyRead et MostlyWrite.  De plus, le canal MostlyRead complet coûte le même prix que le canal incomplet.  Et le canal tamponné de MostlyWrite, dans lequel le tampon n'est pas plein, coûte le même prix que le reste.  Je ne peux pas dire pourquoi il en est ainsi - je n'ai pas encore étudié cette question. <br><br><h2>  Passer des paramètres </h2><br>  <strong>Comment passer les paramètres plus rapidement - par référence ou par valeur?</strong>  Voyons ça. <br><br>  J'ai vérifié comme suit - fait des types imbriqués de 1 à 10. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TP001 <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { I001 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TV002 <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { I001 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> S001 TV001 I002 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> S002 TV001 }</code> </pre> <br>  Le dixième type imbriqué aura 10 champs int64, et les types imbriqués de l'imbrication précédente seront également 10. <br><br>  Il a ensuite écrit des fonctions qui créent un type d'imbrication. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTP001</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TP001</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;TP001{ I001: rand.Int63(), } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTV002</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TV002</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TV002{ I001: rand.Int63(), S001: NewTV001(), I002: rand.Int63(), S002: NewTV001(), } }</code> </pre> <br>  Pour les tests, j'ai utilisé trois options du type: petit avec emboîtement 2, moyen avec emboîtement 3, grand avec emboîtement 5. J'ai dû mettre un très grand test avec emboîtement 10 la nuit, mais là, l'image est exactement la même que pour 5. <br><br>  <b>Dans les fonctions, le passage par valeur est au moins deux fois plus rapide que le passage par référence</b> .  Cela est dû au fait que le passage par la valeur ne charge pas l'analyse d'échappement.  En conséquence, les variables que nous allouons sont sur la pile.  C'est beaucoup moins cher pour l'exécution, pour le ramasse-miettes.  Bien qu'il n'ait peut-être pas le temps de se connecter.  Ces tests ont duré quelques secondes - le ramasse-miettes était probablement encore endormi. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkCreateSmallByValue-4 </td><td>  200 000 </td><td>  8942 ns / op </td></tr><tr><td>  BenchmarkCreateSmallByPointer-4 </td><td>  100 000 </td><td>  15985 ns / op </td></tr><tr><td>  BenchmarkCreateMediuMByValue-4 </td><td>  2000 </td><td>  862317 ns / op </td></tr><tr><td>  BenchmarkCreateMediuMByPointer-4 </td><td>  2000 </td><td>  1228130 ns / op </td></tr><tr><td>  BenchmarkCreateLargeByValue-4 </td><td>  30 </td><td>  47398456 ns / op </td></tr><tr><td>  BenchmarkCreateLargeByPointer-4 </td><td>  20 </td><td>  61928751 ns / op </td></tr></tbody></table></div><br><h2>  Magie noire </h2><br>  Savez-vous ce que ce programme produira? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { a, b <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(A) aa = <span class="hljs-number"><span class="hljs-number">0</span></span> ab = <span class="hljs-number"><span class="hljs-number">1</span></span> z := (*(*<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>)(unsafe.Pointer(a))) fmt.Println(z) }</code> </pre> <br>  Le résultat du programme dépend de l'architecture sur laquelle il est exécuté.  Sur le petit endian, par exemple, AMD64, le programme affiche <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>32</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhjODPUKWfTXdexdP3ahMhWMyXYZ0w#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhjODPUKWfTXdexdP3ahMhWMyXYZ0w#MJMAIN-33"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhjODPUKWfTXdexdP3ahMhWMyXYZ0w#MJMAIN-32" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>32</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> 2 ^ {32} </script>  .  Sur big endian, un.  Le résultat est différent, car sur le petit endian, cette unité apparaît au milieu du nombre, et sur le gros endian - à la fin. <br><br>  Il existe encore des processeurs dans le monde où des commutateurs endiens, par exemple, Power PC.  Il sera nécessaire de savoir quel endian est configuré sur votre ordinateur au démarrage, avant de faire des inférences sur les astuces dangereuses de ce type.  Par exemple, si vous écrivez un code Go qui sera exécuté sur un serveur multiprocesseur IBM. <br><br>  J'ai cité ce code pour expliquer pourquoi je considère toute magie noire dangereuse.  Vous n'avez pas besoin de l'utiliser.  Mais Cyril pense que c'est nécessaire.  Et voici pourquoi. <br><br>  Il existe une fonction qui fait la même chose que GOB - Go Binary Marshaller.  Ceci est Encoder, mais dangereux. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encodeMut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { sz := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data) * <span class="hljs-number"><span class="hljs-number">8</span></span> dh := (*header)(unsafe.Pointer(&amp;data)) rh := &amp;header{ data: dh.data, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>: sz, <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>: sz, } res = *(*[]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(unsafe.Pointer(&amp;rh)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br>  En fait, il prend un morceau de mémoire et en tire un tableau d'octets. <br><br>  Ce n'est même pas une commande - ce sont deux commandes.  Par conséquent, Cyril Danshin, lorsqu'il écrit un code performant, n'hésite pas à entrer dans les tripes de son programme et à le rendre dangereux. <br><br><div class="scrollable-table"><table><tbody><tr><td>  Benchmark gob-4 </td><td>  200 000 </td><td>  8466 ns / op </td><td>  120,94 Mo / s </td></tr><tr><td>  BenchmarkUnsafeMut-4 </td><td>  50 000 000 </td><td>  37 ns / op </td><td>  27691.06 Mo / s </td></tr></tbody></table></div><blockquote>  Nous discuterons des caractéristiques plus spécifiques de Go le 7 octobre au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GolangConf</a> - une conférence pour ceux qui utilisent Go dans le développement professionnel et ceux qui considèrent ce langage comme une alternative.  Daniil Podolsky n'est qu'un membre du comité du programme, si vous souhaitez discuter de cet article ou révéler des problèmes connexes - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">soumettez une demande</a> de rapport. <br><br>  Pour tout le reste, en ce qui concerne les hautes performances, bien sûr, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HighLoad ++</a> .  Nous acceptons également les candidatures.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Inscrivez-vous</a> à la newsletter et restez à jour avec les nouvelles de toutes nos conférences pour les développeurs Web. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461291/">https://habr.com/ru/post/fr461291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461281/index.html">Procédure pas à pas pour configurer un serveur DNS BIND dans un environnement chroot pour Red Hat (RHEL / CentOS) 7</a></li>
<li><a href="../fr461283/index.html">Architecture logicielle et conception de systèmes: guide général et ressources</a></li>
<li><a href="../fr461285/index.html">5 algorithmes d'échantillonnage principaux</a></li>
<li><a href="../fr461287/index.html">Développer une IA astucieuse dans un jeu tactique basé sur l'heuristique et les mutations</a></li>
<li><a href="../fr461289/index.html">Sortie de CLion 2019.2: support de développement intégré, débogueur pour MSVC, recherche de fichiers d'en-tête inutilisés</a></li>
<li><a href="../fr461297/index.html">À quoi ressemblent les attaques ciblées modernes</a></li>
<li><a href="../fr461299/index.html">Comment le PC a conquis l'industrie des médias avec des logiciels performants: discussion sur Pro Tools et Media Composer</a></li>
<li><a href="../fr461303/index.html">Utilisation de la carte Troïka comme police d'assurance médicale obligatoire</a></li>
<li><a href="../fr461305/index.html">Réseau d'entreprise et MitM. 2e partie</a></li>
<li><a href="../fr461307/index.html">Nous vous invitons au VK Hackathon 2019. La cagnotte de cette année est de deux millions de roubles.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>