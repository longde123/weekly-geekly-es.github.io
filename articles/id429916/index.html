<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê¶ üè≥Ô∏è‚Äçüåà ‚ú¥Ô∏è Cara membangun dan membangun üöí ‚ù£Ô∏è üë®üèæ‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Latar belakang 


 Setelah bertemu di banyak tempat dalam pengembangan Javascript dengan situasi di mana perlu untuk memvalidasi nilai, menjadi jelas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara membangun dan membangun</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429916/"><h2 id="predystoriya">  Latar belakang </h2><br><p>  Setelah bertemu di banyak tempat dalam pengembangan Javascript dengan situasi di mana perlu untuk memvalidasi nilai, menjadi jelas bahwa perlu untuk entah bagaimana menyelesaikan masalah ini.  Untuk tujuan ini, tugas berikut telah ditetapkan: <br>  Kembangkan perpustakaan yang akan memungkinkan: </p><br><ul><li>  memvalidasi <strong>tipe data</strong> ; </li><li>  atur <strong>nilai default</strong> sebagai ganti bidang atau elemen yang tidak valid; </li><li>  <strong>hapus bagian yang tidak valid dari suatu</strong> objek atau array; </li><li>  Terima <strong>pesan kesalahan</strong> </li></ul><br><p>  Dasarnya adalah: </p><br><ul><li>  Mudah dipelajari </li><li>  Keterbacaan kode yang diterima. </li><li>  Kemudahan modifikasi kode </li></ul><br><p>  Untuk mencapai tujuan ini, perpustakaan validasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="kuartet">kuartet</a> telah dikembangkan. </p><a name="habracut"></a><br><h2 id="osnovnye-kirpichi-validacii">  Batu bata validasi dasar </h2><br><p>  Inti dari sebagian besar sistem yang dirancang agar dapat diterapkan dalam berbagai tugas adalah <strong>elemen</strong> paling sederhana: tindakan, data, dan algoritma.  Serta metode <strong>komposisi</strong> mereka - untuk mengumpulkan sesuatu yang lebih rumit dari elemen sederhana untuk menyelesaikan masalah yang lebih kompleks. </p><br><h3 id="validator">  Validator </h3><br><p> Pustaka kuartet didasarkan pada konsep <strong>validator</strong> .  Validator di perpustakaan ini adalah fungsi dari formulir berikut </p><br><pre><code class="plaintext hljs">function validator( value: any, { key: string|int, parent: any }, { key: string|int, parent: any }, ... ): boolean</code> </pre> <br><p>  Ada beberapa hal dalam definisi ini yang harus dijelaskan secara lebih rinci: </p><br><p>  <strong><code>function(...): boolean</code></strong> - mengatakan bahwa validator - menghitung hasil validasi, dan hasil validasi adalah nilai boolean - <strong>benar</strong> atau <strong>salah</strong> , masing-masing <strong>valid</strong> atau <strong>tidak valid</strong> </p><br><p>  <strong><code>value: any</code></strong> - menunjukkan bahwa validator - menghitung hasil validasi <strong>nilai</strong> , yang bisa berupa nilai javascript apa pun.  Validator baik menetapkan nilai yang <strong>divalidasi</strong> menjadi valid atau tidak valid. </p><br><p>  <strong><code>{ key: string|int, parent: any }, ...</code></strong> - menunjukkan bahwa nilai yang divalidasi dapat berada dalam konteks yang berbeda tergantung pada level apa dari nesting nilainya.  Mari kita tunjukkan dengan contoh </p><br><p>  Nilai contoh <strong>tanpa konteks apa pun</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">//         . //         : const isValueValid = validator(4)</span></span></code> </pre> <br><p>  Nilai contoh <b>dalam konteks array</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  0 1 2 3 4 const arr = [1, 2, 3, value, 5] //       (k): 3 //      : [1, 2, 3, value, 5] //    value -      const isValueValid = validator(4, { key: 3, parent: [1,2,3,4,5] })</span></span></code> </pre> <br><p>  Nilai contoh <b>dalam konteks objek</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> } <span class="hljs-comment"><span class="hljs-comment">//        'c' //       : { a: 1, b: 2, c: 4, d: 8 } //    value -   //   : const isValueValid = validator(4, { key: 'c', parent: { a: 1, b: 2, c: 4, d: 8 } })</span></span></code> </pre> <br><p>  Karena struktur dalam suatu objek dapat memiliki sarang yang lebih besar, masuk akal untuk berbicara tentang <b>berbagai konteks</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrOfObj = [{ <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> }, <span class="hljs-comment"><span class="hljs-comment">// ... ] //   c     'c' //    : { a: 1, b: 2, c: 4, d: 8 } //        arrOfObj, //       0. //    value -      const isValueValid = validator( 4, { key: 'c', parent: { a: 1, b: 2, c: 4, d: 8 } } { key: 0, parent: [{ a: 1, b: 2, c: 4, d: 8 }] } )</span></span></code> </pre> <br><p>  Dan sebagainya. </p><br><div class="spoiler">  <b class="spoiler_title">Tentang kesamaan dengan metode array</b> <div class="spoiler_text"><p>  Definisi validator ini harus mengingatkan Anda tentang definisi fungsi yang dilewatkan sebagai argumen ke metode array, seperti: <strong>peta, filter, beberapa, setiap</strong> , dll. </p><br><ul><li>  Argumen pertama untuk fungsi-fungsi ini adalah <strong>elemen array.</strong> </li><li>  Argumen kedua adalah <strong>indeks elemen.</strong> </li><li>  Argumen ketiga adalah <strong>array itu sendiri.</strong> </li></ul><br><p>  Validator dalam hal ini adalah fungsi yang lebih umum - ia mengambil tidak hanya indeks elemen dalam array dan array, tetapi juga indeks array - dalam induk dan induknya, dan seterusnya. </p></div></div><br><h3 id="chto-nam-stoit-dom-postroit">  Apa yang harus kita bangun rumah? </h3><br><p>  Batu bata yang dijelaskan di atas tidak menonjol di antara <em>"solusi batu" lainnya</em> yang tergeletak di <em>"pantai"</em> kruk javascript.  Karena itu, mari kita membangun dari mereka, sesuatu yang lebih koheren dan menarik.  Untuk ini kami memiliki <strong>komposisi</strong> . </p><br><h3 id="kak-postroit-neboskryob-validacii-obektov">  Bagaimana cara membangun validasi gedung pencakar langit? </h3><br><p>  Setuju, akan lebih mudah untuk memvalidasi objek sedemikian rupa sehingga deskripsi validasi cocok dengan deskripsi objek.  Untuk ini kita akan menggunakan <strong>komposisi objek validator</strong> .  Ini terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    quartet const quartet = require('quartet') //    (v -  validator) const v = quartet() //      , //     const objectSchema = { a: a =&gt; typeof a ==='string', //   'string' b: b =&gt; typeof b === 'number', //   'number' // ... } const compositeObjValidator = v(objectSchema) const obj = { a: 'some text', b: 2 } const isObjValid = compositeObjValidator(obj) console.log(isObjValid) // =&gt; true</span></span></code> </pre> <br><p>  Seperti yang Anda lihat, dari batu bata validator berbeda yang ditentukan untuk bidang tertentu, kita dapat mengumpulkan validator objek - beberapa "bangunan kecil", yang masih cukup ramai - tetapi lebih baik daripada tanpa itu.  Untuk ini, kami menggunakan komposer validator <code>v</code> .  <strong>Setiap kali, bertemu objek literal <code>v</code> di tempat validator, itu akan menganggapnya sebagai komposisi objek, mengubahnya menjadi validator objek di bidangnya.</strong> </p><br><p>  Terkadang kami <strong>tidak dapat menjelaskan semua bidang</strong> .  Misalnya, ketika suatu objek adalah kamus data: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quartet = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'quartet'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v = quartet() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isStringValidator = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> name === <span class="hljs-string"><span class="hljs-string">'string'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyValueValidator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, { key }</span></span></span><span class="hljs-function">) =&gt;</span></span> value.length === <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; key.length === <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dictionarySchema= { <span class="hljs-attr"><span class="hljs-attr">dictionaryName</span></span>: isStringValidator, ...v.rest(keyValueValidator) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compositeObjValidator = v(dictionarySchema) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">dictionaryName</span></span>: <span class="hljs-string"><span class="hljs-string">'next letter'</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-string"><span class="hljs-string">'d'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isObjValid = compositeObjValidator(obj) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(isObjValid) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true const obj2 = { dictionaryName: 'next letter', b: 'a', a: 'invalid value', notValidKey: 'a' } const isObj2Valid = compositeObjValidator(obj2) console.log(isObj2Valid) // =&gt; false</span></span></code> </pre> <br><h3 id="kak-pereispolzovat-stroitelnye-resheniya">  Bagaimana cara menggunakan kembali solusi konstruksi? </h3><br><p>  Seperti yang kita lihat di atas, ada kebutuhan untuk menggunakan kembali validator sederhana.  Dalam contoh ini, kami sudah harus menggunakan "validator tipe string" sudah dua kali. </p><br><p>  Untuk mempersingkat catatan dan meningkatkan keterbacaannya, pustaka kuartet menggunakan sinonim string validator.  <strong>Setiap kali komposer validator menemukan string di tempat validator seharusnya, itu mencari kamus untuk validatornya dan menggunakannya</strong> . </p><br><p>  Secara default, validator paling umum sudah ditentukan di perpustakaan. </p><br><p>  Perhatikan contoh-contoh berikut: </p><br><pre> <code class="javascript hljs">v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>)(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true v('number')('1') // =&gt; false v('string')('1') // =&gt; true v('string')(null) // =&gt; false v('null')(null) // =&gt; true v('object')(null) // =&gt; true v('object!')(null) // =&gt; false // ...</span></span></code> </pre> <br><p>  dan banyak lainnya yang dijelaskan dalam <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="dokumentasi">dokumentasi</a></strong> . </p><br><h3 id="kazhdoy-arke---svoy-vid-kirpichey">  Setiap lengkungan memiliki jenis batu bata sendiri? </h3><br><p>  Komposer validator (fungsi <code>v</code> ) juga merupakan pabrik validator.  Dalam artian itu mengandung banyak metode berguna yang kembali </p><br><ul><li>  validator fungsi </li><li>  nilai yang akan dirasakan oleh komposer sebagai skema untuk membuat validator </li></ul><br><p>  Sebagai contoh, mari kita lihat validasi array: paling sering terdiri dari memeriksa tipe array dan memeriksa semua elemennya.  Kami akan menggunakan metode <code>v.arrayOf(elementValidator)</code> untuk ini.  Misalnya, ambil array poin dengan nama. </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [ {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'B'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'C'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'D'</span></span>}, ]</code> </pre> <br><p>  Karena array poin adalah array objek, masuk akal untuk menggunakan komposisi objek untuk memvalidasi elemen array. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> namedPointSchema = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-comment"><span class="hljs-comment">// number -       y: 'number', name: 'string' // string -       }</span></span></code> </pre> <br><p>  Sekarang, menggunakan metode pabrik <code>v.arrayOf</code> , buat validator untuk seluruh array. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isArrayValid = v.arrayOf({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span> })</code> </pre> <br><p>  Mari kita lihat bagaimana validator ini bekerja: </p><br><pre> <code class="javascript hljs">isArrayValid(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; false isArrayValid(null) // =&gt; false isArrayValid([]) // =&gt; true isArrayValid([1, 2, 3]) // =&gt; false isArrayValid([ {x: 1, y: 1, name: 'A'}, {x: 2, y: 1, name: 'B'}, {x: -1, y: 2, name: 'C'}, {x: 1, y: 3, name: 'D'}, ]) // =&gt; true</span></span></code> </pre> <br><p>  Ini hanyalah salah satu metode pabrik, yang masing-masing dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="dokumentasi">dokumentasi.</a> </p><br><p>  Seperti yang Anda lihat di atas, <code>v.rest</code> juga merupakan metode pabrik yang mengembalikan komposisi objek yang memeriksa semua bidang yang tidak ditentukan dalam komposisi objek.  Itu berarti dapat tertanam dalam komposisi objek lain menggunakan <code>spread-operator</code> . </p><br><p>  Mari kita kutip sebagai contoh penggunaan beberapa di antaranya: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    quartet const quartet = require('quartet') //    (v -  validator) const v = quartet() //   ,    const max = { name: 'Maxim', sex: 'male', age: 34, status: 'grandpa', friends: [ { name: 'Dima', friendDuration: '1 year'}, { name: 'Semen', friendDuration: '3 months'} ], workExperience: 2 } //  ,   "" , // ""  , ""   -  const nameSchema = v.and( 'not-empty', 'string', //   name =&gt; name[0].toUpperCase() === name[0] // - ) const maxSchema = { name: nameSchema, //       sex: v.enum('male', 'female'), //  -   . //       "" age: v.and('non-negative', 'safe-integer'), status: v.enum('grandpa', 'non-grandpa'), friends: v.arrayOf({ name: nameSchema, //      friendDuration: v.regex(/^[1-9]\d? (years?|months?)$/) }), workExperience: v.and('non-negative', 'safe-integer') } console.log(v(maxSchema)(max)) // =&gt; true</span></span></code> </pre> <br><h3 id="byt-ili-ne-byt">  Menjadi, atau tidak menjadi? </h3><br><p>  Sering terjadi bahwa data yang valid mengambil berbagai bentuk, misalnya: </p><br><ul><li>  <code>id</code> bisa berupa angka, atau bisa berupa string. </li><li>  Objek <code>point</code> mungkin atau mungkin tidak mengandung beberapa koordinat, tergantung pada dimensi. </li><li>  Dan banyak kasus lainnya. </li></ul><br><p>  Untuk mengatur validasi varian, disediakan jenis komposisi yang berbeda - komposisi varian.  Ini diwakili oleh array validator dari opsi yang memungkinkan.  Suatu objek dianggap valid ketika setidaknya satu validator melaporkan validitasnya. </p><br><p>  Pertimbangkan contoh dengan validasi pengidentifikasi: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isValidId = v([ v.and(<span class="hljs-string"><span class="hljs-string">'not-empty'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>), <span class="hljs-comment"><span class="hljs-comment">//       v.and('positive', 'safe-integer') //    ]) isValidId('') // =&gt; false isValidId('asdba32bas321ab321adb321abds546ba98s7') // =&gt; true isValidId(0) // =&gt; false isValidId(1) // =&gt; true isValidId(1123124) // =&gt; true</span></span></code> </pre> <br><p>  Contoh validasi poin: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPointValid = v([ { <span class="hljs-comment"><span class="hljs-comment">//    -    x  dimension: v.enum(1), x: 'number', // v.rest    false // ,    -  ...v.rest(() =&gt; false) }, //   -    { dimension: v.enum(2), x: 'number', y: 'number', ...v.rest(() =&gt; false) }, //   - x, y  z { dimension: v.enum(3), x: 'number', y: 'number', z: 'number', ...v.rest(() =&gt; false) }, ]) // ,    ,      ,     -  -    isPointValid(1) // =&gt; false isPointValid(null) // =&gt; false isPointValid({ dimension: 1, x: 2 }) // =&gt; true isPointValid({ dimension: 1, x: 2, y: 3 //   }) // =&gt; false isPointValid({ dimension: 2, x: 2, y: 3 }) // =&gt; true isPointValid({ dimension: 3, x: 2, y: 3, z: 4 }) // =&gt; true // ...</span></span></code> </pre> <br><p>  Jadi, <strong>setiap kali seorang komposer melihat sebuah array, ia akan menganggapnya sebagai komposisi elemen validator dari array ini sedemikian rupa sehingga ketika salah satu dari mereka menganggap nilai valid, perhitungan validasi akan berhenti dan nilai tersebut akan diakui sebagai valid.</strong> </p><br><p>  Seperti yang kita lihat, komposer menganggap tidak hanya fungsi validator sebagai validator, tetapi juga segala sesuatu yang dapat mengarah pada fungsi validator. </p><br><table><thead><tr><th>  Jenis Validator </th><th>  Contoh </th><th>  Seperti yang dirasakan oleh komposer </th></tr></thead><tbody><tr><td>  fungsi validasi </td><td> <code>x =&gt; typeof x === 'bigint'</code> </td> <td>  hanya memanggil nilai-nilai yang diperlukan </td></tr><tr><td>  komposisi objek </td><td> <code>{ a: 'number' }</code> </td> <td>  membuat fungsi validator untuk objek berdasarkan validator bidang yang ditentukan </td></tr><tr><td>  Komposisi varian </td><td> <code>['number', 'string']</code> </td> <td>  Membuat fungsi validator untuk memvalidasi nilai dengan setidaknya satu opsi </td></tr><tr><td>  Hasil Panggilan Metode Pabrik </td><td> <code>v.enum('male', 'female')</code> </td> <td>  Sebagian besar metode pabrik mengembalikan fungsi validasi (dengan pengecualian <code>v.rest</code> , yang mengembalikan komposisi objek), sehingga mereka diperlakukan seperti fungsi validasi biasa </td></tr></tbody></table><br><p>  Semua opsi validator ini valid dan dapat digunakan di mana saja dalam skema di mana validator seharusnya berada. </p><br><p>  Akibatnya, skema kerja selalu seperti ini: <code>v(schema)</code> mengembalikan fungsi validasi.  Selanjutnya, fungsi validasi ini dipanggil pada nilai-nilai spesifik: <br> <code>v(schema)(value[, ...parents])</code> </p> <br><h2 id="u-vas-avarii-na-stroyke-byli">  Pernahkah Anda mengalami kecelakaan di lokasi konstruksi? </h2><br><p>  <em>- Belum, belum satu</em> <br>  <em>- Mereka akan!</em> </p><br><p>  Kebetulan data tidak valid dan kami harus dapat menentukan penyebab tidak valid. </p><br><p>  Untuk ini, perpustakaan kuartet menyediakan mekanisme <em>penjelasan</em> .  Terdiri dari fakta bahwa dalam kasus ketika validator, baik internal maupun eksternal, mendeteksi validitas data yang diverifikasi, ia harus mengirim <em>catatan penjelasan</em> . </p><br><p>  Untuk tujuan ini, argumen kedua komposer validator <code>v</code> .  Itu menambahkan efek samping dari mengirim <em>catatan penjelasan</em> ke array <code>v.explanation</code> dalam kasus data tidak valid. </p><br><p>  Contoh, mari kita memvalidasi array, dan ingin mencari tahu jumlah semua elemen yang tidak valid dan nilainya: </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   -     //   const getExplanation = (value, { key: index }) =&gt; ({ invalidValue: value, index }) // ,       . //         v.explanation //    const arrValidator = v.arrayOf( v( 'number', //   getExplanation //   "",   "" ) ) // ,     ""  //     ,     //         //   ,       const explainableArrValidator = v(arrValidator, 'this array is not valid') const arr = [1, 2, 3, 4, '5', '6', 7, '8'] explainableArrValidator(arr) // =&gt; false v.explanation // [ // { invalidValue: '5', index: 4 }, // { invalidValue: '6', index: 5 }, // { invalidValue: '8', index: 7 }, // 'this array is not valid' // ]</span></span></code> </pre> <br><p>  Seperti yang Anda lihat, pilihan penjelasan tergantung pada tugas.  Kadang-kadang bahkan tidak perlu. </p><br><p>  Terkadang kita perlu melakukan sesuatu dengan bidang yang tidak valid.  Dalam kasus seperti itu, masuk akal untuk menggunakan nama bidang yang tidak valid sebagai <em>penjelasan</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> objSchema = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>), <span class="hljs-attr"><span class="hljs-attr">b</span></span>: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>), <span class="hljs-attr"><span class="hljs-attr">c</span></span>: v(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isObjValid = v(objSchema) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> invalidObj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> } isObjValid(invalidObj) <span class="hljs-comment"><span class="hljs-comment">// =&gt; false v.explanation // ['b', 'c'] //     console.error(`${v.explanation.join(', ')} is not valid`) // =&gt; b, c is not valid //       (. ) invalidObj = v.omitInvalidProps(objSchema)(invalidObj) console.log(invalidObj) // =&gt; { a: 1 }</span></span></code> </pre> <br><p>  Dengan mekanisme penjelasan ini, Anda dapat menerapkan perilaku apa pun yang terkait dengan hasil validasi. </p><br><p>  Penjelasan bisa berupa apa saja: </p><br><ul><li>  sebuah objek yang berisi informasi yang diperlukan; </li><li>  fungsi yang memperbaiki kesalahan.  ( <code>getExplanation =&gt; function(invalid): valid</code> ); </li><li>  nama bidang tidak valid, atau indeks elemen tidak valid; </li><li>  kode kesalahan </li><li>  dan semua itu sudah cukup untuk imajinasi Anda. </li></ul><br><h2 id="chto-delat-kogda-delo-ne-stroitsya">  Apa yang harus dilakukan ketika segala sesuatu tidak dibangun? </h2><br><p>  Memperbaiki kesalahan validasi bukanlah tugas yang jarang.  Untuk tujuan ini, perpustakaan menggunakan validator dengan efek samping yang mengingat tempat kesalahan dan cara memperbaikinya. </p><br><ul><li>  <code>v.default(validator, value)</code> - mengembalikan validator yang mengingat nilai yang tidak valid, dan pada saat memanggil <code>v.fix</code> - menetapkan nilai default </li><li>  <code>v.filter(validator)</code> - mengembalikan validator yang mengingat nilai yang tidak valid, dan pada saat memanggil <code>v.fix</code> - menghapus nilai ini dari induknya </li><li>  <code>v.addFix(validator, fixFunc)</code> - mengembalikan validator yang mengingat nilai yang tidak valid, dan pada saat memanggil <code>v.fix</code> - memanggil fixFunc dengan parameter (nilai, {key, parent}, ...).  <code>fixFunc</code> - harus bermutasi salah satu mitra - untuk mengubah nilai </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toPositive = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">negativeValue, { key, parent }</span></span></span><span class="hljs-function">) =&gt;</span></span> { parent[key] = -negativeValue } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> objSchema = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-attr"><span class="hljs-attr">b</span></span>: v.filter(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-attr"><span class="hljs-attr">c</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'array'</span></span>, []), <span class="hljs-attr"><span class="hljs-attr">d</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, invalidValue =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(invalidValue)), <span class="hljs-comment"><span class="hljs-comment">//    pos: v.and( v.default('number', 0), //     -  0 v.addFix('non-negative', toPositive) //     -   ) } const invalidObj = { a: 1, b: 2, c: 3, d: '4', pos: -3 } v.resetExplanation() //   v() v(objSchema)(invalidObj) // =&gt; false // v.hasFixes() =&gt; true const validObj = v.fix(invalidObj) console.log(validObj) // =&gt; { a: 1, b: '', c: [], d: 4 }</span></span></code> </pre> <br><h3 id="po-hozyaystvu-eschyo-prigoditsya">  Pekerjaan masih berguna </h3><br><p>  Ada juga metode utilitas untuk tindakan validasi di perpustakaan ini: </p><br><table><thead><tr><th>  Metode </th><th>  Hasil </th></tr></thead><tbody><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="`v.throwError`"><code>v.throwError</code></a> </td> <td>  Jika tidak valid, lempar TypeError dengan pesan yang diberikan. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="`v.omitInvalidItems`"><code>v.omitInvalidItems</code></a> </td> <td>  Mengembalikan array baru (atau objek kamus) tanpa elemen (bidang) yang tidak valid. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="`v.omitInvalidProps`"><code>v.omitInvalidProps</code></a> </td> <td>  Mengembalikan objek baru tanpa bidang yang tidak valid, sesuai dengan validator objek yang ditentukan. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="`v.validOr`"><code>v.validOr</code></a> </td> <td>  Mengembalikan nilai jika valid, jika tidak maka akan menggantinya dengan nilai default yang ditentukan. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>v.example</code></a> </td> <td>  Cek apakah nilai yang diberikan sesuai dengan skema.  Jika mereka tidak cocok, kesalahan dilemparkan.  Berfungsi sebagai dokumentasi dan pengujian sirkuit </td></tr></tbody></table><br><h2 id="rezultaty">  Hasil </h2><br><p>  Tugas diselesaikan dengan cara-cara berikut: </p><br><table><thead><tr><th>  Tantangan </th><th>  Solusi </th></tr></thead><tbody><tr><td>  Validasi Jenis Data </td><td>  Validator bernama default. </td></tr><tr><td>  Nilai default </td><td> <code>v.default</code> </td> </tr><tr><td>  Menghapus bagian yang tidak valid </td><td>  <code>v.filter</code> , <code>v.omitInvalidItems</code> dan <code>v.omitInvalidProps</code> . </td></tr><tr><td>  Mudah dipelajari </td><td>  Validator sederhana, cara sederhana untuk menyusunnya menjadi validator yang kompleks. </td></tr><tr><td>  Keterbacaan kode </td><td>  Salah satu tujuan perpustakaan adalah menyamakan skema validasi itu sendiri </td></tr><tr><td>  benda yang divalidasi. </td></tr><tr><td>  Kemudahan modifikasi </td><td>  Setelah menguasai elemen komposisi dan menggunakan fungsi validasi Anda sendiri - mengubah kodenya cukup sederhana. </td></tr><tr><td>  Pesan kesalahan </td><td>  Penjelasan dalam bentuk pesan kesalahan.  Atau perhitungan kode kesalahan berdasarkan penjelasan. </td></tr></tbody></table><br><h2 id="posleslovie">  Kata penutup </h2><br><p>  Solusi ini dirancang untuk membuat fungsi validator dengan cepat dan mudah dengan kemampuan untuk menyematkan fungsi validasi khusus.  Karena itu, jika ada, koreksi, kritik, dan opsi perbaikan dari mereka yang membaca artikel ini dipersilakan.  Terima kasih atas perhatian anda <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429916/">https://habr.com/ru/post/id429916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429904/index.html">Cerita lucu dan sedih tentang perkembangan game komputer</a></li>
<li><a href="../id429908/index.html">Cara menggunakan coroutine dalam makanan dan tidur nyenyak di malam hari</a></li>
<li><a href="../id429910/index.html">AppsConf Naik</a></li>
<li><a href="../id429912/index.html">Pengembangan perpustakaan: dari API ke rilis publik</a></li>
<li><a href="../id429914/index.html">OpenSceneGraph: Grafik Adegan dan Pointer Cerdas</a></li>
<li><a href="../id429918/index.html">Intel Dunia Virtual. Bagian 2: SMP</a></li>
<li><a href="../id429920/index.html">Tragicomedy in NaN bertindak: bagaimana kami membuat game di JS dan merilisnya di Steam</a></li>
<li><a href="../id429922/index.html">Bagaimana mengubah proyek sederhana menjadi konstruksi jangka panjang atau memotong semua yang tidak perlu</a></li>
<li><a href="../id429928/index.html">Semua yang perlu Anda ketahui tentang stres dan emosi yang kuat</a></li>
<li><a href="../id429930/index.html">Splunk Pemecahan masalah aplikasi yang mudah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>