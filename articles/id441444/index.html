<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¯ ğŸ‘¼ ğŸš” Di jari: tipe terkait di Rust dan apa perbedaannya dari argumen tipe ğŸš´ğŸ¾ ğŸ“ ğŸ¤³ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengapa Rust memiliki tipe yang terkait, dan apa perbedaan antara mereka dan tipe argumen alias generik, karena mereka sangat mirip? Apakah itu tidak ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Di jari: tipe terkait di Rust dan apa perbedaannya dari argumen tipe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441444/"><p> Mengapa Rust memiliki tipe yang terkait, dan apa perbedaan antara mereka dan tipe argumen alias generik, karena mereka sangat mirip?  Apakah itu tidak cukup hanya yang terakhir, seperti dalam semua bahasa normal?  Bagi mereka yang baru mulai mempelajari Rust, dan terutama bagi orang-orang yang berasal dari bahasa lain ("Ini generik!" - ahli jav, akan mengatakan bertahun-tahun), pertanyaan seperti itu muncul secara teratur.  Mari kita perbaiki. </p><br><p>  TL; DR Yang pertama mengontrol kode yang dipanggil, yang terakhir pemanggil. </p><a name="habracut"></a><br><h3 id="dzheneriki-vs-associirovannye-tipy">  Generik vs tipe terkait </h3><br><p>  Jadi, kami sudah memiliki argumen jenis, atau obat generik favorit semua orang.  Itu terlihat seperti ini: </p><br><pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, x: T); }</code> </pre> <br><p>  Di sini <code>T</code> adalah tipe argumen.  Tampaknya ini harus cukup untuk semua orang (seperti memori 640 kilobyte).  Namun di Rust, ada juga tipe terkait, seperti ini: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//    fn bar(self, x: Self::Bar); }</span></span></code> </pre> <br><p>  Sekilas, telurnya sama, tetapi dari sudut yang berbeda.  Mengapa Anda perlu memperkenalkan entitas lain ke dalam bahasa?  (Omong-omong, yang tidak ada dalam versi awal bahasa.) </p><br><p>  Jenis <strong><em>argumen adalah argumen</em></strong> , yang berarti bahwa mereka diteruskan ke sifat di tempat panggilan, dan kontrol atas jenis yang akan digunakan, bukan <code>T</code> milik pemanggil.  Bahkan jika kita tidak secara eksplisit menentukan <code>T</code> di lokasi panggilan, kompiler akan melakukan ini untuk kita menggunakan inferensi tipe.  Artinya, secara implisit, bagaimanapun, jenis ini akan disimpulkan pada penelepon dan disahkan sebagai argumen.  (Tentu saja, semua ini terjadi selama kompilasi, bukan di runtime.) </p><br><p>  Pertimbangkan sebuah contoh.  Pustaka standar memiliki <code>AsRef</code> AsRef, yang memungkinkan satu jenis berpura-pura menjadi jenis lain untuk sementara waktu, mengubah tautan ke dirinya sendiri menjadi tautan ke sesuatu yang lain.  Sederhana, sifat ini terlihat seperti ini (pada kenyataannya, ini sedikit lebih rumit, saya sengaja menghapus semua yang tidak perlu, hanya menyisakan minimum yang diperlukan untuk memahami): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsRef</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_ref</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;T; }</code> </pre> <br><p>  Di sini tipe <code>T</code> dilewatkan oleh pemanggil sebagai argumen, bahkan jika itu terjadi secara implisit (jika kompiler menyimpulkan jenis ini untuk Anda).  Dengan kata lain, penelepon yang memutuskan tipe <code>T</code> baru mana yang akan berpura-pura menjadi tipe kita yang mengimplementasikan sifat ini: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> foo = Foo::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bar: &amp;Bar = foo.as_ref();</code> </pre> <br><p>  Di sini, kompiler, menggunakan pengetahuan <code>bar: &amp;Bar</code> , akan menggunakan <code>AsRef&lt;Bar&gt;</code> untuk memanggil metode <code>as_ref()</code> , karena itu adalah jenis <code>Bar</code> yang diperlukan oleh pemanggil.  Tak perlu dikatakan bahwa tipe <code>Foo</code> harus menerapkan sifat AsRef <code>AsRef&lt;Bar&gt;</code> , dan di samping itu, ia dapat menerapkan <code>AsRef&lt;T&gt;</code> lainnya, di antaranya penelepon memilih yang diinginkan. </p><br><p>  Dalam hal tipe terkait, semuanya justru sebaliknya.  Jenis terkait sepenuhnya dikendalikan oleh mereka yang menerapkan sifat ini, dan bukan oleh penelepon. </p><br><p>  Contoh umum adalah iterator.  Misalkan kita memiliki koleksi, dan kita ingin mendapatkan iterator darinya.  Apa jenis nilai yang harus dikembalikan oleh iterator?  Persis yang terkandung dalam koleksi ini!  Tidak tergantung pada penelepon untuk memutuskan apa yang akan dikembalikan oleh iterator, dan iterator sendiri lebih tahu <em>apa sebenarnya yang</em> ia tahu bagaimana mengembalikannya.  Berikut adalah kode singkatan dari perpustakaan standar: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::Item&gt;; }</code> </pre> <br><p>  Perhatikan bahwa iterator tidak memiliki parameter tipe yang memungkinkan pemanggil untuk memilih apa yang harus dikembalikan oleh iterator.  Sebagai gantinya, tipe nilai yang dikembalikan dari metode <code>next()</code> ditentukan oleh iterator itu sendiri menggunakan tipe yang terkait, tetapi tidak terjebak dengan paku, mis.  setiap implementasi iterator dapat memilih tipenya. </p><br><p>  Berhenti  Jadi apa  Semua sama, tidak jelas mengapa ini lebih baik daripada obat generik.  Bayangkan sejenak bahwa kita menggunakan generik biasa, bukan tipe terkait.  Ciri iterator kemudian akan terlihat seperti ini: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericIterator</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;T&gt;; }</code> </pre> <br><p>  Tetapi sekarang, pertama, tipe <code>T</code> perlu diindikasikan berulang kali di setiap tempat di mana iterator disebutkan, dan kedua, sekarang telah menjadi mungkin untuk menerapkan sifat ini beberapa kali dengan tipe yang berbeda, yang bagi iterator terlihat agak aneh.  Berikut ini sebuah contoh: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyIterator</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> GenericIterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyIterator { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> GenericIterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyIterator { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> iter = MyIterator; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lolwhat: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;_&gt; = iter.next(); <span class="hljs-comment"><span class="hljs-comment">// Error! Which impl of GenericIterator to use? }</span></span></code> </pre> <br><p>  Lihat tangkapannya?  Kami tidak bisa menerima dan memanggil <code>iter.next()</code> tanpa squat - kami perlu memberi tahu kompiler, secara eksplisit atau implisit, jenis apa yang akan dikembalikan.  Dan itu terlihat canggung: mengapa kita, di sisi panggilan, tahu (dan memberi tahu kompiler!) Jenis iterator akan kembali, sementara iterator ini harus tahu lebih baik apa jenisnya kembali ?!  Dan semua karena kami dapat mengimplementasikan <code>GenericIterator</code> GenericIterator dua kali dengan parameter yang berbeda untuk <code>MyIterator</code> sama, yang dari sudut pandang semantik iterator juga terlihat konyol: mengapa iterator yang sama dapat mengembalikan nilai dari jenis yang berbeda? </p><br><p>  Jika kita kembali ke varian dengan tipe terkait, maka semua masalah ini dapat dihindari: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyIter</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyIter { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span> = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::Item&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> iter = MyIter; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = iter.next(); }</code> </pre> <br><p>  Di sini, pertama, kompiler akan menampilkan <code>value: Option&lt;String&gt;</code> dengan benar <code>value: Option&lt;String&gt;</code> tipe <code>value: Option&lt;String&gt;</code> tanpa kata-kata yang tidak perlu, dan kedua, itu tidak akan bekerja untuk menerapkan <code>MyIter</code> <code>Iterator</code> untuk <code>MyIter</code> untuk kedua kalinya dengan jenis pengembalian yang berbeda, dan dengan demikian merusak segalanya. </p><br><p>  Untuk memperbaiki.  Koleksi dapat menerapkan sifat tersebut untuk dapat mengubah dirinya menjadi iterator: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntoIterator</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntoIter</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>&lt;Item=Self::Item&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">into_iter</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Self::IntoIter; }</code> </pre> <br><p>  Dan lagi, ini dia koleksi yang menentukan iterator mana yang akan dipilih, yaitu: sebuah iterator yang tipe pengembaliannya cocok dengan jenis elemen dalam koleksi itu sendiri, dan tidak ada yang lain. </p><br><h3 id="eschyo-bolee-na-palcah">  Lebih banyak di jari </h3><br><p>  Jika contoh-contoh di atas masih tidak dapat dipahami, maka di sini ada penjelasan yang bahkan kurang ilmiah tetapi lebih dapat dipahami.  Ketik argumen dapat dianggap sebagai informasi "masukan" yang kami berikan agar sifat tersebut berfungsi.  Jenis terkait dapat dianggap sebagai informasi "keluaran" yang disediakan oleh sifat tersebut sehingga kami dapat menggunakan hasil pekerjaannya. </p><br><p>  Perpustakaan standar memiliki kemampuan untuk membebani operator matematika untuk jenisnya (penambahan, pengurangan, perkalian, pembagian, dan sejenisnya).  Untuk melakukan ini, Anda perlu menerapkan salah satu sifat yang sesuai dari perpustakaan standar.  Di sini, misalnya, bagaimana sifat ini terlihat untuk operasi penambahan (sekali lagi, disederhanakan): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Add</span></span></span></span>&lt;RHS&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, rhs: RHS) -&gt; Self::Output; }</code> </pre> <br><p>  Di sini kita memiliki argumen "input" <code>RHS</code> - ini adalah tipe yang akan kita terapkan operasi penambahan dengan tipe kita.  Dan ada argumen "output" <code>Add::Output</code> - ini adalah jenis yang akan dihasilkan dari penambahan.  Dalam kasus umum, ini bisa berbeda dari jenis istilah, yang, pada gilirannya, juga bisa dari jenis yang berbeda (menambah enak dengan warna biru dan menjadi lunak - tapi apa, saya melakukan ini sepanjang waktu).  Yang pertama ditentukan menggunakan argumen tipe, yang kedua ditentukan menggunakan tipe yang terkait. </p><br><p>  Anda dapat mengimplementasikan sejumlah tambahan apa pun dengan berbagai jenis argumen kedua, tetapi setiap kali hanya akan ada satu jenis hasil, dan itu ditentukan oleh penerapan penambahan ini. </p><br><p>  Mari kita coba terapkan sifat ini: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>); <span class="hljs-meta"><span class="hljs-meta">#[derive(PartialEq, Debug)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span></span>(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Foo { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Bar; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, rhs: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; Bar { Bar(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, rhs) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = Foo(<span class="hljs-string"><span class="hljs-string">"test"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = x + <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      &lt;Foo as Add&gt;::add(42)  x assert_eq!(y, Bar("test", 42)); }</span></span></code> </pre> <br><p>  Dalam contoh ini, tipe variabel <code>y</code> ditentukan oleh algoritma penjumlahan, bukan kode panggilan.  Akan sangat aneh jika ada kemungkinan untuk menulis sesuatu seperti <code>let y: Baz = x + 42</code> , yaitu, memaksa operasi penjumlahan untuk mengembalikan hasil dari beberapa tipe yang asing.  Dari hal-hal seperti itulah tipe terkait <code>Add::Output</code> menjamin kami. </p><br><h3 id="itogo">  Total </h3><br><p>  Kami menggunakan obat generik di mana kami tidak keberatan memiliki beberapa implementasi sifat untuk jenis yang sama, dan di mana dapat diterima untuk menentukan implementasi spesifik pada sisi panggilan.  Kami menggunakan tipe terkait di mana kami ingin memiliki satu implementasi "kanonik", yang mengontrol jenisnya sendiri.  Gabungkan dan campur dalam proporsi yang tepat, seperti pada contoh terakhir. </p><br><p>  Apakah koin itu gagal?  Bunuh aku dengan komentar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441444/">https://habr.com/ru/post/id441444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441428/index.html">Dasar-Dasar PowerShell: Menentukan Akhir Garis dengan Karakter Tertentu</a></li>
<li><a href="../id441430/index.html">Pertama kali kami mencoba App Center dan menceritakan pengalaman kami</a></li>
<li><a href="../id441436/index.html">Para ilmuwan telah menumbuhkan sel induk universal menggunakan teknik CRISPR</a></li>
<li><a href="../id441438/index.html">Layanan Terpadu goszakup.gov.kz - Versi 2</a></li>
<li><a href="../id441442/index.html">YouTube telah menonaktifkan iklan anti-vaksin</a></li>
<li><a href="../id441446/index.html">Belajar Komputer: Cara Mendapatkan Keterampilan Baru</a></li>
<li><a href="../id441448/index.html">Panci mustahil dan ubin Penrose lainnya menang</a></li>
<li><a href="../id441450/index.html">Pentesting Azure - Pikiran tentang Keamanan dalam Cloud Computing</a></li>
<li><a href="../id441452/index.html">Tiga ekstensi reaktif zen</a></li>
<li><a href="../id441454/index.html">NASA memperingatkan SpaceX dan Boeing tentang kekurangan di pesawat ruang angkasa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>