<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÖ∞Ô∏è üê£ üèÄ Detecci√≥n de bordes en tiempo real usando FPGA üéôÔ∏è ‚óæÔ∏è üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 


 Nuestro proyecto implementa un sistema de detecci√≥n de bordes en tiempo real basado en la captura de cuadros de imagen de una c√°mara ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Detecci√≥n de bordes en tiempo real usando FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431326/"><h2 id="introduction">  Introduccion </h2><br><p>  Nuestro proyecto implementa un sistema de detecci√≥n de bordes en tiempo real basado en la captura de cuadros de imagen de una c√°mara OV7670 y su transmisi√≥n a un monitor VGA despu√©s de aplicar un filtro de escala de grises y un operador Sobel.  Nuestro dise√±o se basa en una placa FPGA Cyclone IV que nos permite optimizar el rendimiento utilizando las potentes funciones del hardware de bajo nivel y los c√°lculos paralelos, lo cual es importante para cumplir con los requisitos del sistema en tiempo real. </p><br><p>  Utilizamos la placa de desarrollo ZEOWAA FPGA que se basa en Cyclone IV (EP4CE6E22C8N).  Adem√°s, utilizamos Quartus Prime Lite Edition como entorno de desarrollo y Verilog HDL como lenguaje de programaci√≥n.  Adem√°s, utilizamos la interfaz VGA incorporada para controlar el monitor VGA y GPIO (pines generales de entrada y salida) para conectar el hardware externo con nuestra placa. </p><br><p><img src="https://habrastorage.org/webt/j4/0g/l0/j40gl0a_funpi7k3om89bkjy2xc.png" alt="Junta de desarrollo FPGA de ZEOWAA"></p><a name="habracut"></a><br><h2 id="architecture">  Arquitectura </h2><br><p>  Nuestro dise√±o se divide en 3 partes principales: </p><br><ol><li>  Lectura de los p√≠xeles de datos de la c√°mara. </li><li>  Implementando nuestro algoritmo de detecci√≥n de bordes (convertidor de escala de grises y operador de Sobel). </li><li>  Visualizaci√≥n de la imagen final mediante la interfaz con un monitor VGA. </li></ol><br><p>  Adem√°s, hay un almacenamiento de memoria intermedio entre leer / escribir los datos y operar con estos datos.  Para este prop√≥sito, implementamos dos buffers que funcionan como espacio temporal para p√≠xeles antes de que se usen. </p><br><p><img src="https://habrastorage.org/webt/-m/ra/4n/-mra4ni51g8heajqfmzauskcbtu.jpeg" alt="La arquitectura implementada"></p><br><p>  Tenga en cuenta que despu√©s de tomar el p√≠xel de la c√°mara, no lo almacenamos directamente en el b√∫fer de memoria intermedia.  En cambio, lo convertimos a la escala de grises y luego lo almacenamos en el b√∫fer.  Esto se debe a que el almacenamiento de p√≠xeles en escala de grises de 8 bits requiere menos memoria que el almacenamiento de los p√≠xeles coloreados que son de 16 bits.  Adem√°s, tenemos otro b√∫fer que almacena los datos despu√©s de aplicar el operador Sobel para que est√©n listos para mostrarse en el monitor. </p><br><p>  Aqu√≠ est√°n los detalles sobre la implementaci√≥n de nuestra arquitectura: </p><cut></cut><br><h5 id="camera">  C√°mara </h5><br><p>  Utilizamos la c√°mara OV7670, que es uno de los m√≥dulos de c√°mara m√°s baratos que encontramos.  Adem√°s, esta c√°mara puede funcionar con 3.3V y no necesita protocolos de comunicaci√≥n dif√≠ciles como I2c o SPI para extraer los datos de la imagen.  Solo requiere una interfaz SCCB que sea similar a la interfaz I2c para establecer la configuraci√≥n de la c√°mara en t√©rminos de formato de color (RGB565, RGB555, YUV, YCbCr 4: 2: 2), resoluci√≥n (VGA, QVGA, QQVGA, CIF, QCIF) y muchos otros ajustes. </p><br><p><img src="https://habrastorage.org/webt/hj/47/uk/hj47ukzo4cqixn0tyzwegoerumg.jpeg" alt="M√≥dulo de c√°mara OV7670"></p><br><p>  El video consta de cuadros que se est√°n cambiando a una velocidad espec√≠fica.  Un cuadro es una imagen que consta de filas y columnas de p√≠xeles donde cada p√≠xel est√° representado por valores de color.  En este proyecto, utilizamos la configuraci√≥n predeterminada de la c√°mara donde el tama√±o del marco es la resoluci√≥n VGA 640 x 480 (0.3 Megapixels), y el formato de color del p√≠xel es RGB565 (5 bits para Rojo, 6 bits para Azul, 5 bits para Verde ) y la tasa de cambio de fotogramas es de 30 fps. </p><br><p>  A continuaci√≥n, las conexiones de la c√°mara a la FPGA utilizando el GPIO que existe en la placa de desarrollo: </p><br><table><thead><tr><th>  Pin en la c√°mara </th><th>  pin en el FPGA </th><th>  Descripci√≥n </th><th>  Pin en la c√°mara </th><th>  pin en el FPGA </th><th>  Descripci√≥n </th></tr></thead><tbody><tr><td>  3.3V </td><td>  3.3V </td><td>  Fuente de alimentaci√≥n (+) </td><td>  GND </td><td>  GND </td><td>  Nivel de suministro de tierra (-) </td></tr><tr><td>  Sdioc </td><td>  GND </td><td>  Reloj SCCB </td><td>  SDIOD </td><td>  GND </td><td>  Datos SCCB </td></tr><tr><td>  VSYNC </td><td>  P31 </td><td>  Sincronizaci√≥n vertical </td><td>  Href </td><td>  P55 </td><td>  Sincronizaci√≥n horizontal </td></tr><tr><td>  PCLK </td><td>  P23 </td><td>  Reloj de p√≠xeles </td><td>  Xclk </td><td>  P54 </td><td>  Sistema de entrada de reloj (25 MHz) </td></tr><tr><td>  D7 </td><td>  P46 </td><td>  Octavo bit de datos </td><td>  D6 </td><td>  P44 </td><td>  S√©ptimo bit de datos </td></tr><tr><td>  D5 </td><td>  P43 </td><td>  6to bit de datos </td><td>  D4 </td><td>  P42 </td><td>  5to bit de datos </td></tr><tr><td>  D3 </td><td>  P39 </td><td>  4to bit de datos </td><td>  D2 </td><td>  P38 </td><td>  3er bit de datos </td></tr><tr><td>  D1 </td><td>  P34 </td><td>  2do bit de datos </td><td>  D0 </td><td>  P33 </td><td>  1er bit de datos </td></tr><tr><td>  RESET (activo bajo) </td><td>  3.3V </td><td>  Restablecer pin </td><td>  PWDN </td><td>  GND </td><td>  Pin de apagado </td></tr></tbody></table><br><p>  Tenga en cuenta que no utilizamos la interfaz SCCB para la configuraci√≥n.  Entonces, colocamos sus cables correspondientes en el suelo para evitar cualquier se√±al flotante que pueda afectar los datos. </p><br><p>  Para proporcionar el reloj de 25MHz para la c√°mara, utilizamos el bucle de fase bloqueada (PLL), que es un sistema de control de frecuencia de bucle cerrado para proporcionar el reloj necesario desde los 50MHz proporcionados desde la placa.  Para implementar el PLL, utilizamos la herramienta interna del cat√°logo de IP dentro del software Quartus. </p><cut></cut><br><p>  Esta c√°mara utiliza la se√±al de sincronizaci√≥n vertical (VSYNC) para controlar el proceso de env√≠o del cuadro y la se√±al de sincronizaci√≥n horizontal (HREF) para controlar el env√≠o de cada fila del cuadro.  Esta c√°mara usa solo 8 l√≠neas de datos (D0-D7) para transferir los bits que representan los valores de color del p√≠xel, ya que la c√°mara divide el valor de p√≠xel RGB de 16 bits en 2 partes (8 bits) y env√≠a cada una por separado. </p><br><p>  Las siguientes figuras de la hoja de datos del m√≥dulo de c√°mara OV7670 ilustran las se√±ales de sincronizaci√≥n vertical y horizontal. </p><br><p><img src="https://habrastorage.org/webt/vu/9-/nr/vu9-nr2blv5dnrfezs1dsuja8ns.png" alt="VGA Frame Timing"></p><br><p><img src="https://habrastorage.org/webt/q8/bb/nj/q8bbnji2ajbs3nxklpstw55mip8.png" alt="Sincronizaci√≥n horizontal"></p><br><p><img src="https://habrastorage.org/webt/sr/qt/5n/srqt5n3eoriiopfeq0icnpnf4z0.png" alt="Diagrama de temporizaci√≥n de salida RGB565"></p><br><h5 id="grayscale-converter">  Convertidor de escala de grises </h5><br><p>  Para producir una imagen en escala de grises a partir de su imagen en color original, se deben tener en cuenta muchos factores, ya que la imagen puede perder contraste, nitidez, sombra y estructura.  Adem√°s, la imagen debe preservar la luminancia relativa del espacio de color.  Se utilizan varias t√©cnicas lineales y no lineales para convertir la imagen en color a escala de grises.  En consecuencia, para lograr nuestro objetivo, utilizamos la conversi√≥n colorim√©trica (preservaci√≥n de la luminancia perceptiva) a escala de grises representada en la siguiente ecuaci√≥n: </p><br><p><img src="https://habrastorage.org/webt/xo/na/bk/xonabkl8jpwg5zixxk9yl6hr8lw.png"></p><br><p>  Para mejorar el rendimiento en t√©rminos de c√°lculos, es m√°s r√°pido usar el operador de turno.  Por lo tanto, la ecuaci√≥n anterior se puede reducir a lo siguiente: </p><cut></cut><br><p><img src="https://habrastorage.org/webt/sm/6s/nr/sm6snrzc5z7nem3fsgamwy81xis.png"></p><br><p>  Como resultado, despu√©s de capturar un valor de p√≠xel (565 RGB) de la c√°mara, se puede convertir inmediatamente en un valor de p√≠xel en escala de grises de 8 bits aplicando la f√≥rmula de conversi√≥n.  La imagen en escala de grises es m√°s f√°cil de almacenar en la memoria y lo suficientemente r√°pida como para servir a la funcionalidad de nuestro sistema en tiempo real, ya que su complejidad es aproximadamente logar√≠tmica y FPGA puede hacerlo a√∫n m√°s r√°pido al acceder a la memoria en paralelo.  Despu√©s de eso, la imagen almacenada est√° lista para implementar el algoritmo de detecci√≥n de bordes. </p><br><h5 id="intermediate-memory-the-buffer">  Memoria intermedia (el b√∫fer) </h5><br><p>  Tenemos 2 buffers, el primero se usa para almacenar los p√≠xeles despu√©s de convertirlos a escala de grises y su tama√±o (8 bits x 150 x 150) y el segundo se usa para almacenar los p√≠xeles despu√©s de aplicar el operador Sobel y el umbral para el valor de salida y su tama√±o (1 bit x 150 x 150).  Desafortunadamente, las memorias intermedias de 150 x 150 no almacenan toda la imagen de la c√°mara, sino que solo almacenan parte de ella. </p><br><p>  Hemos elegido el tama√±o de nuestras memorias intermedias como 150 x 150 debido a la limitaci√≥n de la memoria del cicl√≥n IV, ya que solo tiene 276.480 Kbit, mientras que nuestras dos memorias intermedias toman 202.500 Kbit (150 x 150 x 9), lo que equivale al 73.24% de la memoria original de El cicl√≥n IV y el resto de la memoria se utilizan para almacenar el algoritmo y la arquitectura.  Adem√°s, probamos (170 x 170) como un tama√±o para nuestros b√∫feres que toma el 94.07% de la memoria que no deja suficiente espacio para implementar el algoritmo. </p><cut></cut><br><p>  Nuestros buffers son verdaderos RAM de doble puerto que pueden leer y escribir en diferentes ciclos de reloj simult√°neamente.  Aqu√≠, creamos nuestra implementaci√≥n en lugar de utilizar la herramienta de cat√°logo de IP dentro del software Quartus para tener m√°s flexibilidad en la implementaci√≥n.  Adem√°s, integramos ambas memorias intermedias en un solo m√≥dulo en lugar de tener m√≥dulos diferentes. </p><br><h5 id="sobel-operator">  Operador Sobel </h5><br><p>  Utilizamos un primer operador de detecci√≥n de bordes derivado que es un operador de gradiente de √°rea de matriz que determina el cambio de luminancia entre diferentes p√≠xeles.  Para ser m√°s precisos, ya que es un m√©todo sencillo y eficiente en t√©rminos de uso de memoria y complejidad de tiempo, utilizamos el operador de gradiente Sobel que usa un n√∫cleo de 3x3 centrado en un p√≠xel elegido para representar la fuerza del borde.  El operador Sobel es la magnitud del gradiente calculada por: </p><br><p><img src="https://habrastorage.org/webt/1e/-8/aj/1e-8ajvp7o58vzzhc6d5euzljfa.png" alt="Ecuaci√≥n G"></p><br><p>  Donde Gx y Gy pueden representarse usando m√°scaras de convoluci√≥n: </p><br><p><img src="https://habrastorage.org/webt/gq/3e/tb/gq3etbpr2ioaxrpzgmtbk8p0ppg.png" alt="Matrices de convoluci√≥n Gx y Gy"></p><cut></cut><br><p>  Tenga en cuenta que los p√≠xeles que est√°n m√°s cerca del centro de la m√°scara tienen m√°s peso.  Adem√°s, G <sub>x</sub> y G <sub>y</sub> se pueden calcular de la siguiente manera: </p><br><p><img src="https://habrastorage.org/webt/ji/wt/us/jiwtusibcq8rngnqe3hvy3kbzgu.png" alt="Ecuaciones gx y gy"></p><br><p>  Donde p <sub>i</sub> es el p√≠xel correspondiente en la siguiente matriz, y el valor de p <sub>i</sub> es un valor de escala de grises de 8 bits: </p><br><p><img src="https://habrastorage.org/webt/-0/cd/4s/-0cd4stky-xqnhkaeulsuvujbam.png" alt="matriz de p√≠xeles"></p><br><p>  Es una pr√°ctica com√∫n aproximar la magnitud del gradiente del operador Sobel por valores absolutos: </p><br><p><img src="https://habrastorage.org/webt/jq/ga/tr/jqgatrro-agy4-hdyu_92umzdgi.png" alt="la ecuaci√≥n"></p><br><p>  Esta aproximaci√≥n es m√°s f√°cil de implementar y m√°s r√°pida de calcular, lo que nuevamente sirve a nuestra funcionalidad en t√©rminos de tiempo y memoria. </p><br><p>  Aqu√≠ est√° el diagrama de bloques del operador Sobel que toma 9 p√≠xeles (8 bits) como entrada y produce un valor de p√≠xel (8 bits): </p><cut></cut><br><p><img src="https://habrastorage.org/webt/l4/eg/9w/l4eg9warlvign4ibbjq3ptcuvg4.jpeg" alt="N√∫cleo Sobel"></p><br><p>  Y aqu√≠ est√° el diagrama de bloques detallado de la implementaci√≥n del operador Sobel. </p><br><p><img src="https://habrastorage.org/webt/tg/0o/pg/tg0opgzckrosd2eaanar-jisy14.jpeg" alt="N√∫cleo Sobel detallado"></p><br><h5 id="vga-monitor">  Monitor vga </h5><br><p>  Nuestra placa de desarrollo tiene una interfaz VGA incorporada que tiene la capacidad de mostrar solo 8 colores en el monitor VGA, ya que solo tiene 3 bits para controlar los colores a trav√©s de un bit para Rojo, uno para Verde y otro para Azul.  Esto ha dificultado nuestra depuraci√≥n ya que nos impide mostrar la imagen de la c√°mara directamente al monitor.  Entonces, usamos un umbral para convertir los p√≠xeles en un valor de 1 bit para que sea posible mostrar la imagen. </p><br><p>  La interfaz VGA funciona como la c√°mara, ya que funciona p√≠xel por p√≠xel desde la esquina superior izquierda hasta la esquina inferior derecha.  Usando la sincronizaci√≥n vertical y horizontal, podemos sincronizar las se√±ales que controlan el flujo de p√≠xeles. </p><br><p>  La se√±al de sincronizaci√≥n vertical se usa para representar el √≠ndice de la fila, mientras que la se√±al de sincronizaci√≥n horizontal se usa para representar el √≠ndice de la columna.  Adem√°s, ambas se√±ales usan el porche delantero, el pulso de sincronizaci√≥n y el porche trasero como se√±ales de sincronizaci√≥n para separar la fila anterior de la fila nueva en la se√±al de sincronizaci√≥n horizontal, y el cuadro antiguo del nuevo cuadro en la se√±al de sincronizaci√≥n vertical. </p><cut></cut><br><p><img src="https://habrastorage.org/webt/uv/3f/gv/uv3fgvrj_y9yuabjdhuxhvek0ak.png" alt="Diagrama de sincronizaci√≥n de se√±al VGA"></p><br><p>  Utilizamos la interfaz de se√±al VGA est√°ndar (640 x 480 a 60 MHz).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> se describen todas las especificaciones est√°ndar de la se√±al. </p><br><h2 id="testing">  Prueba </h2><br><p>  Antes de armar todo y probar el sistema en tiempo real.  Primero tuvimos que probar cada parte por separado.  Al principio, verificamos los valores y las se√±ales que provienen de la c√°mara al mostrar ciertos valores de p√≠xeles.  Luego, con la ayuda de OpenCV usando el lenguaje de programaci√≥n Python, pudimos aplicar el filtro Sobel en varias im√°genes para comparar los resultados con nuestro algoritmo y verificar la correcci√≥n de nuestra l√≥gica.  Adem√°s, probamos nuestros buffers y el controlador VGA al mostrar varias im√°genes est√°ticas en el monitor VGA despu√©s de aplicar el operador Sobel y el umbral.  Adem√°s, al cambiar el valor del umbral, la precisi√≥n de la imagen se ve afectada. </p><cut></cut><br><p>  El c√≥digo de Python que usamos: </p><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># This code is made to test the accuracy of our algorithm on FPGA import cv2 #import opencv library f = open("sample.txt",'w') # Open file to write on it the static image initialization lines img = cv2.imread('us.jpg') # Read the image which has our faces and its size 150x150 gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #convert to grayscale sobelx = cv2.Sobel(gray,cv2.CV_64F,1,0,ksize=3) #x-axis sobel operator sobely = cv2.Sobel(gray,cv2.CV_64F,0,1,ksize=3) #y-axis sobel operator abs_grad_x = cv2.convertScaleAbs(sobelx) abs_grad_y = cv2.convertScaleAbs(sobely) grad = abs_grad_x + abs_grad_y for i in range(0,150): for x in range(0,150): #read the pixels of the grayscaled image and Store them into file with specific format to initialize the buffer in FPGA code f.write("data_a[{:d}]&lt;=8'd{:d};\n".format(i*150+x,gray[i][x])) #apply threshold to be exactly like the code on FPGA if(grad[i][x] &lt; 100): grad[i][x] = 255 else: grad[i][x] = 0 cv2.imshow("rgb", img) #Show the real img cv2.imshow("gray",gray) #Show the grayscale img cv2.imshow("sobel",grad)#Show the result img cv2.waitKey(0) #Stop the img to see it</span></span></code> </pre> <cut></cut><br><h2 id="results">  Resultados </h2><br><p>  Como resultado de nuestra implementaci√≥n, obtuvimos un sistema de detecci√≥n de bordes en tiempo real que produce una imagen de 150x150 despu√©s de aplicar el filtro de escala de grises y el operador Sobel.  El sistema implementado proporciona 30 fps.  La c√°mara funciona con un reloj de 25MHz y el sistema, en general, cumple con los plazos en tiempo real sin retraso notable.  Adem√°s, el valor umbral puede afectar la cantidad de detalles y el ruido en la imagen final. </p><br><p>  Aqu√≠ hay una comparaci√≥n entre el operador Sobel en FPGA y el operador Sobel OpenCV: </p><br><p><img src="https://habrastorage.org/webt/pg/sl/rc/pgslrcclisueu2qpfghaav-yju8.png" alt="Comparaci√≥n"></p><br><p>  A continuaci√≥n se muestra un video ilustrativo de los resultados: </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/3a5/ea2/d49/3a5ea2d49eeb6e23f9ca4a64921d287a.jpg" alt="Video del proyecto"></a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> est√° el enlace del repositorio en Github que tiene todos los c√≥digos fuente. </p><br><h2 id="future-improvements">  Mejoras futuras </h2><br><p>  Como estamos usando FPGA Cyclone IV, estamos limitados a su capacidad de memoria y al n√∫mero de puertas l√≥gicas.  Por lo tanto, como una mejora futura, podemos usar una fuente de memoria externa o podemos implementar nuestro trabajo en otra placa para que podamos mostrar todos los p√≠xeles de la imagen recibida de la c√°mara. </p><br><p>  Adem√°s, aunque el operador Sobel es r√°pido y sencillo de implementar, es notablemente sensible al ruido.  Para eliminar el ruido producido, podemos usar un filtro de ruido como el filtro mediano no lineal que funciona perfectamente bien con nuestro sistema si tuvi√©ramos suficiente memoria para implementar un tercer b√∫fer.  Esto producir√° una imagen m√°s suave con caracter√≠sticas n√≠tidas eliminadas. </p><br><p>  En consecuencia, utilizamos la interfaz VGA integrada de la FPGA que solo puede producir una imagen de 3 bits.  Por lo tanto, no pudimos mostrar la imagen en escala de grises ya que necesita 8 bits para mostrarse.  Como resultado, la implementaci√≥n de otra interfaz o el uso de una placa m√°s potente mejorar√° la flexibilidad de mostrar la imagen. </p><cut></cut><br><h2 id="conclusion">  Conclusi√≥n </h2><br><p>  Pudimos usar nuestro conocimiento y comprensi√≥n de conceptos cruciales en sistemas embebidos como m√°quinas de estado, paralelismo de c√≥mputos e interfaz de hardware y software para crear una aplicaci√≥n eficiente de detecci√≥n de bordes que cumpla con nuestros objetivos. </p><br><h2 id="acknowledgment">  Acuse de recibo </h2><br><p>  Este proyecto est√° construido por un equipo compuesto por dos estudiantes: <strong>Hussein Youness</strong> y <strong>Hany Hamed</strong> en el primer a√±o de licenciatura en Ciencias de la Computaci√≥n en la <strong>Universidad de Innopolis</strong> en Rusia. </p><br><p>  Este proyecto es parte del curso de <strong>Arquitectura</strong> de <strong>Computadores</strong> Oto√±o 2018 en la <strong>Universidad de Innopolis</strong> . </p><br><div class="spoiler">  <b class="spoiler_title">Referencias</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://eu.mouser.com/ProductDetail/Intel-Altera/EP4CE6E22C8N?qs=jblrfmjbeiF2FLmcokX%252bDw%3D%3D</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.voti.nl/docs/OV7670.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://embeddedprogrammer.blogspot.com/2012/07/hacking-ov7670-camera-module-sccb-cheat.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.intel.com/content/www/us/en/programmable/support/support-resources/operation-and-testing/pll-and-clock-management/pll-basics.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://knowledge.ni.com/KnowledgeArticleDetails?id=kA00Z000000P9T3SAK</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/ug/ug_megafunction_overview.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/ug/ug_ram_rom.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://www.cse.usf.edu/~r1k/MachineVisionBook/MachineVision.files/MachineVision_Chapter5.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.digikey.com/eewiki/pages/viewpage.action?pageId=15925278</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://tinyvga.com/vga-timing/640x480@60Hz</a> </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431326/">https://habr.com/ru/post/es431326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431316/index.html">Votaci√≥n en la segunda versi√≥n beta del Informe revisado 7 sobre el esquema de lenguaje algor√≠tmico (lenguaje grande)</a></li>
<li><a href="../es431318/index.html">Python transpiler chain ‚Üí 11l ‚Üí C ++ [para acelerar el c√≥digo Python y m√°s]</a></li>
<li><a href="../es431320/index.html">Estudio IFR: el n√∫mero de robots industriales en Rusia sigue siendo insignificante</a></li>
<li><a href="../es431322/index.html">Iteraciones del ciclo: c√≥mo fue la conferencia HolyJS y qu√© pasa con la pr√≥xima</a></li>
<li><a href="../es431324/index.html">Microsoft ofrece una alternativa a los caracteres personalizados</a></li>
<li><a href="../es431328/index.html">Kotlin, IT en Estonia y (de repente) el t√∫nel entre Tallin y Helsinki: una entrevista con Anton Keks</a></li>
<li><a href="../es431330/index.html">Fin de semana m√≥vil: transmisi√≥n gratuita de Mobius</a></li>
<li><a href="../es431332/index.html">Descripci√≥n general de los informes DotNext 2018 m√°s interesantes: versi√≥n de EastBanc Technologies</a></li>
<li><a href="../es431334/index.html">Huawei: protecci√≥n del plano de control</a></li>
<li><a href="../es431338/index.html">El libro "ADN. La historia de la revoluci√≥n gen√©tica "</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>