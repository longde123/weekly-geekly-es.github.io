<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏼 😦 🏛️ ILV-Sperren mit DNSTap und BGP umgehen 🤾🏼 🛡️ 👩‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Thema ist ziemlich aus dem Bilde, ich weiß. Zum Beispiel gibt es einen ausgezeichneten Artikel , aber dort wird nur der IP-Teil der Sperrliste ber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ILV-Sperren mit DNSTap und BGP umgehen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467547/"><p><img src="https://habrastorage.org/webt/zg/if/qq/zgifqqqqol7bai9dlh3_e-3cgn8.png"></p><br><p>  Das Thema ist ziemlich aus dem Bilde, ich weiß.  Zum Beispiel gibt es einen ausgezeichneten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> , aber dort wird nur der IP-Teil der Sperrliste berücksichtigt.  Wir werden auch Domains hinzufügen. </p><br><p>  Aufgrund der Tatsache, dass die Gerichte und ILV alles rechts und links blockieren und die Anbieter sich bemühen, nicht unter die von „Revizorro“ verhängten Geldbußen zu fallen, sind die damit verbundenen Verluste aus den Schlössern recht groß.  Ja, und unter den "legal" gesperrten Websites gibt es viele nützliche (Hallo, Rutracker) </p><br><p> Ich lebe außerhalb der Gerichtsbarkeit der ILV, aber meine Eltern, Verwandten und Freunde blieben zu Hause.  Daher wurde beschlossen, eine Möglichkeit zu finden, um Sperren zu umgehen, die für IT-weit entfernte Personen, vorzugsweise ohne deren Teilnahme, einfach ist. </p><br><p>  In diesem Artikel werde ich die grundlegenden Netzwerkelemente nicht schrittweise beschreiben, sondern die allgemeinen Prinzipien, wie dieses Schema implementiert werden kann.  Kenntnisse darüber, wie das Netzwerk im Allgemeinen und unter Linux im Besonderen funktioniert, sind daher ein Muss. </p><a name="habracut"></a><br><h1 id="tipy-blokirovok">  Arten von Schlössern </h1><br><p>  Lassen Sie uns zunächst aktualisieren, was blockiert ist. </p><br><p>  Es gibt verschiedene Arten von Sperren in ausgelagertem XML von ILV: </p><br><ul><li>  IP </li><li>  Domain </li><li>  URL </li></ul><br><p>  Der Einfachheit halber werden wir sie auf zwei reduzieren: IP und Domain, und wir werden die Domain einfach aus der URL-Blockierung herausziehen (genauer gesagt, wir haben dies bereits für uns getan). </p><br><p>  Gute Leute von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Roskomsvoboda haben</a> eine wunderbare <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API</a> implementiert, mit der wir bekommen können, was wir brauchen: </p><br><ul><li>  IP: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://api.reserve-rbl.ru/api/v2/ips/json</a> </li><li>  Domänen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://api.reserve-rbl.ru/api/v2/domains/json</a> </li></ul><br><h1 id="dostup-k-zablokirovannym-saytam">  Zugriff auf blockierte Websites </h1><br><p>  Dazu benötigen wir einige kleine ausländische VPS, vorzugsweise mit unbegrenztem Verkehr - es gibt viele solcher 3-5 Dollar.  Sie müssen es im nahen Ausland nehmen, damit der Ping nicht sehr groß ist, aber berücksichtigen Sie auch hier, dass das Internet und die Geografie nicht immer zusammenfallen.  Und da es für 5 Dollar keine SLA gibt, ist es aus Gründen der Fehlertoleranz besser, 2+ Teile von verschiedenen Anbietern zu nehmen. </p><br><p>  Als nächstes müssen wir den verschlüsselten Tunnel vom Client-Router zum VPS konfigurieren.  Ich benutze Wireguard als das schnellste und am einfachsten zu konfigurierende seitdem  Ich habe auch Client-Router, die auf Linux basieren ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">APU2</a> oder etwas auf OpenWRT).  Bei einigen Mikrotik / Cisco können Sie Protokolle wie OpenVPN und GRE-over-IPSEC verwenden. </p><br><h1 id="identifikaciya-i-perenapravlenie-interesuyuschego-traffika">  Identifizierung und Umleitung des interessierenden Verkehrs </h1><br><p>  Natürlich können Sie den gesamten Internetverkehr im Ausland vollständig abschließen.  Höchstwahrscheinlich wird jedoch die Geschwindigkeit der Arbeit mit lokalen Inhalten stark darunter leiden.  Außerdem sind die Bandbreitenanforderungen an den VPS viel höher. </p><br><p>  Daher müssen wir blockierten Sites irgendwie Verkehr zuweisen und ihn selektiv an den Tunnel senden.  Selbst wenn ein Teil des "zusätzlichen" Verkehrs dort ankommt, ist es immer noch viel besser, als alles durch einen Tunnel zu fahren. </p><br><p>  Zur Verwaltung des Datenverkehrs verwenden wir das BGP-Protokoll und geben den Kunden Routen zu den erforderlichen Netzwerken von unserem VPS bekannt.  Nehmen wir als BGP-Daemon BIRD als einen der funktionalsten und bequemsten. </p><br><h3 id="ip">  IP </h3><br><p>  Mit der IP-Blockierung ist alles klar: Wir kündigen nur alle blockierten IPs mit VPS an.  Das Problem ist, dass die Liste, die die API angibt, ungefähr 600.000 Subnetze enthält und die überwiegende Mehrheit davon / 32 Hosts sind.  Eine solche Anzahl von Routen kann für schwache Client-Router verwirrend sein. </p><br><p>  Daher wurde beschlossen, bei der Verarbeitung der Liste eine Zusammenfassung zum Netzwerk / 24 zu erstellen, wenn zwei oder mehr Hosts darin enthalten sind.  Somit wurde die Anzahl der Routen auf ~ 100.000 reduziert.  Das Skript dafür wird als nächstes kommen. </p><br><h3 id="domeny">  Domänen </h3><br><p>  Es ist komplizierter und es gibt verschiedene Möglichkeiten.  Beispielsweise können Sie jedem Client-Router einen transparenten Squid hinzufügen und im TLS-Handshake HTTP-Interception und Peeping durchführen, um im ersten Fall die angeforderte URL und im zweiten Fall die Domain von SNI abzurufen. </p><br><p>  Aufgrund all der neuen TLS1.3 + eSNI wird die HTTPS-Analyse von Tag zu Tag realer.  Und die Infrastruktur auf der Client-Seite wird immer komplizierter - Sie müssen mindestens OpenWRT verwenden. </p><br><p>  Aus diesem Grund habe ich mich entschlossen, Antworten auf DNS-Abfragen abzufangen.  Auch hier steigt jedes DNS-over-TLS / HTTPS über unseren Köpfen auf, aber wir können diesen Teil (vorerst) auf dem Client steuern - entweder deaktivieren oder unseren eigenen Server für DoT / DoH verwenden. </p><br><h4 id="kak-perehvatyvat-dns">  Wie kann ich DNS abfangen? </h4><br><p>  Es kann auch mehrere Ansätze geben. </p><br><ul><li>  Abfangen des DNS-Verkehrs über PCAP oder NFLOG <br>  Beide <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abfangmethoden</a> sind im Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sidmat</a> implementiert.  Es wurde jedoch schon lange nicht mehr unterstützt und die Funktionalität ist sehr primitiv. Sie müssen daher trotzdem eine Bindung dazu schreiben. </li><li>  DNS-Server-Protokollanalyse <br>  Leider wissen die mir bekannten Rekursoren nicht, wie man Antworten protokolliert, sondern nur Anfragen.  Im Prinzip ist dies logisch, da Antworten im Gegensatz zu Anfragen eine komplexe Struktur haben und es schwierig ist, sie in Textform zu schreiben. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DNSTap</a> <br>  Glücklicherweise unterstützen viele von ihnen DNSTap bereits für diese Zwecke. </li></ul><br><h4 id="chto-takoe-dnstap">  Was ist DNSTap? </h4><br><p><img src="https://habrastorage.org/webt/gc/4g/qs/gc4gqsppif5ypkbf06ok0oihll4.png"></p><br><p>  Dies ist ein Client-Server-Protokoll, das auf Protokollpuffern und Frame-Streams für die Übertragung von einem DNS-Server an einen Sammler strukturierter DNS-Abfragen und -Antworten basiert.  Tatsächlich überträgt der DNS-Server Metadaten von Anforderungen und Antworten (Nachrichtentyp, Client / Server-IP usw.) sowie vollständige DNS-Nachrichten in der (binären) Form, in der er mit ihnen über das Netzwerk arbeitet. </p><br><p>  Es ist wichtig zu verstehen, dass im DNSTap-Paradigma der DNS-Server als Client und der Collector als Server fungiert.  Das heißt, der DNS-Server stellt eine Verbindung zum Collector her und nicht umgekehrt. </p><br><p>  Heute wird DNSTap auf allen gängigen DNS-Servern unterstützt.  Aber zum Beispiel wird BIND in vielen Distributionen (wie Ubuntu LTS) oft aus irgendeinem Grund ohne seine Unterstützung erstellt.  Wir werden uns also nicht um den Wiederaufbau kümmern, sondern einen leichteren und schnelleren Rekorder verwenden - Ungebunden. </p><br><h4 id="chem-lovit-dnstap">  Wie fange ich DNSTap? </h4><br><p>  Es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von</a> CLI-Dienstprogrammen für die Arbeit mit einem Stream von DNSTap-Ereignissen, die jedoch für unsere Aufgabe nicht gut geeignet sind.  Also habe ich beschlossen, mein eigenes Fahrrad zu erfinden, das alles kann: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>dnstap-bgp</strong></a> </p><br><p>  Operationsalgorithmus: </p><br><ul><li>  Beim Start wird eine Liste von Domänen aus einer Textdatei geladen, diese invertiert (habr.com -&gt; com.habr), gestrichelte Linien, Duplikate und Subdomänen ausgeschlossen (d. H. Wenn habr.com und www.habr.com in der Liste enthalten sind - wird sie geladen nur die erste) und erstellt einen Präfixbaum für die schnelle Suche in dieser Liste </li><li>  Als DNSTap-Server wartet er auf eine Verbindung vom DNS-Server.  Im Prinzip werden sowohl UNIX- als auch TCP-Sockets unterstützt, aber die mir bekannten DNS-Server können nur UNIX-Sockets verwenden </li><li>  Eingehende DNSTap-Pakete werden zuerst in die Protobuf-Struktur deserialisiert, und dann wird die in einem der Protobuf-Felder befindliche binäre DNS-Nachricht auf die Ebene der DNS-RR-Einträge analysiert </li><li>  Überprüft, ob der angeforderte Host (oder seine übergeordnete Domäne) in der geladenen Liste enthalten ist. Andernfalls wird die Antwort ignoriert </li><li>  Aus der Antwort werden nur A / AAAA / CNAME RR ausgewählt und die entsprechenden IPv4 / IPv6-Adressen daraus abgerufen </li><li>  IP-Adressen werden mit benutzerdefinierten TTLs zwischengespeichert und allen konfigurierten BGP-Peers bekannt gegeben </li><li>  Nach Erhalt einer Antwort, die eine bereits zwischengespeicherte IP angibt, wird deren TTL aktualisiert </li><li>  Nach Ablauf der TTL wird der Datensatz aus dem Cache und aus BGP-Ankündigungen gelöscht </li></ul><br><p>  Zusätzliche Funktionalität: </p><br><ul><li>  Domain-Liste von SIGHUP erneut lesen </li><li>  Synchronisieren des Cache mit anderen <strong>dnstap-bgp-</strong> Instanzen über HTTP / JSON </li><li>  Duplizieren des Caches auf der Festplatte (in der BoltDB-Datenbank), um den Inhalt nach einem Neustart wiederherzustellen </li><li>  Unterstützung für das Umschalten auf einen anderen Netzwerk-Namespace (warum dies unten beschrieben wird) </li><li>  IPv6-Unterstützung </li></ul><br><p>  Einschränkungen: </p><br><ul><li>  IDN-Domänen werden noch nicht unterstützt </li><li>  Einige BGP-Einstellungen </li></ul><br><p>  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RPM- und DEB-</a> Pakete für eine einfache Installation zusammengestellt.  Sollte auf allen relativ neuen Betriebssystemen mit systemd funktionieren, wie  Sie haben keine Abhängigkeiten. </p><br><h1 id="shema">  Schema </h1><br><p>  Beginnen wir also mit dem Zusammenbau aller Komponenten.  Als Ergebnis sollten wir so etwas wie diese Netzwerktopologie erhalten: <br><img src="https://habrastorage.org/webt/cm/ks/uo/cmksuol_njfgyjznmlf3oj6u94m.png"></p><br><p>  Die Logik der Arbeit, denke ich, geht aus dem Diagramm hervor: </p><br><ul><li>  Der Client hat unseren Server als DNS konfiguriert, und DNS-Abfragen müssen auch über das VPN erfolgen.  Dies ist erforderlich, damit der Anbieter die DNS-Überwachung nicht zum Blockieren verwenden kann. </li><li>  Wenn die Site geöffnet wird, sendet der Client eine DNS-Abfrage in der Form "Welche IPs hat xxx.org?" </li><li>  <strong>Ungebunden</strong> löst xxx.org auf (oder nimmt es aus dem Cache) und sendet eine Antwort an den Client "xxx.org hat solche und solche IPs", wobei es parallel über DNSTap dupliziert wird </li><li>  <strong>dnstap-bgp</strong> kündigt diese Adressen in <strong>BIRD</strong> von BGP an, wenn die Domain in der Liste der blockierten Domänen enthalten ist </li><li> <strong>BIRD</strong> kündigt die Route zu diesen IPs mit dem <code>next-hop self</code> Client-Router des <code>next-hop self</code> </li><li>  Nachfolgende Pakete vom Client zu diesen IPs durchlaufen den Tunnel </li></ul><br><p>  Auf dem Server habe ich für Routen zu blockierten Sites eine separate Tabelle in BIRD, die sich nicht mit dem Betriebssystem überschneidet. </p><br><p>  Dieses Schema weist einen Nachteil auf: Das erste SYN-Paket des Clients wird höchstwahrscheinlich seitdem Zeit haben, über den inländischen Anbieter abzureisen  Die Route wird nicht sofort angekündigt.  Und hier sind Optionen möglich, je nachdem, wie der Anbieter die Sperre macht.  Wenn er nur den Verkehr fallen lässt, gibt es keine Probleme.  Und wenn er es auf eine DPI umleitet, sind (theoretisch) Spezialeffekte möglich. </p><br><p>  Wunder sind auch möglich, wenn Clients DNS-TTL nicht beachten. Dies kann dazu führen, dass der Client einige veraltete Einträge aus seinem faulen Cache verwendet, anstatt Unbound zu fragen. </p><br><p>  In der Praxis hat mir weder der erste noch der zweite Probleme bereitet, aber Ihr Kilometerstand kann variieren. </p><br><h2 id="nastroyka-servera">  Server-Setup </h2><br><p>  Um das Rollen zu vereinfachen, habe ich eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rolle für Ansible geschrieben</a> .  Es kann sowohl Server als auch Linux-basierte Clients konfigurieren (entwickelt für deb-basierte Distributionen).  Alle Einstellungen sind ziemlich offensichtlich und werden in <em>inventar.yml festgelegt</em> .  Diese Rolle wurde aus meinem großen Spielbuch herausgeschnitten, daher kann sie Fehler enthalten - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pull-Anfragen sind</a> willkommen :) </p><br><p>  Lassen Sie uns die Hauptkomponenten durchgehen. </p><br><h3 id="bgp">  BGP </h3><br><p>  Beim Starten von zwei BGP-Daemons auf demselben Host tritt ein grundlegendes Problem auf: BIRD möchte das BGP-Peering nicht mit einem lokalen Host (oder einer lokalen Schnittstelle) auslösen.  Vom Wort überhaupt.  Googeln und Lesen von Mailinglisten haben nicht geholfen, sie behaupten, dass es beabsichtigt ist.  Vielleicht gibt es einen Weg, aber ich habe ihn nicht gefunden. </p><br><p>  Sie können einen anderen BGP-Daemon ausprobieren, aber ich mag BIRD und es wird überall bei mir verwendet. Ich möchte keine Entitäten erstellen. </p><br><p>  Deshalb habe ich dnstap-bgp im Netzwerk-Namespace versteckt, der über die veth-Schnittstelle mit dem Root verbunden ist: Es ist wie eine Pipe, deren Enden in einem anderen Namespace herausragen.  An jedem dieser Enden hängen wir private p2p-IP-Adressen auf, die nicht außerhalb des Hosts liegen, sodass sie beliebig sein können.  Dies ist derselbe Mechanismus, der für den Zugriff auf Prozesse im <em>geliebten</em> Docker und anderen Containern verwendet wird. </p><br><p>  Zu diesem Zweck wurde ein <a href="">Skript</a> geschrieben und in dnstap-bgp die oben beschriebene Funktionalität hinzugefügt, um sich an den Haaren in einen anderen Namespace zu ziehen.  Aus diesem Grund muss es als root ausgeführt oder über den Befehl setcap an die Binärdatei CAP_SYS_ADMIN zurückgegeben werden. </p><br><div class="spoiler">  <b class="spoiler_title">Beispielskript zum Erstellen eines Namespace</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash NS="dtap" IP="/sbin/ip" IPNS="$IP netns exec $NS $IP" IF_R="veth-$NS-r" IF_NS="veth-$NS-ns" IP_R="192.168.149.1" IP_NS="192.168.149.2" /bin/systemctl stop dnstap-bgp || true $IP netns del $NS &gt; /dev/null 2&gt;&amp;1 $IP netns add $NS $IP link add $IF_R type veth peer name $IF_NS $IP link set $IF_NS netns $NS $IP addr add $IP_R remote $IP_NS dev $IF_R $IP link set $IF_R up $IPNS addr add $IP_NS remote $IP_R dev $IF_NS $IPNS link set $IF_NS up /bin/systemctl start dnstap-bgp</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">dnstap-bgp.conf</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">namespace = "dtap" domains = "/var/cache/rkn_domains.txt" ttl = "168h" [dnstap] listen = "/tmp/dnstap.sock" perm = "0666" [bgp] as = 65000 routerid = "192.168.149.2" peers = [ "192.168.149.1", ]</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">bird.conf</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">router id 192.168.1.1; table rkn; # Clients protocol bgp bgp_client1 { table rkn; local as 65000; neighbor 192.168.1.2 as 65000; direct; bfd on; next hop self; graceful restart; graceful restart time 60; export all; import none; } # DNSTap-BGP protocol bgp bgp_dnstap { table rkn; local as 65000; neighbor 192.168.149.2 as 65000; direct; passive on; rr client; import all; export none; } # Static routes list protocol static static_rkn { table rkn; include "rkn_routes.list"; import all; export none; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">rkn_routes.list</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">route 3.226.79.85/32 via "ens3"; route 18.236.189.0/24 via "ens3"; route 3.224.21.0/24 via "ens3"; ...</code> </pre> </div></div><br><h3 id="dns">  DNS </h3><br><p>  In Ubuntu wird die ungebundene Binärdatei standardmäßig vom AppArmor-Profil geklemmt, wodurch verhindert wird, dass eine Verbindung zu DNSTap-Sockets hergestellt wird.  Sie können dieses Profil entweder entfernen oder deaktivieren: </p><br><pre> <code class="plaintext hljs"># cd /etc/apparmor.d/disable &amp;&amp; ln -s ../usr.sbin.unbound . # apparmor_parser -R /etc/apparmor.d/usr.sbin.unbound</code> </pre> <br><p>  Dies sollte wahrscheinlich zum Playbook hinzugefügt werden.  Es ist natürlich ideal, das Profil zu korrigieren und die erforderlichen Rechte zu erteilen, aber ich war zu faul. </p><br><div class="spoiler">  <b class="spoiler_title">ungebunden.conf</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">server: chroot: "" port: 53 interface: 0.0.0.0 root-hints: "/var/lib/unbound/named.root" auto-trust-anchor-file: "/var/lib/unbound/root.key" access-control: 192.168.0.0/16 allow remote-control: control-enable: yes control-use-cert: no dnstap: dnstap-enable: yes dnstap-socket-path: "/tmp/dnstap.sock" dnstap-send-identity: no dnstap-send-version: no dnstap-log-client-response-messages: yes</code> </pre> </div></div><br><h3 id="skachivanie-i-obrabotka-spiskov">  Download und Listenverarbeitung </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Skript zum Herunterladen und Verarbeiten einer Liste von IP-Adressen</a> <br>  Es lädt die Liste herunter und fasst sie vor dem <em>pfx-</em> Präfix zusammen.  In <em>dont_add</em> und <em>dont_summarize können</em> Sie IP und Netzwerken <em>anweisen,</em> zu überspringen oder nicht zusammenzufassen.  Ich brauchte es, weil  Mein VPS-Subnetz war in der Blockliste :) </p><br><p>  Das Lustige ist, dass die RosKomSvoboda-API Anforderungen mit dem Standard-Python-Benutzeragenten blockiert.  Sieht aus wie ein Drehbuchkind hat es verstanden.  Deshalb ändern wir es in Firelis. </p><br><p>  Bisher funktioniert es nur mit IPv4, weil  IPv6 ist klein, lässt sich aber leicht beheben.  Es sei denn, es ist notwendig, auch bird6 zu verwenden. </p><br><div class="spoiler">  <b class="spoiler_title">rkn.py.</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python3 import json, urllib.request, ipaddress as ipa url = 'https://api.reserve-rbl.ru/api/v2/ips/json' pfx = '24' dont_summarize = { # ipa.IPv4Network('1.1.1.0/24'), } dont_add = { # ipa.IPv4Address('1.1.1.1'), } req = urllib.request.Request( url, data=None, headers={ 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.47 Safari/537.36' } ) f = urllib.request.urlopen(req) ips = json.loads(f.read().decode('utf-8')) prefix32 = ipa.IPv4Address('255.255.255.255') r = {} for i in ips: ip = ipa.ip_network(i) if not isinstance(ip, ipa.IPv4Network): continue addr = ip.network_address if addr in dont_add: continue m = ip.netmask if m != prefix32: r[m] = [addr, 1] continue sn = ipa.IPv4Network(str(addr) + '/' + pfx, strict=False) if sn in dont_summarize: tgt = addr else: tgt = sn if not sn in r: r[tgt] = [addr, 1] else: r[tgt][1] += 1 o = [] for n, v in r.items(): if v[1] == 1: o.append(str(v[0]) + '/32') else: o.append(n) for k in o: print(k)</span></span></code> </pre> </div></div><br><p>  <a href="">Zu aktualisierendes Skript</a> <br>  Es beginnt einmal am Tag an meiner Krone, vielleicht lohnt es sich, sie alle 4 Stunden zu ziehen, weil  Dies ist meiner Meinung nach der Aktualisierungszeitraum, den ILV von Anbietern benötigt.  Außerdem gibt es einige andere besonders dringende Schleusen, mit denen sie schneller fliegen können. </p><br><p>  Tut folgendes: </p><br><ul><li>  Führt das erste Skript aus und aktualisiert die <code>rkn_routes.list</code> ( <code>rkn_routes.list</code> ) für BIRD </li><li>  BIRD neu laden </li><li>  Aktualisiert und bereinigt die Domain-Liste für dnstap-bgp </li><li>  Verschieben Sie dnstap-bgp </li></ul><br><div class="spoiler">  <b class="spoiler_title">rkn_update.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash ROUTES="/etc/bird/rkn_routes.list" DOMAINS="/var/cache/rkn_domains.txt" # Get &amp; summarize routes /opt/rkn.py | sed 's/\(.*\)/route \1 via "ens3";/' &gt; $ROUTES.new if [ $? -ne 0 ]; then rm -f $ROUTES.new echo "Unable to download RKN routes" exit 1 fi if [ -e $ROUTES ]; then mv $ROUTES $ROUTES.old fi mv $ROUTES.new $ROUTES /bin/systemctl try-reload-or-restart bird # Get domains curl -s https://api.reserve-rbl.ru/api/v2/domains/json -o - | jq -r '.[]' | sed 's/^\*\.//' | sort | uniq &gt; $DOMAINS.new if [ $? -ne 0 ]; then rm -f $DOMAINS.new echo "Unable to download RKN domains" exit 1 fi if [ -e $DOMAINS ]; then mv $DOMAINS $DOMAINS.old fi mv $DOMAINS.new $DOMAINS /bin/systemctl try-reload-or-restart dnstap-bgp</span></span></code> </pre> </div></div><br><p>  Sie wurden ohne viel Nachdenken geschrieben. Wenn Sie also sehen, was verbessert werden kann, versuchen Sie es. </p><br><h2 id="nastroyka-klienta">  Client-Setup </h2><br><p>  Hier werde ich Beispiele für Linux-Router geben, aber im Fall von Mikrotik / Cisco sollte dies noch einfacher sein. </p><br><p>  Konfigurieren Sie zunächst BIRD: </p><br><div class="spoiler">  <b class="spoiler_title">bird.conf</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">router id 192.168.1.2; table rkn; protocol device { scan time 10; }; # Servers protocol bgp bgp_server1 { table rkn; local as 65000; neighbor 192.168.1.1 as 65000; direct; bfd on; next hop self; graceful restart; graceful restart time 60; rr client; export none; import all; } protocol kernel { table rkn; kernel table 222; scan time 10; export all; import none; }</code> </pre> </div></div><br><p>  Daher werden wir die von BGP empfangenen Routen mit der Kernel-Routing-Tabelle Nummer 222 synchronisieren. </p><br><p>  Danach reicht es aus, den Kernel zu bitten, sich diese Platte anzusehen, bevor Sie sich die Standardeinstellung ansehen: </p><br><pre> <code class="plaintext hljs"># ip rule add from all pref 256 lookup 222 # ip rule 0: from all lookup local 256: from all lookup 222 32766: from all lookup main 32767: from all lookup default</code> </pre> <br><p>  Sie müssen lediglich DHCP auf dem Router so konfigurieren, dass die Tunnel-IP-Adresse des Servers als DNS verteilt wird und das Schema bereit ist. </p><br><h1 id="nedostatki">  Nachteile </h1><br><p>  Mit dem aktuellen Algorithmus zum Erstellen und Verarbeiten einer Liste von Domains fallen <code>youtube.com</code> und seine CDNs hinein. </p><br><p>  Dies führt dazu, dass alle Videos über das VPN übertragen werden, wodurch der gesamte Kanal verstopft werden kann.  Vielleicht lohnt es sich, eine Liste der gängigen Ausnahmedomänen zusammenzustellen, die vorerst in der ILV blockiert sind.  Und überspringen Sie sie beim Parsen. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Mit der beschriebenen Methode können Sie fast alle Sperren umgehen, die Anbieter derzeit implementieren. </p><br><p>  Im Prinzip kann <em>dnstap-bgp</em> für jeden anderen Zweck verwendet werden, bei dem ein bestimmtes Maß an Verkehrssteuerung basierend auf einem Domänennamen erforderlich ist.  Denken Sie jedoch daran, dass heutzutage tausend Websites an derselben IP-Adresse hängen können (z. B. für einige Cloudflare), sodass diese Methode eine relativ geringe Genauigkeit aufweist. </p><br><p>  Für die Umgehung von Schlössern ist dies jedoch völlig ausreichend. </p><br><p>  Ergänzungen, Änderungen, Pull-Quests sind willkommen! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467547/">https://habr.com/ru/post/de467547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467531/index.html">Reaktive Zustandsmaschine</a></li>
<li><a href="../de467533/index.html">Informationslärm hören: Musik und Videos, die niemand hätte finden sollen</a></li>
<li><a href="../de467539/index.html">CA / B-Forum gegen Kürzung von SSL-Zertifikaten auf 397 Tage gestimmt</a></li>
<li><a href="../de467543/index.html">Ssh-Chat, Teil 2</a></li>
<li><a href="../de467545/index.html">ShIoTiny: eine Uhr ohne Feder oder Echtzeit und wie man damit arbeitet</a></li>
<li><a href="../de467549/index.html">SpaceX plant, das Satelliten-Internet-Netzwerk früher als geplant bereitzustellen</a></li>
<li><a href="../de467551/index.html">Frontend Weekly Digest (9. - 15. September 2019)</a></li>
<li><a href="../de467555/index.html">Wie gut kennen Sie CSS? (+ Minitest)</a></li>
<li><a href="../de467557/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 380 (8. - 15. September 2019)</a></li>
<li><a href="../de467559/index.html">Digitale Veranstaltungen in Moskau vom 16. bis 22. September</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>