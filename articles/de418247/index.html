<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí• üë©üèº‚Äçüîß üíá Beschleunigen Sie die Float 4x4 Matrix Multiplikation mit SIMD ü§ì ü¶í üßõüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele Jahre sind vergangen, seit ich die Anweisungen MMX, SSE und sp√§ter AVX auf Intel-Prozessoren kennengelernt habe. Zu einer Zeit wirkten sie wie e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beschleunigen Sie die Float 4x4 Matrix Multiplikation mit SIMD</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418247/">  Viele Jahre sind vergangen, seit ich die Anweisungen MMX, SSE und sp√§ter AVX auf Intel-Prozessoren kennengelernt habe.  Zu einer Zeit wirkten sie wie eine Art Magie vor dem Hintergrund des x86-Assemblers, der lange Zeit etwas Allt√§gliches gewesen war.  Sie haben mich so begeistert, dass ich vor ein paar Jahren die Idee hatte, meinen eigenen Software-Renderer f√ºr ein ber√ºhmtes Spiel zu schreiben.  Das, was diese Anweisungen versprach, versprach mir dies.  Irgendwann habe ich sogar dar√ºber nachgedacht, es zu schreiben.  Das Schreiben von Text erwies sich jedoch als viel komplizierter als Code. <br><br>  Zu dieser Zeit wollte ich Probleme mit der Unterst√ºtzung auf verschiedenen Prozessoren vermeiden.  Ich wollte in der Lage sein, meinen Renderer auf die maximal verf√ºgbare Menge zu √ºberpr√ºfen.  Ich habe immer noch Freunde mit alten AMD-Prozessoren, und ihre Obergrenze war SSE3.  Aus diesem Grund habe ich mich damals entschlossen, mich auf maximal SSE3 zu beschr√§nken.  Es gab also eine vektormathematische Bibliothek, die in SSE etwas weniger als vollst√§ndig implementiert war, mit einer seltenen Aufnahme vor SSE3.  Irgendwann fragte ich mich jedoch, welche maximale Leistung ich f√ºr eine Reihe kritischer Vektormathematikoperationen aus dem Prozessor herausholen k√∂nnte.  Eine solche Operation besteht darin, 4 Matrizen mit 4 zu multiplizieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/ii/cq/kgiicqemuc5agmypikedjioaogc.jpeg"></div><a name="habracut"></a><br>  Eigentlich habe ich beschlossen, dieses Gesch√§ft eher zur Unterhaltung zu betreiben.  Ich habe bereits geschrieben und verwende Matrixmultiplikation f√ºr mein Software-Rendering auf SSE, und es scheint mir genug zu sein.  Aber dann habe ich mich entschlossen zu sehen, wie viele Ma√ünahmen ich im Prinzip aus der Multiplikation von 2 float4x4-Matrizen herausholen kann.  Bei meiner aktuellen SSE sind dies 16 Taktzyklen.  Richtig, der k√ºrzliche √úbergang zu <abbr title="Intel Architecture Code Analyzer">IACA</abbr> 3 zeigte 19, da ich anfing, 1 * f√ºr einige Anweisungen anstelle von 0 * zu schreiben.  Anscheinend war es fr√ºher nur ein Fehler im Analyseger√§t. <br><br><h3>  Kurz √ºber die verwendeten Dienstprogramme </h3><br>  F√ºr die Codeanalyse habe ich das ber√ºhmte Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel Architecture Code Analyzer verwendet</a> .  F√ºr die Analyse verwende ich mindestens die Haswell-Architektur (HSW) mit Unterst√ºtzung f√ºr AVX2.  Das Schreiben von Code ist auch sehr bequem: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel Intrinsics Guide</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel Optimierungshandbuch</a> . <br><br>  F√ºr die Montage verwende ich MSVS 2017 Community von der Konsole aus.  Ich schreibe den Code in der Version mit intrinsischen.  Sie schreiben einmal und normalerweise funktioniert es sofort auf verschiedenen Plattformen.  Dar√ºber hinaus unterst√ºtzt der x64 VC ++ - Compiler keinen Inline-Assembler, aber ich m√∂chte, dass er auch unter x64 funktioniert. <br><br>  Da dieser Artikel in der SIMD-Programmierung bereits etwas √ºber dem Anf√§ngerniveau liegt, werde ich keine Register, Anweisungen beschreiben, sch√∂ne Bilder zeichnen (oder rasieren) und versuchen, das Programmieren mit SIMD-Anweisungen zu lernen.  Die Intel-Website ist voll von hervorragender, klarer und detaillierter Dokumentation. <br><br><h2>  Ich wollte alles einfacher machen ... Aber es stellte sich wie immer heraus </h2><br>  Hier beginnt der Moment, der sowohl die Implementierung als auch den Artikel erheblich verkompliziert.  Deshalb werde ich ein wenig darauf eingehen.  Es ist f√ºr mich nicht interessant, eine Matrixmultiplikation mit einem Standardzeilenlayout von Elementen zu schreiben.  Wer brauchte es, und so studierten sie an Universit√§ten oder allein.  Unser Ziel ist die Produktivit√§t.  Erstens habe ich vor langer Zeit zum Spaltenlayout gewechselt.  Mein Software-Renderer basiert auf der OpenGL-API. Um unn√∂tige Transpositionen zu vermeiden, habe ich begonnen, Elemente in Spalten zu speichern.  Dies ist auch wichtig, da die Matrixmultiplikation nicht so kritisch ist.  Gut multiplizierte 2-5-10 Matrizen.  Und alle.  Und dann multiplizieren wir die fertige Matrix mit Tausenden oder Millionen von Eckpunkten.  Und diese Operation ist viel kritischer.  Sie k√∂nnen nat√ºrlich jedes Mal transponieren.  Aber warum, wenn dies vermieden werden kann. <br><br>  Aber zur√ºck zu den Matrizen ausschlie√ülich.  Wir haben die Speicherung in Spalten festgelegt.  Es kann jedoch noch komplizierter sein.  F√ºr mich ist es bequemer, die √§lteren Elemente von Vektoren und Matrixzeilen in SIMD-Registern so zu speichern, dass <strong>x</strong> im h√∂chsten Float (Index 3) und <strong>w</strong> im untersten (Index 0) liegt.  Hier m√ºssen wir uns anscheinend wieder zur√ºckziehen, warum. <br><br>  Die Sache ist, dass Sie in einem Software-Renderer in einem Vektor die <strong>w-</strong> Komponente h√§ufiger manipulieren m√ºssen ( <strong>1 / z</strong> wird dort gespeichert), und dies ist sehr bequem √ºber die <strong>_ss-</strong> Version der Operation (Operationen ausschlie√ülich mit der Komponente im unteren Float des <em>xmm-</em> Registers), ohne <strong><nobr>x, y,</nobr></strong> zu ber√ºhren <strong><nobr>. z</nobr></strong> .  Daher wird im SSE-Register der Vektor in einer verst√§ndlichen Reihenfolge <strong><nobr>x, y, z, w</nobr></strong> und im Speicher in umgekehrter Reihenfolge <strong><nobr>w, z, y, x</nobr></strong> gespeichert. <br><br>  Ferner werden alle Multiplikationsoptionen auch durch einzelne Funktionen implementiert.  Dies geschieht, weil ich sie verwende, um die gew√ºnschte Option abh√§ngig von der Art der unterst√ºtzten Anweisungen zu ersetzen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier gut beschrieben.</a> <br><br><h2>  Wir implementieren die Grundfunktionalit√§t </h2><br><h3>  Multiplikation mit Schleifen, Zeile geordnet </h3><br><div class="spoiler">  <b class="spoiler_title">Option f√ºr das Linienlayout von Elementen</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) { r[i][j] = <span class="hljs-number"><span class="hljs-number">0.f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++k) { r[i][j] += m[i][k] * n[k][j]; } } }</code> </pre> <br></div></div><br>  Hier ist alles einfach und klar.  F√ºr jedes Element machen wir 4 Multiplikationen und 3 Additionen.  Insgesamt sind dies 64 Multiplikationen und 48 Additionen.  Und dies ohne Ber√ºcksichtigung des Lesens der Datensatzelemente. <br><br>  Kurz gesagt, alles ist traurig.  F√ºr diese Option hat IACA f√ºr den internen Zyklus Folgendes ausgegeben: <em>3,65 Taktzyklen f√ºr die x86-Assembly und 2,97 Takte f√ºr die x64-Assembly</em> .  Fragen Sie nicht, warum Bruchzahlen.  Wei√ü nicht.  IACA 2.1 litt nicht darunter.  In jedem Fall sollten diese Zahlen mit ungef√§hr 4 * 4 * 4 = 64 multipliziert werden. Selbst wenn Sie x64 nehmen, ergibt sich ein Ergebnis von ungef√§hr 192 Takten.  Es ist klar, dass dies eine grobe Sch√§tzung ist.  Ich sehe keinen Sinn darin, die Leistung f√ºr diese Option genauer zu bewerten. <br><br><h3>  Looping-Implementierung, Spalte bestellt </h3><br><div class="spoiler">  <b class="spoiler_title">transponierte Matrix, Zeilen- und Spaltenindizes neu anordnen</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) { r[j][i] = <span class="hljs-number"><span class="hljs-number">0.f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++k) { r[j][i] += m[k][i] * n[j][k]; } } }</code> </pre><br></div></div><br><h3>  Zyklusmultiplikation, SIMD-orientierter Speicher </h3><br><div class="spoiler">  <b class="spoiler_title">Das Speichern von Zeilen in umgekehrter Reihenfolge im Speicher wird hinzugef√ºgt</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) { r[j][<span class="hljs-number"><span class="hljs-number">3</span></span>-i] = <span class="hljs-number"><span class="hljs-number">0.f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++k) { r[j][<span class="hljs-number"><span class="hljs-number">3</span></span>-i] += m[k][<span class="hljs-number"><span class="hljs-number">3</span></span>-i] * n[j][<span class="hljs-number"><span class="hljs-number">3</span></span>-k]; } } }</code> </pre><br></div></div><br>  Diese Implementierung vereinfacht das Verst√§ndnis dessen, was im Inneren geschieht, etwas, reicht aber eindeutig nicht aus. <br><br><h3>  Hilfsklassen </h3><br>  Um das Verstehen und Schreiben von Referenz- und Debugging-Code zu vereinfachen, ist es zweckm√§√üig, einige Hilfsklassen zu implementieren.  Nichts weiter, alles dient nur zum Verst√§ndnis.  Ich stelle fest, dass die Implementierung vollwertiger Vektor- und Matrixklassen eine separate schwierige Frage ist und nicht im Thema dieses Artikels enthalten ist. <br><br><div class="spoiler">  <b class="spoiler_title">Vektor- und Matrixklassen</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">struct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alignas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(__m128))</span></span></span><span class="hljs-function"> vec4 </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> w, z, y, x; }; __m128 fmm; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> arr[<span class="hljs-number"><span class="hljs-number">4</span></span>]; }; vec4() {} vec4(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d) : w(d), z(c), y(b), x(a) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.00001</span></span></span></span><span class="hljs-function"><span class="hljs-params">f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(ab) &lt; t; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> == (vec4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; v) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> equ(x, vx) &amp;&amp; equ(y, vy) &amp;&amp; equ(z, vz) &amp;&amp; equ(w, vw); } }; <span class="hljs-function"><span class="hljs-function">struct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alignas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(__m256))</span></span></span><span class="hljs-function"> mtx4 </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//           union { struct { float _30, _20, _10, _00, _31, _21, _11, _01, _32, _22, _12, _02, _33, _23, _13, _03; }; __m128 r[4]; __m256 s[2]; vec4 v[4]; }; //    mtx4() {} mtx4( float i00, float i01, float i02, float i03, float i10, float i11, float i12, float i13, float i20, float i21, float i22, float i23, float i30, float i31, float i32, float i33) : _00(i00), _01(i01), _02(i02), _03(i03) , _10(i10), _11(i11), _12(i12), _13(i13) , _20(i20), _21(i21), _22(i22), _23(i23) , _30(i30), _31(i31), _32(i32), _33(i33) {} //      operator __m128 const* () const { return r; } operator __m128* () { return r; } //   bool operator == (mtx4 const&amp; m) const { return v[0]==mv[0] &amp;&amp; v[1]==mv[1] &amp;&amp; v[2]==mv[2] &amp;&amp; v[3]==mv[3]; } //  static mtx4 identity() { return mtx4( 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f); } static mtx4 zero() { return mtx4( 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f); } };</span></span></code> </pre><br></div></div><br><h3>  Referenzfunktion f√ºr Tests </h3><br>  Da die akzeptierte Reihenfolge der Elemente in der Matrix das Verst√§ndnis erheblich erschwert, wird uns auch die <em>verst√§ndliche</em> Referenzfunktion nicht st√∂ren, die in zuk√ºnftigen Implementierungen zeigen wird, dass alles korrekt funktioniert.  Wir werden nachfolgende Ergebnisse damit vergleichen. <br><br><div class="spoiler">  <b class="spoiler_title">Um es zu erstellen, nehmen Sie einfach den Zyklus und erweitern Sie ihn</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_unroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _n)</span></span></span><span class="hljs-function"> </span></span>{ mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; m = **<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt;(&amp;_m); mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; n = **<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt;(&amp;_n); mtx4&amp; r = **<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;mtx4* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt;(&amp;_r); r._00 = m._00*n._00 + m._01*n._10 + m._02*n._20 + m._03*n._30; r._01 = m._00*n._01 + m._01*n._11 + m._02*n._21 + m._03*n._31; r._02 = m._00*n._02 + m._01*n._12 + m._02*n._22 + m._03*n._32; r._03 = m._00*n._03 + m._01*n._13 + m._02*n._23 + m._03*n._33; r._10 = m._10*n._00 + m._11*n._10 + m._12*n._20 + m._13*n._30; r._11 = m._10*n._01 + m._11*n._11 + m._12*n._21 + m._13*n._31; r._12 = m._10*n._02 + m._11*n._12 + m._12*n._22 + m._13*n._32; r._13 = m._10*n._03 + m._11*n._13 + m._12*n._23 + m._13*n._33; r._20 = m._20*n._00 + m._21*n._10 + m._22*n._20 + m._23*n._30; r._21 = m._20*n._01 + m._21*n._11 + m._22*n._21 + m._23*n._31; r._22 = m._20*n._02 + m._21*n._12 + m._22*n._22 + m._23*n._32; r._23 = m._20*n._03 + m._21*n._13 + m._22*n._23 + m._23*n._33; r._30 = m._30*n._00 + m._31*n._10 + m._32*n._20 + m._33*n._30; r._31 = m._30*n._01 + m._31*n._11 + m._32*n._21 + m._33*n._31; r._32 = m._30*n._02 + m._31*n._12 + m._32*n._22 + m._33*n._32; r._33 = m._30*n._03 + m._31*n._13 + m._32*n._23 + m._33*n._33; }</code> </pre><br></div></div><br>  Der klassische Algorithmus ist hier klar dargestellt, es ist schwierig, einen Fehler zu machen (aber Sie k√∂nnen :-)).  Darauf gab die IACA Folgendes heraus: <em>x86 - 69,95 Ma√ünahmen, x64 - 64 Ma√ünahmen</em> .  Hier sind ungef√§hr 64 Zyklen und wir werden uns die Beschleunigung dieses Vorgangs in Zukunft ansehen. <br><br><h2>  SSE-Implementierung </h2><br><h3>  Klassischer SSE-Algorithmus </h3><br>  Warum klassisch?  Weil es seit langem in der Implementierung von <em>FVec</em> als Teil von MSVS ist.  Zun√§chst werden wir schreiben, wie wir Matrixelemente in SSE-Registern darstellen.  Hier sieht es schon einfacher aus.  Nur eine transponierte Matrix. <br><br><pre> <code class="plaintext hljs">//     00, 10, 20, 30 // m[0] -  SIMD /   01, 11, 21, 31 // m[1] 02, 12, 22, 32 // m[2] 03, 13, 23, 33 // m[3]</code> </pre><br>  Wir nehmen den <em>Abrollcode</em> der obigen Variante.  Irgendwie ist er f√ºr SSE unfreundlich.  Die erste Gruppe von Zeilen besteht aus den Ergebnissen f√ºr die Spalte der resultierenden Matrix: <em><nobr>r._00, r._01, r._02, r._03</nobr></em> .  Wir haben diese Spalte, aber wir brauchen eine Zeile.  Ja, und <strong>m</strong> , <strong>n</strong> sehen f√ºr Berechnungen unpraktisch aus.  Daher ordnen wir die Zeilen des Algorithmus so an, dass das Ergebnis <strong>r</strong> zeilenweise ist. <br><br><pre> <code class="plaintext hljs">//  ,     r[0] r00 = m00*n00 + m01*n10 + m02*n20 + m03*n30; r10 = m10*n00 + m11*n10 + m12*n20 + m13*n30; r20 = m20*n00 + m21*n10 + m22*n20 + m23*n30; r30 = m30*n00 + m31*n10 + m32*n20 + m33*n30; //  ,     r[1] r01 = m00*n01 + m01*n11 + m02*n21 + m03*n31; r11 = m10*n01 + m11*n11 + m12*n21 + m13*n31; r21 = m20*n01 + m21*n11 + m22*n21 + m23*n31; r31 = m30*n01 + m31*n11 + m32*n21 + m33*n31; //  ,     r[2] r02 = m00*n02 + m01*n12 + m02*n22 + m03*n32; r12 = m10*n02 + m11*n12 + m12*n22 + m13*n32; r22 = m20*n02 + m21*n12 + m22*n22 + m23*n32; r32 = m30*n02 + m31*n12 + m32*n22 + m33*n32; //  ,     r[3] r03 = m00*n03 + m01*n13 + m02*n23 + m03*n33; r13 = m10*n03 + m11*n13 + m12*n23 + m13*n33; r23 = m20*n03 + m21*n13 + m22*n23 + m23*n33; r33 = m30*n03 + m31*n13 + m32*n23 + m33*n33;</code> </pre><br>  Das ist aber schon viel besser.  Was sehen wir eigentlich?  Entsprechend den Spalten des Algorithmus in jeder Gruppe haben wir die Zeilen der Matrix <strong>m</strong> beteiligt: <br><pre> m [0] = {00,10,20,30}, m [1] = {01,11,21,31}, m [2] = {02,12,22,32}, m [3] = {03,13,23,33},
</pre>  die mit dem gleichen Element der Matrix <strong>n</strong> multipliziert werden.  Zum Beispiel ist es f√ºr die erste Gruppe: <em>n._00, n._10, n._20, n._30</em> .  Und die Elemente der Matrix <strong>n</strong> f√ºr jede Gruppe von Zeilen des Algorithmus liegen wieder in einer Zeile der Matrix. <br><br>  Dann ist alles einfach: Wir nehmen einfach die Zeilen der Matrix <strong>m als</strong> Index, aber f√ºr die Elemente von <strong>n</strong> nehmen wir ihre Zeile und streuen sie durch den <em>Shuffle-</em> Befehl auf alle 4 Elemente des Registers, um sie mit der Zeile der Matrix <strong>m</strong> im Register zu multiplizieren.  F√ºr das Element <em>n._00</em> (denken <em>Sie</em> daran, dass seine Verschiebung im Register den Index 3 hat) <em>lautet</em> dies beispielsweise: <pre>  _mm_shuffle_ps (n [0], n [0], _MM_SHUFFLE (3,3,3,3)) </pre><br>  In vereinfachter Form sieht der Algorithmus folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">//   n[0]={00,10,20,30} r[0] = m[0] * n00 + m[1] * n10 + m[2] * n20 + m[3] * n30; //   n[1]={01,11,21,31} r[1] = m[0] * n01 + m[1] * n11 + m[2] * n21 + m[3] * n31; //   n[2]={02,12,22,32} r[2] = m[0] * n02 + m[1] * n12 + m[2] * n22 + m[3] * n32; //   n[3]={03,13,23,33} r[3] = m[0] * n03 + m[1] * n13 + m[2] * n23 + m[3] * n33;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Grundlegende SSE-Implementierung</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ r[<span class="hljs-number"><span class="hljs-number">0</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); r[<span class="hljs-number"><span class="hljs-number">1</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); r[<span class="hljs-number"><span class="hljs-number">2</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); r[<span class="hljs-number"><span class="hljs-number">3</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); }</code> </pre><br></div></div><br>  Jetzt √§ndern wir die Elemente <strong>n</strong> im Algorithmus in die entsprechende <em>Zufallswiedergabe</em> , Multiplikation mit <em>_mm_mul_ps</em> , die Summe mit <em>_mm_add_ps</em> , und fertig.  Es funktioniert.  Der Code sieht jedoch viel schlechter aus als der Algorithmus selbst.  Zu diesem Code gab IACA Folgendes aus: <em>x86 - 18.89, x64 - 16 Zyklen</em> .  Dies ist viermal schneller als der vorherige.  Im SSE-Register 4. Float.  Fast lineare Beziehung. <br><br><h4>  Dekorieren Sie die SSE-Implementierung </h4><br>  Trotzdem sieht es im Code schrecklich aus.  Wir werden versuchen, dies zu verbessern, indem wir ein wenig syntaktischen Zucker schreiben. <br><br><div class="spoiler">  <b class="spoiler_title">Operatoren und Verbesserer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        ( -    namespace) __m128 operator + (__m128 const a, __m128 const b) { return _mm_add_ps(a, b); } __m128 operator - (__m128 const a, __m128 const b) { return _mm_sub_ps(a, b); } __m128 operator * (__m128 const a, __m128 const b) { return _mm_mul_ps(a, b); } __m128 operator / (__m128 const a, __m128 const b) { return _mm_div_ps(a, b); } //_mm_shuffle_ps(u, v, _MM_SHUFFLE(3,2,1,0))   shuf&lt;3,2,1,0&gt;(u, v) template &lt;int a, int b, int c, int d&gt; __m128 shuf(__m128 const u, __m128 const v) { return _mm_shuffle_ps(u, v, _MM_SHUFFLE(a, b, c, d)); } template &lt;int a, int b, int c, int d&gt; __m128 shuf(__m128 const v) { return _mm_shuffle_ps(v, v, _MM_SHUFFLE(a, b, c, d)); } //    template &lt;int i&gt; __m128 shuf(__m128 const u, __m128 const v) { return _mm_shuffle_ps(u, v, _MM_SHUFFLE(i, i, i, i)); } template &lt;int i&gt; __m128 shuf(__m128 const v) { return _mm_shuffle_ps(v, v, _MM_SHUFFLE(i, i, i, i)); } //  float       , //    ,    template &lt;int a, int b, int c, int d&gt; __m128 shufd(__m128 const v) { return _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v), _MM_SHUFFLE(a, b, c, d))); } template &lt;int i&gt; __m128 shufd(__m128 const v) { return _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v), _MM_SHUFFLE(i, i, i, i))); }</span></span></code> </pre><br></div></div><br>  Der Compiler kann diese Funktionen perfekt einbinden (wenn auch manchmal ohne __forceinline). <br><br><div class="spoiler">  <b class="spoiler_title">Der Code dreht sich also ...</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ r[<span class="hljs-number"><span class="hljs-number">0</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]); r[<span class="hljs-number"><span class="hljs-number">1</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]); r[<span class="hljs-number"><span class="hljs-number">2</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]); r[<span class="hljs-number"><span class="hljs-number">3</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]); }</code> </pre><br></div></div><br>  Und so ist es schon viel besser und lesbarer.  Zu diesem Zweck erzielte IACA ungef√§hr das erwartete Ergebnis: <em>x86 - 19 (und warum nicht fraktioniert?), X64 - 16</em> .  Tats√§chlich hat sich die Leistung nicht ge√§ndert, aber der Code ist viel sch√∂ner und verst√§ndlicher. <br><br><h4>  Wenig Beitrag zur zuk√ºnftigen Optimierung </h4><br>  Lassen Sie uns eine weitere Verbesserung auf der Ebene einer Funktion einf√ºhren, die k√ºrzlich in der Eisenversion erschien.  Operation <em>Multiple-Add (fma)</em> .  <em><nobr>fma (a, b, c) = a * b + c</nobr></em> . <br><br><div class="spoiler">  <b class="spoiler_title">Implementierung mit mehreren Adds</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">m128 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm_add_ps(_mm_mul_ps(a, b), c); }</code> </pre><br></div></div><br>  Warum ist das notwendig?  Zun√§chst f√ºr die zuk√ºnftige Optimierung.  Zum Beispiel k√∂nnen Sie <em>mad</em> im fertigen Code einfach durch dieselben Makros durch <em>fma</em> ersetzen, wie Sie <em>m√∂chten</em> .  Aber wir werden jetzt den Grundstein f√ºr die Optimierung legen: <br><br><div class="spoiler">  <b class="spoiler_title">Variante mit Mehrfachaddition</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ r[<span class="hljs-number"><span class="hljs-number">0</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>])); r[<span class="hljs-number"><span class="hljs-number">1</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>])); r[<span class="hljs-number"><span class="hljs-number">2</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>])); r[<span class="hljs-number"><span class="hljs-number">3</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br>  IACA: <em>x86 - 18,89, x64 - 16</em> .  Wieder fraktioniert.  Trotzdem f√ºhrt IACA manchmal zu seltsamen Ergebnissen.  Der Code hat sich nicht so sehr ge√§ndert.  Wahrscheinlich noch ein bisschen schlimmer.  Aber die Optimierung erfordert manchmal solche Opfer. <br><br><h4>  Wir gehen zum Speichern durch _mm_stream √ºber </h4><br>  Verschiedene Optimierungshandb√ºcher empfehlen erneut, den Cache nicht f√ºr Massenspeichervorg√§nge zu ziehen.  Dies ist normalerweise gerechtfertigt, wenn Sie Scheitelpunkte verarbeiten, die Tausende oder mehr betragen.  Aber f√ºr Matrizen ist das vielleicht nicht so wichtig.  Ich werde es jedoch trotzdem hinzuf√ºgen. <br><br><div class="spoiler">  <b class="spoiler_title">Stream-Speicheroption</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]))); _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">1</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]))); _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]))); _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">3</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]))); }</code> </pre><br></div></div><br>  Hier hat sich im Laufe der Zeit nichts ge√§ndert.  Den Empfehlungen zufolge ber√ºhren wir den Cache jetzt jedoch nicht mehr. <br><br><h2>  AVX-Implementierung </h2><br><h3>  Basis-AVX-Option </h3><br><img src="https://habrastorage.org/webt/8d/l-/1r/8dl-1rgisfl2sqr0dhzmizkmawg.jpeg" align="right"><br>  Als n√§chstes fahren wir mit der n√§chsten Stufe der Optimierung fort.  Der 4. Float ist im SSE-Register enthalten, und im AVX ist er bereits 8. Das hei√üt, es besteht eine theoretische Chance, die Anzahl der ausgef√ºhrten Operationen zu reduzieren und die Produktivit√§t zu steigern, wenn nicht um die H√§lfte, dann mindestens um das 1,5-fache.  Aber irgendetwas sagt mir, dass mit dem √úbergang zu AVX nicht alles so einfach sein wird.  K√∂nnen wir die notwendigen Daten aus Doppelregistern erhalten? <br><br>  Versuchen wir es herauszufinden.  Wieder schreiben wir unseren oben verwendeten Multiplikationsalgorithmus aus.  Sie k√∂nnen dies nicht tun, aber es ist bequemer, mit dem Code umzugehen, wenn sich alles in der N√§he befindet und Sie keine halbe Seite nach oben scrollen m√ºssen. <br><br><pre> <code class="plaintext hljs">//    : 00, 10, 20, 30, 01, 11, 21, 31, 02, 12, 22, 32, 03, 13, 23, 33 //   SSE: r0 = m0*n00 + m1*n10 + m2*n20 + m3*n30 r1 = m0*n01 + m1*n11 + m2*n21 + m3*n31 r2 = m0*n02 + m1*n12 + m2*n22 + m3*n32 r3 = m0*n03 + m1*n13 + m2*n23 + m3*n33</code> </pre><br>  Am Ausgang erwarten wir das Ergebnis in <em><nobr>ymm = {r0: r1}</nobr></em> und <em><nobr>ymm = {r2: r3}</nobr></em> .  Wenn unser Algorithmus in der SSE-Version auf Spalten verallgemeinert wurde, m√ºssen wir ihn jetzt auf Zeilen verallgemeinern.  Es funktioniert also nicht, wie bei der SSE-Option zu handeln. <br><br>  Wenn wir die Matrix <strong>m</strong> in den Registern <em>ymm betrachten</em> , erhalten wir <em><nobr>ymm = {m0: m1}</nobr></em> bzw. <em><nobr>ymm = {m2: m3}</nobr></em> .  Bisher hatten wir nur Matrixspalten im Register und jetzt Spalten und Zeilen. <br><br>  Wenn Sie versuchen, wie zuvor zu handeln, m√ºssen Sie <em><nobr>ymm = {m0: m1}</nobr></em> mit dem Register <em><nobr>ymm = {n00, n00, n00, n00}: {n10, n10, n10, n10} multiplizieren</nobr></em> .  Da sich <em>n00</em> und <em>n01</em> in derselben Zeile der Matrix <strong>n befinden</strong> , ist es nach dem verf√ºgbaren Satz von AVX-Befehlen teuer, sie um <em>ymm</em> zu <em>streuen</em> .  Sowohl <em>Shuffle</em> als auch <em>Permute</em> arbeiten getrennt f√ºr jeden der beiden Viere eines Schwimmers (hoch und niedrig <em>xmm</em> ) in <em>ymm-</em> Registern. <br><br>  Wenn wir <em>ymm</em> aus der Matrix <strong>n nehmen</strong> , erhalten wir beide Elemente <em>n00</em> und <em>n10</em> im h√∂chsten von 2 <em>xmm</em> innerhalb des <em>ymm-</em> Registers.  <em><nobr>{n00, n10, n20, n30}: {n01, n11, n21, n31}</nobr></em> .  Normalerweise liegt der Index f√ºr vorhandene Anweisungen zwischen 0 und 3. Die Adressen schweben nur innerhalb eines <em>xmm-</em> Registers von zwei innerhalb des <em>ymm-</em> Registers.  Es ist nicht m√∂glich, <em>n10 billig</em> vom √§lteren <em>xmm</em> auf das j√ºngere zu √ºbertragen.  Und dann muss dieser Fokus mehrmals wiederholt werden.  Wir k√∂nnen einen solchen Verlust von Ma√ünahmen nicht ertragen.  Es ist notwendig, sich etwas anderes auszudenken. <br><br>  Fr√ºher haben wir Spalten verallgemeinert, jetzt aber Zeilen.  Deshalb werden wir versuchen, einen etwas anderen Weg zu gehen.  Wir m√ºssen das Ergebnis in <em>{r0: r1} erhalten</em> .  Dies bedeutet, dass der Algorithmus nicht in separaten Zeilen des Algorithmus verbessert werden muss, sondern in zwei gleichzeitig.  Und hier wird das Minus in der Arbeit von <em>Shuffle</em> und <em>Permute</em> ein Plus f√ºr uns sein.  Wir schauen uns an, was wir in den <em>ymm-</em> Registern haben werden, wenn wir die Matrix <strong>n betrachten</strong> . <br><br><pre> <code class="plaintext hljs">n0n1 = {00, 10, 20, 30} : {01, 11, 21, 31} n2n3 = {02, 12, 22, 32} : {03, 13, 23, 33}</code> </pre><br>  Ja, wir bemerken, dass wir in verschiedenen <em>xmm-</em> Teilen des <em>ymm-</em> Registers die Elemente <em>00</em> und <em>01 haben</em> .  Sie k√∂nnen durch Registrierung mit dem Befehl <em><nobr>permute</nobr></em> in <em><nobr>{_00, _00, _00, _00} multipliziert werden: {_ 01, _01, _01, _01}</nobr></em> , wobei nur ein Index 3 f√ºr beide <em>xmm-</em> Teile angegeben wird.  Genau das brauchen wir.  In der Tat werden die Koeffizienten auch in verschiedenen Zeilen verwendet.  Erst jetzt muss im entsprechenden <em>ymm-</em> Register f√ºr die Multiplikation <em>{m0: m0} beibehalten werden, dh</em> die duplizierte erste Zeile der Matrix <strong>m</strong> . <br><br>  Also malen wir den Algorithmus detaillierter.  Wir lesen die doppelten Zeilen der Matrix <strong>m</strong> in <em>ymm-</em> Registern: <br><br><pre> <code class="plaintext hljs">mm[0] = {m0:m0} mm[1] = {m1:m1} mm[2] = {m2:m2} mm[3] = {m3:m3}</code> </pre><br>  Und dann berechnen wir die Multiplikation wie folgt: <br><br><pre> <code class="plaintext hljs">r0r1 = mm[0] * {n00,n00,n00,n00:n01,n01,n01,n01} + // permute&lt;3,3,3,3&gt;(n0n1) mm[1] * {n10,n10,n10,n10:n11,n11,n11,n11} + // permute&lt;2,2,2,2&gt;(n0n1) mm[2] * {n20,n20,n20,n20:n21,n21,n21,n21} + // permute&lt;1,1,1,1&gt;(n0n1) mm[3] * {n30,n30,n30,n30:n31,n31,n31,n31} // permute&lt;0,0,0,0&gt;(n0n1) r2r3 = mm[0] * {n02,n02,n02,n02:n03,n03,n03,n03} + // permute&lt;3,3,3,3&gt;(n2n3) mm[1] * {n12,n12,n12,n12:n13,n13,n13,n13} + // permute&lt;2,2,2,2&gt;(n2n3) mm[2] * {n22,n22,n22,n22:n23,n23,n23,n23} + // permute&lt;1,1,1,1&gt;(n2n3) mm[3] * {n32,n32,n32,n32:n33,n33,n33,n33} // permute&lt;0,0,0,0&gt;(n2n3)</code> </pre><br>  Wir schreiben klarer um: <br><br><pre> <code class="plaintext hljs">r0r1 = mm[0]*n0n1&lt;3,3,3,3&gt;+mm[1]*n0n1&lt;2,2,2,2&gt;+mm[2]*n0n1&lt;1,1,1,1&gt;+mm[3]*n0n1&lt;0,0,0,0&gt; r2r3 = mm[0]*n2n3&lt;3,3,3,3&gt;+mm[1]*n2n3&lt;2,2,2,2&gt;+mm[2]*n2n3&lt;1,1,1,1&gt;+mm[3]*n2n3&lt;0,0,0,0&gt;</code> </pre><br>  Oder in vereinfachter Form: <br><br><pre> <code class="plaintext hljs">r0r1 = mm[0]*n0n1&lt;3&gt; + mm[1]*n0n1&lt;2&gt; + mm[2]*n0n1&lt;1&gt; + mm[3]*n0n1&lt;0&gt; r2r3 = mm[0]*n2n3&lt;3&gt; + mm[1]*n2n3&lt;2&gt; + mm[2]*n2n3&lt;1&gt; + mm[3]*n2n3&lt;0&gt;</code> </pre><br>  Alles scheint klar zu sein. <br><br><div class="spoiler">  <b class="spoiler_title">Es bleibt nur eine Implementierung zu schreiben</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx_v1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ __m256 mm0 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], m[<span class="hljs-number"><span class="hljs-number">0</span></span>]); __m256 mm1 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], m[<span class="hljs-number"><span class="hljs-number">1</span></span>]); __m256 mm2 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], m[<span class="hljs-number"><span class="hljs-number">2</span></span>]); __m256 mm3 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], m[<span class="hljs-number"><span class="hljs-number">3</span></span>]); __m256 n0n1 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); __m256 y1 = _mm256_permute_ps(n0n1, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>);<span class="hljs-comment"><span class="hljs-comment">//3,3,3,3 __m256 y2 = _mm256_permute_ps(n0n1, 0xAA);//2,2,2,2 __m256 y3 = _mm256_permute_ps(n0n1, 0x55);//1,1,1,1 __m256 y4 = _mm256_permute_ps(n0n1, 0x00);//0,0,0,0 y1 = _mm256_mul_ps(y1, mm0); y2 = _mm256_mul_ps(y2, mm1); y3 = _mm256_mul_ps(y3, mm2); y4 = _mm256_mul_ps(y4, mm3); y1 = _mm256_add_ps(y1, y2); y3 = _mm256_add_ps(y3, y4); y1 = _mm256_add_ps(y1, y3); __m256 n2n3 = _mm256_load_ps(&amp;n[2].m128_f32[0]); __m256 y5 = _mm256_permute_ps(n2n3, 0xFF); __m256 y6 = _mm256_permute_ps(n2n3, 0xAA); __m256 y7 = _mm256_permute_ps(n2n3, 0x55); __m256 y8 = _mm256_permute_ps(n2n3, 0x00); y5 = _mm256_mul_ps(y5, mm0); y6 = _mm256_mul_ps(y6, mm1); y7 = _mm256_mul_ps(y7, mm2); y8 = _mm256_mul_ps(y8, mm3); y5 = _mm256_add_ps(y5, y6); y7 = _mm256_add_ps(y7, y8); y5 = _mm256_add_ps(y5, y7); _mm256_stream_ps(&amp;r[0].m128_f32[0], y1); _mm256_stream_ps(&amp;r[2].m128_f32[0], y5); }</span></span></code> </pre><br></div></div><br>  Hier sind die interessanten Zahlen von IACA: <em>x86 - 12.53, x64 - 12</em> .  Obwohl ich nat√ºrlich besser wollte.  Etwas verpasst. <br><br><h3>  AVX-Optimierung plus syntaktischer Zucker </h3><br>  Es scheint, dass im obigen Code AVX nicht in vollem Umfang genutzt wurde.  Wir stellen fest, dass wir anstelle von zwei identischen Zeilen im <strong>ymm-</strong> Register <em>Broadcast verwenden</em> k√∂nnen, der das <em>ymm-</em> Register mit zwei identischen <em>xmm-</em> Werten f√ºllen kann.  F√ºgen Sie auf dem Weg auch etwas ‚Äûsyntaktischen Zucker‚Äú f√ºr die AVX-Funktionen hinzu. <br><br><div class="spoiler">  <b class="spoiler_title">Erweiterte AVX-Implementierung</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> + (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_add_ps(a, b); } __m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> - (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_sub_ps(a, b); } __m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_mul_ps(a, b); } __m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> / (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_div_ps(a, b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permute_ps(v, _MM_SHUFFLE(i, i, i, i)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permute_ps(v, _MM_SHUFFLE(a, b, c, d)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permutevar_ps(v, _mm256_set_epi32(i, i, i, i, j, j, j, j)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> e, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> f, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permutevar_ps(v, _mm256_set_epi32(a, b, c, d, e, f, g, h)); } __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_add_ps(_mm256_mul_ps(a, b), c); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx_v2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mm[] { _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">0</span></span>), _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">1</span></span>), _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">2</span></span>), _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">3</span></span>) }; __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n0n1 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ mad(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n2n3 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ mad(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br>  Und hier sind die Ergebnisse schon interessanter.  IACA produziert Zahlen: <em>x86 - 10, x64 - 8.58</em> , was viel besser aussieht, aber immer noch nicht zweimal. <br><br><h3>  AVX + FMA Option (endg√ºltig) </h3><br>  Machen wir noch einen Versuch.  Jetzt w√§re es logisch, den FMA-Befehlssatz erneut abzurufen, da er nach AVX zu den Prozessoren hinzugef√ºgt wurde.  √Ñndern Sie einfach einzelne <em>Mul + Add</em> f√ºr eine Operation.  Obwohl wir immer noch die Anweisung der Multiplikation verwenden, um dem Compiler mehr M√∂glichkeiten zur Optimierung und dem Prozessor die parallele Ausf√ºhrung von Multiplikationen zu geben.  Normalerweise schaue ich mir den generierten Code im Assembler an, um sicherzustellen, welche Option besser ist. <br><br>  In diesem Fall m√ºssen wir <em><nobr>a * b + c * d + e * f + g * h</nobr></em> berechnen.  Sie k√∂nnen diese Stirn tun: <em><nobr>fma (a, b, fma (c, d, fma (e, f, g * h)))</nobr></em> .  Wie wir jedoch sehen, ist es hier unm√∂glich, eine Operation durchzuf√ºhren, ohne die vorherige abzuschlie√üen.  Dies bedeutet, dass wir nicht in der Lage sein werden, gepaarte Multiplikationen durchzuf√ºhren, wie dies die SIMD-Pipeline erm√∂glicht.  Wenn wir die Berechnungen <em><nobr>fma (a, b, c * d) + fma (e, f, g * h)</nobr></em> leicht transformieren, werden wir sehen, dass wir die Berechnungen parallelisieren k√∂nnen.  <em>F√ºhren Sie</em> zuerst zwei unabh√§ngige Multiplikationen und dann zwei unabh√§ngige <em>fma-</em> Operationen durch. <br><br><div class="spoiler">  <b class="spoiler_title">AVX + FMA-Implementierung</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_fmadd_ps(a, b, c); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx_fma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mm[]{ _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">0</span></span>), _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">1</span></span>), _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">2</span></span>), _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">3</span></span>) }; __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n0n1 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], fma(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ fma(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n2n3 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], fma(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ fma(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br>  IACA: <em>x86 - 9,21, x64 - 8</em> .  Jetzt ist es sehr gut.  Jemand wird wahrscheinlich sagen, was noch besser gemacht werden kann, aber ich wei√ü nicht wie. <br><br><h2>  Benchmarks </h2><br>  Ich stelle sofort fest, dass diese Zahlen nicht als die ultimative Wahrheit angesehen werden sollten.  Selbst mit einem festen Test schwimmen sie innerhalb bestimmter Grenzen.  Und noch mehr verhalten sie sich auf verschiedenen Plattformen unterschiedlich.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nehmen Sie bei jeder Optimierung Messungen speziell f√ºr Ihren Fall vor. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inhaltsverzeichnis </font></font></h4><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktion: Funktionsname. </font><font style="vertical-align: inherit;">Das Ende auf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - funktioniert mit einem Streaming, anders normal mov (ohne Streaming). </font><font style="vertical-align: inherit;">Zur Verdeutlichung hinzugef√ºgt, da dies wichtig genug ist.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IACA-Zyklen: Anzahl der von IACA berechneten Ticks pro Funktion </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gemessene Zyklen: gemessene Anzahl von Messungen (weniger ist mehr) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IACA-Beschleunigung: Anzahl der Kennzahlen in einer Nulllinie / Anzahl der Kennzahlen in einer Zeile </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gemessene Beschleunigung: Anzahl der Takte in der Nulllinie / Anzahl der Takte in der Linie (je mehr desto besser) </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr loop_m wurden die Ticks aus dem Artikel mit 64 multipliziert. Dies ist ein sehr ungef√§hrer Wert. </font><font style="vertical-align: inherit;">Tats√§chlich stellte sich heraus, dass dies so war.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> i3-3770: </font></font></h3><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86</font></font></b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IACA-Zyklen </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gemessene Zyklen </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IACA-Beschleunigung </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gemessene Beschleunigung </font></font></th></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unroll_m </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 70,00 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 50,75 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1,00 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1,00 </font></font></th></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> loop_m </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 233,60 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 119,21 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,30 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,43 </font></font></th></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sse_v1m </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 18.89 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 27.51 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3,70 </font></font></th><th>  1,84 </th></tr><tr><th> sse_v2m </th><th> 19.00 </th><th> 27.61 </th><th> 3.68 </th><th>  1,84 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 27.22 </th><th> 3.70 </th><th> 1.86 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 27.18 </th><th> 3.70 </th><th> 1.87 </th></tr><tr><th> avx_v1m </th><th> 13.00 </th><th> 19.21 </th><th> 5.38 </th><th> 2.64 </th></tr><tr><th> avx_v1s </th><th> 13.00 </th><th>  20.03 </th><th> 5.38 </th><th> 2.53 </th></tr><tr><th> avx_v2m </th><th> 10.00 </th><th> 12.91 </th><th>  6,99 </th><th> 3.93 </th></tr><tr><th> avx_v2s </th><th> 10.00 </th><th> 17.34 </th><th>  6,99 </th><th> 2.93 </th></tr></tbody></table></div></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x64</font></font></b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th>  70 </th><th> 68.60 </th><th> 1.00 </th><th> 1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 119.37 </th><th> 0.30 </th><th>  0,57 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th>  21,98 </th><th> 3.70 </th><th> 3.12 </th></tr><tr><th> sse_v2m </th><th> 19.00 </th><th> 21.09 </th><th> 3.68 </th><th>  3.25 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 22.19 </th><th> 3.70 </th><th> 3.09 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 22.39 </th><th> 3.70 </th><th>  3,06 </th></tr><tr><th> avx_v1m </th><th> 13.00 </th><th> 9.61 </th><th> 5.38 </th><th> 7.13 </th></tr><tr><th> avx_v1s </th><th> 13.00 </th><th> 16.90 </th><th> 5.38 </th><th> 4.06 </th></tr><tr><th> avx_v2m </th><th> 10.00 </th><th> 9.20 </th><th>  6,99 </th><th>  7.45 </th></tr><tr><th> avx_v2s </th><th> 10.00 </th><th> 14.64 </th><th>  6,99 </th><th> 4.68 </th></tr></tbody></table></div></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> i7-8700K: </font></font></h3><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86</font></font></b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th> 69.95 </th><th> 40.25 </th><th> 1.00 </th><th> 1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 79.49 </th><th> 0.30 </th><th>  0,51 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th> 19.31 </th><th> 3.70 </th><th> 2.09 </th></tr><tr><th> sse_v2m </th><th> 19.00 </th><th> 19.98 </th><th> 3.68 </th><th>  2.01 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 19.69 </th><th> 3.70 </th><th>  2,04 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 19.67 </th><th> 3.70 </th><th>  2.05 </th></tr><tr><th> avx_v1m </th><th> 13.00 </th><th> 14.22 </th><th> 5.38 </th><th>  2.83 </th></tr><tr><th> avx_v1s </th><th> 13.00 </th><th> 14.13 </th><th> 5.38 </th><th>  2,85 </th></tr><tr><th> avx_v2m </th><th> 10.00 </th><th> 11.73 </th><th>  6,99 </th><th>  3.43 </th></tr><tr><th> avx_v2s </th><th> 10.00 </th><th> 11.81 </th><th>  6,99 </th><th>  3.41 </th></tr><tr><th> AVX+FMAm </th><th> 9.21 </th><th> 10.38 </th><th> 7.60 </th><th> 3.88 </th></tr><tr><th> AVX+FMAs </th><th> 9.21 </th><th> 10.32 </th><th> 7.60 </th><th> 3.90 </th></tr></tbody></table></div></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x64</font></font></b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th> 69.95 </th><th> 57.11 </th><th> 1.00 </th><th> 1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 75.73 </th><th> 0.30 </th><th> 0.75 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th> 15.83 </th><th> 3.70 </th><th> 3.61 </th></tr><tr><th> sse_v2m </th><th> 19.00 </th><th> 17.22 </th><th> 3.68 </th><th> 3.32 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 15.92 </th><th> 3.70 </th><th>  3.59 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 16.18 </th><th> 3.70 </th><th> 3.53 </th></tr><tr><th> avx_v1m </th><th> 13.00 </th><th> 7.03 </th><th> 5.38 </th><th> 8.12 </th></tr><tr><th> avx_v1s </th><th> 13.00 </th><th> 12.98 </th><th> 5.38 </th><th> 4.40 </th></tr><tr><th> avx_v2m </th><th> 10.00 </th><th> 5.40 </th><th>  6,99 </th><th> 10.57 </th></tr><tr><th> avx_v2s </th><th> 10.00 </th><th> 11.39 </th><th>  6,99 </th><th>  5.01 </th></tr><tr><th> AVX+FMAm </th><th> 9.21 </th><th>  9.73 </th><th> 7.60 </th><th> 5.87 </th></tr><tr><th> AVX+FMAs </th><th> 9.21 </th><th> 9.81 </th><th> 7.60 </th><th> 5.82 </th></tr></tbody></table></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testcode in der Quelle. </font><font style="vertical-align: inherit;">Wenn es vern√ºnftige Vorschl√§ge gibt, wie man sie verbessern kann, schreibe in die Kommentare.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> BONUS aus dem Bereich der Fiktion </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigentlich ist es aus dem Bereich der Fiktion, denn wenn ich Prozessoren mit Unterst√ºtzung f√ºr AVX512 gesehen habe, dann vielleicht auf den Bildern. </font><font style="vertical-align: inherit;">Ich habe jedoch versucht, den Algorithmus zu implementieren. </font><font style="vertical-align: inherit;">Hier werde ich nichts erkl√§ren, eine komplette Analogie zu AVX + FMA. </font><font style="vertical-align: inherit;">Der Algorithmus ist der gleiche, nur weniger Operationen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie sie sagen, lasse ich es einfach hier</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">__m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> + (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_add_ps(a, b); } __m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> - (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_sub_ps(a, b); } __m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_mul_ps(a, b); } __m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> / (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_div_ps(a, b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i&gt; __<span class="hljs-function"><span class="hljs-function">m512 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_permute_ps(v, _MM_SHUFFLE(i, i, i, i)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d&gt; __<span class="hljs-function"><span class="hljs-function">m512 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_permute_ps(v, _MM_SHUFFLE(a, b, c, d)); } __<span class="hljs-function"><span class="hljs-function">m512 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_fmadd_ps(a, b, c); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx512</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _n)</span></span></span><span class="hljs-function"> </span></span>{ __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mm[]{ _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">0</span></span>]), _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">1</span></span>]), _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">2</span></span>]), _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">3</span></span>]) }; __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n = _mm512_load_ps(&amp;_n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm512_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], fma(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ fma(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zahlen sind fantastisch: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86 - 4.79, x64 - 5.42</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (IACA mit SKX-Architektur). </font><font style="vertical-align: inherit;">Dies trotz der Tatsache, dass der Algorithmus 64 Multiplikationen und 48 Additionen hat.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PS-Code aus dem Artikel </font></font></h2><br><div class="oembed"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/truthfinder/mul_m4_m4</font></font></a> </div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist meine erste Erfahrung beim Schreiben eines Artikels. </font><font style="vertical-align: inherit;">Vielen Dank f√ºr Ihre Kommentare. </font><font style="vertical-align: inherit;">Sie helfen, den Code und den Artikel besser zu machen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418247/">https://habr.com/ru/post/de418247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418237/index.html">Entwicklung mandantenf√§higer Anwendungen auf der SAP Cloud Platform in Neo, Teil 2: Autorisierung und Authentifizierung</a></li>
<li><a href="../de418239/index.html">48 Megapixel f√ºr Smartphone</a></li>
<li><a href="../de418241/index.html">Warum Gau√ü? (100 M√∂glichkeiten, das Gleichungssystem zu l√∂sen)</a></li>
<li><a href="../de418243/index.html">Die popul√§re Geschichte der Astronomie ist falsch</a></li>
<li><a href="../de418245/index.html">Wie man kein Projekt auf Bitrix entwickelt</a></li>
<li><a href="../de418249/index.html">Neue VM-Images der Google Compute Engine f√ºr Deep Learning</a></li>
<li><a href="../de418251/index.html">Computer Vision: Wie KI uns beobachtet</a></li>
<li><a href="../de418253/index.html">Der fr√ºhe Mond k√∂nnte Wasser, Atmosph√§re und Leben haben</a></li>
<li><a href="../de418255/index.html">Wie Verkehrsb√∂rsen Autosurfen weiterverkaufen und woher Millionen von Bots online kommen</a></li>
<li><a href="../de418257/index.html">Github.com weigert sich, jQuery zu verwenden und wechselt zu reinem JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>