<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚯 🤹🏻 👩🏾‍🔧 PostgreSQL-3中的MVCC。 行版本 🌸 🤲🏻 🤛🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="好了，我们已经讨论过隔离，并且对低级数据结构做了题外话。 我们终于达到了最令人着迷的东西，即行版本（元组）。 

 元组头 
 如前所述，数据库中可以同时使用每行的多个版本。 我们需要以某种方式将一个版本与另一个版本区分开。 为此，每个版本均标有有效的“时间”（ xmin ）和到期的“时间”（ xm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL-3中的MVCC。 行版本</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/477648/"> 好了，我们已经讨论过<a href="https://habr.com/ru/company/postgrespro/blog/467437/">隔离，</a>并且<a href="https://habr.com/ru/company/postgrespro/blog/469087/">对低级数据结构</a>做了题外话。 我们终于达到了最令人着迷的东西，即行版本（元组）。 <br><br><h1> 元组头 </h1><br> 如前所述，数据库中可以同时使用每行的多个版本。 我们需要以某种方式将一个版本与另一个版本区分开。 为此，每个版本均标有有效的“时间”（ <code>xmin</code> ）和到期的“时间”（ <code>xmax</code> ）。 引号表示使用特殊的递增计数器，而不是时间本身。 这个计数器是<em>交易标识符</em> 。 <br><br>  （通常，这实际上更加复杂：由于计数器的位深度有限，交易ID不能总是递增。但是，当我们的讨论陷入僵局时，我们将探索其更多细节。） <br><a name="habracut"></a><br> 创建行时，将<code>xmin</code>的值设置为等于执行INSERT命令的事务的ID，而未填写<code>xmax</code> 。 <br><br> 删除一行后，当前版本的<code>xmax</code>值将标记有执行DELETE的事务的ID。 <br><br>  UPDATE命令实际上执行两个后续操作：DELETE和INSERT。 在该行的当前版本中，将<code>xmax</code>设置为等于执行UPDATE的事务的ID。 然后，创建同一行的新版本，其中<code>xmin</code>的值与先前版本的<code>xmax</code>相同。 <br><br>  <code>xmin</code>和<code>xmax</code>字段包含在行版本的标题中。 除了这些字段外，元组头还包含其他字段，例如： <br><br><ul><li>  <code>infomask</code>确定给定元组属性的几个位。 其中有很多，我们将逐步讨论。 </li><li>  <code>ctid</code>对同一行的下一个更新版本的引用。 最新的行版本的<code>ctid</code>引用该版本。 该数字采用<code>(x,y)</code>形式，其中<code>x</code>是页面的编号，而<code>y</code>是数组中指针的顺序号。 </li><li>  NULL位图，用于标记给定版本中包含NULL的那些列。  NULL不是数据类型的常规值，因此，我们必须单独存储此特征。 </li></ul><br> 结果，标题看起来非常大：每个元组至少23个字节，但是由于NULL位图而通常更大。 如果表是“窄”的（即，它包含的列很少），则开销字节会比有用信息占用更多空间。 <br><br><h1> 插入 </h1><br> 让我们更详细地看一下如何在低级别执行行操作，并从插入开始。 <br><br> 为了进行试验，我们将创建一个新表，其中包含两列，并在其中一列上具有索引： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">text</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t(s);</code> </pre><br> 我们开始一个事务以插入一行。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>);</code> </pre><br> 这是我们当前交易的ID： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3664 (1 row)</code> </pre><br> 让我们看一下页面的内容。 来自“ pageinspect”扩展名的<code>heap_page_items</code>函数使我们能够获取有关指针和行版本的信息： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------- lp | 1 lp_off | 8160 lp_flags | 1 lp_len | 32 t_xmin | 3664 t_xmax | 0 t_field3 | 0 t_ctid | (0,1) t_infomask2 | 2 t_infomask | 2050 t_hoff | 24 t_bits | t_oid | t_data | \x0100000009464f4f</code> </pre><br> 请注意，PostgreSQL中的“堆”一词表示表。 这是术语的另一种怪异用法：堆是已知的<a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">数据结构</a> ，与表无关。 此处使用的单词的含义是“全部堆积”，这与有序索引不同。 <br><br> 此功能以难以理解的格式“按原样”显示数据。 为了澄清问题，我们仅保留部分信息并进行解释： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> lp_flags <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'unused'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'redirect to '</span></span>||lp_off <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> state, t_xmin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmin, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">256</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">512</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_aborted, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">1024</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">2048</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_aborted, t_ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]-+------- ctid | (0,1) state | normal xmin | 3664 xmax | 0 xmin_commited | f xmin_aborted | f xmax_commited | f xmax_aborted | t t_ctid | (0,1)</code> </pre><br> 我们做了以下工作： <br><br><ul><li> 在指针编号上添加了零，使其看起来像<code>t_ctid</code> ：（页面编号，指针编号）。 </li><li> 解释了<code>lp_flags</code>指针的状态。 这里是“正常”的，这意味着指针实际上引用了行版本。 稍后我们将讨论其他值。 </li><li> 到目前为止，在所有信息位中，我们仅选择了两对。  <code>xmin_committed</code>和<code>xmin_aborted</code>位显示ID为<code>xmin</code>的事务是否已提交（回退）。 一对相似的比特与ID为<code>xmax</code>的交易有关。 </li></ul><br> 我们观察到什么？ 当插入一行时，在表格页面中会出现一个指针，该指针的编号为1，并引用该行的第一个和唯一版本。 <br><br> 元组中的<code>xmin</code>字段填充有当前事务的ID。 由于事务仍处于活动状态，因此<code>xmin_committed</code>和<code>xmin_aborted</code>位均未设置。 <br><br> 行版本的<code>ctid</code>字段引用同一行。 这意味着没有新版本可用。 <br><br> 由于没有删除元组（即最新），因此<code>xmax</code>字段用常规数字0填充。 由于设置了<code>xmax_aborted</code>位，事务将忽略该数字。 <br><br> 通过将信息位附加到事务ID上，我们又向前迈出了一步，以提高可读性。 并且创建函数，因为我们将不止一次需要查询： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> heap_page_items(get_raw_page(relname,pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br> 在行版本的标题中发生的事情，这种形式更加清楚： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br> 通过使用<code>xmin</code>和<code>xmax</code>伪列，我们可以从表本身获得类似的信息，但详细程度要低得多： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3664 | 0 | 1 | FOO (1 row)</code> </pre><br><h1> 提交 </h1><br> 事务成功时，必须记住其状态，即，必须将事务标记为已提交。 为此，使用了XACT结构。  （在版本10之前，它称为CLOG（提交日志），您仍然很可能会遇到此名称。） <br><br>  XACT不是系统目录的表，而是PGDATA / pg_xact目录中的文件。 在这些文件中为每个事务分配了两位（“已提交”和“已中止”），其方式与元组头中的方式完全相同。 此信息只是为了方便而散布在几个文件中。 在讨论冻结时，我们将回到这一点。  PostgreSQL与所有其他文件一样，逐页处理这些文件。 <br><br> 因此，提交事务后，将在XACT中为此事务设置“已提交”位。 这就是提交事务时发生的所有事情（尽管我们还没有提到预写日志）。 <br><br> 当其他事务访问我们刚刚查看的表页面时，前者将不得不回答一些问题。 <br><br><ol><li> 交易<code>xmin</code>是否已完成？ 如果不是，则创建的元组必须不可见。 <br> 通过查看位于实例的共享内存中的另一个结构ProcArray可以检查此情况。 此结构包含所有活动进程的列表，以及每个进程的当前（活动）事务的ID。 </li><li> 如果交易完成，那么是提交还是回滚？ 如果已回滚，则该元组也不得可见。 <br> 这正是XACT所需要的。 但是，尽管XACT的最后一页存储在共享内存的缓冲区中，但每次检查XACT的开销都很高。 因此，一旦确定了交易状态， <code>xmin_committed</code>其写入元组的<code>xmin_committed</code>和<code>xmin_aborted</code>位。 如果设置了这些位中的任何一个，则将事务状态视为已知​​，并且下一个事务将不需要检查XACT。 </li></ol><br> 为什么执行插入的事务未设置这些位？ 当执行插入操作时，事务尚不知道它是否将成功完成。 在提交时，还不清楚哪些行和哪些页面已更改。 这样的页面可能很多，要跟踪它们是不切实际的。 此外，某些页面可以从缓冲区高速缓存中逐出到磁盘上。 再次读取它们以更改位将意味着提交速度显着下降。 <br><br> 节省成本的反面是，更新之后，任何事务（甚至是执行SELECT的事务）都可以开始更改缓冲区高速缓存中的数据页。 <br><br> 因此，我们提交更改。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 页面中没有任何更改（但是我们知道事务状态已经写入XACT）： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br> 现在，首先访问该页面的事务将需要确定事务<code>xmin</code>的状态，并将其写入信息位： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 0 (a) | (0,1) (1 row)</code> </pre><br><h1> 删掉 </h1><br> 当删除一行时，当前删除事务的ID会写入最新版本的<code>xmax</code>字段，并且<code>xmax_aborted</code>位将被重置。 <br><br> 请注意，与活动事务相对应的<code>xmax</code>值用作行锁。 如果另一个事务要更新或删除该行，则必须等到<code>xmax</code>事务完成。 稍后我们将更详细地讨论锁。 此时，仅注意行锁的数量没有限制。 它们不占用内存，并且该数量不会影响系统性能。 但是，持久的交易还有其他缺点，稍后将对此进行讨论。 <br><br> 让我们删除一行。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3665 (1 row)</code> </pre><br> 我们看到事务ID被写入<code>xmax</code>字段，但是未设置信息位： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br><h1> 中止 </h1><br> 事务中止的工作与提交类似，只是在XACT中设置了“中止”位。 中止与提交一样快。 尽管该命令称为ROLLBACK，但更改不会回滚：事务已更改的所有内容均保持不变。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br> 当访问该页面时，将检查状态并设置提示位<code>xmax_aborted</code> 。 尽管数字<code>xmax</code>本身仍将在页面中，但不会看到它。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+----------+-------- (0,1) | normal | 3664 (c) | 3665 (a) | (0,1) (1 row)</code> </pre><br><h1> 更新资料 </h1><br> 更新的工作方式就像先删除当前版本，然后插入新版本一样。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3666 (1 row)</code> </pre><br> 查询返回一行（新版本）： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | BAR (1 row)</code> </pre><br> 但是我们可以在页面中看到两个版本： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 3666 | (0,2) (0,2) | normal | 3666 | 0 (a) | (0,2) (2 rows)</code> </pre><br> 删除的版本在<code>xmax</code>字段中标有当前交易的ID。 此外，自从上次事务回滚以来，此值已覆盖了旧值。 由于当前事务的状态尚不清楚，因此将<code>xmax_aborted</code>位复位。 <br><br> 该行的第一个版本现在引用第二个版本，作为较新的版本。 <br><br> 索引页现在包含第二个指针和第二行，该行引用表页面中的第二个版本。 <br><br> 与删除相同，第一个版本中的<code>xmax</code>值指示该行已锁定。 <br><br> 最后，我们提交交易。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1> 指标 </h1><br> 到目前为止，我们仅谈论表页面。 但是索引内部会发生什么？ <br><br> 索引页中的信息高度取决于特定的索引类型。 而且，即使一种类型的索引也可以具有不同种类的页面。 例如：B树具有元数据页面和“常规”页面。 <br><br> 但是，索引页通常具有一个指向行和行本身的指针数组（就像表页一样）。 此外，页面末尾的一些空间还分配给特殊数据。 <br><br> 索引中的行也可以具有不同的结构，具体取决于索引类型。 例如：在B树中，与叶子页相关的行包含索引键的值和对相应表行的引用（ <code>ctid</code> ）。 通常，索引的结构可以完全不同。 <br><br> 要点是，在任何类型的索引中都没有行<em>版本</em> 。 或者我们可以考虑每一行仅由一个版本表示。 换句话说，索引行的标题不包含<code>xmin</code>和<code>xmax</code>字段。 现在，我们可以假设从索引指向表行的所有版本的引用。 因此，要确定事务中可见哪些行版本，PostgreSQL需要调查表。  （像往常一样，这还不是全部内容。有时可见性图可以优化流程，但我们稍后会讨论。） <br><br> 在这里，在索引页面中，我们找到两个版本的指针：最新版本和之前版本： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> itemoffset, ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'t_s_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,1) (2 rows)</code> </pre><br><h1> 虚拟交易 </h1><br> 实际上，PostgreSQL利用了优化的优势，该优化允许“少量”使用事务ID。 <br><br> 如果事务仅读取数据，则根本不会影响元组的可见性。 因此，首先，后端进程将虚拟ID（虚拟xid）分配给事务。 该ID由进程标识符和序列号组成。 <br><br> 该虚拟ID的分配不需要所有进程之间的同步，因此可以非常快速地执行。 在讨论冻结时，我们将了解使用虚拟ID的另一个原因。 <br><br> 数据快照根本不考虑虚拟ID。 <br><br> 在不同的时间点，系统可以具有已使用ID的虚拟事务，这很好。 但是此ID无法写入数据页，因为下次访问该页时，该ID可能变得毫无意义。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- (1 row)</code> </pre><br> 但是，如果事务开始更改数据，它将收到一个真实的，唯一的事务ID。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1.00</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- 3667 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1> 子交易 </h1><br><h2> 保存点 </h2><br> 在SQL中，定义了<em>保存点</em> ，这些<em>保存点</em>允许回滚事务的某些操作而无需完全中止。 但这与上述模型不兼容，因为事务状态是所有更改的结果之一，并且没有物理回滚的数据。 <br><br> 为了实现此功能，带有保存点的事务被分为几个单独的<em>子事务，</em>其状态可以分别进行管理。 <br><br> 子交易具有自己的ID（大于主交易的ID）。 子事务的状态以通常的方式写入XACT，但是最终状态取决于主事务的状态：如果回滚，则所有子事务也会回滚。 <br><br> 有关子事务嵌套的信息存储在PGDATA / pg_subtrans目录的文件中。 这些文件是通过实例共享内存中的缓冲区访问的，这些缓冲区的结构与XACT缓冲区相同。 <br><br> 不要将子事务与自主事务混淆。 自主事务绝不相互依赖，而子事务却相互依赖。 常规PostgreSQL中没有自治事务，这可能会变得更好：实际上很少需要它们，并且它们在其他DBMS中的可用性会导致滥用，每个人都会遭受痛苦。 <br><br> 让我们清除表，开始事务并插入一行： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (1 row)</code> </pre><br> 现在我们建立一个保存点并插入另一行。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SAVEPOINT</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XYZ'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br> 请注意， <code>txid_current</code>函数返回主事务的ID，而不是子事务的ID。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3670 | 0 | 3 | XYZ (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 | 0 (a) | (0,2) (2 rows)</code> </pre><br> 让我们回滚到保存点并插入第三行。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'BAR'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 | 0 (a) | (0,3) (3 rows)</code> </pre><br> 在页面中，我们继续看到由回滚子事务添加的行。 <br><br> 提交更改。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (3 rows)</code> </pre><br> 现在可以清楚地看到每个子事务都有其自己的状态。 <br><br> 请注意，SQL不允许显式使用子事务，也就是说，您不能在完成当前事务之前启动新事务。 在使用保存点时以及在处理PL / pgSQL异常时，以及在其他一些更特殊的情况下，都将隐式涉及此技术。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is already a transaction in progress BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is no transaction in progress COMMIT</code> </pre><br><h2> 错误和操作原子性 </h2><br> 如果在执行操作时发生错误怎么办？ 例如，像这样： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br> 发生错误。 现在，该事务被视为已中止，并且其中不允许进行任何操作： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs">ERROR: current transaction is aborted, commands ignored until end of transaction block</code> </pre><br> 即使我们尝试提交更改，PostgreSQL也会报告回滚： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ROLLBACK</code> </pre><br> 为什么失败后无法继续执行事务？ 问题是可能发生错误，以便我们可以访问部分更改，也就是说，不仅对于事务，甚至对于单个操作员，原子性都将被破坏。 例如，在我们的示例中，操作员可以在发生错误之前更新一行： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 3672 | (0,4) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (0,4) | normal | 3672 | 0 (a) | (0,4) (4 rows)</code> </pre><br> 值得注意的是，psql具有一种模式，该模式允许在失败后继续执行事务，就好像回滚了错误运算符的影响一样。 <br><br><pre> <code class="pgsql hljs">=&gt; \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ON_ERROR_ROLLBACK <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 很容易弄清楚，在这种模式下，psql实际上在每个命令之前建立一个隐式保存点，并在失败时向其发起回滚。 默认情况下不使用此模式，因为建立保存点（即使不回滚保存点）也需要大量开销。 <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/479512/">继续阅读</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN477648/">https://habr.com/ru/post/zh-CN477648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN477634/index.html">微服务和组织结构。 哪些类型的团队将确保成功？</a></li>
<li><a href="../zh-CN477638/index.html">=您的：约翰迪尔（John Deere）剥夺了农民修理自己的拖拉机的权利</a></li>
<li><a href="../zh-CN477642/index.html">机器（无线电）视觉穿透墙壁</a></li>
<li><a href="../zh-CN477644/index.html">将UNIX v0还原到PDP-7：后台详细信息</a></li>
<li><a href="../zh-CN477646/index.html">数学家切割形状以寻找方程的一部分</a></li>
<li><a href="../zh-CN477650/index.html">使用Stunnel根据GOST-2012算法对TLS流量进行加密</a></li>
<li><a href="../zh-CN477654/index.html">在Java 14中尝试改进的instanceof运算符</a></li>
<li><a href="../zh-CN477656/index.html">那么，为什么还需要make？</a></li>
<li><a href="../zh-CN477658/index.html">Active Restore：灾难恢复可以更快吗？ 快多了？</a></li>
<li><a href="../zh-CN477662/index.html">在FTDI桥上使用Redd轮胎</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>