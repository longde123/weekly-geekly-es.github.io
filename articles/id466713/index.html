<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🏭 💅 👩🏼‍🏭 Apakah mungkin dalam 1C untuk tidak mengamati teknologi komponen eksternal? Atau Bagaimana cara memberi selamat kepada kolega menggunakan 1C? 🚱 🔐 🦕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada ide di sini untuk memberi selamat kepada kepala akuntan kami dengan cara yang kurang lebih orisinal, misalnya, dengan bantuan program 1C favoritny...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apakah mungkin dalam 1C untuk tidak mengamati teknologi komponen eksternal? Atau Bagaimana cara memberi selamat kepada kolega menggunakan 1C?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466713/">  Ada ide di sini untuk memberi selamat kepada kepala akuntan kami dengan cara yang kurang lebih orisinal, misalnya, dengan bantuan program 1C favoritnya?  Tapi bagaimana caranya? <br><br>  Setelah beberapa pemikiran, idenya mulai digunakan untuk latar belakang selamat gambar latar belakang di area klien dari bentuk konvensional untuk konfigurasi pada 1C77-1C82 atau di jendela eksternal untuk formulir yang dikelola 1C82 dan dalam semua kasus untuk 1C83.  Di atasnya, tampilkan pesan yang diinginkan dan berikan tautan ke video ucapan selamat, seperti yang ditunjukkan pada gambar. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a77/0bd/055/a770bd055ca43fdb5ad8d6f1f124253b.jpg" alt="Selamat dalam 1C"><br><a name="habracut"></a><br><h2>  Bagian Satu - Menghasilkan </h2><br>  Jelas, ide ini bukanlah hal baru.  Jadi, pada 2011, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">solusi serupa</a> diusulkan berdasarkan <b>FormEx.dll, oleh <i>Aleksey Fedorov alias ALF</i></b> .  Dan pertanyaan tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagaimana mencapai ini</a> ditanyakan kembali pada tahun 2008. <br><br>  Pada suatu waktu, kami juga menggunakan komponen ini untuk memuat gambar latar belakang ke 1C77.  Tetapi mengunduh file-file bmp besar (dan yang lain tidak dapat digunakan) lambat (karena ini, gambar-gambar kecil yang diletakkan dengan ubin digunakan), jadi ada keinginan untuk menulis komponen eksternal Anda sendiri (VK), yang hanya akan mengunduh gambar yang diperlukan dan tidak lebih, kecuali apa lagi yang menjadi dasar pengujian untuk eksperimen. <br><br>  Komponen seperti itu ditulis (juga, hanya untuk file-file bmp, menggunakan, jika perlu, ubin).  Fungsi <b>WinAPI LoadImage ()</b> digunakan di sana.  Dll ini tidak bertentangan dengan FormEx.dll, itu sederhana, cukup cepat dan disajikan untuk waktu yang lama. <br><br>  Semua ini luar biasa, tetapi sudah waktunya untuk memperluas kemampuannya, dan di sini diperlukan pendekatan yang berbeda. <br><br>  Dalam artikel ini, kami tidak membahas masalah membuat file multimedia.  Ini bukan spesialisasi kami.  Kami membatasi diri hanya untuk beberapa nuansa pemrograman komponen eksternal untuk 1C. <br><br><h3>  1C77 </h3><br>  Karena versi platform 1C dapat berbeda, mungkin ada beberapa solusi.  Dalam kasus kami, ini adalah konfigurasi pada 1C77 (Gbr. 1). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b4/611/4ad/8b46114ad1ae83e57667cc4bb84aae7e.jpg" alt="Fig. 1. Gambar selamat dalam konfigurasi tes pada 1C77"><br>  Fig.  1. Gambar selamat dalam konfigurasi tes pada 1C77. <br><br>  Video di sini, meskipun miliknya sendiri, tetapi gagasan penciptaannya diperoleh dari <b><i>Anna Shiyanova, dengan nama panggilan "Kasus khusus"</i></b> .  Gadis ini memiliki bakat, dia bisa ditiru, tetapi hampir tidak mungkin untuk mengulangi gaya sepenuhnya.  Dalam hal ini, saya hanya ingin setidaknya beberapa unsur kreativitas. <br><br>  Jika salah satu rekan sudah bosan melihat ucapan selamat orang lain, maka mereka dapat membebani gambar dengan " <b>Alt + I</b> " (Gbr. 2-3). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/01a/8c1/200/01a8c120008b72dd648b7c8697298d65.jpg" alt="Fig. 2. Memilih gambar latar belakang lain dalam menu &quot;File / Select Background&quot; atau dengan &quot;Alt + I&quot;"><br>  Fig.  2. Memilih gambar latar belakang yang berbeda di menu "File / Select Background" atau dengan "Alt + I". <br><br>  Dan pada saat yang sama lihat informasi tentang modul yang digunakan oleh " <b>Alt + L</b> " (Gbr. 3). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/499/499/f23/499499f23ec33734bd6a5068f5d493b8.jpg" alt="Fig. 3. Gambar latar yang kelebihan beban bersama dengan informasi tentang program (&quot;Bantuan / Tentang modul LionExt32.dll&quot; atau &quot;Alt + L&quot;)"><br>  Fig.  3. Gambar latar kelebihan beban bersama dengan informasi tentang program ("Bantuan / Tentang modul LionExt32.dll" atau "Alt + L"). <br><br><h3>  1C82 bentuk konvensional </h3><br>  Secara alami, mayoritas sekarang berorientasi pada G8 (1C8x).  Namun, bekerja dengan gambar latar belakang dalam 1C hanya dimungkinkan pada formulir biasa dalam versi 8.2 dan lebih sedikit, dan jika Anda tidak menggunakan pemrosesan apa pun yang dimulai dalam mode "desktop", yang hanya akan sepenuhnya tumpang tindih dengan latar belakang kami (Gbr. 4). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/390/123/bfd/390123bfd2ef88bfbc108dbe44c70835.jpg" alt="Fig. 4. Gambar selamat dalam konfigurasi tes pada formulir biasa 1C82"><br>  Fig.  4. Gambar selamat dalam konfigurasi tes pada formulir biasa 1C82. <br><br>  Perhatikan bahwa tautan ke Fig.  4 menunjukkan bukan video kami.  Mereka ditampilkan hanya untuk tes. <br><br>  Dalam bentuk biasa, 1C82 tidak lagi bekerja dengan cara standar untuk mengakses menu, karena tidak sistemik di sana, seperti pada "tujuh", tetapi "milik" (meskipun sistem dapat dibuat, tetapi mengapa kita memerlukan dua menu utama?).  Namun, hotkey dapat digunakan.  Dengan token yang sama, "Alt + I", di komponen kami, kami memanggil dialog, seperti pada Gambar. 2, dan memuat latar belakang lain (Gambar 5). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3f/535/deb/c3f535deb522e2ae7ad8937ce31b1188.jpg" alt="Fig. 5. Gambar latar kelebihan beban dalam bentuk &quot;tebal&quot; 1C82"><br>  Fig.  5. Gambar latar kelebihan beban dalam bentuk "tebal" 1C82. <br><br>  Demikian pula, Anda dapat memperoleh informasi tentang modul dengan menekan tombol "Alt + L", seperti pada gambar.  3. <br><br><h3>  1C82 formulir terkelola </h3><br>  Untuk formulir terkelola di 1C82, Anda masih dapat menemukan jendela yang kami butuhkan di tingkat sarang ketujuh, seperti " <b>V8FormElement</b> " dan menggambar di atasnya, tetapi entah bagaimana itu tidak menarik. <br><br>  Bagi kami, dari pertimbangan ini maka lebih mudah untuk membuat jendela eksternal dengan pesan ucapan selamat (Gbr. 6) daripada menangani setiap kasus individu.  Jendela itu sendiri dapat ditutup, lebih tepatnya, diminimalkan oleh " <b>Esc</b> ", " <b>Ctrl + F4</b> ", " <b>Alt + F4</b> " atau dengan mengklik pada " <b>cross</b> ". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/790/cd9/79d/790cd979df8a4d97ff5488c50fa4bd6c.jpg" alt="Fig. 6. Gambar ucapan selamat dalam konfigurasi pengujian pada formulir yang dikelola 1C82"><br>  Fig.  6. Gambar ucapan selamat dalam konfigurasi pengujian pada formulir yang dikelola 1C82. <br><br>  Selain itu, jendela yang diperkecil (Gbr. 7) dapat diperluas lagi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66c/1a7/c7f/66c1a7c7f725404604318cdcde3a9915.jpg" alt="Fig.  7. Gambar yang diperkecil dari jendela eksternal pada formulir yang dikelola 1C82"><br>  Fig.  7. Gambar jendela eksternal yang diperkecil pada formulir terkelola 1C82. <br><br>  Dimensi dan posisi relatif jendela eksternal dapat diubah, semuanya seperti biasa di sini (lihat gambar yang diperbesar dari jendela eksternal pada Gambar. 6 dan Gambar. 10).  Perhatikan bahwa hotkey hanya berfungsi jika jendela eksternal aktif. <br><br><h3>  1C83 bentuk konvensional </h3><br>  Di 1C83 tidak ada jendela anak sama sekali, yang dapat berfungsi sebagai kriteria untuk versi 1C di dll kami.  Selain itu, bentuk "tebal" adalah bingkai jendela (Gbr. 8), dan formulir yang dikelola tanpa bingkai (Gbr. 9).  Artinya, segala sesuatu yang bukan bingkai bisa digambar ulang.  Bingkai juga dapat digambar ulang, tetapi hanya sebagai elemen sistem. <br><div class="scrollable-table"><table><tbody><tr><th><img src="https://habrastorage.org/getpro/habr/post_images/f9c/35e/0da/f9c35e0da01025306525d14f700d22a4.jpg" alt="Fig.  8. Bingkai jendela dalam bentuk &quot;tebal&quot; 1C83"></th><th><img src="https://habrastorage.org/getpro/habr/post_images/962/5f9/e7c/9625f9e7c28fed4c9226ee73d8126ed8.jpg" alt="Fig.  9. Jendela tanpa bingkai dalam bentuk yang dikelola 1C83"></th></tr><tr><th>  Fig.  8. Bingkai jendela dalam bentuk "tebal" 1C83. </th><th>  Fig.  9. Jendela tanpa bingkai dalam bentuk yang dikendalikan 1C83. </th></tr></tbody></table></div>  Di sini kami membuat jendela uji menggunakan perpustakaan dinamis dan menempatkannya ke jendela 1C utama.  Perbedaan perilaku terlihat pada gambar. <br><br><h3>  1C83 formulir yang dikelola </h3><br>  Dalam kasus 1C83, seperti pada formulir yang dikelola 1C82, kami akan menarik ucapan selamat kami tidak dengan latar belakang, tetapi di jendela terpisah, prototipe yang ditunjukkan pada Gambar.  8-9.  Akibatnya, komponen yang diinginkan ( <b>LionExt32.dll</b> atau <b>LionExt64.dll</b> ) akan memberikan hasil berikut (Gbr. 10-12). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/104/cf1/f10/104cf1f10c6ae652d24edea7082c7e6c.jpg" alt="Fig.  10. Gambar latar belakang di jendela eksternal untuk bentuk konvensional 1C83"><br>  Fig.  10. Gambar latar belakang di jendela eksternal untuk bentuk konvensional 1C83. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56a/03f/fc7/56a03ffc7fe1f2bfee6358ecb81af9fa.jpg" alt="Fig.  11. Gambar latar belakang di jendela eksternal bentuk terkelola 1C83, rilis 14, versi 64-bit"><br>  Fig.  11. Gambar latar belakang di jendela eksternal bentuk terkelola 1C83, rilis 14, versi 64-bit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/05e/12f/71c/05e12f71ccfb9212b96bc3db92630869.jpg" alt="Fig.  12. Gambar latar belakang di jendela eksternal Form terkelola 1C83, rilis versi 15, 64-bit"><br>  Fig.  12. Gambar latar belakang di jendela eksternal formulir terkelola 1C83, rilis versi 15, 64-bit. <br><br><h3>  Temuan awal </h3><br>  Komponen ini sebenarnya digunakan dalam praktik (Gbr. 1), kepala akuntan puas, semuanya berjalan dengan luar biasa.  Sepanjang jalan, ternyata pengguna suka memilih gambar latar belakang mereka sendiri, dalam hal ini, untuk bekerja pada "tujuh".  Untuk G8, komponen kami disesuaikan dengan cadangan untuk masa depan, sementara itu harus dianggap sebagai versi demo. <br><br>  Yang menarik di sini adalah bahwa <b><i>komponen ini tidak memerlukan kepatuhan dengan teknologi menciptakan komponen eksternal dari 1C</i></b> .  Mungkin ide-ide tambahan akan muncul untuk memperluas kemampuannya.  Misalnya, untuk konfigurasi yang didukung penuh, Anda tidak ingin membuat perubahan pada kode 1C tanpa perlu khusus.  Dalam hal ini, seseorang dapat menawarkan opsi untuk memuat eksternal dll. Sewenang-wenang ke ruang alamat 1C.  Tetapi ini adalah topik dari artikel lain. <br><br>  Dari inovasi teknis, kunci digunakan untuk membongkar komponen kami dengan platform 1C (karena tidak sesuai dengan format VK).  Selain itu, trik lain memungkinkan untuk menetapkan <b>menu lokal</b> ke jendela anak, karena sistem operasi Windows memblokir pembuatan menu seperti itu untuk jendela di bawahnya.  Karenanya, Anda tidak akan melihat menu lokal di <b>MDI</b> (Multi Document Interface) yang sama di mana saja.  Ia digantikan oleh panel perintah, bilah alat, dan menu konteks.  Masih ada waktu untuk memperbarui windows.  Kadang-kadang terjadi bahwa <b>UpdateWindow ()</b> atau <b>InvalidateRect () tidak</b> berfungsi dengan baik.  Tetapi beberapa fungsi dalam kasus ini berhasil: <br><br><pre><code class="cpp hljs">ShowWindow(hWnd, SW_HIDE); ShowWindow(hWnd, SW_SHOW);</code> </pre> <br>  Juga harus dicatat bahwa komponen kami dapat bertentangan dengan yang lain, misalnya, dengan FormEx.dll untuk 1C77.  Dalam hal ini, itu harus dimuat terakhir. <br><br>  Omong-omong, diketahui bahwa jika Anda membuat konfigurasi dalam versi 1C-8.3.14 dan lebih tinggi, maka komponen tidak dimuat dengan cara biasa.  Tetapi jika database dibuat dalam versi 1C sebelumnya, dan terbuka di versi terbaru, maka tidak ada masalah memuat VK kami.  Sekali lagi ini mengisyaratkan perlunya membuat bootloader eksternal. <br><br>  Proyek ini menggunakan subsistem <b>WinAPI GDI +</b> .  Dengan menggunakannya, Anda dapat menampilkan gambar berbagai format: <b>bmp, jpg, gif, png, tif,</b> dan lainnya.  Dalam urutan yang sama, komponen mencoba memuat <b>Main</b> pertama yang tersedia <b>. *</b> File dari direktori <b>Pics</b> lokal dalam konfigurasi saat ini.  Jika tidak ada file-file ini yang ditemukan, maka gambar latar belakang sederhana dari sumber daya komponen digunakan.  Dalam gbr.  Gambar 13 menunjukkan gambar latar belakang ini untuk bentuk biasa 64-bit 1C83, rilis 15. Untuk perubahan, jendela eksternal bahasa gaul telah diperbesar dan gambar lain dari file <b>Main1.png</b> , yang telah "ubin", telah ditambahkan ke latar belakangnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71c/80a/48a/71c80a48a18236e495a1d62b0f316e11.jpg" alt="Fig.  13. Wallpaper default untuk bentuk reguler 64-bit 1C83, lepaskan 15"><br>  Fig.  13. Gambar latar belakang default untuk bentuk biasa 64-bit 1C83, rilis 15. Selain itu, gambar lain dari file Main1.png, meletakkan "ubin", telah ditambahkan. <br><br>  Tidak ada perbedaan dalam pengoperasian komponen dalam mode bit yang berbeda. <br><br>  Dapat juga dicatat bahwa komponen kami mensubklasifikasikan jendela 1C utama dan klien MDI-nya, jika ada.  Ini, tampaknya, berfungsi sebagai sumber konflik dengan FormEx.dll ketika dimuat terakhir (dalam 1C77). <br><br><h2>  Bagian Dua - Teknis </h2><br>  Proyek itu sendiri dapat ditemukan di tautan berikut: <br><br><ul><li>  <a href="">Konfigurasi tes pada 1C77</a> </li><li>  <a href="">Konfigurasi tes pada 1C82</a> </li><li>  <a href="">Konfigurasi tes pada 1C83</a> </li><li>  <a href="">Proyek pada MS VS C ++, v.</a>  <a href="">13</a> </li></ul><br>  Proyek <b>C ++</b> dapat dengan mudah diadaptasi untuk versi <b>10</b> jika string " <b>v120</b> " diganti oleh " <b>v100</b> " dan " <b>ToolsVersion =" 12.0 "</b> " oleh " <b>ToolsVersion =" 4.0 "</b> dalam file konfigurasi. <br><br>  Kode untuk versi <b>1C</b> <b>32-</b> bit dan <b>64-</b> bit <b>adalah</b> sama dan dapat dikompilasi pada saat yang sama. <br><br>  Versi 1C77 ditentukan dalam komponen eksternal oleh <b>gagang</b> fungsi GetMenu <b>() yang</b> tidak nol, dan versi 1C83, oleh tidak adanya jendela anak di jendela utama, pegangan yang ditentukan oleh fungsi <b>GetForegroundWindow ()</b> . <br><br><h3>  Tentang teknologi pembuatan komponen eksternal untuk 1C </h3><br>  Pada cakram ITS dari perusahaan 1C, dan di Internet, orang dapat dengan mudah menemukan informasi tentang pembuatan VC dan templat yang sesuai dalam berbagai bahasa pemrograman.  Namun, pada masa 1C77, pola-pola ini memuaskan "tidak hanya semua orang." <br><br>  Jika Anda melihat beberapa komponen yang banyak digunakan, terutama untuk 1C77, Anda akan melihat bahwa penulisnya sering menggunakan metode pemrograman khusus untuk memperluas kemampuan desain mereka. <br><br>  Mungkin salah satu komponen eksternal pertama tersebut adalah <b><i>"RAINBOW ADDIN 2000 untuk 1C: Enterprise 7.7</i></b> . <b><i>"</i></b>  Mungkin yang paling penting di sini adalah penetrasi yang lebih dalam ke dalam usus "tujuh" daripada yang diizinkan teknologi VK resmi, meskipun mengikuti format VK.  Ini dicapai karena metode header yang diterima, sangat mungkin tidak standar, file * .h dari file library 1C77 yang digunakan dalam proyek-proyek lain yang dikenal luas. <br><br>  Memang, jika fungsi 1C seperti <b>LoadExternalComponent ()</b> dan <b>ConnectExternalComponent ()</b> memungkinkan Anda untuk menanamkan <b>dll eksternal</b> ke dalam ruang alamat Anda sendiri (pertama-tama, yang memenuhi format teknologi VK), lalu mengapa tidak program-program pengguna menyerah pada godaan dan mencoba mengakses yang lain yang tersembunyi dari mereka, prosedur dan objek lain dari platform target?  Pendekatan ini telah berhasil ditunjukkan oleh komponen <b>Rainbow.dll</b> . <br><br>  Kemudian, mekanisme serupa diadopsi oleh penulis lain dari komponen 1C versi 7.7.  Catatan khusus adalah komponen untuk "tujuh" <b>1C ++. Dll</b> dan, seolah-olah, kasus khusus dari <b>FormEx.dll</b> . <br><br>  Tetapi pendekatan nontrivial untuk desain komponen eksternal untuk 1C77 tidak berakhir di sana.  Rupanya, seseorang seharusnya mengatakan: “Mengapa kita membutuhkan pandai besi?  Kami tidak membutuhkan pandai besi! "  Di sini, dengan "pandai besi" yang kami maksud adalah teknologi COM dari MicroSoft, yang, dalam arti tertentu, diikuti oleh teknologi VK untuk "tujuh".  Tidak, well, sungguh, mengapa kita memerlukan registri jika kita mengunduh VK kita secara langsung?  Ini mungkin masuk akal untuk browser web yang bekerja dengan Internet, tetapi untuk operasi lokal, menggunakan registri jelas berlebihan.  Paling tidak, ini bukan prasyarat.  Selain itu, untuk mengedit registri Anda memerlukan hak administratif. <br><br>  Perhatikan bahwa 1C sangat menyukai teknologi ini (setidaknya sampai porting 1C ke Linux).  Kami memperlakukannya dengan sangat keren.  COM nyaman untuk menggunakan komponen ActiveX dan ini wajar, karena yang terakhir awalnya dikembangkan untuk Internet. <br><br>  Namun, dalam versi terbaru, 1C menambahkan kemampuan untuk menggunakan teknologi <b>Native API</b> , yang menghilangkan kebutuhan untuk registri.  Pada prinsipnya, inilah yang kita butuhkan, kecuali bahwa teknologi ini tidak berlaku dalam "tujuh", dan itu, bagi sebagian orang, masih relevan. <br><br>  Tetapi terkadang tugas yang relatif sederhana muncul ketika Anda tidak ingin menggunakan banyak kode boilerplate untuk VK dan disarankan untuk bekerja dengan 1C dari sisi komponen eksternal saja.  Seperti, katakanlah, dalam kasus kami, demonstrasi gambar ucapan selamat di area klien atau, jika perlu, di jendela terpisah, konfigurasi 1C. <br><br>  Dengan kata lain, jika kita tidak akan secara langsung bertukar data antara 1C dan VK, maka kita akan cukup senang dengan versi komponen eksternal yang lebih sederhana dan lebih universal untuk 1C.  Kesederhanaan di sini akan tercapai karena kurangnya kode boilerplate. <br><br><h3>  Teknologi alternatif untuk membuat VK untuk 1C </h3><br>  Karena VK untuk 1C adalah kasus khusus dari <b>server COM</b> (sebelum teknologi <b>Native API</b> ), ada pengembang VK yang mengatakan: "COM - no!".  Aktivitas ke arah <b><i>Alexander Orefkov</i></b> ini terutama terlihat.  Komponennya " <b>1sqlite.dll</b> ", " <b>TurboMD.dll</b> ", dan mungkin yang lain, jangan gunakan COM dari kata "sepenuhnya".  Komponen <b>Yoksel</b> (" <b>SpreadSheet.dll</b> ") juga berkembang di sepanjang jalur ini. <br><br>  Tetapi bagaimana cara VK loader dari 1C77 memuat komponen-komponen ini?  Lagi pula, mereka bahkan tidak mencoba meniru semacam COM di sana.  Memang, jika kita mencoba terus terang menyelipkan beberapa dll standar yang dihasilkan oleh, katakanlah, wizard <b>MS VC ++</b> ke dalam fungsi <b>LoadExternalComponent ()</b> , maka kita akan memiliki gelandangan. <br><br>  Dalam "tujuh" kita mendapatkan pesan seperti: <blockquote>  Terjadi galat saat membuat objek dari komponen &lt;Full Path \ Component Name&gt; .dll (CLSID tidak ada) </blockquote><br>  Dalam klien "tebal" 32-bit dari pesan "delapan" akan serupa.  Dll yang sama akan menyebabkan bersumpah serupa (Gbr. 15): <blockquote>  Metode konteks panggilan kesalahan (Memuat Komponen Eksternal): Kesalahan saat memuat komponen eksternal </blockquote><br>  Jadi, bagaimana perpustakaan yang disebutkan bisa menyelesaikan masalah ini?  Mempelajari teks-teks dari program Orefkov dan Yoksel, kami akhirnya menyimpulkan bahwa " <b>garis ajaib</b> " berikut dalam file sumber daya (* .rc atau * .rc2) adalah "yang harus disalahkan": <br><br><pre> <code class="plaintext hljs">STRINGTABLE DISCARDABLE BEGIN 100 "\0sd" // 1sqlite.dll 100 "\0tmd" // TurboMD.dll 100 "\0f" // SpreadSheet.dll END</code> </pre> <br>  Yaitu  tanpa gagal, dalam sumber daya program ada garis dengan pengenal <b>100</b> dan beberapa nilai string, karakter pertama yang nol.  Anda dapat bereksperimen dengan variasi string semacam itu, tetapi string " <b>\ 0L</b> " tidak masalah bagi saya.  Jadi, kami membuat file sumber daya dan menulis baris seperti ini: <br><br><pre> <code class="plaintext hljs">STRINGTABLE DISCARDABLE BEGIN 100 "\0L" //    1     ! END</code> </pre> <br>  Kami menghubungkan file ini ke proyek dll kami yang paling sederhana yang dihasilkan oleh wizard MS C ++, tambahkan kode: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DllMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE hModule, DWORD dwReason, LPVOID lpReserved)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(dwReason) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_PROCESS_ATTACH: MessageBox(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">",  DllMain()!"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, MB_OK); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_THREAD_ATTACH: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_THREAD_DETACH: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_PROCESS_DETACH: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// switch(dwReason) return TRUE; } // DllMain()</span></span></code> </pre> <br>  dan amati (Gbr. 14). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/715/a71/7f7/715a717f7ee778dd219e79e5fbd43e97.jpg" alt="Fig.  14. Penggunaan &quot;VK&quot; paling sederhana di 1C82"><br>  Fig.  14. Penggunaan "VK" paling sederhana di 1C82. <br><br>  Tanpa "garis ajaib" dalam file sumber daya, dll. Kami, setelah menampilkan MessageBox, segera bongkar dengan kutukan dari 1C (Gbr. 15). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a98/cec/432/a98cec4326033180917940aa248dbc96.jpg" alt="Fig.  15. Kesalahan Umum, dll. Di 1C82"><br>  Fig.  15. Kesalahan memuat dll biasa di 1C82. <br><br>  Artinya, garis-garis ini benar-benar memiliki efek ajaib pada pemuat komponen 1C eksternal. <br><br>  Yang pertama, tampaknya, "garis ajaib" dijelaskan dalam artikel lamanya oleh <b><i>Alexei Fedorov (ALF)</i></b> , tetapi tautan ke sana tidak lagi tersedia, dan penulis tidak melihat titik dalam publikasi ulang.  Selain itu, <b><i>Alexander Orefkov</i></b> menggunakannya secara paling intensif, dan tampaknya, dari pengajuannya, penulisnya adalah <b><i>Yoksel</i></b> .  Oleh karena itu, kita akan berbicara tentang garis <b><i>"ajaib" dari Fedorov-Orefkov</i></b> .  Arti mereka adalah untuk memblokir pembongkaran file-file non-standar (dari sudut pandang 1C) dll dengan fungsi <b>LoadExternalComponent ()</b> .  Selain itu, seperti yang kita lihat, teknik ini bekerja tidak hanya dalam 1C77, tetapi juga dalam bentuk 1C82 "tebal". <br><br>  Namun, dalam bentuk terkelola 1C82 dan di semua versi 1C83, fitur ini sudah benar-benar rusak (loader lain juga muncul - <b>ConnectExternalComponent ()</b> ). <br><br>  Dengan demikian, dalam versi modern 1C, Anda perlu mencari alternatif sederhana lain dari garis "ajaib" Fedorov-Orefkov. <br><br>  Dan alternatif seperti itu mudah ditawarkan.  Intinya sederhana.  Loader 1C mengeluarkan komponen "salah" jika ia mengeluarkan pengecualian ketika mencoba mengaksesnya menggunakan protokol yang ditentukan, misalnya, ketika meminta versi komponen.  Secara alami, kami tidak memiliki yang seperti ini, yang berfungsi sebagai dasar untuk menurunkan dll yang tidak standar.  Tetapi persyaratan 1C untuk sistem operasi untuk membongkar pustaka dinamis ini dapat diabaikan oleh sistem jika VK ini masih digunakan di suatu tempat.  Alih-alih penghapusan itu sendiri, sistem hanya mengurangi penghitung penggunaan modul yang diinginkan.  Dan secara fisik hapus tidak lebih awal dari penghitung ini diatur ulang.  Oleh karena itu, tugas kami adalah meningkatkan penghitung ini secara buatan. <br><br>  Untuk melakukan ini, Anda dapat memanggil fungsi dll kami WinAPI <b>LoadLibrary ()</b> lagi di bagian <b>DLL_THREAD_ATTACH</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DllMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE hModule, DWORD dwReason, LPVOID lpReserved)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(dwReason) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_PROCESS_ATTACH: { WCHAR szDllName[_MAX_PATH] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//     dll GetModuleFileName(hModule, szDllName, _MAX_PATH); //MessageBox(NULL, szDllName, L"Info", MB_OK); //    dll (     183), //      DLL_PROCESS_ATTACH HMODULE hDll = LoadLibrary(szDllName); break; } // case DLL_PROCESS_ATTACH case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } // switch(dwReason) return TRUE; } // DllMain()</span></span></code> </pre> <br>  Itu saja!  Masalahnya teratasi.  Memanggil kembali perpustakaan dinamis yang sama akan menambah penghitung penggunaannya satu, dan membongkar (dengan akses awal ke bagian <b>DLL_THREAD_DETACH</b> ) akan berkurang satu.  Total yang kita miliki <b>2 - 1 = 1&gt; 0</b> , oleh karena itu, sistem operasi tidak akan membongkar dll.  Selain itu, yang penting, <b>reinisialisasi</b> bagian <b>DLL_PROCESS_ATTACH</b> tidak akan terjadi. <br><br>  Dari sini, omong-omong, orang dapat melihat bagaimana 1C dapat menangani trik serupa dalam versi terbarunya (dan, tampaknya, sudah melakukan ini dalam konfigurasi yang dibuat pada 1C-8.3.14 dan lebih tinggi).  Itu dapat menggunakan fungsi <b>LoadLibraryEx ()</b> dengan parameter yang memblokir eksekusi bagian inisialisasi <b>DLL_PROCESS_ATTACH</b> , setelah itu akan segera memanggil fungsi yang diperlukan yang diekspor.  Dan, memang, jika Anda melihat kode contoh VK untuk Native API, Anda dapat melihat bahwa tidak perlu memanggil kode inisialisasi, karena harus kosong oleh format VK. <br><br>  Mengenai contoh-contoh menggunakan teknologi COM, jelas bahwa pelaksanaan bagian inisialisasi <b>DLL_PROCESS_ATTACH</b> diperlukan di sana, oleh karena itu, dalam versi 1C yang tidak terlalu baru, lebih tepatnya, dalam konfigurasi yang dibuat pada 1C-8.3.13 dan di bawahnya, loader 1C cocok untuk kita: <br><br><pre> <code class="plaintext hljs">(, , .COM);</code> </pre> <br>  Di sini parameter terakhir dapat dihapus, karena tersirat secara default.  Pada saat yang sama, mereka dapat membuka secara normal di versi yang lebih tinggi.  Dalam versi 1C83, bootloader <b>LoadExternalComponent (Komponen Alamat) sebelumnya</b> tidak lagi cocok untuk kita (masing-masing, "garis ajaib" Fedorov-Orefkov tidak berfungsi di sana). <br><br>  Dalam kasus umum, seperti yang telah disebutkan, masalah dapat diselesaikan dengan menggunakan bootloader eksternal.  Atau, yang cukup alami, untuk mengamati, sampai taraf tertentu, teknologi komponen eksternal 1C. <br><br>  Juga harus dicatat bahwa percobaan yang kami lakukan dalam versi file 1C dengan kedalaman bit berbeda.  Untuk mengunduh komponen kami, Anda mungkin perlu mengatur properti " <b>Mode Penggunaan Panggilan Sinkron</b> " menjadi " <b>Gunakan</b> " dalam konfigurasi. <br><br>  Juga harus dipahami bahwa Anda melakukan penggunaan teknik semacam itu dengan risiko Anda sendiri, bereksperimen terlebih dahulu pada konfigurasi tes atau salinan pekerja untuk menghindari kemungkinan masalah dalam program utama. <br><br><h3>  Pembaruan dari 09/11/2019 </h3><br>  Ternyata saya khawatir sia-sia bahwa: "dalam versi 1C-8.3.14 dan lebih tinggi, bagian inisialisasi dalam komponen eksternal tidak lagi dilakukan dari kata" sepenuhnya "." <br><br>  Ternyata hanya pesan kembali di fungsi <b>ConnectExternalComponent () yang</b> tidak perlu diproses.  Selain itu, apa pun jenis komponen yang kami tentukan: <b>COM</b> atau <b>Native API</b> . <br><br>  Dengan demikian, Anda dapat membuat konfigurasi di semua versi 1C yang tersedia saat ini, komponen kami akan berfungsi dengan baik di mana-mana, dan membuat bootloader eksternal akan relevan, kecuali untuk kasus ketika Anda tidak ingin mengubah konfigurasi, yang didukung sepenuhnya. <br><br>  Dalam hal ini, kode dalam konfigurasi tes untuk 1C82 dan 1C83 sedikit berubah, meskipun perbedaan di antara mereka tidak lagi mendasar. <br><br>  Pada saat yang sama, komentar kami bahwa perusahaan 1C dapat dengan mudah memblokir eksekusi kode inisialisasi dalam VK apa pun, setidaknya untuk komponen eksternal seperti <b>API Asli</b> , jelas tetap valid, karena menilai dari templat mereka, ini tidak perlu.  Untuk tipe VK <b>COM, ada</b> kebutuhan seperti itu sejauh ini, tetapi apa yang mencegahnya menyingkirkan?  Pada saat yang sama, mari kita lihat apakah mereka akan mempertimbangkan informasi ini? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466713/">https://habr.com/ru/post/id466713/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466699/index.html">Menjinakkan protokol kepercayaan - OAuth otentikasi dengan InterSystems IRIS</a></li>
<li><a href="../id466701/index.html">Let's Encrypt melayani hampir 30% domain</a></li>
<li><a href="../id466705/index.html">Vivaldi Beta untuk Android - Browser Asli</a></li>
<li><a href="../id466709/index.html">Mengembangkan OS seperti Unix monolitik - Perpustakaan C (2)</a></li>
<li><a href="../id466711/index.html">Kerentanan DaOffice diizinkan untuk menghapus pengguna mana pun dari jejaring sosial</a></li>
<li><a href="../id466719/index.html">Profil kecepatan superlight: teori dan praktik. Bagian 1</a></li>
<li><a href="../id466721/index.html">[Yekaterinburg, pengumuman] java.ural.Meetup @ 3 - pengumuman laporan video mitap + Java ketiga dari java.ural.Meetup @ 2</a></li>
<li><a href="../id466723/index.html">Siaran Teks Apple - 10 September 2019</a></li>
<li><a href="../id466725/index.html">Belati 2 adalah unsur dasar (Bagian 1)</a></li>
<li><a href="../id466727/index.html">Upgrade malas: bagaimana PostgreSQL 12 meningkatkan kinerja</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>