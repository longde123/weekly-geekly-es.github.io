<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç® üåõ üíë Rede neural para classifica√ß√£o de imagens de sat√©lite usando o Tensorflow em Python üë∏üèæ üí∏ üëäüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta √© uma instru√ß√£o passo a passo para a classifica√ß√£o de imagens multiespectrais do sat√©lite Landsat 5. Hoje, em v√°rias √°reas, o aprendizado profund...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rede neural para classifica√ß√£o de imagens de sat√©lite usando o Tensorflow em Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jetinfosystems/blog/468973/"><img src="https://habrastorage.org/webt/uq/qc/uz/uqqcuz2dhxwps1cueikg6ceigja.jpeg"><br><br>  Esta √© uma instru√ß√£o passo a passo para a classifica√ß√£o de imagens multiespectrais do sat√©lite Landsat 5. Hoje, em v√°rias √°reas, o aprendizado profundo domina como uma ferramenta para resolver problemas complexos, incluindo os geoespaciais.  Espero que voc√™ esteja familiarizado com os conjuntos de dados de sat√©lite, em particular o Landsat 5 TM.  Se voc√™ estiver um pouco familiarizado com os algoritmos de aprendizado de m√°quina, isso ajudar√° voc√™ a aprender rapidamente este manual.  E para aqueles que n√£o entendem, ser√° suficiente saber que, de fato, o aprendizado de m√°quina consiste em estabelecer rela√ß√µes entre v√°rias caracter√≠sticas (um conjunto de atributos X) de um objeto com sua outra propriedade (valor ou etiqueta, a vari√°vel de destino Y).  Alimentamos o modelo com muitos objetos para os quais as caracter√≠sticas e o valor do indicador / classe de destino do objeto (dados rotulados) s√£o conhecidos e o treinamos para que ele possa prever o valor da vari√°vel de destino Y para novos dados (sem marca√ß√£o). <br><a name="habracut"></a><br>  Qual √© o principal problema com imagens de sat√©lite? <br><br>  Duas ou mais classes de objetos (por exemplo, edif√≠cios, terrenos baldios e po√ßos de funda√ß√£o) em imagens de sat√©lite podem ter as mesmas caracter√≠sticas espectrais do valor; portanto, nos √∫ltimos vinte anos, sua classifica√ß√£o tem sido uma tarefa dif√≠cil. <br><br>  Por esse motivo, √© poss√≠vel usar modelos cl√°ssicos de aprendizado de m√°quina com e sem um professor, mas sua qualidade estar√° longe do ideal.  Eles sempre t√™m as mesmas desvantagens.  Considere um exemplo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/15b/16c/5b7/15b16c5b76906f81f27374daa8558806.jpg"><br><br>  Se voc√™ usar uma linha vertical como classificador e mov√™-la ao longo do eixo X, n√£o ser√° f√°cil classificar imagens de casas.  Os dados s√£o distribu√≠dos para que seja imposs√≠vel separ√°-los em classes usando uma linha vertical (nesses casos, diz-se que "objetos de classes diferentes n√£o s√£o linearmente separ√°veis").  Mas isso n√£o significa que as casas n√£o possam ser classificadas! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc4/ea7/7a0/cc4ea77a0f9f4713ea6a49b7885d31c2.gif"><br><br>  Vamos usar a linha vermelha para separar as duas classes.  Nesse caso, o classificador identificou a maioria das casas, mas uma casa n√£o foi atribu√≠da √† sua classe e mais tr√™s √°rvores foram atribu√≠das por engano √†s "casas".  Para n√£o perder uma √∫nica casa, voc√™ pode usar o classificador na forma de uma linha azul.  Ent√£o, tudo ser√° coberto em casa, ou seja, dizemos que a m√©trica de recall (plenitude) √© alta.  No entanto, nem todos os valores classificados acabaram sendo casas, ou seja, ao mesmo tempo, obtivemos um valor baixo da m√©trica de precis√£o.  Se usarmos a linha verde, todas as imagens classificadas como casas ser√£o realmente casas, ou seja, o classificador mostrar√° alta precis√£o.  Nesse caso, a plenitude ser√° menor, uma vez que as tr√™s casas n√£o ser√£o contabilizadas.  Na maioria dos casos, precisamos encontrar um compromisso entre precis√£o e perfei√ß√£o. <br><br>  Esse problema de casas e √°rvores √© semelhante ao problema de pr√©dios, terrenos baldios e po√ßos.  A prioridade das m√©tricas de classifica√ß√£o de imagens de sat√©lite pode variar dependendo da tarefa.  Por exemplo, se voc√™ precisa garantir que todos os territ√≥rios constru√≠dos sejam classificados como pr√©dios sem exce√ß√£o, e esteja pronto para tolerar a presen√ßa de pixels de outras classes com assinaturas semelhantes, que tamb√©m ser√£o classificadas como pr√©dios, ser√° necess√°rio um modelo com uma alta completude.  E se for mais importante classificar um edif√≠cio, sem adicionar pixels de outras classes, e voc√™ estiver pronto para abandonar a classifica√ß√£o de territ√≥rios mistos, escolha um classificador com alta precis√£o.  No caso de casas e √°rvores, o modelo usual usar√° a linha vermelha, mantendo um equil√≠brio entre precis√£o e perfei√ß√£o. <br><br><h2>  Dados utilizados </h2><br>  Como sinais, usaremos os valores de seis faixas (banda 2 - banda 7) da imagem do Landsat 5 TM e tentaremos prever a classe de desenvolvimento bin√°rio.  Para treinamento e teste, ser√£o utilizados dados multiespectrais (imagens e uma camada com uma classe de constru√ß√£o bin√°ria) com o Landsat 5 para 2011 para Bangalore.  E para previs√£o ser√£o utilizados dados multiespectrais do Landsat 5 obtidos em 2005 em Hyderabad. <br>  Como usamos dados marcados para o ensino, isso √© chamado de ensino com o professor. <br><br><img src="https://habrastorage.org/webt/c4/nx/71/c4nx71fzbix6rhp4fb1-ofdupjm.jpeg"><br><br>  <i>Dados de treinamento multiespectrais e a camada bin√°ria correspondente com o desenvolvimento.</i> <br><br>  Para criar uma rede neural, usaremos o Python - a biblioteca do Google Tensorflow.  Tamb√©m precisaremos dessas bibliotecas: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>pyrsgis</i></a> - para ler e escrever GeoTIFF. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>scikit-learn</i></a> - para pr√©-processamento de dados e avalia√ß√£o de precis√£o. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>numpy</i></a> - para opera√ß√µes b√°sicas com matrizes. <br></li></ol><br>  E agora, sem mais delongas, vamos escrever o c√≥digo. <br><br>  Coloque os tr√™s arquivos em um diret√≥rio, escreva o caminho e os nomes dos arquivos de entrada no script e leia os arquivos GeoTIFF. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyrsgis <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> raster os.chdir(<span class="hljs-string"><span class="hljs-string">"E:\\yourDirectoryName"</span></span>) mxBangalore = <span class="hljs-string"><span class="hljs-string">'l5_Bangalore2011_raw.tif'</span></span> builtupBangalore = <span class="hljs-string"><span class="hljs-string">'l5_Bangalore2011_builtup.tif'</span></span> mxHyderabad = <span class="hljs-string"><span class="hljs-string">'l5_Hyderabad2011_raw.tif'</span></span> <span class="hljs-comment"><span class="hljs-comment"># Read the rasters as array ds1, featuresBangalore = raster.read(mxBangalore, bands='all') ds2, labelBangalore = raster.read(builtupBangalore, bands=1) ds3, featuresHyderabad = raster.read(mxHyderabad, bands='all')</span></span></code> </pre> <br>  O m√≥dulo <code>raster</code> do pacote <code>pyrsgis</code> l√™ dados de geolocaliza√ß√£o GeoTIFF e valores de n√∫mero digital (DN) como matrizes NumPy separadas.  Se voc√™ estiver interessado em detalhes, leia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Agora exibimos o tamanho dos dados lidos. <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"Bangalore multispectral image shape: "</span></span>, featuresBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Bangalore binary built-up image shape: "</span></span>, labelBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Hyderabad multispectral image shape: "</span></span>, featuresHyderabad.shape)</code> </pre> <br>  Resultado: <br><br><pre> <code class="python hljs">Bangalore multispectral image shape: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2054</span></span>, <span class="hljs-number"><span class="hljs-number">2044</span></span> Bangalore binary built-up image shape: <span class="hljs-number"><span class="hljs-number">2054</span></span>, <span class="hljs-number"><span class="hljs-number">2044</span></span> Hyderabad multispectral image shape: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">1318</span></span>, <span class="hljs-number"><span class="hljs-number">1056</span></span></code> </pre> <br>  Como voc√™ pode ver, as imagens de Bangalore t√™m o mesmo n√∫mero de linhas e colunas que na camada bin√°ria (correspondente ao edif√≠cio).  O n√∫mero de camadas nas imagens multiespectrais em Bangalore e Hyderabad tamb√©m coincide.  O modelo aprender√° a decidir quais pixels pertencem ao edif√≠cio e quais n√£o, com base nos valores correspondentes para todos os 6 espectros.  Portanto, imagens multiespectrais devem ter o mesmo n√∫mero de recursos (intervalos) listados na mesma ordem. <br><br>  Agora, transformamos as matrizes em duas dimens√µes, onde cada linha representa um pixel separado, porque isso √© necess√°rio para a opera√ß√£o da maioria dos algoritmos de aprendizado de m√°quina.  Faremos isso usando o m√≥dulo <code>convert</code> do pacote <code>pyrsgis</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d69/176/b91/d69176b91e9758291e1faae6c25486e5.jpg"><br>  <i>Esquema de reestrutura√ß√£o de dados.</i> <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyrsgis.convert <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> changeDimension featuresBangalore = changeDimension(featuresBangalore) labelBangalore = changeDimension (labelBangalore) featuresHyderabad = changeDimension(featuresHyderabad) nBands = featuresBangalore.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>] labelBangalore = (labelBangalore == <span class="hljs-number"><span class="hljs-number">1</span></span>).astype(int) print(<span class="hljs-string"><span class="hljs-string">"Bangalore multispectral image shape: "</span></span>, featuresBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Bangalore binary built-up image shape: "</span></span>, labelBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Hyderabad multispectral image shape: "</span></span>, featuresHyderabad.shape)</code> </pre> <br>  Resultado: <br><br><pre> <code class="python hljs">Bangalore multispectral image shape: <span class="hljs-number"><span class="hljs-number">4198376</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span> Bangalore binary built-up image shape: <span class="hljs-number"><span class="hljs-number">4198376</span></span> Hyderabad multispectral image shape: <span class="hljs-number"><span class="hljs-number">1391808</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  Na s√©tima linha, extra√≠mos todos os pixels com um valor de 1. Isso ajuda a evitar problemas com pixels sem informa√ß√£o (NoData), que geralmente t√™m valores extremamente altos ou baixos. <br>  Agora vamos dividir os dados em amostras de treinamento e valida√ß√£o.  Isso √© necess√°rio para que o modelo n√£o veja os dados de teste e funcione t√£o bem com as novas informa√ß√µes.  Caso contr√°rio, o modelo ser√° treinado novamente e funcionar√° bem apenas nos dados de treinamento. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.model_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> train_test_split xTrain, xTest, yTrain, yTest = train_test_split(featuresBangalore, labelBangalore, test_size=<span class="hljs-number"><span class="hljs-number">0.4</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">42</span></span>) print(xTrain.shape) print(yTrain.shape) print(xTest.shape) print(yTest.shape)</code> </pre> <br>  Resultado: <br><br><pre> <code class="python hljs">(<span class="hljs-number"><span class="hljs-number">2519025</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">2519025</span></span>,) (<span class="hljs-number"><span class="hljs-number">1679351</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">1679351</span></span>,) test_size=<span class="hljs-number"><span class="hljs-number">0.4</span></span></code> </pre> <br>  significa que os dados s√£o divididos em treinamento e valida√ß√£o na propor√ß√£o de 60/40. <br>  Muitos algoritmos de aprendizado de m√°quina, incluindo redes neurais, precisam de dados normalizados.  Isso significa que eles devem ser distribu√≠dos dentro de um determinado intervalo (neste caso, de 0 a 1).  Portanto, para cumprir esse requisito, normalizamos os sintomas.  Isso pode ser feito extraindo o valor m√≠nimo e dividindo-o pelo spread (a diferen√ßa entre os valores m√°ximo e m√≠nimo).  Como o conjunto de dados do Landsat √© de oito bits, os valores m√≠nimo e m√°ximo ser√£o 0 e 255 (2 <sup>‚Å∏</sup> = 256 valores). <br><br>  Observe que, para normaliza√ß√£o, √© sempre melhor calcular os valores m√≠nimo e m√°ximo com base nos dados.  Para simplificar a tarefa, manteremos o intervalo de oito bits por padr√£o. <br><br>  Outra etapa do processamento preliminar √© a transforma√ß√£o da matriz de sinais de bidimensional para tridimensional, para que o modelo perceba cada linha como um pixel separado (um objeto de aprendizado separado). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/965/d0f/aa8/965d0faa8e8c7b4787c10823cf038d20.jpg"><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Normalise the data xTrain = xTrain / 255.0 xTest = xTest / 255.0 featuresHyderabad = featuresHyderabad / 255.0 # Reshape the data xTrain = xTrain.reshape((xTrain.shape[0], 1, xTrain.shape[1])) xTest = xTest.reshape((xTest.shape[0], 1, xTest.shape[1])) featuresHyderabad = featuresHyderabad.reshape((featuresHyderabad.shape[0], 1, featuresHyderabad.shape[1])) # Print the shape of reshaped data print(xTrain.shape, xTest.shape, featuresHyderabad.shape)</span></span></code> </pre> <br>  Resultado: <br><br><pre> <code class="python hljs">(<span class="hljs-number"><span class="hljs-number">2519025</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">1679351</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">1391808</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)</code> </pre> <br>  Tudo est√° pronto, vamos montar nosso modelo com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">keras</a> .  Para come√ßar, vamos usar o modelo seq√ºencial, adicionando camadas uma ap√≥s a outra.  Teremos uma camada de entrada com o n√∫mero de n√≥s igual ao n√∫mero de faixas ( <code>nBands</code> ) - no nosso caso, existem 6. Tamb√©m usaremos uma camada oculta com 14 n√≥s e a <code>ReLu</code> ativa√ß√£o <code>ReLu</code> .  A √∫ltima camada consiste em dois n√≥s para definir uma classe de constru√ß√£o bin√°ria com a <code>softmax</code> ativa√ß√£o <code>softmax</code> , adequada para exibir um resultado categorizado.  Leia mais sobre as fun√ß√µes de ativa√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> keras <span class="hljs-comment"><span class="hljs-comment"># Define the parameters of the model model = keras.Sequential([ keras.layers.Flatten(input_shape=(1, nBands)), keras.layers.Dense(14, activation='relu'), keras.layers.Dense(2, activation='softmax')]) # Define the accuracy metrics and parameters model.compile(optimizer="adam", loss="sparse_categorical_crossentropy", metrics=["accuracy"]) # Run the model model.fit(xTrain, yTrain, epochs=2)</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/d8a/9cd/5ec/d8a9cd5ec53c57d671d77b0c46bfb17e.png"><br>  <i>Arquitetura de rede neural</i> <br><br>  Conforme mencionado na linha 10, especificamos <code>adam</code> como o otimizador de modelo (existem v√°rios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outros</a> ).  Neste caso, usaremos a entropia cruzada como uma fun√ß√£o de perda (en. <code>categorical-sparse-crossentropy</code> - mais sobre isso est√° escrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ).  Para avaliar a qualidade do modelo, usaremos a m√©trica de <code>accuracy</code> . <br><br>  Por fim, come√ßaremos a treinar nosso modelo para duas eras (ou itera√ß√µes) no <code>xTrain</code> e <code>yTrain</code> .  Isso levar√° algum tempo, dependendo do tamanho dos dados e do poder de processamento.  Aqui est√° o que voc√™ ver√° ap√≥s a compila√ß√£o: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dfa/3fc/c47/dfa3fcc47572b2fd20c5252ba4da1e50.png"><br><br>  Vamos prever os valores para os dados de valida√ß√£o que armazenamos separadamente e calcular v√°rias m√©tricas de precis√£o. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.metrics <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> confusion_matrix, precision_score, recall_score <span class="hljs-comment"><span class="hljs-comment"># Predict for test data yTestPredicted = model.predict(xTest) yTestPredicted = yTestPredicted[:,1] # Calculate and display the error metrics yTestPredicted = (yTestPredicted&gt;0.5).astype(int) cMatrix = confusion_matrix(yTest, yTestPredicted) pScore = precision_score(yTest, yTestPredicted) rScore = recall_score(yTest, yTestPredicted) print("Confusion matrix: for 14 nodes\n", cMatrix) print("\nP-Score: %.3f, R-Score: %.3f" % (pScore, rScore))</span></span></code> </pre> <br>  A fun√ß√£o <code>softmax</code> gera colunas separadas para valores de probabilidade para cada classe.  Usamos apenas os valores da primeira classe ("existe um edif√≠cio"), como pode ser visto na sexta linha do c√≥digo acima.  Avaliar o trabalho dos modelos de an√°lise geoespacial n√£o √© t√£o simples, ao contr√°rio de outros problemas cl√°ssicos do aprendizado de m√°quina.  Ser√° injusto confiar em um erro total generalizado.  A chave para um modelo de sucesso √© o layout espacial.  Assim, a matriz de confus√£o, a precis√£o e a integridade podem fornecer uma id√©ia mais correta da qualidade do modelo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/399/3d8/bf3/3993d8bf36a5f4165b60f39e36e5c566.jpg"><br>  <i>Portanto, o console exibe a matriz de erros, a precis√£o e a integridade.</i> <br><br>  Como voc√™ pode ver na matriz de confus√£o, existem milhares de pixels relacionados a edif√≠cios, mas s√£o classificados de maneira diferente e vice-versa.  No entanto, sua participa√ß√£o no volume total de dados n√£o √© muito grande.  A precis√£o e integridade dos dados do teste excederam o limite de 0,8. <br><br>  Voc√™ pode gastar mais tempo e executar v√°rias itera√ß√µes para encontrar o n√∫mero ideal de camadas ocultas, o n√∫mero de n√≥s em cada camada oculta e o n√∫mero de eras para alcan√ßar a precis√£o desejada.  Conforme necess√°rio, √≠ndices de sensoriamento remoto como NDBI ou NDWI podem ser usados ‚Äã‚Äãcomo recursos.  Ao atingir a precis√£o desejada, use o modelo para prever o desenvolvimento com base em novos dados e exportar o resultado para o GeoTIFF.  Para essas tarefas, voc√™ pode usar um modelo semelhante com pequenas altera√ß√µes. <br><br><pre> <code class="python hljs">predicted = model.predict(feature2005) predicted = predicted[:,<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-comment"><span class="hljs-comment">#Export raster prediction = np.reshape(predicted, (ds.RasterYSize, ds.RasterXSize)) outFile = 'Hyderabad_2011_BuiltupNN_predicted.tif' raster.export(prediction, ds3, filename=outFile, dtype='float')</span></span></code> </pre> <br>  Observe que exportamos o GeoTIFF com valores de probabilidade previstos e n√£o com sua vers√£o com limiar binarizado.  Posteriormente, no ambiente GIS, podemos definir o valor limite de uma camada do tipo float, conforme mostrado na figura abaixo. <br><br><img src="https://habrastorage.org/webt/sk/ka/kz/skkakzxokrbkvrgulcvm0vkuwua.jpeg"><br>  <i>Camada acumulada de Hyderabad prevista pelo modelo com base em dados multiespectrais.</i> <br><br>  A precis√£o do modelo j√° foi medida com precis√£o e recupera√ß√£o.  Voc√™ tamb√©m pode executar verifica√ß√µes tradicionais (por exemplo, usando o coeficiente kappa) em uma nova camada prevista.  Al√©m das dificuldades acima mencionadas na classifica√ß√£o de imagens de sat√©lite, outras limita√ß√µes √≥bvias incluem a impossibilidade de previs√£o com base em imagens tiradas em diferentes √©pocas do ano e em diferentes regi√µes, uma vez que elas ter√£o diferentes assinaturas espectrais. <br><br>  O modelo descrito neste artigo possui a arquitetura mais simples para redes neurais.  Melhores resultados podem ser alcan√ßados com modelos mais complexos, incluindo redes neurais convolucionais.  A principal vantagem dessa classifica√ß√£o √© sua escalabilidade (aplicabilidade) ap√≥s o treinamento do modelo. <br><br>  Os dados usados ‚Äã‚Äãe todo o c√≥digo est√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt468973/">https://habr.com/ru/post/pt468973/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt468961/index.html">Como se livrar da rotina na vida por US $ 560? Ou como viver, n√£o viver</a></li>
<li><a href="../pt468963/index.html">Backup, parte a pedido dos leitores: vis√£o geral do UrBackup, BackupPC, AMANDA</a></li>
<li><a href="../pt468967/index.html">"Tecnologia" de obten√ß√£o de equa√ß√µes de din√¢mica de TAU. E por que a Identifica√ß√£o do sistema √© p√©ssima e a "f√≠sica honesta" governa</a></li>
<li><a href="../pt468969/index.html">Crie usu√°rios do Google a partir do PowerShell via API</a></li>
<li><a href="../pt468971/index.html">Escrevendo em Java para Nintendo DS</a></li>
<li><a href="../pt468989/index.html">Mercado UEBA morre - vida longa UEBA</a></li>
<li><a href="../pt468991/index.html">Personagens modulares de sprites e suas anima√ß√µes</a></li>
<li><a href="../pt468993/index.html">Oculus Quest se conecta a um PC e v√™ as m√£os</a></li>
<li><a href="../pt468995/index.html">Pol√≠tica de abertura: como os usu√°rios influenciam o projeto</a></li>
<li><a href="../pt468997/index.html">Mentoring - um must-have ou um bom b√¥nus?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>