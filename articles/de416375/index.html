<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏽 🐓 📘 JavaScript-Grundlagen für Anfänger 👰🏾 👨🏽‍🚀 🏇🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Material, dessen Übersetzung wir heute veröffentlichen, ist den Grundlagen von JavaScript gewidmet und richtet sich an Programmierer für Anfänger....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Grundlagen für Anfänger</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/416375/">  Das Material, dessen Übersetzung wir heute veröffentlichen, ist den Grundlagen von JavaScript gewidmet und richtet sich an Programmierer für Anfänger.  Es kann als kleiner Hinweis auf die Grundkonstruktionen von JS betrachtet werden.  Hier werden wir insbesondere über das Datentypsystem, über Variablen, über Arrays, über Funktionen, über Prototypen von Objekten und über einige andere Merkmale der Sprache sprechen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/my/cj/zq/mycjzqfpfohnkk9vnefgsl915vm.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Primitive Datentypen</font> </h2><br>  Die folgenden primitiven Datentypen sind in JavaScript verfügbar: <code>number</code> , <code>boolean</code> , <code>string</code> , <code>undefined</code> , <code>null</code> .  Es sollte sofort beachtet werden, dass wir bei der Arbeit mit primitiven Datentypen, beispielsweise mit Zeichenfolgenliteralen, auch ohne explizite Konvertierung auf deren Methoden und Eigenschaften zugreifen können.  Der Punkt hier ist, dass beim Versuch, solche Operationen auszuführen, Literale automatisch mit dem entsprechenden Objekt-Wrapper ausgestattet werden. <br><br><h3>  <font color="#3AC1EF">▍ Zahlen</font> </h3><br>  JavaScript hat nur einen Zifferntyp - Gleitkommazahlen mit doppelter Genauigkeit.  Dies führt dazu, dass die Ergebnisse der Berechnung einiger Ausdrücke arithmetisch falsch sind.  Möglicherweise wissen Sie bereits, dass in JS der Wert des Ausdrucks <code>0.1 + 0.2</code> nicht <code>0.3</code> .  Gleichzeitig werden beim Arbeiten mit ganzen Zahlen solche Probleme nicht beobachtet, <code>1 + 2 === 3</code> . <br><br>  JavaScript verfügt über ein <code>Number</code> Objekt, bei dem es sich um einen Objekt-Wrapper für numerische Werte handelt.  Objekte vom Typ <code>Number</code> können entweder mit einem Befehl der Form <code>var a = new Number(10)</code> werden oder Sie können sich auf das automatische Verhalten des oben beschriebenen Systems verlassen.  Auf diese Weise können Sie insbesondere in <code>Number.prototype</code> gespeicherte Methoden <code>Number.prototype</code> , die auf numerische Literale angewendet werden: <br><br><pre> <code class="hljs ruby">(<span class="hljs-number"><span class="hljs-number">123</span></span>).toString();  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"123"</span></span> (<span class="hljs-number"><span class="hljs-number">1.23</span></span>).toFixed(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"1.2"</span></span></code> </pre> <br>  Es gibt globale Funktionen, mit denen Werte anderer Typen in einen numerischen Typ konvertiert werden können.  Dies sind <code>parseInt()</code> , <code>parseFloat()</code> und das <code>Number()</code> <code>parseFloat()</code> , das in diesem Fall als normale Funktion fungiert, die die Typkonvertierung durchführt: <br><br><pre> <code class="hljs julia">parseInt(<span class="hljs-string"><span class="hljs-string">"1"</span></span>)       //<span class="hljs-number"><span class="hljs-number">1</span></span> parseInt(<span class="hljs-string"><span class="hljs-string">"text"</span></span>)    //<span class="hljs-literal"><span class="hljs-literal">NaN</span></span> parseFloat(<span class="hljs-string"><span class="hljs-string">"1.234"</span></span>) //<span class="hljs-number"><span class="hljs-number">1.234</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>)         //<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(<span class="hljs-string"><span class="hljs-string">"1.234"</span></span>)     //<span class="hljs-number"><span class="hljs-number">1.234</span></span></code> </pre> <br>  Wenn während der Operation mit Zahlen etwas erhalten wird, das keine Zahl ist (während einiger Berechnungen oder beim Versuch, etwas in eine Zahl umzuwandeln), gibt JavaScript keinen Fehler aus, sondern zeigt das Ergebnis einer solchen Operation als den Wert <code>NaN</code> (Not-a-Number, keine Zahl).  Um zu überprüfen, ob ein bestimmter Wert <code>NaN</code> , können Sie die Funktion <code>isNaN()</code> verwenden. <br><br>  JS-Arithmetikoperationen funktionieren auf eine recht vertraute Weise, aber Sie müssen darauf achten, dass der Operator <code>+</code> das Hinzufügen von Zahlen und das Verketten von Zeichenfolgen durchführen kann. <br><br><pre> <code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>      //<span class="hljs-number"><span class="hljs-number">2</span></span> "1" + "1"  //"11" <span class="hljs-number"><span class="hljs-number">1</span></span> + "1"    //"11"</code> </pre> <br><h3>  <font color="#3AC1EF">▍Strings</font> </h3><br>  JavaScript-Zeichenfolgen sind Unicode-Zeichenfolgen.  String-Literale werden erstellt, indem der Text in doppelte ( <code>""</code> ) oder einfache ( <code>''</code> ) Anführungszeichen eingeschlossen wird.  Wie bereits erwähnt, können wir uns bei der Arbeit mit String-Literalen auf den entsprechenden Objekt-Wrapper verlassen, dessen Prototyp viele nützliche Methoden enthält, darunter <code>indexOf()</code> , <code>concat()</code> , <code>concat()</code> . <br><br><pre> <code class="hljs pgsql">"text".substring(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) //ex "text".indexOf(<span class="hljs-string"><span class="hljs-string">'x'</span></span>)   //<span class="hljs-number"><span class="hljs-number">2</span></span> "text".concat(" end") //<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Strings sind wie andere primitive Werte unveränderlich.  Beispielsweise <code>concat()</code> die <code>concat()</code> -Methode keine vorhandene Zeichenfolge, sondern erstellt eine neue. <br><br><h3>  <font color="#3AC1EF">▍Logische Werte</font> </h3><br>  Der logische Datentyp in JS wird durch zwei Werte dargestellt - <code>true</code> und <code>false</code> .  Die Sprache kann verschiedene Werte automatisch in einen logischen Datentyp konvertieren.  Falsch sind also zusätzlich zum logischen Wert <code>false</code> die Werte <code>null</code> , <code>undefined</code> , <code>''</code> (leere Zeichenfolge), <code>0</code> und <code>NaN</code> .  Alles andere, einschließlich aller Objekte, repräsentiert wahre Bedeutungen.  Im Verlauf logischer Operationen wird alles, was als wahr angesehen wird, in <code>true</code> , und alles, was als falsch angesehen wird, wird in falsch umgewandelt.  Schauen Sie sich das folgende Beispiel an.  In Übereinstimmung mit den obigen Prinzipien wird eine leere Zeichenfolge in <code>false</code> konvertiert <code>false</code> und als Ergebnis dieser Codeausführung wird die Zeichenfolge <code>This is false</code> an die Konsole gesendet. <br><br><pre> <code class="hljs pgsql">let <span class="hljs-type"><span class="hljs-type">text</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-type"><span class="hljs-type">text</span></span>) { console.log("This is true"); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { console.log("This is false"); }</code> </pre> <br><h2>  <font color="#3AC1EF">Die Objekte</font> </h2><br>  Objekte sind dynamische Strukturen, die aus Schlüssel-Wert-Paaren bestehen.  Werte können primitive Datentypen haben, können Objekte oder Funktionen sein. <br><br>  Objekte lassen sich am einfachsten mit der Objektliteral-Syntax erstellen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">message</span></span> : <span class="hljs-string"><span class="hljs-string">"A message"</span></span>, <span class="hljs-attr"><span class="hljs-attr">doSomething</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }</code> </pre> <br>  Die Eigenschaften eines Objekts können jederzeit gelesen, hinzugefügt, bearbeitet und gelöscht werden.  So geht's: <br><br><ul><li>  <code>object.name, object[expression]</code> : <code>object.name, object[expression]</code> . </li><li>  Schreiben von Daten in Eigenschaften (wenn die Eigenschaft, auf die zugegriffen wird, nicht vorhanden ist, wird eine neue Eigenschaft mit dem angegebenen Schlüssel hinzugefügt): <code>object.name = value</code> , <code>object[expression] = value</code> . </li><li>  Eigenschaften entfernen: <code>delete object.name</code> <code>delete object[expression]</code> . </li></ul><br>  Hier einige Beispiele: <br><br><pre> <code class="hljs ruby">let obj = {}; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    obj.message = <span class="hljs-string"><span class="hljs-string">"A message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    obj.message = <span class="hljs-string"><span class="hljs-string">"A new message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   delete object.message; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  </code> </pre> <br>  Objekte in der Sprache werden als Hash-Tabellen implementiert.  Eine einfache Hash-Tabelle kann mit dem <code>Object.create(null)</code> : <br><br><pre> <code class="hljs pgsql">let french = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); french["yes"] = "oui"; french["no"]  = "non"; french["yes"];//"oui"</code> </pre> <br>  Wenn das Objekt unveränderlich gemacht werden muss, können Sie den Befehl <code>Object.freeze()</code> . <br><br>  Um alle Eigenschaften eines Objekts zu <code>Object.keys()</code> , können Sie den Befehl <code>Object.keys()</code> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> logProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>){ console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>); //  console.log(obj[<span class="hljs-type"><span class="hljs-type">name</span></span>]); //   } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(obj).<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(logProperty);</code> </pre> <br><h3>  <font color="#3AC1EF">▍Vergleich von Werten primitiver Typen und Objekte</font> </h3><br>  In der praktischen Arbeit mit primitiven Werten können Sie sie, wie bereits erwähnt, als Objekte mit Eigenschaften und Methoden wahrnehmen, obwohl sie keine Objekte sind.  Primitive Werte sind unveränderlich, die interne Struktur von Objekten kann sich ändern. <br><br><h2>  <font color="#3AC1EF">Variablen</font> </h2><br>  In JavaScript können Variablen mit den Schlüsselwörtern <code>var</code> , <code>let</code> und <code>const</code> deklariert werden. <br><br>  Mit dem Schlüsselwort <code>var</code> können Sie eine Variable deklarieren und bei Bedarf mit einem bestimmten Wert initialisieren.  Wenn die Variable nicht initialisiert ist, ist ihr Wert <code>undefined</code> .  Mit dem Schlüsselwort <code>var</code> deklarierte Variablen haben einen Funktionsumfang. <br><br>  Das Schlüsselwort <code>let</code> ist <code>var</code> sehr ähnlich. Der Unterschied besteht darin, dass Variablen, die mit dem Schlüsselwort <code>let</code> deklariert wurden, einen Blockbereich haben. <br><br>  Mit dem Schlüsselwort <code>const</code> deklarierte Variablen haben auch einen Blockbereich, der angesichts der Tatsache, dass die Werte solcher Variablen nicht geändert werden können, korrekter als "Konstanten" bezeichnet wird.  Das Schlüsselwort <code>const</code> , das den Wert einer mit ihm deklarierten Variablen "einfriert", kann mit der <code>Object.freeze()</code> -Methode verglichen werden, die Objekte "einfriert". <br><br>  Wenn eine Variable außerhalb einer Funktion deklariert wird, ist ihr Gültigkeitsbereich global. <br><br><h2>  <font color="#3AC1EF">Arrays</font> </h2><br>  Arrays in JavaScript werden mithilfe von Objekten implementiert.  Wenn wir über Arrays sprechen, diskutieren wir daher Objekte, die Arrays ähnlich sind.  Sie können mit Array-Elementen anhand ihrer Indizes arbeiten.  Numerische Indizes werden in Zeichenfolgen konvertiert und als Namen für den Zugriff auf die Werte von Array-Elementen verwendet.  Beispielsweise ähnelt ein Konstrukt der Form <code>arr[1]</code> einem Konstrukt der Form <code>arr['1']</code> , und beide geben Zugriff auf denselben Wert: <code>arr[1] === arr['1']</code> .  In Übereinstimmung mit dem Obigen wird ein einfaches Array, das durch den Befehl <code>let arr = ['A', 'B', 'C']</code> deklariert wurde, als ein Objekt der folgenden Form dargestellt: <br><br><pre> <code class="hljs objectivec">{ <span class="hljs-string"><span class="hljs-string">'0'</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>: <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>: <span class="hljs-string"><span class="hljs-string">'C'</span></span> }</code> </pre> <br>  Das Entfernen von Array-Elementen mit dem Befehl <code>delete</code> hinterlässt Lücken.  Um dieses Problem zu vermeiden, können Sie den Befehl <code>splice()</code> , der jedoch langsam funktioniert, da nach dem Löschen eines Elements die verbleibenden Elemente des Arrays verschoben und tatsächlich an den Anfang des Arrays nach links verschoben werden. <br><br><pre> <code class="hljs powershell">let arr = [<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>]; delete arr[<span class="hljs-number"><span class="hljs-number">1</span></span>]; console.log(arr); // [<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-type"><span class="hljs-type">empty</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>] console.log(arr.length); // <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Array-Methoden erleichtern die Implementierung von Datenstrukturen wie Stapeln und Warteschlangen: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/  let stack = []; stack.push(1);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1] stack.push(2);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1, 2] let last = stack.pop();  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1] console.log(last);       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  let queue = []; queue.push(1);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1] queue.push(2);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1, 2] let first = queue.shift();/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/[2] console.log(first);      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Funktionen</font> </h2><br>  Funktionen in JavaScript sind Objekte.  Funktionen können Variablen zugewiesen, in Objekten oder Arrays gespeichert, als Argumente an andere Funktionen übergeben und von anderen Funktionen zurückgegeben werden. <br><br>  Es gibt drei Möglichkeiten, Funktionen zu deklarieren: <br><br><ul><li>  Klassische Funktionsdeklaration (Funktionsdeklaration oder Funktionsanweisung). </li><li>  Die Verwendung von Funktionsausdrücken (Funktionsausdruck), die auch als Funktionsliterale (Funktionsliteral) bezeichnet werden. </li><li>  Verwendung der Syntax von Pfeilfunktionen (Pfeilfunktion). </li></ul><br><h3>  <font color="#3AC1EF">▍ Klassische Funktionsdeklaration</font> </h3><br>  Bei diesem Ansatz zum Deklarieren von Funktionen gelten die folgenden Regeln: <br><br><ul><li>  Das erste Schlüsselwort in einer Funktionsdeklarationszeile ist <code>function</code> . </li><li>  Funktionen müssen einen Namen erhalten. </li><li>  Die Funktion kann im Code vor ihrer Deklaration verwendet werden, da die Deklaration der Funktion an die Spitze des Bereichs angehoben wird, in dem sie deklariert ist. </li></ul><br>  So sieht eine klassische Funktionsdeklaration aus: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{}</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Funktionsausdrücke</font> </h3><br>  Bei der Verwendung von Funktionsausdrücken sollte Folgendes berücksichtigt werden: <br><br><ul><li>  Das <code>function</code> ist nicht mehr das erste Wort in einer Funktionsdeklarationszeile. </li><li>  Ein Funktionsname ist optional.  Es können sowohl anonyme als auch benannte Funktionsausdrücke verwendet werden. </li><li>  Befehle zum Aufrufen solcher Funktionen sollten den Befehlen für ihre Deklaration folgen. </li><li>  Eine solche Funktion kann unmittelbar nach der Deklaration mit der Syntax von IIFE (Sofort aufgerufener Funktionsausdruck - sofort als Funktionsausdruck bezeichnet) gestartet werden. </li></ul><br>  Der funktionale Ausdruck sieht folgendermaßen aus: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Pfeilfunktionen</font> </h3><br>  Pfeilfunktionen können in der Tat als „syntaktischer Zucker“ betrachtet werden, um anonyme funktionale Ausdrücke zu erstellen.  Es ist zu beachten, dass solche Funktionen keine eigenen Entitäten und <code>arguments</code> .  Die Pfeilfunktionsdeklaration sieht folgendermaßen aus: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doSomething = () = &gt; {};</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Möglichkeiten zum Aufrufen von Funktionen</font> </h3><br>  Funktionen können auf verschiedene Arten aufgerufen werden. <br><br><h4>  Normaler Funktionsaufruf </h4><br><pre> <code class="hljs lisp">doSomething(<span class="hljs-name"><span class="hljs-name">arguments</span></span>)</code> </pre> <br><h4>  Funktionsaufruf in Form einer Objektmethode </h4><br><pre> <code class="hljs markdown">theObject.doSomething(arguments) theObject[<span class="hljs-string"><span class="hljs-string">"doSomething"</span></span>](<span class="hljs-link"><span class="hljs-link">arguments</span></span>)</code> </pre> <br><h4>  Konstruktorfunktionsaufruf </h4><br><pre> <code class="hljs lisp">new doSomething(<span class="hljs-name"><span class="hljs-name">arguments</span></span>)</code> </pre> <br><h4>  Aufrufen einer Funktion mit der Methode apply () </h4><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">doSomething</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.apply</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">theObject</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[arguments]</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">doSomething</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.call</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">theObject</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">arguments</span></span>)</code> </pre> <br><h4>  Aufrufen einer Funktion mit der Methode bind () </h4><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doSomethingWithObject = doSomething.bind(theObject); doSomethingWithObject();</code> </pre> <br>  Funktionen können mit mehr oder weniger Argumenten als der Anzahl der Parameter aufgerufen werden, die bei der Deklaration angegeben wurden.  Während der Arbeit der Funktion werden die "zusätzlichen" Argumente einfach ignoriert (obwohl die Funktion Zugriff darauf hat), die fehlenden Parameter erhalten den Wert <code>undefined</code> . <br><br>  Funktionen haben zwei Pseudoparameter: <code>this</code> und <code>arguments</code> . <br><br><h3>  <font color="#3AC1EF">▍ Stichwort dies</font> </h3><br>  Das <code>this</code> repräsentiert den Kontext einer Funktion.  Der Wert, auf den es zeigt, hängt davon ab, wie die Funktion aufgerufen wurde.  Hier sind die Bedeutungen <code>this</code> Schlüsselworts in Abhängigkeit davon, wie die Funktion aufgerufen wird (sie werden oben mit Codebeispielen beschrieben, deren Konstruktionen hier verwendet werden): <br><br><ul><li>  Der übliche Funktionsaufruf ist <code>window</code> / <code>undefined</code> . </li><li>  Ein Funktionsaufruf in Form einer Objektmethode ist <code>theObject</code> . </li><li>  Ein Funktionsaufruf in Form eines Konstruktors ist ein neues Objekt. </li><li>  Aufrufen einer Funktion mit der Methode <code>apply()</code> - <code>theObject</code> . </li><li>  Aufrufen einer Funktion mit der Methode <code>bind()</code> - <code>theObject</code> . </li></ul><br><h3>  <font color="#3AC1EF">▍ Schlüsselwortargumente</font> </h3><br>  Das <code>arguments</code> Schlüsselwort ist ein Pseudoparameter, der Zugriff auf alle Argumente gibt, die zum Aufrufen der Funktion verwendet werden.  Es sieht aus wie ein Array, aber kein Array.  Insbesondere verfügt es nicht über Array-Methoden. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> reduceToSum(total, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total + <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> sum(){ let args = <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.prototype.<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(arguments); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args.reduce(reduceToSum, <span class="hljs-number"><span class="hljs-number">0</span></span>); } sum(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Eine Alternative zum <code>arguments</code> Schlüsselwort ist die neue Syntax für die verbleibenden Parameter.  Im folgenden Beispiel ist <code>args</code> ein Array, das alles enthält, was beim Aufruf an die Funktion übergeben wurde. <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...args</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args.reduce(reduceToSum, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3>  <font color="#3AC1EF">▍Operator zurück</font> </h3><br>  Eine Funktion ohne <code>return</code> gibt <code>undefined</code> .  Achten Sie mit dem Schlüsselwort <code>return</code> darauf, wie der automatische Einfügungsmechanismus für Semikolons funktioniert.  Die folgende Funktion gibt beispielsweise kein leeres Objekt, sondern einen <code>undefined</code> Wert zurück: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { } } getObject()</code> </pre> <br>  Um ein ähnliches Problem zu vermeiden, muss die öffnende geschweifte Klammer in derselben Zeile wie die <code>return</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { } }</code> </pre> <br><h2>  <font color="#3AC1EF">Dynamische Eingabe</font> </h2><br>  JavaScript ist eine dynamische Schreibsprache.  Dies bedeutet, dass bestimmte Werte Typen haben, Variablen jedoch nicht.  Während der Programmausführung können Werte unterschiedlichen Typs in dieselbe Variable geschrieben werden.  Hier ist ein Beispiel für eine Funktion, die mit Werten verschiedener Typen arbeitet: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> log(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>){ console.log(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } log(<span class="hljs-number"><span class="hljs-number">1</span></span>); log("text"); log({message : "text"});</code> </pre> <br>  Um den in einer Variablen gespeicherten Datentyp herauszufinden, können Sie den Operator <code>typeof()</code> : <br><br><pre> <code class="hljs lua">let n = <span class="hljs-number"><span class="hljs-number">1</span></span>; typeof(n);   //number let s = <span class="hljs-string"><span class="hljs-string">"text"</span></span>; typeof(s);   //<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> let fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {}; typeof(fn);  //<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Single-Threaded-Ausführungsmodell</font> </h2><br>  Die JavaScript-Laufzeit ist Single-Threaded.  Dies drückt sich insbesondere in der Unmöglichkeit aus, zwei Funktionen gleichzeitig auszuführen (wenn Sie die Möglichkeiten der asynchronen Codeausführung, die wir hier nicht ansprechen, nicht berücksichtigen).  Die Laufzeit hat eine sogenannte Ereigniswarteschlange, in der eine Liste der Aufgaben gespeichert ist, die verarbeitet werden müssen.  Infolgedessen ist für ein JS-Ausführungsschema mit einem Thread das Problem der gegenseitigen Ressourcensperren nicht typisch, weshalb der Sperrmechanismus hier nicht benötigt wird.  Code, der in die Ereigniswarteschlange fällt, muss jedoch schnell ausgeführt werden.  Wenn Sie mit viel Arbeit überladen, reagiert die Anwendungsseite in der Browseranwendung, dem Hauptthread, nicht auf Benutzeraktionen, und der Browser bietet an, diese Seite zu schließen. <br><br><h2>  <font color="#3AC1EF">Ausnahmebehandlung</font> </h2><br>  JavaScript verfügt über einen Mechanismus zur Behandlung von Ausnahmen.  Es funktioniert nach einem für solche Mechanismen üblichen Prinzip: Der Code, der einen Fehler verursachen kann, wird mit dem <code>try/catch</code> Konstrukt ausgeführt.  Der Code selbst befindet sich im <code>try</code> Block, Fehler werden im <code>catch</code> . <br><br>  Es ist interessant festzustellen, dass JavaScript im Notfall manchmal keine Fehlermeldungen erzeugt.  Dies liegt an der Tatsache, dass JS bis zur Übernahme des ECMAScript 3-Standards keine Fehler ausgegeben hat. <br><br>  Im folgenden Codefragment schlägt beispielsweise der Versuch fehl, ein "eingefrorenes" Objekt zu ändern, es wird jedoch keine Ausnahme ausgelöst. <br><br><pre> <code class="hljs pgsql">let obj = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({}); obj.message = "text";</code> </pre> <br>  Einige der "stillen" JS-Fehler werden im strikten Modus angezeigt. Sie können sie mithilfe der Konstruktion <code>"use strict";</code> aktivieren <code>"use strict";</code>  . <br><br><h2>  <font color="#3AC1EF">Prototypsystem</font> </h2><br>  Die Basis solcher JS-Mechanismen wie Konstruktorfunktionen, der Befehl <code>Object.create()</code> , das Schlüsselwort <code>class</code> , basiert auf einem Prototypsystem. <br>  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> service = { <span class="hljs-attr"><span class="hljs-attr">doSomething</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> specializedService = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(service); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(specializedService.__proto__ === service); <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br>  Hier wurde der Befehl <code>Object.create()</code> verwendet, um ein <code>specializedService</code> <code>service</code> zu erstellen, dessen Prototyp ein <code>service</code> sollte.  Als Ergebnis stellt sich heraus, dass die Methode <code>doSomething()</code> durch Zugriff auf das Objekt <code>doSomething()</code> aufgerufen werden kann.  Dies bedeutet außerdem, dass die Eigenschaft <code>__proto__</code> des Objekts <code>specializedService</code> auf ein <code>service</code> verweist. <br><br>  Erstellen Sie nun ein ähnliches Objekt mit dem Schlüsselwort <code>class</code> : <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ doSomething(){} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpecializedService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ } let specializedService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SpecializedService</span></span>(); console.log(specializedService.__proto__ === <span class="hljs-type"><span class="hljs-type">SpecializedService</span></span>.prototype);</code> </pre> <br>  In der <code>Service</code> Klasse deklarierte Methoden werden dem <code>Service.prototype</code> Objekt hinzugefügt.  Instanzen der <code>Service</code> Klasse haben denselben Prototyp ( <code>Service.prototype</code> ).  Alle Instanzen delegieren Methodenaufrufe an das <code>Service.prototype</code> Objekt.  Infolgedessen stellt sich heraus, dass Methoden in <code>Service.prototype</code> nur einmal deklariert werden. <code>Service.prototype</code> werden sie von allen Instanzen der Klasse "geerbt". <br><br><h3>  <font color="#3AC1EF">▍ Prototypkette</font> </h3><br>  Objekte können „Erben“ anderer Objekte sein.  Jedes Objekt hat einen Prototyp, dessen Methoden ihm zur Verfügung stehen.  Wenn Sie versuchen, auf eine Eigenschaft zuzugreifen, die sich nicht im Objekt selbst befindet, beginnt JavaScript, in der Prototypenkette danach zu suchen.  Dieser Vorgang wird fortgesetzt, bis die Eigenschaft gefunden wurde oder bis die Suche das Ende der Kette erreicht. <br><br><h2>  <font color="#3AC1EF">Informationen zur funktionalen Programmierung in JavaScript</font> </h2><br>  In JavaScript sind Funktionen erstklassige Objekte, die Sprache unterstützt den Schließmechanismus.  Dies eröffnet den Weg zur Implementierung funktionaler Programmiertechniken in JS.  Insbesondere sprechen wir über die Möglichkeit, Funktionen höherer Ordnung zu verwenden. <br><br>  Ein Abschluss ist eine interne Funktion, die Zugriff auf Variablen hat, die in der übergeordneten Funktion deklariert sind, auch nachdem die übergeordnete Funktion ausgeführt wurde. <br><br>  Eine Funktion höherer Ordnung ist eine Funktion, die andere Funktionen als Argumente verwenden, Funktionen zurückgeben oder beides ausführen kann. <br><br>  Die funktionale Programmierung in JS wird in vielen Veröffentlichungen behandelt.  Wenn Sie interessiert sind, finden Sie hier einige Materialien zu diesem Thema, die sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mit erstklassigen Funktionen</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kompositionen</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dekoratoren</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verschlüssen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesbarkeit von Code</a> befassen, der in einem funktionalen Stil geschrieben wurde. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Die Stärke von JavaScript liegt in seiner Einfachheit.  Das Verständnis der grundlegenden Mechanismen der Sprache ermöglicht es dem Programmierer, der JS verwendet, diese Mechanismen effektiver anzuwenden, und legt die Grundlage für sein berufliches Wachstum. <br><br>  <b>Liebe Leser!</b>  Welche Funktionen von JavaScript verursachen Ihrer Meinung nach die meisten Neulinge? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416375/">https://habr.com/ru/post/de416375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416363/index.html">Taobao wurde offiziell in Russland eröffnet</a></li>
<li><a href="../de416365/index.html">Sammlung von Wünschen und Abstimmung für neue Funktionen des Vivaldi-Browsers</a></li>
<li><a href="../de416367/index.html">Wir starten ReactOS mit BTRFS des Abschnitts</a></li>
<li><a href="../de416369/index.html">Fast kompliziert. Teil 2, Schaffung eines drahtlosen „Smart Home“. Basierend auf Linux-Technologie, Z-Wave- und MajorDoMo-Software</a></li>
<li><a href="../de416371/index.html">Analoges Campinglicht</a></li>
<li><a href="../de416377/index.html">Wir werden zu Assistenten in der Programmierung. Teil 1</a></li>
<li><a href="../de416379/index.html">Neurobugurt. Wie wir dem neuronalen Netzwerk beigebracht haben, Meme ein Jahr früher als Stanford zu erfinden</a></li>
<li><a href="../de416381/index.html">Bericht des Club of Rome 2018, Kapitel 3.13: Philanthropie, Investition, Crowdsourcing und Blockchain</a></li>
<li><a href="../de416385/index.html">Wenn die Korrelation zu 100% herauskommt, hat sich irgendwo ein Fehler eingeschlichen: die Praktikumserfahrung bei der Rambler Group</a></li>
<li><a href="../de416387/index.html">Shrimp: Skalieren und teilen Sie HTTP-Bilder in modernem C ++ mit ImageMagic ++, SObjectizer und RESTinio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>