<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçü§ù‚Äçüë®üèΩ üêì üìò JavaScript-Grundlagen f√ºr Anf√§nger üë∞üèæ üë®üèΩ‚ÄçüöÄ üèáüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, ist den Grundlagen von JavaScript gewidmet und richtet sich an Programmierer f√ºr Anf√§nger....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Grundlagen f√ºr Anf√§nger</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/416375/">  Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, ist den Grundlagen von JavaScript gewidmet und richtet sich an Programmierer f√ºr Anf√§nger.  Es kann als kleiner Hinweis auf die Grundkonstruktionen von JS betrachtet werden.  Hier werden wir insbesondere √ºber das Datentypsystem, √ºber Variablen, √ºber Arrays, √ºber Funktionen, √ºber Prototypen von Objekten und √ºber einige andere Merkmale der Sprache sprechen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/my/cj/zq/mycjzqfpfohnkk9vnefgsl915vm.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Primitive Datentypen</font> </h2><br>  Die folgenden primitiven Datentypen sind in JavaScript verf√ºgbar: <code>number</code> , <code>boolean</code> , <code>string</code> , <code>undefined</code> , <code>null</code> .  Es sollte sofort beachtet werden, dass wir bei der Arbeit mit primitiven Datentypen, beispielsweise mit Zeichenfolgenliteralen, auch ohne explizite Konvertierung auf deren Methoden und Eigenschaften zugreifen k√∂nnen.  Der Punkt hier ist, dass beim Versuch, solche Operationen auszuf√ºhren, Literale automatisch mit dem entsprechenden Objekt-Wrapper ausgestattet werden. <br><br><h3>  <font color="#3AC1EF">‚ñç Zahlen</font> </h3><br>  JavaScript hat nur einen Zifferntyp - Gleitkommazahlen mit doppelter Genauigkeit.  Dies f√ºhrt dazu, dass die Ergebnisse der Berechnung einiger Ausdr√ºcke arithmetisch falsch sind.  M√∂glicherweise wissen Sie bereits, dass in JS der Wert des Ausdrucks <code>0.1 + 0.2</code> nicht <code>0.3</code> .  Gleichzeitig werden beim Arbeiten mit ganzen Zahlen solche Probleme nicht beobachtet, <code>1 + 2 === 3</code> . <br><br>  JavaScript verf√ºgt √ºber ein <code>Number</code> Objekt, bei dem es sich um einen Objekt-Wrapper f√ºr numerische Werte handelt.  Objekte vom Typ <code>Number</code> k√∂nnen entweder mit einem Befehl der Form <code>var a = new Number(10)</code> werden oder Sie k√∂nnen sich auf das automatische Verhalten des oben beschriebenen Systems verlassen.  Auf diese Weise k√∂nnen Sie insbesondere in <code>Number.prototype</code> gespeicherte Methoden <code>Number.prototype</code> , die auf numerische Literale angewendet werden: <br><br><pre> <code class="hljs ruby">(<span class="hljs-number"><span class="hljs-number">123</span></span>).toString();  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"123"</span></span> (<span class="hljs-number"><span class="hljs-number">1.23</span></span>).toFixed(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"1.2"</span></span></code> </pre> <br>  Es gibt globale Funktionen, mit denen Werte anderer Typen in einen numerischen Typ konvertiert werden k√∂nnen.  Dies sind <code>parseInt()</code> , <code>parseFloat()</code> und das <code>Number()</code> <code>parseFloat()</code> , das in diesem Fall als normale Funktion fungiert, die die Typkonvertierung durchf√ºhrt: <br><br><pre> <code class="hljs julia">parseInt(<span class="hljs-string"><span class="hljs-string">"1"</span></span>)       //<span class="hljs-number"><span class="hljs-number">1</span></span> parseInt(<span class="hljs-string"><span class="hljs-string">"text"</span></span>)    //<span class="hljs-literal"><span class="hljs-literal">NaN</span></span> parseFloat(<span class="hljs-string"><span class="hljs-string">"1.234"</span></span>) //<span class="hljs-number"><span class="hljs-number">1.234</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>)         //<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(<span class="hljs-string"><span class="hljs-string">"1.234"</span></span>)     //<span class="hljs-number"><span class="hljs-number">1.234</span></span></code> </pre> <br>  Wenn w√§hrend der Operation mit Zahlen etwas erhalten wird, das keine Zahl ist (w√§hrend einiger Berechnungen oder beim Versuch, etwas in eine Zahl umzuwandeln), gibt JavaScript keinen Fehler aus, sondern zeigt das Ergebnis einer solchen Operation als den Wert <code>NaN</code> (Not-a-Number, keine Zahl).  Um zu √ºberpr√ºfen, ob ein bestimmter Wert <code>NaN</code> , k√∂nnen Sie die Funktion <code>isNaN()</code> verwenden. <br><br>  JS-Arithmetikoperationen funktionieren auf eine recht vertraute Weise, aber Sie m√ºssen darauf achten, dass der Operator <code>+</code> das Hinzuf√ºgen von Zahlen und das Verketten von Zeichenfolgen durchf√ºhren kann. <br><br><pre> <code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>      //<span class="hljs-number"><span class="hljs-number">2</span></span> "1" + "1"  //"11" <span class="hljs-number"><span class="hljs-number">1</span></span> + "1"    //"11"</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçStrings</font> </h3><br>  JavaScript-Zeichenfolgen sind Unicode-Zeichenfolgen.  String-Literale werden erstellt, indem der Text in doppelte ( <code>""</code> ) oder einfache ( <code>''</code> ) Anf√ºhrungszeichen eingeschlossen wird.  Wie bereits erw√§hnt, k√∂nnen wir uns bei der Arbeit mit String-Literalen auf den entsprechenden Objekt-Wrapper verlassen, dessen Prototyp viele n√ºtzliche Methoden enth√§lt, darunter <code>indexOf()</code> , <code>concat()</code> , <code>concat()</code> . <br><br><pre> <code class="hljs pgsql">"text".substring(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) //ex "text".indexOf(<span class="hljs-string"><span class="hljs-string">'x'</span></span>)   //<span class="hljs-number"><span class="hljs-number">2</span></span> "text".concat(" end") //<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Strings sind wie andere primitive Werte unver√§nderlich.  Beispielsweise <code>concat()</code> die <code>concat()</code> -Methode keine vorhandene Zeichenfolge, sondern erstellt eine neue. <br><br><h3>  <font color="#3AC1EF">‚ñçLogische Werte</font> </h3><br>  Der logische Datentyp in JS wird durch zwei Werte dargestellt - <code>true</code> und <code>false</code> .  Die Sprache kann verschiedene Werte automatisch in einen logischen Datentyp konvertieren.  Falsch sind also zus√§tzlich zum logischen Wert <code>false</code> die Werte <code>null</code> , <code>undefined</code> , <code>''</code> (leere Zeichenfolge), <code>0</code> und <code>NaN</code> .  Alles andere, einschlie√ülich aller Objekte, repr√§sentiert wahre Bedeutungen.  Im Verlauf logischer Operationen wird alles, was als wahr angesehen wird, in <code>true</code> , und alles, was als falsch angesehen wird, wird in falsch umgewandelt.  Schauen Sie sich das folgende Beispiel an.  In √úbereinstimmung mit den obigen Prinzipien wird eine leere Zeichenfolge in <code>false</code> konvertiert <code>false</code> und als Ergebnis dieser Codeausf√ºhrung wird die Zeichenfolge <code>This is false</code> an die Konsole gesendet. <br><br><pre> <code class="hljs pgsql">let <span class="hljs-type"><span class="hljs-type">text</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-type"><span class="hljs-type">text</span></span>) { console.log("This is true"); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { console.log("This is false"); }</code> </pre> <br><h2>  <font color="#3AC1EF">Die Objekte</font> </h2><br>  Objekte sind dynamische Strukturen, die aus Schl√ºssel-Wert-Paaren bestehen.  Werte k√∂nnen primitive Datentypen haben, k√∂nnen Objekte oder Funktionen sein. <br><br>  Objekte lassen sich am einfachsten mit der Objektliteral-Syntax erstellen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">message</span></span> : <span class="hljs-string"><span class="hljs-string">"A message"</span></span>, <span class="hljs-attr"><span class="hljs-attr">doSomething</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }</code> </pre> <br>  Die Eigenschaften eines Objekts k√∂nnen jederzeit gelesen, hinzugef√ºgt, bearbeitet und gel√∂scht werden.  So geht's: <br><br><ul><li>  <code>object.name, object[expression]</code> : <code>object.name, object[expression]</code> . </li><li>  Schreiben von Daten in Eigenschaften (wenn die Eigenschaft, auf die zugegriffen wird, nicht vorhanden ist, wird eine neue Eigenschaft mit dem angegebenen Schl√ºssel hinzugef√ºgt): <code>object.name = value</code> , <code>object[expression] = value</code> . </li><li>  Eigenschaften entfernen: <code>delete object.name</code> <code>delete object[expression]</code> . </li></ul><br>  Hier einige Beispiele: <br><br><pre> <code class="hljs ruby">let obj = {}; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    obj.message = <span class="hljs-string"><span class="hljs-string">"A message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    obj.message = <span class="hljs-string"><span class="hljs-string">"A new message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   delete object.message; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  </code> </pre> <br>  Objekte in der Sprache werden als Hash-Tabellen implementiert.  Eine einfache Hash-Tabelle kann mit dem <code>Object.create(null)</code> : <br><br><pre> <code class="hljs pgsql">let french = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); french["yes"] = "oui"; french["no"]  = "non"; french["yes"];//"oui"</code> </pre> <br>  Wenn das Objekt unver√§nderlich gemacht werden muss, k√∂nnen Sie den Befehl <code>Object.freeze()</code> . <br><br>  Um alle Eigenschaften eines Objekts zu <code>Object.keys()</code> , k√∂nnen Sie den Befehl <code>Object.keys()</code> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> logProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>){ console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>); //  console.log(obj[<span class="hljs-type"><span class="hljs-type">name</span></span>]); //   } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(obj).<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(logProperty);</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçVergleich von Werten primitiver Typen und Objekte</font> </h3><br>  In der praktischen Arbeit mit primitiven Werten k√∂nnen Sie sie, wie bereits erw√§hnt, als Objekte mit Eigenschaften und Methoden wahrnehmen, obwohl sie keine Objekte sind.  Primitive Werte sind unver√§nderlich, die interne Struktur von Objekten kann sich √§ndern. <br><br><h2>  <font color="#3AC1EF">Variablen</font> </h2><br>  In JavaScript k√∂nnen Variablen mit den Schl√ºsselw√∂rtern <code>var</code> , <code>let</code> und <code>const</code> deklariert werden. <br><br>  Mit dem Schl√ºsselwort <code>var</code> k√∂nnen Sie eine Variable deklarieren und bei Bedarf mit einem bestimmten Wert initialisieren.  Wenn die Variable nicht initialisiert ist, ist ihr Wert <code>undefined</code> .  Mit dem Schl√ºsselwort <code>var</code> deklarierte Variablen haben einen Funktionsumfang. <br><br>  Das Schl√ºsselwort <code>let</code> ist <code>var</code> sehr √§hnlich. Der Unterschied besteht darin, dass Variablen, die mit dem Schl√ºsselwort <code>let</code> deklariert wurden, einen Blockbereich haben. <br><br>  Mit dem Schl√ºsselwort <code>const</code> deklarierte Variablen haben auch einen Blockbereich, der angesichts der Tatsache, dass die Werte solcher Variablen nicht ge√§ndert werden k√∂nnen, korrekter als "Konstanten" bezeichnet wird.  Das Schl√ºsselwort <code>const</code> , das den Wert einer mit ihm deklarierten Variablen "einfriert", kann mit der <code>Object.freeze()</code> -Methode verglichen werden, die Objekte "einfriert". <br><br>  Wenn eine Variable au√üerhalb einer Funktion deklariert wird, ist ihr G√ºltigkeitsbereich global. <br><br><h2>  <font color="#3AC1EF">Arrays</font> </h2><br>  Arrays in JavaScript werden mithilfe von Objekten implementiert.  Wenn wir √ºber Arrays sprechen, diskutieren wir daher Objekte, die Arrays √§hnlich sind.  Sie k√∂nnen mit Array-Elementen anhand ihrer Indizes arbeiten.  Numerische Indizes werden in Zeichenfolgen konvertiert und als Namen f√ºr den Zugriff auf die Werte von Array-Elementen verwendet.  Beispielsweise √§hnelt ein Konstrukt der Form <code>arr[1]</code> einem Konstrukt der Form <code>arr['1']</code> , und beide geben Zugriff auf denselben Wert: <code>arr[1] === arr['1']</code> .  In √úbereinstimmung mit dem Obigen wird ein einfaches Array, das durch den Befehl <code>let arr = ['A', 'B', 'C']</code> deklariert wurde, als ein Objekt der folgenden Form dargestellt: <br><br><pre> <code class="hljs objectivec">{ <span class="hljs-string"><span class="hljs-string">'0'</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>: <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>: <span class="hljs-string"><span class="hljs-string">'C'</span></span> }</code> </pre> <br>  Das Entfernen von Array-Elementen mit dem Befehl <code>delete</code> hinterl√§sst L√ºcken.  Um dieses Problem zu vermeiden, k√∂nnen Sie den Befehl <code>splice()</code> , der jedoch langsam funktioniert, da nach dem L√∂schen eines Elements die verbleibenden Elemente des Arrays verschoben und tats√§chlich an den Anfang des Arrays nach links verschoben werden. <br><br><pre> <code class="hljs powershell">let arr = [<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>]; delete arr[<span class="hljs-number"><span class="hljs-number">1</span></span>]; console.log(arr); // [<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-type"><span class="hljs-type">empty</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>] console.log(arr.length); // <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Array-Methoden erleichtern die Implementierung von Datenstrukturen wie Stapeln und Warteschlangen: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/  let stack = []; stack.push(1);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1] stack.push(2);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1, 2] let last = stack.pop();  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1] console.log(last);       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  let queue = []; queue.push(1);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1] queue.push(2);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1, 2] let first = queue.shift();/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/[2] console.log(first);      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Funktionen</font> </h2><br>  Funktionen in JavaScript sind Objekte.  Funktionen k√∂nnen Variablen zugewiesen, in Objekten oder Arrays gespeichert, als Argumente an andere Funktionen √ºbergeben und von anderen Funktionen zur√ºckgegeben werden. <br><br>  Es gibt drei M√∂glichkeiten, Funktionen zu deklarieren: <br><br><ul><li>  Klassische Funktionsdeklaration (Funktionsdeklaration oder Funktionsanweisung). </li><li>  Die Verwendung von Funktionsausdr√ºcken (Funktionsausdruck), die auch als Funktionsliterale (Funktionsliteral) bezeichnet werden. </li><li>  Verwendung der Syntax von Pfeilfunktionen (Pfeilfunktion). </li></ul><br><h3>  <font color="#3AC1EF">‚ñç Klassische Funktionsdeklaration</font> </h3><br>  Bei diesem Ansatz zum Deklarieren von Funktionen gelten die folgenden Regeln: <br><br><ul><li>  Das erste Schl√ºsselwort in einer Funktionsdeklarationszeile ist <code>function</code> . </li><li>  Funktionen m√ºssen einen Namen erhalten. </li><li>  Die Funktion kann im Code vor ihrer Deklaration verwendet werden, da die Deklaration der Funktion an die Spitze des Bereichs angehoben wird, in dem sie deklariert ist. </li></ul><br>  So sieht eine klassische Funktionsdeklaration aus: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{}</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Funktionsausdr√ºcke</font> </h3><br>  Bei der Verwendung von Funktionsausdr√ºcken sollte Folgendes ber√ºcksichtigt werden: <br><br><ul><li>  Das <code>function</code> ist nicht mehr das erste Wort in einer Funktionsdeklarationszeile. </li><li>  Ein Funktionsname ist optional.  Es k√∂nnen sowohl anonyme als auch benannte Funktionsausdr√ºcke verwendet werden. </li><li>  Befehle zum Aufrufen solcher Funktionen sollten den Befehlen f√ºr ihre Deklaration folgen. </li><li>  Eine solche Funktion kann unmittelbar nach der Deklaration mit der Syntax von IIFE (Sofort aufgerufener Funktionsausdruck - sofort als Funktionsausdruck bezeichnet) gestartet werden. </li></ul><br>  Der funktionale Ausdruck sieht folgenderma√üen aus: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Pfeilfunktionen</font> </h3><br>  Pfeilfunktionen k√∂nnen in der Tat als ‚Äûsyntaktischer Zucker‚Äú betrachtet werden, um anonyme funktionale Ausdr√ºcke zu erstellen.  Es ist zu beachten, dass solche Funktionen keine eigenen Entit√§ten und <code>arguments</code> .  Die Pfeilfunktionsdeklaration sieht folgenderma√üen aus: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doSomething = () = &gt; {};</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç M√∂glichkeiten zum Aufrufen von Funktionen</font> </h3><br>  Funktionen k√∂nnen auf verschiedene Arten aufgerufen werden. <br><br><h4>  Normaler Funktionsaufruf </h4><br><pre> <code class="hljs lisp">doSomething(<span class="hljs-name"><span class="hljs-name">arguments</span></span>)</code> </pre> <br><h4>  Funktionsaufruf in Form einer Objektmethode </h4><br><pre> <code class="hljs markdown">theObject.doSomething(arguments) theObject[<span class="hljs-string"><span class="hljs-string">"doSomething"</span></span>](<span class="hljs-link"><span class="hljs-link">arguments</span></span>)</code> </pre> <br><h4>  Konstruktorfunktionsaufruf </h4><br><pre> <code class="hljs lisp">new doSomething(<span class="hljs-name"><span class="hljs-name">arguments</span></span>)</code> </pre> <br><h4>  Aufrufen einer Funktion mit der Methode apply () </h4><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">doSomething</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.apply</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">theObject</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[arguments]</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">doSomething</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.call</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">theObject</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">arguments</span></span>)</code> </pre> <br><h4>  Aufrufen einer Funktion mit der Methode bind () </h4><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doSomethingWithObject = doSomething.bind(theObject); doSomethingWithObject();</code> </pre> <br>  Funktionen k√∂nnen mit mehr oder weniger Argumenten als der Anzahl der Parameter aufgerufen werden, die bei der Deklaration angegeben wurden.  W√§hrend der Arbeit der Funktion werden die "zus√§tzlichen" Argumente einfach ignoriert (obwohl die Funktion Zugriff darauf hat), die fehlenden Parameter erhalten den Wert <code>undefined</code> . <br><br>  Funktionen haben zwei Pseudoparameter: <code>this</code> und <code>arguments</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç Stichwort dies</font> </h3><br>  Das <code>this</code> repr√§sentiert den Kontext einer Funktion.  Der Wert, auf den es zeigt, h√§ngt davon ab, wie die Funktion aufgerufen wurde.  Hier sind die Bedeutungen <code>this</code> Schl√ºsselworts in Abh√§ngigkeit davon, wie die Funktion aufgerufen wird (sie werden oben mit Codebeispielen beschrieben, deren Konstruktionen hier verwendet werden): <br><br><ul><li>  Der √ºbliche Funktionsaufruf ist <code>window</code> / <code>undefined</code> . </li><li>  Ein Funktionsaufruf in Form einer Objektmethode ist <code>theObject</code> . </li><li>  Ein Funktionsaufruf in Form eines Konstruktors ist ein neues Objekt. </li><li>  Aufrufen einer Funktion mit der Methode <code>apply()</code> - <code>theObject</code> . </li><li>  Aufrufen einer Funktion mit der Methode <code>bind()</code> - <code>theObject</code> . </li></ul><br><h3>  <font color="#3AC1EF">‚ñç Schl√ºsselwortargumente</font> </h3><br>  Das <code>arguments</code> Schl√ºsselwort ist ein Pseudoparameter, der Zugriff auf alle Argumente gibt, die zum Aufrufen der Funktion verwendet werden.  Es sieht aus wie ein Array, aber kein Array.  Insbesondere verf√ºgt es nicht √ºber Array-Methoden. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> reduceToSum(total, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total + <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> sum(){ let args = <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.prototype.<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(arguments); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args.reduce(reduceToSum, <span class="hljs-number"><span class="hljs-number">0</span></span>); } sum(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Eine Alternative zum <code>arguments</code> Schl√ºsselwort ist die neue Syntax f√ºr die verbleibenden Parameter.  Im folgenden Beispiel ist <code>args</code> ein Array, das alles enth√§lt, was beim Aufruf an die Funktion √ºbergeben wurde. <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...args</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args.reduce(reduceToSum, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçOperator zur√ºck</font> </h3><br>  Eine Funktion ohne <code>return</code> gibt <code>undefined</code> .  Achten Sie mit dem Schl√ºsselwort <code>return</code> darauf, wie der automatische Einf√ºgungsmechanismus f√ºr Semikolons funktioniert.  Die folgende Funktion gibt beispielsweise kein leeres Objekt, sondern einen <code>undefined</code> Wert zur√ºck: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { } } getObject()</code> </pre> <br>  Um ein √§hnliches Problem zu vermeiden, muss die √∂ffnende geschweifte Klammer in derselben Zeile wie die <code>return</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { } }</code> </pre> <br><h2>  <font color="#3AC1EF">Dynamische Eingabe</font> </h2><br>  JavaScript ist eine dynamische Schreibsprache.  Dies bedeutet, dass bestimmte Werte Typen haben, Variablen jedoch nicht.  W√§hrend der Programmausf√ºhrung k√∂nnen Werte unterschiedlichen Typs in dieselbe Variable geschrieben werden.  Hier ist ein Beispiel f√ºr eine Funktion, die mit Werten verschiedener Typen arbeitet: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> log(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>){ console.log(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } log(<span class="hljs-number"><span class="hljs-number">1</span></span>); log("text"); log({message : "text"});</code> </pre> <br>  Um den in einer Variablen gespeicherten Datentyp herauszufinden, k√∂nnen Sie den Operator <code>typeof()</code> : <br><br><pre> <code class="hljs lua">let n = <span class="hljs-number"><span class="hljs-number">1</span></span>; typeof(n);   //number let s = <span class="hljs-string"><span class="hljs-string">"text"</span></span>; typeof(s);   //<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> let fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {}; typeof(fn);  //<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Single-Threaded-Ausf√ºhrungsmodell</font> </h2><br>  Die JavaScript-Laufzeit ist Single-Threaded.  Dies dr√ºckt sich insbesondere in der Unm√∂glichkeit aus, zwei Funktionen gleichzeitig auszuf√ºhren (wenn Sie die M√∂glichkeiten der asynchronen Codeausf√ºhrung, die wir hier nicht ansprechen, nicht ber√ºcksichtigen).  Die Laufzeit hat eine sogenannte Ereigniswarteschlange, in der eine Liste der Aufgaben gespeichert ist, die verarbeitet werden m√ºssen.  Infolgedessen ist f√ºr ein JS-Ausf√ºhrungsschema mit einem Thread das Problem der gegenseitigen Ressourcensperren nicht typisch, weshalb der Sperrmechanismus hier nicht ben√∂tigt wird.  Code, der in die Ereigniswarteschlange f√§llt, muss jedoch schnell ausgef√ºhrt werden.  Wenn Sie mit viel Arbeit √ºberladen, reagiert die Anwendungsseite in der Browseranwendung, dem Hauptthread, nicht auf Benutzeraktionen, und der Browser bietet an, diese Seite zu schlie√üen. <br><br><h2>  <font color="#3AC1EF">Ausnahmebehandlung</font> </h2><br>  JavaScript verf√ºgt √ºber einen Mechanismus zur Behandlung von Ausnahmen.  Es funktioniert nach einem f√ºr solche Mechanismen √ºblichen Prinzip: Der Code, der einen Fehler verursachen kann, wird mit dem <code>try/catch</code> Konstrukt ausgef√ºhrt.  Der Code selbst befindet sich im <code>try</code> Block, Fehler werden im <code>catch</code> . <br><br>  Es ist interessant festzustellen, dass JavaScript im Notfall manchmal keine Fehlermeldungen erzeugt.  Dies liegt an der Tatsache, dass JS bis zur √úbernahme des ECMAScript 3-Standards keine Fehler ausgegeben hat. <br><br>  Im folgenden Codefragment schl√§gt beispielsweise der Versuch fehl, ein "eingefrorenes" Objekt zu √§ndern, es wird jedoch keine Ausnahme ausgel√∂st. <br><br><pre> <code class="hljs pgsql">let obj = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({}); obj.message = "text";</code> </pre> <br>  Einige der "stillen" JS-Fehler werden im strikten Modus angezeigt. Sie k√∂nnen sie mithilfe der Konstruktion <code>"use strict";</code> aktivieren <code>"use strict";</code>  . <br><br><h2>  <font color="#3AC1EF">Prototypsystem</font> </h2><br>  Die Basis solcher JS-Mechanismen wie Konstruktorfunktionen, der Befehl <code>Object.create()</code> , das Schl√ºsselwort <code>class</code> , basiert auf einem Prototypsystem. <br>  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> service = { <span class="hljs-attr"><span class="hljs-attr">doSomething</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> specializedService = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(service); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(specializedService.__proto__ === service); <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br>  Hier wurde der Befehl <code>Object.create()</code> verwendet, um ein <code>specializedService</code> <code>service</code> zu erstellen, dessen Prototyp ein <code>service</code> sollte.  Als Ergebnis stellt sich heraus, dass die Methode <code>doSomething()</code> durch Zugriff auf das Objekt <code>doSomething()</code> aufgerufen werden kann.  Dies bedeutet au√üerdem, dass die Eigenschaft <code>__proto__</code> des Objekts <code>specializedService</code> auf ein <code>service</code> verweist. <br><br>  Erstellen Sie nun ein √§hnliches Objekt mit dem Schl√ºsselwort <code>class</code> : <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ doSomething(){} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpecializedService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ } let specializedService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SpecializedService</span></span>(); console.log(specializedService.__proto__ === <span class="hljs-type"><span class="hljs-type">SpecializedService</span></span>.prototype);</code> </pre> <br>  In der <code>Service</code> Klasse deklarierte Methoden werden dem <code>Service.prototype</code> Objekt hinzugef√ºgt.  Instanzen der <code>Service</code> Klasse haben denselben Prototyp ( <code>Service.prototype</code> ).  Alle Instanzen delegieren Methodenaufrufe an das <code>Service.prototype</code> Objekt.  Infolgedessen stellt sich heraus, dass Methoden in <code>Service.prototype</code> nur einmal deklariert werden. <code>Service.prototype</code> werden sie von allen Instanzen der Klasse "geerbt". <br><br><h3>  <font color="#3AC1EF">‚ñç Prototypkette</font> </h3><br>  Objekte k√∂nnen ‚ÄûErben‚Äú anderer Objekte sein.  Jedes Objekt hat einen Prototyp, dessen Methoden ihm zur Verf√ºgung stehen.  Wenn Sie versuchen, auf eine Eigenschaft zuzugreifen, die sich nicht im Objekt selbst befindet, beginnt JavaScript, in der Prototypenkette danach zu suchen.  Dieser Vorgang wird fortgesetzt, bis die Eigenschaft gefunden wurde oder bis die Suche das Ende der Kette erreicht. <br><br><h2>  <font color="#3AC1EF">Informationen zur funktionalen Programmierung in JavaScript</font> </h2><br>  In JavaScript sind Funktionen erstklassige Objekte, die Sprache unterst√ºtzt den Schlie√ümechanismus.  Dies er√∂ffnet den Weg zur Implementierung funktionaler Programmiertechniken in JS.  Insbesondere sprechen wir √ºber die M√∂glichkeit, Funktionen h√∂herer Ordnung zu verwenden. <br><br>  Ein Abschluss ist eine interne Funktion, die Zugriff auf Variablen hat, die in der √ºbergeordneten Funktion deklariert sind, auch nachdem die √ºbergeordnete Funktion ausgef√ºhrt wurde. <br><br>  Eine Funktion h√∂herer Ordnung ist eine Funktion, die andere Funktionen als Argumente verwenden, Funktionen zur√ºckgeben oder beides ausf√ºhren kann. <br><br>  Die funktionale Programmierung in JS wird in vielen Ver√∂ffentlichungen behandelt.  Wenn Sie interessiert sind, finden Sie hier einige Materialien zu diesem Thema, die sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mit erstklassigen Funktionen</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kompositionen</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dekoratoren</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verschl√ºssen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesbarkeit von Code</a> befassen, der in einem funktionalen Stil geschrieben wurde. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Die St√§rke von JavaScript liegt in seiner Einfachheit.  Das Verst√§ndnis der grundlegenden Mechanismen der Sprache erm√∂glicht es dem Programmierer, der JS verwendet, diese Mechanismen effektiver anzuwenden, und legt die Grundlage f√ºr sein berufliches Wachstum. <br><br>  <b>Liebe Leser!</b>  Welche Funktionen von JavaScript verursachen Ihrer Meinung nach die meisten Neulinge? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416375/">https://habr.com/ru/post/de416375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416363/index.html">Taobao wurde offiziell in Russland er√∂ffnet</a></li>
<li><a href="../de416365/index.html">Sammlung von W√ºnschen und Abstimmung f√ºr neue Funktionen des Vivaldi-Browsers</a></li>
<li><a href="../de416367/index.html">Wir starten ReactOS mit BTRFS des Abschnitts</a></li>
<li><a href="../de416369/index.html">Fast kompliziert. Teil 2, Schaffung eines drahtlosen ‚ÄûSmart Home‚Äú. Basierend auf Linux-Technologie, Z-Wave- und MajorDoMo-Software</a></li>
<li><a href="../de416371/index.html">Analoges Campinglicht</a></li>
<li><a href="../de416377/index.html">Wir werden zu Assistenten in der Programmierung. Teil 1</a></li>
<li><a href="../de416379/index.html">Neurobugurt. Wie wir dem neuronalen Netzwerk beigebracht haben, Meme ein Jahr fr√ºher als Stanford zu erfinden</a></li>
<li><a href="../de416381/index.html">Bericht des Club of Rome 2018, Kapitel 3.13: Philanthropie, Investition, Crowdsourcing und Blockchain</a></li>
<li><a href="../de416385/index.html">Wenn die Korrelation zu 100% herauskommt, hat sich irgendwo ein Fehler eingeschlichen: die Praktikumserfahrung bei der Rambler Group</a></li>
<li><a href="../de416387/index.html">Shrimp: Skalieren und teilen Sie HTTP-Bilder in modernem C ++ mit ImageMagic ++, SObjectizer und RESTinio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>