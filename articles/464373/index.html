<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍍 📨 👨🏻 Edge-to-edge en Android: hacerlo bien 🐴 👆🏽 👃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El pasado Google I / O 2019 trajo muchas innovaciones sensacionales, muchas de las cuales afectarán a la industria del desarrollo móvil en los próximo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Edge-to-edge en Android: hacerlo bien</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/464373/">  El pasado Google I / O 2019 trajo muchas innovaciones sensacionales, muchas de las cuales afectarán a la industria del desarrollo móvil en los próximos años.  No fue menos interesante seguir las tendencias emergentes.  Primero, las teclas de control mecánico pasaron a la historia, las pantallas de los teléfonos inteligentes se hicieron más grandes y los marcos laterales se volvieron más discretos.  Los gestos reemplazaron los botones del sistema en pantalla, dejando más y más espacio para el consumo de contenido.  Las aplicaciones se muestran en toda la superficie visible de la pantalla, desde el marco inferior al superior, sin restringirse a los límites condicionales de la barra de estado y el panel de navegación.  Estamos al borde de una era de borde a borde. <br><br><img src="https://habrastorage.org/webt/xu/3i/ny/xu3inyrvy6ruyd_uj5j5l97pnf0.png"><br><a name="habracut"></a><br>  ¿Qué es de borde a borde?  Entendido literalmente, esto significa que su aplicación debe mostrarse en toda la superficie visible de la pantalla, desde la parte inferior hasta el marco superior, sin restringirse a la barra de estado y los botones de navegación inferiores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/119/459/053/11945905307bf673c909e4a75a270ba0.jpg"></div><br>  <i>Borde a borde en el ejemplo del shell del sistema Android.</i> <br><br>  Cuando se trata de Android, una idea simple está lejos de ser siempre fácil de implementar.  En este artículo, hablaremos sobre cómo maximizar el uso de todo el espacio disponible en la pantalla de cualquier dispositivo, independientemente del fabricante, la versión del sistema y la variedad de configuraciones que los fabricantes de dispositivos del Reino Medio (y no solo) adoran complacer a los usuarios.  El código presentado en el artículo fue probado personalmente en más de 30 dispositivos, y en 231 dispositivos diferentes por 100 mil usuarios de nuestras aplicaciones. <br><br>  El problema de crear una interfaz de borde a borde no es nuevo en sí mismo y era relevante mucho antes de I / O 2019. Seguramente, cada uno de ustedes recordará cómo googleó por primera vez algo de la categoría: <i>"barra de estado transparente de Android"</i> o <i>"gradiente de barra de estado de Android" "</i> . <br><br>  Los criterios principales para que la aplicación coincida con el título de borde a borde son: <br><br><ul><li>  barra de estado transparente; </li><li>  Barra de navegación transparente. </li></ul><br>  Lea más sobre ellos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">material.io</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a20/18b/3a3/a2018b3a34a0d61b30d940f2c50c44fe.png"></div><br>  <i>La aplicación Deezer no se preocupa por el cumplimiento de borde a borde</i> <i><br></i> <br>  Es importante tener en cuenta que no estamos hablando de eliminarlos por completo, como en el " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modo de pantalla completa</a> ".  Dejamos al usuario la oportunidad de ver información importante del sistema y utilizar la navegación familiar. <br><br>  Un requisito igualmente importante para una solución es la escalabilidad y la extensibilidad.  Hay varios otros: <br><br><ul><li>  Cambie correctamente la pantalla sobre el teclado sin romper el soporte para los indicadores de ajuste de tamaño de actividad; </li><li>  Evite superponer la barra de estado y la barra de navegación en los elementos de la interfaz de usuario de la aplicación, mientras muestra el fondo correspondiente debajo de ellos; </li><li>  Trabaja en todos los dispositivos con versiones actuales de Android y tiene un aspecto idéntico. </li></ul><br><h1>  Poco de teoría </h1><br>  De manera inesperada, puede tomar mucho tiempo encontrar una solución para una tarea aparentemente simple, que no será fácil de explicar para el gerente del proyecto.  Y cuando QA todavía encuentra el teléfono inteligente desafortunado, en el que su pantalla no se ve "según los cánones" ... <br>  En nuestro proyecto, nos equivocamos varias veces.  Solo un mes después, después de pasar por una larga serie de prueba y error, resolvimos el problema de una vez por todas. <br><br>  En primer lugar, debe comprender cómo Android dibuja los paneles del sistema.  Comenzando con Android 5.0, se proporcionó una API conveniente para trabajar con sangrías del sistema a lo largo de los bordes horizontales de la pantalla.  Se llaman WindowInsets, y en la imagen a continuación están coloreados en rojo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/f76/d86/bd4f76d86dd3508a88edf9618eab7a1b.png"></div><br>  Además, los desarrolladores del equipo de Android han agregado escuchas que le permiten suscribirse a los cambios en estas sangrías, por ejemplo, cuando aparece el teclado.  Estrictamente hablando, WindowInsets son los márgenes de su archivo de diseño desde los bordes de la pantalla.  Al cambiar el tamaño de su actividad (modo de pantalla dividida, apariencia del teclado), el recuadro también cambiará.  Por lo tanto, para admitir borde a borde, debemos asegurarnos de que estas sangrías no estén allí.  Una pantalla con WindowInsets nulos se verá así: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/197/cca/01d/197cca01df6de4ab8707131a70f8c993.png"></div><br><h1>  Implementación </h1><br>  En nuestra implementación, operaremos activamente en Windows y sus banderas. <br>  Todos los ejemplos se escribirán en Kotlin, pero puede implementarlos fácilmente en Java, utilizando utilidades en lugar de funciones de extensión. <br><br>  Lo primero que debe hacer con el elemento de diseño raíz es establecer explícitamente el indicador: <br><br><pre><code class="kotlin hljs">android:fitsSystemWindows=<span class="hljs-string"><span class="hljs-string">"true"</span></span></code> </pre> <br>  Esto es necesario para garantizar que la Vista raíz se dibuje debajo de los elementos del sistema, así como para las medidas correctas de Inset al suscribirse a su cambio. <br>  Ahora pasamos a lo más importante: ¡eliminamos los bordes de la pantalla!  Sin embargo, esto debe hacerse con mucho cuidado.  Y aquí está el por qué: <br><br><ol><li>  Poniendo a cero el recuadro inferior, corremos el riesgo de perder la reacción de la ventana a la apariencia del teclado: hay muchos consejos en StackOverflow para restablecer el recuadro superior, pero los inferiores son delicadamente silenciosos.  Debido a esto, la barra de navegación no resulta ser completamente transparente.  Al restablecer el recuadro inferior, el indicador de ajuste de tamaño deja de funcionar. <br><br>  <b>Solución:</b> cada vez que cambie el recuadro, determine si la altura más baja del teclado está contenido en él y solo reinícielo de lo contrario. </li><li>  Cuando reinicia el recuadro, las partes visibles de la vista aparecerán debajo de la barra de estado y la barra de navegación.  Según el concepto de diseño de materiales (y sentido común), no deben ubicarse elementos activos en las áreas del sistema.  Es decir, en esta área no debe haber botones, campos para ingresar texto, casillas de verificación, etc. <br><br>  <b>Solución:</b> agregaremos un oyente al oyente, de modo que cuando cambie WindowInsets, traduzca las sangrías del sistema a la Actividad y responda a ellas internamente configurando los rellenos y márgenes correctos para la Vista. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bd/73e/10e/3bd73e10ee50b6e2ae8a2da1b1bb2808.png"></div><br>  Este comportamiento no debe permitirse (la barra de herramientas se arrastra en la barra de estado). <br><br>  La función <i>removeSystemInsets () se</i> ve así: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeSystemInsets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, listener: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OnSystemInsetsChangedListener</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { ViewCompat.setOnApplyWindowInsetsListener(view) { _, insets -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> desiredBottomInset = calculateDesiredBottomInset( view, insets.systemWindowInsetTop, insets.systemWindowInsetBottom, listener ) ViewCompat.onApplyWindowInsets( view, insets.replaceSystemWindowInsets(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, desiredBottomInset) ) } }</code> </pre><br>  La función CalculateDesiredBottomInset <i>() calcula el</i> recuadro inferior con o sin el teclado, dependiendo de la configuración actual del dispositivo. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateDesiredBottomInset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, topInset: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bottomInset: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, listener: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OnSystemInsetsChangedListener</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasKeyboard = isKeyboardAppeared(view, bottomInset) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> desiredBottomInset = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasKeyboard) bottomInset <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> listener(topInset, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasKeyboard) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> bottomInset) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> desiredBottomInset }</code> </pre><br>  Use el método <i>isKeyboardAppeared ()</i> para verificar la altura del teclado <i>.</i>  Confiamos en la hipótesis de que el teclado no puede ocupar menos de un cuarto de la altura de la pantalla.  Si lo desea, puede modificar la lógica de verificación a su gusto. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isKeyboardAppeared</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bottomInset: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = bottomInset / resourdisplayMetrics.heightPixels.toDouble() &gt; .<span class="hljs-number"><span class="hljs-number">25</span></span></code> </pre> <br>  El método <i>removeSystemInsets ()</i> usa un escucha.  En realidad, estos son solo typealias para una expresión lambda.  Su código completo: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> OnSystemBarsSizeChangedListener = (statusBarSize: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, navigationBarSize: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span></code> </pre> <br>  El siguiente paso es establecer la transparencia en las barras del sistema: <br><br><pre> <code class="kotlin hljs">window.statusBarColor = Color.TRANSPARENT window.navigationBarColor = Color.TRANSPARENT</code> </pre> <br>  Una vez compilado todo lo anterior, obtenemos el siguiente método: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Activity.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setWindowTransparency</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( listener: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OnSystemInsetsChangedListener</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = { _, _ -&gt; } )</span></span></span></span> { InsetUtil.removeSystemInsets(window.decorView, listener) window.navigationBarColor = Color.TRANSPARENT window.statusBarColor = Color.TRANSPARENT }</code> </pre> <br>  Ahora, para habilitar el modo de borde a borde de la Actividad deseada, solo necesita llamar a la siguiente función en el método <i>onCreate ()</i> : <br><br><pre> <code class="kotlin hljs">setWindowTransparency { statusBarSize, navigationBarSize -&gt; <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br>  Por lo tanto, en menos de 30 líneas de código, hemos logrado un efecto de "borde a borde", sin violar ningún principio de UX y sin privar al usuario de los controles habituales del sistema.  Tal implementación puede parecer simple y trivial para alguien, pero es eso lo que garantiza el funcionamiento confiable de su aplicación en cualquier dispositivo. <br>  Puede lograr el efecto de "borde a borde" de aproximadamente cien formas diferentes (el número de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">consejos</a> en StackOverflow es una clara confirmación de esto), pero muchos de ellos conducen a un comportamiento incorrecto en diferentes versiones de Android, o no tienen en cuenta parámetros como la necesidad de mostrar por mucho tiempo listas, o rompa el tamaño de la pantalla al mostrar el teclado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/955/a21/a0a/955a21a0a5422a4463fa0908c0427990.gif"></div><br><hr><br><h1>  Volar en la pomada </h1><br>  La solución descrita en este artículo es adecuada para todos los dispositivos actuales.  Real significa dispositivos en Android Lollipop (5.0) y superior.  Para ellos, la solución anterior funcionará perfectamente.  Pero para las versiones anteriores de Android, necesitará su propia implementación, ya que no se sabía nada sobre WindowInsets en esos días. <br><br>  La buena noticia es que en Android KitKat (4.4), la transparencia de los paneles del sistema todavía es compatible.  Pero las versiones anteriores no admiten tal belleza en absoluto, ni siquiera puedes intentarlo. <br><br>  Centrémonos en el cambio de Insets en Android 4.4.  Esto se puede hacer en el método <i>fitSystemWindows ()</i> .  Por lo tanto, el elemento principal en su diseño debe ser un contenedor con un método anulado fitSystemWindows que contenga exactamente la misma implementación que nuestro oyente en el ejemplo para las versiones actuales de Android. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KitkatTransparentSystemBarsFrame</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@JvmOverloads</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( context: Context, attrs: AttributeSet? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, defStyleAttr: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = -<span class="hljs-number"><span class="hljs-number">1</span></span> ) : FrameLayout(context, attrs, defStyleAttr), KitkatTransparentSystemBarsContainer { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onSystemInsetsChangedListener: OnSystemInsetsChangedListener = { _, _ -&gt; } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fitSystemWindows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(insets: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Rect</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { insets ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> desiredBottomInset = InsetUtil.calculateDesiredBottomInset( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, insets.top, insets.bottom, onSystemInsetsChangedListener ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.fitSystemWindows(Rect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, desiredBottomInset)) }</code> </pre><br>  En dispositivos con Android 4.4, solo la transparencia parcial funciona mediante la configuración de indicadores translúcidos: <br><br><pre> <code class="kotlin hljs">window.addFlags( WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS or WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION )</code> </pre> <br>  Estas banderas hacen que las barras del sistema sean translúcidas, agregando un ligero gradiente que, desafortunadamente, no se puede eliminar.  Sin embargo, el gradiente se puede convertir en una barra de color translúcida usando esta biblioteca: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/jgilfelt/SystemBarTint</a> .  Ella nos ha rescatado más de una vez en el pasado.  Los últimos cambios se realizaron en la biblioteca hace 5 años, por lo que solo revelará su encanto a las verdaderas ciudades retrógradas. <br><br>  Todo el proceso de marcado para Kitkat se verá así: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Activity.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setWindowTransparencyKitkat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( rootView: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KitkatTransparentSystemBarsContainer</span></span></span></span><span class="hljs-function"><span class="hljs-params">, listener: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OnSystemBarsSizeChangedListener</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = { _, _ -&gt; } )</span></span></span></span> { rootView.onSystemBarsSizeChangedListener = listener window.addFlags( WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS or WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION ) }</code> </pre> <br>  Con esto en mente, escribimos un método universal que puede hacer que las barras del sistema sean transparentes (o al menos translúcidas), independientemente de qué aplicación se ejecute en un dispositivo con qué versión de Android: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP -&gt; setWindowTransparency(::updateMargins) Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT -&gt; setWindowTransparencyKitkat(root_container, ::updateMargins) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; { <span class="hljs-comment"><span class="hljs-comment">/*do nothing*/</span></span> } }</code> </pre><br>  Debajo del spoiler a continuación, puede ver cómo se ve la muestra presentada en el artículo en algunos de los dispositivos problemáticos: <br><br><div class="spoiler">  <b class="spoiler_title">Capturas de pantalla</b> <div class="spoiler_text">  Huawei Honor 8, Android 7.0 <br><br><img src="https://habrastorage.org/webt/vb/iq/vb/vbiqvbaw6ncicr9zaramjgp7rw4.png"><br><br>  Xiaomi Redmi Note 4, Android 6.1 <br><br><img src="https://habrastorage.org/webt/oa/qz/09/oaqz09dbvoqd9lvdrqmvd_db2lq.png"><br><br>  HTC Desire Dual Sim, Android 4.4.2 <br><br><img src="https://habrastorage.org/webt/qa/tj/og/qatjogphzqsrtj59iep-bnnqdyw.png"><br><br>  Samsung J3, Android 7.0 <br><br><img src="https://habrastorage.org/webt/_u/tm/gj/_utmgjk86esswybhkri_ropcghw.jpeg"><br><br>  Meizu M3s, Android 5.1 <br><br><img src="https://habrastorage.org/webt/5m/9b/7f/5m9b7f0wc6g3vodq2jimsaqichm.jpeg"><br><br>  Asus Zenfone 3 Max, Android 6.0 <br><br><img src="https://habrastorage.org/webt/ye/t5/9l/yet59l_2qgcqsdbnps2jgwgvx3g.jpeg"><br><br>  Umi Rome, Android 5.0 <br><br><img src="https://habrastorage.org/webt/qn/th/zp/qnthzp8jdtsobkl2t5c_et3iada.png"><br><br>  Nexus 5X, Android 8.0 <br><br><img src="https://habrastorage.org/webt/t7/9j/mo/t79jmolqrgeimm_0ylppf3nwwrk.png"><br><br>  Samsung Galaxy S8, Android 9.0 <br><br><img src="https://habrastorage.org/webt/to/cg/ab/tocgabznqxu36_wp1-d9aou0hbe.jpeg"><br></div></div><br><hr><br>  En conclusión, quiero decir que la solución incluso a una tarea aparentemente tan simple como establecer la transparencia para los elementos de la interfaz de usuario del sistema puede arrastrarlo a lo largo de toda la variedad de trampas y, en última instancia, no conducir al resultado deseado, sino que causará errores desagradables.  Qué bueno que tienes este artículo ahora. <br><br>  Puede encontrar una lista completa del programa y una muestra de trabajo en nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio de git</a> . <br><br>  El material está inspirado en el informe de Chris Banes "Convertirse en un instalador de ventanas maestro". <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_mGDMVRO3iE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Expreso mi gratitud al estudio de Surf y Evgeny Saturov por su ayuda en la preparación del material. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464373/">https://habr.com/ru/post/464373/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464361/index.html">Intel Quartz Canyon - NUC para profesionales</a></li>
<li><a href="../464365/index.html">Semana de la seguridad 34: vulnerabilidades extraordinarias en Windows</a></li>
<li><a href="../464367/index.html">Y otro Steam Windows Client Local Privilege Escalation 0day</a></li>
<li><a href="../464369/index.html">¿Qué bloqueador usas? Resultados</a></li>
<li><a href="../464371/index.html">/etc/resolv.conf para pods Kubernetes, opción ndots: 5, ya que esto puede afectar negativamente el rendimiento de la aplicación</a></li>
<li><a href="../464375/index.html">Cómo funcionan los motores de búsqueda</a></li>
<li><a href="../464377/index.html">Ensamblador sucio piratea 6502</a></li>
<li><a href="../464381/index.html">Viaje a Alaska, o KDD'19 a través de los ojos de un testigo ocular</a></li>
<li><a href="../464383/index.html">Cómo pongo las cosas en orden en un proyecto donde hay un bosque de manos directas (configuración tslint, más bonita, etc.)</a></li>
<li><a href="../464385/index.html">Python como el último caso de C ++. Parte 1/2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>