<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéé üö∂üèª üö• Discussion expliqu√©e sur la programmation asynchrone en Javascript üå≥ üß° üßõüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! 

 Comme vous vous en souvenez peut-√™tre, en octobre, nous traduisions un article int√©ressant sur l'utilisation des minuteries en Java...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Discussion expliqu√©e sur la programmation asynchrone en Javascript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/434360/"> Bonjour √† tous! <br><br>  Comme vous vous en souvenez peut-√™tre, en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">octobre,</a> nous traduisions un article int√©ressant sur l'utilisation des minuteries en Javascript.  Cela a provoqu√© une √©norme discussion, selon les r√©sultats dont nous avons longtemps voulu revenir sur ce sujet et vous proposer une analyse d√©taill√©e de la programmation asynchrone dans ce langage.  Nous sommes heureux d'avoir r√©ussi √† trouver du mat√©riel d√©cent et √† le publier avant la fin de l'ann√©e.  Bonne lecture! <br><a name="habracut"></a><br>  La programmation asynchrone en Javascript a travers√© une √©volution en plusieurs √©tapes: des rappels aux promesses et plus loin aux g√©n√©rateurs, et bient√¥t √† l' <code>async/await</code> .  √Ä chaque √©tape, la programmation asynchrone en Javascript √©tait un peu simplifi√©e pour ceux qui s'√©taient d√©j√† mis √† genoux dans cette langue, mais pour les d√©butants elle devenait seulement plus effrayante, car il fallait comprendre les nuances de chaque paradigme, ma√Ætriser l'application de chacun et, non moins important, comprendre, comment tout cela fonctionne. <br><br>  Dans cet article, nous avons d√©cid√© de rappeler bri√®vement comment utiliser les rappels et les promesses, de donner une br√®ve introduction aux g√©n√©rateurs, puis de vous aider √† comprendre intuitivement exactement comment la programmation asynchrone ¬´sous le capot¬ª avec les g√©n√©rateurs et async / wait est organis√©e.  Nous esp√©rons que vous pourrez ainsi appliquer en toute confiance les diff√©rents paradigmes exactement l√† o√π ils sont appropri√©s. <br><br>  Il est suppos√© que le lecteur a d√©j√† utilis√© des rappels, des promesses et des g√©n√©rateurs pour la programmation asynchrone, et est √©galement assez familier avec les fermetures et le curry en Javascript. <br><br>  <b>Enfer de rappel</b> <br><br>  Au d√©part, il y a eu des rappels.  Javascript n'a pas d'E / S synchrones (ci-apr√®s d√©nomm√©es E / S) et le blocage n'est pas pris en charge du tout.  Ainsi, pour organiser toute E / S ou diff√©rer une action, une telle strat√©gie a √©t√© choisie: le code qui devait √™tre ex√©cut√© de mani√®re asynchrone a √©t√© transmis √† la fonction avec ex√©cution diff√©r√©e, qui a √©t√© lanc√©e quelque part en dessous dans la boucle d'√©v√©nement.  Un rappel n'est pas si mauvais, mais le code se d√©veloppe et les rappels g√©n√®rent g√©n√©ralement de nouveaux rappels.  Le r√©sultat est quelque chose comme ceci: <br><br><pre> <code class="javascript hljs">getUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, a</span></span></span><span class="hljs-function">) </span></span>{ getMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, b</span></span></span><span class="hljs-function">) </span></span>{ getEvenMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doEvenMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, c</span></span></span><span class="hljs-function">) </span></span>{ getYetMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doYetMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Welcome to callback hell!'</span></span>); }); }); }); })</code> </pre> <br>  Mis √† part la chair de poule en voyant un tel code fractal, il y a un autre probl√®me: nous avons maintenant d√©l√©gu√© le contr√¥le de notre logique <code>do*Stuff</code> √† d'autres fonctions ( <code>get*UserData()</code> ), auxquelles vous n'avez peut-√™tre pas de code source, et vous ne l'√™tes peut-√™tre pas s√ªr qu'ils effectuent votre rappel.  Super, non? <br><br>  <b>Promesses</b> <br><br>  Les promesses inversent l'inversion du contr√¥le fourni par les rappels et aident √† d√©m√™ler un enchev√™trement de rappels dans une cha√Æne lisse. <br>  Maintenant, l'exemple pr√©c√©dent peut √™tre converti en quelque chose comme ceci: <br><br><pre> <code class="javascript hljs">getUserData() .then(getUserData) .then(doMoreStuff) .then(getEvenMoreUserData) .then(doEvenMoreStuff) .then(getYetMoreUserData) .then(doYetMoreStuff);</code> </pre><br>  D√©j√† pas si moche, hein? <br><br>  Mais laisse moi !!!  Regardons un exemple de rappel plus vital (mais encore largement artificiel): <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,     fetchJson(),   GET   , //    :         ,     ‚Äì   // . function fetchJson(url, callback) { ... } fetchJson('/api/user/self', function(e, user) { fetchJson('/api/interests?userId=' + user.id, function(e, interests) { var recommendations = []; interests.forEach(function () { fetchJson('/api/recommendations?topic=' + interest, function(e, recommendation) { recommendations.push(recommendation); if (recommendations.length == interests.length) { render(profile, interests, recommendations); } }); }); }); });</span></span></code> </pre><br>  Ainsi, nous s√©lectionnons le profil de l'utilisateur, puis ses int√©r√™ts, puis, en fonction de ses int√©r√™ts, nous s√©lectionnons des recommandations et, enfin, apr√®s avoir rassembl√© toutes les recommandations, nous affichons la page.  Un tel ensemble de rappels, dont, peut-√™tre, peut √™tre fier, mais, n√©anmoins, il est en quelque sorte hirsute.  Rien, appliquez les promesses ici - et tout ira bien.  Non? <br><br>  <code>fetchJson()</code> notre m√©thode <code>fetchJson()</code> pour qu'elle renvoie une promesse au lieu d'accepter un rappel.  Une promesse est r√©solue par un corps de r√©ponse analys√© au format JSON. <br><br><pre> <code class="javascript hljs">fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">interests</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all[interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))]; }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">recommendations</span></span></span><span class="hljs-function">) </span></span>{ render(user, interests, recommendations); });</code> </pre> <br>  Bien, non?  Quel est le probl√®me avec ce code maintenant? <br><br>  ... Oups! .. <br>  Nous n'avons pas acc√®s au profil ou aux int√©r√™ts dans la derni√®re fonction de cette cha√Æne?  Donc rien ne marche!  Que faire?  Essayons les promesses imbriqu√©es: <br><br><pre> <code class="javascript hljs">fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">interests</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: user, <span class="hljs-attr"><span class="hljs-attr">interests</span></span>: interests }); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">blob</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all[blob.interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))] .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">recommendations</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: blob.user, <span class="hljs-attr"><span class="hljs-attr">interests</span></span>: blob.interests, <span class="hljs-attr"><span class="hljs-attr">recommendations</span></span>: recommendations }); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bigBlob</span></span></span><span class="hljs-function">) </span></span>{ render(bigBlob.user, bigBlob.interests, bigBlob.recommendations); });</code> </pre> <br>  Oui ... maintenant √ßa a l'air beaucoup plus maladroit que nous l'esp√©rions.  Est-ce √† cause de ces poup√©es gigognes si folles que nous avons surtout cherch√© √† sortir de l'enfer des rappels?  Que faire maintenant? <br><br>  Le code peut √™tre un peu peign√©, en s'appuyant sur les fermetures: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     var user, interests; fetchJson('/api/user/self') .then(function (fetchedUser) { user = fetchedUser; return fetchJson('/api/user/interests?userId=' + self.id); }) .then(function (fetchedInterests) { interests = fetchedInterests; return Promise.all(interests.map(i =&gt; fetchJson('/api/recommendations?topic=' + i))); }) .then(function (recomendations) { render(user, interests, recommendations); }) .then(function () { console.log('We are done!'); });</span></span></code> </pre> <br>  Oui, maintenant tout est pratiquement comme nous le voulions, mais avec une bizarrerie.  Remarquez comment nous avons appel√© les arguments √† l'int√©rieur des rappels dans les <code>fetchedInterests</code> <code>fetchedUser</code> et <code>fetchedInterests</code> , plut√¥t que l' <code>user</code> et les <code>interests</code> ?  Si oui, alors vous √™tes tr√®s attentif! <br><br>  La faille de cette approche est la suivante: vous devez √™tre tr√®s, tr√®s prudent pour ne rien nommer dans les fonctions internes ainsi que les variables du cache que vous allez utiliser dans votre fermeture.  M√™me si vous avez le don d'√©viter les ombres, r√©f√©rencer une variable si √©lev√©e dans la fermeture semble toujours assez dangereux, et ce n'est certainement pas bon. <br><br>  <b>G√©n√©rateurs asynchrones</b> <br><br>  Les g√©n√©rateurs vous aideront!  Si vous utilisez des g√©n√©rateurs, alors toute l'excitation dispara√Æt.  Juste magique.  La v√©rit√© est.  Jetez un ≈ìil uniquement: <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br>  C‚Äôest tout.  √áa va marcher.  Vous ne fondez pas en larmes quand vous voyez √† quel point les g√©n√©rateurs sont beaux, regrettez-vous d'avoir √©t√© si myope et d'avoir commenc√© √† apprendre Javascript avant que les g√©n√©rateurs n'y apparaissent?  J'avoue, une telle id√©e m'a une fois rendu visite. <br>  Mais ... comment √ßa marche?  Vraiment magique? <br><br>  Bien s√ªr! .. Non.  Nous nous tournons vers l'exposition. <br><br>  <b>G√©n√©rateurs</b> <br><br>  Dans notre exemple, il semble que les g√©n√©rateurs soient faciles √† utiliser, mais en fait, il se passe beaucoup de choses en eux.  Pour en savoir plus sur les g√©n√©rateurs asynchrones, vous devez mieux comprendre comment fonctionnent les g√©n√©rateurs et comment ils fournissent une ex√©cution asynchrone, qui semble synchrone. <br><br>  Comme son nom l'indique, le g√©n√©rateur fait les valeurs: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> start + <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = counts(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter.next()); <span class="hljs-comment"><span class="hljs-comment">// {value: 1, done: false} console.log(counter.next()); // {value: 2, done: false} console.log(counter.next()); // {value: 3, done: false} console.log(counter.next()); // {value: 4, done: true} console.log(counter.next()); // {value: undefined, done: true}</span></span></code> </pre><br>  C'est assez simple, mais de toute fa√ßon, parlons de ce qui se passe ici: <br><br><ol><li> <code>const counter = counts();</code>  - initialiser le g√©n√©rateur et l'enregistrer dans le compteur de variables.  Le g√©n√©rateur est dans les limbes; aucun code dans le corps du g√©n√©rateur n'a encore √©t√© ex√©cut√©. </li><li> <code>console.log(counter.next());</code>  - Interpr√©tation de la sortie ( <code>yield</code> ) 1, apr√®s quoi 1 est retourn√© en tant que <code>value</code> et <code>done</code> aboutit √† <code>false</code> , car la sortie ne s'arr√™te pas l√† </li><li> <code>console.log(counter.next());</code>  - Maintenant 2! </li><li> <code>console.log(counter.next());</code>  - Maintenant 3!  Termin√©.  Tout va bien?  Non.  L'ex√©cution est interrompue au niveau du <code>yield 3;</code>  Pour terminer, vous devez appeler √† nouveau next (). </li><li> <code>console.log(counter.next());</code>  - Maintenant 4, et il revient, mais pas √©mis, alors maintenant nous quittons la fonction, et tout est pr√™t. </li><li> <code>console.log(counter.next());</code>  - Le g√©n√©rateur a fini de fonctionner!  Il n'a rien √† signaler, sauf que "tout est fait". </li></ol><br>  Nous avons donc compris comment fonctionnent les g√©n√©rateurs!  Mais attendez, quelle v√©rit√© choquante: les g√©n√©rateurs peuvent non seulement vomir des valeurs, mais aussi les d√©vorer! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are starting!"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are done!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = printer(); counter.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ! counter.next(2); // 2 counter.next(3); // 3 counter.next(4); // 4\n ! counter.next(5); //   </span></span></code> </pre><br>  Ouf, quoi?!  Un g√©n√©rateur consomme des valeurs, au lieu de les engendrer.  Comment est-ce possible? <br><br>  Le secret est dans la fonction <code>next</code> .  Il renvoie non seulement les valeurs du g√©n√©rateur, mais peut √©galement les renvoyer au g√©n√©rateur.  Si vous dites <code>next()</code> argument, alors l'op√©ration <code>yield</code> , que le g√©n√©rateur attend actuellement, se traduit en fait par l'argument.  C'est pourquoi le premier <code>counter.next(1)</code> enregistr√© comme <code>undefined</code> .  Il n'y a tout simplement aucune extradition qui pourrait √™tre r√©solue. <br><br>  C'est comme si le g√©n√©rateur permettait au code appelant (proc√©dure) et au code g√©n√©rateur (proc√©dure) de s'associer afin qu'ils se transmettent des valeurs au fur et √† mesure de leur ex√©cution et s'attendent.  La situation est pratiquement la m√™me, comme si pour les g√©n√©rateurs Javascript la possibilit√© de mettre en ≈ìuvre des proc√©dures coop√©ratives ex√©cut√©es de mani√®re comp√©titive, ce sont aussi des ¬´coroutines¬ª, aurait √©t√© envisag√©e.  En fait, √† peu pr√®s comme <code>co()</code> , non? <br><br>  Mais ne nous pr√©cipitons pas, sinon nous nous surpasserons.  Dans ce cas, il est important que le lecteur saisisse intuitivement l'essence des g√©n√©rateurs et de la programmation asynchrone, et la meilleure fa√ßon de le faire est d'assembler le g√©n√©rateur vous-m√™me.  N'√©crivez pas de fonction de g√©n√©rateur et n'utilisez pas la fonction termin√©e, mais recr√©ez vous-m√™me l'int√©rieur de la fonction de g√©n√©rateur. <br><br>  <b>Le dispositif interne du g√©n√©rateur - nous g√©n√©rons des g√©n√©rateurs</b> <br><br>  D'accord, je ne sais vraiment pas √† quoi ressemblent exactement les composants internes du g√©n√©rateur dans les diff√©rents runtimes JS.  Mais ce n'est pas si important.  Les g√©n√©rateurs correspondent √† l'interface.  Un ¬´constructeur¬ª pour instancier un g√©n√©rateur, la m√©thode <code>next(value? : any)</code> , avec laquelle nous ordonnons au g√©n√©rateur de continuer √† travailler et lui donner des valeurs, une autre m√©thode <code>throw(error)</code> au cas o√π une <code>throw(error)</code> g√©n√©r√©e √† la place d'une valeur, et enfin une m√©thode <code>return()</code> , qui est toujours silencieux.  Si la conformit√© avec l'interface est atteinte, alors tout va bien. <br><br>  Essayons donc de construire le g√©n√©rateur count <code>counts()</code> susmentionn√© sur ES5 pur, sans le mot cl√© <code>function*</code> .  Pour l'instant, vous pouvez ignorer <code>throw()</code> et passer la valeur √† <code>next()</code> , car la m√©thode n'accepte aucune entr√©e.  Comment faire <br><br>  Mais en Javascript, il existe un autre m√©canisme pour suspendre et reprendre l'ex√©cution du programme: les fermetures!  Cela vous semble familier? <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count++; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = makeCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter()); <span class="hljs-comment"><span class="hljs-comment">// 1 console.log(counter()); // 2 console.log(counter()); // 3</span></span></code> </pre> <br>  Si vous avez d√©j√† utilis√© des fermetures, je suis s√ªr que vous avez d√©j√† √©crit quelque chose comme √ßa.  La fonction retourn√©e par makeCounter peut g√©n√©rer une s√©quence infinie de nombres, tout comme un g√©n√©rateur. <br><br>  Cependant, cette fonction ne correspond pas √† l'interface du g√©n√©rateur, et elle ne peut pas √™tre directement appliqu√©e dans notre exemple avec <code>counts()</code> , qui renvoie 4 valeurs et quitte.  Que faut-il pour une approche universelle de l'√©criture de fonctions de type g√©n√©rateur? <br><br>  Fermetures, machines d'√©tat et travaux forc√©s! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; state = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">2</span></span>; state = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">3</span></span>; state = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">4</span></span>; done = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; state = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = counts(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter.next()); <span class="hljs-comment"><span class="hljs-comment">// {value: 1, done: false} console.log(counter.next()); // {value: 2, done: false} console.log(counter.next()); // {value: 3, done: false} console.log(counter.next()); // {value: 4, done: true} console.log(counter.next()); // {value: undefined, done: true}</span></span></code> </pre> <br>  En ex√©cutant ce code, vous verrez les m√™mes r√©sultats que dans la version avec le g√©n√©rateur.  Bien, non? <br>  Donc, nous avons tri√© le c√¥t√© g√©n√©rateur du g√©n√©rateur;  analysons la consommation? <br>  En fait, il n'y a pas beaucoup de diff√©rences. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are starting!"</span></span>); state = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); state = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); state = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are done!"</span></span>); done = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; state = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = printer(); counter.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ! counter.next(2); // 2 counter.next(3); // 3 counter.next(4); // 4 counter.next(5); // !</span></span></code> </pre> <br>  Tout ce qui est n√©cessaire est d'ajouter une <code>input</code> comme argument <code>go</code> , et les valeurs sont redirig√©es.  Ressemble √† la magie?  Presque comme des g√©n√©rateurs? <br><br>  Hourra!  Nous avons donc recr√©√© le g√©n√©rateur en tant que fournisseur et en tant que consommateur.  Pourquoi ne pas essayer d'y combiner ces fonctions?  Voici un autre exemple assez artificiel d'un g√©n√©rateur: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { sum += <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> sum; } }</code> </pre> <br>  √âtant donn√© que nous sommes tous sp√©cialistes des g√©n√©rateurs, nous comprenons que ce g√©n√©rateur ajoute la valeur donn√©e dans <code>next(value)</code> √† <code>sum</code> , puis renvoie sum.  Cela fonctionne exactement comme pr√©vu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.next(3)); // 6</span></span></code> </pre><br>  Cool.  √âcrivons maintenant cette interface comme une fonction normale! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-string"><span class="hljs-string">'initial'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'initial'</span></span>: result = initialValue; state = <span class="hljs-string"><span class="hljs-string">'loop'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'loop'</span></span>: sum += input; result = sum; state = <span class="hljs-string"><span class="hljs-string">'loop'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runner</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.next(3)); // 6 } runner();</span></span></code> </pre> <br>  Wow, nous avons mis en place une coroutine √† part enti√®re. <br><br>  Il y a encore quelque chose √† discuter sur le fonctionnement des g√©n√©rateurs.  Comment fonctionnent les exceptions?  Avec les exceptions qui se produisent √† l'int√©rieur des g√©n√©rateurs, tout est simple: <code>next()</code> fera que l'exception atteindra l'appelant et le g√©n√©rateur mourra.  Passer une exception au g√©n√©rateur se fait dans la m√©thode <code>throw()</code> , que nous avons omise ci-dessus. <br><br>  Enrichissons notre terminateur avec une nouvelle fonctionnalit√© int√©ressante.  Si l'appelant transmet l'exception au g√©n√©rateur, il reviendra √† la derni√®re valeur de la somme. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastSum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> temp; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { temp = sum; sum += <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> sum; lastSum = temp; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { sum = lastSum; } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.throw(new Error('BOO)!'))); // 1 console.log(add.next(4)); // 5</span></span></code> </pre><br>  <b>Probl√®me de programmation - P√©n√©tration d'erreur de g√©n√©rateur</b> <br><br>  Camarade, comment impl√©menter throw ()? <br><br>  C'est facile!  L'erreur n'est qu'une autre valeur.  Nous pouvons le passer √† <code>go()</code> comme argument suivant.  En fait, une certaine prudence s'impose ici.  Lorsque <code>throw(e)</code> appel√©, l' <code>yield</code> fonctionnera comme si nous avions √©crit throw e.  Cela signifie que nous devons v√©rifier les erreurs √† chaque √©tat de notre machine d'√©tat et planter le programme si nous ne pouvons pas g√©rer l'erreur. <br><br>  Commen√ßons par l'impl√©mentation pr√©c√©dente du terminateur, copi√©e <br><br>  <a href="">Motif</a> <br><br>  <a href="">Solution</a> <br><br>  Boum!  Nous avons impl√©ment√© un ensemble de coroutines capables de se transmettre des messages et des exceptions, tout comme un vrai g√©n√©rateur. <br><br>  Mais la situation empire, non?  L'impl√©mentation de la machine d'√©tat s'√©loigne de plus en plus de l'impl√©mentation du g√©n√©rateur.  Non seulement cela, en raison de la gestion des erreurs, le code est encombr√© de d√©chets;  le code est d'autant plus compliqu√© en raison de la longue <code>while</code> que nous avons ici.  Pour convertir une <code>while</code> vous devez la ¬´d√©m√™ler¬ª en √©tats.  Donc, notre cas 1 comprend en fait 2,5 it√©rations de la <code>while</code> , car le <code>yield</code> casse au milieu.  Enfin, vous devez ajouter du code suppl√©mentaire pour pousser les exceptions de l'appelant et vice versa s'il n'y a pas de <code>try/catch</code> dans le g√©n√©rateur pour g√©rer cette exception. <br><br>  Tu l'as fait !!!  Nous avons termin√© une analyse d√©taill√©e des alternatives possibles pour la mise en ≈ìuvre des g√©n√©rateurs et, j'esp√®re, vous avez d√©j√† mieux compris le fonctionnement des g√©n√©rateurs.  Dans le r√©sidu sec: <br><br><ul><li>  Un g√©n√©rateur peut g√©n√©rer des valeurs, consommer des valeurs ou les deux. </li><li>  L'√©tat du g√©n√©rateur peut √™tre suspendu (√©tat, machine d'√©tat, prise?) </li><li>  L'appelant et le g√©n√©rateur vous permettent de former un ensemble de corutine, en interaction les uns avec les autres </li><li>  Les exceptions sont transmises dans n'importe quelle direction. </li></ul><br>  Maintenant que nous avons une meilleure compr√©hension des g√©n√©rateurs, je propose un moyen potentiellement pratique de les raisonner: ce sont des constructions syntaxiques avec lesquelles vous pouvez √©crire des proc√©dures ex√©cut√©es de mani√®re comp√©titive qui se transmettent des valeurs les unes aux autres via un canal qui transmet les valeurs une par une ( <code>yield</code> ).  Cela sera utile dans la section suivante, o√π nous produirons une impl√©mentation de <code>co()</code> partir de coroutine. <br><br>  <b>Inversion du contr√¥le de la corutine</b> <br><br>  Maintenant que nous sommes qualifi√©s pour travailler avec des g√©n√©rateurs, r√©fl√©chissons √† la fa√ßon dont ils peuvent √™tre utilis√©s dans la programmation asynchrone.  Si nous pouvons √©crire des g√©n√©rateurs en tant que tels, cela ne signifie pas que les promesses dans les g√©n√©rateurs seront automatiquement r√©solues.  Mais attendez, les g√©n√©rateurs ne sont pas cens√©s fonctionner seuls.  Ils doivent interagir avec un autre programme, la proc√©dure principale, celle qui appelle <code>.next()</code> et <code>.throw()</code> . <br><br>  Et si nous pla√ßons notre logique m√©tier non pas dans la proc√©dure principale, mais dans le g√©n√©rateur?  Chaque fois qu'une certaine valeur asynchrone se produit, comme une promesse, pour la logique m√©tier, le g√©n√©rateur dira: "Je ne veux pas jouer avec ce non-sens, me r√©veiller quand il se r√©sout", mettra en pause et √©mettra une promesse √† la proc√©dure de service.  Proc√©dure de maintenance: "OK, je vous rappelle plus tard."  Apr√®s quoi, il enregistre un rappel avec cette promesse, quitte et attend jusqu'√† ce qu'il soit possible de d√©clencher un cycle d'√©v√©nements (c'est-√†-dire lorsque la promesse se r√©sout).  Lorsque cela se produit, la proc√©dure annoncera ¬´h√©, c'est votre tour¬ª et enverra la valeur via <code>.next()</code> g√©n√©rateur de sommeil.  Elle attendra que le g√©n√©rateur fasse son travail, et en attendant, il fera d'autres choses asynchrones ... et ainsi de suite.  Vous avez √©cout√© une triste histoire sur la fa√ßon dont la proc√©dure se poursuit au service d'un g√©n√©rateur. <br><br>  Revenons donc au sujet principal.  Maintenant que nous savons comment fonctionnent les g√©n√©rateurs et les promesses, il ne nous sera pas difficile de cr√©er une telle ¬´proc√©dure de service¬ª.  La proc√©dure de service elle-m√™me sera ex√©cut√©e de mani√®re comp√©titive comme une promesse, instanciera et maintiendra le g√©n√©rateur, puis reviendra au r√©sultat final de notre proc√©dure principale en utilisant le rappel <code>.then()</code> . <br><br>  Ensuite, revenons au programme co () et discutons-en plus en d√©tail.  <code>co()</code> est une proc√©dure de service qui prend du travail esclave afin que le g√©n√©rateur ne puisse fonctionner qu'avec des valeurs synchrones.  Semble d√©j√† beaucoup plus logique, non? <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br> ,     ,   <code>co()</code>      ,  . <br><br> <b>   ‚Äî co() </b> <br><br>  Super!     <code>co()</code> ,   ,      . <code>co()</code>  <br><br><ol><li>    ,    </li><li>   </li><li>  <code>.next()</code>       ,     <code>{done: false, value: [a Promise]}</code> </li><li>      </li><li>    (   ),  <code>.next()</code>  ,         </li><li>  ,    4 </li><li>   -    <code>{done: true, value: ...}</code> ,  ,  <code>co()</code> </li></ol><br>      ,    co(),      : <br><br> <a href=""></a> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferred</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> resolve(val)); } co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncAdds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">3</span></span>)); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">co</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   }); }</span></span></code> </pre><br> <a href=""></a> <br><br>  , ?  - 10         <code>co()</code> ,        .  ,    .    ? <br><br> <b>   ‚Äì    co()</b> <br><br>  ,  , ,  ,  <code>co()</code>     .   ,      <code>.throw()</code>   . <br><br> <a href=""></a> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferred</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> resolve(val)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferReject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> reject(e)); } co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncAdds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferredError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'To fail, or to not fail.'</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'To not fail!'</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(<span class="hljs-number"><span class="hljs-number">3</span></span>)); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">co</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   }); }</span></span></code> </pre> <br> <a href=""></a> <br><br>    .         ,      ,      <code>.next()</code>     <code>onResolve()</code> .      <code>onReject()</code> ,      <code>.throw()</code> .        <code>try/catch</code> ,     ,      <code>try/catch</code>   . <br><br> ,   <code>co()</code> ! ! <code>co()</code>    ,  ,   ,    .     , ? <br><br> <b> : async/await</b> <br><br>         <code>co()</code> .      - ,      async/await?  ‚Äî !       ,       <code>async await</code> . <br><br>     async   ,        <code>await</code> ,          <code>yield</code> . <code>await</code>            ,    <code>async</code> .   <code>async</code> -  . <br><br> ,     <code>async/await</code> ,   , -    <code>co()</code>  <code>async</code>  <code>yield</code>  <code>await</code> ,      <code>*</code> ,     . <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); }();</code> </pre> <br> ,      : <br><br><ul><li> <code>co()</code>     . async  ,        . <code>async</code>    <code>co()</code>   <code>co.wrap()</code> . </li><li>  <code>co()</code>   ( <code>yield</code> ) ,  ,     .  <code>async</code>    ( <code>await</code> ) . </li></ul><br> <b></b> <br><br>       Javascript   , ,  ¬´ ¬ª     <code>co()</code> ,  ,    ,    <code>async/await</code> . ? . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434360/">https://habr.com/ru/post/fr434360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434346/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 22: ¬´Information Security MIT¬ª, partie 3</a></li>
<li><a href="../fr434348/index.html">Vous souvenez-vous de votre mot de passe sur Habr√©?</a></li>
<li><a href="../fr434354/index.html">Cr√©ation d'un mod√®le de reconnaissance faciale √† l'aide du deep learning en Python</a></li>
<li><a href="../fr434356/index.html">Python Stiller avec e-mail</a></li>
<li><a href="../fr434358/index.html">Substitution d'importation de syst√®mes d'exploitation. Comment puis-je voir le syst√®me d'exploitation national</a></li>
<li><a href="../fr434362/index.html">PAS pr√©vu pour 2019</a></li>
<li><a href="../fr434364/index.html">Prise en charge de la file d'attente Hangfire</a></li>
<li><a href="../fr434368/index.html">Apprentissage automatique pour trouver des erreurs dans le code: comment j'ai effectu√© un stage chez JetBrains Research</a></li>
<li><a href="../fr434370/index.html">Un autre conqu√©rant de l'ombre √† Phaser, ou l'utilisation de v√©los</a></li>
<li><a href="../fr434374/index.html">V√©rification de RBAC dans Kubernetes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>