<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🍳 🙅🏿 🈺 我们脚踏实地，处理输入数据 🐱 👍🏾 🛌🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天的文章中的链接与通常的链接不同。 这不是一个对其源代码进行分析的项目，而是在几个不同项目中对相同诊断规则的一系列响应。 这里有什么兴趣？ 事实是，某些被考虑的代码片段包含在使用应用程序时可重现的错误，而另一些则完全包含漏洞（CVE）。 另外，在本文的结尾，我们将讨论有关安全缺陷的话题。 

 简...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们脚踏实地，处理输入数据</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/433932/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/iw/l-/jhiwl-y02cm4bhppsrj9flbpqsi.png"></div><br> 今天的文章中的链接与通常的链接不同。 这不是一个对其源代码进行分析的项目，而是在几个不同项目中对相同诊断规则的一系列响应。 这里有什么兴趣？ 事实是，某些被考虑的代码片段包含在使用应用程序时可重现的错误，而另一些则完全包含漏洞（CVE）。 另外，在本文的结尾，我们将讨论有关安全缺陷的话题。 <br><a name="habracut"></a><br><h2> 简要序言 </h2><br> 本文今天将要考虑的所有错误都有类似的模式： <br><br><ul><li> 程序从<i>标准输入</i>流接收数据； </li><li> 检查是否成功读取数据； </li><li> 如果成功读取数据，则从行中删除进位字符。 </li></ul><br> 但是，将要考虑的所有片段都包含错误，并且容易受到操纵输入的影响。 由于从用户那里接收到的数据可能违反应用程序执行的逻辑，因此人们很想尝试破坏某些内容。 我做到了 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio静态分析器</a>发现了以下所有问题，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分析器</a>不仅在C，C ++和C＃，Java中搜索代码中的错误。 <br><br> 当然，用静态分析仪发现问题是件好事，但是发现和再现是完全不同的乐趣。  :) <br><br><h2> 自由开关 </h2><br> 在<i>fs_cli.exe</i>模块的代码中找到了第一个可疑代码片段，该模块是FreeSWITCH分发工具包的一部分： <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">basic_gets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cnt)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = getchar(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fgets(command_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(command_buf) - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>) != command_buf) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } command_buf[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(command_buf)<span class="hljs-number"><span class="hljs-number">-1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* remove endline */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br>  <b>PVS-Studio警告</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V1010</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-20</a>索引：“ strlen（command_buf）”中使用了未经检查的污染数据。 <br><br> 分析器通过对<i>command_buf</i>数组的索引来警告可疑的调用。 由于未验证的外部数据被用作索引，因此被认为是可疑的。 外部的-因为它们是通过<i>stdin</i>流中的<i>fgets</i>函数获得的。 未验证-由于未在使用前进行验证。 表达式<i>fgets（command_buf，....）！= Command_buf</i>不计算在内，因为通过这种方式，我们仅检查接收数据的事实，而不检查其内容。 <br><br> 此代码的问题在于，在某些情况下，'\ 0'将被写入数组之外，这将导致未定义的行为。 为此，只需输入长度为零的字符串（从C语言的角度来看，即长度为零的字符串，即第一个字符为'\ 0'的字符串）。 <br><br> 让我们估计一下，如果将零长度的字符串传递给输入，将会发生什么： <br><br><ul><li>  <i>fgets（command_buf，....）</i> -&gt; <i>command_buf</i> ; </li><li>  <i>fgets（....）！= command_buf-</i> &gt; <i>false</i> （ <i>然后</i> <i>if语句</i> <i>的</i>分支将<i>被</i>忽略）； </li><li>  <i>strlen（command_buf）</i> -&gt; <i>0</i> ; </li><li>  <i>command_buf [strlen（command_buf）-1]</i> -&gt; <i>command_buf [-1]</i> 。 </li></ul><br> 糟糕！ <br><br> 有趣的是，此分析仪警告可能“用手感到”。 为了重现该问题，您需要： <br><br><ul><li> 使程序具有此功能； </li><li> 微调输入，以便<i>getchar（）</i>调用返回负值； </li><li> 将<i>fgets</i>函数传递给在开头的终端为零的行，应该可以成功读取该行。 </li></ul><br> 我在源代码中进行了一些混编，为重现该问题制定了一个特定的顺序： <br><br><ul><li> 以批处理模式（ <i>fs_cli.exe -b</i> ）运行<i>fs_cli.exe</i> 。 我注意到要执行其他步骤，必须成功将<i>fs_cli.exe</i>连接到服务器。 为此，例如，以管理员<i>身份在本地</i>运行<i>FreeSwitchConsole.exe</i>就足够了。 </li><li> 我们执行输入，以便<i>getchar（）</i>调用返回负值。 </li><li> 输入开头为零的行（例如，“ \ 0Oooops”）。 </li><li>  .... </li><li> 赢利！ </li></ul><br> 以下是该问题的视频播放： <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jSYJirPIK8E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  ftp </h2><br> 在NcFTP项目中发现了类似的问题，但已经在两个地方遇到了。 由于代码看起来相似，所以只考虑一个有问题的地方： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NcFTPConfirmResumeDownloadProc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fgets(newname, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(newname) - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) newname[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; newname[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(newname) - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... }</code> </pre> <br>  <b>PVS-Studio警告</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V1010</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-20</a>索引：“ strlen（newname）”中使用了未经检查的污染数据。 <br><br> 在这里，与FreeSWITCH的示例不同，代码编写得更糟，更容易出现问题。 例如，无论使用<i>fgets</i>是否成功读取，都会写入'\ 0'。 也就是说，还有更多的可能性可以打破常规的执行逻辑。 让我们以行之有效的方式进行-通过零长度的行。 <br><br> 重现的问题比FreeSWITCH复杂。 步骤的顺序如下所述： <br><br><ul><li> 启动并连接到可以从中下载文件的服务器。 例如，我使用了<i>speedtest.tele2.net</i> （最后，应用程序启动命令如下所示： <i>ncftp.exe <a href="">speedtest.tele2.net</a></i> ）； </li><li> 从服务器下载文件。 在本地，具有相同名称但具有不同属性的文件应该已经存在。 例如，您可以从服务器下载文件，进行更改，然后尝试再次执行下载命令（例如， <i>获取512KB.zip</i> ）； </li><li> 回答有关选择以'N'开头的一行的动作的问题（例如， <i>现在让我们玩得开心</i> ）； </li><li> 输入“ \ 0”（或更有趣的东西）； </li><li>  .... </li><li> 赢利！ </li></ul><br> 问题的重现也记录在视频中： <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8DBQjvPQ7tk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Openldap </h2><br> 在OpenLDAP项目中（更确切地说，在其中一个附带的实用程序中），他们踩着与FreeSWITCH中相同的耙子。 仅当成功读取行后，才尝试删除换行符，但也没有针对零长度行的保护措施。 <br><br> 程式码片段： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[ <span class="hljs-number"><span class="hljs-number">4096</span></span> ]; FILE *fp = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { fp = <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( fp == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((rc == <span class="hljs-number"><span class="hljs-number">0</span></span> || contoper) &amp;&amp; fgets(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf), fp) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { buf[ <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>( buf ) - <span class="hljs-number"><span class="hljs-number">1</span></span> ] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* remove trailing newline */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( *buf != <span class="hljs-string"><span class="hljs-string">'\0'</span></span> ) { rc = dodelete( ld, buf ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( rc != <span class="hljs-number"><span class="hljs-number">0</span></span> ) retval = rc; } } } .... }</code> </pre> <br>  <b>PVS-Studio警告</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V1010</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-20</a>索引：“ strlen（buf）”中使用了未经检查的污染数据。 <br><br> 我们排除了多余的部分，以便使问题的本质更加明显： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (.... &amp;&amp; fgets(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf), fp) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { buf[ <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>( buf ) - <span class="hljs-number"><span class="hljs-number">1</span></span> ] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... }</code> </pre> <br> 此代码比NcFTP更好，但仍然容易受到攻击。 如果根据请求<i>fget</i>将零长度的字符串传递给输入： <br><br><ul><li>  <i>fgets（buf，....）</i> -&gt; <i>buf</i> ; </li><li>  <i>fgets（....）！= NULL-</i> &gt; <i>true</i> （ <i>while循环</i>的主体开始执行）； </li><li>  <i>strlen（buf）-1-</i> &gt; <i>0-1-</i> &gt; <i>-1</i> ; </li><li>  <i>buf [-1] ='\ 0'</i> 。 </li></ul><br><h2> 利比登 </h2><br> 尽管上面讨论的错误非常有趣（它们已被稳定地重现并且可以被“触摸”（除了我无法解决OpenLDAP问题），但不能将其称为漏洞，仅是因为问题未分配CVE标识符。 <br><br> 但是，某些实际漏洞具有相同的问题模式。 以下两个代码段均适用于libidn项目。 <br><br> 程式码片段： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fgets (readbuf, BUFSIZ, <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (feof (<span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; error (EXIT_FAILURE, errno, _(<span class="hljs-string"><span class="hljs-string">"input error"</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readbuf[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (readbuf) - <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) readbuf[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (readbuf) - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... }</code> </pre> <br>  <b>PVS-Studio警告</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V1010</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-20</a>索引“ strlen（readbuf）”中使用了未经检查的污染数据。 <br><br> 情况类似，不同之处在于，与先前的示例不同，在此处以索引<i>-1</i>进行记录，然后在此处进行读取。 但是，这仍然是未定义的行为。 已<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为该</a>错误<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分配</a>了自己的CVE标识符（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CVE-2015-8948</a> ）。 <br><br> 检测到问题后，此代码如下更改： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getline (&amp;line, &amp;linelen, <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (feof (<span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; error (EXIT_FAILURE, errno, _(<span class="hljs-string"><span class="hljs-string">"input error"</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (line[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (line) - <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) line[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (line) - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... }</code> </pre> <br> 有点惊讶？ 它发生了。 新漏洞，对应的CVE标识符： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CVE-2016-6262</a> 。 <br><br>  <b>PVS-Studio警告</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V1010</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-20</a>索引：“ strlen（line）”中使用了未经检查的污染数据。 <br><br> 再次尝试，通过添加对输入字符串长度的检查来解决此问题： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (line) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (line[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (line) - <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) line[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (line) - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>;</code> </pre> <br> 让我们看一下日期。 提交``关闭''CVE-2015-8948-08/10/2015。 提交关闭CVE-2016-62-62-2016年1月14日。 也就是说，上述更正之间的差值为<i>5个月</i> ！ 在这里，您回想起了静态分析的优势，例如在编写代码的早期阶段检测错误... <br><br><h2> 静态分析与安全 </h2><br> 不会再有其他代码示例；而是统计信息和推理。 在本节中，作者的观点可能与读者的观点不比本文以前的相符得多。 <br><br>  <b>注意事项</b> 我建议您阅读另一篇有关类似主题的文章-“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio如何帮助发现漏洞？</a> ”。 有一些有趣的漏洞示例，看起来像简单的错误。 此外，在那篇文章中，我谈到了一些术语，以及如果您关心安全性主题，为什么必须进行静态分析。 <br><br> 让我们看一下过去十年来发现的漏洞数量的统计数据，以评估情况。 我从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CVE Details</a>网站获取了数据。 <br><br><p><img src="https://habrastorage.org/webt/lu/au/2i/luau2ik1aoqytidzblkeqjy8vhs.png" alt="图片2"></p><br><br> 一个有趣的情况迫在眉睫。 直到2014年，记录的CVE数量均未超过6,000单位，并且从-开始没有下降。 但是，这里最有趣的当然是2017年的统计数据-绝对领先者（14,714个单位）。 至于当前-2018-年，它尚未结束，但已经打破纪录-15,310单位。 <br><br> 这是否意味着所有新软件都像筛子一样充满漏洞？ 我不认为，这是为什么： <br><br><ul><li> 对漏洞主题的兴趣增加。 当然，即使您不太熟悉安全性主题，您也会反复遇到有关安全性主题的文章，说明，报告和视频。 换句话说，创建了一种“炒作”。 不好吗 可能不是。 最后，归根结底是开发人员更加关注应用程序安全性这一事实，这是件好事。 </li><li> 开发的应用程序数量增加。 更多代码-更有可能发生补充统计数据的漏洞。 </li><li> 改进的漏洞搜索工具和代码质量保证。 更多需求-&gt;更多供应。 分析仪，模糊器和其他工具正在变得越来越先进，这使那些想要寻找漏洞的人（无论他们身处障碍的哪一侧）都可以使用它们。 </li></ul><br> 因此，不能将这种新兴趋势称为完全消极的-出版商更加关注信息安全，发现问题的工具正在改进，而所有这些无疑都是积极的。 <br><br> 这是否意味着您可以放松而不是“沐浴”？ 我认为不是。 如果您担心应用程序的安全性主题，则应采取尽可能多的安全性措施。 如果源代码位于公共领域，则尤其如此，因为： <br><br><ul><li> 更容易嵌入外部漏洞； </li><li> 那些对您的应用程序漏洞感兴趣的“绅士”更倾向于“探索”，以利用它们。 尽管在这种情况下好心人士将能够为您提供更多帮助。 </li></ul><br> 我不想说您不需要在开源下翻译项目。 只要记住适当的质量/安全控制。 <br><br> 静态分析是一种额外的措施吗？ 是的 静态分析在检测将来可能会变成现实的潜在漏洞方面做得很好。 <br><br> 在我看来（我承认我错了），许多人认为漏洞是一种相当高级的现象。 是的，没有。 看起来像简单的编程错误的代码问题也可能是严重的漏洞。 同样，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">前面提到的文章</a>中提供了此类漏洞的一些示例。 不要小看“简单”的错误。 <br><br><h2> 结论 </h2><br> 不要忘记输入数据的长度可以为零，这也需要加以考虑。 <br><br> 关于所有带有漏洞的炒作仅仅是炒作还是存在问题的结论，请自己解决。 <br><br> 就我而言，除非我建议尝试您的项目<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio</a> （如果尚未这样做）。 <br><br> 祝一切顺利！ <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br> 如果您想与讲英语的读者分享这篇文章，请使用以下链接：Sergey Vasiliev。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">处理输入数据时，请放手脚</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433932/">https://habr.com/ru/post/zh-CN433932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433918/index.html">网络为何如此复杂？</a></li>
<li><a href="../zh-CN433920/index.html">中国多晶硅巨头提高产能</a></li>
<li><a href="../zh-CN433922/index.html">Kubernetes Intensive：支持工作</a></li>
<li><a href="../zh-CN433926/index.html">Javascript框架：2019年趋势</a></li>
<li><a href="../zh-CN433930/index.html">自由职业者和客户的单独个人资料</a></li>
<li><a href="../zh-CN433934/index.html">SAFe或规模化敏捷框架</a></li>
<li><a href="../zh-CN433936/index.html">在寻找给孩子的高科技礼物吗？ 想想一个游乐场，而不是一个围栏</a></li>
<li><a href="../zh-CN433938/index.html">Yandex和Google如何总结年度</a></li>
<li><a href="../zh-CN433940/index.html">AppStore中的Review多少钱</a></li>
<li><a href="../zh-CN433944/index.html">毁灭性的例外</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>