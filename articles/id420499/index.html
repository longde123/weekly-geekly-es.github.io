<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👦 💛 🧒 Anatomi sistem rekomendasi. Bagian satu 🔸 🌉 🦂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya bekerja sebagai ilmuwan data di CleverDATA . Kami terlibat dalam proyek pembelajaran mesin, dan salah satu permintaan paling sering untuk pengemb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anatomi sistem rekomendasi. Bagian satu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/420499/"> Saya bekerja sebagai ilmuwan data di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CleverDATA</a> .  Kami terlibat dalam proyek pembelajaran mesin, dan salah satu permintaan paling sering untuk pengembangan solusi pemasaran berbasis pembelajaran mesin adalah pengembangan model rekomendasi. <br><br>  Pada artikel ini, saya akan berbicara tentang sistem rekomendasi, mencoba memberikan gambaran paling lengkap dari pendekatan yang ada, dan menjelaskan dengan jari bagaimana algoritma bekerja.  Beberapa materi didasarkan pada kursus yang baik pada sistem rekomendasi dari laboratorium <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MovieLens</a> (yang kebanyakan orang kenal dengan dataset yang sama untuk rekomendasi pengujian), sisanya berasal dari pengalaman pribadi.  Artikel ini terdiri dari dua bagian.  Yang pertama menjelaskan pernyataan masalah dan memberikan ikhtisar algoritma rekomendasi sederhana (tapi populer).  Pada artikel kedua saya akan berbicara tentang metode yang lebih maju dan beberapa aspek praktis implementasi. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/652/779/d2d/652779d2ded29db0c8412ad892d0df72.jpg"></a> </div>  <a href="">Sumber</a> <br><a name="habracut"></a><br><h3>  <font color="#0057b6">Tinjau dan pernyataan masalah</font> </h3><br>  Tugas dari sistem pemberi rekomendasi adalah untuk memberi tahu pengguna tentang suatu produk yang mungkin paling menarik baginya pada waktu tertentu.  Klien menerima informasi, dan layanan menghasilkan uang dari penyediaan layanan berkualitas.  Layanan belum tentu penjualan langsung dari barang yang ditawarkan.  Layanan ini juga dapat menghasilkan komisi atau hanya meningkatkan loyalitas pengguna, yang kemudian diterjemahkan menjadi iklan dan pendapatan lainnya. <br><br>  Bergantung pada model bisnis, rekomendasi dapat menjadi dasarnya, seperti, misalnya, dengan TripAdvisor, atau sekadar layanan tambahan yang nyaman (seperti, misalnya, di beberapa toko pakaian online), yang dirancang untuk meningkatkan Pengalaman Pelanggan dan membuat navigasi katalog lebih banyak nyaman <br><br>  Personalisasi pemasaran online adalah tren yang jelas dalam dekade terakhir.  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">McKinsey</a> , 35% dari pendapatan Amazon atau 75% dari pendapatan Netflix berasal dari produk yang direkomendasikan, dan persentase ini kemungkinan akan tumbuh.  Sistem rujukan adalah tentang apa yang ditawarkan klien untuk membuatnya bahagia. <br><br>  Untuk mengilustrasikan seluruh variasi layanan rekomendasi, saya akan memberikan daftar karakteristik utama yang dapat digunakan untuk menggambarkan sistem rekomendasi. <br><br><ol><li>  <b>Subjek rekomendasi</b> - apa yang direkomendasikan. <br><br>  Ada banyak variasi di sini - bisa berupa barang (Amazon, Ozon), artikel (Arxiv.org), berita (Surfingbird, Yandex.Zen), gambar (500px), video (YouTube, Netflix), orang (Linkedin, LonelyPlanet), musik (Last.fm, Pandora), daftar putar, dan lainnya.  Secara umum, Anda dapat merekomendasikan apa pun. <br></li><li>  <b>Tujuan dari rekomendasi</b> ini adalah mengapa direkomendasikan. <br><br>  Misalnya: membeli, memberi informasi, melatih, membuat kontak. <br></li><li>  <b>Konteks rekomendasi</b> adalah apa yang sedang dilakukan pengguna saat ini. <br><br>  Misalnya: menonton barang, mendengarkan musik, berbicara dengan orang. <br></li><li>  <b>Sumber rekomendasi</b> adalah siapa yang merekomendasikan: <br><br>  - audiens (nilai rata-rata restoran di TripAdvisor), <br>  - Pengguna yang tertarik <br>  - komunitas ahli (kadang-kadang ketika datang ke produk yang kompleks, seperti, misalnya, anggur). <br></li><li>  <b>Tingkat personalisasi</b> . <br><br>  Rekomendasi non-pribadi - ketika Anda direkomendasikan sama seperti orang lain.  Mereka memungkinkan penargetan berdasarkan wilayah atau waktu, tetapi tidak memperhitungkan preferensi pribadi Anda. <br><br>  Opsi yang lebih maju adalah ketika rekomendasi menggunakan data dari sesi Anda saat ini.  Anda telah melihat beberapa produk, dan di bagian bawah halaman Anda ditawarkan yang serupa. <br><br>  Rekomendasi pribadi menggunakan semua informasi yang tersedia tentang klien, termasuk riwayat pembeliannya. <br></li><li>  <b>Transparansi</b> <br><br>  Orang-orang lebih mempercayai rekomendasi tersebut jika mereka benar-benar mengerti bagaimana itu diterima.  Jadi ada risiko yang lebih kecil untuk masuk ke sistem "tidak bermoral" yang mempromosikan barang-barang berbayar atau menempatkan barang-barang yang lebih mahal lebih tinggi dalam peringkat.  Selain itu, sistem rekomendasi yang baik itu sendiri harus dapat menangani ulasan yang dibeli dan menipu penjualan. <br><br>  Omong-omong, manipulasi juga tidak disengaja.  Misalnya, ketika blockbuster baru dirilis, hal pertama yang dilakukan para penggemar adalah, oleh karena itu, peringkatnya bisa sangat ditaksir terlalu tinggi untuk beberapa bulan pertama. <br></li><li>  <b>Format rekomendasi</b> . <br><br>  Ini bisa berupa jendela sembulan, daftar yang diurutkan muncul di bagian tertentu situs, pita di bagian bawah layar, atau yang lainnya. <br></li><li>  <b>Algoritma</b> <br><br>  Meskipun banyak algoritma yang ada, semuanya bermuara pada beberapa pendekatan dasar, yang akan dijelaskan nanti.  Yang paling klasik adalah algoritma Summary-based (non-personal), Content-based (model berdasarkan deskripsi produk), Collaborative Filtering (kolaboratif filtering), Matrix Factorization (metode berdasarkan dekomposisi matriks) dan beberapa lainnya. <br></li></ol><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d4/db2/906/6d4db2906e4c73fe2dfc75325e55157b.png" width="400"></div>  <a href="">Sumber</a> <br><br>  Di pusat dari setiap sistem rekomendasi adalah apa yang disebut matriks preferensi.  Ini adalah matriks, pada satu sumbu di mana semua klien layanan (Pengguna) disisihkan, dan di sisi lain, objek rekomendasi (Item).  Di persimpangan beberapa pasangan (pengguna, item), matriks ini diisi dengan peringkat (Peringkat) - ini adalah indikator yang diketahui dari minat pengguna terhadap produk ini, dinyatakan pada skala tertentu (misalnya, dari 1 hingga 5). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9a/1cd/f0d/b9a1cdf0d459d5bd938dcd269dc04678.jpg"></div><br>  Pengguna biasanya mengevaluasi hanya sebagian kecil dari produk yang ada di katalog, dan tugas sistem rekomendasi adalah untuk meringkas informasi ini dan memprediksi sikap pelanggan terhadap produk lain yang tidak diketahui apa-apa.  Dengan kata lain, Anda harus mengisi semua sel kosong pada gambar di atas. <br><br>  Pola konsumsi orang berbeda, dan produk baru tidak harus direkomendasikan.  Anda dapat menunjukkan posisi berulang, misalnya, untuk mengisi kembali stok.  Menurut prinsip ini, dua kelompok barang dibedakan. <br><br><ul><li>  <b>Diulang</b>  Misalnya, shampo atau pisau cukur yang selalu dibutuhkan. <br></li><li>  <b>Unik</b>  Misalnya, buku atau film yang jarang didapat kembali. <br></li></ul><br>  Jika produk tidak dapat secara eksplisit ditugaskan ke salah satu kelas, masuk akal untuk menentukan diizinkannya pembelian berulang secara individual (seseorang pergi ke toko hanya demi selai kacang dari merek tertentu, dan bagi seseorang penting untuk mencoba semua yang ada di katalog). <br><br>  Konsep "bunga" juga subyektif.  Beberapa pengguna hanya memerlukan barang-barang dari kategori favorit mereka (rekomendasi konservatif), sementara seseorang, sebaliknya, lebih responsif terhadap produk atau kelompok produk yang tidak standar (rekomendasi berisiko).  Misalnya, hosting video dapat merekomendasikan pengguna hanya episode baru dari seri favoritnya, dan secara berkala dapat melemparkannya ke pertunjukan baru atau bahkan genre baru.  Idealnya, Anda harus memilih strategi untuk menampilkan rekomendasi untuk setiap klien secara terpisah, menggunakan pemodelan kategori klien. <br><br>  Peringkat pengguna dapat diperoleh dengan dua cara: <br><br><ul><li>  peringkat eksplisit - pengguna menempatkan peringkat produk, meninggalkan ulasan, menyukai halaman, <br></li><li>  peringkat tersirat - pengguna tidak secara eksplisit mengungkapkan sikapnya, tetapi kesimpulan tidak langsung dapat diambil dari tindakannya: ia membeli produk - yang berarti dia menyukainya, membaca deskripsi untuk waktu yang lama - itu berarti ada minat, dll. <br></li></ul><br>  Tentu saja, preferensi eksplisit lebih baik - pengguna sendiri mengatakan bahwa dia menyukainya.  Namun, dalam praktiknya, tidak semua situs memberikan kesempatan untuk secara eksplisit menyatakan minat mereka, dan tidak semua pengguna memiliki keinginan untuk melakukannya.  Kedua jenis peringkat ini paling sering digunakan sekaligus dan saling melengkapi dengan baik. <br><br>  Penting juga untuk membedakan antara istilah Prediksi (memprediksi tingkat minat) dan Rekomendasi itu sendiri (menunjukkan rekomendasi).  Apa dan bagaimana menampilkan adalah tugas terpisah yang menggunakan taksiran yang diperoleh pada langkah Prediksi, tetapi dapat diimplementasikan dengan cara yang berbeda. <br><br>  Kadang-kadang istilah "rekomendasi" digunakan dalam arti yang lebih luas dan merujuk pada optimasi apa pun, apakah itu merupakan pilihan klien untuk pengiriman iklan, menentukan harga penawaran yang optimal atau hanya memilih strategi komunikasi terbaik dengan klien.  Dalam artikel itu, saya membatasi diri pada definisi klasik dari istilah ini, menunjukkan pilihan produk yang paling menarik bagi klien. <br><br><h3>  <font color="#0057b6">Rekomendasi yang tidak dipersonalisasi</font> </h3><br>  Mari kita mulai dengan rekomendasi yang tidak dipersonalisasi, karena merupakan yang termudah untuk diterapkan.  Di dalamnya, minat potensial pengguna hanya ditentukan oleh peringkat rata-rata produk: "Semua orang menyukainya, jadi Anda akan menyukainya."  Sebagian besar layanan bekerja berdasarkan prinsip ini ketika pengguna tidak masuk ke sistem, misalnya, TripAdvisor yang sama. <br><br>  Rekomendasi dapat ditampilkan dengan cara yang berbeda - seperti spanduk di sisi deskripsi produk (Amazon), sebagai hasil dari permintaan yang diurutkan berdasarkan parameter tertentu (TripAdvisor), atau yang lainnya. <br><br>  Peringkat produk juga dapat ditampilkan dalam berbagai cara.  Ini mungkin bintang di sebelah produk, jumlah suka, perbedaan antara suara positif dan negatif (seperti biasanya dilakukan di forum), proporsi peringkat tinggi atau bahkan histogram peringkat.  Histogram adalah cara yang paling informatif, tetapi mereka memiliki satu kelemahan - sulit untuk membandingkan satu sama lain atau mengurutkan, ketika Anda perlu membuat daftar produk. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b73/0ea/d52/b730ead5266ac0ad83e4a22aef73e91f.jpg"></div><br><h4>  <font color="#0057b6">Masalah mulai dingin</font> </h4><br>  Cold start adalah situasi yang khas ketika data yang cukup belum diakumulasikan untuk sistem rekomendasi untuk bekerja dengan benar (misalnya, ketika suatu produk baru atau jarang dibeli).  Jika peringkat rata-rata dihitung dengan perkiraan hanya tiga pengguna (igor92, xyz_111 dan oleg_s), penilaian seperti itu jelas tidak akan dapat diandalkan, dan pengguna memahami hal ini.  Seringkali dalam situasi seperti itu, peringkat secara artifisial disesuaikan. <br><br>  Cara pertama adalah untuk menunjukkan bukan nilai rata-rata, tetapi rata-rata dihaluskan (Damped Mean).  Artinya adalah: dengan sejumlah kecil peringkat, peringkat yang ditampilkan lebih cenderung ke beberapa jenis indikator "rata-rata" yang aman, dan segera setelah cukup banyak peringkat baru dikumpulkan, penyesuaian "rata-rata" berhenti bekerja. <br><br>  Pendekatan lain adalah menghitung interval kepercayaan untuk setiap peringkat.  Secara matematis, semakin banyak perkiraan, semakin sedikit variasi rata-rata dan, oleh karena itu, lebih percaya pada kebenarannya.  Dan sebagai peringkat, Anda dapat menampilkan, misalnya, batas bawah interval (Batas CI Rendah).  Pada saat yang sama, jelas bahwa sistem seperti itu akan cukup konservatif, dengan kecenderungan untuk meremehkan peringkat untuk produk-produk baru (kecuali, tentu saja, ini sangat populer). <br><br>  Karena perkiraan terbatas pada skala tertentu (misalnya, dari 0 hingga 1), cara biasa menghitung interval kepercayaan tidak berlaku di sini: karena ekor distribusi yang mencapai tak terbatas dan simetri interval itu sendiri.  Ada cara alternatif dan lebih akurat untuk menghitungnya - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wilson Confidence Interval</a> .  Dalam hal ini, interval asimetris dari jenis ini diperoleh. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/b3/ks/rt/b3ksrtynyspkk3lnfpawslijoou.jpeg"></div><br>  Pada gambar di atas, peringkat horizontal dari peringkat rata-rata diplot, dan vertikal adalah penyebaran di sekitar rata-rata.  Warna menunjukkan ukuran sampel yang berbeda (jelas, semakin besar sampel, semakin kecil interval kepercayaannya). <br><br>  Masalah cold start sama relevan untuk rekomendasi yang tidak dipersonalisasi.  Pendekatan umum di sini adalah untuk mengganti apa yang tidak dapat dihitung saat ini dengan berbagai heuristik (misalnya, ganti dengan nilai rata-rata, gunakan algoritma yang lebih sederhana, atau tidak menggunakan produk sama sekali sampai data dikumpulkan). <br><br><h4>  <font color="#0057b6">Relevansi rekomendasi</font> </h4><br>  Dalam beberapa kasus, penting juga untuk mempertimbangkan “kesegaran” dari rekomendasi.  Ini terutama berlaku untuk artikel atau posting forum.  Entri baru harus sering menekan bagian atas.  Untuk melakukan ini, gunakan faktor redaman.  Di bawah ini adalah beberapa rumus untuk menghitung peringkat artikel di situs media. <br><br>  Contoh perhitungan peringkat di majalah berita Hacker: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/yr/sn/vcyrsnoylizvctaq3ilbafaosbq.jpeg"></div>  di mana U = upvotes, D = downvotes, dan P (Penalty) - penyesuaian tambahan untuk penerapan aturan bisnis lainnya <br><br>  Perhitungan peringkat di Reddit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g-/zj/fg/g-zjfghqsstjvuryzd-b9c92hjk.jpeg"></div>  di mana U = jumlah suara yang mendukung, D = jumlah suara yang menentang, T = waktu perekaman.  Istilah pertama memperkirakan "kualitas rekaman", dan yang kedua membuat koreksi waktu. <br><br>  Jelas, formula universal tidak ada, dan setiap layanan menciptakan formula yang paling baik memecahkan masalahnya - itu diverifikasi secara empiris. <br><br><h3>  <font color="#0057b6">Rekomendasi berbasis konten</font> </h3><br>  Rekomendasi pribadi menyarankan penggunaan maksimum informasi tentang pengguna itu sendiri, terutama tentang pembelian sebelumnya.  Salah satu yang pertama adalah pendekatan penyaringan berbasis konten.  Dalam kerangka pendekatan ini, deskripsi produk (konten) dibandingkan dengan minat pengguna yang diperoleh dari peringkat sebelumnya.  Semakin banyak produk memenuhi minat ini, semakin tinggi minat potensial pengguna dievaluasi.  Persyaratan yang jelas di sini adalah bahwa semua produk dalam katalog harus memiliki deskripsi. <br><br>  Secara historis, subjek rekomendasi berbasis Konten sering kali merupakan barang dengan deskripsi yang tidak terstruktur: film, buku, artikel.  Tanda-tanda tersebut mungkin, misalnya, deskripsi teks, ulasan, pemeran, dan lainnya.  Namun, tidak ada yang mencegah penggunaan tanda numerik atau kategorikal biasa. <br><br>  Fitur tidak terstruktur dijelaskan dengan cara yang khas untuk teks - vektor dalam ruang kata-kata ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model Vector-Space</a> ).  Setiap elemen dari vektor tersebut adalah fitur yang berpotensi mencirikan minat pengguna.  Demikian pula, suatu produk adalah vektor dalam ruang yang sama. <br><br>  Ketika pengguna berinteraksi dengan sistem (katakanlah, ia membeli film), deskripsi vektor barang yang dibeli olehnya digabungkan (diringkas dan dinormalisasi) menjadi vektor tunggal dan, dengan demikian, vektor minatnya terbentuk.  Selanjutnya, cukup untuk menemukan produk yang uraiannya paling dekat dengan vektor minat, yaitu.  memecahkan masalah menemukan dan tetangga terdekat. <br><br>  Tidak semua elemen sama pentingnya: misalnya, kata-kata serumpun, jelas, tidak membawa muatan apa pun.  Oleh karena itu, ketika menentukan jumlah elemen yang cocok dalam dua vektor, semua pengukuran pertama-tama harus ditimbang dengan signifikansinya.  Tugas ini diselesaikan oleh transformasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TF-IDF</a> , yang terkenal di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Text Mining</a> , yang memberikan bobot lebih untuk kepentingan yang lebih jarang.  Kebetulan minat semacam itu lebih penting dalam menentukan kedekatan dua vektor daripada kebetulan populer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ns/yf/-l/nsyf-lljlfb0r7bjrc_l3xonto0.jpeg"></div><br>  Prinsip TF-IDF di sini sama berlaku untuk atribut nominal biasa, seperti, misalnya, genre, sutradara, bahasa.  TF - ukuran pentingnya atribut bagi pengguna, IDF - ukuran "kelangkaan" atribut. <br><br>  Ada seluruh keluarga transformasi serupa (misalnya, BM25 dan yang serupa), tetapi pada dasarnya mereka semua mengulangi logika yang sama dengan TF-IDF: atribut langka harus memiliki bobot lebih ketika membandingkan produk.  Gambar di bawah ini menggambarkan bagaimana berat TF-IDF tergantung pada TF dan IDF.  Sumbu horisontal terdekat adalah DF: frekuensi atribut di antara semua produk, sumbu horizontal jauh adalah TF: logaritma frekuensi atribut pengguna. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/248/b71/1f2/248b711f2b0f9c813c8e88ced69bafbd.png"></div><br>  Beberapa poin yang dapat diperhitungkan selama implementasi. <br><br><ul><li>  Saat membuat presentasi ruang vektor, alih-alih kata-kata individual, Anda dapat menggunakan sirap atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">n-gram</a> (pasangan kata, tripel, dll.).  Ini akan membuat model lebih rinci, tetapi lebih banyak data akan dibutuhkan untuk pelatihan. <br></li><li>  Di tempat yang berbeda dari deskripsi produk, berat kata kunci mungkin berbeda (misalnya, deskripsi film dapat terdiri dari judul, deskripsi singkat dan deskripsi terperinci). <br></li><li>  Deskripsi produk dari pengguna yang berbeda dapat diberi bobot berbeda.  Misalnya, kami dapat memberikan bobot lebih kepada pengguna aktif yang memiliki banyak peringkat. <br></li><li>  Demikian pula, Anda dapat menimbang dan produk.  Semakin tinggi peringkat rata-rata suatu objek, semakin besar bobotnya (mirip dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PageRank</a> ). <br></li><li>  Jika deskripsi produk memungkinkan tautan ke sumber eksternal, maka Anda dapat menjadi bingung dan menganalisis juga semua informasi pihak ketiga yang terkait dengan produk. <br></li></ul><br>  Dapat dilihat bahwa penyaringan berbasis konten hampir sepenuhnya mengulangi mekanisme pencocokan dokumen permintaan yang digunakan dalam mesin pencari seperti Yandex dan Google.  Satu-satunya perbedaan adalah dalam bentuk permintaan pencarian - ini adalah vektor yang menggambarkan minat pengguna, dan ada kata kunci dari dokumen yang diminta.  Ketika mesin pencari mulai menambahkan personalisasi, perbedaannya semakin terhapus. <br><br>  Sebagai ukuran kedekatan dua vektor, jarak cosinus paling sering digunakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a6/136/c9b/0a6136c9bd4144fabc84b53b4e0b6f49.png"></div><br>  Ketika penilaian baru ditambahkan, vektor minat diperbarui secara bertahap (hanya untuk elemen-elemen yang telah berubah).  Saat menghitung ulang, masuk akal untuk memberikan perkiraan baru sedikit lebih berat, karena preferensi dapat bervariasi. <br><br><h3>  <font color="#0057b6">Penyaringan kolaboratif (opsi berbasis pengguna)</font> </h3><br>  Kelas sistem ini mulai aktif berkembang di tahun 90-an.  Sebagai bagian dari pendekatan, rekomendasi dihasilkan berdasarkan minat pengguna lain yang sejenis.  Rekomendasi tersebut adalah hasil dari "kolaborasi" banyak pengguna.  Oleh karena itu nama metode. <br><br>  Implementasi klasik dari algoritma ini didasarkan pada prinsip k tetangga terdekat.  Dengan jari - untuk setiap pengguna, kami mencari k yang paling mirip dengannya (dalam hal preferensi) dan melengkapi informasi tentang pengguna dengan data yang diketahui tentang tetangganya.  Jadi, misalnya, jika diketahui bahwa tetangga Anda yang berminat senang dengan film "Darah dan Beton," dan Anda belum menontonnya karena alasan tertentu, ini adalah kesempatan yang bagus untuk menawarkan film ini kepada Anda untuk ditonton pada hari Sabtu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/al/it/fv/alitfv0yszejlvhji0agoy01amg.jpeg"></div><br>  Gambar di atas menggambarkan prinsip metode ini.  Dalam matriks preferensi, pengguna disorot dengan warna kuning yang ingin kami tentukan peringkat untuk produk baru (tanda tanya).  Tiga tetangga terdekatnya disorot dengan warna biru. <br><br>  "Persamaan" dalam hal ini adalah sinonim untuk "korelasi" kepentingan dan dapat dipertimbangkan dalam banyak hal (selain korelasi Pearson, ada juga jarak kosinus, ada jarak Jacquard, jarak Hamming, dll.). <br><br>  Implementasi klasik dari algoritma memiliki satu minus yang jelas - itu buruk dalam penerapannya karena kompleksitas kuadratik.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memang, seperti metode tetangga terdekat, ia membutuhkan perhitungan semua jarak berpasangan antara pengguna (dan mungkin ada jutaan pengguna). </font><font style="vertical-align: inherit;">Mudah untuk menghitung bahwa kompleksitas menghitung matriks jarak akan menjadi</font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>m</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.072ex" height="2.901ex" viewBox="0 -935.7 3475.4 1249" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/lanit/blog/420499/&amp;usg=ALkJrhjzRoAi4-9ObMi049nVyKKyZRFgwA#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/lanit/blog/420499/&amp;usg=ALkJrhjzRoAi4-9ObMi049nVyKKyZRFgwA#MJMAIN-28" x="763" y="0"></use><g transform="translate(1153,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/lanit/blog/420499/&amp;usg=ALkJrhjzRoAi4-9ObMi049nVyKKyZRFgwA#MJMATHI-6E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/lanit/blog/420499/&amp;usg=ALkJrhjzRoAi4-9ObMi049nVyKKyZRFgwA#MJMAIN-32" x="849" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/lanit/blog/420499/&amp;usg=ALkJrhjzRoAi4-9ObMi049nVyKKyZRFgwA#MJMATHI-6D" x="2207" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/lanit/blog/420499/&amp;usg=ALkJrhjzRoAi4-9ObMi049nVyKKyZRFgwA#MJMAIN-29" x="3085" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></mi><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></mo><msup><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></mi><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></mn></msup><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></mi><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></mo></math></span></span><script type="math/tex" id="MathJax-Element-1">O(n^2m)</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana n adalah jumlah pengguna dan m adalah jumlah produk. </font><font style="vertical-align: inherit;">Dengan satu juta pengguna, minimum 4TB diperlukan untuk menyimpan raw distance matrix. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah ini sebagian dapat diselesaikan dengan membeli besi berkinerja tinggi. </font><font style="vertical-align: inherit;">Tetapi jika Anda mendekati dengan bijak, lebih baik untuk memperkenalkan koreksi ke dalam algoritma:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perbarui jarak tidak dengan setiap pembelian, tetapi dengan batch (misalnya, sekali sehari), </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jangan menghitung ulang matriks jarak sepenuhnya, tetapi perbarui secara bertahap, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memilih untuk algoritma iteratif dan perkiraan (mis. ALS). </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agar algoritma menjadi efektif, penting bahwa beberapa asumsi terpenuhi. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selera orang tidak berubah dengan waktu (atau perubahan, tetapi untuk semua orang sama). </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika selera orang bertepatan, maka mereka bertepatan dalam segala hal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya, jika dua klien lebih suka film yang sama, maka mereka juga menyukai buku yang sama. </font><font style="vertical-align: inherit;">Ini sering terjadi ketika produk yang direkomendasikan adalah homogen (misalnya, hanya film). </font><font style="vertical-align: inherit;">Jika tidak demikian, maka beberapa pelanggan mungkin memiliki preferensi makanan yang sama, dan pandangan politik secara langsung berlawanan - di sini algoritme akan kurang efektif.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lingkungan pengguna di ruang preferensi (tetangganya), yang akan kami analisis untuk menghasilkan rekomendasi baru, dapat dipilih dengan berbagai cara. Kita dapat bekerja dengan semua pengguna sistem secara umum, kita dapat menetapkan batas kedekatan tertentu, kita dapat memilih beberapa tetangga secara acak atau mengambil n tetangga yang paling mirip (ini adalah pendekatan yang paling populer). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para penulis MovieLens sebagai jumlah optimal tetangga memberikan angka 30-50 tetangga untuk film dan 25-100 untuk rekomendasi sewenang-wenang. Jelas di sini bahwa jika kita mengambil terlalu banyak tetangga, kita akan mendapatkan lebih banyak peluang dari kebisingan acak. Dan sebaliknya, jika kita mengambil terlalu sedikit, kita akan mendapatkan rekomendasi yang lebih akurat, tetapi lebih sedikit produk yang direkomendasikan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tahap penting dalam persiapan data adalah normalisasi estimasi.</font></font><br><br><h3> <font color="#0057b6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardisasi Data (penskalaan)</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena semua pengguna mengevaluasi secara berbeda - seseorang menempatkan lima berturut-turut, dan Anda jarang mengharapkan empat dari seseorang - lebih baik untuk menormalkan data sebelum menghitung, mis. </font><font style="vertical-align: inherit;">mengarah ke skala tunggal sehingga algoritma dapat dengan benar membandingkannya satu sama lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara alami, estimasi yang diprediksi akan perlu diterjemahkan ke dalam skala asli dengan transformasi terbalik (dan, jika perlu, bulat ke bilangan bulat terdekat). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada beberapa cara untuk menormalkan:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">centering (mean-centering) - dari peringkat pengguna kami cukup mengurangi peringkat rata-rata, </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* hanya relevan untuk matriks non-biner</font></font></i> <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">standardisasi (skor-z) - selain pemusatan, kami membagi peringkatnya dengan standar deviasi pengguna, </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* di sini, setelah konversi balik, peringkat dapat melampaui skala (mis., misalnya, 6 pada skala lima poin), tetapi situasi seperti itu cukup langka dan mereka diselesaikan hanya dengan membulatkan ke perkiraan terdekat yang dapat diterima.</font></font></i> <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">standardisasi ganda - pertama kali kami menormalkan peringkat pengguna, kedua kalinya - peringkat produk. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika film "The Best Movie" memiliki peringkat rata-rata 2.5, dan pengguna memberikannya 5, maka ini adalah faktor kuat yang menunjukkan bahwa film tersebut jelas sesuai dengan seleranya.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Kesamaan" atau korelasi preferensi dua pengguna dapat dipertimbangkan dengan cara yang berbeda. </font><font style="vertical-align: inherit;">Bahkan, kita hanya perlu membandingkan dua vektor. </font><font style="vertical-align: inherit;">Kami daftar beberapa yang paling populer.</font></font><br><br><ol><li>   —  ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/110/e8c/698/110e8c698e7cf685c3bc2041afb25cec.png"></div><br>    —     ,      . <br><br>           50 / min(50, Rating intersection)    damping factor,       . <br></li><li>   <br><br>   —  , ..      ,     .         . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fdd/59e/325/fdd59e32550c21f7007bd4242a9a7b29.png"></div></li><li>   <br><br>    .  ,      —     ,     . <br><br><img src="https://habrastorage.org/webt/jo/s3/vn/jos3vnkilzsvrkevdfsm8xl22gq.png"><br><br>   —  ,     (..    ),       .  ,       . <br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perkembangan yang menarik dari pendekatan kolaboratif adalah apa yang disebut rekomendasi berbasis Kepercayaan, yang memperhitungkan tidak hanya kedekatan orang sesuai dengan minat mereka, tetapi juga kedekatan "sosial" mereka dan tingkat kepercayaan di antara mereka. </font><font style="vertical-align: inherit;">Jika misalnya kita melihat bahwa di Facebook gadis secara berkala mengunjungi halaman dengan rekaman audio temannya, maka dia mempercayai selera musiknya. </font><font style="vertical-align: inherit;">Oleh karena itu, rekomendasi kepada gadis itu dapat sepenuhnya mencampur lagu-lagu baru dari daftar putar teman.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63b/62c/55e/63b62c55e1f68e966d6b4928617cc406.jpg"></div><br><h3> <font color="#0057b6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Justifikasi rekomendasi</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adalah penting bahwa pengguna mempercayai sistem rekomendasi, dan untuk ini harus sederhana dan dapat dimengerti. </font><font style="vertical-align: inherit;">Jika perlu, penjelasan rekomendasi yang dapat dipahami harus selalu tersedia (dalam penjelasan terminologi bahasa Inggris). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai bagian dari penjelasan, menyenangkan untuk menunjukkan penilaian produk tetangga, sesuai dengan atribut mana (misalnya, aktor atau sutradara), ada kebetulan, serta menampilkan kepercayaan sistem dalam penilaian (kepercayaan). </font><font style="vertical-align: inherit;">Agar tidak membebani antarmuka, Anda dapat memasukkan semua informasi ini ke tombol "Tell me more".</font></font><br><br>  Sebagai contoh: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Kamu mungkin suka filmnya ... karena diputar di sana ... dan ..." </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Pengguna dengan selera musik yang serupa menilai album ... 4.5 dari 5." </font></font></li></ul><br><h3>  <font color="#0057b6">Ringkasan</font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini akan mengakhiri bagian pertama artikel. </font><font style="vertical-align: inherit;">Kami memeriksa pernyataan umum masalah, berbicara tentang rekomendasi non-pribadi, menggambarkan dua pendekatan klasik (berbasis konten dan penyaringan kolaboratif), dan juga menyentuh pada topik rekomendasi yang menguatkan. </font><font style="vertical-align: inherit;">Secara umum, kedua pendekatan ini cukup memadai untuk membangun sistem rekomendasi siap-produksi. </font><font style="vertical-align: inherit;">Pada bagian selanjutnya, saya akan melanjutkan tinjauan dan berbicara tentang metode yang lebih modern, termasuk yang melibatkan jaringan saraf dan pembelajaran yang mendalam, serta tentang model hybrid.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sementara itu, lihat lowongan kami.</font></font></b> <div class="spoiler_text"><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontend-</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> Java (Big Data)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  Linux</a> </li></ul></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420499/">https://habr.com/ru/post/id420499/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420489/index.html">Prosesor ARM baru dapat bersaing dengan Core i5</a></li>
<li><a href="../id420491/index.html">Caraku seorang pejuang, atau bagaimana aku menyiapkan aplikasi untuk hidup di Sailfish</a></li>
<li><a href="../id420493/index.html">Bisakah layanan pemesanan makanan Amerika menjadi Amazon di dunia restoran</a></li>
<li><a href="../id420495/index.html">Rendering air layar</a></li>
<li><a href="../id420497/index.html">Singularity Sayuran: Kroger Meluncurkan Robocouriers untuk Pelanggan Buah dan Sayuran di Arizona</a></li>
<li><a href="../id420501/index.html">Linux dalam RAM: cara debirf 2018</a></li>
<li><a href="../id420503/index.html">Hari Pengembang JS, berbagai kota dan komunitas - satu hari libur</a></li>
<li><a href="../id420505/index.html">Akankah OpenAI Five memenangkan tim profesional di The International</a></li>
<li><a href="../id420507/index.html">Latar Belakang: Internet global untuk semua dan penciptanya</a></li>
<li><a href="../id420509/index.html">Masalah yang jelas dengan menggunakan menegaskan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>