<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👦 👩‍👩‍👧‍👧 🍑 Porting OS ke Aarch64 ☯️ 🕺🏽 🍵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aarch64 adalah arsitektur 64-bit dari ARM (kadang-kadang disebut arm64). Pada artikel ini saya akan memberi tahu Anda perbedaannya dari ARM "reguler" ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Porting OS ke Aarch64</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/463417/"><p><img src="https://habrastorage.org/webt/91/sk/1l/91sk1l1eqxkwlaa5ndnvwv5rcwk.png" align="right" width="320">  Aarch64 adalah arsitektur 64-bit dari ARM (kadang-kadang disebut arm64).  Pada artikel ini saya akan memberi tahu Anda perbedaannya dari ARM "reguler" (32-bit) dan betapa sulitnya untuk mem-port sistem Anda ke sana. </p><br><p>  Artikel ini bukan panduan terperinci, melainkan gambaran umum modul-modul sistem yang harus diulang, dan seberapa besar arsitektur secara keseluruhan berbeda dari ARM 32-bit biasa;  semua ini dari pengalaman pribadi saya porting <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Embox</a> ke arsitektur ini.  Untuk porting langsung dari sistem tertentu, dengan satu atau lain cara Anda harus berurusan dengan dokumentasi, di akhir artikel saya meninggalkan tautan ke beberapa dokumen yang mungkin berguna. </p><a name="habracut"></a><br><p>  Bahkan, ada lebih banyak perbedaan daripada kesamaan, dan Aarch64 lebih merupakan arsitektur baru daripada ekstensi 64-bit dari ARM yang sudah dikenal.  Pendahulu Aarch64 sebagian besar adalah Aarch32 (ini merupakan perpanjangan dari ARM 32-bit yang biasa), tetapi karena saya tidak memiliki pengalaman dengannya, saya tidak akan menulis tentang itu :) </p><br><p>  Lebih lanjut dalam artikel ini, jika saya menulis tentang ARM "lama" atau "tua", maksud saya ARM 32-bit (dengan seperangkat perintah ARM). </p><br><p>  Secara singkat saya akan membahas daftar perubahan dibandingkan dengan ARM 32-bit, dan kemudian saya akan menganalisisnya secara lebih rinci. </p><br><ul><li>  Register untuk keperluan umum menjadi 2 kali lebih luas (sekarang masing-masing 64 bit), dan jumlahnya bertambah dua kali lipat (yaitu, sekarang tidak ada 16, tetapi 32). </li><li> Penolakan konsep register coprocessor, sekarang mereka dapat diakses hanya dengan nama, misalnya <code>msr vbar_el1, x0</code> (terhadap <code>mcr p15, 0, %0, c1, c1, 2</code> sebelumnya <code>mcr p15, 0, %0, c1, c1, 2</code> ) </li><li>  Model MMU baru (tidak terhubung dengan yang lama dengan cara apa pun, Anda harus menulis lagi). </li><li>  Sebelumnya, ada dua level privilege: pengguna (sesuai dengan mode prosesor USR) dan sistem (terkait dengan SYS, IRQ, FIQ, ABT, ...) mode, sekarang semuanya lebih mudah dan lebih rumit pada saat yang sama - sekarang ada 4 mode. </li><li>  AdvSIMD menggantikan NEON, operasi floating-point dilakukan melaluinya. </li></ul><br><p>  Sekarang lebih lanjut tentang poin. </p><br><h2 id="registry-i-nabor-komand">  Register dan set instruksi </h2><br><p>  Register tujuan umum adalah r0-r30, sementara Anda dapat mengaksesnya sebagai 64-bit (x0-x30) atau 32-bit (w0-w30, akses ke 32 bit yang lebih rendah). </p><br><p>  Set instruksi untuk Aarch64 disebut A64.  Baca deskripsi instruksi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Aritmatika dasar dan beberapa perintah lain dalam bahasa assembly tetap sama: </p><br><pre> <code class="plaintext hljs"> mov w0, w1 /*    w1  w0 */ add x0, x1, 13 /*   x0  x1   13 */ b label /* ""   "label" bl label /* ""   "label",     x30 */ ldr x3, [x1, 0] /*   x3 ,    x1 */ str x3, [x0, 0] /*   x3  ,    x0 */</code> </pre> <br><p>  Sekarang sedikit tentang perbedaannya: </p><br><ul><li>  Daftar "nol" khusus <code>rzr/xzr/wzr</code> , yaitu nol saat membaca (Anda dapat menggunakan tulis ke register, tetapi hasil perhitungan tidak akan ditulis di mana pun). </li></ul><br><pre> <code class="plaintext hljs">subs xzr, x1, x2 /*  x1  x2    NZCV,       */</code> </pre> <br><ul><li>  Anda tidak dapat menumpuk banyak register ( <code>stmfd sp!, {r0-r3}</code> ) ke dalam tumpukan sekaligus, Anda harus melakukan ini secara berpasangan: </li></ul><br><pre> <code class="plaintext hljs"> stp x0, x1, [sp, 16]! stp x2, x3, [sp, 16]!</code> </pre> <br><ul><li><p>  Register PC (Program counter, sebuah pointer ke instruksi pelaksanaan saat ini) sekarang bukan register umum (dulu R15), oleh karena itu, itu tidak dapat diakses dengan perintah biasa ( <code>mov</code> , <code>ldr</code> ), hanya melalui <code>ret</code> , <code>bl</code> dan sebagainya. </p><br></li><li><p>  Status program sekarang tidak menampilkan CPSR (register ini tidak ada), tetapi register DAIF (berisi IRQ, mask FIQ, dll., AIF - bit A yang sama, I, F dari CPSR), NZCV (bit negatif, nol, membawa , oVerflow - tiba-tiba, NZCV yang sama dari CPSR) dan System Control Register (SCTLR, untuk mengaktifkan caching, MMU, endianness, dan sebagainya). </p><br></li></ul><br><p>  Tampaknya perintah-perintah ini cukup untuk menulis bootloader sederhana yang dapat mentransfer kontrol ke kode platform-independen :) </p><br><h2 id="rezhimy-ispolneniya-i-pereklyuchenie-mezhdu-nimi">  Mode kinerja dan beralih di antara mereka </h2><br><p>  Mode kinerja ditulis dengan baik dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fundamentals of ARMv8-A</a> , saya akan menceritakan secara singkat esensi dokumen ini di sini. </p><br><p>  Aarch64 memiliki 4 level privilege (Level eksekusi, selanjutnya disingkat EL). </p><br><ul><li>  EL3 - Secure Monitor (diasumsikan bahwa firmware berjalan pada level ini) </li><li>  EL2 - Hypervisor </li><li>  EL1 - OS </li><li>  EL0 - Aplikasi </li></ul><br><p>  Pada OS 64-bit, Anda dapat menjalankan aplikasi 32-bit dan 64-bit;  pada OS 32-bit, hanya aplikasi 32-bit yang dapat dijalankan. </p><br><img src="https://habrastorage.org/webt/pa/uw/hd/pauwhdk-xp3y_ixyfuu2yawmeno.png"><br><p>  Transisi antar EL dilakukan dengan pengecualian (panggilan sistem, interupsi, kesalahan akses memori), atau dengan menggunakan perintah return from exception ( <code>eret</code> ). </p><br><p>  Setiap EL memiliki register sendiri SPSR, ELR, SP (yaitu "register banked"). </p><br><p>  Banyak register sistem juga dibagi dengan EL - misalnya, register konteks MMU <code>ttbr0</code> - ada <code>ttbr0_el2</code> , <code>ttbr0_el1</code> , dan Anda perlu mengakses register Anda pada EL yang sesuai.  Hal yang sama berlaku untuk register status program - DAIF, NZCV, SCTLR, SPSR, ELR ... </p><br><h2 id="mmu">  MMU </h2><br><p>  Armv8-A mendukung MMU ARMv8.2 LPA, lebih lanjut tentang ini dapat ditemukan di bab D5 dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Manual Referensi Arsitektur ARM untuk Armv8, Armv8-A</a> . </p><br><p>  Singkatnya, MMU ini mendukung halaman 4KiB (4 level tabel memori virtual), 16KiB (4 level) dan 64KiB (3 level).  Pada tingkat menengah mana pun, Anda dapat menentukan blok memori, dengan demikian tidak menunjukkan tingkat berikutnya dari tabel, tetapi keseluruhan memori dengan ukuran yang harus "ditutupi" oleh tabel tingkat berikutnya.  Saya memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel lama</a> tentang memori virtual, di mana Anda dapat membaca tentang tabel, level terjemahan, dan itu saja. </p><br><p>  Dari perubahan kecil, mereka menolak domain, tetapi menambahkan bendera seperti sedikit kotor. </p><br><p>  Secara umum, kecuali untuk "blok" alih-alih tabel terjemahan perantara, tidak ada perubahan konseptual khusus yang terlihat, MMU sebagai MMU. </p><br><h2 id="advanced-simd">  SIMD lanjutan </h2><br><p>  Ada perbedaan AdvSIMD yang signifikan dalam NEON lama, baik ketika bekerja dengan floating point dan dengan operasi vektor (SIMD).  Misalnya, jika sebelumnya D0 terdiri dari S0 dan S1, dan Q0 - dari D0 dan D1, maka sekarang tidak demikian: Q0 sesuai dengan D0 dan S0, untuk Q1 - D1 dan S0, dan seterusnya.  Pada saat yang sama, dukungan untuk VFP / SIMD adalah wajib, dengan menelepon perjanjian sekarang tidak ada transfer parameter terprogram (apa yang dulu disebut "soft float ABI", di GCC - flag <code>-mfloat-abi=softfp</code> ), jadi Anda harus mengimplementasikan dukungan perangkat keras untuk floating point . </p><br><p>  Ada 16 register 128 bit: </p><br><img src="https://habrastorage.org/webt/la/hg/y5/lahgy5x8kbmbnrh1xyuzirvoujo.png"><br><p>  Ada 32 register masing-masing 128 bit: </p><br><img src="https://habrastorage.org/webt/xy/ls/dp/xylsdp-1iwyse4ezlhp9prfsy14.png"><br><p>  Anda dapat membaca lebih lanjut tentang NEON di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> , daftar perintah yang tersedia untuk Aarch64 dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Operasi dasar dengan register floating point: </p><br><pre> <code class="plaintext hljs"> fadd s0, s1, s2 /* s0 = s1 + s2 */ fmul d0, d1, d2 /* d0 = d1 * d2 */</code> </pre> <br><p>  Operasi SIMD dasar: </p><br><pre> <code class="plaintext hljs"> /*  , : NEON,    */ /* q0 = q1 + q2,   --   4     */ vadd.s32 q0, q1, q2 /* : AdvSIMD,    */ /* v0 = v1 + v2,   --   4     */ add v0.4s, v1.4s, v2.4s /*   v1 (  2 64- )    d1 */ addv d1, v1.ds /*     4   0 */ movi v1.4s, 0x0</code> </pre> <br><h2 id="platformy">  Platform </h2><br><h3 id="qemu">  QEMU </h3><br><p>  QEMU memiliki dukungan untuk Aarch64.  Salah satu platformnya adalah <code>virt</code> , sehingga dimulai dalam mode 64-bit, Anda juga harus melewati <code>-cpu cortex-a53</code> , seperti ini: </p><br><pre> <code class="plaintext hljs">qemu-system-aarch64 -M virt -cpu cortex-a53 -kernel ./embox -m 1024 -nographic # ./embox -- ELF- </code> </pre> <br><p>  Apa yang bagus, banyak periferal yang digunakan untuk platform ini, driver yang sudah ada di Embox - misalnya, PL011 untuk konsol, ARM Generic Interrupt Controller, dll. Tentu saja, perangkat ini memiliki alamat register pangkalan yang berbeda dan angka interupsi lainnya, tetapi yang utama adalah kode driver berfungsi tidak berubah pada arsitektur baru.  Ketika sistem dimulai, kontrolnya ada di EL1. </p><br><h3 id="imx8">  i.MX8 </h3><br><p>  Karena sepotong besi ini, porting ke Aarch64 - i.MX8MQ Nitrogen8M dimulai. </p><br><img src="https://habrastorage.org/webt/gr/1j/-s/gr1j-sdvpb7cc4y0kkmkbkqwbu8.jpeg"><br><p>  Tidak seperti QEMU, u-boot mentransfer kontrol ke gambar dalam EL2, dan, lebih lagi, untuk beberapa alasan itu termasuk MMU (semua memori dipetakan 1 ke 1), yang menciptakan beberapa masalah tambahan selama inisialisasi. </p><br><p>  Embox sudah mendukung i.MX6, dan, yah, di i.MX8 bagian dari periferal adalah sama - misalnya, UART dan Ethernet, yang juga berfungsi (saya harus memperbaiki beberapa tempat di mana ada ikatan yang erat dengan alamat 32-bit).  Di sisi lain, pengontrol interupsi berbeda di sana - ARM GICv3, yang sangat berbeda dari versi pertama. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Saat ini, dukungan untuk Aarch64 di Embox tidak lengkap, tetapi sudah ada fungsi minimal - interupsi, MMU, input-output melalui UART.  Masih banyak yang harus diselesaikan, tetapi langkah-langkah pertama lebih mudah dibuat daripada yang tampak dari awal.  Ada jauh lebih sedikit dokumentasi dan artikel daripada di ARM, tetapi ada lebih dari cukup informasi untuk menangani semuanya. </p><br><p>  Secara umum, jika Anda memiliki pengalaman dengan ARM, porting ke Aarch64 adalah tugas yang layak.  Meskipun, seperti biasa, Anda dapat menemukan beberapa hal kecil :) </p><br><p>  Anda dapat mengunduh proyek untuk menyodoknya di QEMU dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori kami</a> , jika Anda memiliki pertanyaan - tulis di komentar, atau di <a href="">buletin</a> , atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di obrolan di Telegram</a> (ada juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran</a> ). </p><br><h3 id="poleznye-ssylki">  Tautan yang bermanfaat </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">A64 Instruksi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dasar-dasar ARMv8-A</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Manual Referensi Arsitektur ARM untuk Armv8, Armv8-A</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aarch64 ABI (konvensi panggilan)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Migrasi kode dari ARM ke ARM64</a> - presentasi kecil dengan rekomendasi untuk menulis kode portabel </li></ul><br><h3 id="ps">  PS </h3><br><p>  24-25 Agustus, kami akan berbicara di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TechTrain</a> , mendengarkan penampilan kami sekitar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua atau</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiga</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kali</a> , datang ke stand - kami akan menjawab pertanyaan Anda :) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463417/">https://habr.com/ru/post/id463417/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463401/index.html">Naples ke Roma: CPU AMD EPYC Baru</a></li>
<li><a href="../id463403/index.html">Seluruh kebenaran tentang RTOS. Artikel # 31. Diagnostik dan pengecekan kesalahan RTOS</a></li>
<li><a href="../id463405/index.html">Lapisan kedua pengembangan (mobile game), apa, kapan, dan mengapa</a></li>
<li><a href="../id463411/index.html">Jangan bekerja dalam proyek yang buruk</a></li>
<li><a href="../id463415/index.html">Security Week 33: menarik dengan Black Hat / DEF CON 2019</a></li>
<li><a href="../id463419/index.html">Acara digital di Moskow dari 12 hingga 18 Agustus</a></li>
<li><a href="../id463425/index.html">Sistem telepon hybrid</a></li>
<li><a href="../id463427/index.html">Museum Emigrasi Rusia: bagaimana kita meletakkan sensor gerak dalam gramofon dan teknologi yang secara umum ditambahkan</a></li>
<li><a href="../id463431/index.html">Radio musik pintar yang tidak memerlukan koneksi Internet permanen</a></li>
<li><a href="../id463433/index.html">Email Blog: Fitur Gmail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>