<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏾 🎈 🧕🏽 Bagaimana cara geocode sejuta poin pada Spark dengan cara cepat? 🔔 👩‍👦 🤔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam proyek saya sebelumnya, kami dihadapkan dengan tugas melakukan geocoding terbalik untuk banyak pasangan koordinat geografis. Reverse geocoding a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara geocode sejuta poin pada Spark dengan cara cepat?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438046/">  Dalam proyek saya sebelumnya, kami dihadapkan dengan tugas melakukan geocoding <b>terbalik</b> untuk banyak pasangan koordinat geografis.  Reverse geocoding adalah prosedur yang cocok dengan pasangan garis lintang-bujur dengan alamat atau nama objek pada peta yang titik atau koordinatnya milik atau tutup.  Yaitu, kita ambil koordinatnya, katakan ini: @ 55.7602485,37.6170409, dan kita mendapatkan hasilnya baik "Rusia, Distrik Federal Pusat, Moskow, Teater Square, rumah begini", atau misalnya, "Teater Bolshoi". <br><br>  Jika alamat atau nama ada di input, dan koordinat ada di output, maka operasi ini adalah <b>geocoding langsung</b> , kami berharap untuk membicarakannya nanti. <br><br>  Sebagai input, kami memiliki sekitar 100 atau 200 ribu poin pada input yang terletak di cluster Hadoop sebagai tabel Hive.  Ini untuk memperjelas skala tugas. <br><br>  Spark akhirnya dipilih sebagai alat pemrosesan, meskipun dalam prosesnya kami mencoba MapReduce dan Apache Crunch.  Tetapi ini adalah cerita yang terpisah, mungkin layak untuk posnya. <br><a name="habracut"></a><br><h2>  Solusi mudah dengan cara yang terjangkau </h2><br>  Untuk memulainya, kami mencoba untuk mendekati masalah, sehingga untuk berbicara.  Sebagai alat, ada server ArcGIS yang menyediakan layanan REST geocoding terbalik.  Menggunakannya cukup sederhana, untuk ini kami melakukan permintaan http GET dengan URL berikut: <br><br><pre><code class="plaintext hljs">http://-url/GeocodeServer/reverseGeocode?&lt;&gt;</code> </pre> <br>  Dari banyak parameter, itu cukup untuk mengatur lokasi = x, y (yang utama adalah tidak membingungkan yang mana dari mereka adalah garis lintang dan mana yang garis bujur;).  Dan sekarang kita sudah memiliki JSON dengan hasil: negara, wilayah, kota, jalan, nomor rumah.  Contoh dari dokumentasi: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"address"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Match_addr"</span></span>: <span class="hljs-string"><span class="hljs-string">"Beeman's Redlands Pharmacy"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"LongLabel"</span></span>: <span class="hljs-string"><span class="hljs-string">"Beeman's Redlands Pharmacy, 255 Terracina Blvd, Redlands, CA, 92373, USA"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ShortLabel"</span></span>: <span class="hljs-string"><span class="hljs-string">"Beeman's Redlands Pharmacy"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Addr_type"</span></span>: <span class="hljs-string"><span class="hljs-string">"POI"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"Pharmacy"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"PlaceName"</span></span>: <span class="hljs-string"><span class="hljs-string">"Beeman's Redlands Pharmacy"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"AddNum"</span></span>: <span class="hljs-string"><span class="hljs-string">"255"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Address"</span></span>: <span class="hljs-string"><span class="hljs-string">"255 Terracina Blvd"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Block"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Sector"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Neighborhood"</span></span>: <span class="hljs-string"><span class="hljs-string">"South Redlands"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"District"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"City"</span></span>: <span class="hljs-string"><span class="hljs-string">"Redlands"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"MetroArea"</span></span>: <span class="hljs-string"><span class="hljs-string">"Inland Empire"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Subregion"</span></span>: <span class="hljs-string"><span class="hljs-string">"San Bernardino County"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Region"</span></span>: <span class="hljs-string"><span class="hljs-string">"California"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Territory"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Postal"</span></span>: <span class="hljs-string"><span class="hljs-string">"92373"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"PostalExt"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"CountryCode"</span></span>: <span class="hljs-string"><span class="hljs-string">"USA"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"location"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-number"><span class="hljs-number">-117.20558993392585</span></span>, <span class="hljs-attr"><span class="hljs-attr">"y"</span></span>: <span class="hljs-number"><span class="hljs-number">34.037880040538894</span></span>, <span class="hljs-attr"><span class="hljs-attr">"spatialReference"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"wkid"</span></span>: <span class="hljs-number"><span class="hljs-number">4326</span></span>, <span class="hljs-attr"><span class="hljs-attr">"latestWkid"</span></span>: <span class="hljs-number"><span class="hljs-number">4326</span></span> } } }</code> </pre><br>  Anda juga dapat menunjukkan jenis jawaban apa yang kami inginkan - alamat pos, atau mengatakan POI (tempat tujuan, ini untuk mendapatkan jawaban seperti "Teater Bolshoi"), atau apakah kita memerlukan persimpangan jalan, misalnya.  Anda juga dapat menentukan radius di mana objek bernama akan dicari dari titik yang ditentukan. <br><br>  Untuk memeriksa kualitas respons dengan cepat, Anda dapat memperkirakan jarak antara titik awal dalam parameter permintaan dan lokasi titik yang diterima dalam respons layanan. <br><br>  Tampaknya sekarang semuanya akan baik-baik saja.  Tapi itu dia.  Contoh ArcGIS kami sangat lambat, server dialokasikan 4 core, dan sekitar 8 gigabytes RAM.  Sebagai hasilnya, tugas pada cluster dapat membaca 200 ribu poin kami dengan sangat cepat, tetapi bertumpu pada kinerja REST dan ArcGIS.  Dan geocoding semua poin butuh berjam-jam.  Pada saat yang sama, kami mengalokasikan hanya sekitar 8 core pada Hadoop, dan sedikit memori, tetapi karena memuat server ArcGIS hampir mencapai 100% selama berjam-jam, sumber daya tambahan di cluster tidak memberi kami apa pun. <br><br>  ArcGIS tidak tahu bagaimana melakukan operasi geocoding batch terbalik, sehingga permintaan dieksekusi sekali untuk setiap titik.  Dan omong-omong, jika layanan tidak merespons, maka kami jatuh karena batas waktu atau dengan kesalahan, dan apa yang harus dilakukan dengan itu adalah masalah dengan jawaban yang tidak jelas.  Mungkin mencoba lagi, atau menyelesaikan seluruh proses, dan kemudian ulangi untuk poin mentah. <br><br><h2>  Perkiraan kedua, kami memperkenalkan cache </h2><br>  Untuk memulainya, kami menemukan bahwa banyak titik di set kami memiliki koordinat berulang.  Alasannya sederhana - jelas, akurasi GPS tidak cukup baik untuk koordinat titik yang terletak dua meter dari satu sama lain untuk berbeda pada output, atau koordinat yang diperoleh bukan dari GPS, tetapi dari pangkalan lain, cukup dimasukkan ke dalam basis data sumber.  Secara umum, tidak masalah mengapa demikian, yang utama adalah bahwa ini adalah situasi yang sangat khas, sehingga cache hasil yang diterima dari layanan akan memungkinkan Anda untuk melakukan geocode setiap pasangan koordinat hanya sekali.  Dan kita bisa membeli memori untuk cache. <br><br>  Sebenarnya, modifikasi pertama dari algoritma dibuat sepele - semua hasil yang diperoleh dari REST ditambahkan ke cache, dan untuk semua poin, pencarian pertama kali dilakukan untuk koordinat di dalamnya.  Kami bahkan tidak mulai membuat cache umum untuk semua proses percikan - pada setiap node cluster yang dimilikinya. <br><br>  Sedemikian sederhananya, kami dapat memperoleh akselerasi hingga sekitar 10 kali, yang secara kasar sesuai dengan jumlah pengulangan koordinat dalam set aslinya.  Sudah bisa diterima, tetapi masih sangat lambat. <br><br>  Nah, pelanggan kami memberi tahu kami saat ini, jika kami tidak dapat mengetahui alamat dengan lebih cepat, dapatkah kami dengan cepat mengidentifikasi setidaknya sebuah kota?  Dan kami mengambil ... <br><br><h2>  Solusi yang disederhanakan, mengimplementasikan Geomerty API </h2><br>  Apa yang harus kita definisikan sebagai kota?  Kami memiliki geometri wilayah Rusia, divisi administrasi-teritorial, yang kira-kira akurat untuk distrik-distrik kota. <br><br>  Anda dapat mengambil data ini misalnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Ada apa disana  Ini adalah basis data batas administratif Federasi Rusia, untuk level dari 2 (negara) hingga 9 (distrik perkotaan).  Formatnya adalah geojson atau CSV (sedangkan geometri itu sendiri dalam format wkt).  Secara total, database sekitar 20 ribu catatan. <br><br>  Solusi baru yang disederhanakan untuk masalah tampak seperti ini: <br><br><ol><li>  Mengunggah data ADT ke Hive. </li><li>  Untuk setiap titik dengan koordinat, kita lihat di tabel pembagian wilayah untuk poligon tempat titik ini masuk. </li><li>  Urutkan poligon yang ditemukan berdasarkan level. </li></ol><br>  Sebagai hasilnya, kita mendapatkan sesuatu seperti: Rusia, Distrik Federal Pusat, Moskow, distrik administratif ini dan itu, area ini dan itu, yaitu, daftar wilayah di mana titik kami berada. <br><br><h3>  Pemuatan ADT </h3><br>  Untuk mengunduh CSV lebih mudah, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">layang-layang</a> .  Alat ini dapat dengan baik membangun skema untuk Hive berdasarkan header kolom di CSV.  Bahkan, impor turun menjadi tiga perintah (salah satunya diulang untuk setiap file level): <br><br><pre> <code class="plaintext hljs">kite-tools csv-schema admin_level_2.csv --class al --delimiter \; &gt;adminLevel.avrs kite-tools create dataset:hive:/default/levelswkt -s adminLevel.avrs kite-tools csv-import admin_level_2.csv dataset:hive:/default/levelswkt --delimiter \; ... kite-tools csv-import admin_level_10.csv dataset:hive:/default/levelswkt --delimiter \;</code> </pre><br>  Apa yang sudah kita lakukan di sini?  Tim pertama membuatkan skema Avro untuk csv, yang kami tentukan beberapa parameter skema (kelas, dalam hal ini), dan pemisah bidang untuk CSV.  Selanjutnya, ada baiknya melihat diagram yang diperoleh dengan mata Anda, dan dimungkinkan untuk melakukan beberapa perbaikan, karena Kite tidak melihat semua baris file kami, tetapi hanya pada beberapa sampel, sehingga terkadang dapat membuat asumsi yang salah tentang tipe data (saya melihat tiga angka - saya memutuskan bahwa kolom angka, dan kemudian pergi baris). <br><br>  Nah, kemudian berdasarkan skema, kami membuat dataset (ini adalah istilah umum Layang-layang, menggeneralisasi tabel di Hive, tabel di HBase, dan yang lainnya).  Dalam hal ini, default adalah database (untuk Hive itu sama dengan skema), dan levelswkt adalah nama tabel kami. <br><br>  Nah, perintah terbaru mengunggah file CSV ke dataset kami.  Setelah unduhan selesai dengan sukses, Anda sudah dapat menyelesaikan permintaan: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> levelswkt;</code> </pre> <br>  suatu tempat di rona. <br><br><h3>  Bekerja dengan geometri </h3><br>  Untuk bekerja dengan geometri di Jawa, kami memilih Esri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Geometry API</a> (pengembang ArcGIS).  Pada prinsipnya, dimungkinkan untuk mengambil kerangka kerja lain, ada beberapa pilihan Open Source, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Suite Topologi JTS yang</a> dikenal luas, atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Geotools</a> . <br><br>  Tugas pertama memungkinkan kita untuk mengatasi kerangka kerja lain dari perusahaan Esri yang sama, yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kerangka Tata Ruang untuk Hadoop</a> , dan berdasarkan yang pertama.  Sebenarnya, kita memerlukan SerDe dari itu, modul serialisasi-deserialisasi untuk Hive, yang memungkinkan kita untuk menyajikan banyak file geojson sebagai tabel di Hive, kolom yang diambil dari atribut geojson.  Dan geometri itu sendiri menjadi kolom lain (dengan data biner).  Sebagai hasilnya, kami memiliki tabel, salah satu kolom di antaranya adalah geometri wilayah tertentu, dan sisanya adalah atributnya (nama, level dalam ADT, dll.).  Tabel ini tersedia untuk aplikasi Spark. <br><br>  Jika kita memuat basis data dalam format CSV, maka kita memiliki kolom di mana geometri berada dalam bentuk teks, dalam format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WKT</a> .  Dalam hal ini, Spark dapat membuat objek geometri saat runtime menggunakan API Geometri. <br><br>  Kami memilih format CSV (dan WKT), karena satu alasan sederhana - seperti yang diketahui semua orang, Rusia menempati peta area dengan koordinat Chukotka di luar 180 meridian.  Format geojson memiliki batasan - semua poligon di dalamnya harus dibatasi hingga 180 derajat, dan yang melintasi meridian 180 harus dipotong menjadi dua bagian di sepanjang itu.  Akibatnya, saat mengimpor geometri ke API Geometri, kami mendapatkan objek yang API Geometri salah mendefinisikan Kotak Bounding (melampirkan persegi panjang) untuk perbatasan Rusia.  Ternyata jawabannya adalah -180.180 dalam bujur.  Yang tentu saja tidak benar - pada kenyataannya, Rusia membutuhkan sekitar 20 hingga -170 derajat.  Ini adalah masalah API Geometri; hari ini mungkin sudah diperbaiki, tetapi kami harus mengatasinya. <br><br>  WKT tidak memiliki masalah seperti itu.  Anda mungkin bertanya, mengapa kita membutuhkan Bounding Box?  Maka saya akan memberitahu;) <br><br>  Masih untuk memecahkan apa yang disebut masalah PIP, tunjuk poligon.  Java Geometry API dapat melakukannya lagi, bagi kami itu sederhana, satu geometri tipe Point, poligon kedua (Multipoligon) untuk wilayah tersebut, dan satu berisi metode. <br><br>  Akibatnya, solusi kedua, dan juga di dahi, tampak seperti ini: Aplikasi Spark memuat ADT, termasuk geometri.  Sesuatu seperti Map name-&gt; geometry dibangun dari mereka (sebenarnya sedikit lebih rumit, karena ADT bersarang di dalam satu sama lain, dan kami hanya perlu mencari di level yang lebih rendah yang termasuk dalam yang sudah ditemukan. Akibatnya, ada semacam pohon geometri yang menurut sumbernya data masih perlu dibangun).  Dan kemudian kita membangun Spark Dataset dengan poin kita, dan untuk setiap titik kita menerapkan UDF kita sendiri, yang memeriksa entri titik ke semua geometri (di pohon). <br><br>  Menulis versi baru membutuhkan waktu sekitar satu hari kerja, karena Kerangka Spasial untuk bundel Hadoop menyertakan contoh-contoh bagus secara langsung untuk menyelesaikan tugas PIP (walaupun, menggunakan beberapa cara lain). <br><br>  Kami mulai, dan ... oh, horor, sesuatu tidak menjadi lebih cepat.  Tonton lagi.  Sudah waktunya untuk berpikir tentang optimasi. <br><br><h2>  Solusi yang Efisien, QuadTree </h2><br>  Alasan rem cukup jelas - katakanlah, geometri Rusia, mis.  batas eksternal, ini adalah megabyte geojson, poligon besar, dan bukan satu.  Jika Anda ingat bagaimana masalah PIP diselesaikan, maka salah satu metode yang terkenal adalah membangun sinar dari suatu titik, mengatakan di suatu tempat hingga tak terhingga, dan menentukan berapa banyak titik yang memotong poligon.  Jika jumlah titiknya genap, titiknya di luar poligon, jika ganjil, ia ada di dalam. <br><br>  Berikut deskripsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari wiki</a> . <br><br><img src="https://habrastorage.org/webt/rr/e4/pr/rre4praq1mhfcbtbekvdutvgge0.png"><br><br>  Jelas bahwa untuk poligon besar, solusi untuk masalah persimpangan rumit sebanyak yang ada garis lurus dalam poligon kami.  Oleh karena itu, diinginkan untuk entah bagaimana membuang poligon-poligon yang tidak dapat dimasuki titik tersebut.  Dan sebagai peretas tambahan, dimungkinkan untuk menjatuhkan cek untuk masuk ke perbatasan Rusia (jika kita tahu bahwa semua koordinat jelas termasuk di dalamnya). <br><br>  Untuk ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon kuadran</a> cocok untuk kita.  Untungnya, implementasinya semuanya dalam API Geometri yang sama (dan banyak lagi). <br><br><img src="https://habrastorage.org/webt/8l/ie/_x/8lie_xz2j_spgusj9mqul0ratsy.png" width="400" height="400"><br><br>  Solusi berbasis pohon terlihat seperti ini: <br><br><ol><li>  Memuat ATD Geometri </li><li>  Untuk masing-masing geometri kita mendefinisikan sebuah persegi panjang terlampir </li><li>  Kami memasukkannya ke QuadTree, kami mendapatkan indeks sebagai respons </li><li>  indeks diingat </li></ol><br>  Selanjutnya, saat memproses poin: <br><br><ol><li>  Kami bertanya QuadTree mana dari geometri yang diketahuinya mungkin termasuk titik </li><li>  Dapatkan indeks geometri </li><li>  Hanya untuk mereka, kami memeriksa kejadian dengan memecahkan masalah PIP </li></ol><br>  Ini semua membutuhkan empat jam untuk berkembang.  Kami mulai lagi, dan kami melihat bahwa tugas itu selesai dengan sangat cepat.  Kami memeriksa - semuanya baik-baik saja, solusinya diterima.  Dan itu semua dalam beberapa menit.  QuadTree memberi kami beberapa kali akselerasi besar. <br><br><h2>  Ringkasan </h2><br>  Jadi apa yang akhirnya kita lakukan?  Kami mendapat mekanisme geocoding terbalik yang secara paralel melakukan paralel pada Hadoop cluster, dan yang memecahkan masalah awal kami dengan 200 ribu poin dalam sekitar satu menit.  Yaitu  kita dapat dengan mudah menerapkan solusi ini ke jutaan poin. <br><br>  Apa keterbatasan dari solusi ini?  Pertama, yang jelas - ini didasarkan pada data ADT yang tersedia bagi kami, yang a) mungkin tidak relevan b) terbatas hanya untuk Rusia. <br><br>  Dan yang kedua - kita tidak dapat menyelesaikan masalah geocoding terbalik untuk objek selain poligon tertutup.  Dan itu berarti - untuk jalanan juga. <br><br><h2>  Pengembangan </h2><br>  Apa yang bisa dilakukan dengan ini? <br><br>  Untuk memiliki geometri ADT saat ini, hal yang paling sederhana adalah mendapatkannya dari OpenStreetMap.  Tentu saja, mereka harus bekerja sedikit, tetapi ini adalah tugas yang sepenuhnya dapat dipecahkan.  Jika ada minat, saya akan berbicara tentang tugas memuat data OpenStreetMap ke cluster Hadoop lain kali. <br><br>  Apa yang bisa dilakukan untuk jalanan dan rumah?  Pada prinsipnya, jalanan di OSM yang sama.  Tapi ini bukan struktur tertutup, tetapi garis.  Untuk menentukan bahwa titik tersebut "dekat" dengan jalan tertentu, Anda harus membuat poligon untuk jalan dari titik yang sama jauhnya dari itu, dan memeriksa apakah itu masuk ke dalamnya.  Akibatnya, semacam sosis ternyata ... terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/6h/ky/of/6hkyoffev4qx6a07-vlw2vluytc.png"><br><br>  Seberapa dekat intinya?  Ini adalah parameter, dan kira-kira sesuai dengan radius di mana ArcGIS mencari objek, yang saya sebutkan di awal. <br><br>  Jadi kita menemukan jalan yang jaraknya dari titik kurang dari batas tertentu (katakanlah, 100 meter).  Dan semakin kecil batas ini, semakin cepat algoritma bekerja, tetapi semakin besar kemungkinan Anda tidak akan menemukan kecocokan tunggal. <br><br>  Masalah yang jelas adalah bahwa tidak mungkin untuk menghitung buffer yang disebut sebelumnya - ukurannya adalah parameter layanan.  Mereka perlu dibangun dengan cepat, setelah kami mengidentifikasi area kota yang diinginkan, dan memilih dari pangkalan OSM jalan-jalan yang melewati area ini.  Jalan-jalan, bagaimanapun, dapat dipilih terlebih dahulu. <br><br>  Rumah-rumah yang ada di daerah yang ditemukan juga tidak bergerak ke mana-mana, sehingga daftar mereka dapat dibangun di muka - tetapi masuk ke mereka masih harus dipertimbangkan dengan cepat. <br><br>  Artinya, Anda harus terlebih dahulu membangun indeks dari bentuk "distrik kota" -&gt; daftar rumah dengan tautan ke geometri, dan yang serupa untuk daftar jalan. <br><br>  Dan segera setelah kami mengidentifikasi daerah tersebut, kami mendapatkan daftar rumah dan jalan, kami membangun di sepanjang jalan-jalan perbatasan, dan hanya untuk mereka kami menyelesaikan masalah PIP (mungkin menggunakan optimasi yang sama seperti untuk perbatasan daerah).  Pohon kuadran untuk rumah dalam hal ini, jelas, juga dapat dibangun di muka, dan disimpan di suatu tempat. <br><br>  Tujuan utama kami adalah untuk meminimalkan jumlah perhitungan, sambil memaksimalkan dan mempertahankan semua yang dapat dihitung dan disimpan terlebih dahulu.  Dalam hal ini, proses akan terdiri dari tahap lambat membangun indeks, dan tahap kedua perhitungan, yang sudah akan berlangsung cepat, dekat dengan versi online. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438046/">https://habr.com/ru/post/id438046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438020/index.html">Caterpillar Memperkenalkan Excavator Listrik 26 Ton dengan Baterai Raksasa 300 kWh</a></li>
<li><a href="../id438024/index.html">Pembayaran cepat: apa yang perlu dikhawatirkan oleh bank</a></li>
<li><a href="../id438028/index.html">Anda tidak perlu blockchain: 8 case pengguna populer dan mengapa itu tidak berfungsi</a></li>
<li><a href="../id438032/index.html">Sumber terbuka populer - bagian dua: 5 alat manajemen cloud</a></li>
<li><a href="../id438034/index.html">Android, Rx, dan Kotlin, atau cara membuat cakar Lego menyusut. Bagian 1</a></li>
<li><a href="../id438050/index.html">Filter Kalman untuk meminimalkan nilai entropi dari kesalahan acak dengan distribusi non-Gaussian</a></li>
<li><a href="../id438058/index.html">"Analisis Data dengan Python" dalam dua bagian</a></li>
<li><a href="../id438060/index.html">Estimasi orientasi spasial, atau Bagaimana tidak perlu takut dengan filter Mahoney dan Majwik</a></li>
<li><a href="../id438062/index.html">Alamat saya bukan rumah atau jalan, alamat saya adalah Uni Soviet?</a></li>
<li><a href="../id438064/index.html">Daftar periksa: apa yang harus dilakukan sebelum menjalankan layanan microser di prod</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>