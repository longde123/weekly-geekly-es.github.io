<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñï üë©‚Äçüé® ‚ôíÔ∏è Stan Drapkin. Hochrangige Kryptografiefallen in .NET ü§õüèæ üé≤ ‚úçüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Stan Drapkin ist ein Sicherheits- und Compliance-Experte mit √ºber 16 Jahren Erfahrung mit .NET Framework (beginnend mit .NET 1.0-Beta im Jahr 2001). L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Stan Drapkin. Hochrangige Kryptografiefallen in .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/428121/">  Stan Drapkin ist ein Sicherheits- und Compliance-Experte mit √ºber 16 Jahren Erfahrung mit .NET Framework (beginnend mit .NET 1.0-Beta im Jahr 2001).  Leider schreibt er selbst keine Artikel auf Russisch, daher haben wir uns mit ihm darauf geeinigt, eine √úbersetzung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seines Berichts mit DotNext Piter zu ver√∂ffentlichen</a> .  Dieser Bericht <b>gewann den ersten Platz</b> auf der Konferenz! <br><br>  Symmetrische Kryptographie, asymmetrische, hybride, High-Level-, Low-Level-, Stream- und moderne elliptische Kryptographie.  Sechsundf√ºnfzig Minuten Video √ºber Kryptographie und viel schneller - in Form von Text. <br><br><img src="https://habrastorage.org/webt/ye/8s/g0/ye8sg0kuwhgvtitnjxvwpehfnwc.png"><br><br>  Unter dem Schnitt - Videos, Folien und √úbersetzung.  Viel Spa√ü beim Lesen! <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZqGyV7Jshww" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Folien</a> <br><br>  Mein Name ist Stan Drapkin, ich bin der technische Direktor eines Unternehmens, das sich auf Informationssicherheit und Einhaltung gesetzlicher Vorschriften spezialisiert hat.  Au√üerdem bin ich Autor mehrerer Open-Source-Bibliotheken, die von der Community sehr gut angenommen werden.  Wie viele haben von <i>Inferno geh√∂rt</i> ?  Diese Bibliothek demonstriert den korrekten Ansatz zur Kryptografie in .NET, und <i>TinyORM</i> implementiert Micro-ORM f√ºr .NET.  Dar√ºber hinaus habe ich mehrere B√ºcher geschrieben, die f√ºr das Thema des heutigen Artikels relevant sein k√∂nnten.  Eine davon, die Ausgabe 2014, ist "Security Driven .NET", die andere von 2017 ist "Application Security in .NET, pr√§gnant". <br><br>  Zuerst werden wir √ºber die vier Stufen der Kryptoaufkl√§rung sprechen.  Dann folgen zwei Hauptthemen, im ersten √ºber symmetrische Kryptographie, im zweiten √ºber asymmetrische und hybride.  Im ersten Teil vergleichen wir die Kryptografie auf hoher und niedriger Ebene und sehen uns ein Beispiel f√ºr die Streaming-Kryptografie an.  Im zweiten Teil werden wir viele ‚ÄûAbenteuer‚Äú mit RSA erleben, wonach wir uns mit der modernen elliptischen Kryptographie vertraut machen werden. <br><br>  Wie sehen diese Stadien der Kryptoaufkl√§rung aus?  Die erste Phase - "XOR ist so cool, schau, Mama, wie kann ich!"  Sicherlich sind viele von Ihnen mit dieser Phase vertraut und kennen die Wunder der XOR-Funktion.  Ich hoffe jedoch, dass der gr√∂√üte Teil dieser Phase gewachsen ist und zur n√§chsten √ºbergegangen ist, dh gelernt hat, Verschl√ºsselung und Entschl√ºsselung mit AES (Advanced Encryption Standard) durchzuf√ºhren, einem bekannten und hoch angesehenen Algorithmus.  Die meisten Entwickler, die DotNext nicht besuchen, befinden sich in dieser Phase.  Da Sie DotNext folgen und mit Berichten √ºber die Gefahren von Low-Level-APIs vertraut sind, befinden Sie sich h√∂chstwahrscheinlich in der n√§chsten Phase: ‚ÄûIch habe alles (a) falsch gemacht, ich muss zu High-Level-APIs wechseln‚Äú.  Um das Bild zu vervollst√§ndigen, m√∂chte ich auch die letzte Phase erw√§hnen - das Verst√§ndnis, dass bei der besten L√∂sung des Problems Kryptografie m√∂glicherweise √ºberhaupt nicht ben√∂tigt wird.  Diese Phase ist am schwierigsten zu erreichen, und es gibt nur wenige Menschen.  Ein Beispiel ist Peter G. Neumann, der Folgendes sagte: "Wenn Sie der Meinung sind, dass die L√∂sung Ihres Problems in der Kryptographie liegt, verstehen Sie nicht genau, was Ihr Problem ist." <br><br>  Die Tatsache, dass Kryptografie auf niedriger Ebene gef√§hrlich ist, wurde in vielen Berichten √ºber .NET diskutiert.  Sie k√∂nnen auf den Bericht von Vladimir Kochetkov aus dem Jahr 2015 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Fallstricke von System.Security.Cryptography" verweisen</a> .  Seine Hauptidee ist, dass wir in jeder Phase der Arbeit mit kryptografischen APIs auf niedriger Ebene, ohne es zu wissen, viele Entscheidungen treffen, f√ºr die wir einfach nicht √ºber das entsprechende Wissen verf√ºgen.  Die Hauptschlussfolgerung ist, dass im Idealfall eine Kryptographie auf hoher Ebene anstelle einer Kryptographie auf niedriger Ebene verwendet werden sollte.  Dies ist eine wunderbare Schlussfolgerung, f√ºhrt uns jedoch zu einem anderen Problem: Wissen wir genau, wie Kryptografie auf hoher Ebene aussehen sollte?  Reden wir ein wenig dar√ºber. <br><br>  Definieren Sie die Attribute einer <i>nicht √ºbergeordneten</i> kryptografischen API.  Zun√§chst vermittelt eine solche API nicht den Eindruck, in .NET nativ zu sein, sondern sieht aus wie eine Shell auf niedriger Ebene.  Ferner ist eine solche API leicht falsch zu verwenden, d.h.  nicht wie es sollte.  Dar√ºber hinaus werden Sie gezwungen, viele seltsame Dinge auf niedriger Ebene zu generieren - Nonce, Initialisierungsvektoren und dergleichen.  Eine solche API zwingt Sie dazu, unangenehme Entscheidungen zu treffen, auf die Sie m√∂glicherweise nicht vorbereitet sind - w√§hlen Sie Algorithmen, Auff√ºllmodi, Schl√ºsselgr√∂√üen, Nonce usw. aus.  Es wird auch nicht die richtige API f√ºr das Streaming geben (Streaming-API) - wir werden dar√ºber sprechen, wie letztere aussehen sollte. <br><br>  Wie sollte dagegen eine kryptografische API auf hoher Ebene aussehen?  Ich glaube, dass es sowohl f√ºr den Leser des Codes als auch f√ºr den Verfasser zun√§chst intuitiv und pr√§gnant sein sollte.  Dar√ºber hinaus sollte eine solche API leicht zu erlernen und zu verwenden sein und es sollte √§u√üerst schwierig sein, sie falsch anzuwenden.  Es muss auch m√§chtig sein, das hei√üt, es muss uns erm√∂glichen, unser Ziel mit ein wenig Aufwand, einer kleinen Menge Code, zu erreichen.  Schlie√ülich sollte eine solche API im Allgemeinen keine lange Liste von Einschr√§nkungen, Vorsichtsma√ünahmen und Sonderf√§llen enthalten - es sollte ein Minimum an Dingen geben, die bei der Arbeit beachtet werden m√ºssen, mit anderen Worten - sie sollte durch ein geringes Ma√ü an Interferenz (geringe Reibung) gekennzeichnet sein arbeiten Sie einfach ohne Vorbehalte. <br><br>  Wie k√∂nnen wir die Anforderungen f√ºr eine kryptografische API auf hoher Ebene f√ºr .NET jetzt finden?  Sie k√∂nnen einfach Google ausprobieren, aber das w√§re zu primitiv - wir sind professionelle Entwickler, und dies ist nicht unsere Methode.  Daher untersuchen wir dieses Problem und testen verschiedene Alternativen.  Dazu m√ºssen wir uns zun√§chst die richtige Vorstellung davon machen, was authentifizierte Verschl√ºsselung ist, und daf√ºr m√ºssen wir die Grundkonzepte verstehen.  Sie sind wie folgt: der Klartext P (Klartext), den wir mit einem geheimen Schl√ºssel K (Schl√ºssel) in Chiffretext C (Chiffretext) gleicher L√§nge konvertieren.  Wie Sie sehen, arbeiten wir bisher mit einem sehr einfachen Schema.  Zus√§tzlich haben wir auch ein Authentifizierungs-Tag T und Nonce N. Ein wichtiger Parameter ist NÃÖ, dh die Wiederverwendung von Nonce mit einem Schl√ºssel.  Wie viele von Ihnen wahrscheinlich wissen, f√ºhrt dies zu einer Verletzung der Vertraulichkeit des Textes, was offensichtlich unerw√ºnscht ist.  Ein weiteres wichtiges Konzept sind AD (Associated Data), dh zugeh√∂rige Daten.  Dies sind optionale Daten, die authentifiziert sind, aber nicht an der Ver- und Entschl√ºsselung teilnehmen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f9/41c/537/2f941c537ee2813920df009759b19e97.jpg"><br><br>  Nachdem wir die grundlegenden Konzepte verstanden haben, werfen wir einen Blick auf die verschiedenen Optionen kryptografischer Bibliotheken f√ºr .NET.  Beginnen wir mit der Analyse von <i>Libsodium.NET.</i>  Wie viele von euch kennen sie?  Wie ich sehe, sind einige vertraut. <br><br><pre><code class="cs hljs">nonce = SecretAeadAes.GenerateNonce(); c = SecretAeadAes.Encrypt(p, nonce, key, ad); d = SecretAeadAes.Decrypt(c, nonce, key, ad);</code> </pre> <br>  <i>Hier ist der</i> C # -Code, mit dem die Verschl√ºsselung mit <i>Libsodium.NET durchgef√ºhrt wird</i> .  Auf den ersten Blick ist es recht einfach und pr√§gnant: In der ersten Zeile wird Nonce generiert, das dann in der zweiten Zeile verwendet wird, in der die Verschl√ºsselung selbst stattfindet, und in der dritten Zeile, in der der Text entschl√ºsselt wird.  Es schien - welche Schwierigkeiten k√∂nnte es geben?  Zun√§chst bietet Libsodium.NET nicht eine, sondern drei verschiedene symmetrische Verschl√ºsselungsmethoden: <br><br>  Zeiten <br><br><pre> <code class="cs hljs">nonce = SecretAeadAes.GenerateNonce(); c = SecretAeadAes.Encrypt(p, nonce, key, ad); d = SecretAeadAes.Decrypt(c, nonce, key, ad);</code> </pre><br>  Zwei <br><br><pre> <code class="cs hljs">nonce = SecretAead.GenerateNonce(); c = SecretAead.Encrypt(p, nonce, key, ad); d = SecretAead.Decrypt(c, nonce, key. ad);</code> </pre><br>  Drei <br><br><pre> <code class="cs hljs">nonce = SecretBox.GenerateNonce(); c = SecretBox.Create(p, nonce, key); d = SecretBox.Open(c, nonce, key);</code> </pre><br>  Offensichtlich stellt sich die Frage: Welcher von ihnen ist in Ihrer spezifischen Situation besser?  Um darauf zu antworten, m√ºssen Sie sich mit diesen Methoden befassen, die wir jetzt ausf√ºhren werden. <br><br>  Die erste Methode, <code>SecretAeadAes</code> , verwendet AES-GCM mit einer 96-Bit-Nonce.  Es ist wichtig, dass er eine ziemlich lange Liste von Einschr√§nkungen hat.  Wenn Sie es beispielsweise verwenden, sollten Sie nicht mehr als 550 Gigabyte mit einem Schl√ºssel verschl√ºsseln, und eine Nachricht mit maximal 2 <sup>32</sup> Nachrichten sollte nicht mehr als 64 Gigabyte enthalten.  Dar√ºber hinaus warnt die Bibliothek nicht davor, sich diesen Einschr√§nkungen zu n√§hern. Sie m√ºssen sie selbst nachverfolgen, was Sie als Entwickler zus√§tzlich belastet. <br><br>  Die zweite Methode, <code>SecretAead</code> verwendet eine andere Verschl√ºsselungssuite, <code>ChaCha20/Poly1305</code> mit einer deutlich kleineren 64-Bit-Nonce.  Solch eine kleine Nonce macht Kollisionen √§u√üerst wahrscheinlich, und allein aus diesem Grund sollten Sie diese Methode nicht anwenden - au√üer in recht seltenen F√§llen und vorausgesetzt, Sie sind mit dem Thema sehr gut vertraut. <br><br>  Schlie√ülich die dritte Methode, <code>SecretBox</code> .  Es sollte sofort beachtet werden, dass die Argumente f√ºr diese API keine zugeordneten Daten enthalten.  Wenn Sie eine authentifizierte Verschl√ºsselung mit AD ben√∂tigen, ist diese Methode nicht f√ºr Sie geeignet.  Der hier verwendete Verschl√ºsselungsalgorithmus hei√üt <code>xSalsa20/Poly1305</code> , nonce ist gro√ü genug - 192 Bit.  Das Fehlen von AD ist jedoch eine signifikante Einschr√§nkung. <br><br>  Bei der Verwendung von <i>Libsodium.NET</i> treten einige Fragen auf.  Was genau sollen wir zum Beispiel mit der Nonce tun, die in den obigen Beispielen durch die erste Codezeile generiert wird?  Die Bibliothek sagt uns nichts dar√ºber, wir m√ºssen es selbst herausfinden.  H√∂chstwahrscheinlich werden wir diese Nonce manuell am Anfang oder Ende des Chiffretextes hinzuf√ºgen.  Ferner k√∂nnten wir den Eindruck haben, dass AD in den ersten beiden Methoden beliebig lang sein kann.  Tats√§chlich unterst√ºtzt die Bibliothek AD jedoch nicht l√§nger als 16 Bytes - schlie√ülich reichen 16 Bytes f√ºr alle, oder?  Lass uns weitermachen.  Was passiert mit Entschl√ºsselungsfehlern?  In dieser Bibliothek wurde in diesen F√§llen beschlossen, Ausnahmen auszul√∂sen.  Wenn in Ihrer Umgebung w√§hrend der Entschl√ºsselung die Datenintegrit√§t verletzt wird, m√ºssen Sie viele Ausnahmen behandeln.  Was ist, wenn Ihre Schl√ºsselgr√∂√üe nicht genau 32 Byte betr√§gt?  Die Bibliothek sagt uns nichts dar√ºber, das sind Ihre Probleme, die es nicht interessieren.  Ein weiteres wichtiges Thema ist die Wiederverwendung von Byte-Arrays, um die Belastung des Garbage Collector in intensiven Szenarien zu verringern.  Zum Beispiel haben wir im Code ein Array gesehen, das der Nonce-Generator an uns zur√ºckgegeben hat.  Ich m√∂chte nicht jedes Mal einen neuen Puffer erstellen, sondern den vorhandenen wiederverwenden.  Dies ist in dieser Bibliothek nicht m√∂glich. Jedes Mal wird ein Array von Bytes neu generiert. <br><br>  Mit dem bereits gesehenen Schema werden wir versuchen, verschiedene <i>Libsodium.NET-</i> Algorithmen zu vergleichen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3c/6e3/d3c/b3c6e3d3ce4ef29723e2ac691c3fd4d4.jpg"><br><br>  Der erste Algorithmus, AES-GCM, verwendet eine L√§nge von 96 Bit (gelbe Spalte im Bild).  Es sind weniger als 128 Bit, was einige Unannehmlichkeiten verursacht, aber nicht zu bedeutend ist.  Die n√§chste Spalte ist blau. Dies ist die Stelle, an der sich das Authentifizierungs-Tag befindet. Bei AES-GCM sind es 16 Byte oder 128 Bit.  Die zweite blaue Ziffer in Klammern bedeutet die Entropie oder Zuf√§lligkeit, die in diesem Tag enthalten ist - weniger als 128 Bit.  Wie viel weniger - bei diesem Algorithmus h√§ngt davon ab, wie viele Daten verschl√ºsselt sind.  Je verschl√ºsselter, desto schw√§cher das Tag.  Dies allein sollte Zweifel an diesem Algorithmus aufkommen lassen, die nur zunehmen werden, wenn wir uns die wei√üe Spalte ansehen.  Es hei√üt, dass Wiederholungen (Kollisionen) von Nonce zur Verf√§lschung aller Chiffretexte f√ºhren, die mit demselben Schl√ºssel erstellt wurden.  Wenn beispielsweise von 100 Ihrer Chiffretexte, die von einem gemeinsamen Schl√ºssel in zwei erstellt wurden, eine Nonce-Kollision auftritt, f√ºhrt diese Nonce zu einem internen Leck des Authentifizierungsschl√ºssels und erm√∂glicht es einem Angreifer, jeden anderen von diesem Schl√ºssel erstellten Chiffretext zu f√§lschen.  Dies ist eine sehr bedeutende Einschr√§nkung. <br><br>  <i>Fahren</i> wir mit der zweiten <i>Libsodium.NET-</i> Methode fort.  Wie gesagt, hier wird f√ºr Nonce zu wenig Speicherplatz verwendet, nur 64 Bit.  Das Tag belegt 128 Bit, enth√§lt jedoch nur 106 Bit Entropie oder weniger, dh es ist deutlich niedriger als die Sicherheitsstufe von 128 Bit, die in den meisten F√§llen erreicht werden soll.  Bei F√§lschungen ist die Situation hier etwas besser als bei AES-GCM.  Die Kollision von Nonce f√ºhrt zur Verf√§lschung von Chiffretexten, jedoch nur f√ºr diejenigen Bl√∂cke, in denen Kollisionen aufgetreten sind.  Im vorherigen Beispiel h√§tten wir 2 Chiffretexte gef√§lscht, nicht 100. <br><br>  Schlie√ülich haben wir im Fall des xSalsa / Poly-Algorithmus eine sehr gro√üe Nonce von 192 Bits, was Kollisionen √§u√üerst unwahrscheinlich macht.  Die Authentifizierungsmethode ist dieselbe wie bei der vorherigen Methode, sodass das Tag erneut 128 Bit ben√∂tigt und 106 Bit Entropie oder weniger aufweist. <br><br>  Vergleichen Sie alle diese Zahlen mit den entsprechenden Indikatoren der <i>Inferno-</i> Bibliothek.  Nonce nimmt darin einen kolossalen Raum von 320 Bit ein, was Kollisionen fast unm√∂glich macht.  Was das Tag betrifft, ist alles einfach: Es belegt genau 128 Bit und hat genau 128 Bit Entropie, nicht weniger.  Dies ist ein Beispiel f√ºr einen zuverl√§ssigen und sicheren Ansatz. <br><br>  Bevor wir <i>Libsodium.NET</i> genauer kennenlernen, m√ºssen wir dessen Zweck verstehen - leider ist dies nicht jedem bekannt, der diese Bibliothek verwendet.  <i>Informationen</i> hierzu finden Sie in der Dokumentation, in der angegeben ist, dass <i>Libsodium.NET</i> ein C # <i>-Wrapper</i> f√ºr <i>libsodium ist</i> .  Dies ist ein weiteres Open-Source-Projekt, dessen Dokumentation besagt, dass es sich um eine <i>NaCl-Verzweigung</i> mit einer kompatiblen API handelt.  Wenden Sie sich der Dokumentation von <i>NaCl zu</i> , einem weiteren Open-Source-Projekt.  Als Ziel <i>wird</i> postuliert, dass <i>NaCl</i> alle erforderlichen Operationen zum Erstellen von kryptografischen Tools auf hoher Ebene bereitstellt.  Hier ist der Hund begraben: Die Aufgabe von <i>NaCl</i> und all seinen Schalen besteht darin, Elemente auf niedriger Ebene bereitzustellen, aus denen dann bereits jemand anderes kryptografische APIs auf hoher Ebene zusammenstellen kann.  Diese Shells selbst als hochrangige Bibliotheken wurden nicht konzipiert.  Daher die Moral: Wenn Sie eine kryptografische API auf hoher Ebene ben√∂tigen, m√ºssen Sie eine Bibliothek auf hoher Ebene finden und keinen Wrapper auf niedriger Ebene verwenden und so tun, als w√ºrden Sie mit einer auf hoher Ebene arbeiten. <br><br>  Mal sehen, wie die Verschl√ºsselung in <i>Inferno</i> funktioniert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/64f/367/fe7/64f367fe769bce5d8fa0482f8a301648.jpg"><br><br>  Hier ist ein Beispielcode, in dem wie im Fall von <i>Libsodium</i> jede Ver- und Entschl√ºsselung nur eine Zeile dauert.  Die Argumente sind Schl√ºssel, Text und optionale zugeh√∂rige Daten.  Es sollte beachtet werden, dass es keine Nonce gibt, keine Notwendigkeit besteht, Entscheidungen zu treffen. Im Falle eines Entschl√ºsselungsfehlers wird einfach null zur√ºckgegeben, ohne Ausnahmen auszul√∂sen.  Da das Erstellen von Ausnahmen die Belastung des Garbage Collectors erheblich erh√∂ht, ist ihre Abwesenheit f√ºr Skripts, die gro√üe Datenstr√∂me verarbeiten, sehr wichtig.  Ich hoffe, ich konnte Sie davon √ºberzeugen, dass dieser Ansatz optimal ist. <br><br>  Versuchen wir aus Interesse, eine Zeichenfolge zu verschl√ºsseln.  Dies sollte das einfachste Szenario sein, das jeder implementieren kann.  Angenommen, wir haben nur zwei verschiedene m√∂gliche Zeichenfolgenwerte: "LINKS" und "RECHTS". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/88b/522/92b/88b52292b7ce52dc2a90302cbbbe1f36.jpg"><br><br>  Auf dem Bild sehen Sie die Verschl√ºsselung dieser Zeilen mit <i>Inferno</i> (obwohl es f√ºr dieses Beispiel keine Rolle spielt, welche Bibliothek verwendet wird).  Wir verschl√ºsseln zwei Zeilen mit einem Schl√ºssel und erhalten zwei Chiffretexte, <code>c1</code> und <code>c2</code> .  Ist alles in diesem Code korrekt?  Ist er bereit f√ºr die Produktion?  Jemand mag sagen, dass das Problem auf kurze Weise m√∂glich ist, aber es ist weit vom Hauptproblem entfernt, sodass wir davon ausgehen, dass der Schl√ºssel gleich verwendet wird und eine ausreichende L√§nge hat.  Ich meine noch etwas anderes: Bei herk√∂mmlichen kryptografischen Ans√§tzen ist <code>c1</code> in unserem Beispiel k√ºrzer als <code>c2</code> .  Dies wird als L√§ngenleck bezeichnet - <code>c2</code> in vielen F√§llen ein Byte l√§nger als <code>c1</code> .  Dadurch kann ein Angreifer m√∂glicherweise verstehen, welche Zeichenfolge durch diesen Chiffretext "LINKS" oder "RECHTS" dargestellt wird.  Der einfachste Weg, um dieses Problem zu l√∂sen, besteht darin, beide Zeilen gleich lang zu machen. F√ºgen Sie beispielsweise am Ende der Zeile ‚ÄûLINKS‚Äú ein Zeichen hinzu. <br><br>  Auf den ersten Blick wird L√§ngenleckage als ein etwas weit hergeholtes Problem wahrgenommen, das in realen Anwendungen nicht auftreten kann.  Im Januar 2018 wurde im Wired-Magazin ein Artikel mit einer Studie des israelischen Unternehmens Checkmarx unter der √úberschrift ‚ÄûDie fehlende Verschl√ºsselung in Tinder erm√∂glicht es Au√üenstehenden, zu verfolgen, wann Sie √ºber den Bildschirm streichen‚Äú ver√∂ffentlicht.  Ich werde kurz auf den Inhalt eingehen, aber zuerst eine grobe Beschreibung der Tinder-Funktionalit√§t.  Tinder ist eine Anwendung, die einen Stream mit Fotos empf√§ngt. Anschlie√üend wischt der Benutzer den Bildschirm nach rechts oder links, je nachdem, ob ihm das Foto gef√§llt oder nicht.  Die Forscher fanden heraus, dass die Daten f√ºr den rechten Befehl eine andere Anzahl von Bytes ben√∂tigten als die Daten f√ºr den linken, obwohl die Befehle selbst mit TLS und HTTPS korrekt verschl√ºsselt waren.  Dies ist nat√ºrlich eine Sicherheitsl√ºcke, aber an sich ist sie nicht zu bedeutend.  Wichtiger f√ºr Tinder war die Tatsache, dass die Streams mit Fotos √ºber normales HTTP ohne Verschl√ºsselung gesendet wurden.  So kann der Angreifer nicht nur auf Benutzerreaktionen auf Fotos zugreifen, sondern auch auf die Fotos selbst.  Wie Sie sehen k√∂nnen, ist L√§ngenleckage ein sehr reales Problem. <br><br>  Versuchen wir nun, die Datei zu verschl√ºsseln.  Ich muss sofort sagen, dass in <i>Libsodium.NET die</i> Dateiverschl√ºsselung oder allgemeiner die Stream-Verschl√ºsselung nicht standardm√§√üig implementiert ist, sondern manuell durchgef√ºhrt werden muss - was meiner Meinung nach sehr schwierig ist, dies richtig zu tun.  Im <i>Inferno</i> sieht es damit viel besser aus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f0/446/955/5f0446955f52e679e6dbeaacee2389b4.jpg"><br><br>  Oben sehen Sie ein Beispiel, das praktisch ohne √Ñnderung von MSDN aufgenommen wurde.  Es ist sehr einfach, hier sehen wir einen Stream f√ºr die Quelldatei und einen anderen f√ºr die Zieldatei sowie einen Krypto-Stream, der den ersten in den zweiten konvertiert.  In diesem Code wird <i>Inferno</i> nur in einer Zeile verwendet - in der Zeile, in der die Konvertierung stattfindet.  Vor uns liegt also eine einfache und gleichzeitig voll funktionsf√§hige und getestete L√∂sung f√ºr die Stream-Verschl√ºsselung. <br><br>  Es ist zu beachten, dass beim Verschl√ºsseln mit demselben Schl√ºssel die Anzahl der Nachrichten begrenzt ist.  Sie existieren im <i>Inferno</i> und sind in dieser Bibliothek deutlich auf dem Bildschirm geschrieben.  Gleichzeitig sind sie im <i>Inferno</i> so gro√ü, dass Sie sie in der Praxis niemals erreichen werden.  In <i>Libsodium.NET sind die</i> Einschr√§nkungen f√ºr verschiedene Algorithmen unterschiedlich, aber in allen F√§llen niedrig genug, um √ºberschritten zu werden.  Sie m√ºssen also pr√ºfen, ob sie in jedem einzelnen Szenario erreicht werden. <br><br>  Wir sollten auch √ºber die Authentifizierung zugeh√∂riger Daten sprechen, da dies ein Thema ist, das nicht oft behandelt wird.  ADs k√∂nnen ‚Äûschwach‚Äú sein: Dies bedeutet, dass sie authentifiziert sind, aber nicht am Ver- und Entschl√ºsselungsprozess beteiligt sind.  Im Gegensatz dazu ver√§ndern ‚Äûstarke‚Äú ADs diesen Prozess selbst.  Die meisten mir bekannten AD-Bibliotheken sind schwach, w√§hrend <i>Inferno</i> den zweiten Ansatz verwendet, bei dem ADs im Verschl√ºsselungs- / Entschl√ºsselungsprozess selbst verwendet werden ... <br><br>  Es sollte auch dar√ºber nachgedacht werden, welche Sicherheitsstufe f√ºr eine Kryptografie auf hoher Ebene angestrebt werden sollte.  Kurz gesagt, meine Antwort lautet: 256-Bit-Verschl√ºsselung mit einem 128-Bit-Authentifizierungs-Tag.  Warum ist ein Schl√ºssel so gro√ü?  Es gibt viele Gr√ºnde daf√ºr, von denen jeder f√ºr sich von Bedeutung ist, aber jetzt m√∂chte ich Sie bitten, sich an eines zu erinnern: Wir m√ºssen uns vor m√∂glichen Verzerrungen sch√ºtzen, wenn wir kryptografische Schl√ºssel generieren.  Lassen Sie mich erkl√§ren, was unter Voreingenommenheit zu verstehen ist.  F√ºr einen Zufallsbitgenerator ohne Vorspannung sind f√ºr jedes Bit die Wahrscheinlichkeiten f√ºr das Akzeptieren des Werts 0 oder 1 gleich.  Nehmen wir jedoch an, dass das Bit in unserem Generator den Wert 1 mit einer Wahrscheinlichkeit von 56% und nicht von 50% annimmt.  Auf den ersten Blick ist diese Tendenz gering, aber tats√§chlich ist sie signifikant: 25%.  Versuchen wir nun zu berechnen, wie viel Entropie wir erhalten, wenn wir mit unserem Generator eine bestimmte Anzahl von Bits erzeugen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3eb/f2e/df8/3ebf2edf8c049579b2e4218f9dff16b8.jpg"><br><br>  Im Bild sehen Sie die Formel, nach der diese Berechnung durchgef√ºhrt wird.  Es ist wichtig, dass nur zwei Variablen enthalten sind: die Verzerrung, √ºber die wir bereits gesprochen haben (Verzerrung), und die Anzahl der vom Generator erzeugten Bits.  Wir gehen davon aus, dass die Abweichung 25% betr√§gt - dies ist ein ziemlich extremer Fall. In der Praxis werden Sie h√∂chstwahrscheinlich nicht in Systemen mit einem derart verzerrten Zufallszahlengenerator arbeiten.  Mit 25% Bias und einem 128-Bit-Schl√ºssel erhalten wir jedenfalls nur 53 Bit Entropie.  Erstens sind es deutlich weniger als 128 Bit, die normalerweise von einem Zufallszahlengenerator erwartet werden, und zweitens kann ein solcher Schl√ºssel mit modernen Technologien einfach Brute Force sein.  Wenn wir jedoch anstelle des 128-Bit-Schl√ºssels 256-Bit verwenden, erhalten wir 106 Bit Entropie.  Dies ist bereits recht gut, wenn auch weniger als die erwarteten 256. Mit modernen Technologien ist es fast unm√∂glich, einen solchen Schl√ºssel zu knacken. <br><br>  Am Ende des ersten Teils des Berichts werde ich die Zwischenergebnisse zusammenfassen.  Ich empfehle jedem, gut geschriebene kryptografische APIs zu verwenden.  Finden Sie diejenige, die zu Ihnen passt, oder senden Sie eine Petition an Microsoft, um Ihnen zu schreiben.  Dar√ºber hinaus sollten Sie bei der Auswahl einer API auf die Verf√ºgbarkeit von Unterst√ºtzung f√ºr die Arbeit mit Threads achten.  Aus den bereits erl√§uterten Gr√ºnden sollte die minimale Schl√ºssell√§nge 256 Bit betragen.  Schlie√ülich sollte bedacht werden, dass Kryptographie auf hoher Ebene wie jede andere nicht ideal ist.  Es k√∂nnen Undichtigkeiten auftreten, und in den meisten Szenarien m√ºssen deren F√§higkeiten ber√ºcksichtigt werden. <br><br>  Lassen Sie uns √ºber asymmetrische oder hybride Kryptographie sprechen.  Ich stelle eine Trickfrage: K√∂nnen Sie RSA in .NET verwenden?  Beeilen Sie sich nicht, dies zu bejahen, wie es viele tun - lassen Sie uns zun√§chst Ihr Wissen in diesem Bereich testen.  Die folgenden Folien wurden speziell f√ºr Personen entwickelt, die bereits mit diesem Thema vertraut sind.  Aber zuerst schauen wir uns Wikipedia an und erinnern uns, was RSA genau ist, falls jemand diesen Algorithmus vergessen hat oder ihn lange nicht benutzt hat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fec/e71/6ba/fece716ba7a00668b4d955c37745e744.png"><br><br>  Angenommen, es gibt einige Alice, die mithilfe eines Zufallszahlengenerators ein Schl√ºsselpaar erstellt, das ein privates und ein √∂ffentliches enth√§lt.  Als n√§chstes gibt es einige Bob, die eine Nachricht f√ºr Alice verschl√ºsseln m√∂chten: "Hallo Alice!"  Mit ihrem √∂ffentlichen Schl√ºssel generiert er einen Chiffretext, den er dann an sie sendet.  Sie entschl√ºsselt diesen Chiffretext mit dem privaten Teil ihres Schl√ºssels. <br><br>  Versuchen wir, dieses Szenario in der Praxis zu reproduzieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/35d/021/627/35d021627d87f316a65b87bc4662aa05.jpg"><br><br>  Wie Sie oben sehen k√∂nnen, erstellen wir eine Instanz von RSA und verschl√ºsseln Text.  Achten Sie sofort darauf, dass .NET uns zwingt, den Auff√ºllmodus zu w√§hlen.  Es gibt f√ºnf von ihnen, alle mit obskuren Namen.  Wenn wir sie alle nacheinander ausprobieren, werden wir feststellen, dass die letzten drei einfach eine Ausnahme ausl√∂sen und nicht funktionieren.  Wir werden eine der beiden verbleibenden verwenden - <code>OaepSHA1</code> .  Hier hat der Schl√ºssel eine Gr√∂√üe von 1 Kilobit, was f√ºr RSA zu klein ist. Es handelt sich praktisch um einen gehackten Schl√ºssel.  Daher m√ºssen wir die Schl√ºsselgr√∂√üe manuell einstellen.  Aus der Dokumentation erfahren wir, dass es eine spezielle Eigenschaft <code>.KeySize</code> , die die Schl√ºsselgr√∂√üe empf√§ngt oder festlegt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0e/e77/a12/e0ee77a12bcd866142463ee8440c9b28.jpg"><br><br>  Auf den ersten Blick ist dies genau das, was wir brauchen, also schreiben wir: <code>rsa.KeySize = 3072</code> .  Wenn wir jedoch nach vage Vermutung √ºberpr√ºfen, wie gro√ü die Schl√ºsselgr√∂√üe jetzt ist, werden wir feststellen, dass es immer noch 1 Kilobit dauert.  Es spielt keine Rolle, wir √ºberpr√ºfen diesen Parameter mit der <code>WriteLine(rsa.KeySize)</code> Methode <code>WriteLine(rsa.KeySize)</code> oder <code>rsa.ExportParameters(false).Modulus.Length * 8</code> - im letzteren Fall wird die √∂ffentliche Komponente des RSA-Schl√ºssels exportiert. Dazu ben√∂tigen wir das Argument "false".  Der Modul dieses Schl√ºssels ist ein Array, das wir mit 8 multiplizieren und die Gr√∂√üe in Bits erhalten - was wiederum 1 Kilobit betr√§gt.  Wie Sie sehen, ist dieser Algorithmus noch zu fr√ºh, um an die Produktion gesendet zu werden. <br><br>  Wir werden keine Zeit damit verschwenden, herauszufinden, warum diese API nicht funktioniert. Versuchen Sie stattdessen eine andere RSA-Implementierung, die von Microsoft in .NET 4.6 bereitgestellt wird, dh eine v√∂llig neue.  Es hei√üt <i>RSACng</i> und <i>Cng</i> steht f√ºr Cryptography Next Generation.  Gro√üartig, wer m√∂chte nicht mit Tools der n√§chsten Generation arbeiten?  Hier finden wir sicherlich eine magische L√∂sung f√ºr all unsere Probleme. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ed/1af/3fb/7ed1af3fbcd93422ff6648e2af791264.jpg"><br><br>  Wir fordern eine Instanz von RSACng an, setzen die Schl√ºsselgr√∂√üe erneut auf 3 Kilobit, √ºberpr√ºfen erneut die Schl√ºsselgr√∂√üe √ºber <code>WriteLine(rsa.KeySize)</code> - und stellen erneut fest, dass die Schl√ºsselgr√∂√üe immer noch einem Kilobit entspricht.  Wenn wir au√üerdem den Typ des Objekts anfordern, das den Schl√ºssel generiert hat - wie wir uns erinnern, haben wir eine Instanz von RSACng angefordert -, stellen wir fest, dass es sich um RSACryptoServiceProvider handelt.  Ich m√∂chte hier nur mein pers√∂nliches Gef√ºhl der Verzweiflung teilen und schreien: "Warum, Microsoft ?!" <br><br>  Nach l√§ngerer Qual und Qual stellen wir fest, dass Sie tats√§chlich den Designer verwenden m√ºssen, nicht die Fabrik. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c20/5e7/be1/c205e7be1603914e310bfb703f25e157.jpg"><br><br>  Hier betr√§gt der Standardwert f√ºr die Schl√ºsselgr√∂√üe 2048 Bit, was bereits viel besser ist.  Was noch besser ist - hier schaffen wir es endlich, die Schl√ºsselgr√∂√üe auf 3 Kilobit einzustellen.  Wie sie sagen, Leistung freigeschaltet. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich m√∂chte Sie daran erinnern, dass alle unsere bisherigen Bem√ºhungen nur auf die Schaffung von RSA beschr√§nkt waren. Wir haben noch nicht einmal mit der Verschl√ºsselung begonnen. Es gibt noch Fragen, die wir zuerst beantworten m√ºssen. Inwieweit k√∂nnen Sie sich f√ºr den Anfang auf Standardschl√ºsselgr√∂√üen verlassen? Die Implementierung der RSA-Factory kann √ºberschrieben werden </font></font><code>machine.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, daher kann sie sich ohne Ihr Wissen √§ndern (z. B. kann ein Systemadministrator sie √§ndern). Dies bedeutet, dass sich auch die Standardschl√ºsselgr√∂√üe √§ndern kann. Daher sollten Sie den standardm√§√üig angegebenen Werten niemals vertrauen. Die Schl√ºsselgr√∂√üe sollte immer unabh√§ngig festgelegt werden. Wie gut sind die Standard-RSA-Schl√ºsselgr√∂√üen? In .NET gibt es zwei RSA-Implementierungen, eine basierend </font></font><code>RSACryptoServiceProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und eine basierend</font></font><code>RSACng</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In der ersten ist die Standardgr√∂√üe 1 Kilobit, in den zweiten beiden. Vergleichen wir diese Werte zum Spa√ü mit denen im Bitcoin-Netzwerk (BCN). Ich entschuldige mich im Voraus daf√ºr, dass ich ein schmerzhaftes Thema angesprochen habe, aber wir werden weder Bitcoin noch Kryptow√§hrung diskutieren, sondern nur √ºber das Netzwerk selbst sprechen. Sie hat eine ver√∂ffentlichte Hashrate, die jeden Monat w√§chst und heute 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hashes pro Sekunde entspricht. Dies entspricht 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">90</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hashes pro Jahr. Nehmen wir der Einfachheit halber an, dass ein Hash einer grundlegenden Operation entspricht - obwohl dies nicht ganz zutrifft, ist es komplexer. Wenn Sie B√ºcher √ºber Kryptographie lesen, die von echten Fachleuten geschrieben wurden, und nicht von Leuten wie mir, dann wissen Sie, dass 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operationen (dh eine Minute BCN) ausreichen, um einen 1-Kilobit-RSA-Schl√ºssel zu knacken, und 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">90</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ein Jahr BCN) - um einen 2-Kilobit-Schl√ºssel zu knacken. Beide Werte sollten uns Angst machen - das kann mit vorhandenen Technologien erreicht werden. Aus diesem Grund empfehle ich dringend, dass Sie die Schl√ºsselgr√∂√üe immer selbst festlegen und mindestens 3 Kilobit gro√ü machen. Wenn die Leistung dies zul√§sst, ist 4. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In .NET ist es nicht so einfach, herauszufinden, wie √∂ffentliche und private Schl√ºssel exportiert werden. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ea/836/078/4ea8360788f3ffdbb6a07dfe9c0587e0.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oben auf der Folie sehen Sie zwei Instanzen des RSA-Schl√ºssels, die erste von </font></font><code>RSACryptoServiceProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die zweite von</font></font><code>RSACng</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jeweils 4 Kilobit. Der folgende Code wird verwendet, um den √∂ffentlichen und den privaten Schl√ºssel aus beiden Instanzen zu extrahieren. Es sollte beachtet werden, dass beide APIs sehr unterschiedlich sind - unterschiedlicher Code, unterschiedliche Methoden, unterschiedliche Parameter. Wenn wir au√üerdem die Gr√∂√üen der √∂ffentlichen Schl√ºssel der ersten und zweiten Kopie vergleichen, werden wir feststellen, dass sie vergleichbar sind, jeweils ungef√§hr ein halbes Kilobyte. Der private Schl√ºssel f√ºr die neue RSA-Implementierung ist jedoch viel kleiner als der alte. Es ist notwendig, dies zu ber√ºcksichtigen und die Einheitlichkeit zu beachten, um diese beiden APIs nicht miteinander zu st√∂ren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles, was wir bisher mit RSA gemacht haben, ist darauf hinausgegangen, eine Arbeitskopie zu erhalten. Versuchen Sie nun, etwas zu verschl√ºsseln. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c88/fb5/c3c/c88fb5c3ca4ee8a62b9b0bd2595291cf.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie ein Array von Bytes, das unser Klartext sein wird (</font></font><code>data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), und dann werden wir es mit einem dieser Additionsmodi verschl√ºsseln, die keine Ausnahme ausgel√∂st haben. Aber diesmal haben wir eine Ausnahme. Dies ist eine Ausnahme von einem ung√ºltigen Parameter. aber √ºber welchen Parameter sprechen wir? Ich habe keine Ahnung - und Microsoft h√∂chstwahrscheinlich auch. Wenn wir versuchen, dieselbe Methode mit anderen Erg√§nzungsmodi auszuf√ºhren, erhalten wir jeweils dieselbe Ausnahme. Der Punkt befindet sich also nicht im Erg√§nzungsmodus. Das Problem liegt also im Quellcode selbst. Es ist schwer zu sagen, was mit ihm los ist, also versuchen wir es f√ºr alle F√§lle zu halbieren. Diesmal ist die Verschl√ºsselung erfolgreich. Wir sind ratlos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht ist der springende Punkt, dass wir die SHA-1-Erg√§nzung verwendet haben? Wie wir wissen, ist SHA-1 keine kryptografisch starke Funktion mehr, daher bestehen unsere Pr√ºfer und die Compliance-Abteilung darauf, dass wir es loswerden. Ersetzen Sie </font></font><code>OaepSHA1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch </font></font><code>OaepSHA256</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, zumindest wird es die Auditoren beruhigen. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/29e/7ed/275/29e7ed275ae1eb8deea59683289b5b6b.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir jedoch versuchen zu verschl√ºsseln, erhalten wir erneut die Ausnahme des falschen Parameters. Diese ganze Situation wird durch die Tatsache verursacht, dass die Beschr√§nkung der Gr√∂√üe des Textes, der auf die kryptografische Funktion √ºbertragen werden kann, nicht nur vom Erg√§nzungsmodus, sondern auch von der Gr√∂√üe des Schl√ºssels abh√§ngt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versuchen wir herauszufinden, wie genau diese Zauberformel aussieht, die die maximale Menge an verschl√ºsselten Daten bestimmt. Es muss in der Methode sein</font></font><code>int GetMaxDataSizeForEnc(RSAEncryptionPadding pad)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der dieses Volumen berechnet, nachdem er den Erg√§nzungsmodus am Eingang erhalten hat. Der Hauptnachteil dieser Methode ist, dass sie nicht existiert, ich habe sie erfunden. Ich versuche zu vermitteln, dass uns nicht einmal die grundlegendsten Informationen zur Verf√ºgung stehen, die ein Entwickler ben√∂tigt, um RSA korrekt zu verwenden. Vielen Dank, Microsoft.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sind die Gr√ºnde, warum RSA auch zur Unterschrift vermieden werden sollte. Wie ich hoffentlich zeigen konnte, sind die APIs f√ºr RSA in .NET √§u√üerst unbefriedigend. Sie sind gezwungen, viele Entscheidungen bez√ºglich des Erg√§nzungsmodus, der Datengr√∂√üe und dergleichen zu treffen, was unerw√ºnscht ist. F√ºr eine 128-Bit-Sicherheitsstufe ben√∂tigen Sie au√üerdem mindestens einen sehr sperrigen 4-Kilobyte-Schl√ºssel. Sie erhalten einen privaten Kilobyte-Schl√ºssel, einen √∂ffentlichen Schl√ºssel mit einem halben Kilobyte und eine Signatur mit einem halben Kilobyte. In vielen Szenarien sind solche Werte m√∂glicherweise nicht w√ºnschenswert. Und wenn Sie versuchen, eine 256-Bit-Sicherheitsstufe zu erreichen, ben√∂tigen Sie √ºberhaupt einen riesigen Schl√ºssel - 15360 Bit. In RSA ist die Verwendung eines solchen Schl√ºssels fast unm√∂glich. Auf meinem Laptop wird eine solche Taste eineinhalb Minuten lang generiert.Dar√ºber hinaus implementiert der RSA auf einer fundamentalen Ebene als Algorithmus unabh√§ngig von der Implementierung sehr langsam eine Signatur. Warum ist uns die Signaturgeschwindigkeit wichtig? Wenn Sie TLS mit RSA-Zertifikaten verwenden, erfolgt die Signatur auf dem Server. Und wir als Entwickler sind am meisten davon betroffen, was genau auf dem Server passiert. Wir sind daf√ºr verantwortlich. Der Durchsatz ist f√ºr uns wichtig. Zusammenfassend m√∂chte ich noch einmal empfehlen, RSA nicht zu verwenden.Ich m√∂chte noch einmal empfehlen, RSA nicht zu verwenden.Ich m√∂chte noch einmal empfehlen, RSA nicht zu verwenden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was kann in diesem Fall den RSA ersetzen? Ich m√∂chte Ihnen moderne elliptische kryptografische Grundelemente vorstellen. Beachten Sie zun√§chst den ECDSA (Digital Signature Algorithm), der anstelle von RSA f√ºr Signaturen verwendet werden kann. In dieser und den folgenden Abk√ºrzungen ist EC ein generisches Pr√§fix, das f√ºr Elliptic-Curve (‚Äûelliptical‚Äú) steht. Unter securitydriven.net/inferno/#DSA Signatures finden Sie Beispiel-ECDSA-Code, der √ºbrigens in .NET enthalten ist. Ein weiterer wichtiger Algorithmus ist ECIES (Integrated Encryption Scheme, ‚Äûelliptisches integriertes Verschl√ºsselungsschema‚Äú). Dieser Algorithmus kann anstelle von RSA eine Hybridverschl√ºsselung durchf√ºhren, dh Sie generieren einen symmetrischen Schl√ºssel, verschl√ºsseln die Daten damit und verschl√ºsseln dann den Schl√ºssel selbst.Beispielcode finden Sie unter securitydriven.net/inferno/#ECIES Beispiel. Ein weiterer sehr wichtiger Algorithmus ist ECDH (Diffie-Hellman-Schl√ºsselaustausch, ‚ÄûDiffie-Hellman-Schl√ºsselaustausch‚Äú). Sie k√∂nnen damit Schl√ºssel f√ºr die symmetrische Verschl√ºsselung zwischen zwei Parteien mit bekannten √∂ffentlichen Schl√ºsseln erstellen. In einigen Situationen und Verwendungsmethoden erm√∂glicht es direkte Geheimhaltung (</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorw√§rtsgeheimnis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Der Link </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">securitydriven.net/inferno/#DHM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Key Exchange verf√ºgbar Beispielcode.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Gespr√§ch √ºber asymmetrische Verschl√ºsselung zusammenzufassen. Sie sollten immer APIs auf hoher Ebene verwenden, die Sie nicht zwingen, Entscheidungen zu treffen, f√ºr die Sie nicht bereit sind. Ich w√ºrde auch empfehlen, RSA nicht mehr zu verwenden. Dies ist nat√ºrlich leichter gesagt als getan, da wir alle mit gro√üen, bereits erstellten Anwendungen arbeiten, die m√∂glicherweise nicht vollst√§ndig √ºberarbeitet werden. In diesem Fall m√ºssen Sie zumindest lernen, wie Sie RSA richtig verwenden. Au√üerdem rate ich Ihnen, sich mit modernen elliptischen kryptografischen Algorithmen (ECDSA, ECDH, ECIES) vertraut zu machen. Schlie√ülich ist es wichtig, dass die Kryptografie auf hoher Ebene nicht alle Probleme auf magische Weise l√∂st. Sie m√ºssen sich daher an die Ziele erinnern, die Sie verfolgen. Ich zitiere aus StackOverflow, dem ich voll und ganz zustimme: ‚ÄûKryptographie allein l√∂st keine Probleme.Durch die symmetrische Verschl√ºsselung wird der Datenschutz nur zu einem Schl√ºsselverwaltungsproblem. ‚Äú</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich werde ein paar Worte zu Ressourcen sagen, die f√ºr Sie n√ºtzlich sein k√∂nnen. Es gibt eine relativ akzeptable hochrangige </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SecurityDriven.Inferno-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek </font><font style="vertical-align: inherit;">mit guter Dokumentation. Es gibt ein wundervolles Buch, Serious Cryptography von Jean-Philippe Aumasson, Serious Cryptography. Es bietet einen √úberblick √ºber den aktuellen Stand der Kryptographie unter Ber√ºcksichtigung der neuesten Innovationen. Au√üerdem habe ich das bereits erw√§hnte Buch Application Security in .NET, kurz und b√ºndig, geschrieben, das gemeinfrei ist. Es enth√§lt noch mehr Informationen zu .NET-Sicherheitsfallen. Schlie√ülich hat Slideshare eine hervorragende Pr√§sentation von Vladimir Kochetkov, die die Grundlagen der Anwendungssicherheitstheorie auf eine etwas vereinfachte, aber sehr solide Weise umrei√üt und verschiedene Gefahrenquellen erkl√§rt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns abschlie√üend einige zus√§tzliche Beispiele sehen, die ich vorbereitet habe. Ganz am Anfang habe ich √ºber die vierte Stufe der Kryptoaufkl√§rung gesprochen, in der erkannt wird, dass die beste L√∂sung m√∂glicherweise √ºberhaupt keine Kryptographie ben√∂tigt. Schauen wir uns ein Beispiel f√ºr eine solche L√∂sung an. Werfen wir einen Blick auf den klassischen .NET-Mechanismus - CSRF (Cross-Site Request Forgery, ‚ÄûCross-Site Request Forgery‚Äú), der zum Schutz vor einer Klasse von Angriffen, einschlie√ülich Cross-Site Request Forgery, entwickelt wurde. In diesem Modell haben wir einen Benutzeragenten - normalerweise einen Browser. Es wird versucht, eine Verbindung zum Server herzustellen, indem eine GET-Anforderung gesendet wird. Als Antwort sendet der Server ein CSRF-Token, das im HTML-Feld "versteckt" versteckt ist. Dar√ºber hinaus wird der Antwort dasselbe Token als Cookie und als Header zugeordnet.Der Benutzer verarbeitet ein Formular und f√ºhrt einen POST durch, der mit beiden Token zum Server zur√ºckkehrt. Der Server pr√ºft zum einen, ob beide Token gesendet wurden, und zum anderen, ob sie √ºbereinstimmen. Dieser Identit√§tsvergleich erm√∂glicht es dem Server, sich vor einem Angreifer zu sch√ºtzen. Dies ist ein klassischer Mechanismus, der in ASP.NET und ASP.NET Core integriert ist. Mikhail Shcherbakov machte einen ausgezeichneten Bericht, in dem die Arbeit von CSRF im Detail untersucht wurde.</font></font><br><br>     ,    CSRF  .   ,      ‚Äî     ,   ,  ,  .   .  ,  (injection)   ,    .    ‚Äî ,   AJAX,   ‚Äî        . ,   , ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a22/806/cae/a22806caea546a62b7a14d2af7583d48.jpg"><br><br>           ,   <i>‚Äî</i>   .  ,     ,          .     ,  . <br><br><blockquote>  .       DotNext.      DotNext 2018 Moscow ‚Äî   22-23  2018  - ¬´  ¬ª. <br><br> <b>  </b> .  ,  ,    .          !     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428121/">https://habr.com/ru/post/de428121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428111/index.html">Arithmetik beliebiger Genauigkeit in Erlang</a></li>
<li><a href="../de428113/index.html">Auf die Frage nach Bezier-Kurven, Arduino-Geschwindigkeit und einem interessanten Ort oder wie ich das Wochenende verbracht habe</a></li>
<li><a href="../de428115/index.html">Webentwicklung f√ºr E-Commerce: 5 Technologietrends f√ºr 2019</a></li>
<li><a href="../de428117/index.html">Kostenlose Tensorprozessoren von Google in der Colaboratory Cloud</a></li>
<li><a href="../de428119/index.html">"Klassenfeld-Vorschlag" oder "Was ist beim tc39-Commit schief gelaufen"</a></li>
<li><a href="../de428123/index.html">Sicherheitswoche 41: Gute Nachrichten</a></li>
<li><a href="../de428125/index.html">Wer sind Produktanalysen und warum werden sie in einem Team ben√∂tigt?</a></li>
<li><a href="../de428127/index.html">Nginx-Cache: alles neu - gut vergessen alt</a></li>
<li><a href="../de428129/index.html">Einfache Fuzzy-Logik ‚Äûf√ºr das, was f√ºr ein Gasturbinentriebwerk war‚Äú</a></li>
<li><a href="../de428131/index.html">Die ganze Wahrheit √ºber RTOS. Artikel Nr. 17. Ereignisflag-Gruppen: Einf√ºhrung und Basisdienste</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>