<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèø üßôüèª üì¢ Einf√ºhrung in die Kubernetes-Netzwerkrichtlinien f√ºr Sicherheitsexperten ‚Ü©Ô∏è üë©üèø‚Äçüî¨ üîù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : Der Autor des Artikels - Reuven Harrison - verf√ºgt √ºber mehr als 20 Jahre Erfahrung in der Softwareentwicklung und ist heute technisc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung in die Kubernetes-Netzwerkrichtlinien f√ºr Sicherheitsexperten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/443190/"><img src="https://habrastorage.org/webt/dt/ya/kp/dtyakpb8umg8hkfvtfcrll8kc9y.png"><br><br>  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Der Autor des Artikels - Reuven Harrison - verf√ºgt √ºber mehr als 20 Jahre Erfahrung in der Softwareentwicklung und ist heute technischer Direktor und Mitbegr√ºnder von Tufin, einem Unternehmen, das L√∂sungen f√ºr das Management von Sicherheitsrichtlinien entwickelt.</i>  <i>In Anbetracht der Kubernetes-Netzwerkrichtlinien als leistungsstarkes Tool f√ºr die Netzwerksegmentierung in einem Cluster ist er der Ansicht, dass sie in der Praxis nicht so einfach anzuwenden sind.</i>  <i>Dieses Material (ziemlich umfangreich) soll das Wissen von Spezialisten auf diesem Gebiet verbessern und ihnen bei der Erstellung der erforderlichen Konfigurationen helfen.</i> <a name="habracut"></a><br><br>  Heutzutage entscheiden sich viele Unternehmen zunehmend f√ºr Kubernetes, um ihre Anwendungen auszuf√ºhren.  Das Interesse an dieser Software ist so gro√ü, dass manche Kubernetes als "neues Betriebssystem f√ºr Rechenzentren" bezeichnen.  Allm√§hlich wird Kubernetes (oder k8s) als kritischer Teil des Gesch√§fts wahrgenommen, der die Organisation ausgereifter Gesch√§ftsprozesse einschlie√ülich der Netzwerksicherheit erfordert. <br><br>  F√ºr Sicherheitsexperten, die durch die Arbeit mit Kubernetes verwirrt sind, kann die Standardrichtlinie dieser Plattform eine echte Entdeckung sein: Lassen Sie alles zu. <br><br>  Dieses Handbuch hilft Ihnen beim Verst√§ndnis der internen Struktur von Netzwerkrichtlinien.  Verstehen Sie, wie sie sich von den Regeln f√ºr normale Firewalls unterscheiden.  Es werden auch einige Fallstricke beschrieben und Empfehlungen gegeben, die zum Schutz von Anwendungen in Kubernetes beitragen. <br><br><h2>  Kubernetes-Netzwerkrichtlinien </h2><br>  Mit dem Netzwerkrichtlinienmechanismus von Kubernetes k√∂nnen Sie die Interaktion von Anwendungen steuern, die auf der Plattform auf Netzwerkebene bereitgestellt werden (die dritte im OSI-Modell).  In Netzwerkrichtlinien fehlen einige der erweiterten Funktionen moderner Firewalls, wie z. B. die √úberwachung von OSI Level 7 und die Erkennung von Bedrohungen. Sie bieten jedoch ein grundlegendes Ma√ü an Netzwerksicherheit, was ein guter Ausgangspunkt ist. <br><br><h2>  Netzwerkrichtlinien steuern die Kommunikation zwischen Pods </h2><br>  Kubernetes-Workloads werden auf Pods verteilt, die aus einem oder mehreren zusammen bereitgestellten Containern bestehen.  Kubernetes weist jedem Pod eine IP-Adresse zu, auf die von anderen Pods aus zugegriffen werden kann.  In den Netzwerkrichtlinien von Kubernetes werden Berechtigungen f√ºr Pod-Gruppen auf dieselbe Weise festgelegt wie Sicherheitsgruppen in der Cloud, um den Zugriff auf Instanzen virtueller Maschinen zu steuern. <br><br><h2>  Netzwerkrichtlinien definieren </h2><br>  Wie bei anderen Kubernetes-Ressourcen werden Netzwerkrichtlinien in YAML festgelegt.  Im folgenden Beispiel wird dem <code>balance</code> Zugriff auf <code>postgres</code> gew√§hrt: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres namespace: default spec: podSelector: matchLabels: app: postgres ingress: - from: - podSelector: matchLabels: app: balance policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/ee/d3/wf/eed3wfhzcdtuhobly7r3wdhyvhk.png"><br><br>  <i>( <b>Hinweis</b> : Dieser Screenshot wurde wie alle nachfolgenden √§hnlichen nicht mit den nativen Tools von Kubernetes erstellt, sondern mit dem Tufin Orca-Tool, das vom Autor des Originalartikels entwickelt und am Ende des Artikels erw√§hnt wurde.)</i> <br><br>  Das Definieren Ihrer eigenen Netzwerkrichtlinie erfordert grundlegende YAML-Kenntnisse.  Diese Sprache basiert auf Einr√ºckungen (angegeben durch Leerzeichen, nicht durch Tabulatoren).  Ein einger√ºcktes Element geh√∂rt zum n√§chsten einger√ºckten Element dar√ºber.  Ein neues Listenelement beginnt mit einem Bindestrich, alle anderen Elemente sind <i>Schl√ºsselwerte</i> . <br><br>  Nachdem Sie die Richtlinie in YAML <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beschrieben haben</a> , erstellen Sie sie mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kubectl</a> im Cluster: <br><br><pre> <code class="bash hljs">kubectl create -f policy.yaml</code> </pre> <br><h2>  Netzwerkrichtlinienspezifikation </h2><br>  Die Kubernetes-Netzwerkrichtlinienspezifikation enth√§lt vier Elemente: <br><br><ol><li>  <code>podSelector</code> : <code>podSelector</code> die von dieser Richtlinie betroffenen Pods (Ziele) - obligatorisch; </li><li>  <code>policyTypes</code> : <code>policyTypes</code> an, welche Arten von Richtlinien darin enthalten sind: Ingress und / oder Egress - optional. Ich empfehle jedoch, dass Sie sie in allen F√§llen explizit registrieren. </li><li>  <code>ingress</code> : Definiert den zul√§ssigen <b>eingehenden</b> Verkehr zu den Ziel-Pods - optional; </li><li>  <code>egress</code> : Definiert den zul√§ssigen <b>ausgehenden</b> Datenverkehr von den Ziel-Pods - optional. </li></ol><br>  Ein Beispiel von der Kubernetes-Website (ich habe die <code>role</code> durch die <code>app</code> ) zeigt, wie alle vier Elemente verwendet werden: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: test-network-policy namespace: default spec: podSelector: # &lt;&lt;&lt; matchLabels: app: db policyTypes: # &lt;&lt;&lt; - Ingress - Egress ingress: # &lt;&lt;&lt; - from: - ipBlock: cidr: 172.17.0.0/16 except: - 172.17.1.0/24 - namespaceSelector: matchLabels: project: myproject - podSelector: matchLabels: role: frontend ports: - protocol: TCP port: 6379 egress: # &lt;&lt;&lt; - to: - ipBlock: cidr: 10.0.0.0/24 ports: - protocol: TCP port: 5978</code> </pre> <br><img src="https://habrastorage.org/webt/ln/sa/ni/lnsanisggaar5tf3lbda8njxaau.png"><br><img src="https://habrastorage.org/webt/bo/re/in/borein4ll_4hoovj6vdhlo_zfee.png"><br><br>  Bitte beachten Sie, dass alle vier Elemente optional sind.  Es wird nur <code>podSelector</code> , andere Parameter k√∂nnen nach Wunsch verwendet werden. <br><br>  Wenn Sie <code>policyTypes</code> weglassen, wird die Richtlinie wie folgt interpretiert: <br><br><ul><li>  Standardm√§√üig wird davon ausgegangen, dass es die Eingangsseite definiert.  Wenn die Richtlinie dies nicht ausdr√ºcklich angibt, wird das System ber√ºcksichtigen, dass der gesamte Datenverkehr verboten ist. </li><li>  Das Verhalten auf der Austrittsseite wird durch das Vorhandensein oder Fehlen des entsprechenden Austrittsparameters bestimmt. </li></ul><br>  Um Fehler zu vermeiden, empfehle ich <b>, <code>policyTypes</code> immer explizit anzugeben</b> . <br><br>  In √úbereinstimmung mit der obigen Logik verbietet die Richtlinie den gesamten Datenverkehr, wenn die <code>ingress</code> und / oder <code>egress</code> weggelassen werden (siehe "Stripping-Regel" unten). <br><br><h2>  Die Standardrichtlinie lautet Zulassen </h2><br>  Wenn keine Richtlinien definiert sind, l√§sst Kubernetes standardm√§√üig den gesamten Datenverkehr zu.  Alle Pods k√∂nnen Informationen miteinander austauschen.  Aus Sicherheitsgr√ºnden mag dies nicht intuitiv erscheinen, aber denken Sie daran, dass Kubernetes urspr√ºnglich von Entwicklern erstellt wurde, um die Interoperabilit√§t von Anwendungen sicherzustellen.  Netzwerkrichtlinien wurden sp√§ter hinzugef√ºgt. <br><br><h2>  Namespaces </h2><br>  Namespaces sind ein kollaborativer Mechanismus von Kubernetes.  Sie dienen dazu, logische Umgebungen voneinander zu isolieren, w√§hrend der Datenaustausch zwischen Leerzeichen standardm√§√üig zul√§ssig ist. <br><br>  Wie die meisten Kubernetes-Komponenten befinden sich Netzwerkrichtlinien in einem bestimmten Namespace.  Im <code>metadata</code> k√∂nnen Sie angeben, zu welchem ‚Äã‚ÄãBereich die Richtlinie geh√∂rt: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: test-network-policy namespace: my-namespace # &lt;&lt;&lt; spec: ...</code> </pre> <br>  Wenn der Namespace nicht explizit in die Metadaten geschrieben wird, verwendet das System den in kubectl angegebenen Namespace (standardm√§√üig <code>namespace=default</code> ): <br><br><pre> <code class="bash hljs">kubectl apply -n my-namespace -f namespace.yaml</code> </pre> <br>  Ich empfehle <b>, einen Namespace explizit anzugeben, es</b> sei denn, Sie schreiben eine Richtlinie, die f√ºr mehrere Namespaces gleichzeitig vorgesehen ist. <br><br>  <b>Das</b> Hauptelement <code>podSelector</code> in einer Richtlinie w√§hlt Pods aus dem Namespace aus, zu dem die Richtlinie geh√∂rt (der Zugriff auf Pods aus einem anderen Namespace wird verweigert). <br><br>  In √§hnlicher Weise k√∂nnen podSelectors <b>in</b> Eingangs- <b>und Ausgangsbl√∂cken</b> Pods nur aus ihrem Namespace ausw√§hlen, es sei denn, Sie kombinieren sie nat√ºrlich mit <code>namespaceSelector</code> (dies wird im Abschnitt ‚ÄûFiltern nach Namespaces und Pods‚Äú erl√§utert). . <br><br><h2>  Richtlinienbenennungsregeln </h2><br>  Richtliniennamen sind innerhalb eines einzelnen Namespace eindeutig.  Es k√∂nnen keine zwei Richtlinien mit demselben Namen in einem Bereich vorhanden sein, aber es k√∂nnen Richtlinien mit demselben Namen in verschiedenen Bereichen vorhanden sein.  Dies ist n√ºtzlich, wenn Sie dieselbe Richtlinie auf mehrere Bereiche erneut anwenden m√∂chten. <br><br>  Ich mag besonders eine Art zu benennen.  Es besteht darin, den Namespace-Namen mit den Ziel-Pods zu kombinieren.  Zum Beispiel: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres # &lt;&lt;&lt; namespace: default spec: podSelector: matchLabels: app: postgres ingress: - from: - podSelector: matchLabels: app: admin policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/pp/rf/6a/pprf6aa0w2bysbuw6_-lbt926mi.png"><br><br><h2>  Etiketten </h2><br>  Benutzerdefinierte Beschriftungen k√∂nnen an Kubernetes-Objekte wie Pods und Namespaces angeh√§ngt werden.  Beschriftungen entsprechen Tags in der Cloud.  Kubernetes-Netzwerkrichtlinien verwenden Beschriftungen, um die <b>Pods</b> auszuw√§hlen, f√ºr die sie gelten: <br><br><pre> <code class="plaintext hljs">podSelector: matchLabels: role: db</code> </pre> <br>  ... oder <b>die Namespaces,</b> f√ºr die sie gelten.  In diesem Beispiel werden alle Pods in den Namespaces mit den entsprechenden Beschriftungen ausgew√§hlt: <br><br><pre> <code class="plaintext hljs">namespaceSelector: matchLabels: project: myproject</code> </pre> <br>  Eine Einschr√§nkung: Wenn Sie <code>namespaceSelector</code> <b>stellen Sie sicher, dass die von Ihnen ausgew√§hlten</b> <code>namespaceSelector</code> <b>die gew√ºnschte Bezeichnung enthalten</b> .  <code>kube-system</code> Sie, dass integrierte Namespaces wie <code>default</code> und <code>kube-system</code> standardm√§√üig keine Beschriftungen enthalten. <br><br>  Sie k√∂nnen dem Bereich wie folgt eine Beschriftung hinzuf√ºgen: <br><br><pre> <code class="bash hljs">kubectl label namespace default namespace=default</code> </pre> <br>  In diesem Fall sollte sich der Namespace im <code>metadata</code> auf den tats√§chlichen Namen des Space und nicht auf die Bezeichnung beziehen: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: test-network-policy namespace: default # &lt;&lt;&lt; spec: ...</code> </pre> <br><h2>  Quelle und Ziel </h2><br>  Richtlinien f√ºr Firewalls bestehen aus Regeln mit Quellen und Zielen.  Kubernetes Netzwerkrichtlinien werden f√ºr diesen Zweck definiert - eine Reihe von Pods, auf die sie angewendet werden, und legen dann Regeln f√ºr eingehenden (eingehenden) und / oder ausgehenden (ausgehenden) Verkehr fest.  In unserem Beispiel sind das Richtlinienziel alle Pods im <code>default</code> Namespace mit einer Bezeichnung mit dem <code>app</code> Schl√ºssel und dem <code>db</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: test-network-policy namespace: default spec: podSelector: matchLabels: app: db # &lt;&lt;&lt; policyTypes: - Ingress - Egress ingress: - from: - ipBlock: cidr: 172.17.0.0/16 except: - 172.17.1.0/24 - namespaceSelector: matchLabels: project: myproject - podSelector: matchLabels: role: frontend ports: - protocol: TCP port: 6379 egress: - to: - ipBlock: cidr: 10.0.0.0/24 ports: - protocol: TCP port: 5978</code> </pre> <br><img src="https://habrastorage.org/webt/zd/un/wi/zdunwi6xxqfdkvd7tj0qqpmjxly.png"><br><img src="https://habrastorage.org/webt/se/dj/wp/sedjwp5-arw7sxn7hm4dblgqhku.png"><br><br>  Der Eingangsunterabschnitt in dieser Richtlinie √∂ffnet eingehenden Datenverkehr f√ºr die Ziel-Pods.  Mit anderen Worten, Ingress ist die Quelle und das Ziel ist der geeignete Empf√§nger.  In √§hnlicher Weise ist der Ausgang das Ziel und das Ziel ist seine Quelle. <br><br><img src="https://habrastorage.org/webt/rs/nf/u9/rsnfu97eapuetrrhbwejb-awnas.png"><br><br>  <i>Dies entspricht zwei Regeln f√ºr die Firewall: Ingress ‚Üí Target;</i>  <i>Ziel ‚Üí Austritt.</i> <br><br><h2>  Ausgang und DNS (wichtig!) </h2><br>  Achten Sie bei der Begrenzung des ausgehenden Datenverkehrs <b>besonders auf DNS.</b> Kubernetes verwendet diesen Dienst, um Dienste IP-Adressen zuzuordnen.  Die folgende Richtlinie funktioniert beispielsweise nicht, da Sie der <code>balance</code> Anwendung keinen Zugriff auf DNS gew√§hrt haben: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.balance namespace: default spec: podSelector: matchLabels: app: balance egress: - to: - podSelector: matchLabels: app: postgres policyTypes: - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/6w/dy/jf/6wdyjftwhfiynlxrx22vivumtli.png"><br><br>  Sie k√∂nnen das Problem beheben, indem Sie den Zugriff auf den DNS-Dienst √∂ffnen: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.balance namespace: default spec: podSelector: matchLabels: app: balance egress: - to: - podSelector: matchLabels: app: postgres - to: # &lt;&lt;&lt; ports: # &lt;&lt;&lt; - protocol: UDP # &lt;&lt;&lt; port: 53 # &lt;&lt;&lt; policyTypes: - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/z4/np/5m/z4np5m-afkmcbkqlgoxufjgc4fm.png"><br><br>  Das letzte to-Element ist leer und w√§hlt daher indirekt <b>alle Pods in allen Namespaces aus</b> , sodass <code>balance</code> DNS-Abfragen an den entsprechenden Kubernetes-Dienst senden kann (dies funktioniert normalerweise im <code>kube-system</code> ). <br><br>  Dieser Ansatz funktioniert, ist jedoch zu <b>freiz√ºgig und unsicher</b> , da Sie damit DNS-Abfragen au√üerhalb des Clusters leiten k√∂nnen. <br><br>  Sie k√∂nnen es in drei aufeinander folgenden Schritten verbessern. <br><br>  1. Erlauben Sie DNS-Abfragen nur <b>innerhalb des</b> Clusters, indem Sie <code>namespaceSelector</code> hinzuf√ºgen: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.balance namespace: default spec: podSelector: matchLabels: app: balance egress: - to: - podSelector: matchLabels: app: postgres - to: - namespaceSelector: {} # &lt;&lt;&lt; ports: - protocol: UDP port: 53 policyTypes: - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/a1/hk/8v/a1hk8vmrton9izmj1jwhxtz-q1e.png"><br><br>  2. Erlauben Sie DNS-Abfragen nur im Namespace des <code>kube-system</code> . <br><br>  <code>kubectl label namespace kube-system namespace=kube-system</code> eine Bezeichnung <code>kube-system</code> : <code>kubectl label namespace kube-system namespace=kube-system</code> - und registrieren Sie sie mit <code>namespaceSelector</code> in der Richtlinie: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.balance namespace: default spec: podSelector: matchLabels: app: balance egress: - to: - podSelector: matchLabels: app: postgres - to: - namespaceSelector: # &lt;&lt;&lt; matchLabels: # &lt;&lt;&lt; namespace: kube-system # &lt;&lt;&lt; ports: - protocol: UDP port: 53 policyTypes: - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/q6/e2/ed/q6e2edqwfz63nbamlvk2v5zpjhy.png"><br><br>  3. Paranoide k√∂nnen noch weiter gehen und DNS-Abfragen auf einen bestimmten DNS-Dienst im <code>kube-system</code> .  Im Abschnitt ‚ÄûFiltern nach Namespaces &amp; Pods‚Äú wird erl√§utert, wie dies erreicht wird. <br><br>  Eine weitere Option ist das Aufl√∂sen von DNS auf Namespace-Ebene.  In diesem Fall muss es nicht f√ºr jeden Dienst ge√∂ffnet werden: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.dns namespace: default spec: podSelector: {} # &lt;&lt;&lt; egress: - to: - namespaceSelector: {} ports: - protocol: UDP port: 53 policyTypes: - Egress</code> </pre> <br>  Ein leerer <code>podSelector</code> w√§hlt alle Pods im Namespace aus. <br><br><img src="https://habrastorage.org/webt/ua/hn/7t/uahn7tgfus08_yt1u-rsilqoi90.png"><br><br><h2>  Erste √úbereinstimmung und Regelreihenfolge </h2><br>  In normalen Firewalls wird die Aktion ("Zulassen" oder "Verweigern") f√ºr ein Paket durch die erste Regel bestimmt, die es erf√ºllt.  <b>In Kubernetes spielt die Reihenfolge der Richtlinien keine Rolle.</b> <br><br>  Wenn keine Richtlinien festgelegt sind, ist standardm√§√üig die Kommunikation zwischen Pods zul√§ssig und sie k√∂nnen Informationen frei austauschen.  Sobald Sie mit der Formulierung von Richtlinien beginnen, wird jeder von mindestens einer davon betroffene Pod gem√§√ü der Disjunktion (logisches ODER) aller Richtlinien, die ihn ausgew√§hlt haben, isoliert.  Pods, die von keiner Richtlinie betroffen sind, bleiben ge√∂ffnet. <br><br>  Sie k√∂nnen dieses Verhalten mithilfe der Abisolierregel √§ndern. <br><br><h2>  Abisolierregel (Verweigern) </h2><br>  Firewall-Richtlinien verbieten im Allgemeinen explizit nicht autorisierten Datenverkehr. <br><br>  <b>Kubernetes hat keine Verweigerungsaktion</b> . Ein √§hnlicher Effekt kann jedoch mit einer regul√§ren (zul√§ssigen) Richtlinie erzielt werden, indem eine leere Gruppe von Quell-Pods (Eingang) ausgew√§hlt wird: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: deny-all namespace: default spec: podSelector: {} policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/65/-s/au/65-sauxptvceaqgedw9xvsadlso.png"><br><br>  Diese Richtlinie w√§hlt alle Pods im Namespace aus und l√§sst den Eingang undefiniert, wodurch der gesamte eingehende Datenverkehr blockiert wird. <br><br>  Ebenso k√∂nnen Sie den gesamten ausgehenden Datenverkehr aus dem Namespace begrenzen: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: deny-all-egress namespace: default spec: podSelector: {} policyTypes: - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/bn/fg/vq/bnfgvqcfwsgaj-jyompezzmhz6q.png"><br><br>  Beachten Sie, dass <b>alle zus√§tzlichen Richtlinien, die den Datenverkehr zu Pods im Namespace zulassen, Vorrang vor dieser Regel haben</b> (√§hnlich wie beim Hinzuf√ºgen einer Zulassungsregel √ºber eine Verweigerungsregel in der Firewall-Konfiguration). <br><br><h2>  Alle zulassen (Any-Any-Any-Allow) </h2><br>  Um eine Allow All-Richtlinie zu erstellen, m√ºssen Sie die oben genannte Verbotsrichtlinie mit einem leeren <code>ingress</code> Element hinzuf√ºgen: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-all namespace: default spec: podSelector: {} ingress: # &lt;&lt;&lt; - {} # &lt;&lt;&lt; policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/bl/x6/ed/blx6edy0ez8h-yrkil5vb0yeb5g.png"><br><br>  Es erm√∂glicht den Zugriff von <b>allen Pods in allen Namespaces (und allen IPs) auf alle Pods im <code>default</code> Namespace</b> .  Dieses Verhalten ist standardm√§√üig aktiviert und muss daher normalerweise nicht zus√§tzlich definiert werden.  Manchmal kann es jedoch erforderlich sein, bestimmte Berechtigungen vor√ºbergehend zu deaktivieren, um das Problem zu diagnostizieren. <br><br>  Die Regel kann eingegrenzt werden und nur auf einen <b>bestimmten Satz von Pods</b> ( <code>app:balance</code> ) im <code>default</code> Namespace zugreifen: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-all-to-balance namespace: default spec: podSelector: matchLabels: app: balance ingress: - {} policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/ji/jn/ki/jijnkiy1fzkligxx9b2okk8arm8.png"><br><br>  Die folgende Richtlinie erm√∂glicht den gesamten eingehenden und ausgehenden Datenverkehr, einschlie√ülich des Zugriffs auf IP-Adressen au√üerhalb des Clusters: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-all spec: podSelector: {} ingress: - {} egress: - {} policyTypes: - Ingress - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/yx/eq/c4/yxeqc4hamtqwvirrodsrym7y4iy.png"><br><img src="https://habrastorage.org/webt/bi/nu/ob/binuob-mafzfz6w_r-2fmdseu2c.png"><br><br><h2>  Mehrere Richtlinien kombinieren </h2><br>  Richtlinien werden mithilfe des logischen ODER auf drei Ebenen kombiniert.  Die Berechtigungen f√ºr jeden Pod werden in √úbereinstimmung mit der Disjunktion aller Richtlinien festgelegt, die ihn betreffen: <br><br>  1. In den Feldern <code>from</code> und <code>to</code> k√∂nnen Sie drei Arten von Elementen definieren (alle werden mit ODER kombiniert): <br><br><ul><li>  <code>namespaceSelector</code> - W√§hlt den gesamten Namespace aus. </li><li>  <code>podSelector</code> - w√§hlt Pods aus; </li><li>  <code>ipBlock</code> - w√§hlt ein Subnetz aus. </li></ul><br>  Gleichzeitig ist die Anzahl der Elemente (auch der gleichen) in den Unterabschnitten <code>from</code> / <code>to</code> nicht begrenzt.  Alle von ihnen werden durch logisches ODER kombiniert. <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres namespace: default spec: ingress: - from: - podSelector: matchLabels: app: indexer - podSelector: matchLabels: app: admin podSelector: matchLabels: app: postgres policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/_y/pu/xy/_ypuxynlq6wslkjk65yyj5_zwsi.png"><br><br>  2. Innerhalb der Richtlinie kann der <code>ingress</code> viele Elemente enthalten (kombiniert durch logisches ODER).  In √§hnlicher Weise kann der <code>egress</code> viele Elemente enthalten (auch durch eine Klausel verbunden): <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres namespace: default spec: ingress: - from: - podSelector: matchLabels: app: indexer - from: - podSelector: matchLabels: app: admin podSelector: matchLabels: app: postgres policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/4t/-l/f9/4t-lf9a8fm1f4whkitifyhgyfee.png"><br><br>  3. Verschiedene Richtlinien werden auch durch logisches ODER kombiniert <br><br>  Beim Kombinieren gibt es jedoch eine Einschr√§nkung, auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chris Cooney</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hingewiesen hat</a> : Kubernetes kann Richtlinien nur mit verschiedenen <code>policyTypes</code> ( <code>Ingress</code> oder <code>Egress</code> ) kombinieren.  Die Richtlinien, die den Eingang (oder Ausgang) definieren, √ºberschreiben sich gegenseitig. <br><br><h2>  Die Beziehung zwischen Namespaces </h2><br>  Standardm√§√üig ist der Informationsaustausch zwischen Namespaces zul√§ssig.  Dies kann mithilfe einer unzul√§ssigen Richtlinie ge√§ndert werden, die ausgehenden und / oder eingehenden Datenverkehr in den Namespace einschr√§nkt (siehe "Stripping-Regel" oben). <br><br>  Durch Blockieren des Zugriffs auf den Namespace (siehe "Stripping-Regel" oben) k√∂nnen Sie Ausnahmen von der restriktiven Richtlinie machen, indem Sie Verbindungen von einem bestimmten Namespace mit <code>namespaceSelector</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: database.postgres namespace: database spec: podSelector: matchLabels: app: postgres ingress: - from: - namespaceSelector: # &lt;&lt;&lt; matchLabels: namespace: default policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/gh/-0/ed/gh-0edsyfhl5st5_8nngwadmoai.png"><br><br>  Infolgedessen haben alle Pods im <code>default</code> Namespace Zugriff auf die <code>postgres</code> Pods im <code>database</code> Namespace.  Was aber, wenn Sie den Zugriff auf <code>postgres</code> nur f√ºr bestimmte Pods im <code>default</code> Namespace √∂ffnen m√∂chten? <br><br><h2>  Filtern nach Namespaces &amp; Pods </h2><br>  Mit Kubernetes Version 1.11 und h√∂her k√∂nnen Sie die Operatoren <code>namespaceSelector</code> und <code>podSelector</code> mit logischem I kombinieren. Es sieht folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: database.postgres namespace: database spec: podSelector: matchLabels: app: postgres ingress: - from: - namespaceSelector: matchLabels: namespace: default podSelector: # &lt;&lt;&lt; matchLabels: app: admin policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/47/_b/op/47_bopr6mjii5-qkujgiwgs2bku.png"><br><br>  Warum wird es als UND anstelle des √ºblichen ODER interpretiert? <br><br>  Beachten Sie, dass <code>podSelector</code> nicht mit einem Bindestrich beginnt.  In YAML bedeutet dies, dass sich <code>podSelector</code> und der davor stehende <code>namespaceSelector</code> auf dasselbe Listenelement beziehen.  Daher werden sie durch logisches I kombiniert. <br><br>  Das Hinzuf√ºgen eines Bindestrichs vor <code>podSelector</code> f√ºhrt zu einem neuen Listenelement, das mit dem vorherigen <code>namespaceSelector</code> mithilfe eines logischen ODER kombiniert wird. <br><br>  <b>Geben Sie</b> einen leeren <code>namespaceSelector</code> ein, um Pods mit einer bestimmten Bezeichnung <b>in allen Namespaces</b> auszuw√§hlen: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: database.postgres namespace: database spec: podSelector: matchLabels: app: postgres ingress: - from: - namespaceSelector: {} podSelector: matchLabels: app: admin policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/t9/lc/vn/t9lcvnyl17u39krw9vn1nc-5xmk.png"><br><br><h2>  Mehrere Beschriftungen werden mit UND kombiniert </h2><br>  Regeln f√ºr eine Firewall mit vielen Objekten (Hosts, Netzwerke, Gruppen) werden mithilfe eines logischen ODER kombiniert.  Die folgende Regel funktioniert, wenn die Quelle des Pakets mit <code>Host_1</code> ODER <code>Host_2</code> : <br><br><pre> <code class="plaintext hljs">| Source | Destination | Service | Action | | ----------------------------------------| | Host_1 | Subnet_A | HTTPS | Allow | | Host_2 | | | | | ----------------------------------------|</code> </pre> <br>  Umgekehrt werden in Kubernetes verschiedene Beschriftungen in <code>podSelector</code> oder <code>namespaceSelector</code> durch logisches I kombiniert. Mit der folgenden Regel werden beispielsweise Pods ausgew√§hlt, die beide Beschriftungen haben: <code>role=db</code> AND <code>version=v2</code> : <br><br><pre> <code class="plaintext hljs">podSelector: matchLabels: role: db version: v2</code> </pre> <br>  Die gleiche Logik gilt f√ºr alle Arten von Operatoren: Richtlinienzielselektoren, Pod-Selektoren und Namespace-Selektoren. <br><br><h2>  Subnetze und IP-Adressen (IPBlocks) </h2><br>  Firewalls verwenden VLANs, IP-Adressen und Subnetze, um ein Netzwerk zu segmentieren. <br><br>  In Kubernetes werden Pods automatisch IP-Adressen zugewiesen und k√∂nnen sich h√§ufig √§ndern. Daher werden Beschriftungen verwendet, um Pods und Namespaces in Netzwerkrichtlinien auszuw√§hlen. <br><br>  <code>ipBlocks</code> ( <code>ipBlocks</code> ) werden verwendet, um eingehende (eingehende) oder ausgehende (ausgehende) externe (Nord-S√ºd) Verbindungen zu steuern.  Diese Richtlinie gew√§hrt beispielsweise allen Pods aus dem <code>default</code> Namespace Zugriff auf den Google DNS-Dienst: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: egress-dns namespace: default spec: podSelector: {} policyTypes: - Egress egress: - to: - ipBlock: cidr: 8.8.8.8/32 ports: - protocol: UDP port: 53</code> </pre> <br><img src="https://habrastorage.org/webt/fm/uc/oa/fmucoaptwhse0i5yx-hsize1d0e.png"><br><br>  Der leere Pod-Selektor in diesem Beispiel bedeutet "Alle Pods im Namespace ausw√§hlen". <br><br>  Diese Richtlinie bietet nur Zugriff auf 8.8.8.8;  Der Zugriff auf eine andere IP wird verweigert.  Daher haben Sie im Wesentlichen den Zugriff auf den internen DNS-Dienst von Kubernetes blockiert.  Wenn Sie es dennoch √∂ffnen m√∂chten, geben Sie es explizit an. <br><br>  Normalerweise schlie√üen sich <code>ipBlocks</code> und <code>podSelectors</code> gegenseitig aus, da die internen IP-Adressen von Pods in <code>ipBlocks</code> nicht verwendet <code>ipBlocks</code> .  <b>Indem Sie interne IP-Pods angeben</b> , lassen Sie tats√§chlich Verbindungen zu / von Pods mit diesen Adressen zu.  In der Praxis wissen Sie nicht, welche IP-Adresse Sie verwenden sollen, weshalb sie nicht zur Auswahl von Pods verwendet werden sollten. <br><br>  Als Gegenbeispiel enth√§lt die folgende Richtlinie alle IPs und erm√∂glicht daher den Zugriff auf alle anderen Pods: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: egress-any namespace: default spec: podSelector: {} policyTypes: - Egress egress: - to: - ipBlock: cidr: 0.0.0.0/0</code> </pre> <br><img src="https://habrastorage.org/webt/yt/dt/ow/ytdtowaueimdgmppg5x9mp7y2ec.png"><br><br>  Sie k√∂nnen den Zugriff nur auf externe IPs √∂ffnen, indem Sie die internen IP-Adressen von Pods ausschlie√üen.  Wenn das Subnetz Ihres Pods beispielsweise 10.16.0.0/14 lautet: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: egress-any namespace: default spec: podSelector: {} policyTypes: - Egress egress: - to: - ipBlock: cidr: 0.0.0.0/0 except: - 10.16.0.0/14</code> </pre> <br><img src="https://habrastorage.org/webt/9a/iz/c4/9aizc4r0bjzljsl0smkwaagpgfm.png"><br><br><h2>  Ports und Protokolle </h2><br>  Normalerweise lauschen Pods an einem Port.  Dies bedeutet, dass Sie Portnummern in Richtlinien einfach weglassen und alles als Standard belassen k√∂nnen.  Es wird jedoch empfohlen, die Richtlinien so restriktiv wie m√∂glich zu gestalten, sodass Sie in einigen F√§llen weiterhin Ports angeben k√∂nnen: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres namespace: default spec: ingress: - from: - podSelector: matchLabels: app: indexer - podSelector: matchLabels: app: admin ports: # &lt;&lt;&lt; - port: 443 # &lt;&lt;&lt; protocol: TCP # &lt;&lt;&lt; - port: 80 # &lt;&lt;&lt; protocol: TCP # &lt;&lt;&lt; podSelector: matchLabels: app: postgres policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/ie/yo/og/ieyoogygmsewwwxtg0ncvsapxmw.png"><br><br>  Beachten Sie, dass der <code>ports</code> Selektor f√ºr alle Elemente in dem darin enthaltenen to- oder <code>from</code> Block gilt.  Um verschiedene Ports f√ºr verschiedene <code>egress</code> anzugeben, teilen Sie den <code>ingress</code> oder <code>egress</code> in mehrere Unterabschnitte mit oder <code>from</code> und auf und listen Sie Ihre Ports in jedem auf: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres namespace: default spec: ingress: - from: - podSelector: matchLabels: app: indexer ports: # &lt;&lt;&lt; - port: 443 # &lt;&lt;&lt; protocol: TCP # &lt;&lt;&lt; - from: - podSelector: matchLabels: app: admin ports: # &lt;&lt;&lt; - port: 80 # &lt;&lt;&lt; protocol: TCP # &lt;&lt;&lt; podSelector: matchLabels: app: postgres policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/bw/_a/8p/bw_a8p4luekpljv4c9zh6p4hw_y.png"><br><br>  Die Standardports funktionieren: <br><br><ul><li>  Wenn Sie die Definition von Ports vollst√§ndig weglassen, bedeutet dies alle Protokolle und alle Ports. </li><li>  Wenn Sie die Protokolldefinition weglassen, bedeutet dies TCP. </li><li>  Wenn Sie die Definition eines Ports weglassen, bedeutet dies alle Ports. </li></ul><br>  Best Practice: Verlassen Sie sich nicht auf die Standardwerte, sondern geben Sie explizit an, was Sie ben√∂tigen. <br><br>  Bitte beachten Sie, dass Pod-Ports und keine Dienste verwendet werden m√ºssen (mehr dazu im n√§chsten Absatz). <br><br><h2>  Sind Richtlinien f√ºr Pods oder Services definiert? </h2><br>  Normalerweise kontaktieren sich Pods in Kubernetes √ºber einen Dienst - einen virtuellen Load Balancer, der den Datenverkehr zu Pods umleitet, die den Dienst implementieren.  Sie k√∂nnten denken, dass Netzwerkrichtlinien den Zugriff auf Dienste steuern, dies ist jedoch nicht der Fall.  <b>Kubernetes-Netzwerkrichtlinien funktionieren mit Pod-Ports, nicht mit Diensten.</b> <br><br> ,    80- ,      8080  pod',       8080. <br><br>     :      (   pod')    . <br><br>      Service Mesh <i>(, .  Istio  ‚Äî . .)</i>     . <br><br><h2>     Ingress,   Egress? </h2><br>   ‚Äî ,  pod     pod' ,       (    egress-),  pod        ( , ,  ingress-). <br><br>         ,       . <br><br>   pod- <b></b>      <b>egress</b> -,        .         pod'- <b></b> .  pod   - ,   (egress)    . <br><br>    pod'- <b></b> ,     <b>ingress</b> -,    .           pod'-.  pod   - ,   (ingress)      . <br><br> .  ¬´Stateful  Stateless¬ª . <br><br><h2>  </h2><br>   Kubernetes    .    ,     ,       . <br><br><h2>       </h2><br>   Kubernetes       (DNS)   egress.             ,   IP- (  aws.com). <br><br><h2>   </h2><br>         . Kubernetes    .      kubectl Kubernetes  ,   ,    .    Kubernetes       .      : <br><br><pre> <code class="plaintext hljs">kubernetes get networkpolicy &lt;policy-name&gt; -o yaml</code> </pre> <br>   ,    Kubernetes        . <br><br><h2>  Ausf√ºhrung </h2><br> Kubernetes      ,    API-,        ,  Container Networking Interface (CNI).     Kubernetes    CNI             .        CNI ,    Kubernetes,    <i>(     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ‚Äî . .)</i> ,   ,   CNI  . <br><br>  ,  Kubernetes   ,         CNI. <br><br><h3> Stateful  Stateless? </h3><br>  CNI Kubernetes,     ,   (, Calico  Linux conntrack).   pod'      TCP-     .       Kubernetes,      (statefulness). <br><br><h2>     </h2><br>          Kubernetes: <br><br><ol><li>   Service Mesh  sidecar-           .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Istio</a> . </li><li>    CNI   ,        Kubernetes. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tufin Orca</a>       Kubernetes. </li></ol><br>  Tufin Orca    Kubernetes (   ,  ). <br><br><h2>   </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  ,  Ahmet Alp Balkan'  GKE</a> ; </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    Kubernetes</a> ; </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    Kubernetes</a> ; </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    </a> . </li></ul><br><h2>  Fazit </h2><br>   Kubernetes       ,        .  ,  -        .             . <br><br> ,          ,     . <br><br><h2>  PS vom √úbersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li> ¬´     Istio¬ª: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 1 (   )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 2 (,  )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 3 ()</a> ; </li><li> ¬´      Kubernetes¬ª: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 1  2 ( ,  )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 3 (   )</a> ; </li><li> ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker  Kubernetes     </a> ¬ª; </li><li> ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">9       Kubernetes</a> ¬ª; </li><li> ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">11  ()     Kubernetes</a> ¬ª. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443190/">https://habr.com/ru/post/de443190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443180/index.html">Crew Dragon Landung und Asteroiden Videoaufnahme</a></li>
<li><a href="../de443182/index.html">Ziehen Sie YPbPr vom Commodore 64</a></li>
<li><a href="../de443184/index.html">Von der Liebe zur Kontrolle einen Schritt</a></li>
<li><a href="../de443186/index.html">3CX Technical Support antwortet - 5 IP PBX-Sicherheitsregeln</a></li>
<li><a href="../de443188/index.html">Drei Augen h√§ngen an einer S√§ule oder die Geschichte, dass f√ºnf Beine von ATtiny13 ausreichen</a></li>
<li><a href="../de443192/index.html">Private Methoden ohne Unterstriche und Schnittstellen in Python</a></li>
<li><a href="../de443194/index.html">Die WFIRM-Ingenieure haben einen Bioprinter erfunden, der die Haut direkt auf eine Wunde druckt</a></li>
<li><a href="../de443196/index.html">Keine Minute offline - Auswahl eines industriellen LTE-Routers</a></li>
<li><a href="../de443198/index.html">Laut Mark Zuckerberg arbeitet Facebook an einer neuronalen Schnittstelle zum Lesen von Gedanken</a></li>
<li><a href="../de443200/index.html">Iranische Hacker stehlen Terabyte an Daten von Citrix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>