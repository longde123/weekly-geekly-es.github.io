<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âŒ¨ï¸ ğŸ“ ğŸ¹ Richtiges EinfÃ¤deln in Qt ğŸ”¶ ğŸ’ ğŸ™€</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qt ist ein Ã¤uÃŸerst leistungsfÃ¤higes und praktisches Framework fÃ¼r C ++. Diese Bequemlichkeit hat jedoch einen Nachteil: Viele Dinge in Qt passieren vo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Richtiges EinfÃ¤deln in Qt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467261/">  Qt ist ein Ã¤uÃŸerst leistungsfÃ¤higes und praktisches Framework fÃ¼r C ++.  Diese Bequemlichkeit hat jedoch einen Nachteil: Viele Dinge in Qt passieren vor dem Benutzer verborgen.  In den meisten FÃ¤llen funktioniert die entsprechende FunktionalitÃ¤t in Qt â€magischâ€œ und lehrt den Benutzer, diese Magie einfach als selbstverstÃ¤ndlich zu betrachten.  Wenn die Magie dennoch bricht, ist es Ã¤uÃŸerst schwierig, ein Problem zu erkennen und zu lÃ¶sen, das plÃ¶tzlich auf einer Ebene erscheint, die scheinbar flach ist. <br><br>  Dieser Artikel ist ein Versuch zu systematisieren, wie Qt "unter der Haube" die Arbeit mit Flows implementiert, und Ã¼ber eine Reihe nicht offensichtlicher Fallstricke, die mit den EinschrÃ¤nkungen dieses Modells verbunden sind. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Grundlagen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thread-AffinitÃ¤t, Initialisierung und ihre EinschrÃ¤nkungen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hauptthread, QCoreApplication und GUI</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thread rendern</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> <br><br><a name="habracut"></a><a name="part1"></a><h3>  Die Grundlagen </h3><br>  Beginnen wir mit den Grundlagen.  In Qt sind alle Objekte, die Signale und Slots verarbeiten kÃ¶nnen, Nachkommen der QObject-Klasse.  Diese Objekte sind von Natur aus nicht kopierbar und stellen logischerweise einige einzelne EntitÃ¤ten dar, die miteinander â€sprechenâ€œ - auf bestimmte Ereignisse reagieren und selbst Ereignisse erzeugen kÃ¶nnen.  Mit anderen Worten, QObject in Qt implementiert das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Actors-Muster</a> .  Bei korrekter Implementierung ist jedes Qt-Programm im Wesentlichen nichts anderes als ein Netzwerk von QObjects, die miteinander interagieren und in denen die gesamte Programmlogik â€lebtâ€œ. <br><br>  ZusÃ¤tzlich zu einer Reihe von QObjects kann ein Qt-Programm Datenobjekte enthalten.  Diese Objekte kÃ¶nnen keine Signale erzeugen und empfangen, sondern kÃ¶nnen kopiert werden.  Beispielsweise kÃ¶nnen Sie QStringList und QStringListModel untereinander vergleichen.  Eines davon ist QObject und kann nicht kopiert werden, kann jedoch direkt mit UI-Objekten interagieren. Das andere ist ein regulÃ¤rer kopierbarer Container fÃ¼r Daten.  Objekte mit Daten werden wiederum in â€Qt-Metatypenâ€œ und alle anderen unterteilt.  Beispielsweise ist QStringList ein Qt-Metatyp, std :: list &lt;std :: string&gt; (ohne zusÃ¤tzliche Gesten) jedoch nicht.  Ersteres kann in jedem Qt-shnom-Kontext verwendet werden (Ã¼ber Signale Ã¼bertragen, in QVariant liegend usw.), erfordert jedoch ein spezielles Registrierungsverfahren, und die Klasse muss Ã¼ber einen Ã¶ffentlichen Destruktor, einen Kopierkonstruktor und einen Standardkonstruktor verfÃ¼gen.  Die zweiten sind beliebige C ++ - Typen. <br><br><a name="part2"></a><h3>  Gehen Sie nahtlos zu den eigentlichen Themen Ã¼ber </h3><br>  Wir haben also bedingte â€Datenâ€œ und es gibt einen bedingten â€Codeâ€œ, der mit ihnen funktioniert.  Aber wer wird diesen Code tatsÃ¤chlich ausfÃ¼hren?  Im Qt-Modell wird die Antwort auf diese Frage explizit festgelegt: Jedes QObject ist streng an einen QThread-Thread gebunden, der tatsÃ¤chlich Slots und andere Ereignisse dieses Objekts bedient.  Ein Thread kann viele QObjects gleichzeitig oder gar keine bedienen, aber QObject hat immer einen Ã¼bergeordneten Thread und es ist immer genau einer.  TatsÃ¤chlich kÃ¶nnen wir davon ausgehen, dass jeder QThread einen Satz von QObject "besitzt".  In der Qt-Terminologie wird dies als Thread-AffinitÃ¤t bezeichnet.  Versuchen wir zur Verdeutlichung zu visualisieren: <br><br><img src="https://habrastorage.org/webt/zs/py/t2/zspyt2yti1t8-mr6k708rer0rao.png"><br><br>  In jedem QThread befindet sich eine Warteschlange mit Nachrichten, die an Objekte adressiert sind, die dieser QThread â€besitztâ€œ.  Im Qt-Modell wird davon ausgegangen, dass wir, wenn ein QObject eine Aktion ausfÃ¼hren soll, eine QEvent-Nachricht an dieses QObject "senden": <br><br><pre><code class="cpp hljs">QCoreApplication::postEvent(QObject *receiver, QEvent *event, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority);</code> </pre> <br>  Bei diesem thread-sicheren Aufruf findet Qt den QThread, zu dem das EmpfÃ¤ngerobjekt gehÃ¶rt, schreibt das QEvent in die Nachrichtenwarteschlange dieses Threads und weckt diesen Thread bei Bedarf.  Es wird erwartet, dass der Code, der irgendwann danach in diesem QThread ausgefÃ¼hrt wird, die Nachricht aus der Warteschlange liest und die entsprechende Aktion ausfÃ¼hrt.  Damit dies wirklich geschieht, muss der Code in QThread in die QEventLoop-Ereignisschleife eintreten, das entsprechende Objekt erstellen und entweder die exec () -Methode oder die processEvents () -Methode aufrufen.  Die erste Option tritt in eine endlose Nachrichtenverarbeitungsschleife ein (bevor der QEventLoop das Ereignis quit () empfÃ¤ngt), die zweite beschrÃ¤nkt sich auf die Verarbeitung von Nachrichten, die sich zuvor in der Warteschlange angesammelt haben. <br><br><img src="https://habrastorage.org/webt/8x/ia/6o/8xia6o7i8wf0q5hoxkvzdjsl9xq.png"><br><br>  Es ist leicht zu erkennen, dass Ereignisse fÃ¼r alle Objekte, die zu einem Thread gehÃ¶ren, nacheinander verarbeitet werden.  Wenn die Verarbeitung eines Ereignisses durch einen Thread lange dauert, werden alle anderen Objekte "eingefroren" - ihre Ereignisse sammeln sich in der Warteschlange des Streams an, werden jedoch nicht verarbeitet.  Um dies zu verhindern, bietet Qt die MÃ¶glichkeit des kooperativen Multitasking - Event-Handler kÃ¶nnen Ã¼berall â€vorÃ¼bergehend unterbrechenâ€œ, indem sie eine neue QEventLoop erstellen und die Steuerung an diese Ã¼bergeben.  Da der Ereignishandler zuvor auch von QEventLoop im Stream aufgerufen wurde, wird bei diesem Ansatz eine Kette von ineinander verschachtelten Ereignisschleifen gebildet. <br><br><div class="spoiler">  <b class="spoiler_title">Ein paar Worte zum Event Dispatcher</b> <div class="spoiler_text">  Genau genommen ist QEventLoop nichts anderes als ein benutzerfreundlicher Wrapper Ã¼ber ein systemabhÃ¤ngiges Grundelement auf niedrigerer Ebene namens Event Dispatcher und implementiert die QAbstractEventDispatcher-Schnittstelle.  Er ist es, der die eigentliche Erfassung und Verarbeitung von Ereignissen durchfÃ¼hrt.  Ein Thread kann nur einen QAbstractEventDispatcher haben und wird nur einmal installiert.  Ab Qt5 kÃ¶nnen Sie so <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Dispatcher bei</a> Bedarf einfach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">durch einen geeigneteren ersetzen,</a> indem Sie der Initialisierung des Streams nur eine Zeile hinzufÃ¼gen und ohne die potenziell zahlreichen Stellen zu berÃ¼hren, an denen QEventLoop verwendet wird. </div></div><br>  Was beinhaltet das Konzept eines â€Ereignissesâ€œ, das in einem solchen Zyklus verarbeitet wird?  Allen Qt-Mitarbeitern bekannt, ist â€Signaleâ€œ nur ein besonderes Beispiel, QEvent :: MetaCall.  Ein solches QEvent speichert einen Zeiger auf die Informationen, die erforderlich sind, um die aufzurufende Funktion (Slot) und ihre Argumente zu identifizieren.  ZusÃ¤tzlich zu den Signalen in Qt gibt es jedoch ungefÃ¤hr hundert (!) Andere Ereignisse, von denen ein Dutzend fÃ¼r spezielle Qt-Ereignisse (ChildAdded, DeferredDelete, ParentChange) reserviert ist und der Rest verschiedenen Nachrichten des Betriebssystems entspricht. <br><br><div class="spoiler">  <b class="spoiler_title">Warum gibt es so viele von ihnen und warum war es unmÃ¶glich, nur auf Signale zu verzichten?</b> <div class="spoiler_text">  Der Leser mag fragen: Warum gibt es so viele Ereignisse und warum war es unmÃ¶glich, mit nur einem praktischen und universellen Signalmechanismus auszukommen?  Tatsache ist, dass unterschiedliche Signale sehr unterschiedlich verarbeitet werden kÃ¶nnen.  Beispielsweise sind einige der Signale komprimierbar. Wenn die Warteschlange bereits eine Rohnachricht dieses Typs enthÃ¤lt (z. B. QEvent :: Paint), Ã¤ndern die nachfolgenden Nachrichten diese einfach.  Andere Signale kÃ¶nnen herausgefiltert werden.  Das Vorhandensein einer kleinen Anzahl von Standard- und leicht identifizierbaren QEvents vereinfacht die entsprechende Verarbeitung erheblich.  DarÃ¼ber hinaus wird die QEvent-Verarbeitung aufgrund eines deutlich einfacheren GerÃ¤ts normalerweise etwas schneller ausgefÃ¼hrt als die Verarbeitung eines Ã¤hnlichen Signals. </div></div><br>  Eine der nicht offensichtlichen Fallstricke hier ist, dass in Qt ein Stream im Allgemeinen mÃ¶glicherweise nicht einmal einen Dispatcher und daher keinen einzigen EventLoop hat.  Objekte, die zu diesem Stream gehÃ¶ren, reagieren nicht auf an sie gesendete Ereignisse.  Da QThread :: run () standardmÃ¤ÃŸig QThread :: exec () aufruft, in dem die Standard-EventLoop gerade implementiert ist, sind diejenigen, die hÃ¤ufig versuchen, ihre eigene Version von run () zu ermitteln, die von QThread erbt, hÃ¤ufig mit diesem Problem konfrontiert.  Ein Ã¤hnlicher Anwendungsfall fÃ¼r QThread ist im Prinzip durchaus gÃ¼ltig und wird sogar in der Dokumentation empfohlen, widerspricht jedoch der oben beschriebenen allgemeinen Idee, den Code in Qt zu organisieren, und funktioniert hÃ¤ufig nicht so, wie Benutzer es <i>erwarten</i> .  Ein typischer Fehler in diesem Fall ist der Versuch, einen solchen benutzerdefinierten QThread durch Aufrufen von QThread :: exit () oder quit () zu stoppen.  Beide Funktionen senden eine Nachricht an QEventLoop, aber wenn sich einfach kein QEventLoop im Stream befindet, gibt es natÃ¼rlich niemanden, der sie verarbeitet.  Infolgedessen versuchen unerfahrene Benutzer, die versuchen, "eine defekte Klasse zu reparieren", ein "funktionierendes" QThread :: terminate zu verwenden, was absolut unmÃ¶glich ist.  Denken Sie daran: Wenn Sie run () neu definieren und die Standardereignisschleife nicht verwenden, mÃ¼ssen Sie einen Mechanismus zum Beenden des Threads selbst bereitstellen - beispielsweise mithilfe der speziell hinzugefÃ¼gten Funktion QThread :: requestInterruption ().  Es ist jedoch richtiger, einfach nicht von QThread zu erben, wenn Sie nicht wirklich eine spezielle neue Art von Threads implementieren und entweder den speziell fÃ¼r solche Skripte erstellten QtConcurrent verwenden oder die Logik in ein spezielles Worker-Objekt einfÃ¼gen, das von QObject geerbt wurde, und dieses in Standard-QThread einfÃ¼gen und verwalten Arbeiter mit Signalen. <br><br><a name="part3"></a><h3>  Thread-AffinitÃ¤t, Initialisierung und ihre EinschrÃ¤nkungen </h3><br>  Wie wir bereits herausgefunden haben, "gehÃ¶rt" jedes Objekt in Qt zu einem Stream.  Gleichzeitig stellt sich eine logische Frage: Zu welcher eigentlich genau?  Die folgenden Konventionen werden in Qt akzeptiert: <br><br>  <b>1. Alle â€Kinderâ€œ eines â€Elternteilsâ€œ leben immer im selben Stream wie der Elternteil</b> <br><br>  Dies ist mÃ¶glicherweise die stÃ¤rkste EinschrÃ¤nkung des Qt-Stream-Modells, und Versuche, es zu brechen, fÃ¼hren fÃ¼r den Benutzer hÃ¤ufig zu sehr seltsamen Ergebnissen.  Beispielsweise schlÃ¤gt ein Versuch, setParent fÃ¼r ein Objekt zu erstellen, das in einem anderen Thread in Qt lebt, einfach stillschweigend fehl (eine Warnung wird in die Konsole geschrieben).  Anscheinend wurde dieser Kompromiss aufgrund der Tatsache erzielt, dass die fadensichere Entfernung von â€Kindernâ€œ im Falle des Todes eines Elternteils, der in einem anderen Faden lebt, sehr trivial und anfÃ¤llig fÃ¼r schwer zu fassende Fehler ist.  Wenn Sie eine Hierarchie interagierender Objekte implementieren mÃ¶chten, die in verschiedenen Streams leben, mÃ¼ssen Sie das LÃ¶schen selbst organisieren. <br><br>  <b>2. Ein Objekt, dessen Ã¼bergeordnetes Element wÃ¤hrend der Erstellung nicht angegeben wurde, befindet sich in dem Stream, der es erstellt hat</b> <br><br>  Alles hier zur gleichen Zeit und einfach und zur gleichen Zeit ist nicht immer offensichtlich.  Aufgrund dieser Regel befindet sich QThread (als Objekt) beispielsweise in einem anderen Thread als der Thread, den es selbst steuert (und gemÃ¤ÃŸ Regel 1 kann es keines der in diesem Thread erstellten Objekte besitzen).  Wenn Sie beispielsweise QThread :: run neu definieren und darin QObject-Nachkommen erstellen, reagieren die erstellten Objekte ohne besondere MaÃŸnahmen (wie im vorherigen Kapitel erlÃ¤utert) nicht auf Signale. <br><br>  Die Thread-AffinitÃ¤t kann bei Bedarf durch Aufrufen von QObject :: moveToThread geÃ¤ndert werden.  GemÃ¤ÃŸ Regel 1 kÃ¶nnen nur "Eltern" der obersten Ebene (fÃ¼r die Eltern == null sind) verschoben werden. Ein Versuch, ein "Kind" zu verschieben, wird stillschweigend ignoriert.  Wenn sich der Ã¼bergeordnete â€Elternteilâ€œ bewegt, werden auch alle seine â€Kinderâ€œ in einen neuen Stream verschoben.  Seltsamerweise ist der Aufruf von moveToThread (nullptr) auch legal und bietet die MÃ¶glichkeit, ein Objekt mit einer Thread-AffinitÃ¤t von â€nullâ€œ zu erstellen.  Solche Objekte kÃ¶nnen keine Nachrichten empfangen. <br><br>  Sie kÃ¶nnen den "aktuellen" AusfÃ¼hrungsthread durch einen Aufruf der Funktion QThread :: currentThread () abrufen, dem Thread, dem das Objekt zugeordnet ist - durch einen Aufruf von QObject :: thread (). <br><br><div class="spoiler">  <b class="spoiler_title">Eine interessante Frage zur Aufmerksamkeit</b> <div class="spoiler_text">  Beachten Sie, dass die Implementierung der Funktion des Eigentums an Objekten und der Speicherung von an sie gerichteten QEvents offensichtlich erfordert, dass der Datenfluss die entsprechenden Daten irgendwo speichert.  Im Fall von Qt ist die QThread-Basisklasse normalerweise an der Extraktion und Verwaltung solcher Daten beteiligt.  Aber was passiert, wenn Sie ein QObject in einem std :: thread erstellen oder die QThread :: currentThread () -Funktion von diesem Thread aus aufrufen?  Es stellt sich heraus, dass Qt in diesem Fall implizit â€hinter den Kulissenâ€œ ein spezielles Wrapper-Objekt QAdoptedThread erstellt, das kein EigentÃ¼mer ist.  Gleichzeitig ist es Sache des Benutzers, unabhÃ¤ngig sicherzustellen, dass alle Objekte in einem solchen Stream gelÃ¶scht werden, bevor der Stream, der sie generiert hat, gestoppt wird. <br></div></div><br><a name="part4"></a><h3>  Hauptthread, QCoreApplication und GUI </h3><br>  Unter allen Threads wird Qt definitiv einen â€Haupt-Threadâ€œ herausgreifen, der im Fall von UI-Anwendungen auch zu einem GUI-Thread wird.  In diesem Thread befindet sich das QApplication-Objekt (QCoreApplication / QGuiApplication), das der Hauptereignisschleife dient, die fÃ¼r die Arbeit mit Nachrichten des Betriebssystems ausgerichtet ist.  GemÃ¤ÃŸ Regel Nr. 2 aus dem vorherigen Abschnitt ist in der Praxis der "Haupt" -Thread derjenige, der das QApplication-Objekt tatsÃ¤chlich erstellt hat. Da in vielen Betriebssystemen der "Hauptthread" eine besondere Bedeutung hat, wird in der Dokumentation dringend empfohlen, QApplication mit dem allerersten Objekt im Ganzen zu erstellen Qt programmieren und sofort nach dem Start der Anwendung ausfÃ¼hren (== innerhalb des ersten Threads im Prozess).  Um einen Zeiger auf den Hauptthread der Anwendung zu erhalten, kÃ¶nnen Sie eine Konstruktion des Formulars QCoreApplication :: instance () -&gt; thread () verwenden.  Rein technisch gesehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kann</a> QApplication <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jedoch auch an einen Nicht-Main () - Stream gehÃ¤ngt werden</a> , wenn beispielsweise die Qt-Schnittstelle in einer Art Plug-In erstellt wird und dies in vielen FÃ¤llen problemlos funktioniert. <br><br>  Aufgrund der Regel "Erstellte Objekte erben den aktuellen Thread" kÃ¶nnen Sie immer ruhig arbeiten, ohne die Grenzen eines Threads zu Ã¼berschreiten.  Alle erstellten Objekte werden automatisch zur Wartung an den Hauptthread gesendet, wo es immer eine Ereignisschleife gibt und (aufgrund des Fehlens anderer Threads) niemals Probleme mit der Synchronisierung auftreten.  Selbst wenn Sie mit einem komplexeren System arbeiten, das Multithreading erfordert, fallen die meisten Objekte hÃ¶chstwahrscheinlich in den Hauptstrom, mit Ausnahme der wenigen, die explizit an einer anderen Stelle platziert werden.  Vielleicht ist es genau dieser Umstand, der zu der scheinbaren â€Magieâ€œ fÃ¼hrt, in der Objekte ohne Aufwand unabhÃ¤ngig zu arbeiten scheinen (weil kooperatives Multitasking innerhalb des Flusses implementiert ist) und gleichzeitig keine Synchronisation, Blockierung oder dergleichen erfordern (weil alles in einem Thread geschieht) ) <br><br>  Neben der Tatsache, dass der "Haupt" -Thread der "erste" ist und die Hauptverarbeitungsschleife fÃ¼r QCoreApplication-Ereignisse enthÃ¤lt, besteht eine weitere EinschrÃ¤nkung von Qt darin, dass alle mit der GUI verbundenen Objekte in diesem Thread "leben" mÃ¼ssen.  Dies ist teilweise eine Folge von Legacy: Aufgrund der Tatsache, dass in einer Reihe von Betriebssystemen alle Operationen mit der GUI nur im Hauptthread ausgefÃ¼hrt werden kÃ¶nnen, unterteilt Qt alle Objekte in "Widgets" und "Nicht-Widgets".  Widget-artige Objekte kÃ¶nnen nur im Haupt-Thread leben. Ein Versuch, ein solches Objekt in einem anderen zu "Ã¼berwiegen", wird automatisch ausgelÃ¶st.  Aufgrund dessen gibt es sogar eine spezielle QObject :: isWidgetType () -Methode, die ziemlich tiefe interne Unterschiede in der Mechanik der Arbeit mit solchen Objekten widerspiegelt.  Es ist jedoch interessant, dass in dem viel neueren QtQuick, in dem versucht wurde, mit isWidgetType von der KrÃ¼cke wegzukommen, das gleiche Problem bestehen blieb <br><br>  Was ist los?  In Qt5 sind QML-Objekte keine Widgets mehr und kÃ¶nnen in einem separaten Thread gerendert werden.  Dies fÃ¼hrte jedoch zu einem anderen Problem - Synchronisationsschwierigkeiten.  Das Rendern von UI-Objekten ist ein â€Lesenâ€œ ihres Status und sollte konsistent sein: Wenn wir versuchen, den Status eines Objekts gleichzeitig mit dem Rendern zu Ã¤ndern, gefÃ¤llt uns das Ergebnis der resultierenden â€Rasseâ€œ mÃ¶glicherweise nicht.  DarÃ¼ber hinaus wird OpenGL, um das die â€neueâ€œ Grafik Qt erstellt wird, durch die Tatsache, dass die Bildung von Zeichenbefehlen von einem Thread ausgefÃ¼hrt wird, der mit einem globalen Status arbeitet, extrem â€geschÃ¤rftâ€œ - dem â€grafischen Kontextâ€œ, der sich nur als eine Reihe von aufeinanderfolgenden Operationen Ã¤ndern kann.  Wir kÃ¶nnen einfach nicht gleichzeitig zwei verschiedene Grafikobjekte auf dem Bildschirm zeichnen - sie werden immer nacheinander gezeichnet.  Infolgedessen kehren wir zur gleichen LÃ¶sung zurÃ¼ck - das Rendern der BenutzeroberflÃ¤che wird einem Thread zugewiesen.  Ein aufmerksamer Leser wird jedoch feststellen, dass dieser Thread nicht der Haupt-Thread sein muss - und in Qt5 wird das Framework wirklich versuchen, einen separaten Rendering-Thread dafÃ¼r zu verwenden <br><br><a name="part5"></a><h3>  Thread rendern </h3><br>  Im Rahmen des neuen Qt5-Modells erfolgt das gesamte Rendern von Objekten in einem speziell dafÃ¼r zugewiesenen Thread, dem Rendern von Threads.  Gleichzeitig werden die Objekte implizit in ein â€Front-Endâ€œ unterteilt, das der Programmierer sieht, und normalerweise in ein â€Back-Endâ€œ, das ihm verborgen bleibt und das tatsÃ¤chlich das eigentliche Rendern ausfÃ¼hrt, damit dies sinnvoll ist und nicht nur auf einen einfachen Wechsel von einem â€Hauptstromâ€œ zu einem anderen beschrÃ¤nkt ist.  Das hintere Ende befindet sich im Rendering-Thread, wÃ¤hrend das vordere Ende theoretisch in jedem anderen Thread leben kann.  Es wird angenommen, dass das Front-End die nÃ¼tzliche Arbeit (falls vorhanden) in Form einer Ereignisverarbeitung ausfÃ¼hrt, wÃ¤hrend die Back-End-Funktion nur durch Rendern eingeschrÃ¤nkt wird.  Theoretisch stellt sich heraus, dass es sich um eine Win-Win-Situation handelt: Die RÃ¼ckseite â€fragtâ€œ regelmÃ¤ÃŸig den aktuellen Status der Objekte ab und zeichnet sie auf den Bildschirm, wÃ¤hrend dies nicht durch die Tatsache â€gestopptâ€œ werden kann, dass einige der Objekte wÃ¤hrend der Verarbeitung des Ereignisses zu viel â€nachgedachtâ€œ haben In einem anderen Thread erfolgt eine langsame Verarbeitung.  Der Objektfluss muss wiederum nicht auf "Antworten" des Grafiktreibers warten, die den Abschluss des Renderns bestÃ¤tigen, und verschiedene Objekte kÃ¶nnen in verschiedenen FlÃ¼ssen arbeiten. <br><br>  Aber wie ich bereits im vorigen Kapitel erwÃ¤hnt habe, mÃ¼ssen wir sie irgendwie synchronisieren, da wir einen Stream haben, der Daten erstellt (eine Vorderseite) und einen Stream, der sie liest (eine RÃ¼ckseite).  Diese Synchronisation in Qt erfolgt durch Sperren.  Der Stream, in dem sich die Front befindet, wird vorÃ¼bergehend angehalten, gefolgt von einem speziellen Funktionsaufruf (QQuickItem :: updatePaintNode (), QQuickFramebufferObject :: Renderer :: synchronize ()), dessen einzige Aufgabe darin besteht, das fÃ¼r die Visualisierung relevante Objekt von vorne nach hinten zu kopieren ".  In diesem Fall erfolgt der Aufruf einer solchen Funktion <i>innerhalb des Rendering-Threads</i> . Aufgrund der Tatsache, dass der Thread, in dem sich das Objekt gerade befindet, gestoppt ist, kann der Benutzer mit den Daten des Objekts frei arbeiten, als ob dies â€wie gewohntâ€œ innerhalb des Streams geschehen wÃ¤re, zu dem das Objekt gehÃ¶rt. <br><br>  Ist alles in Ordnung, ist alles in Ordnung?  Leider beginnen hier keine und ziemlich unauffÃ¤lligen Momente.  Wenn wir fÃ¼r jedes Objekt einzeln eine Sperre vornehmen, ist dies ziemlich langsam, da der Rendering-Thread warten muss, bis diese Objekte ihre Ereignisse verarbeitet haben.  Der "Hang" -Stream, in dem sich das Objekt befindet, ist "Hang" und Rendern.  AuÃŸerdem wird eine â€Desynchronisierungâ€œ mÃ¶glich, wenn bei gleichzeitiger Ã„nderung von zwei Objekten eines in Bild N und das andere nur in Bild N + 1 gezeichnet wird.  Es ist vorzuziehen, die Sperre nur einmal und fÃ¼r alle Objekte gleichzeitig und nur dann zu Ã¼bernehmen, wenn wir sicher sind, dass diese Sperre erfolgreich sein wird. <br><br>  Was wurde implementiert, um dieses Problem in Qt zu lÃ¶sen?  ZunÃ¤chst wurde entschieden, dass alle "grafischen" Objekte eines Fensters in einem Stream leben.  Um ein Fenster zu zeichnen und alle darin enthaltenen Objekte zu sperren, reicht es aus, diesen Stream alleine zu stoppen.  Zweitens initiiert der Thread mit UI-Objekten die Sperre fÃ¼r die Aktualisierung des Back-End und sendet eine Nachricht an den Rendering-Thread Ã¼ber die Notwendigkeit, sich selbst zu synchronisieren und zu stoppen (QSGThreadedRenderLoop :: polishAndSync, wenn jemand interessiert ist).  Dies stellt sicher, dass der Rendering-Thread niemals auf einen Front-End-Stream â€wartetâ€œ.  Wenn es plÃ¶tzlich "hÃ¤ngt", zeichnet der Rendering-Thread einfach weiter den "alten" Status der Objekte, ohne Nachrichten Ã¼ber die Notwendigkeit einer Aktualisierung zu erhalten.  Dies fÃ¼hrt zu ziemlich amÃ¼santen Fehlern der Form "Wenn das Rendering aus irgendeinem Grund das Fenster nicht sofort zeichnen kann, friert der Haupt-Thread ein", aber im Allgemeinen ist es ein vernÃ¼nftiger Kompromiss.  Ab QtQuick 2.0 kÃ¶nnen sogar eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von "animierten" Objekten</a> im Render-Thread "aufgefÃ¼llt" werden, sodass die Animation auch dann weiter funktioniert, wenn der Haupt-Thread "gedacht" ist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc0/250/3da/bc02503da9d76ff4b66ae038ce3cf81f.png"><br><br>  Die praktische Konsequenz dieser LÃ¶sung ist jedoch, dass alle UI-Objekte ohnehin im selben Thread leben mÃ¼ssen.  Bei alten Widgets im "Haupt" -Thread, bei neuen Qt Quick-Objekten im QQuickWindow-Objekt-Thread, dem sie gehÃ¶ren.  Die letzte Regel wird ziemlich elegant geschlagen - um ein QQuickItem zu zeichnen, muss setParent auf das entsprechende QQuickWindow gesetzt werden, wodurch, wie bereits erlÃ¤utert, sichergestellt wird, dass das Objekt entweder in den entsprechenden Stream verschoben wird oder der Aufruf von setParent fehlschlÃ¤gt. <br><br>  Und jetzt leider eine Fliege in der Salbe: Obwohl verschiedene QQuickWindow theoretisch in verschiedenen Streams leben kÃ¶nnten, erfordert dies in der Praxis ein genaues Senden von Nachrichten vom Betriebssystem an sie und in Qt ist es heute nicht implementiert.  In Qt 5.13 versucht QCoreApplication beispielsweise, Ã¼ber sendEvent mit QQuickWindow zu kommunizieren, wobei sich der EmpfÃ¤nger und der sendende Teilnehmer im selben Thread befinden mÃ¼ssen (anstelle von postEvent, wodurch die Threads unterschiedlich sein kÃ¶nnen).  Daher funktioniert QQuickWindow in der Praxis nur in einem GUI-Thread ordnungsgemÃ¤ÃŸ. Daher befinden sich alle QtQuick-Objekte an derselben Stelle.  Trotz des Vorhandenseins des Rendering-Threads befinden sich fast alle dem Benutzer zur VerfÃ¼gung stehenden GUI-bezogenen Objekte weiterhin im selben GUI-Thread.  Vielleicht Ã¤ndert sich dies in Qt 6. <br><br>  DarÃ¼ber hinaus ist zu beachten, dass das Framework, da Qt auf vielen verschiedenen Plattformen funktioniert (einschlieÃŸlich solcher, die kein Multithreading unterstÃ¼tzen), eine anstÃ¤ndige Anzahl von Fallbacks bietet und in einigen FÃ¤llen die Rendering-Thread-FunktionalitÃ¤t tatsÃ¤chlich von demselben GUI-Thread ausgefÃ¼hrt wird .  In diesem Fall befindet sich die gesamte BenutzeroberflÃ¤che, einschlieÃŸlich des Renderns, in einem Thread, und das Synchronisierungsproblem verschwindet automatisch.  Ã„hnlich verhÃ¤lt es sich mit der Ã¤lteren Widget-basierten BenutzeroberflÃ¤che im Qt4-Stil.      Qt    Â«Â»       QSG_RENDER_LOOP   . <br><br><a name="part6"></a><h3>  Fazit </h3><br> Qt â€”              .     ,   ,           Qt      . <br><br>     ; <br><br><ul><li>    Â«Â»         ,   queued signals </li><li>  Â«Â»     Qt Event Loop                   exit() </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eltern und Nachkommen leben immer im selben Strom. </font><font style="vertical-align: inherit;">Nur Ã¼bergeordnete Elemente der obersten Ebene kÃ¶nnen von Stream zu Stream Ã¼bertragen werden. </font><font style="vertical-align: inherit;">Ein VerstoÃŸ gegen diese Regel kann zu einem stillen Ausfall der Operation setParent oder moveToThread fÃ¼hren</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein Objekt, dessen Ã¼bergeordnetes Element nicht angegeben ist, wird zur Eigenschaft des Threads, den dieses Objekt erstellt hat. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alle GUI-Objekte mit Ausnahme des Rendering-Backends mÃ¼ssen im GUI-Stream gespeichert sein </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der GUI-Thread ist derjenige, in dem das QApplication-Objekt erstellt wurde </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich hoffe, dass dies Ihnen hilft, Qt effizienter zu nutzen und keine Fehler im Zusammenhang mit seinem Multithread-Modell zu machen. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467261/">https://habr.com/ru/post/de467261/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467251/index.html">Geiseln COBOL und Math. Teil 1</a></li>
<li><a href="../de467253/index.html">Geiseln COBOL und Math. Teil 2</a></li>
<li><a href="../de467255/index.html">Drei hÃ¤ufige Sicherheitsfehler, Ã¼ber die jeder Reaktionsentwickler Bescheid wissen sollte</a></li>
<li><a href="../de467257/index.html">Lagern Sie nicht alle Eier gleichzeitig in einem Korb</a></li>
<li><a href="../de467259/index.html">DPI (SSL Inspection) widerspricht der Bedeutung von Kryptografie, wird jedoch von Unternehmen implementiert</a></li>
<li><a href="../de467263/index.html">Wir verdienen mit Solarenergie oder passivem Einkommen 25% pro Jahr, praktische Erfahrung. Teil 2</a></li>
<li><a href="../de467269/index.html">Modelle in der Informationssicherheit</a></li>
<li><a href="../de467271/index.html">Berufsprogrammierer, Chemiker von Beruf</a></li>
<li><a href="../de467275/index.html">Zum Tag des Programmierers. Programmierer im Jahr 2019</a></li>
<li><a href="../de467277/index.html">pg_stat_statements + pg_stat_activity + loq_query = pg_ash?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>