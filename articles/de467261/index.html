<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⌨️ 📞 🐹 Richtiges Einfädeln in Qt 🔶 🍒 🙀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qt ist ein äußerst leistungsfähiges und praktisches Framework für C ++. Diese Bequemlichkeit hat jedoch einen Nachteil: Viele Dinge in Qt passieren vo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Richtiges Einfädeln in Qt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467261/">  Qt ist ein äußerst leistungsfähiges und praktisches Framework für C ++.  Diese Bequemlichkeit hat jedoch einen Nachteil: Viele Dinge in Qt passieren vor dem Benutzer verborgen.  In den meisten Fällen funktioniert die entsprechende Funktionalität in Qt „magisch“ und lehrt den Benutzer, diese Magie einfach als selbstverständlich zu betrachten.  Wenn die Magie dennoch bricht, ist es äußerst schwierig, ein Problem zu erkennen und zu lösen, das plötzlich auf einer Ebene erscheint, die scheinbar flach ist. <br><br>  Dieser Artikel ist ein Versuch zu systematisieren, wie Qt "unter der Haube" die Arbeit mit Flows implementiert, und über eine Reihe nicht offensichtlicher Fallstricke, die mit den Einschränkungen dieses Modells verbunden sind. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Grundlagen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thread-Affinität, Initialisierung und ihre Einschränkungen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hauptthread, QCoreApplication und GUI</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thread rendern</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> <br><br><a name="habracut"></a><a name="part1"></a><h3>  Die Grundlagen </h3><br>  Beginnen wir mit den Grundlagen.  In Qt sind alle Objekte, die Signale und Slots verarbeiten können, Nachkommen der QObject-Klasse.  Diese Objekte sind von Natur aus nicht kopierbar und stellen logischerweise einige einzelne Entitäten dar, die miteinander „sprechen“ - auf bestimmte Ereignisse reagieren und selbst Ereignisse erzeugen können.  Mit anderen Worten, QObject in Qt implementiert das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Actors-Muster</a> .  Bei korrekter Implementierung ist jedes Qt-Programm im Wesentlichen nichts anderes als ein Netzwerk von QObjects, die miteinander interagieren und in denen die gesamte Programmlogik „lebt“. <br><br>  Zusätzlich zu einer Reihe von QObjects kann ein Qt-Programm Datenobjekte enthalten.  Diese Objekte können keine Signale erzeugen und empfangen, sondern können kopiert werden.  Beispielsweise können Sie QStringList und QStringListModel untereinander vergleichen.  Eines davon ist QObject und kann nicht kopiert werden, kann jedoch direkt mit UI-Objekten interagieren. Das andere ist ein regulärer kopierbarer Container für Daten.  Objekte mit Daten werden wiederum in „Qt-Metatypen“ und alle anderen unterteilt.  Beispielsweise ist QStringList ein Qt-Metatyp, std :: list &lt;std :: string&gt; (ohne zusätzliche Gesten) jedoch nicht.  Ersteres kann in jedem Qt-shnom-Kontext verwendet werden (über Signale übertragen, in QVariant liegend usw.), erfordert jedoch ein spezielles Registrierungsverfahren, und die Klasse muss über einen öffentlichen Destruktor, einen Kopierkonstruktor und einen Standardkonstruktor verfügen.  Die zweiten sind beliebige C ++ - Typen. <br><br><a name="part2"></a><h3>  Gehen Sie nahtlos zu den eigentlichen Themen über </h3><br>  Wir haben also bedingte „Daten“ und es gibt einen bedingten „Code“, der mit ihnen funktioniert.  Aber wer wird diesen Code tatsächlich ausführen?  Im Qt-Modell wird die Antwort auf diese Frage explizit festgelegt: Jedes QObject ist streng an einen QThread-Thread gebunden, der tatsächlich Slots und andere Ereignisse dieses Objekts bedient.  Ein Thread kann viele QObjects gleichzeitig oder gar keine bedienen, aber QObject hat immer einen übergeordneten Thread und es ist immer genau einer.  Tatsächlich können wir davon ausgehen, dass jeder QThread einen Satz von QObject "besitzt".  In der Qt-Terminologie wird dies als Thread-Affinität bezeichnet.  Versuchen wir zur Verdeutlichung zu visualisieren: <br><br><img src="https://habrastorage.org/webt/zs/py/t2/zspyt2yti1t8-mr6k708rer0rao.png"><br><br>  In jedem QThread befindet sich eine Warteschlange mit Nachrichten, die an Objekte adressiert sind, die dieser QThread „besitzt“.  Im Qt-Modell wird davon ausgegangen, dass wir, wenn ein QObject eine Aktion ausführen soll, eine QEvent-Nachricht an dieses QObject "senden": <br><br><pre><code class="cpp hljs">QCoreApplication::postEvent(QObject *receiver, QEvent *event, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority);</code> </pre> <br>  Bei diesem thread-sicheren Aufruf findet Qt den QThread, zu dem das Empfängerobjekt gehört, schreibt das QEvent in die Nachrichtenwarteschlange dieses Threads und weckt diesen Thread bei Bedarf.  Es wird erwartet, dass der Code, der irgendwann danach in diesem QThread ausgeführt wird, die Nachricht aus der Warteschlange liest und die entsprechende Aktion ausführt.  Damit dies wirklich geschieht, muss der Code in QThread in die QEventLoop-Ereignisschleife eintreten, das entsprechende Objekt erstellen und entweder die exec () -Methode oder die processEvents () -Methode aufrufen.  Die erste Option tritt in eine endlose Nachrichtenverarbeitungsschleife ein (bevor der QEventLoop das Ereignis quit () empfängt), die zweite beschränkt sich auf die Verarbeitung von Nachrichten, die sich zuvor in der Warteschlange angesammelt haben. <br><br><img src="https://habrastorage.org/webt/8x/ia/6o/8xia6o7i8wf0q5hoxkvzdjsl9xq.png"><br><br>  Es ist leicht zu erkennen, dass Ereignisse für alle Objekte, die zu einem Thread gehören, nacheinander verarbeitet werden.  Wenn die Verarbeitung eines Ereignisses durch einen Thread lange dauert, werden alle anderen Objekte "eingefroren" - ihre Ereignisse sammeln sich in der Warteschlange des Streams an, werden jedoch nicht verarbeitet.  Um dies zu verhindern, bietet Qt die Möglichkeit des kooperativen Multitasking - Event-Handler können überall „vorübergehend unterbrechen“, indem sie eine neue QEventLoop erstellen und die Steuerung an diese übergeben.  Da der Ereignishandler zuvor auch von QEventLoop im Stream aufgerufen wurde, wird bei diesem Ansatz eine Kette von ineinander verschachtelten Ereignisschleifen gebildet. <br><br><div class="spoiler">  <b class="spoiler_title">Ein paar Worte zum Event Dispatcher</b> <div class="spoiler_text">  Genau genommen ist QEventLoop nichts anderes als ein benutzerfreundlicher Wrapper über ein systemabhängiges Grundelement auf niedrigerer Ebene namens Event Dispatcher und implementiert die QAbstractEventDispatcher-Schnittstelle.  Er ist es, der die eigentliche Erfassung und Verarbeitung von Ereignissen durchführt.  Ein Thread kann nur einen QAbstractEventDispatcher haben und wird nur einmal installiert.  Ab Qt5 können Sie so <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Dispatcher bei</a> Bedarf einfach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">durch einen geeigneteren ersetzen,</a> indem Sie der Initialisierung des Streams nur eine Zeile hinzufügen und ohne die potenziell zahlreichen Stellen zu berühren, an denen QEventLoop verwendet wird. </div></div><br>  Was beinhaltet das Konzept eines „Ereignisses“, das in einem solchen Zyklus verarbeitet wird?  Allen Qt-Mitarbeitern bekannt, ist „Signale“ nur ein besonderes Beispiel, QEvent :: MetaCall.  Ein solches QEvent speichert einen Zeiger auf die Informationen, die erforderlich sind, um die aufzurufende Funktion (Slot) und ihre Argumente zu identifizieren.  Zusätzlich zu den Signalen in Qt gibt es jedoch ungefähr hundert (!) Andere Ereignisse, von denen ein Dutzend für spezielle Qt-Ereignisse (ChildAdded, DeferredDelete, ParentChange) reserviert ist und der Rest verschiedenen Nachrichten des Betriebssystems entspricht. <br><br><div class="spoiler">  <b class="spoiler_title">Warum gibt es so viele von ihnen und warum war es unmöglich, nur auf Signale zu verzichten?</b> <div class="spoiler_text">  Der Leser mag fragen: Warum gibt es so viele Ereignisse und warum war es unmöglich, mit nur einem praktischen und universellen Signalmechanismus auszukommen?  Tatsache ist, dass unterschiedliche Signale sehr unterschiedlich verarbeitet werden können.  Beispielsweise sind einige der Signale komprimierbar. Wenn die Warteschlange bereits eine Rohnachricht dieses Typs enthält (z. B. QEvent :: Paint), ändern die nachfolgenden Nachrichten diese einfach.  Andere Signale können herausgefiltert werden.  Das Vorhandensein einer kleinen Anzahl von Standard- und leicht identifizierbaren QEvents vereinfacht die entsprechende Verarbeitung erheblich.  Darüber hinaus wird die QEvent-Verarbeitung aufgrund eines deutlich einfacheren Geräts normalerweise etwas schneller ausgeführt als die Verarbeitung eines ähnlichen Signals. </div></div><br>  Eine der nicht offensichtlichen Fallstricke hier ist, dass in Qt ein Stream im Allgemeinen möglicherweise nicht einmal einen Dispatcher und daher keinen einzigen EventLoop hat.  Objekte, die zu diesem Stream gehören, reagieren nicht auf an sie gesendete Ereignisse.  Da QThread :: run () standardmäßig QThread :: exec () aufruft, in dem die Standard-EventLoop gerade implementiert ist, sind diejenigen, die häufig versuchen, ihre eigene Version von run () zu ermitteln, die von QThread erbt, häufig mit diesem Problem konfrontiert.  Ein ähnlicher Anwendungsfall für QThread ist im Prinzip durchaus gültig und wird sogar in der Dokumentation empfohlen, widerspricht jedoch der oben beschriebenen allgemeinen Idee, den Code in Qt zu organisieren, und funktioniert häufig nicht so, wie Benutzer es <i>erwarten</i> .  Ein typischer Fehler in diesem Fall ist der Versuch, einen solchen benutzerdefinierten QThread durch Aufrufen von QThread :: exit () oder quit () zu stoppen.  Beide Funktionen senden eine Nachricht an QEventLoop, aber wenn sich einfach kein QEventLoop im Stream befindet, gibt es natürlich niemanden, der sie verarbeitet.  Infolgedessen versuchen unerfahrene Benutzer, die versuchen, "eine defekte Klasse zu reparieren", ein "funktionierendes" QThread :: terminate zu verwenden, was absolut unmöglich ist.  Denken Sie daran: Wenn Sie run () neu definieren und die Standardereignisschleife nicht verwenden, müssen Sie einen Mechanismus zum Beenden des Threads selbst bereitstellen - beispielsweise mithilfe der speziell hinzugefügten Funktion QThread :: requestInterruption ().  Es ist jedoch richtiger, einfach nicht von QThread zu erben, wenn Sie nicht wirklich eine spezielle neue Art von Threads implementieren und entweder den speziell für solche Skripte erstellten QtConcurrent verwenden oder die Logik in ein spezielles Worker-Objekt einfügen, das von QObject geerbt wurde, und dieses in Standard-QThread einfügen und verwalten Arbeiter mit Signalen. <br><br><a name="part3"></a><h3>  Thread-Affinität, Initialisierung und ihre Einschränkungen </h3><br>  Wie wir bereits herausgefunden haben, "gehört" jedes Objekt in Qt zu einem Stream.  Gleichzeitig stellt sich eine logische Frage: Zu welcher eigentlich genau?  Die folgenden Konventionen werden in Qt akzeptiert: <br><br>  <b>1. Alle „Kinder“ eines „Elternteils“ leben immer im selben Stream wie der Elternteil</b> <br><br>  Dies ist möglicherweise die stärkste Einschränkung des Qt-Stream-Modells, und Versuche, es zu brechen, führen für den Benutzer häufig zu sehr seltsamen Ergebnissen.  Beispielsweise schlägt ein Versuch, setParent für ein Objekt zu erstellen, das in einem anderen Thread in Qt lebt, einfach stillschweigend fehl (eine Warnung wird in die Konsole geschrieben).  Anscheinend wurde dieser Kompromiss aufgrund der Tatsache erzielt, dass die fadensichere Entfernung von „Kindern“ im Falle des Todes eines Elternteils, der in einem anderen Faden lebt, sehr trivial und anfällig für schwer zu fassende Fehler ist.  Wenn Sie eine Hierarchie interagierender Objekte implementieren möchten, die in verschiedenen Streams leben, müssen Sie das Löschen selbst organisieren. <br><br>  <b>2. Ein Objekt, dessen übergeordnetes Element während der Erstellung nicht angegeben wurde, befindet sich in dem Stream, der es erstellt hat</b> <br><br>  Alles hier zur gleichen Zeit und einfach und zur gleichen Zeit ist nicht immer offensichtlich.  Aufgrund dieser Regel befindet sich QThread (als Objekt) beispielsweise in einem anderen Thread als der Thread, den es selbst steuert (und gemäß Regel 1 kann es keines der in diesem Thread erstellten Objekte besitzen).  Wenn Sie beispielsweise QThread :: run neu definieren und darin QObject-Nachkommen erstellen, reagieren die erstellten Objekte ohne besondere Maßnahmen (wie im vorherigen Kapitel erläutert) nicht auf Signale. <br><br>  Die Thread-Affinität kann bei Bedarf durch Aufrufen von QObject :: moveToThread geändert werden.  Gemäß Regel 1 können nur "Eltern" der obersten Ebene (für die Eltern == null sind) verschoben werden. Ein Versuch, ein "Kind" zu verschieben, wird stillschweigend ignoriert.  Wenn sich der übergeordnete „Elternteil“ bewegt, werden auch alle seine „Kinder“ in einen neuen Stream verschoben.  Seltsamerweise ist der Aufruf von moveToThread (nullptr) auch legal und bietet die Möglichkeit, ein Objekt mit einer Thread-Affinität von „null“ zu erstellen.  Solche Objekte können keine Nachrichten empfangen. <br><br>  Sie können den "aktuellen" Ausführungsthread durch einen Aufruf der Funktion QThread :: currentThread () abrufen, dem Thread, dem das Objekt zugeordnet ist - durch einen Aufruf von QObject :: thread (). <br><br><div class="spoiler">  <b class="spoiler_title">Eine interessante Frage zur Aufmerksamkeit</b> <div class="spoiler_text">  Beachten Sie, dass die Implementierung der Funktion des Eigentums an Objekten und der Speicherung von an sie gerichteten QEvents offensichtlich erfordert, dass der Datenfluss die entsprechenden Daten irgendwo speichert.  Im Fall von Qt ist die QThread-Basisklasse normalerweise an der Extraktion und Verwaltung solcher Daten beteiligt.  Aber was passiert, wenn Sie ein QObject in einem std :: thread erstellen oder die QThread :: currentThread () -Funktion von diesem Thread aus aufrufen?  Es stellt sich heraus, dass Qt in diesem Fall implizit „hinter den Kulissen“ ein spezielles Wrapper-Objekt QAdoptedThread erstellt, das kein Eigentümer ist.  Gleichzeitig ist es Sache des Benutzers, unabhängig sicherzustellen, dass alle Objekte in einem solchen Stream gelöscht werden, bevor der Stream, der sie generiert hat, gestoppt wird. <br></div></div><br><a name="part4"></a><h3>  Hauptthread, QCoreApplication und GUI </h3><br>  Unter allen Threads wird Qt definitiv einen „Haupt-Thread“ herausgreifen, der im Fall von UI-Anwendungen auch zu einem GUI-Thread wird.  In diesem Thread befindet sich das QApplication-Objekt (QCoreApplication / QGuiApplication), das der Hauptereignisschleife dient, die für die Arbeit mit Nachrichten des Betriebssystems ausgerichtet ist.  Gemäß Regel Nr. 2 aus dem vorherigen Abschnitt ist in der Praxis der "Haupt" -Thread derjenige, der das QApplication-Objekt tatsächlich erstellt hat. Da in vielen Betriebssystemen der "Hauptthread" eine besondere Bedeutung hat, wird in der Dokumentation dringend empfohlen, QApplication mit dem allerersten Objekt im Ganzen zu erstellen Qt programmieren und sofort nach dem Start der Anwendung ausführen (== innerhalb des ersten Threads im Prozess).  Um einen Zeiger auf den Hauptthread der Anwendung zu erhalten, können Sie eine Konstruktion des Formulars QCoreApplication :: instance () -&gt; thread () verwenden.  Rein technisch gesehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kann</a> QApplication <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jedoch auch an einen Nicht-Main () - Stream gehängt werden</a> , wenn beispielsweise die Qt-Schnittstelle in einer Art Plug-In erstellt wird und dies in vielen Fällen problemlos funktioniert. <br><br>  Aufgrund der Regel "Erstellte Objekte erben den aktuellen Thread" können Sie immer ruhig arbeiten, ohne die Grenzen eines Threads zu überschreiten.  Alle erstellten Objekte werden automatisch zur Wartung an den Hauptthread gesendet, wo es immer eine Ereignisschleife gibt und (aufgrund des Fehlens anderer Threads) niemals Probleme mit der Synchronisierung auftreten.  Selbst wenn Sie mit einem komplexeren System arbeiten, das Multithreading erfordert, fallen die meisten Objekte höchstwahrscheinlich in den Hauptstrom, mit Ausnahme der wenigen, die explizit an einer anderen Stelle platziert werden.  Vielleicht ist es genau dieser Umstand, der zu der scheinbaren „Magie“ führt, in der Objekte ohne Aufwand unabhängig zu arbeiten scheinen (weil kooperatives Multitasking innerhalb des Flusses implementiert ist) und gleichzeitig keine Synchronisation, Blockierung oder dergleichen erfordern (weil alles in einem Thread geschieht) ) <br><br>  Neben der Tatsache, dass der "Haupt" -Thread der "erste" ist und die Hauptverarbeitungsschleife für QCoreApplication-Ereignisse enthält, besteht eine weitere Einschränkung von Qt darin, dass alle mit der GUI verbundenen Objekte in diesem Thread "leben" müssen.  Dies ist teilweise eine Folge von Legacy: Aufgrund der Tatsache, dass in einer Reihe von Betriebssystemen alle Operationen mit der GUI nur im Hauptthread ausgeführt werden können, unterteilt Qt alle Objekte in "Widgets" und "Nicht-Widgets".  Widget-artige Objekte können nur im Haupt-Thread leben. Ein Versuch, ein solches Objekt in einem anderen zu "überwiegen", wird automatisch ausgelöst.  Aufgrund dessen gibt es sogar eine spezielle QObject :: isWidgetType () -Methode, die ziemlich tiefe interne Unterschiede in der Mechanik der Arbeit mit solchen Objekten widerspiegelt.  Es ist jedoch interessant, dass in dem viel neueren QtQuick, in dem versucht wurde, mit isWidgetType von der Krücke wegzukommen, das gleiche Problem bestehen blieb <br><br>  Was ist los?  In Qt5 sind QML-Objekte keine Widgets mehr und können in einem separaten Thread gerendert werden.  Dies führte jedoch zu einem anderen Problem - Synchronisationsschwierigkeiten.  Das Rendern von UI-Objekten ist ein „Lesen“ ihres Status und sollte konsistent sein: Wenn wir versuchen, den Status eines Objekts gleichzeitig mit dem Rendern zu ändern, gefällt uns das Ergebnis der resultierenden „Rasse“ möglicherweise nicht.  Darüber hinaus wird OpenGL, um das die „neue“ Grafik Qt erstellt wird, durch die Tatsache, dass die Bildung von Zeichenbefehlen von einem Thread ausgeführt wird, der mit einem globalen Status arbeitet, extrem „geschärft“ - dem „grafischen Kontext“, der sich nur als eine Reihe von aufeinanderfolgenden Operationen ändern kann.  Wir können einfach nicht gleichzeitig zwei verschiedene Grafikobjekte auf dem Bildschirm zeichnen - sie werden immer nacheinander gezeichnet.  Infolgedessen kehren wir zur gleichen Lösung zurück - das Rendern der Benutzeroberfläche wird einem Thread zugewiesen.  Ein aufmerksamer Leser wird jedoch feststellen, dass dieser Thread nicht der Haupt-Thread sein muss - und in Qt5 wird das Framework wirklich versuchen, einen separaten Rendering-Thread dafür zu verwenden <br><br><a name="part5"></a><h3>  Thread rendern </h3><br>  Im Rahmen des neuen Qt5-Modells erfolgt das gesamte Rendern von Objekten in einem speziell dafür zugewiesenen Thread, dem Rendern von Threads.  Gleichzeitig werden die Objekte implizit in ein „Front-End“ unterteilt, das der Programmierer sieht, und normalerweise in ein „Back-End“, das ihm verborgen bleibt und das tatsächlich das eigentliche Rendern ausführt, damit dies sinnvoll ist und nicht nur auf einen einfachen Wechsel von einem „Hauptstrom“ zu einem anderen beschränkt ist.  Das hintere Ende befindet sich im Rendering-Thread, während das vordere Ende theoretisch in jedem anderen Thread leben kann.  Es wird angenommen, dass das Front-End die nützliche Arbeit (falls vorhanden) in Form einer Ereignisverarbeitung ausführt, während die Back-End-Funktion nur durch Rendern eingeschränkt wird.  Theoretisch stellt sich heraus, dass es sich um eine Win-Win-Situation handelt: Die Rückseite „fragt“ regelmäßig den aktuellen Status der Objekte ab und zeichnet sie auf den Bildschirm, während dies nicht durch die Tatsache „gestoppt“ werden kann, dass einige der Objekte während der Verarbeitung des Ereignisses zu viel „nachgedacht“ haben In einem anderen Thread erfolgt eine langsame Verarbeitung.  Der Objektfluss muss wiederum nicht auf "Antworten" des Grafiktreibers warten, die den Abschluss des Renderns bestätigen, und verschiedene Objekte können in verschiedenen Flüssen arbeiten. <br><br>  Aber wie ich bereits im vorigen Kapitel erwähnt habe, müssen wir sie irgendwie synchronisieren, da wir einen Stream haben, der Daten erstellt (eine Vorderseite) und einen Stream, der sie liest (eine Rückseite).  Diese Synchronisation in Qt erfolgt durch Sperren.  Der Stream, in dem sich die Front befindet, wird vorübergehend angehalten, gefolgt von einem speziellen Funktionsaufruf (QQuickItem :: updatePaintNode (), QQuickFramebufferObject :: Renderer :: synchronize ()), dessen einzige Aufgabe darin besteht, das für die Visualisierung relevante Objekt von vorne nach hinten zu kopieren ".  In diesem Fall erfolgt der Aufruf einer solchen Funktion <i>innerhalb des Rendering-Threads</i> . Aufgrund der Tatsache, dass der Thread, in dem sich das Objekt gerade befindet, gestoppt ist, kann der Benutzer mit den Daten des Objekts frei arbeiten, als ob dies „wie gewohnt“ innerhalb des Streams geschehen wäre, zu dem das Objekt gehört. <br><br>  Ist alles in Ordnung, ist alles in Ordnung?  Leider beginnen hier keine und ziemlich unauffälligen Momente.  Wenn wir für jedes Objekt einzeln eine Sperre vornehmen, ist dies ziemlich langsam, da der Rendering-Thread warten muss, bis diese Objekte ihre Ereignisse verarbeitet haben.  Der "Hang" -Stream, in dem sich das Objekt befindet, ist "Hang" und Rendern.  Außerdem wird eine „Desynchronisierung“ möglich, wenn bei gleichzeitiger Änderung von zwei Objekten eines in Bild N und das andere nur in Bild N + 1 gezeichnet wird.  Es ist vorzuziehen, die Sperre nur einmal und für alle Objekte gleichzeitig und nur dann zu übernehmen, wenn wir sicher sind, dass diese Sperre erfolgreich sein wird. <br><br>  Was wurde implementiert, um dieses Problem in Qt zu lösen?  Zunächst wurde entschieden, dass alle "grafischen" Objekte eines Fensters in einem Stream leben.  Um ein Fenster zu zeichnen und alle darin enthaltenen Objekte zu sperren, reicht es aus, diesen Stream alleine zu stoppen.  Zweitens initiiert der Thread mit UI-Objekten die Sperre für die Aktualisierung des Back-End und sendet eine Nachricht an den Rendering-Thread über die Notwendigkeit, sich selbst zu synchronisieren und zu stoppen (QSGThreadedRenderLoop :: polishAndSync, wenn jemand interessiert ist).  Dies stellt sicher, dass der Rendering-Thread niemals auf einen Front-End-Stream „wartet“.  Wenn es plötzlich "hängt", zeichnet der Rendering-Thread einfach weiter den "alten" Status der Objekte, ohne Nachrichten über die Notwendigkeit einer Aktualisierung zu erhalten.  Dies führt zu ziemlich amüsanten Fehlern der Form "Wenn das Rendering aus irgendeinem Grund das Fenster nicht sofort zeichnen kann, friert der Haupt-Thread ein", aber im Allgemeinen ist es ein vernünftiger Kompromiss.  Ab QtQuick 2.0 können sogar eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von "animierten" Objekten</a> im Render-Thread "aufgefüllt" werden, sodass die Animation auch dann weiter funktioniert, wenn der Haupt-Thread "gedacht" ist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc0/250/3da/bc02503da9d76ff4b66ae038ce3cf81f.png"><br><br>  Die praktische Konsequenz dieser Lösung ist jedoch, dass alle UI-Objekte ohnehin im selben Thread leben müssen.  Bei alten Widgets im "Haupt" -Thread, bei neuen Qt Quick-Objekten im QQuickWindow-Objekt-Thread, dem sie gehören.  Die letzte Regel wird ziemlich elegant geschlagen - um ein QQuickItem zu zeichnen, muss setParent auf das entsprechende QQuickWindow gesetzt werden, wodurch, wie bereits erläutert, sichergestellt wird, dass das Objekt entweder in den entsprechenden Stream verschoben wird oder der Aufruf von setParent fehlschlägt. <br><br>  Und jetzt leider eine Fliege in der Salbe: Obwohl verschiedene QQuickWindow theoretisch in verschiedenen Streams leben könnten, erfordert dies in der Praxis ein genaues Senden von Nachrichten vom Betriebssystem an sie und in Qt ist es heute nicht implementiert.  In Qt 5.13 versucht QCoreApplication beispielsweise, über sendEvent mit QQuickWindow zu kommunizieren, wobei sich der Empfänger und der sendende Teilnehmer im selben Thread befinden müssen (anstelle von postEvent, wodurch die Threads unterschiedlich sein können).  Daher funktioniert QQuickWindow in der Praxis nur in einem GUI-Thread ordnungsgemäß. Daher befinden sich alle QtQuick-Objekte an derselben Stelle.  Trotz des Vorhandenseins des Rendering-Threads befinden sich fast alle dem Benutzer zur Verfügung stehenden GUI-bezogenen Objekte weiterhin im selben GUI-Thread.  Vielleicht ändert sich dies in Qt 6. <br><br>  Darüber hinaus ist zu beachten, dass das Framework, da Qt auf vielen verschiedenen Plattformen funktioniert (einschließlich solcher, die kein Multithreading unterstützen), eine anständige Anzahl von Fallbacks bietet und in einigen Fällen die Rendering-Thread-Funktionalität tatsächlich von demselben GUI-Thread ausgeführt wird .  In diesem Fall befindet sich die gesamte Benutzeroberfläche, einschließlich des Renderns, in einem Thread, und das Synchronisierungsproblem verschwindet automatisch.  Ähnlich verhält es sich mit der älteren Widget-basierten Benutzeroberfläche im Qt4-Stil.      Qt    «»       QSG_RENDER_LOOP   . <br><br><a name="part6"></a><h3>  Fazit </h3><br> Qt —              .     ,   ,           Qt      . <br><br>     ; <br><br><ul><li>    «»         ,   queued signals </li><li>  «»     Qt Event Loop                   exit() </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eltern und Nachkommen leben immer im selben Strom. </font><font style="vertical-align: inherit;">Nur übergeordnete Elemente der obersten Ebene können von Stream zu Stream übertragen werden. </font><font style="vertical-align: inherit;">Ein Verstoß gegen diese Regel kann zu einem stillen Ausfall der Operation setParent oder moveToThread führen</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein Objekt, dessen übergeordnetes Element nicht angegeben ist, wird zur Eigenschaft des Threads, den dieses Objekt erstellt hat. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alle GUI-Objekte mit Ausnahme des Rendering-Backends müssen im GUI-Stream gespeichert sein </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der GUI-Thread ist derjenige, in dem das QApplication-Objekt erstellt wurde </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich hoffe, dass dies Ihnen hilft, Qt effizienter zu nutzen und keine Fehler im Zusammenhang mit seinem Multithread-Modell zu machen. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467261/">https://habr.com/ru/post/de467261/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467251/index.html">Geiseln COBOL und Math. Teil 1</a></li>
<li><a href="../de467253/index.html">Geiseln COBOL und Math. Teil 2</a></li>
<li><a href="../de467255/index.html">Drei häufige Sicherheitsfehler, über die jeder Reaktionsentwickler Bescheid wissen sollte</a></li>
<li><a href="../de467257/index.html">Lagern Sie nicht alle Eier gleichzeitig in einem Korb</a></li>
<li><a href="../de467259/index.html">DPI (SSL Inspection) widerspricht der Bedeutung von Kryptografie, wird jedoch von Unternehmen implementiert</a></li>
<li><a href="../de467263/index.html">Wir verdienen mit Solarenergie oder passivem Einkommen 25% pro Jahr, praktische Erfahrung. Teil 2</a></li>
<li><a href="../de467269/index.html">Modelle in der Informationssicherheit</a></li>
<li><a href="../de467271/index.html">Berufsprogrammierer, Chemiker von Beruf</a></li>
<li><a href="../de467275/index.html">Zum Tag des Programmierers. Programmierer im Jahr 2019</a></li>
<li><a href="../de467277/index.html">pg_stat_statements + pg_stat_activity + loq_query = pg_ash?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>