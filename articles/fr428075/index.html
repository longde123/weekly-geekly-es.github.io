<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õîÔ∏è ü§Æ üëµüèª Vous ne pouvez tout de m√™me pas le faire! - Utilisation d'interfaces et d'injection de d√©pendances pour une conception √† long terme ‚óΩÔ∏è üöé üòª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! 

 Nous avons enfin un contrat pour mettre √† jour le livre de Mark Siman " Dependency Injection in .NET " - l'essentiel est qu'il l'ac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vous ne pouvez tout de m√™me pas le faire! - Utilisation d'interfaces et d'injection de d√©pendances pour une conception √† long terme</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/428075/">  Bonjour √† tous! <br><br>  Nous avons enfin un contrat pour mettre √† jour le livre de Mark Siman " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dependency Injection in .NET</a> " - l'essentiel est qu'il l'ach√®ve d√®s que possible.  Nous avons √©galement un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livre</a> dans l'√©diteur du respect√© Dinesh Rajput sur les mod√®les de conception au printemps 5, o√π l'un des chapitres est √©galement consacr√© √† la mise en ≈ìuvre des d√©pendances. <br><br>  Nous recherchons depuis longtemps des documents int√©ressants qui rappelleront les forces du paradigme DI et clarifieront notre int√©r√™t pour lui - et maintenant il a √©t√© trouv√©.  Certes, l'auteur a pr√©f√©r√© donner des exemples dans Go.  Nous esp√©rons que cela ne vous emp√™che pas de suivre ses pens√©es et aide √† comprendre les principes g√©n√©raux de l'inversion de contr√¥le et de travailler avec des interfaces, si ce sujet est proche de vous. <br><br>  La coloration √©motionnelle de l'original est un peu plus silencieuse, le nombre de points d'exclamation dans la traduction est r√©duit.  Bonne lecture! <br><a name="habracut"></a><br>  L'utilisation d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interfaces</a> est une technique compr√©hensible qui vous permet de cr√©er du code facile √† tester et facilement extensible.  J'ai √©t√© √† plusieurs reprises convaincu qu'il s'agit de l'outil de conception d'architecture le plus puissant de tous. <br><br>  Le but de cet article est d'expliquer ce que sont les interfaces, comment elles sont utilis√©es et comment elles fournissent l'extensibilit√© et la testabilit√© du code.  Enfin, l'article devrait montrer comment les interfaces peuvent aider √† optimiser la gestion de la livraison de logiciels et √† simplifier la planification! <br><br>  <b>Interfaces</b> <br><br>  L'interface d√©crit le contrat.  Selon le langage ou le framework, l'utilisation des interfaces peut √™tre dict√©e explicitement ou implicitement.  Ainsi, dans le langage Go, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interfaces sont dict√©es explicitement</a> .  Si vous essayez d'utiliser une entit√© comme interface, mais qu'elle ne sera pas enti√®rement coh√©rente avec les r√®gles de cette interface, une erreur de compilation se produira.  Par exemple, en ex√©cutant l'exemple ci-dessus, nous obtenons l'erreur suivante: <br><br><pre><code class="hljs sql">prog.go:22:85: cannot <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> BadPricer literal (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BadPricer) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StockPricer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> argument <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> isPricerHigherThan100: BadPricer does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> implement StockPricer (<span class="hljs-keyword"><span class="hljs-keyword">missing</span></span> CurrentPrice method) Program exited.</code> </pre> <br>  Les interfaces sont un outil pour aider √† d√©tacher l'appelant de l'appel√©, cela se fait √† l'aide d'un contrat. <br><br>  Concr√©tisons ce probl√®me √† l'aide d'un exemple de programme d'√©change automatique de devises.  Le programme de n√©gociation sera appel√© avec un prix d'achat d√©fini et un symbole boursier.  Ensuite, le programme ira √† la bourse pour conna√Ætre la cotation actuelle de ce ticker.  De plus, si le prix d'achat de ce ticker ne d√©passe pas le prix fix√©, le programme effectuera un achat. <br><br><img src="https://habrastorage.org/webt/pp/hx/mv/pphxmvus0-rkxh-vffl9o18bjsq.png"><br><br>  Sous une forme simplifi√©e, l'architecture de ce programme peut √™tre repr√©sent√©e comme suit.  D'apr√®s l'exemple ci-dessus, il est clair que l'op√©ration d'obtention du prix actuel d√©pend directement du protocole HTTP, par lequel le programme contacte le service d'√©change. <br><br>  L'√©tat de l' <code>Action</code> √©galement directement de HTTP.  Ainsi, les deux √âtats doivent comprendre parfaitement comment utiliser HTTP pour extraire des donn√©es d'√©change et / ou effectuer des transactions. <br><br>  Voici √† quoi pourrait ressembler l'impl√©mentation: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxTradePrice </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err)</span></span></span></span> { resp, err := http.Get( <span class="hljs-string"><span class="hljs-string">"http://stock-service.com/currentprice/"</span></span> + ticker ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... currentPrice := parsePriceFromBody(body) var hasTraded bool var err error if currentPrice &lt;= maximumTradePrice { err = doTrade(ticker, currentPrice) if err == nil { hasTraded = true } } return hasTraded, err }</span></span></code> </pre> <br>  Ici, l'appelant ( <code>analyze</code> ) d√©pend directement de HTTP.  Elle a besoin de savoir comment les requ√™tes HTTP sont formul√©es.  Comment l'analyse est-elle effectu√©e?  Comment g√©rer les tentatives, les d√©lais d'attente, l'authentification, etc.  Elle a une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prise</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">main</a> √©troite sur <code>http</code> .  <b>Chaque fois que nous appelons analyse, nous devons √©galement appeler la biblioth√®que <code>http</code></b> . <br><br>  Comment l'interface peut-elle nous aider ici?  Dans le contrat fourni par l'interface, vous pouvez d√©crire le <b>comportement</b> plut√¥t que l' <b>impl√©mentation</b> sp√©cifique. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StockExchange <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { CurrentPrice(ticker <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> }</code> </pre> <br>  Ce qui pr√©c√®de d√©finit le concept de <code>StockExchange</code> .  Il indique ici que <code>StockExchange</code> prend en charge l'appel de la seule fonction <code>CurrentPrice</code> .  Ces trois lignes me semblent la technique architecturale la plus puissante de toutes.  Ils nous aident √† contr√¥ler les d√©pendances des applications de mani√®re beaucoup plus s√ªre.  Fournir des tests.  Fournir une extensibilit√©. <br><br>  <b>Injection de d√©pendance</b> <br><br>  Afin de bien comprendre la valeur des interfaces, vous devez ma√Ætriser la technique appel√©e ¬´injection de d√©pendance¬ª. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'injection de d√©pendance</a> signifie que l'appelant fournit quelque chose dont il a besoin.  Habituellement, cela ressemble √† ceci: l'appelant configure l'objet, puis le transmet √† l'appel√©.  Ensuite, l'appel√© r√©sume la configuration et la mise en ≈ìuvre.  Dans ce cas, il existe une m√©diation connue.  Consid√©rez une demande au service HTTP Rest.  Pour impl√©menter le client, nous devons utiliser une biblioth√®que HTTP qui peut formuler, envoyer et recevoir des requ√™tes HTTP. <br><br>  Si nous pla√ßions la requ√™te HTTP derri√®re l'interface, l'appelant pourrait √™tre d√©tach√©, et elle ne serait "pas au courant" que la requ√™te HTTP a r√©ellement eu lieu. <br><br>  L'appelant ne doit effectuer qu'un appel de fonction g√©n√©rique.  Cela peut √™tre un appel local, un appel distant, un appel HTTP, un appel RPC, etc.  L'appelante n'est pas au courant de ce qui se passe, et cela lui convient g√©n√©ralement parfaitement, tant qu'elle obtient les r√©sultats escompt√©s.  Ce qui suit montre √† quoi pourrait ressembler l'injection de d√©pendance dans notre m√©thode d' <code>analyze</code> . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se StockExchange, ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxTradePrice </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { currentPrice := se.CurrentPrice(ticker) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hasTraded <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currentPrice &lt;= maximumTradePrice { err = doTrade(ticker, currentPrice) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { hasTraded = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasTraded, err }</code> </pre> <br>  Je ne cesse d'√™tre √©tonn√© de ce qui se passe ici.  Nous avons compl√®tement invers√© notre arbre de d√©pendance et commenc√© √† mieux contr√¥ler l'ensemble du programme.  De plus, m√™me visuellement, toute la mise en ≈ìuvre est devenue plus propre et plus compr√©hensible.  Nous voyons clairement que la m√©thode d'analyse doit choisir le prix actuel, v√©rifier si ce prix nous convient et, dans l'affirmative, conclure un accord. <br><br>  Plus important encore, dans ce cas, nous d√©tachons l'appelant de l'appelant.  √âtant donn√© que l'appelant et l'impl√©mentation enti√®re sont s√©par√©s de l'appel√© √† l'aide de l'interface, vous pouvez √©tendre l'interface en en cr√©ant de nombreuses impl√©mentations diff√©rentes.  Les interfaces vous permettent de cr√©er de nombreuses impl√©mentations sp√©cifiques diff√©rentes sans n√©cessiter de changer le code de l'appel√©! <br><br><img src="https://habrastorage.org/webt/c8/us/5_/c8us5_mv_y2tmittjhk33ahgw7i.png"><br><br>  Le statut ¬´obtenir le prix actuel¬ª dans ce programme d√©pend uniquement de l'interface <code>StockExchange</code> .  Cette impl√©mentation ne sait pas comment contacter le service d'√©change, comment les prix sont stock√©s ou comment les demandes sont faites.  Une v√©ritable ignorance b√©at.  De plus, bilat√©ral.  L'impl√©mentation <code>HTTPStockExchange</code> ne sait √©galement rien de l'analyse.  A propos du contexte dans lequel l'analyse sera effectu√©e, quand elle est effectu√©e - parce que les d√©fis se produisent indirectement. <br><br>  √âtant donn√© que les fragments de programme (ceux qui d√©pendent des interfaces) n'ont pas besoin d'√™tre modifi√©s lors du changement / ajout / suppression d'impl√©mentations sp√©cifiques, <b>une telle conception s'av√®re durable</b> .  Supposons que nous trouvions que <code>StockService</code> tr√®s souvent indisponible. <br><br>  En quoi l'exemple ci-dessus est diff√©rent de l'appel d'une fonction?  Lors de l'application d'un appel de fonction, l'impl√©mentation deviendra √©galement plus propre.  La diff√©rence est que lorsque vous appelez la fonction, nous devons toujours recourir √† HTTP.  La m√©thode d' <code>analyze</code> d√©l√©guera simplement la t√¢che de la fonction, qui devrait appeler <code>http</code> , plut√¥t que d'appeler directement <code>http</code> lui-m√™me.  Toute la force de cette technique r√©side dans l '¬´injection¬ª, c'est-√†-dire que l'appelant fournit l'interface √† l'appel√©.  C'est exactement comme cela que se produit l'inversion de d√©pendance, o√π les prix d'obtention d√©pendent uniquement de l'interface et non de l'impl√©mentation. <br><br>  <b>Plusieurs impl√©mentations pr√™tes √† l'emploi</b> <br><br>  √Ä ce stade, nous avons la fonction d' <code>analyze</code> et l'interface <code>StockExchange</code> , mais nous ne pouvons rien faire d'utile.  Je viens d'annoncer notre programme.  Pour le moment, il est impossible de l'appeler, car nous n'avons toujours pas une seule impl√©mentation sp√©cifique qui r√©pondrait aux exigences de notre interface. <br><br>  L'accent principal dans le diagramme suivant est mis sur l'√©tat ¬´obtenir le prix actuel¬ª et sa d√©pendance √† l'interface <code>StockExchange</code> .  Ce qui suit montre comment deux impl√©mentations compl√®tement diff√©rentes coexistent et que le prix actuel n'est pas connu.  De plus, les deux impl√©mentations ne sont pas li√©es l'une √† l'autre, chacune d'entre elles ne d√©pend que de l'interface <code>StockExchange</code> . <br><br><img src="https://habrastorage.org/webt/c8/us/5_/c8us5_mv_y2tmittjhk33ahgw7i.png"><br><br>  La production <br><br>  L'impl√©mentation HTTP d'origine existe d√©j√† dans l'impl√©mentation d' <code>analyze</code> principale;  il ne nous reste plus qu'√† l'extraire et √† l'encapsuler derri√®re une impl√©mentation concr√®te de l'interface. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> HTTPStockExchange <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se HTTPStockExchange)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { resp, err := http.Get( <span class="hljs-string"><span class="hljs-string">"http://stock-service.com/currentprice/"</span></span> + ticker ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... return parsePriceFromBody(body) }</span></span></code> </pre> <br>  Le code que nous avons pr√©c√©demment li√© √† la fonction d'analyse est maintenant autonome et satisfait l'interface <code>StockExchange</code> , c'est-√†-dire que nous pouvons maintenant le passer √† <code>analyze</code> .  Comme vous vous en souvenez des diagrammes ci-dessus, l'analyse n'est plus associ√©e √† la d√©pendance HTTP.  √Ä l'aide de l'interface, l' <code>analyze</code> n'imagine pas ce qui se passe dans les coulisses.  Il sait seulement qu'on lui garantira un objet avec lequel il pourra appeler <code>CurrentPrice</code> . <br><br>  Ici aussi, nous profitons des vertus typiques de l'encapsulation.  Avant, lorsque les requ√™tes http √©taient li√©es √† l'analyse, la seule fa√ßon de communiquer avec l'√©change via http √©tait indirecte - via la m√©thode d' <code>analyze</code> .  Oui, nous pourrions encapsuler ces appels dans des fonctions et ex√©cuter la fonction ind√©pendamment, mais les interfaces nous obligent √† d√©tacher l'appelant de l'appelant.  Nous pouvons maintenant tester <code>HTTPStockExchange</code> quel que soit l'appelant.  Cela affecte fondamentalement la port√©e de nos tests et la fa√ßon dont nous comprenons et r√©pondons aux √©checs des tests. <br><br>  <b>Test</b> <br><br>  Dans le code existant, nous avons la structure <code>HTTPStockService</code> , qui nous permet de nous assurer s√©par√©ment qu'il peut communiquer avec le service d'√©change et analyser les r√©ponses re√ßues de celui-ci.  Mais maintenant, assurons-nous que l'analyse peut g√©rer correctement la r√©ponse de l'interface <code>StockExchange</code> , en outre, que cette op√©ration est fiable et reproductible. <br><br><pre> <code class="go hljs">currentPrice := se.CurrentPrice(ticker) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currentPrice &lt;= maxTradePrice { err := doTrade(ticker, currentPrice) }</code> </pre> <br>  NOUS POUVONS utiliser l'impl√©mentation avec HTTP, mais cela aurait de nombreux inconv√©nients.  Les appels r√©seau dans les tests unitaires peuvent √™tre lents, en particulier pour les services externes.  En raison de retards et d'une connexion r√©seau instable, les tests pourraient s'av√©rer peu fiables.  De plus, si nous avions besoin de tests avec la d√©claration que nous pouvons terminer la transaction et de tests avec la d√©claration que nous pouvons filtrer les cas dans lesquels la transaction ne devrait PAS √™tre conclue, il serait difficile de trouver de vraies donn√©es de production qui satisfassent de mani√®re fiable ces deux conditions.  On pourrait choisir <code>maxTradePrice</code> , en imitant artificiellement chacune des conditions de cette mani√®re, par exemple, avec <code>maxTradePrice := -100</code> transaction ne devrait pas √™tre termin√©e, et <code>maxTradePrice := 10000000</code> devrait √©videmment se terminer avec la transaction. <br><br>  Mais que se passe-t-il si un certain quota nous est attribu√© sur le service d'√©change?  Ou si nous devons payer l'acc√®s?  Allons-nous vraiment (et devrions-nous) payer ou d√©penser notre quota en mati√®re de tests unitaires?  Id√©alement, les tests devraient √™tre ex√©cut√©s aussi souvent que possible, donc ils devraient √™tre rapides, bon march√© et fiables.  Je pense qu'√† partir de ce paragraphe, il est clair pourquoi utiliser une version avec HTTP pur est irrationnel en termes de tests! <br><br>  <b>Il y a une meilleure fa√ßon, et cela implique d'utiliser des interfaces!</b> <br><br>  Ayant une interface, vous pouvez fabriquer avec soin l'impl√©mentation <code>StockExchange</code> , ce qui nous permettra d' <code>analyze</code> rapidement, en toute s√©curit√© et de mani√®re fiable. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StubExchange <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Price <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se StubExchange)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> se.Price } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAnalyze_MakeTrade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { se := StubExchange{Price: <span class="hljs-number"><span class="hljs-number">10</span></span>} maxTradePrice := <span class="hljs-number"><span class="hljs-number">11</span></span> traded, err := analyze(se, <span class="hljs-string"><span class="hljs-string">"TSLA"</span></span>, maxTradePrice) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Errorf(<span class="hljs-string"><span class="hljs-string">"expected err == nil received: %s"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !traded { t.Error(<span class="hljs-string"><span class="hljs-string">"expected traded == true"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAnalyze_DontTrade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { se := StubExchange{Price: <span class="hljs-number"><span class="hljs-number">10</span></span>} maxTradePrice := <span class="hljs-number"><span class="hljs-number">9</span></span> traded, err := analyze(se, <span class="hljs-string"><span class="hljs-string">"TSLA"</span></span>, maxTradePrice) <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br>  Le talon du service d'√©change est utilis√© ci-dessus, gr√¢ce auquel la branche qui nous int√©resse dans l' <code>analyze</code> est lanc√©e.  Ensuite, des d√©clarations sont faites dans chacun des tests pour s'assurer que l'analyse fait ce qui est n√©cessaire.  Bien qu'il s'agisse d'un programme de test, mon exp√©rience sugg√®re que les composants / architecture, o√π les interfaces sont utilis√©es √† peu pr√®s de cette mani√®re, sont √©galement test√©s pour la durabilit√© dans le code de bataille !!!  Gr√¢ce aux interfaces, nous pouvons utiliser le <code>StockExchange</code> contr√¥l√© en m√©moire, qui fournit des tests fiables, facilement configurables, faciles √† comprendre, reproductibles et ultra-rapides !!! <br><br>  <b>D√©tacher - Configuration de l'appelant</b> <br><br>  Maintenant que nous avons discut√© de la fa√ßon d'utiliser les interfaces pour d√©tacher l'appelant de l'appel√© et de la fa√ßon de r√©aliser plusieurs impl√©mentations, nous n'avons toujours pas abord√© un aspect critique.  Comment configurer et fournir une impl√©mentation sp√©cifique √† un moment strictement d√©fini?  Vous pouvez appeler directement la fonction d'analyse, mais que faire dans la configuration de production? <br><br>  C'est l√† que l'impl√©mentation des d√©pendances est utile. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ticker = flag.String(<span class="hljs-string"><span class="hljs-string">"ticker"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"stock ticker symbol to trade for"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maxTradePrice = flag.Float64(<span class="hljs-string"><span class="hljs-string">"maxtradeprice"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"max price to pay for a share of the ticker symbol."</span></span> se := HTTPStockExchange{} analyze(se, *ticker, *maxTradePrice) }</code> </pre> <br>  Tout comme dans notre cas de test, l'impl√©mentation concr√®te sp√©cifique de StockExchange qui sera utilis√©e avec <code>analyze</code> est configur√©e par l'appelant en dehors de l'analyse.  Ensuite, il est pass√© (inject√©) pour <code>analyze</code> .  Cela garantit que rien n'est analys√© sur la fa√ßon dont <code>HTTPStockExchange</code> configur√©.  Peut-√™tre que nous aimerions fournir le domaine http que nous allons utiliser sous la forme d'un indicateur de ligne de commande, puis l'analyse n'aura pas √† changer.  Ou que faire si nous devons fournir une sorte d'authentification ou de jeton pour acc√©der √† <code>HTTPStockExchange</code> , qui sera extrait de l'environnement?  Encore une fois, l'analyse ne devrait pas changer. <br><br>  La configuration a lieu √† un niveau ext√©rieur √† l' <code>analyze</code> , lib√©rant ainsi compl√®tement l'analyse de la n√©cessit√© de configurer ses propres d√©pendances.  Ainsi, une stricte s√©paration des t√¢ches est r√©alis√©e. <br><br><img src="https://habrastorage.org/webt/nq/jt/_i/nqjt_id9j2-yc7rzozkrldtrwxq.png"><br><br>  <b>D√©cisions de mise en rayon</b> <br><br>  Les exemples ci-dessus suffisent peut-√™tre, mais il existe encore de nombreux autres avantages aux interfaces et √† l'injection de d√©pendances.  Les interfaces permettent de diff√©rer les d√©cisions concernant des impl√©mentations sp√©cifiques.  Bien que les d√©cisions nous obligent √† d√©cider du comportement que nous prendrons en charge, elles nous permettent toujours de prendre des d√©cisions sur des impl√©mentations sp√©cifiques plus tard.  Supposons que nous savions que nous voulions effectuer des transactions automatis√©es, mais que nous ne savions pas encore quel fournisseur de devis utiliser.  Une classe de solutions similaire est constamment trait√©e lorsque vous travaillez avec des entrep√¥ts de donn√©es.  Que doit utiliser notre programme: mysql, postgres, redis, syst√®me de fichiers, cassandra?  En fin de compte, tout cela est des d√©tails de mise en ≈ìuvre, et les interfaces nous permettent de diff√©rer les d√©cisions finales sur ces questions.  Ils nous permettent de d√©velopper la logique m√©tier de nos programmes, et de basculer vers des solutions technologiques sp√©cifiques au dernier moment! <br><br>  Malgr√© le fait que cette technique seule laisse de nombreuses possibilit√©s, quelque chose de magique se produit au niveau de la planification du projet.  Imaginez ce qui se passera si nous ajoutons une d√©pendance suppl√©mentaire √† l'interface d'√©change. <br><br><img src="https://habrastorage.org/webt/pb/bf/x-/pbbfx-mcx9oabbpa-tkkeivgtnq.png"><br><br>  Ici, nous allons reconfigurer notre architecture sous la forme d'un graphe acyclique dirig√©, de sorte que d√®s que nous nous mettrons d'accord sur les d√©tails de l'interface d'√©change, nous pouvons COMPETITEMENT continuer √† travailler avec le pipeline √† l'aide de <code>HTTPStockExchange</code> .  Nous avons cr√©√© une situation dans laquelle l'ajout d'une nouvelle personne au projet nous aide √† avancer plus rapidement.  En modifiant notre architecture de cette mani√®re, nous pouvons mieux voir o√π, quand et pendant combien de temps nous pouvons engager des personnes suppl√©mentaires dans le projet afin d'acc√©l√©rer la livraison de l'ensemble du projet.  De plus, comme la connexion entre nos interfaces est faible, il est g√©n√©ralement facile de s'impliquer dans le travail, √† commencer par les interfaces d'impl√©mentation.  Vous pouvez d√©velopper, tester et tester <code>HTTPStockExchange</code> compl√®tement ind√©pendamment de notre programme! <br><br>  L'analyse des d√©pendances architecturales et la planification en fonction de ces d√©pendances peuvent acc√©l√©rer consid√©rablement les projets.  Gr√¢ce √† cette technique particuli√®re, j'ai pu r√©aliser tr√®s rapidement des projets pour lesquels plusieurs mois ont √©t√© allou√©s. <br><br>  <b>Devant</b> <br><br>  Maintenant, il devrait √™tre plus clair comment les interfaces et la mise en ≈ìuvre des d√©pendances assurent la durabilit√© du programme con√ßu.  Supposons que nous modifions notre fournisseur de devis ou que nous commencions √† diffuser des quotas et les enregistrions en temps r√©el;  il y a autant d'autres possibilit√©s que vous le souhaitez.  La m√©thode d'analyse dans sa forme actuelle prendra en charge toute impl√©mentation adapt√©e √† l'int√©gration avec l'interface <code>StockExchange</code> . <br><br><pre> <code class="go hljs">se.CurrentPrice(ticker)</code> </pre> <br>  Ainsi, dans de nombreux cas, vous pouvez vous passer de modifications.  Pas du tout, mais dans les cas pr√©visibles que nous pouvons rencontrer.  Nous sommes non seulement √† l'abri de la n√©cessit√© de modifier le code d' <code>analyze</code> et de rev√©rifier ses fonctionnalit√©s cl√©s, mais nous pouvons facilement proposer de nouvelles impl√©mentations ou basculer entre les fournisseurs.  Nous pouvons √©galement √©tendre ou mettre √† jour en douceur les impl√©mentations sp√©cifiques que nous avons d√©j√† sans avoir besoin de modifier ou de rev√©rifier l' <code>analyze</code> ! <br><br>  J'esp√®re que les exemples ci-dessus d√©montrent de mani√®re convaincante comment l'affaiblissement de la connexion entre les entit√©s du programme par l'utilisation d'interfaces r√©oriente compl√®tement les d√©pendances et s√©pare l'appelant de l'appelant.  Gr√¢ce √† ce d√©tachement, le programme ne d√©pend pas d'une impl√©mentation sp√©cifique, mais il d√©pend d'un <b>comportement</b> sp√©cifique.  Ce comportement peut √™tre fourni par une grande vari√©t√© d'impl√©mentations.  Ce principe de conception critique est √©galement appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">typage du canard</a> . <br><br>  Le concept d'interfaces et la d√©pendance au comportement, et non √† l'impl√©mentation, est si puissant que je consid√®re les interfaces comme une langue primitive - oui, c'est assez radical.  J'esp√®re que les exemples discut√©s ci-dessus se sont av√©r√©s assez convaincants, et vous conviendrez que les interfaces et l'injection de d√©pendances devraient √™tre utilis√©es d√®s le d√©but du projet.  Dans presque tous les projets sur lesquels j'ai travaill√©, il fallait non pas une, mais au moins deux impl√©mentations: pour la production et pour les tests. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428075/">https://habr.com/ru/post/fr428075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428063/index.html">Les navigateurs refusent la prise en charge de TLS 1.0 et 1.1</a></li>
<li><a href="../fr428065/index.html">Moins ne signifie pas pire: skyrmions et murs de domaine dans les ferromagn√©tiques</a></li>
<li><a href="../fr428067/index.html">AntiFuzzing: la s√©curit√© par l'obscurit√©!?</a></li>
<li><a href="../fr428069/index.html">Optimiser l'√©quilibrage de charge dans l'infrastructure Veeam Backup & Replication</a></li>
<li><a href="../fr428073/index.html">Rust 1.30 Release</a></li>
<li><a href="../fr428077/index.html">React.js: Guide du d√©butant</a></li>
<li><a href="../fr428079/index.html">Appliquer les principes SOLID pour r√©agir au d√©veloppement d'applications</a></li>
<li><a href="../fr428081/index.html">Utilisation de RxJS dans React Development pour g√©rer l'√©tat de l'application</a></li>
<li><a href="../fr428083/index.html">Matrice d'influence de l'analyse Web - Syst√®me strat√©gique d'Avinash Koshik</a></li>
<li><a href="../fr428085/index.html">Frontend contre-attaque: Top 10 (?) Rapports HolyJS 2018 Piter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>