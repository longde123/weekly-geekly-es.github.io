<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç≠ „Ä∞Ô∏è üõÅ Swift funcional üöÉ ü§© üéπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øQu√© une "curry", "m√≥nadas", "tipos de datos algebraicos"? No solo el hecho de que algunos desarrolladores est√°n tratando de eludir estas palabras, si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift funcional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462121/">  <em>¬øQu√© une "curry", "m√≥nadas", "tipos de datos algebraicos"?</em>  <em>No solo el hecho de que algunos desarrolladores est√°n tratando de eludir estas palabras, sino tambi√©n la programaci√≥n funcional.</em>  <em>Bajo la cuidadosa gu√≠a de Yevgeny Elchev, nos sumergimos en un paradigma funcional y entendimos casi todo.</em>  <em>No se asuste con anticipaci√≥n, no dude en leer la transcripci√≥n de la d√©cima edici√≥n del podcast de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppsCast</a> .</em> <br><br><img src="https://habrastorage.org/webt/hq/lv/vo/hqlvvoaeah9ruqamawgdcwrtwbk.png"><br><a name="habracut"></a><br>  <strong>Daniil Popov:</strong> Hola a todos.  Hoy, nuestro invitado es Evgeny Elchev del soleado Krasnoyarsk.  Eugene, dime qu√© est√°s haciendo y c√≥mo llegaste a la programaci√≥n funcional. <br><br>  <strong>Evgeny Elchev:</strong> Hola a todos.  Soy desarrollador de iOS en Redmadrobot, como todos los dem√°s, pinto botones, a veces escribo l√≥gica de negocios. <br><br>  Primero me familiaric√© con la programaci√≥n funcional a trav√©s de art√≠culos.  Yo, sin entender el punto, pens√© que era una especie de programaci√≥n de procedimiento, sin clases.  Cuando le√≠ m√°s de cerca uno de los art√≠culos, me di cuenta de que estaba equivocado y comenc√© a cavar.  Esto no quiere decir que acabo de <strong>llegar</strong> a la programaci√≥n funcional, ya que los seguidores reales pondr√°n sus huesos para ello y escribir√°n en Haskell, usando m√≥nadas siempre que sea posible.  Acabo de zambullirme y usarlo solo en producci√≥n. <br><br>  <strong>Daniil Popov:</strong> Entonces, las m√≥nadas ya se han ido. <br><br>  <strong>Evgeny Elchev: ¬ø</strong> Ya es dif√≠cil? <br><br>  <strong>Daniil Popov:</strong> Trat√© de seguir el mismo camino, pero abr√≠ el art√≠culo, vi las palabras "curry", "m√≥nada" e inmediatamente lo cerr√©, pensando que a√∫n no era digno.  ¬øTengo una oportunidad? <br><br>  <strong>Evgeny Elchev:</strong> Por supuesto.  Puede que no sepas esto en absoluto. <br><br><h2>  En palabras simples sobre funcionalismo </h2><br>  <strong>Daniil Popov:</strong> demos una definici√≥n simple para aquellos que nunca han o√≠do hablar de un paradigma funcional. <br><br>  <strong>Evgeny Elchev:</strong> Todos entienden los paradigmas a su manera.  Si tomamos la explicaci√≥n de Wikipedia, este es el uso de funciones matem√°ticas, donde todo el programa se interpreta como una funci√≥n matem√°tica. <br><br><blockquote>  El enfoque funcional (FP) es cuando utiliza funciones en su trabajo que solo tienen argumentos de entrada y un valor de salida.  Si el programa completo consta de tales funciones, entonces este es un programa funcional. </blockquote><br>  <strong>Daniil Popov:</strong> OOP fue una continuaci√≥n l√≥gica de la programaci√≥n procesal habitual y resolvi√≥ el problema de encapsular datos en clases.  ¬øQu√© problemas deber√≠a resolver la programaci√≥n funcional? <br><br>  <strong>Evgeny Elchev: los</strong> matem√°ticos inventaron la programaci√≥n funcional.  Los muchachos se reunieron y decidieron crear un paradigma donde todo se puede probar.  Hay c√≥digo, a√∫n no se ha lanzado, pero lo probaremos todo.  Se puede calcular cualquier punto del programa, entendiendo de d√≥nde iremos cuando permitamos alguna acci√≥n. <br><br>  Suena abstracto, as√≠ que veamos un ejemplo de una funci√≥n pura.  Escribimos una funci√≥n de suma que toma dos argumentos, le pasamos 2 y 3, obtenemos 5 y podemos probarlo.  Siempre es cierto.  Si todo nuestro programa consta de tales funciones, entonces todo es demostrable. <br><br>  Al crear idiomas, comenzaron a perderse funciones b√°sicas y aparecieron caracter√≠sticas adicionales: lambdas, funciones de orden superior, m√≥nadas, monoides. <br><br><blockquote>  El paradigma funcional no resuelve un solo problema, es el mismo deseo de escribir un buen c√≥digo lo m√°s simple posible para que los programas sean estables y f√°ciles de mantener. </blockquote><br>  Si observa de cerca, muchas de las cosas que utilizamos en OOP se reflejan en un enfoque funcional.  Hay clases en el OPP que encapsulan un conjunto de campos.  En FP, esto tambi√©n se puede hacer usando clases de tipo.  Como a Vitaly Bragilevsky le gusta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">decir</a> : "Si miras la tableta donde van los datos a lo largo de las l√≠neas y las columnas de funci√≥n, entonces el FI va a lo largo de las columnas, OOP va a lo largo de las l√≠neas".  Eso es todo <br><br>  <strong>Daniil Popov:</strong> ¬øC√≥mo se relaciona FI con otros paradigmas?  ¬øPuedo escribir funcionalmente en OOP?  ¬øC√≥mo mezclar paradigmas, y tiene sentido? <br><br>  <strong>Evgeny Elchev:</strong> El paradigma se limita al hecho de que escribes funciones con datos.  Una de las caracter√≠sticas de la FA es la ausencia de estados variables.  Si sus datos son una clase, entonces no hay problema.  Si la clase es completamente inmutable, entonces se puede usar.  Una clase es simplemente un tipo, como una cadena o un n√∫mero, solo que m√°s complejo, que consta de varios valores. <br><br>  <strong>Daniil Popov:</strong> Usted dijo anteriormente que puede probar la correcci√≥n matem√°tica de un programa si lo escribe exclusivamente de manera funcional.  Entonces la broma de "compilado - funciona" para los lenguajes funcionales deja de ser una broma, ¬øverdad? <br><br>  <strong>Evgeny Elchev:</strong> Si nos fijamos en los errores de E / S, entonces s√≠.  Anteriormente, los programadores luchaban con el problema: conectado a la red, sin red, devuelto nulo y todo cay√≥.  Para la soluci√≥n, la forma m√°s f√°cil era verificar lo que vino - nula / no nula, pero dado que exist√≠a el riesgo de que no todo se tuviera en cuenta, el programa podr√≠a compilarse y bloquearse. <br><br>  En los idiomas modernos, esto se decide.  En Haskell, puede escribir un programa que funcione y no se bloquee, pero nadie dir√° c√≥mo funciona correctamente.  Por supuesto, hay tipos estrictos, y no puede cometer un error al agregar un n√∫mero a una cadena, pero siempre puede dejar errores en la aplicaci√≥n, y funcionar√°. <br><br><h2>  Lugar de aproximaci√≥n funcional en Swift </h2><br>  <strong>Alexei Kudryavtsev:</strong> ¬øCu√°nto puede llamarse Swift un lenguaje funcional? <br><br>  <strong>Evgeny Elchev:</strong> Es posible.  La funcionalidad se posiciona como sin estado, pero puede escribir en Swift evitando tales estados.  Al mismo tiempo, Swift no es lo mismo que escribir en iOS, donde hay estados en todas partes.  Por supuesto, en Swift no hay instrucciones especiales como en Haskell, donde todas las funciones est√°n limpias por defecto y el compilador no le permitir√° acceder al estado y cambiarlo.  Si marca la funci√≥n como "sucia", los cambios estar√°n disponibles. <br><br>  <strong>Alexei Kudryavtsev:</strong> En el segundo o tercer Swift, hubo un modificador puro, pero actu√≥ solo en el nivel de compilaci√≥n para que los valores globales no cambiaran.  Escribiste algo en ellos, pero el compilador cort√≥ todo. <br><br>  <strong>Evgeny Elchev:</strong> S√≠, en iOS el compilador no seguir√° esto.  Todo est√° enteramente en nuestra conciencia: mientras escribes, ser√° as√≠. <br><br>  <strong>Alexei Kudryavtsev:</strong> Dices que hay muchos estados en las aplicaciones de iOS, pero ¬ød√≥nde y qu√© hacer con ellas si escribes con un estilo funcional? <br><br>  <strong>Evgeny Elchev:</strong> El estado m√°s importante es la interfaz de usuario, por ejemplo, los campos de entrada.  Pr√°cticamente no se puede hacer nada con ellos.  Puede intentar abstraerse de ellos, recopilarlos en un solo lugar y escribir la mayor cantidad de c√≥digo posible sin tenerlos en cuenta.  Por ejemplo, escribe una funci√≥n sucia que obtiene todos los datos de la interfaz de usuario. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">En mi art√≠culo</a> di un ejemplo de un formulario de autorizaci√≥n, donde es importante que el usuario ingrese un nombre de usuario / contrase√±a.  Escribimos una funci√≥n sucia que devuelve una estructura con datos de autorizaci√≥n, y luego escribimos c√≥digo limpio en ella.  Obtuvimos estos datos, validados, si el resultado es v√°lido, env√≠e una solicitud al servidor.  Una solicitud de servidor tambi√©n es una funci√≥n sucia, y procesarla por completo puede estar limpia.  "Recibido, analizado" es una funci√≥n lineal: la entrada de datos, la salida es nuestra estructura.  Luego se transformaron, filtraron y se pueden mostrar en la pantalla nuevamente. <br><br>  <strong>Alexei Kudryavtsev</strong> : En Haskell, el compilador ayuda mucho.  Si el estado proviene de alg√∫n lugar, toda la cadena de llamadas se considerar√° sucia y deber√° envolver todo en m√≥nadas.  Si la funci√≥n es pura, entonces el almacenamiento en cach√© de los resultados funciona: la misma salida es siempre la misma salida.  En Swift, debe implementar los mapas usted mismo e intentar devolver el resultado si ya est√° en cach√©. <br><br>  <strong>Daniil Popov:</strong> La mayor√≠a de los lenguajes modernos se consideran multi-paradigm√°ticos y muchos tienen caracter√≠sticas funcionales.  Por ejemplo, en Java hay una anotaci√≥n especial para la interfaz: <code>@FunctionalInterface</code> , que obliga al desarrollador a definir solo un m√©todo en la interfaz, de modo que esta interfaz en forma de lambdas se use en todo el c√≥digo.  Cuando agrega un segundo m√©todo o elimina uno existente, el compilador comenzar√° a jurar que ha dejado de ser una interfaz funcional.  ¬øSwift, aparte de la plataforma iOS, tiene caracter√≠sticas tan funcionales? <br><br>  <strong>Evgeny Elchev:</strong> Es dif√≠cil para m√≠ entender qu√© hace una anotaci√≥n en Java.  Si quiere decir que implementa esta interfaz en la clase, y luego implementa solo un m√©todo, entonces no hay tales restricciones en Swift.  Puede crear alias de tipo, nombrarlo y usarlo como un tipo de funci√≥n como un tipo de argumento, un tipo de variable para asignar un cierre.  Puede definir restricciones: argumentos de cierre de entrada y salida.  Las funciones de orden superior que pueden tomar cierres son polimorfismos, y en Swift puede construir polimorfismos en tipos, no limitados a objetos. <br><br>  Pero no s√© cosas funcionales espec√≠ficas.  Sol√≠a ‚Äã‚Äãhaber curry en el primer Swift, pero estaba cortado.  Ahora podemos escribir una funci√≥n para cursarnos, o escribir una funci√≥n para que devuelva cierres entre s√≠, pero esto no es del todo correcto. <br><br><blockquote>  No tenemos functores ni m√≥nadas en caja.  Ni siquiera se pueden escribir.  Las nuevas caracter√≠sticas en Swift 5.1 deber√≠an ayudar a hacer esto, pero trat√© de escribir ese c√≥digo y xCode se cay√≥. </blockquote><br>  En principio, en Swift, si lo desea, es f√°cil hacer todo usted mismo.  Ya hay una m√≥nada opcional fuera de la caja (en Haskell, tal vez).  Ella tiene un mapa y un mapa plano para construir computaci√≥n lineal. <br><br>  Swift tiene una poderosa coincidencia de patrones.  Switch, que existe en casi todos los idiomas y en la mayor√≠a de los casos asocia un n√∫mero entero con una unidad, puede asociar una variable con un patr√≥n espec√≠fico, rangos, tipos, extraer valores de tipos relacionados.  Hay cartago: compones un nuevo tipo y le pasas varios m√°s.  En base a ellos, tambi√©n puede hacer una coincidencia de patrones.  Hay una enumeraci√≥n que puede limitar los tipos, vincular los tipos relacionados con ellos. <br><br>  <strong>Alexei Kudryavtsev:</strong> Aclarar√© que los tipos relacionados son similares a las clases selladas de Kotlin.  Esta es la enumeraci√≥n dentro del caso en el que puede poner el valor enlazado.  A cambio, puede escribir: aqu√≠ est√° el caso, expandir, dentro del objeto.  Por ejemplo, los casos de usuarios y empresas con los objetos correspondientes pueden ser enumerados y pueden cambiarse.  Solo las clases selladas son extensibles y el interruptor es finito. <br><br><h3>  ¬øPor qu√© un movilista necesita funcionalismo? </h3><br>  <strong>Daniil Popov:</strong> ¬øC√≥mo es √∫til un enfoque funcional para el desarrollo m√≥vil?  ¬øHay alg√∫n problema que resuelva? <br><br>  <strong>Evgeny Elchev:</strong> No existe un problema espec√≠fico que pueda resolverse precisamente con la ayuda de la programaci√≥n funcional. <br><br><blockquote>  Lo m√°s importante es que, siguiendo estos principios, incluso si no funciona, debemos abandonar las condiciones, porque son el principal dolor. </blockquote><br>  Al abandonarlos, haces que tu c√≥digo sea m√°s comprensible.  No estoy diciendo que habr√° menos errores, porque esto debe medirse al menos.  Sin embargo, cuando comienza a implementar algo, el c√≥digo cambia.  A menudo sucede que mira el c√≥digo y todo lo que contiene es el caso, pero comienza a reescribir, intercambiar, eliminar innecesarios y m√°s f√°ciles de leer. <br><br><blockquote>  Siguiendo el paradigma funcional, obtienes una fuente adicional de inspiraci√≥n. </blockquote><br>  <strong>Daniil Popov:</strong> Si empiezo a escribir clases tan inmutables en el lenguaje OOP y utilizando m√©todos inmutables, ¬øpuedo decir que escribo funcionalmente? <br><br>  <strong>Evgeny Elchev:</strong> S√≠, mientras comienzas a ver a los profesionales.  Cada vez es m√°s f√°cil probar m√©todos debido a la falta de un estado global, es m√°s f√°cil componer una cadena de c√°lculos a partir de m√©todos. <br><br>  <strong>Daniil Popov:</strong> En tu art√≠culo, explicas qu√© es una funci√≥n pura y los efectos secundarios.  Usted da un ejemplo con sumatoria, donde la funci√≥n tambi√©n modifica el estado externo.  El problema es que cuando lees dicho c√≥digo, es dif√≠cil mantener todos los cambios en tu cabeza: debes mirar esta variable global, qui√©n m√°s lee en ella, qui√©n m√°s le escribe lo que puede suceder.  Pero el enfoque funcional le permite permanecer en la secuencia, no ir a clases vecinas, solo leer el c√≥digo. <br><br>  <strong>Alexei Kudryavtsev:</strong> Si est√°s en un lenguaje funcional, por un lado es m√°s f√°cil para ti escribir c√≥digo, pero por otro lado, debes entender en qu√© tipo de m√≥nada est√°s ahora. <br><br>  <strong>Evgeny Elchev:</strong> S√≠, pero cuando comienzas a escribir todo sobre funciones puras, surgen otros problemas.  Por ejemplo, c√≥mo construir una larga cadena de c√°lculos.  En el estilo habitual, sin pensarlo, puede volcar f√°cilmente los datos que inicialmente no estaban all√≠.  En un enfoque funcional, esto no se puede hacer: hay que romper las cadenas, conectar todos los c√°lculos utilizados en varios m√©todos a los estados.  Tienes que acostumbrarte. <br><br>  Por otro lado, a diferencia de las clases en OPP, que hacen que el c√≥digo sea osificado y dif√≠cil de componer, las funciones pueden ser m√°s flexibles.  Puede escribir una funci√≥n, agregar libertad con la ayuda del cierre, lanzar dichas funciones y combinarlas en cadenas. <br><br>  <strong>Alexei Kudryavtsev:</strong> Esto es similar a la ideolog√≠a de Unix: hay bash, terminal, y puedes transferir datos de peque√±os programas que realizan una peque√±a acci√≥n a otros. <br><br>  <strong>Daniil Popov:</strong> Me record√≥ el enfoque de Rx, donde escriben cadenas gigantes. <br><br>  <strong>Evgeny Elchev:</strong> Ambos tienen raz√≥n.  Y Unix-way se trata de eso, y Rx es una fusi√≥n de la idea de uni√≥n y reactividad.  En FP, nos unimos al origen del evento y en la cadena de c√°lculo lo cambiamos, vinculando el resultado al estado final. <br><br>  <strong>Daniil Popov:</strong> ¬øSon buenos los lenguajes de paradigmas m√∫ltiples? ¬øQu√© tan conveniente y √∫til es que el lenguaje pueda hacer esto y aquello? <br><br>  <strong>Evgeny Elchev:</strong> Si sigues estrictamente alg√∫n tipo de paradigma, siempre habr√° cosas que ser√°n inconvenientes.  Hay cosas que son dif√≠ciles de lograr en un estilo funcional, por ejemplo, almacenar el estado y hacer un cach√©. <br><br><blockquote>  Cuando es posible elegir una herramienta que sea m√°s adecuada para una tarea espec√≠fica, esto es genial. </blockquote><br>  Puede crear una clase, dentro de ella realizar varios m√©todos en un estilo funcional y organizar el c√≥digo de forma concisa en cadenas, o abandonar la clase por completo, realizar las funciones necesarias y usarlas. <br><br>  La desventaja es que hay un dilema de elecci√≥n y cuantas m√°s opciones, m√°s dif√≠cil es elegir.  Tambi√©n se est√° volviendo m√°s dif√≠cil de entender: cuantas m√°s opciones, m√°s dif√≠cil es leer el c√≥digo. <br><br><h3>  Sobre Monad Jam </h3><br>  <strong>Alexei Kudryavtsev:</strong> Volviendo al funcionalismo, ¬øqu√© es una m√≥nada? <br><br>  <strong>Evgeny Elchev:</strong> Yo lo llamar√≠a un contenedor en el que puedes combinar las cadenas de c√°lculos.  La forma m√°s simple es un contenedor al que puede aplicar la funci√≥n y convertirla en un nuevo contenedor con un valor modificado. <br><br><blockquote>  Imagina la caja en la que se encuentra la fresa, y hay un dispositivo que te permite hacer mermelada con fresas, pero no puedes poner una caja de fresas en ella, debes verterla.  M√≥nadas: esto es lo que le permite colocar una caja en el dispositivo. </blockquote><br>  Este no es un estado en el sentido directo, ya que el estado se almacena por separado, pero aqu√≠ est√° el contexto (cuadro) con el valor y se pasa de uno a otro.  Esta es la transferencia de informaci√≥n de un c√°lculo a otro. <br><br>  <strong>Alexei Kudryavtsev:</strong> Resulta que en un enfoque funcional, para hacer mermelada, debes meterte dentro de la caja ... <br><br>  <strong>Evgeny Elchev:</strong> La belleza es que no tienes que meterte en la caja.  Puedes tirar una caja. <br><br><h3>  ¬øFuncionalidad para la √©lite? </h3><br>  <strong>Daniil Popov:</strong> Existe la opini√≥n de que la programaci√≥n funcional no se puede practicar sin un doctorado en matem√°ticas.  ¬øEs esto cierto? <br><br>  <strong>Evgeny Elchev:</strong> Esto no es cierto.  El conocimiento de las matem√°ticas, por supuesto, mejora todo, pero olvid√© las matem√°ticas despu√©s de graduarme y vivir normalmente.  De hecho, todas estas son herramientas que est√°n incorporadas en los idiomas para resolver problemas espec√≠ficos.  Se pueden usar sin intentar demostrar matem√°ticamente.  Si bien compilar√° una ecuaci√≥n desde un punto de vista matem√°tico, ser√° m√°s r√°pido y f√°cil tirar un par de l√≠neas de c√≥digo escribiendo, y funcionar√°n. <br><br>  <strong>Alexei Kudryavtsev:</strong> ¬øCu√°nto puede un pasatiempo para un enfoque funcional interferir con el desarrollo del producto?  Si parte del c√≥digo ya est√° escrito funcionalmente, ¬øhay alguna dificultad para trabajar con √©l? <br><br>  <strong>Evgeny Elchev:</strong> Para nada.  Si no eres un man√≠aco y no vas a escribir un gran ecosistema con decoradores, entonces puedes usar la misma coincidencia de patrones. <br><br>  Ser√° m√°s dif√≠cil si quieres cambiar a un nuevo elemento de funcionalismo.  Por ejemplo, el quinto Swift y la m√≥nada resultante aparecieron recientemente, no lo hab√≠a usado antes, pero ahora decidi√≥ que todo estar√° en √©l.  Lleva la funci√≥n de consulta a la red y escribe que su resultado ahora es resultado (ya sea datos o error), y decide combinar con la siguiente consulta, y all√≠ tiene un cierre separado con el valor y el error, y necesita reescribirlo.  Comenc√© a escribir as√≠ en un lugar, me despert√© dos d√≠as despu√©s, cuando reescrib√≠ la mitad del c√≥digo, tambi√©n hice nuevos envoltorios para que las bibliotecas se integraran maravillosamente. <br><br><h3>  Por donde empezar </h3><br>  <strong>Daniil Popov:</strong> ¬øQu√© deber√≠a leer un principiante para comprender la programaci√≥n funcional? <br><br>  <strong>Evgeny Elchev:</strong> Necesitamos tomar un lenguaje puramente funcional, por ejemplo, Haskell e intentarlo en la pr√°ctica.  Tomas un libro de texto y haces los ejemplos m√°s simples.  Aqu√≠ comprende el enfoque: cuando no hay para, no puede crear una variable en la que pueda cambiar el valor.  Personalmente, una vez tom√© el libro "Learn Haskell in the name of good", donde todo se describe en un lenguaje simple.  Despu√©s de eso, puede comenzar a leer art√≠culos en Internet: sobre c√≥mo se ven las m√≥nadas en Swift, sobre los tipos de datos algebraicos.  Un par de art√≠culos, y queda claro que esto no debe temer. <br><br>  <strong>Daniil Popov</strong> : Lo m√°s dif√≠cil es romper el paradigma en tu propia cabeza. <br><br>  <strong>Evgeny Elchev:</strong> No es necesario sumergirse bruscamente en la programaci√≥n funcional.  Muchas personas piensan que se sentar√°n y comenzar√°n a escribir funcionalmente, esto est√° mal. <br><br>  <strong>Alexei Kudryavtsev:</strong> Lo mejor que vi fue un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://gate.sc/%3Furl%3D">curso sobre Stepic de Haskell de Denis Moskvin</a> .  Empiezas sumando un par de n√∫meros y termina envolviendo las m√≥nadas en m√≥nadas.  Y si desea romper completamente su mente, es decir, el libro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://gate.sc/%3Furl%3D">"La estructura de la interpretaci√≥n de los programas de computadora"</a> es un curso en Lisp, desde ejemplos simples hasta lo que escribe un int√©rprete de Lisp en Lisp. <br><br><blockquote>  Si el miedo principal al funcionalismo ha pasado, eche un vistazo al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe de Vitaliy Bragilevsky</a> de la AppsConf de primavera.  Sin embargo, en la temporada de oto√±o de AppsConf tocaremos temas no menos interesantes: la comunidad de iOS espera un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe de Daniil Goncharov sobre ingenier√≠a inversa de Bluetooth</a> , y los desarrolladores de Android junto con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alexander Smirnov discutir√°n los enfoques actuales para crear animaciones</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/462121/">https://habr.com/ru/post/462121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../462111/index.html">C√≥mo probamos varias bases de datos de series temporales</a></li>
<li><a href="../462113/index.html">Entorno sin culpa: nadie debe escribir c√≥digo de calidad</a></li>
<li><a href="../462115/index.html">Encaja el cielo estrellado en WebGL en 1009 bytes de JavaScript</a></li>
<li><a href="../462117/index.html">¬øC√≥mo maximizar el valor de la preparaci√≥n de la cartera de productos?</a></li>
<li><a href="../462119/index.html">Delta Smart City Solutions: ¬øAlguna vez se ha preguntado qu√© tan verde puede ser un cine?</a></li>
<li><a href="../462125/index.html">10 pasos para zam zam</a></li>
<li><a href="../462127/index.html">Seminario "Para s√≠ mismo un auditor: auditor√≠a de un proyecto de centro de datos y pruebas de aceptaci√≥n", 15 de agosto, Mosc√∫</a></li>
<li><a href="../462131/index.html">A trav√©s de espinas a un juego so√±ado</a></li>
<li><a href="../462133/index.html">Una vez m√°s sobre Chipre, los matices de la vida.</a></li>
<li><a href="../462135/index.html">Asociaci√≥n estrat√©gica: por qu√© ServiceNow se asocia con un gran proveedor de la nube</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>