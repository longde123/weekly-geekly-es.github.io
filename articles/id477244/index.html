<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✅ 👃 👸🏾 Dimengerti RayTracing dalam 256 baris telanjang C ++ 👩‍🚀 👌🏾 🎅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dimengerti RayTracing dalam 256 baris telanjang C ++ 


 Ini adalah bab lain dari kuliah singkat saya tentang grafik komputer . Kali ini kita berbicar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dimengerti RayTracing dalam 256 baris telanjang C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477244/"><h1 id="understandable-raytracing-in-256-lines-of-bare-c">  Dimengerti RayTracing dalam 256 baris telanjang C ++ </h1><br><p> Ini adalah bab lain dari <a href="https://github.com/ssloy/tinyrenderer/wiki">kuliah singkat</a> saya <a href="https://github.com/ssloy/tinyrenderer/wiki">tentang grafik komputer</a> .  Kali ini kita berbicara tentang penelusuran sinar.  Seperti biasa, saya mencoba menghindari perpustakaan pihak ketiga, karena saya percaya itu membuat siswa memeriksa apa yang terjadi di bawah tenda.  Periksa <a href="https://github.com/ssloy/tinykaboom/wiki">juga proyek tinykaboom</a> . </p><br><p>  Ada banyak artikel raytracing di web;  namun masalahnya adalah bahwa hampir semuanya menunjukkan perangkat lunak yang sudah jadi yang bisa sangat sulit untuk dipahami.  Ambil, misalnya, tantangan <a href="https://www.taylorpetrick.com/blog/post/business-rt">pelacak ray kartu bisnis yang</a> sangat terkenal.  Ini menghasilkan program yang sangat mengesankan, tetapi sangat sulit untuk memahami cara kerjanya.  Daripada menunjukkan bahwa saya dapat melakukan rendering, saya ingin memberi tahu Anda secara rinci bagaimana Anda bisa melakukannya sendiri. </p><br><p>  <i>Catatan: Tidak masuk akal hanya untuk melihat kode saya, atau hanya membaca artikel ini dengan secangkir teh di tangan.</i>  <i>Artikel ini dirancang agar Anda dapat menggunakan keyboard dan menerapkan mesin rendering Anda sendiri.</i>  <i>Itu pasti akan lebih baik daripada milikku.</i>  <i>Paling tidak ubahlah bahasa pemrograman!</i> </p><br><p>  Jadi, tujuan hari ini adalah mempelajari cara membuat gambar seperti itu: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><a name="habracut"></a><br><h1>  Langkah 1: menulis gambar ke disk </h1><br><p>  Saya tidak ingin repot dengan manajer jendela, pemrosesan mouse / keyboard dan hal-hal seperti itu.  Hasil dari program kami adalah gambar sederhana yang disimpan di disk.  Jadi, hal pertama yang perlu kita lakukan adalah menyimpan gambar ke disk.  <a href="https://github.com/ssloy/tinyraytracer/tree/bd36c9857305b3cbd06f5b768bb48a92df9ae68b">Di sini</a> Anda dapat menemukan kode yang memungkinkan kami melakukan ini.  Biarkan saya daftar file utama: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" void render() { const int width = 1024; const int height = 768; std::vector&lt;Vec3f&gt; framebuffer(width*height); for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/float(height),i/float(width), 0); } } std::ofstream ofs; // save the framebuffer to file ofs.open("./out.ppm"); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i][j]))); } } ofs.close(); } int main() { render(); return 0; }</span></span></span></span></code> </pre> <br><p>  Hanya render () yang dipanggil dalam fungsi utama dan tidak ada yang lain.  Apa yang ada di dalam fungsi render ()?  Pertama-tama, saya mendefinisikan framebuffer sebagai array satu dimensi dari nilai Vec3f, yaitu vektor tiga dimensi sederhana yang memberi kita (r, g, b) nilai untuk setiap piksel.  Kelas vektor tinggal di file geometry.h, saya tidak akan menjelaskannya di sini: itu benar-benar manipulasi sepele dari vektor dua dan tiga dimensi (penambahan, pengurangan, penugasan, perkalian dengan skalar, produk skalar). </p><br><p>  Saya menyimpan gambar dalam <a href="https://en.wikipedia.org/wiki/Netpbm_format">format ppm</a> .  Ini adalah cara termudah untuk menyimpan gambar, meskipun tidak selalu cara yang paling nyaman untuk melihatnya lebih jauh.  Jika Anda ingin menyimpan dalam format lain, saya sarankan Anda menautkan perpustakaan pihak ketiga, seperti <a href="https://github.com/nothings/stb">stb</a> .  Ini adalah perpustakaan yang hebat: Anda hanya perlu memasukkan satu file header stb_image_write.h dalam proyek, dan itu akan memungkinkan Anda untuk menyimpan gambar dalam format paling populer. </p><br><p>  <b>Peringatan:</b> kode saya penuh dengan bug, saya memperbaikinya di hulu, tetapi komitmen yang lebih lama terpengaruh.  Lihat <a href="https://github.com/ssloy/tinyraycaster/issues/9">masalah ini</a> . </p><br><p>  Jadi, tujuan dari langkah ini adalah untuk memastikan bahwa kita dapat a) membuat gambar dalam memori + menetapkan warna yang berbeda dan b) menyimpan hasilnya ke disk.  Kemudian Anda dapat melihatnya di perangkat lunak pihak ketiga.  Inilah hasilnya: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ec1/8d8/1f8/ec18d81f825957255d786b50c05c8c4b.jpg" alt="gambar"></p><br><h1>  Langkah 2, yang penting: penelusuran sinar </h1><br><p>  Ini adalah langkah paling penting dan sulit dari keseluruhan rantai.  Saya ingin mendefinisikan satu bola dalam kode saya dan menggambarnya tanpa terobsesi dengan bahan atau pencahayaan.  Beginilah hasilnya akan terlihat seperti: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b02/143/d02/b02143d02d333d683313d209ec14eb25.jpg" alt="gambar"></p><br><p>  Demi kenyamanan, saya memiliki satu komit per langkah dalam repositori saya;  Github membuatnya sangat mudah untuk melihat perubahan yang dilakukan.  <a href="https://github.com/ssloy/tinyraytracer/commit/5806eb45e93dab225ab335824cbc3f537d511b28">Di sini, misalnya</a> , apa yang diubah oleh komit kedua. </p><br><p>  Untuk memulainya, apa yang kita butuhkan untuk mewakili lingkup dalam memori komputer?  Empat angka sudah cukup: vektor tiga dimensi untuk pusat bola dan skalar yang menggambarkan jari-jari: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> Vec3f center; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; Sphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;r) : center(c), radius(r) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ray_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;t0)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Vec3f L = center - orig; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tca = L*dir; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = L*L - tca*tca; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 &gt; radius*radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thc = sqrtf(radius*radius - d2); t0 = tca - thc; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = tca + thc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t0 = t1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre> <br><p>  Satu-satunya hal non-sepele dalam kode ini adalah fungsi yang memungkinkan Anda untuk memeriksa apakah sinar yang diberikan (berasal dari asal dalam arah dir) berpotongan dengan bola kami.  Penjelasan terperinci dari algoritma untuk persimpangan ray-sphere <a href="http://www.lighthouse3d.com/tutorials/maths/ray-sphere-intersection/">dapat ditemukan di sini</a> , saya sangat menyarankan Anda untuk melakukan ini dan memeriksa kode saya. </p><br><p>  Bagaimana cara kerja penelusuran sinar?  Ini sangat sederhana.  Pada langkah pertama kita baru saja mengisi gambar dengan gradien warna: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;height; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(height),i/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(width), <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br><p>  Sekarang untuk setiap piksel kita akan membentuk sinar yang berasal dari asal dan melewati piksel kita, dan kemudian memeriksa apakah sinar ini berpotongan dengan bola: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/a0e/be3/66da0ebe356e82253f0492e6335f114e.svg"><br><p>  Jika tidak ada persimpangan dengan bola, kami menggambar piksel dengan color1, sebaliknya dengan color2: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sphere_dist = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sphere.ray_intersect(orig, dir, sphere_dist)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// background color } return Vec3f(0.4, 0.4, 0.3); } void render(const Sphere &amp;sphere) { ￼ [...] for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { float x = (2*(i + 0.5)/(float)width - 1)*tan(fov/2.)*width/(float)height; float y = -(2*(j + 0.5)/(float)height - 1)*tan(fov/2.); Vec3f dir = Vec3f(x, y, -1).normalize(); framebuffer[i+j*width] = cast_ray(Vec3f(0,0,0), dir, sphere); } } ￼ [...] }</span></span></code> </pre> <br><p>  Pada titik ini, saya sarankan Anda untuk mengambil pensil dan memeriksa di atas kertas semua perhitungan (persimpangan ray-sphere dan menyapu gambar dengan sinar).  Untuk jaga-jaga, kamera kami ditentukan oleh hal-hal berikut: </p><br><ul><li>  lebar gambar </li><li>  tinggi gambar </li><li>  bidang sudut pandang </li><li>  lokasi kamera, Vec3f (0.0.0) </li><li>  lihat arah, sepanjang sumbu z, ke arah minus tanpa batas </li></ul><br><p>  Biarkan saya menggambarkan bagaimana kita menghitung arah awal sinar untuk dilacak.  Pada loop utama kita memiliki rumus ini: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = (<span class="hljs-number"><span class="hljs-number">2</span></span>*(i + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)width - <span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(fov/<span class="hljs-number"><span class="hljs-number">2.</span></span>)*width/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = -(<span class="hljs-number"><span class="hljs-number">2</span></span>*(j + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height - <span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(fov/<span class="hljs-number"><span class="hljs-number">2.</span></span>);</code> </pre> <br><p>  Dari mana asalnya?  Cukup sederhana.  Kamera kami ditempatkan di tempat asal dan menghadap ke arah -z.  Biarkan saya menggambarkan hal-hal, gambar ini menunjukkan kamera dari atas, sumbu y menunjukkan layar: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e00/5c1/b99/e005c1b996cc7eb9978bc434f6773196.png" alt="gambar"></p><br><p>  Seperti yang saya katakan, kamera ditempatkan di tempat asal, dan pemandangan diproyeksikan di layar yang terletak di bidang z = -1.  Bidang pandang menentukan sektor ruang apa yang akan terlihat di layar.  Dalam gambar kami layarnya 16 piksel lebar;  dapatkah Anda menghitung panjangnya dalam koordinat dunia?  Ini cukup sederhana: mari kita fokus pada segitiga yang dibentuk oleh garis putus-putus merah, abu-abu dan abu-abu.  Sangat mudah untuk melihat tan itu (bidang pandang / 2) = (lebar layar) <em>0,5 / (jarak layar kamera).</em>  <em>Kami menempatkan layar pada jarak 1 dari kamera, dengan demikian (lebar layar) = 2</em> tan (bidang pandang / 2). </p><br><p>  Sekarang mari kita katakan bahwa kita ingin membuat vektor melalui tengah piksel ke-12 layar, yaitu kita ingin menghitung vektor biru.  Bagaimana kita bisa melakukan itu?  Berapa jarak dari kiri layar ke ujung vektor biru?  Pertama-tama, itu adalah 12 + 0,5 piksel.  Kita tahu bahwa 16 piksel layar sesuai dengan 2 <em>tan (fov / 2) unit dunia.</em>  <em>Dengan demikian, ujung vektor terletak di (12 + 0,5) / 16</em> 2 <em>tan (fov / 2) satuan dunia dari tepi kiri, atau pada jarak (12 + 0,5)</em> 2/16 * tan (fov / 2) - tan (fov / 2) dari persimpangan antara layar dan sumbu -z.  Tambahkan rasio aspek layar ke perhitungan dan Anda akan menemukan formula untuk arah ray. </p><br><h1>  Langkah 3: tambahkan lebih banyak bola </h1><br><p>  Bagian tersulit sudah berakhir, dan sekarang jalan kita sudah jelas.  Jika kita tahu cara menggambar satu bola, kita tidak perlu waktu lama untuk menambahkan beberapa bola lagi.  <a href="https://github.com/ssloy/tinyraytracer/commit/c19c430151cb659372b4988876173b022164e371">Periksa perubahan</a> dalam kode, dan ini adalah gambar yang dihasilkan: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fc0/f37/6c9/fc0f376c9cb8971781f2a24065b47fa5.jpg" alt="gambar"></p><br><h1>  Langkah 4: pencahayaan </h1><br><p>  Gambar sempurna dalam semua aspek, kecuali kurangnya cahaya.  Sepanjang sisa artikel kita akan berbicara tentang pencahayaan.  Mari kita tambahkan beberapa sumber cahaya titik: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light</span></span></span><span class="hljs-class"> {</span></span> Light(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;p, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;i) : position(p), intensity(i) {} Vec3f position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity; };</code> </pre> <br><p>  Menghitung iluminasi global yang nyata adalah tugas yang sangat, sangat sulit, jadi seperti orang lain, kita akan menipu mata dengan menggambar sepenuhnya hasil non-fisik, tetapi masuk akal secara visual.  Pertama-tama: mengapa dingin di musim dingin dan panas di musim panas?  Karena pemanasan permukaan bumi tergantung pada sudut datangnya sinar matahari.  Semakin tinggi matahari terbit di atas cakrawala, semakin terang permukaannya.  Sebaliknya, semakin rendah di atas cakrawala, semakin redupnya.  Dan setelah matahari terbenam di cakrawala, foton bahkan tidak mencapai kita sama sekali. </p><br><p>  Kembali bola kami: kami memancarkan sinar dari kamera (tidak ada hubungannya dengan foton!) Saat itu berhenti di bola.  Bagaimana kita tahu intensitas pencahayaan titik persimpangan?  Bahkan, cukup untuk memeriksa sudut antara vektor normal pada titik ini dan vektor yang menggambarkan arah cahaya.  Semakin kecil sudutnya, semakin baik permukaannya menyala.  Ingatlah bahwa produk skalar antara dua vektor a dan b sama dengan produk norma vektor kali kosinus sudut antara vektor: a * b = | a |  | b |  cos (alpha (a, b)).  Jika kita mengambil vektor satuan panjang, produk titik akan memberi kita intensitas pencahayaan permukaan. </p><br><p>  Jadi, dalam fungsi cast_ray, alih-alih warna konstan, kami akan mengembalikan warna dengan mempertimbangkan sumber cahaya: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diffuse_light_intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;lights.size(); i++) { Vec3f light_dir = (lights[i].position - point).normalize(); diffuse_light_intensity += lights[i].intensity * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-number"><span class="hljs-number">0.f</span></span>, light_dir*N); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material.diffuse_color * diffuse_light_intensity; }</code> </pre> <br><p>  Modifikasi wrt langkah sebelumnya <a href="https://github.com/ssloy/tinyraytracer/commit/9a728fff2bbebb1eedd86e1ac89f657d43191609">tersedia di sini</a> , dan inilah hasilnya: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/207/766/76d/20776676d3aff568b466807ef548ea5a.jpg" alt="gambar"></p><br><h1>  Langkah 5: pencahayaan specular </h1><br><p>  Trik produk titik memberikan perkiraan yang baik tentang pencahayaan permukaan matt, dalam literatur itu disebut iluminasi difus.  Apa yang harus kita lakukan jika kita ingin menggambar permukaan yang mengkilap?  Saya ingin mendapatkan gambar seperti ini: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2d6/b39/c52/2d6b39c52aaa6a8c8667fd2df19f2e93.jpg" alt="gambar"></p><br><p>  Periksa <a href="https://github.com/ssloy/tinyraytracer/commit/f5ec45c2541feb86b6a30cc3bb04917d60d13e9b">seberapa sedikit modifikasi</a> yang diperlukan.  Singkatnya, semakin terang cahaya pada permukaan mengkilap, semakin sedikit sudut antara arah tampilan dan arah cahaya yang <i>dipantulkan</i> . </p><br><p>  Ini tipuan dengan pencahayaan permukaan matt dan mengkilap dikenal sebagai <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">model refleksi Phong</a> .  Wiki memiliki deskripsi yang cukup rinci tentang model pencahayaan ini.  Bisa menyenangkan untuk membacanya berdampingan dengan kode sumber.  Inilah gambar kunci untuk memahami keajaiban: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/881/d77/0ca/881d770ca8779cc876808a22c0fd8cce.png" alt="gambar"></p><br><h1>  Langkah 6: bayangan </h1><br><p>  Mengapa kita memiliki cahaya, tetapi tidak ada bayangan?  Itu tidak baik!  Saya ingin gambar ini: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e8f/fdd/04c/e8ffdd04c72dfc92f0845bb7b079faf7.jpg" alt="gambar"></p><br><p>  <a href="https://github.com/ssloy/tinyraytracer/commit/ef70d1356169dacb3183ad4fcb4c23f1d7003e1b">Hanya enam baris kode</a> memungkinkan kami untuk mencapai ini: ketika menggambar setiap titik, kami hanya memastikan bahwa segmen antara titik saat ini dan sumber cahaya tidak memotong objek pemandangan kami.  Jika ada persimpangan, kami lewati sumber cahaya saat ini.  Hanya ada sedikit kehalusan: Saya mengganggu titik dengan memindahkannya ke arah normal: </p><br><pre> <code class="cpp hljs">Vec3f shadow_orig = light_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>;</code> </pre> <br><p>  Kenapa begitu?  Hanya saja titik kita terletak pada permukaan objek, dan (kecuali untuk pertanyaan kesalahan numerik) sinar apa pun dari titik ini akan memotong objek itu sendiri. </p><br><h1>  Langkah 7: refleksi </h1><br><p>  Ini luar biasa, tetapi untuk menambahkan refleksi ke render kami, kami hanya perlu menambahkan tiga baris kode: </p><br><pre> <code class="cpp hljs"> Vec3f reflect_dir = reflect(dir, N).normalize(); Vec3f reflect_orig = reflect_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// offset the original point to avoid occlusion by the object itself Vec3f reflect_color = cast_ray(reflect_orig, reflect_dir, spheres, lights, depth + 1);</span></span></code> </pre> <br><p>  <a href="https://github.com/ssloy/tinyraytracer/commit/c80479d1d22fe98f41b584972affeb43422a23a6">Lihat sendiri:</a> ketika memotong bola, kami hanya menghitung sinar yang dipantulkan (dengan bantuan fungsi yang sama yang kami gunakan untuk sorotan specular!) Dan secara rekursif memanggil fungsi cast_ray ke arah sinar yang dipantulkan.  Pastikan untuk bermain dengan <a href="">kedalaman rekursi</a> , saya atur ke 4, coba nilai yang berbeda pengisian dari 0, apa yang akan berubah dalam gambar?  Inilah hasil saya dengan refleksi dan kedalaman rekursi 4: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a9d/1c2/e6d/a9d1c2e6d428aaba07953cae3fa007ea.jpg" alt="gambar"></p><br><h1>  Langkah 8: refraksi </h1><br><p>  Jika kita tahu melakukan refleksi, <a href="https://github.com/ssloy/tinyraytracer/commit/b69793bf6e8be54973cad1b18185a67dbf11bad1">pembiasan itu mudah</a> .  Kita perlu menambahkan satu fungsi untuk menghitung sinar yang dibiaskan ( <a href="https://en.wikipedia.org/wiki/Snell%2527s_law">menggunakan hukum Snell</a> ), dan tiga baris kode lainnya dalam cast_ray fungsi rekursif kami.  Inilah hasil di mana bola terdekat "terbuat dari kaca", itu memantulkan dan membiaskan cahaya pada saat yang bersamaan: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8c8/14a/56a/8c814a56aafc88609ebeb8c5a6f9a494.jpg" alt="gambar"></p><br><h1>  Steo 9: di luar bola </h1><br><p>  Hingga saat ini kami hanya memberikan bidang karena merupakan salah satu objek matematika nontrivial yang paling sederhana.  Mari kita tambahkan pesawat.  Papan catur adalah pilihan klasik.  Untuk tujuan ini, cukup menambahkan <a href="https://github.com/ssloy/tinyraytracer/commit/5e0da1f09fdbc585caa16df4c7b2f527d61536ef">beberapa baris</a> . </p><br><p>  Dan inilah hasilnya: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/871/a50/d88871a5021eb69cc64c7b9a5915e855.jpg"><br><p>  Seperti yang dijanjikan, kode memiliki 256 baris kode, <a href="https://github.com/ssloy/tinyraytracer">periksa sendiri</a> ! </p><br><h1>  Langkah 10: tugas rumah </h1><br><p>  Kami telah menempuh perjalanan panjang: kami telah belajar cara menambahkan objek ke pemandangan, cara menghitung pencahayaan yang agak rumit.  Biarkan saya meninggalkan Anda dua tugas sebagai pekerjaan rumah.  Benar-benar semua pekerjaan persiapan telah dilakukan dalam <a href="https://github.com/ssloy/tinyraytracer/tree/homework_assignment">pekerjaan rumah</a> cabang <a href="https://github.com/ssloy/tinyraytracer/tree/homework_assignment">_ tugas</a> .  Setiap tugas akan membutuhkan sepuluh baris kode puncak. </p><br><h3>  Tugas 1: peta lingkungan </h3><br><p>  Saat ini, jika sinar tidak memotong objek apa pun, kami hanya mengatur piksel ke warna latar belakang konstan.  Dan mengapa, sebenarnya, apakah itu konstan?  Mari kita mengambil foto bulat (file <a href="">envmap.jpg</a> ) dan menggunakannya sebagai latar belakang!  Untuk membuat hidup lebih mudah, saya menautkan proyek kami dengan perpustakaan stb untuk kenyamanan bekerja dengan format jpg.  Seharusnya memberi kita gambar seperti itu: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3e0/531/fa9/3e0531fa9ee361de7580029e818bc5f5.jpg" alt="gambar"></p><br><h3>  Tugas 2: dukun! </h3><br><p>  Kita dapat membuat bola dan pesawat (lihat kotak-kotak).  Jadi mari kita menggambar jerat segitiga!  Saya telah menulis kode yang memungkinkan Anda membaca file .obj, dan saya telah menambahkan fungsi persimpangan ray-triangle ke dalamnya.  Sekarang menambahkan bebek ke adegan kita seharusnya cukup sepele: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg" alt="gambar"></p><br><h1>  Kesimpulan </h1><br><p>  Tujuan utama saya adalah menunjukkan proyek yang menarik (dan mudah!) Ke program.  Saya yakin bahwa untuk menjadi programmer yang baik, seseorang harus melakukan banyak proyek sampingan.  Saya tidak tahu tentang Anda, tetapi saya pribadi tidak tertarik dengan perangkat lunak akuntansi dan permainan kapal penyapu ranjau, bahkan jika kompleksitas kode ini cukup sebanding. </p><br><p>  Beberapa jam dan dua ratus lima puluh baris kode memberi kita raytracer.  <a href="https://github.com/ssloy/tinyrenderer/wiki">Lima ratus baris</a> rasterizer perangkat lunak dapat dilakukan dalam beberapa hari.  Grafik sangat keren untuk mempelajari pemrograman! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477244/">https://habr.com/ru/post/id477244/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477230/index.html">Sejarah perangkat lunak pendidikan: komputer pribadi pertama, game dan perangkat lunak pendidikan untuk siswa</a></li>
<li><a href="../id477234/index.html">Tikus yang mengakhiri saudara kawat</a></li>
<li><a href="../id477236/index.html">Pengadilan A.S. memungkinkan negara untuk mengembalikan netralitas bersih</a></li>
<li><a href="../id477238/index.html">Plus untuk Karma: Apa Stack Overflow Dikritik untuk dan Mengapa Banyak Mengeluh tentang Keracunan Komunitas</a></li>
<li><a href="../id477242/index.html">Bagaimana kami memilih ServiceDesk. Bagian 3</a></li>
<li><a href="../id477248/index.html">Pengalaman pertama saya memulihkan database Postgres setelah kerusakan (halaman tidak valid di blok 4123007 dari relatton base / 16490)</a></li>
<li><a href="../id477250/index.html">Jadi Anda ingin menjalankan Windows 10 pada kalkulator? Baiklah</a></li>
<li><a href="../id477252/index.html">Bagaimana Inkubator dan Akselerator Bisnis Berkembang: Dari Laboratorium Thomas Edison ke Y Combinator</a></li>
<li><a href="../id477254/index.html">Otentikasi XSS, CSRF, dan Flash. Pemecahan masalah dengan r0ot-mi Web - Client. Bagian 2</a></li>
<li><a href="../id477256/index.html">Peluncuran OneWeb penuh pertama pada kendaraan peluncuran Soyuz ditunda tahun depan, serta peluncuran kendaraan peluncuran Angara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>