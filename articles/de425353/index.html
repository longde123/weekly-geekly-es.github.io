<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎇 ✋🏾 👈🏿 Die ganze Wahrheit über RTOS. Artikel Nr. 13. Aufgabendatenstrukturen und nicht unterstützte API-Aufrufe 🚶🏻 🤸🏿 🔛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem dritten und letzten Aufgabenartikel werde ich die Nucleus SE-Datenstrukturen untersuchen und RTOS-API-Aufrufe beschreiben, die nicht in Nucl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit über RTOS. Artikel Nr. 13. Aufgabendatenstrukturen und nicht unterstützte API-Aufrufe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425353/"><img src="https://habrastorage.org/webt/a2/hi/au/a2hiaum17nhh6_ibldqgahpgaxo.jpeg"><br><br>  In diesem dritten und letzten Aufgabenartikel werde ich die Nucleus SE-Datenstrukturen untersuchen und RTOS-API-Aufrufe beschreiben, die nicht in Nucleus SE implementiert sind, sowie andere Kompatibilitätsprobleme. <br><a name="habracut"></a><br>  Frühere Artikel in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen für die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einführung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einführung.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><h2>  Datenstrukturen </h2><br>  Aufgaben verwenden verschiedene Datenstrukturen (sowohl im RAM als auch im ROM), die wie andere Nucleus SE-Objekte eine Reihe von Tabellen sind, deren Größe der Anzahl der ausgewählten Aufgaben und Parameter entspricht. <br><br>  Ich empfehle dringend, dass Anwendungscode über API-Funktionen und nicht direkt auf diese Datenstrukturen zugreift.  Dies vermeidet unerwünschte Nebenwirkungen, Inkompatibilität mit zukünftigen Versionen von Nucleus SE und vereinfacht auch die Portierung der Anwendung auf Nucleus RTOS.  Zum besseren Verständnis der Funktionsweise des Serviceabrufcodes und des Debugging-Prozesses wird nachfolgend eine detaillierte Beschreibung der Datenstrukturen gegeben. <br><br><h3>  Im RAM gehostete Kernel-Datenstrukturen </h3><br>  Diese Datenstrukturen umfassen: <br><br>  <b>NUSE_Task_Context [] []</b> - Ein zweidimensionales Array vom Typ <b>ADDR</b> enthält eine Zeile für jede Aufgabe.  Die Anzahl der Spalten hängt von der Controller-Architektur ab und wird durch das Symbol <b>NUSE_REGISTERS bestimmt</b> , das in <b>nuse_types.h</b> definiert <b>ist</b> .  Dieses Array wird vom Scheduler zum Speichern des Kontexts jeder Aufgabe verwendet und wurde im Abschnitt "Speichern des Kontexts" von Artikel 10 ausführlich beschrieben.  Wird nicht erstellt, wenn der RTC-Scheduler verwendet wird. <br>  <b>NUSE_Task_Signal_Flags []</b> - Ein Array vom Typ <b>U8</b> , das erstellt wird, wenn Signale aktiviert sind, und 8 Signalflags für jede Aufgabe enthält.  Signale werden in einem der folgenden Artikel behandelt. <br>  <b>NUSE_Task_Timeout_Counter []</b> ist ein Array vom Typ <b>U16</b> , besteht aus dem Subtrahieren von Zählern für jede Aufgabe und wird erstellt, wenn der Aufruf der API <b>NUSE_Task_Sleep ()</b> aktiviert wird. <br>  <b>NUSE_Task_Status []</b> - Ein Array vom Typ U8 enthält die Status jeder Aufgabe - <b>NUSE_READY</b> oder Suspend-Status.  Wird nur erstellt, wenn die Task-Suspendierung aktiviert ist. <br>  <b>NUSE_Task_Blocking_Return []</b> - Ein Array vom Typ U8, das erstellt wird, wenn die Blockierung von API-Aufrufen aktiviert ist.  Es enthält einen Rückkehrcode, der nach dem Blockieren von API-Aufrufen verwendet wird.  Es enthält normalerweise <b>NUSE_SUCCESS</b> oder einen Code, der angibt, dass das Objekt zurückgesetzt wurde (z. B. <b>NUSE_MAILBOX_WAS_RESET</b> ). <br>  <b>NUSE_Task_Schedule_Count []</b> - Ein Array vom Typ <b>U16</b> , enthält einen Zähler für jede Aufgabe und wird nur erstellt, wenn die Anzahl der Scheduler aktiviert wurde. <br><br>  <b>NUSE_Task_Context [] [] wird</b> hauptsächlich durch Nullen initialisiert, mit Ausnahme von Einträgen, die dem Statusregister (Statusregister, SR), dem Programmzähler (Programmzähler, PC) und dem Stapelzeiger (Stapelzeiger, SP) entsprechen, denen Anfangswerte zugewiesen sind (siehe "Daten" im ROM "unten) und allen anderen Datenstrukturen <b>NUSE_Init_Task () werden</b> beim Starten von Nucleus SE Nullen zugewiesen.  Einer der folgenden Artikel enthält eine vollständige Liste der Nucleus SE-Startverfahren mit ihrer Beschreibung. <br><br>  Im Folgenden finden Sie Definitionen der Datenstrukturen, die in der Datei nuse_init.c enthalten sind. <br><br><img src="https://habrastorage.org/webt/fj/hr/le/fjhrlehn7si_hkt5lnnyk6dosno.jpeg"><br><br><h3>  RAM-Benutzerdaten </h3><br>  Der Benutzer muss für jede Aufgabe einen Stapel definieren (wenn der RTC-Scheduler nicht verwendet wird).  Dies sollten <b>ADDR-</b> Arrays sein, die normalerweise in <b>nuse_config.c</b> definiert <b>sind</b> .  Adressen und <b>Stapelgrößen</b> sollten in den Aufgabeneinträgen <b>NUSE_Task_Stack_Base []</b> bzw. <b>NUSE_Task_Stack_Size []</b> platziert werden (siehe Daten im ROM). <br><br><h3>  ROM-Daten </h3><br>  Ein ROM speichert eine bis vier Datenstrukturen, die sich auf Aufgaben beziehen.  Die genaue Menge hängt von den ausgewählten Parametern ab: <br><br>  <b>NUSE_Task_Start_Address []</b> ist ein Array vom Typ <b>ADDR</b> mit einem Eintrag für jede Aufgabe, der ein Zeiger auf den <b>Codeeintrittspunkt</b> für die Aufgabe ist. <br>  <b>NUSE_Task_Stack_Base []</b> ist ein Array vom Typ <b>ADDR</b> mit einem Eintrag für jede Aufgabe, der ein Zeiger auf die Basisadresse des Stapels für die Aufgabe ist.  Dieses Array wird erstellt, wenn ein anderer Scheduler als RTC verwendet wird. <br>  <b>NUSE_Task_Stack_Size []</b> ist ein Array vom Typ <b>U16</b> mit einem Eintrag für jede Aufgabe, der die Größe des Stapels für die Aufgabe (in Worten) <b>angibt</b> .  Dieses Array wird erstellt, wenn ein anderer Scheduler als RTC verwendet wird. <br>  <b>NUSE_Task_Initial_State []</b> ist ein Array vom Typ <b>U8</b> mit einem Eintrag für jede Aufgabe, der den Anfangszustand der Aufgabe anzeigt.  <b>Dies</b> kann <b>NUSE_READY</b> oder <b>NUSE_PURE_SUSPEND sein</b> .  Dieses Array wird erstellt, wenn die Unterstützung für den Anfangszustand der Aufgabe ausgewählt ist. <br><br>  Diese Datenstrukturen werden in <b>nuse_config.c</b> deklariert und (statisch) <b>initialisiert</b> : <br><br><img src="https://habrastorage.org/webt/2g/pp/bu/2gppbu3zs8wc0gipo3kggntvxek.jpeg"><br><br><h3>  Die Speichermenge zum Speichern von Aufgabendaten (Task Data Footprint) </h3><br>  Wie bei allen Nucleus SE-Kernobjekten ist die zum Speichern von Daten erforderliche Speichermenge vorhersehbar. <br><br>  ROM-Größe (in Byte) für alle Anwendungsaufgaben erforderlich: <br>  <b>NUSE_TASK_NUMBER * sizeof (ADDR)</b> <br><br>  Wenn ein anderer Scheduler als RTC ausgewählt ist: <br>  <b>NUSE_TASK_NUMBER * (Größe von (ADDR) +2)</b> <br><br>  Wenn die Unterstützung für den Anfangszustand der Aufgabe ausgewählt ist: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  Um Daten im RAM zu speichern, wird die Speichermenge (in Bytes) durch die ausgewählten Parameter bestimmt und kann einen Nullwert haben, wenn keiner der Parameter ausgewählt ist. <br>  Wenn ein anderer Scheduler als RTC ausgewählt ist: <br>  <b>NUSE_TASK_NUMBER * NUSE-REGISTER * sizeof (ADDR)</b> <br><br>  Plus, wenn Signalunterstützung ausgewählt ist: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  Wenn der Aufruf der API NUSE_Task_Sleep () aktiviert ist: <br>  <b>NUSE_TASK_NUMBER * 2</b> <br><br>  Plus, wenn die Aufgabensperre aktiviert ist: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  Wenn die Blockierung von API-Aufrufen aktiviert ist: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  Plus, wenn der Scheduler-Zähler aktiviert ist: <br>  <b>NUSE_TASK_NUMBER * 2</b> <br><br><h2>  API-Aufrufe in Nucleus SE nicht implementiert </h2><br>  Nachfolgend sind sieben API-Aufrufe aufgeführt, die in Nucleus RTOS verfügbar sind und nicht in Nucleus SE implementiert sind. <br><br><h3>  Aufgabe erstellen </h3><br>  Dieser API-Aufruf erstellt eine Anwendungsaufgabe.  Nucleus SE benötigt diese Funktion nicht, da Aufgaben statisch erstellt werden. <br><br>  Prototyp aufrufen: <br><br>  <b>STATUS NU_Create_Task (NU_TASK * task, CHAR * name, VOID (* task_entry) (UNSIGNED, VOID *), UNSIGNED argc, VOID * argv, VOID * stack_address, UNSIGNED stack_size, OPTION priority, UNSIGNED time_slice, OPTION priority, UNSIGNED time_slice</b> <br><br>  Parameter: <br><br>  <b>task</b> - Ein Zeiger auf einen Steuerblock für Benutzeraufgaben, der als Handle / Link („Handle“) einer Task in anderen API-Aufrufen verwendet werden kann. <br>  <b>name</b> - Zeiger auf den Namen der Aufgabe, eine 7-stellige Zeichenfolge mit einer abschließenden Null; <br>  <b>task_entry</b> - gibt die Eingabefunktion für die Aufgabe an; <br>  <b>argc</b> - <b>UNSIGNED-</b> Datenelement, mit dem Anfangsinformationen an die Aufgabe übergeben werden können; <br>  <b>argv</b> - ein Zeiger, mit dem Informationen an die Aufgabe übertragen werden können; <br>  <b>stack_address</b> - legt den Anfangssektor des Speichers für den <b>Taskstack fest</b> ; <br>  <b>stack_size</b> - gibt die Anzahl der Bytes im Stapel an; <br>  <b>Priorität</b> - gibt den Prioritätswert der Aufgabe an: von 0 bis 255, wobei niedrigere Zahlen der höchsten Priorität entsprechen; <br>  <b>time_slice</b> - <b>Gibt</b> die maximale Anzahl von <b>Zeitscheiben an</b> , die während dieser Aufgabe vergehen können.  Der Wert "0" deaktiviert das Time Slicing für diese Aufgabe. <br>  <b>preempt</b> - <b>Gibt</b> an, ob die Aufgabe ersetzt wurde oder nicht.  <b>Kann</b> Werte <b>NU_PREEMPT</b> und <b>NU_NO_PREEMPT haben</b> ; <br>  <b>auto_start</b> - Zeigt den Anfangszustand der Aufgabe an.  <b>NU_START</b> bedeutet, dass die Aufgabe zur Ausführung bereit ist, und <b>NU_NO_START bedeutet,</b> dass die Aufgabe angehalten ist. <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - zeigt einen erfolgreichen Abschluss des Dienstes an; <br>  <b>NU_INVALID_TASK</b> - gibt an, dass der Zeiger auf die <b>Tasksteuereinheit</b> <b>NULL ist</b> ; <br>  <b>NU_INVALID_ENTRY</b> - <b>Gibt</b> an, dass der Zeiger auf die Eingabefunktion der Task <b>NULL ist</b> . <br>  <b>NU_INVALID_MEMORY</b> - <b>Gibt</b> an, dass der durch den Parameter stack_address zugewiesene Speichersektor Null ( <b>NULL</b> ) ist. <br>  <b>NU_INVALID_SIZE</b> - <b>Gibt</b> an, dass die angegebene <b>Stapelgröße</b> nicht ausreicht. <br>  <b>NU_INVALID_PREEMPT</b> - <b>Gibt</b> an, dass der <b>Preempt-</b> Parameter falsch eingestellt ist. <br>  <b>NU_INVALID_START</b> - <b>Zeigt</b> an, dass der Parameter <b>auto_start</b> falsch eingestellt ist. <br><br><h3>  Aufgabe löschen </h3><br>  Dieser API-Aufruf löscht eine zuvor erstellte Anwendungsaufgabe, die abgeschlossen oder <i>beendet werden</i> muss.  Dieser Aufruf ist auch für Nucleus SE nicht erforderlich, da Aufgaben statisch erstellt werden und nicht gelöscht werden können. <br><br>  Prototyp aufrufen: <br><br>  <b>STATUS NU_Delete_Task (NU_TASK * Aufgabe);</b> <br><br>  Parameter: <br><br>  <b>task</b> - Zeiger auf den Task Control Block <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - zeigt einen erfolgreichen Abschluss des Dienstes an; <br>  <b>NU_INVALID_TASK</b> - zeigt an, dass der Zeiger auf die Aufgabe falsch gesetzt ist; <br>  <b>NU_INVALID_DELETE</b> - Zeigt an, dass sich die Aufgabe nicht im Status "Fertig" oder "Beendet" befindet. <br><br><h3>  Aufgabenzeiger abrufen </h3><br>  Dieser API-Aufruf enthält eine sequentielle Liste von Zeigern auf alle Aufgaben im System.  Es wird in Nucleus SE nicht benötigt, da Aufgaben anhand eines einfachen Index und nicht anhand eines Zeigers identifiziert werden. <br><br>  Prototyp aufrufen: <br><br>  <b>UNSIGNED NU_Task_Pointers (NU_TASK ** Zeigerliste, UNSIGNED Maximum_Pointers);</b> <br><br>  Parameter: <br><br>  <b>pointer_list</b> - Zeiger auf ein Array von <b>NU_TASK-</b> Zeigern.  Dieses Array wird mit Zeigern auf die im System installierten Aufgaben gefüllt. <br>  <b>Maximum_Pointers</b> - Die maximale Anzahl von Zeigern, die im Array platziert werden können. <br><br>  Rückgabewert: <br><br>  Die Anzahl der im Array platzierten <b>NU_TASK-</b> Zeiger. <br><br><h3>  Aufgabenpriorität ändern </h3><br>  Dieser API-Aufruf gibt der Aufgabe eine neue Priorität.  In Nucleus SE ist dies nicht erforderlich, da die Aufgabenprioritäten konstant sind. <br><br>  Prototyp aufrufen: <br><br>  <b>OPTION NU_Change_Priority (Task NU_TASK *, OPTION new_priority);</b> <br><br>  Parameter: <br><br>  <b>task</b> - ein Zeiger auf einen Task-Steuerblock; <br>  <b>new_priority</b> - <b>Setzt</b> die Priorität von 0 auf 255. <br><br>  Rückgabewert: <br>  Der vorherige Wert für die Aufgabenpriorität. <br><br><h3>  Ändern Sie den Task Preemption-Algorithmus </h3><br>  Dieser API-Aufruf ändert die Reihenfolge, in der die laufende Aufgabe verdrängt wird.  Nucleus SE benötigt es nicht, da es einen einfacheren Planungsalgorithmus verwendet. <br><br>  Prototyp aufrufen: <br>  <b>OPTION NU_Change_Preemption (OPTION preempt);</b> <br><br>  Parameter: <br>  <b>preempt</b> - neuer <b>präemptiver</b> Algorithmus, akzeptiert <b>NU_PREEMPT</b> oder <b>NU_NO_PREEMPT</b> <br><br>  Rückgabewert: <br>  Der vorherige Algorithmus zum Verdrängen einer Aufgabe. <br><br><h3>  Task Time Slice ändern </h3><br>  Dieser API-Aufruf ändert die Zeitscheibe einer bestimmten Aufgabe.  Nucleus SE benötigt es nicht, da Task-Zeitscheiben festgelegt sind. <br><br>  Prototyp aufrufen: <br>  <b>UNSIGNED NU_Change_Time_Slice (NU_TASK * -Aufgabe, UNSIGNED time_slice);</b> <br><br>  Parameter: <br>  <b>task</b> - ein Zeiger auf einen Task-Steuerblock; <br>  <b>time_slice</b> - Die maximale Anzahl von <b>Zeitscheiben</b> , die während dieser Aufgabe vergehen können. Ein Nullwert dieses Felds deaktiviert die Zeitquantisierung für diese Aufgabe. <br><br>  Rückgabewert: <br>  Der vorherige Wert des Task-Zeit-Quanten. <br><br><h3>  Aufgabe beenden </h3><br>  Dieser API-Aufruf führt eine bestimmte Aufgabe aus.  Nucleus SE benötigt dies nicht, da der Status " <i>Beendet"</i> nicht unterstützt wird. <br><br>  Prototyp aufrufen: <br>  <b>STATUS NU_Terminate_Task (NU_TASK * -Aufgabe);</b> <br><br>  Parameter: <br>  <b>task</b> - ein Zeiger auf einen Task-Steuerblock. <br><br>  Rückgabewert: <br>  <b>NU_SUCCESS</b> - zeigt einen erfolgreichen Abschluss des Dienstes an; <br>  <b>NU_INVALID_TASK</b> - Zeigt an, dass der <b>Taskzeiger</b> falsch ist. <br><br><h2>  Nucleus RTOS-kompatibel </h2><br>  Bei der Entwicklung von Nucleus SE bestand eines der Hauptziele darin, ein hohes Maß an Codekompatibilität mit Nucleus RTOS sicherzustellen.  Aufgaben sind keine Ausnahme und werden aus Anwendersicht ähnlich wie in Nucleus RTOS implementiert.  Es gibt einige inkompatible Bereiche, in denen ich zu dem Schluss gekommen bin, dass eine solche Inkompatibilität akzeptabel wäre, da der endgültige Code leichter zu verstehen ist und den Speicher effizienter nutzen kann.  Zusätzlich zu diesen Inkompatibilitäten können die restlichen Nucleus RTOS-API-Aufrufe jedoch fast direkt als Nucleus SE-Aufrufe verwendet werden.  In einem der folgenden Artikel werden weitere Einzelheiten zum Übergang von Nucleus RTOS zu Nucleus SE beschrieben <br><br><h3>  Objektkennungen </h3><br>  In Nucleus RTOS werden alle Objekte durch eine Datenstruktur (Steuereinheiten) beschrieben, die von einem bestimmten Typ sind.  Ein Zeiger auf diese Steuereinheit dient als Kennung für die Aufgabe.  Bei Nucleus SE entschied ich, dass ein anderer Ansatz für die effiziente Nutzung des Speichers erforderlich ist.  Alle Kernelobjekte werden durch eine Reihe von Tabellen im RAM und / oder ROM beschrieben.  Die Größe dieser Tabellen wird durch die Anzahl der Objekttypen bestimmt.  Die Kennung eines bestimmten Objekts ist der Index in diesen Tabellen.  Also habe ich <b>NUSE_TASK</b> als das Äquivalent von <b>U8 definiert</b> .  Eine Variable dieses Typs (kein Zeiger) dient als Kennung für Aufgaben.  Dies ist eine kleine Inkompatibilität, die leicht herauszufinden ist, ob der Code auf oder von Nucleus RTOS portiert ist.  Objektkennungen werden normalerweise unverändert gespeichert und übertragen. <br><br>  Nucleus RTOS unterstützt auch die Benennung von Aufgaben.  Diese Namen werden nur zum Debuggen verwendet.  Ich habe sie von Nucleus SE ausgeschlossen, um Speicherplatz zu sparen. <br><br><h3>  Aufgabenzustände </h3><br>  In Nucleus RTOS können sich Aufgaben in einem von mehreren Zuständen befinden: <i>Ausführen</i> , <i>Bereit</i> , <i>Angehalten</i> (was zu Unsicherheit führt: Die Aufgabe befindet sich im Standby-Modus oder wird durch einen API-Aufruf blockiert), Beendet oder Abgeschlossen. <br><br>  Nucleus SE unterstützt auch <i>Ausführungs-</i> und <i>Bereitschaftszustände</i> .  Alle drei <i>angehaltenen</i> Optionen werden optional unterstützt.  Beendet und beendet werden nicht unterstützt.  Keine API-Aufrufe zum Abschließen von Aufgaben.  Eine externe Taskfunktion sollte niemals explizit oder implizit einen Wert zurückgeben (dies führt zu einem Status " <i>Fertig"</i> in Nucleus RTOS). <br><br><h3>  Nicht realisierte API-Aufrufe </h3><br>  Nucleus RTOS unterstützt 16 Büroanrufe für die Arbeit mit Aufgaben.  Davon sind 7 nicht in Nucleus SE implementiert.  Ihre Beschreibung sowie der Grund für ihren Ausschluss sind oben beschrieben. <br><br>  Im nächsten Artikel beginnen wir mit der RTOS-Speicherverwaltung. <br><br>  <b>Über den Autor:</b> Colin Walls ist seit über dreißig Jahren in der Elektronikindustrie tätig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht häufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier Bücher über Firmware.  Lebt in Großbritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425353/">https://habr.com/ru/post/de425353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425343/index.html">25 nützliche Kubernetes-Tools: Bereitstellung und Verwaltung</a></li>
<li><a href="../de425345/index.html">Vereinfachung der Namen: 802.11ax wird zu Wi-Fi 6</a></li>
<li><a href="../de425347/index.html">Dumping Mask: Mythos oder Realität</a></li>
<li><a href="../de425349/index.html">Das Forum der Positive Hack Days 9 findet am 21. und 22. Mai auf der Crocus Expo statt</a></li>
<li><a href="../de425351/index.html">Heimwerker verlieren ihre Arbeit</a></li>
<li><a href="../de425355/index.html">Sicherheitsbewertung des ICO-Projekts</a></li>
<li><a href="../de425357/index.html">Wie wir einen 12-stöckigen Technologie-Stack zusammengestellt haben und nicht verrückt geworden sind</a></li>
<li><a href="../de425359/index.html">Die Chinesen verwendeten einen Mikrochip, um amerikanische Computer zu steuern</a></li>
<li><a href="../de425361/index.html">Inhaltsblockierung, Erweiterung für Chrom-Browser</a></li>
<li><a href="../de425363/index.html">Tipps für studentische Programmierer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>