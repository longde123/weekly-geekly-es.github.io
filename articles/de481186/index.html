<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🏫 💄 🌠 Top 10 Bugs in Java-Projekten für 2019 🧥 👨‍💼 🅾️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Jahr 2019 neigt sich dem Ende zu und das PVS-Studio-Team fasst die Ergebnisse des neuen Jahres zusammen. Anfang 2019 haben wir die Fähigkeiten des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Top 10 Bugs in Java-Projekten für 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/481186/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/uy/oe/n2uyoeo7ko6owq_omdtzx419gty.png"></div><br>  Das Jahr 2019 neigt sich dem Ende zu und das PVS-Studio-Team fasst die Ergebnisse des neuen Jahres zusammen.  Anfang 2019 haben wir die Fähigkeiten des Analysators durch die Unterstützung der Java-Sprache erweitert.  Aus diesem Grund wurde die Liste unserer Veröffentlichungen zum Überprüfen geöffneter Projekte mit Überprüfungen von Java-Projekten ergänzt.  Im Laufe des Jahres wurden viele Fehler festgestellt, und wir haben uns entschlossen, die 10 interessantesten davon vorzubereiten. <br><a name="habracut"></a><br><br><h2>  Zehnter Platz: ikonisches Byte </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0663/">Analyse des Quellcodes des RPC-Frameworks Apache Dubbo durch den statischen Analysator PVS-Studio</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007</a> Ausdruck 'endKey [i] &lt;0xff' ist immer wahr.  OptionUtil.java (32) <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> ByteSequence </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefixEndOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ByteSequence prefix)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] endKey = prefix.getBytes().clone(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = endKey.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (endKey[i] &lt; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= endKey[i] = (byte) (endKey[i] + 1); return ByteSequence.from(Arrays.copyOf(endKey, i + 1)); } } return ByteSequence.from(NO_PREFIX_END); }</span></span></code> </pre> <br>  Viele Programmierer glauben, dass ein benanntes <i>Byte</i> ohne Vorzeichen sein wird.  Tatsächlich ist dies häufig in verschiedenen Sprachen der Fall.  In C # ist der <i>Bytetyp</i> beispielsweise vorzeichenlos.  In Java ist dies nicht der Fall. <br><br>  In der Bedingung <i>endKey [i] &lt;0xff</i> vergleicht <i>der</i> Autor der Methode eine Variable vom Typ <i>Byte</i> mit der in der hexadezimalen Darstellung dargestellten Zahl 255 (0xff).  Offensichtlich hat der Entwickler beim Schreiben der Methode vergessen, dass der Wertebereich des Typs <i>Byte</i> in Java [-128, 127] ist.  Diese Bedingung ist immer wahr, sodass die <i>for-</i> Schleife immer nur das letzte Element des <i>endKey-</i> Arrays verarbeitet. <br><br><h2>  Neunter Platz: zwei in einem </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0621/">PVS-Studio für Java wird an den Pfad gesendet.</a>  <a href="https://www.viva64.com/ru/b/0621/">Nächste Station ist Elasticsearch</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007</a> Ausdruck '(int) x &lt;0' ist immer falsch.  BCrypt.java (429) <br><br>  <a href="https://www.viva64.com/ru/w/v6025/">V6025</a> Möglicherweise liegt der Index '(int) x' außerhalb des <a href="https://www.viva64.com/ru/w/v6025/">zulässigen Bereichs</a> .  BCrypt.java (431) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x &gt; index_64.length) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index_64[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x]; }</code> </pre> <br>  Heute haben wir ein Sonderangebot!  Zwei Fehler auf einmal.  Die Ursache für den ersten Fehler ist der in Java vorzeichenlose <i>char-</i> Typ, weshalb die Bedingung <i>(int) x &lt;0</i> immer falsch ist.  Der zweite Fehler ist das banale <i>Überschreiten</i> der <i>Grenzen des</i> Arrays <i>index_64,</i> wenn <i>(int) x == index_64.length ist</i> .  Diese Situation ist aufgrund der Bedingung <i>(int) x&gt; index_64.length möglich</i> .  Um die Grenzen des Arrays zu überschreiten, muss die Bedingung '&gt;' durch '&gt; =' ersetzt werden.  Die korrekte Bedingung wäre: <i>(int) x&gt; = index_64.length</i> . <br><br><h2>  Achte Stelle: Entscheidung und ihre Folgen </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0626/">CUBA-Plattform-Code-Analyse mit PVS-Studio</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007</a> Ausdruck 'previousMenuItemFlatIndex&gt; = 0' ist immer wahr.  CubaSideMenuWidget.java (328) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> MenuItemWidget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findNextMenuItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MenuItemWidget currentItem)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;MenuTreeNode&gt; menuTree = buildVisibleTree(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); List&lt;MenuItemWidget&gt; menuItemWidgets = menuTreeToList(menuTree); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> menuItemFlatIndex = menuItemWidgets.indexOf(currentItem); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> previousMenuItemFlatIndex = menuItemFlatIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousMenuItemFlatIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return menuItemWidgets.get(previousMenuItemFlatIndex); } return null; }</span></span></code> </pre> <br>  Der Autor der <i>findNextMenuItem-</i> Methode möchte das von der <i>indexOf-</i> Methode zurückgegebene -1 <i>entfernen</i> , wenn die <i>menuItemWidgets-</i> Liste kein <i>currentItem</i> enthält.  Dazu addiert er eins zum Ergebnisindex (Variable <i>menuItemFlatIndex</i> ) und speichert den resultierenden Wert in der Variablen <i>previousMenuItemFlatIndex</i> , die in der Methode weiter verwendet wird.  Diese Lösung für das -1-Problem ist nicht erfolgreich, da sie gleichzeitig zu mehreren Fehlern führt: <br><br><ul><li>  <i>return null</i> code wird niemals ausgeführt, da der Ausdruck <i>previousMenuItemFlatIndex&gt; = 0</i> immer true ist. <i>Dies</i> bedeutet, dass die Rückgabe der <i>findNextMenuItem-</i> Methode immer innerhalb der <i>if-</i> Methode <i>erfolgt</i> . </li><li>  Eine <i>IndexOutOfBoundsException</i> wird ausgelöst, wenn die <i>menuItemWidgets-</i> Liste leer ist, da auf das erste Element der leeren Liste zugegriffen wird. </li><li>  Eine <i>IndexOutOfBoundsException-</i> Ausnahme tritt auf, wenn das Argument <i>currentItem</i> das letzte Argument in der <i>menuItemWidget-</i> Liste ist. </li></ul><br><h2>  Siebter Platz: Erstellen einer Datei aus dem Nichts </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0688/">Huawei Cloud: Heute ist es in PVS-Studio bewölkt</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6008/">V6008</a> Mögliche Null-Dereferenzierung von 'dataTmpFile'.  CacheManager.java (91) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putToCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PutRecordsRequest putRecordsRequest)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !dataTmpFile.exists()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { dataTmpFile.createNewFile(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } catch (IOException e) { LOGGER.error("Failed to create cache tmp file, return.", e); return; } } .... }</span></span></code> </pre> <br>  Beim Schreiben der <i>putToCache-</i> Methode <i>machte der</i> Programmierer einen Tippfehler in der Bedingung <i>dataTmpFile == null ||</i>  <i>! dataTmpFile.exists ()</i> vor dem Erstellen einer neuen <i>dataTmpFile.createNewFile ()</i> -Datei <i>.</i>  Ein Tippfehler ist die Verwendung des Operators '==' anstelle von '! ='.  Dieser Tippfehler <i>löst</i> eine <i>NullPointerException aus,</i> wenn die <i>createNewFile-</i> Methode <i>aufgerufen</i> wird.  Die Bedingung nach der Korrektur eines Tippfehlers sieht folgendermaßen aus: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !dataTmpFile.exists())</code> </pre> <br>  „Der Fehler wurde gefunden, behoben.  Du kannst dich entspannen “, werden Sie denken.  Aber egal wie! <br><br>  Nachdem wir einen Fehler behoben hatten, fanden wir einen anderen.  Jetzt kann beim Aufrufen von <i>dataTmpFile.exists ()</i> eine <i>NullPointerException</i> auftreten.  Um die Ausnahme zu beseitigen, muss der Operator '||' in der Bedingung ersetzt werden  auf '&amp;&amp;'.  Die Bedingung, unter der alle Fehler verschwinden, lautet wie folgt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !dataTmpFile.exists())</code> </pre> <br><h2>  Sechster Platz: ein sehr seltsamer logischer Fehler </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0603/">PVS-Studio für Java</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007</a> [CWE-570] Der Ausdruck "0" .equals (text) "ist immer falsch.  ConvertIntegerToDecimalPredicate.java 46 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-meta"><span class="hljs-meta">@NonNls</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String text = expression.getText().replaceAll(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || text.length() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"0"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0L"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0l"</span></span>.equals(text)) {<span class="hljs-comment"><span class="hljs-comment">// &lt;= return false; } return text.charAt(0) == '0'; }</span></span></code> </pre> <br>  Diese Methode ist insofern interessant, als sie einen offensichtlichen logischen Fehler enthält.  Wenn die <i>satisfiedBy-</i> Methode nach dem ersten <i>if</i> <i>keinen</i> Wert <i>zurückgibt</i> , wird bekannt, dass die <i>Textzeichenfolge</i> aus mindestens zwei Zeichen besteht.  Aus diesem Grund ist der erste <i>Haken bei "0" .Equals (Text)</i> im nächsten <i>If</i> bedeutungslos.  Was der Entwickler wirklich gemeint hat, bleibt ein Rätsel. <br><br><h2>  Fünfter Platz: Dies ist eine Wende! </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0657/">PVS-Studio besucht Apache Hive</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6034/">V6034 Die</a> Verschiebung um den Wert 'bitShiftsInWord - 1' kann mit der Größe des Typs 'bitShiftsInWord - 1' = [-1 ... 30] inkonsistent sein.  UnsignedInt128.java (1791) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shiftRightDestructive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wordShifts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitShiftsInWord, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> roundUp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bitShiftsInWord == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (bitShiftsInWord &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (bitShiftsInWord &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { zeroClear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shiftRestore = <span class="hljs-number"><span class="hljs-number">32</span></span> - bitShiftsInWord; <span class="hljs-comment"><span class="hljs-comment">// check this because "123 &lt;&lt; 32" will be 123. final boolean noRestore = bitShiftsInWord == 0; final int roundCarryNoRestoreMask = 1 &lt;&lt; 31; final int roundCarryMask = (1 &lt;&lt; (bitShiftsInWord - 1)); // &lt;= .... }</span></span></code> </pre> <br>  Bei den Eingabeargumenten <i>wordShifts = 3</i> und <i>bitShiftsInWord = 0</i> ist die Variable <i>roundCarryMask</i> , die das Ergebnis der Bitverschiebung <i>(1 &lt;&lt; (bitShiftsInWord - 1)) speichert</i> , eine negative Zahl.  Vielleicht hat der Entwickler dieses Verhalten nicht erwartet. <br><br><h2>  Vierter Platz: Werden die Ausnahmen für einen Spaziergang herauskommen? </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0657/">PVS-Studio besucht Apache Hive</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6051/">V6051</a> Die Verwendung der Anweisung 'return' im Block 'finally' kann zum Verlust nicht behandelter Ausnahmen führen.  ObjectStore.java (9080) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;MPartitionColumnStatistics&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMPartitionColumnStatistics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> NoSuchObjectException, MetaException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> committed = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... <span class="hljs-comment"><span class="hljs-comment">/*some actions*/</span></span> committed = commitTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LOG.error(<span class="hljs-string"><span class="hljs-string">"Error retrieving statistics via jdo"</span></span>, ex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ex <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> MetaException) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (MetaException) ex; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MetaException(ex.getMessage()); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!committed) { rollbackTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lists.newArrayList(); } } }</code> </pre> <br>  Die Deklaration der Methode <i>getMPartitionColumnStatistics</i> sagt uns, dass sie eine Ausnahme <i>auslösen</i> kann.  Wenn bei <i>try</i> eine Ausnahme auftritt, bleibt die <i>festgeschriebene</i> Variable <i>false</i> . Daher gibt die <i>return-Anweisung</i> im <i>finally-</i> Block den Wert der Methode zurück, und alle ausgelösten Ausnahmen gehen verloren und können nicht außerhalb der Methode verarbeitet werden.  Daher kann eine Ausnahme, die in dieser Methode ausgelöst wird, niemals daraus hervorgehen. <br><br><h2>  Dritter Platz: Ich drehe, drehe, ich möchte eine neue Maske bekommen </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0657/">PVS-Studio besucht Apache Hive</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6034/">V6034 Die</a> Verschiebung um den Wert 'j' kann mit der Größe des Typs inkonsistent sein: 'j' = [0 ... 63].  IoTrace.java (272) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logSargResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stripeIx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] rgsToRead)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, valOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; elements; ++i, valOffset += <span class="hljs-number"><span class="hljs-number">64</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">64</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ix = valOffset + j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rgsToRead.length == ix) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rgsToRead[ix]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; val = val | (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; j); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } .... } .... }</span></span></code> </pre> <br>  Ein weiterer Fehler betraf die bitweise Verschiebung, aber diesmal war nicht nur er in den Fall verwickelt.  In der inneren <i>for-</i> Schleife wird die Variable <i>j</i> [0 ... 63] als Schleifenzähler verwendet.  Dieser Zähler ist an einer Bitverschiebung von <i>1 &lt;&lt; j beteiligt</i> .  Nichts ist ärgerlich, aber hier kommt das Integer-Literal '1' vom Typ <i>int</i> (32-Bit-Wert) ins Spiel.  Daraus folgt, dass sich die Ergebnisse der Bitverschiebung zu wiederholen beginnen, nachdem <i>j</i> größer als 31 ist. Wenn das beschriebene Verhalten unerwünscht ist, muss die Einheit so <i>lange dargestellt werden</i> , beispielsweise <i>1L &lt;&lt; j</i> oder <i>(lang) 1 &lt;&lt; j</i> . <br><br><h2>  Zweiter Platz: Initialisierungsauftrag </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0688/">Huawei Cloud: Heute ist es in PVS-Studio bewölkt</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6050/">V6050 Klasseninitialisierungszyklus</a> ist vorhanden.  Die Initialisierung von 'INSTANCE' erscheint vor der Initialisierung von 'LOG'.  UntrustedSSL.java (32), UntrustedSSL.java (59), UntrustedSSL.java (33) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> UntrustedSSL INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UntrustedSSL(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(UntrustedSSL.class); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { LOG.error(t.getMessage(), t); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  Die Reihenfolge, in der Felder in einer Klasse deklariert werden, ist wichtig, da die Felder in der Reihenfolge initialisiert werden, in der sie deklariert wurden.  Wenn sie es jedoch vergessen, treten subtile Fehler wie dieser auf. <br><br>  Der Analyzer hat angegeben, dass das statische <i>LOG-</i> Feld im Konstruktor dereferenziert wird, wenn es auf <i>null</i> initialisiert wird, was zur <i>Ausnahmekette</i> <i>NullPointerException</i> -&gt; <i>ExceptionInInitializerError führt</i> . <br><br>  "Warum ist das statische <i>LOG-</i> Feld zum Zeitpunkt des Konstruktoraufrufs <i>null</i> ?" <br><br>  Die ExceptionInInitializerError- <i>Ausnahme</i> ist ein Hinweis.  Tatsache ist, dass dieser Konstruktor verwendet wird, um das in der Klasse <i>deklarierte</i> statische <i>INSTANCE-</i> Feld vor dem <i>LOG-</i> Feld zu initialisieren.  Zum Zeitpunkt des Konstruktoraufrufs ist das <i>LOG-</i> Feld daher noch nicht initialisiert.  Damit der Code korrekt funktioniert, muss das <i>LOG-</i> Feld initialisiert werden, bevor der Konstruktor <i>aufgerufen wird</i> . <br><br><h2>  Erster Platz: Copy-Paste-orientierte Programmierung </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0697/">Apache Hadoop Code Qualität: Produktions-VS-Test</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6072/">V6072</a> Es wurden zwei ähnliche Codefragmente gefunden.  Möglicherweise ist dies ein Tippfehler, und die Variable 'localFiles' sollte anstelle von 'localArchives' verwendet werden.  LocalDistributedCacheManager.java (183), LocalDistributedCacheManager.java (178), LocalDistributedCacheManager.java (176), LocalDistributedCacheManager.java (181) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobConf conf, JobID jobId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Update the configuration object with localized data. if (!localArchives.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils .arrayToString(localArchives.toArray(new String[localArchives // &lt;= .size()]))); } if (!localFiles.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils .arrayToString(localFiles.toArray(new String[localArchives // &lt;= .size()]))); } .... }</span></span></code> </pre> <br>  Und der erste Platz wird durch Kopieren und Einfügen eingenommen, oder vielmehr durch einen Fehler, der auf die Nachlässigkeit desjenigen zurückzuführen ist, der diese sündige Sache begangen hat.  Es ist sehr wahrscheinlich, dass das zweite <i>if</i> durch Kopieren und Einfügen des ersten mit dem Ersetzen von Variablen erstellt wurde: <br><br><ul><li>  <i>localArchives</i> on <i>localFiles</i> ; </li><li>  <i>MRJobConfig.CACHE_LOCALARCHIVES</i> bei <i>MRJobConfig.CACHE_LOCALFILES</i> . </li></ul><br>  Selbst mit solch einer einfachen Operation wurde jedoch ein Fehler gemacht, da die Variable <i>localArchives</i> in der zweiten <i>if-</i> Zeile des zweiten <i>Analysators noch verwendet wurde</i> , obwohl die Verwendung von <i>localFiles</i> höchstwahrscheinlich impliziert war. <br><br><h2>  Fazit </h2><br>  Die Korrektur von Fehlern in späteren Entwicklungsstadien oder nach der Freigabe eines Projekts erfordert erhebliche Ressourcen.  Der statische Analysator PVS-Studio vereinfacht das Erkennen von Fehlern beim Schreiben von Code, wodurch der Aufwand für die Fehlerbehebung erheblich reduziert wird.  Die ständige Verwendung des Analysators hat bereits das Leben der Entwickler vieler <a href="https://www.viva64.com/ru/customers/">Unternehmen</a> vereinfacht.  Wenn Sie gerne programmieren möchten, probieren Sie unseren <a href="https://www.viva64.com/ru/pvs-studio-download/">Analysator aus</a> . <br><br>  Unser Team wird hier nicht aufhören und den Analysator weiter verbessern und verbessern.  Erwarten Sie im nächsten Jahr neue Diagnosen und Artikel mit noch interessanteren Fehlern. <br><br>  Ich sehe zu, wie du Abenteuer liebst!  Zuerst gewannen die <a href="https://habr.com/ru/company/pvs-studio/blog/481178/">10 häufigsten Fehler in C # -Projekten für 2019</a> und jetzt konnte Java siegen!  Willkommen auf der nächsten Ebene im Artikel über die <a href="https://habr.com/ru/company/pvs-studio/blog/481190/">besten Fehler des Jahres 2019 in C ++ - Projekten</a> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/24/2j/ex/242jexzqwnmth1lyfcrr8icxmms.png"></div><br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/481184/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel mit einem englischsprachigen Publikum teilen möchten, verwenden Sie bitte den Link zur Übersetzung: Valery Komarov.  <a href="https://habr.com/en/company/pvs-studio/blog/481184/">Die 10 häufigsten Fehler in Java-Projekten im Jahr 2019</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481186/">https://habr.com/ru/post/de481186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481176/index.html">Kuriere Yandex.Food and Delivery Club brauchen eine Gewerkschaft</a></li>
<li><a href="../de481178/index.html">Top 10 Bugs in C # -Projekten für 2019</a></li>
<li><a href="../de481180/index.html">Müssen Entwickler Vorschläge von Benutzern erhalten?</a></li>
<li><a href="../de481182/index.html">Istio Service Mesh Beiträge Serie</a></li>
<li><a href="../de481184/index.html">Die 10 häufigsten Fehler in Java-Projekten im Jahr 2019</a></li>
<li><a href="../de481188/index.html">Die 10 häufigsten Fehler in C ++ - Projekten im Jahr 2019</a></li>
<li><a href="../de481190/index.html">Top 10 Bugs in C ++ Projekten für 2019</a></li>
<li><a href="../de481200/index.html">Sprachsteuerung und VoiceOver: So passen Sie die Anwendung für Blinde oder Standbilder an</a></li>
<li><a href="../de481202/index.html">Antiquitäten: das Prinzip des Müllsammelns und die Ergebnisse von 2019</a></li>
<li><a href="../de481204/index.html">Tech release Mail.ru Group, Winter 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>