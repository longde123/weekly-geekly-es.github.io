<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüè´ üíÑ üå† Top 10 Bugs in Java-Projekten f√ºr 2019 üß• üë®‚Äçüíº üÖæÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Jahr 2019 neigt sich dem Ende zu und das PVS-Studio-Team fasst die Ergebnisse des neuen Jahres zusammen. Anfang 2019 haben wir die F√§higkeiten des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Top 10 Bugs in Java-Projekten f√ºr 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/481186/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/uy/oe/n2uyoeo7ko6owq_omdtzx419gty.png"></div><br>  Das Jahr 2019 neigt sich dem Ende zu und das PVS-Studio-Team fasst die Ergebnisse des neuen Jahres zusammen.  Anfang 2019 haben wir die F√§higkeiten des Analysators durch die Unterst√ºtzung der Java-Sprache erweitert.  Aus diesem Grund wurde die Liste unserer Ver√∂ffentlichungen zum √úberpr√ºfen ge√∂ffneter Projekte mit √úberpr√ºfungen von Java-Projekten erg√§nzt.  Im Laufe des Jahres wurden viele Fehler festgestellt, und wir haben uns entschlossen, die 10 interessantesten davon vorzubereiten. <br><a name="habracut"></a><br><br><h2>  Zehnter Platz: ikonisches Byte </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0663/">Analyse des Quellcodes des RPC-Frameworks Apache Dubbo durch den statischen Analysator PVS-Studio</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007</a> Ausdruck 'endKey [i] &lt;0xff' ist immer wahr.  OptionUtil.java (32) <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> ByteSequence </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefixEndOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ByteSequence prefix)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] endKey = prefix.getBytes().clone(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = endKey.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (endKey[i] &lt; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= endKey[i] = (byte) (endKey[i] + 1); return ByteSequence.from(Arrays.copyOf(endKey, i + 1)); } } return ByteSequence.from(NO_PREFIX_END); }</span></span></code> </pre> <br>  Viele Programmierer glauben, dass ein benanntes <i>Byte</i> ohne Vorzeichen sein wird.  Tats√§chlich ist dies h√§ufig in verschiedenen Sprachen der Fall.  In C # ist der <i>Bytetyp</i> beispielsweise vorzeichenlos.  In Java ist dies nicht der Fall. <br><br>  In der Bedingung <i>endKey [i] &lt;0xff</i> vergleicht <i>der</i> Autor der Methode eine Variable vom Typ <i>Byte</i> mit der in der hexadezimalen Darstellung dargestellten Zahl 255 (0xff).  Offensichtlich hat der Entwickler beim Schreiben der Methode vergessen, dass der Wertebereich des Typs <i>Byte</i> in Java [-128, 127] ist.  Diese Bedingung ist immer wahr, sodass die <i>for-</i> Schleife immer nur das letzte Element des <i>endKey-</i> Arrays verarbeitet. <br><br><h2>  Neunter Platz: zwei in einem </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0621/">PVS-Studio f√ºr Java wird an den Pfad gesendet.</a>  <a href="https://www.viva64.com/ru/b/0621/">N√§chste Station ist Elasticsearch</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007</a> Ausdruck '(int) x &lt;0' ist immer falsch.  BCrypt.java (429) <br><br>  <a href="https://www.viva64.com/ru/w/v6025/">V6025</a> M√∂glicherweise liegt der Index '(int) x' au√üerhalb des <a href="https://www.viva64.com/ru/w/v6025/">zul√§ssigen Bereichs</a> .  BCrypt.java (431) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x &gt; index_64.length) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index_64[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x]; }</code> </pre> <br>  Heute haben wir ein Sonderangebot!  Zwei Fehler auf einmal.  Die Ursache f√ºr den ersten Fehler ist der in Java vorzeichenlose <i>char-</i> Typ, weshalb die Bedingung <i>(int) x &lt;0</i> immer falsch ist.  Der zweite Fehler ist das banale <i>√úberschreiten</i> der <i>Grenzen des</i> Arrays <i>index_64,</i> wenn <i>(int) x == index_64.length ist</i> .  Diese Situation ist aufgrund der Bedingung <i>(int) x&gt; index_64.length m√∂glich</i> .  Um die Grenzen des Arrays zu √ºberschreiten, muss die Bedingung '&gt;' durch '&gt; =' ersetzt werden.  Die korrekte Bedingung w√§re: <i>(int) x&gt; = index_64.length</i> . <br><br><h2>  Achte Stelle: Entscheidung und ihre Folgen </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0626/">CUBA-Plattform-Code-Analyse mit PVS-Studio</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007</a> Ausdruck 'previousMenuItemFlatIndex&gt; = 0' ist immer wahr.  CubaSideMenuWidget.java (328) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> MenuItemWidget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findNextMenuItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MenuItemWidget currentItem)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;MenuTreeNode&gt; menuTree = buildVisibleTree(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); List&lt;MenuItemWidget&gt; menuItemWidgets = menuTreeToList(menuTree); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> menuItemFlatIndex = menuItemWidgets.indexOf(currentItem); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> previousMenuItemFlatIndex = menuItemFlatIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousMenuItemFlatIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return menuItemWidgets.get(previousMenuItemFlatIndex); } return null; }</span></span></code> </pre> <br>  Der Autor der <i>findNextMenuItem-</i> Methode m√∂chte das von der <i>indexOf-</i> Methode zur√ºckgegebene -1 <i>entfernen</i> , wenn die <i>menuItemWidgets-</i> Liste kein <i>currentItem</i> enth√§lt.  Dazu addiert er eins zum Ergebnisindex (Variable <i>menuItemFlatIndex</i> ) und speichert den resultierenden Wert in der Variablen <i>previousMenuItemFlatIndex</i> , die in der Methode weiter verwendet wird.  Diese L√∂sung f√ºr das -1-Problem ist nicht erfolgreich, da sie gleichzeitig zu mehreren Fehlern f√ºhrt: <br><br><ul><li>  <i>return null</i> code wird niemals ausgef√ºhrt, da der Ausdruck <i>previousMenuItemFlatIndex&gt; = 0</i> immer true ist. <i>Dies</i> bedeutet, dass die R√ºckgabe der <i>findNextMenuItem-</i> Methode immer innerhalb der <i>if-</i> Methode <i>erfolgt</i> . </li><li>  Eine <i>IndexOutOfBoundsException</i> wird ausgel√∂st, wenn die <i>menuItemWidgets-</i> Liste leer ist, da auf das erste Element der leeren Liste zugegriffen wird. </li><li>  Eine <i>IndexOutOfBoundsException-</i> Ausnahme tritt auf, wenn das Argument <i>currentItem</i> das letzte Argument in der <i>menuItemWidget-</i> Liste ist. </li></ul><br><h2>  Siebter Platz: Erstellen einer Datei aus dem Nichts </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0688/">Huawei Cloud: Heute ist es in PVS-Studio bew√∂lkt</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6008/">V6008</a> M√∂gliche Null-Dereferenzierung von 'dataTmpFile'.  CacheManager.java (91) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putToCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PutRecordsRequest putRecordsRequest)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !dataTmpFile.exists()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { dataTmpFile.createNewFile(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } catch (IOException e) { LOGGER.error("Failed to create cache tmp file, return.", e); return; } } .... }</span></span></code> </pre> <br>  Beim Schreiben der <i>putToCache-</i> Methode <i>machte der</i> Programmierer einen Tippfehler in der Bedingung <i>dataTmpFile == null ||</i>  <i>! dataTmpFile.exists ()</i> vor dem Erstellen einer neuen <i>dataTmpFile.createNewFile ()</i> -Datei <i>.</i>  Ein Tippfehler ist die Verwendung des Operators '==' anstelle von '! ='.  Dieser Tippfehler <i>l√∂st</i> eine <i>NullPointerException aus,</i> wenn die <i>createNewFile-</i> Methode <i>aufgerufen</i> wird.  Die Bedingung nach der Korrektur eines Tippfehlers sieht folgenderma√üen aus: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !dataTmpFile.exists())</code> </pre> <br>  ‚ÄûDer Fehler wurde gefunden, behoben.  Du kannst dich entspannen ‚Äú, werden Sie denken.  Aber egal wie! <br><br>  Nachdem wir einen Fehler behoben hatten, fanden wir einen anderen.  Jetzt kann beim Aufrufen von <i>dataTmpFile.exists ()</i> eine <i>NullPointerException</i> auftreten.  Um die Ausnahme zu beseitigen, muss der Operator '||' in der Bedingung ersetzt werden  auf '&amp;&amp;'.  Die Bedingung, unter der alle Fehler verschwinden, lautet wie folgt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !dataTmpFile.exists())</code> </pre> <br><h2>  Sechster Platz: ein sehr seltsamer logischer Fehler </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0603/">PVS-Studio f√ºr Java</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007</a> [CWE-570] Der Ausdruck "0" .equals (text) "ist immer falsch.  ConvertIntegerToDecimalPredicate.java 46 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-meta"><span class="hljs-meta">@NonNls</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String text = expression.getText().replaceAll(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || text.length() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"0"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0L"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0l"</span></span>.equals(text)) {<span class="hljs-comment"><span class="hljs-comment">// &lt;= return false; } return text.charAt(0) == '0'; }</span></span></code> </pre> <br>  Diese Methode ist insofern interessant, als sie einen offensichtlichen logischen Fehler enth√§lt.  Wenn die <i>satisfiedBy-</i> Methode nach dem ersten <i>if</i> <i>keinen</i> Wert <i>zur√ºckgibt</i> , wird bekannt, dass die <i>Textzeichenfolge</i> aus mindestens zwei Zeichen besteht.  Aus diesem Grund ist der erste <i>Haken bei "0" .Equals (Text)</i> im n√§chsten <i>If</i> bedeutungslos.  Was der Entwickler wirklich gemeint hat, bleibt ein R√§tsel. <br><br><h2>  F√ºnfter Platz: Dies ist eine Wende! </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0657/">PVS-Studio besucht Apache Hive</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6034/">V6034 Die</a> Verschiebung um den Wert 'bitShiftsInWord - 1' kann mit der Gr√∂√üe des Typs 'bitShiftsInWord - 1' = [-1 ... 30] inkonsistent sein.  UnsignedInt128.java (1791) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shiftRightDestructive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wordShifts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitShiftsInWord, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> roundUp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bitShiftsInWord == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (bitShiftsInWord &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (bitShiftsInWord &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { zeroClear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shiftRestore = <span class="hljs-number"><span class="hljs-number">32</span></span> - bitShiftsInWord; <span class="hljs-comment"><span class="hljs-comment">// check this because "123 &lt;&lt; 32" will be 123. final boolean noRestore = bitShiftsInWord == 0; final int roundCarryNoRestoreMask = 1 &lt;&lt; 31; final int roundCarryMask = (1 &lt;&lt; (bitShiftsInWord - 1)); // &lt;= .... }</span></span></code> </pre> <br>  Bei den Eingabeargumenten <i>wordShifts = 3</i> und <i>bitShiftsInWord = 0</i> ist die Variable <i>roundCarryMask</i> , die das Ergebnis der Bitverschiebung <i>(1 &lt;&lt; (bitShiftsInWord - 1)) speichert</i> , eine negative Zahl.  Vielleicht hat der Entwickler dieses Verhalten nicht erwartet. <br><br><h2>  Vierter Platz: Werden die Ausnahmen f√ºr einen Spaziergang herauskommen? </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0657/">PVS-Studio besucht Apache Hive</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6051/">V6051</a> Die Verwendung der Anweisung 'return' im Block 'finally' kann zum Verlust nicht behandelter Ausnahmen f√ºhren.  ObjectStore.java (9080) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;MPartitionColumnStatistics&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMPartitionColumnStatistics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> NoSuchObjectException, MetaException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> committed = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... <span class="hljs-comment"><span class="hljs-comment">/*some actions*/</span></span> committed = commitTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LOG.error(<span class="hljs-string"><span class="hljs-string">"Error retrieving statistics via jdo"</span></span>, ex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ex <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> MetaException) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (MetaException) ex; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MetaException(ex.getMessage()); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!committed) { rollbackTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lists.newArrayList(); } } }</code> </pre> <br>  Die Deklaration der Methode <i>getMPartitionColumnStatistics</i> sagt uns, dass sie eine Ausnahme <i>ausl√∂sen</i> kann.  Wenn bei <i>try</i> eine Ausnahme auftritt, bleibt die <i>festgeschriebene</i> Variable <i>false</i> . Daher gibt die <i>return-Anweisung</i> im <i>finally-</i> Block den Wert der Methode zur√ºck, und alle ausgel√∂sten Ausnahmen gehen verloren und k√∂nnen nicht au√üerhalb der Methode verarbeitet werden.  Daher kann eine Ausnahme, die in dieser Methode ausgel√∂st wird, niemals daraus hervorgehen. <br><br><h2>  Dritter Platz: Ich drehe, drehe, ich m√∂chte eine neue Maske bekommen </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0657/">PVS-Studio besucht Apache Hive</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6034/">V6034 Die</a> Verschiebung um den Wert 'j' kann mit der Gr√∂√üe des Typs inkonsistent sein: 'j' = [0 ... 63].  IoTrace.java (272) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logSargResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stripeIx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] rgsToRead)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, valOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; elements; ++i, valOffset += <span class="hljs-number"><span class="hljs-number">64</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">64</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ix = valOffset + j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rgsToRead.length == ix) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rgsToRead[ix]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; val = val | (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; j); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } .... } .... }</span></span></code> </pre> <br>  Ein weiterer Fehler betraf die bitweise Verschiebung, aber diesmal war nicht nur er in den Fall verwickelt.  In der inneren <i>for-</i> Schleife wird die Variable <i>j</i> [0 ... 63] als Schleifenz√§hler verwendet.  Dieser Z√§hler ist an einer Bitverschiebung von <i>1 &lt;&lt; j beteiligt</i> .  Nichts ist √§rgerlich, aber hier kommt das Integer-Literal '1' vom Typ <i>int</i> (32-Bit-Wert) ins Spiel.  Daraus folgt, dass sich die Ergebnisse der Bitverschiebung zu wiederholen beginnen, nachdem <i>j</i> gr√∂√üer als 31 ist. Wenn das beschriebene Verhalten unerw√ºnscht ist, muss die Einheit so <i>lange dargestellt werden</i> , beispielsweise <i>1L &lt;&lt; j</i> oder <i>(lang) 1 &lt;&lt; j</i> . <br><br><h2>  Zweiter Platz: Initialisierungsauftrag </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0688/">Huawei Cloud: Heute ist es in PVS-Studio bew√∂lkt</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6050/">V6050 Klasseninitialisierungszyklus</a> ist vorhanden.  Die Initialisierung von 'INSTANCE' erscheint vor der Initialisierung von 'LOG'.  UntrustedSSL.java (32), UntrustedSSL.java (59), UntrustedSSL.java (33) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> UntrustedSSL INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UntrustedSSL(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(UntrustedSSL.class); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { LOG.error(t.getMessage(), t); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  Die Reihenfolge, in der Felder in einer Klasse deklariert werden, ist wichtig, da die Felder in der Reihenfolge initialisiert werden, in der sie deklariert wurden.  Wenn sie es jedoch vergessen, treten subtile Fehler wie dieser auf. <br><br>  Der Analyzer hat angegeben, dass das statische <i>LOG-</i> Feld im Konstruktor dereferenziert wird, wenn es auf <i>null</i> initialisiert wird, was zur <i>Ausnahmekette</i> <i>NullPointerException</i> -&gt; <i>ExceptionInInitializerError f√ºhrt</i> . <br><br>  "Warum ist das statische <i>LOG-</i> Feld zum Zeitpunkt des Konstruktoraufrufs <i>null</i> ?" <br><br>  Die ExceptionInInitializerError- <i>Ausnahme</i> ist ein Hinweis.  Tatsache ist, dass dieser Konstruktor verwendet wird, um das in der Klasse <i>deklarierte</i> statische <i>INSTANCE-</i> Feld vor dem <i>LOG-</i> Feld zu initialisieren.  Zum Zeitpunkt des Konstruktoraufrufs ist das <i>LOG-</i> Feld daher noch nicht initialisiert.  Damit der Code korrekt funktioniert, muss das <i>LOG-</i> Feld initialisiert werden, bevor der Konstruktor <i>aufgerufen wird</i> . <br><br><h2>  Erster Platz: Copy-Paste-orientierte Programmierung </h2><br>  Quelle: <a href="https://www.viva64.com/ru/b/0697/">Apache Hadoop Code Qualit√§t: Produktions-VS-Test</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6072/">V6072</a> Es wurden zwei √§hnliche Codefragmente gefunden.  M√∂glicherweise ist dies ein Tippfehler, und die Variable 'localFiles' sollte anstelle von 'localArchives' verwendet werden.  LocalDistributedCacheManager.java (183), LocalDistributedCacheManager.java (178), LocalDistributedCacheManager.java (176), LocalDistributedCacheManager.java (181) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobConf conf, JobID jobId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Update the configuration object with localized data. if (!localArchives.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils .arrayToString(localArchives.toArray(new String[localArchives // &lt;= .size()]))); } if (!localFiles.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils .arrayToString(localFiles.toArray(new String[localArchives // &lt;= .size()]))); } .... }</span></span></code> </pre> <br>  Und der erste Platz wird durch Kopieren und Einf√ºgen eingenommen, oder vielmehr durch einen Fehler, der auf die Nachl√§ssigkeit desjenigen zur√ºckzuf√ºhren ist, der diese s√ºndige Sache begangen hat.  Es ist sehr wahrscheinlich, dass das zweite <i>if</i> durch Kopieren und Einf√ºgen des ersten mit dem Ersetzen von Variablen erstellt wurde: <br><br><ul><li>  <i>localArchives</i> on <i>localFiles</i> ; </li><li>  <i>MRJobConfig.CACHE_LOCALARCHIVES</i> bei <i>MRJobConfig.CACHE_LOCALFILES</i> . </li></ul><br>  Selbst mit solch einer einfachen Operation wurde jedoch ein Fehler gemacht, da die Variable <i>localArchives</i> in der zweiten <i>if-</i> Zeile des zweiten <i>Analysators noch verwendet wurde</i> , obwohl die Verwendung von <i>localFiles</i> h√∂chstwahrscheinlich impliziert war. <br><br><h2>  Fazit </h2><br>  Die Korrektur von Fehlern in sp√§teren Entwicklungsstadien oder nach der Freigabe eines Projekts erfordert erhebliche Ressourcen.  Der statische Analysator PVS-Studio vereinfacht das Erkennen von Fehlern beim Schreiben von Code, wodurch der Aufwand f√ºr die Fehlerbehebung erheblich reduziert wird.  Die st√§ndige Verwendung des Analysators hat bereits das Leben der Entwickler vieler <a href="https://www.viva64.com/ru/customers/">Unternehmen</a> vereinfacht.  Wenn Sie gerne programmieren m√∂chten, probieren Sie unseren <a href="https://www.viva64.com/ru/pvs-studio-download/">Analysator aus</a> . <br><br>  Unser Team wird hier nicht aufh√∂ren und den Analysator weiter verbessern und verbessern.  Erwarten Sie im n√§chsten Jahr neue Diagnosen und Artikel mit noch interessanteren Fehlern. <br><br>  Ich sehe zu, wie du Abenteuer liebst!  Zuerst gewannen die <a href="https://habr.com/ru/company/pvs-studio/blog/481178/">10 h√§ufigsten Fehler in C # -Projekten f√ºr 2019</a> und jetzt konnte Java siegen!  Willkommen auf der n√§chsten Ebene im Artikel √ºber die <a href="https://habr.com/ru/company/pvs-studio/blog/481190/">besten Fehler des Jahres 2019 in C ++ - Projekten</a> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/24/2j/ex/242jexzqwnmth1lyfcrr8icxmms.png"></div><br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/481184/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel mit einem englischsprachigen Publikum teilen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Valery Komarov.  <a href="https://habr.com/en/company/pvs-studio/blog/481184/">Die 10 h√§ufigsten Fehler in Java-Projekten im Jahr 2019</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481186/">https://habr.com/ru/post/de481186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481176/index.html">Kuriere Yandex.Food and Delivery Club brauchen eine Gewerkschaft</a></li>
<li><a href="../de481178/index.html">Top 10 Bugs in C # -Projekten f√ºr 2019</a></li>
<li><a href="../de481180/index.html">M√ºssen Entwickler Vorschl√§ge von Benutzern erhalten?</a></li>
<li><a href="../de481182/index.html">Istio Service Mesh Beitr√§ge Serie</a></li>
<li><a href="../de481184/index.html">Die 10 h√§ufigsten Fehler in Java-Projekten im Jahr 2019</a></li>
<li><a href="../de481188/index.html">Die 10 h√§ufigsten Fehler in C ++ - Projekten im Jahr 2019</a></li>
<li><a href="../de481190/index.html">Top 10 Bugs in C ++ Projekten f√ºr 2019</a></li>
<li><a href="../de481200/index.html">Sprachsteuerung und VoiceOver: So passen Sie die Anwendung f√ºr Blinde oder Standbilder an</a></li>
<li><a href="../de481202/index.html">Antiquit√§ten: das Prinzip des M√ºllsammelns und die Ergebnisse von 2019</a></li>
<li><a href="../de481204/index.html">Tech release Mail.ru Group, Winter 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>