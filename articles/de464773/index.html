<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîñ üíü ü§ôüèª Asynchrones Typoskript in Rich Internet-Anwendungen und Dekorateuren zur Bek√§mpfung üöµüèº üö• üåßÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seit dem Aufkommen von async / await hat Typescript viele Artikel ver√∂ffentlicht, die diesen Entwicklungsansatz hervorheben ( hackernoon , blog.bitsrc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asynchrones Typoskript in Rich Internet-Anwendungen und Dekorateuren zur Bek√§mpfung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464773/"><p> Seit dem Aufkommen von <code>async</code> / <code>await</code> hat Typescript viele Artikel ver√∂ffentlicht, die diesen Entwicklungsansatz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hervorheben</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hackernoon</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">blog.bitsrc.io</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr.com</a> ).  Wir verwenden sie von Anfang an auf der Clientseite (wenn ES6-Generatoren weniger als 50% der Browser unterst√ºtzen).  Und jetzt m√∂chte ich meine Erfahrungen teilen, denn <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">parallele Ausf√ºhrung</a> ist nicht alles, was auf diesem Weg gut zu wissen w√§re. </p><a name="habracut"></a><br><p>  Der letzte Artikel gef√§llt mir nicht wirklich: Etwas kann unverst√§ndlich sein.  Teilweise aufgrund der Tatsache, dass ich keinen propriet√§ren Code bereitstellen kann - nur um den allgemeinen Ansatz zu skizzieren.  Deshalb: </p><br><ul><li>  Z√∂gern Sie nicht, den Tab zu schlie√üen, ohne ihn zu lesen </li><li>  Wenn Sie es schaffen, fragen Sie nach unklaren Details </li><li>  Ich nehme gerne Ratschl√§ge und Kritik von den hartn√§ckigsten und gr√ºndlichsten bis zu dem Punkt an. </li></ul><br><p>  <strong>Liste der Kerntechnologien:</strong> </p><br><ul><li>  Das Projekt ist haupts√§chlich in Typescript mit mehreren Javascript-Bibliotheken geschrieben.  Die Hauptbibliothek ist ExtJS.  Es ist in seiner Modalit√§t schlechter als React, eignet sich jedoch am besten f√ºr ein Unternehmensprodukt mit einer umfangreichen Benutzeroberfl√§che: viele vorgefertigte Komponenten, sofort gut gestaltete Tabellen, ein umfangreiches √ñkosystem verwandter Produkte zur Vereinfachung der Entwicklung. </li><li>  Asynchroner Multithread-Server. </li><li>  RPC √ºber Websocket wird als Transport zwischen Client und Server verwendet.  Die Implementierung √§hnelt .NET WCF. <br><ul><li>  Jedes Objekt ist eine Dienstleistung. </li><li>  Jedes Objekt kann sowohl nach Wert als auch nach Referenz √ºbertragen werden. </li></ul></li><li>  Die Datenanforderungsschnittstelle √§hnelt GraphQL von Facebook, nur auf Typescript. </li><li>  Zweiwege-Kommunikation: Die Initialisierung der Datenaktualisierung kann sowohl vom Client als auch vom Server aus gestartet werden. </li><li>  Asynchroner Code wird nacheinander mithilfe der asynchronen / wartenden Funktionen von Typesrcipt geschrieben. </li><li>  Die Server-API wird in Typescript generiert: Wenn sie sich √§ndert, zeigt der Build sie im Fehlerfall sofort an. </li></ul><br><p>  <strong>Was ist die Ausgabe</strong> </p><br><p>  Ich werde Ihnen sagen, wie wir damit arbeiten und was wir f√ºr eine sichere, nicht wettbewerbsf√§hige Ausf√ºhrung von asynchronem Code getan haben: unsere Typesrcipt-Dekoratoren, die die Funktionalit√§t von Warteschlangen implementieren.  Von den Grundlagen bis zur L√∂sung der Rennbedingungen und anderer Schwierigkeiten, die w√§hrend des Entwicklungsprozesses auftreten. </p><br><h2 id="kak-strukturirovany-dannye-poluchaemye-s-servera">  Wie die vom Server empfangenen Daten strukturiert sind </h2><br><p>  Der Server gibt ein √ºbergeordnetes Objekt zur√ºck, das in seinen Eigenschaften Daten (andere Objekte, Sammlungen von Objekten, Zeilen usw.) in Form eines Diagramms enth√§lt.  Dies ist unter anderem auf die Anwendung selbst zur√ºckzuf√ºhren: </p><br><ul><li>  Es macht die Datenanalyse / ML zu einem gerichteten Graphen von Handlerknoten. </li><li>  Jeder Knoten kann sein eigenes eingebettetes Diagramm enthalten </li><li>  Diagramme haben Abh√§ngigkeiten: Knoten k√∂nnen "geerbt" werden, und neue Knoten werden durch ihre "Klasse" erstellt. </li></ul><br><p>  Die Abfragestruktur in Form eines Diagramms kann jedoch in fast jeder Anwendung angewendet werden, und GraphQL erw√§hnt dies meines Wissens auch in seiner Spezifikation. </p><br><p>  Beispieldatenstruktur: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   interface IParent { ServerId: string; Nodes: INodes; // INodes -     INode } //     interface INodes&lt;TNode extends INode&gt; extends ICollection { IndexOf(item: TNode): number; Item(index: number): TNode; // ...     } //    interface INode extends IItem { Guid: string; Name: string; DisplayName: string; Links: ILinks; // ILinks -    Info: INodeInfo; //    -  } //      interface ILink { Guid: string; DisplayName: string; SourceNode: INode; //   -  TargetNode: INode; //   ,   } interface INodeInfo { Component: IComponent; ConfigData: IData; }</span></span></code> </pre><br><h2 id="kak-klient-poluchaet-dannye">  Wie erh√§lt ein Kunde Daten? </h2><br><p>  Es ist ganz einfach: Wenn Sie eine Eigenschaft eines Objekts eines nicht skalaren Typs anfordern, gibt RPC <code>Promise</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Nodes = Parent.Nodes; <span class="hljs-comment"><span class="hljs-comment">// Nodes -&gt; Promise&lt;INodes&gt;</span></span></code> </pre><br><h3 id="asinhronnost-bez-callback-hell">  Asynchronit√§t ohne "Callback Hell". </h3><br><p>  Um einen "sequentiellen" asynchronen Code zu organisieren, wird die Typescript-Funktion <code>async</code> / <code>await</code> verwendet: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowNodes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">parent: IParent</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    let Nodes = await parent.Nodes; //       await Nodes.forEachParallel(async function(node): Promise&lt;void&gt; { await RenderNode(node); //          }); }</span></span></code> </pre><br><p>  Es macht keinen Sinn, im Detail darauf einzugehen, auf der Nabe gibt es bereits gen√ºgend <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">detailliertes Material</a> .  Sie erschienen bereits 2016 in Typescript.  Wir verwenden diesen Ansatz, seit er im Feature-Zweig des Typescript-Repositorys erscheint. Deshalb haben wir schon lange Probleme und arbeiten jetzt mit Vergn√ºgen.  Seit einiger Zeit und in Produktion. </p><br><p>  Kurz gesagt, die Essenz f√ºr diejenigen, die mit dem Thema nicht vertraut sind: </p><br><p>  Sobald Sie der Funktion das Schl√ºsselwort <code>async</code> hinzuf√ºgen, wird automatisch das <code>Promise&lt;_&gt;</code> .  Merkmale solcher Funktionen: </p><br><ul><li>  Ausdr√ºcke in <code>async</code> Funktionen mit <code>await</code> (die <code>Promise</code> ) stoppen die Ausf√ºhrung der Funktion und werden nach dem Aufl√∂sen des erwarteten <code>Promise</code> fortgesetzt. </li><li>  Wenn in der <code>async</code> Funktion eine Ausnahme auftritt, wird das zur√ºckgegebene <code>Promise</code> mit dieser Ausnahme abgelehnt. </li><li>  Beim Kompilieren in Javascript-Code gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Generatoren</a> f√ºr den ES6-Standard ( <code>function*</code> anstelle der <code>async function</code> und <code>yield</code> statt Warten) oder be√§ngstigenden Code mit <code>switch</code> f√ºr ES5 (Zustandsmaschine).  <code>await</code> ist ein Schl√ºsselwort, das auf das Ergebnis eines Versprechens wartet.  Zum Zeitpunkt des Meetings stoppt die <code>ShowNodes</code> Funktion w√§hrend der Ausf√ºhrung des Codes, und w√§hrend Javascript auf Daten wartet, f√ºhrt es m√∂glicherweise einen anderen Code aus. </li></ul><br><p>  Im obigen Code verf√ºgt die Auflistung √ºber eine <code>forEachParallel</code> Methode, die f√ºr jeden Knoten parallel einen asynchronen R√ºckruf aufruft.  Warten Sie gleichzeitig, bevor <code>Nodes.forEachParallel</code> auf alle R√ºckrufe wartet.  Innerhalb der Implementierung - <code>Promise.all</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *            * @param items  * @param callbackfn  * @param [thisArg]   ,      this  callbackfn */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEachParallel</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items: IItemArray&lt;T&gt;, callbackfn: (value: T, index: int, items: IItemArray&lt;T&gt;</span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">&gt;, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thisArg</span></span></span><span class="hljs-function">?: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xCount = items ? <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> items.Count : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!xCount) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xActions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> | any&gt;&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xCount</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">for</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">let</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; xCount; i++</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">let</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xItem</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Item</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xActions</span></span></span><span class="hljs-function">[</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">] = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecuteCallback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xItem, callbackfn, i, items, thisArg</span></span></span><span class="hljs-function">); } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">await</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Promise</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">all</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xActions</span></span></span><span class="hljs-function">); } /**   </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">   </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callbackfn</span></span></span><span class="hljs-function"> */ </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecuteCallback</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item: </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Promise</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; | T, callbackfn: (value: T, index: int, items: IItemArray&lt;T&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> | any&gt;, <span class="hljs-attr"><span class="hljs-attr">index</span></span>: int, <span class="hljs-attr"><span class="hljs-attr">items</span></span>: IItemArray&lt;T&gt;, thisArg?: any): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xItem = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> item; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> callbackfn.call(thisArg, xItem, index, items); }</code> </pre><br><p>  Dies ist syntaktischer Zucker: Solche Methoden sollten nicht nur f√ºr ihre Sammlungen verwendet werden, sondern auch f√ºr Standard-Javascript-Arrays. </p><br><p>  Die <code>ShowNodes</code> Funktion sieht √§u√üerst nicht optimal aus: Wenn wir eine andere Entit√§t anfordern, warten wir jedes Mal darauf.  Der Vorteil besteht darin, dass ein solcher Code schnell geschrieben werden kann, sodass dieser Ansatz f√ºr das Rapid Prototyping gut ist.  In der endg√ºltigen Version m√ºssen Sie die Abfragesprache verwenden, um die Anzahl der Anrufe an den Server zu verringern. </p><br><h2 id="yazyk-zaprosov">  Abfragesprache </h2><br><p>  Es gibt verschiedene Funktionen, mit denen eine Datenanforderung vom Server "erstellt" wird.  Sie "teilen" dem Server mit, welche Knoten des Datengraphen in der Antwort zur√ºckgegeben werden sollen: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *       item    Promise  , *      properties */</span></span> selectAsync&lt;T extends IItem&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item: T, properties: (</span></span></span><span class="hljs-function">) =&gt;</span></span> any[]): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;T&gt;; <span class="hljs-comment"><span class="hljs-comment">/** *   items,       properties */</span></span> selectAsyncAll&lt;T extends ICollection&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items: T[], properties: (</span></span></span><span class="hljs-function">) =&gt;</span></span> any[]): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;T[]&gt;; <span class="hljs-comment"><span class="hljs-comment">/**    selectAsync     */</span></span> select&lt;T&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item: T, properties: (</span></span></span><span class="hljs-function">) =&gt;</span></span> any[]): T; <span class="hljs-comment"><span class="hljs-comment">/**    selectAsync     */</span></span> selectAll&lt;T&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items: T[], properties: (</span></span></span><span class="hljs-function">) =&gt;</span></span> any[]): T[];</code> </pre><br><p>  Schauen wir uns nun die Anwendung dieser Funktionen an, um die erforderlichen eingebetteten Daten mit einem Aufruf an den Server anzufordern: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowNodes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">parentPoint: IParent</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       IParent -    selectAsync ( // Promise,  ). let Parent = await selectAsync(parentPoint, parent =&gt; [ //           selectAll(parent.Nodes, nodes =&gt; [node.Name, node.DisplayName]) // [node.Name, node.DisplayName] -        ]); //      Parent.Nodes ... }</span></span></code> </pre><br><p>  Ein Beispiel f√ºr eine etwas komplexere Abfrage mit tief eingebetteten Informationen: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     parent.Nodes  selectAsyncAll,    let Parent = await selectAsyncAll(parent.Nodes, nodes =&gt; [ //    : select(node, node =&gt; [ node.Name, node.DisplayName, selectAll(node.Links, link =&gt; [ link.Guid, link.DisplayName, select(link.TargetNode, targetNode =&gt; [targetNode.Guid]) ]), select(node.Info, info =&gt; [info.Component]) //    IInfo    IComponent,   ,   ,        ]) ]);</span></span></code> </pre><br><p>  Die Abfragesprache hilft, unn√∂tige Anforderungen an den Server zu vermeiden.  Aber der Code ist niemals perfekt und wird sicherlich mehrere Wettbewerbsanforderungen und infolgedessen die Rennbedingungen enthalten. </p><br><h2 id="race-condition-i-puti-resheniya">  Rennbedingungen und L√∂sungen </h2><br><p>  Da wir Serverereignisse abonnieren und Code mit einer gro√üen Anzahl von asynchronen Anforderungen schreiben, kann eine Race-Bedingung auftreten, wenn die asynchrone <code>FuncOne</code> Funktion unterbrochen wird und auf <code>Promise</code> wartet.  Zu diesem Zeitpunkt kann ein Serverereignis (oder die n√§chste Benutzeraktion) auftreten und nach einer wettbewerbsf√§higen Ausf√ºhrung das Modell auf dem Client √§ndern.  Dann kann <code>FuncOne</code> nach der L√∂sung des Versprechens beispielsweise auf bereits gel√∂schte Ressourcen <code>FuncOne</code> . </p><br><p>  Stellen Sie sich eine solche vereinfachte Situation vor: Das <code>IParent</code> Objekt verf√ºgt √ºber einen <code>IParent</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/**   */</span></span> Parent.OnSynchronize.AddListener(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  .   ,  . });</span></span></code> </pre><br><p>  Es wird aufgerufen, wenn die Liste der <code>INodes</code> Knoten auf dem Server aktualisiert wird.  Dann ist im folgenden Szenario eine Rennbedingung m√∂glich: </p><br><ol><li>  Wir veranlassen das asynchrone Entfernen des Knotens vom Client und warten auf den Abschluss, um das Clientobjekt zu l√∂schen <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnClickRemoveNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node: INode</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> removedOnServer: boolean = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Parent.RemoveNode(node); <span class="hljs-comment"><span class="hljs-comment">//     if (removedOnServer) .... }</span></span></code> </pre> </li><li>  √úber <code>Parent.OnSynchronize</code> wird das Knotenlistenereignis aktualisiert. </li><li>  <code>Parent.OnSynchronize</code> verarbeitet und l√∂scht das <code>Parent.OnSynchronize</code> . </li><li>  <code>async OnClickRemoveNode()</code> nach dem ersten <code>async OnClickRemoveNode()</code> weiter ausgef√ºhrt, und es wird versucht, ein bereits gel√∂schtes <code>async OnClickRemoveNode()</code> zu l√∂schen. </li></ol><br><p>  Sie k√∂nnen die Existenz eines <code>OnClickRemoveNode</code> in <code>OnClickRemoveNode</code> .  Dies ist ein vereinfachtes Beispiel, in dem eine √§hnliche Pr√ºfung normal ist.  Was aber, wenn die Anrufkette komplizierter ist?  Daher ist es eine schlechte Praxis, nach jedem <code>await</code> einen √§hnlichen Ansatz zu verwenden: </p><br><ul><li>  Der so aufgebl√§hte Code ist kompliziert zu unterst√ºtzen und zu erweitern. </li><li>  Der Code funktioniert nicht wie beabsichtigt: Das L√∂schen in <code>OnClickRemoveNode</code> , und das eigentliche L√∂schen des <code>OnClickRemoveNode</code> erfolgt an anderer Stelle.  Es sollte keine Verletzung der vom Entwickler definierten Sequenz vorliegen, da sonst Regressionsfehler auftreten. </li><li>  Dies ist nicht zuverl√§ssig genug: Wenn Sie vergessen, irgendwo eine √úberpr√ºfung durchzuf√ºhren, liegt ein Fehler vor.  Zun√§chst besteht die Gefahr, dass eine vergessene Pr√ºfung lokal und in einer Testumgebung nicht zu einem Fehler f√ºhrt und bei Benutzern mit einer l√§ngeren Netzwerkverz√∂gerung auftritt. </li><li>  Und wenn der Controller, zu dem diese Handler geh√∂ren, zerst√∂rt werden kann?  Nach jedem <code>await</code> , um seine Zerst√∂rung zu √ºberpr√ºfen? </li></ul><br><p>  Eine andere Frage stellt sich: Was ist, wenn es viele √§hnliche Wettbewerbsmethoden gibt?  Stellen Sie sich vor, es gibt mehr: </p><br><ul><li>  Hinzuf√ºgen eines Knotens </li><li>  Knotenaktualisierung </li><li>  Links hinzuf√ºgen / entfernen </li><li>  Konvertierungsmethode f√ºr mehrere Knoten </li><li>  Komplexes Verhalten der Anwendung: Wir √§ndern den Status eines Knotens und der Server aktualisiert die davon abh√§ngigen Knoten. </li></ul><br><p>  Es ist eine architektonische Implementierung erforderlich, die im Prinzip die M√∂glichkeit von Fehlern aufgrund von Rennbedingungen, parallelen Benutzeraktionen usw. ausschlie√üt.  Die richtige L√∂sung, um die gleichzeitige √Ñnderung des Modells vom Client oder Server zu vermeiden, besteht darin, einen kritischen Abschnitt mit einer Anrufwarteschlange zu implementieren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typoskript-Dekoratoren</a> sind hier n√ºtzlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> um solche wettbewerbsf√§higen asynchronen Steuerungsfunktionen deklarativ zu kennzeichnen. </p><br><p>  <strong>Wir skizzieren die Anforderungen und Hauptmerkmale solcher Dekorateure:</strong> </p><br><ol><li>  Im Inneren sollte eine Warteschlange mit Aufrufen von asynchronen Funktionen implementiert werden.  Abh√§ngig von der Art des Dekorateurs kann ein Funktionsaufruf in die Warteschlange gestellt oder abgelehnt werden, wenn andere Aufrufe darin enthalten sind. </li><li>  Markierte Funktionen erfordern einen Ausf√ºhrungskontext, um an die Warteschlange gebunden zu werden.  Sie m√ºssen entweder explizit eine Warteschlange erstellen oder dies automatisch basierend auf der Ansicht tun, zu der der Controller geh√∂rt. </li><li>  Informationen zur Zerst√∂rung der Controller-Instanz sind erforderlich (z. B. die <code>IsDestroyed</code> Eigenschaft).  Um zu verhindern, dass Dekorateure Anrufe in die Warteschlange stellen, nachdem der Controller zerst√∂rt wurde. </li><li>  F√ºr den View-Controller f√ºgen wir die Funktionalit√§t zum Anwenden einer durchscheinenden Maske hinzu, um Aktionen zum Zeitpunkt der Ausf√ºhrung der Warteschlange auszuschlie√üen und die laufende Verarbeitung visuell anzuzeigen. </li><li>  Alle Dekorateure m√ºssen mit einem Aufruf von <code>Promise.done()</code> .  Bei dieser Methode m√ºssen Sie den <code>handler</code> behandelte Ausnahmen implementieren.  Eine sehr n√ºtzliche Sache: <br><ul><li>  Ausnahmen, die in <code>Promise</code> aufgetreten sind, werden vom Standard-Fehlerbehandler nicht erfasst (der beispielsweise ein Fenster mit Text und einer Stak-Ablaufverfolgung anzeigt), sodass Sie sie m√∂glicherweise nicht bemerken (wenn Sie die Konsole w√§hrend der Entwicklung nicht st√§ndig √ºberwachen).  Und der Benutzer wird sie √ºberhaupt nicht sehen - dies erschwert die Unterst√ºtzung.  Hinweis: Es ist m√∂glich, sich f√ºr das nicht behandelte <code>unhandledrejection</code> , es wird jedoch nur von Chrome und Edge unterst√ºtzt: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'unhandledrejection'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// handling... });</span></span></code> </pre> </li><li>  Da wir die h√∂chste <code>async</code> Ereignishandlerfunktion als Dekoratoren markieren, erhalten wir den gesamten Stack-Trace-Fehler. </li></ul></li></ol><br><p>  Nun geben wir eine ungef√§hre Liste solcher Dekorateure mit einer Beschreibung und zeigen dann, wie sie angewendet werden k√∂nnen. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * : * 1.      * 2.      ,   . * *  ,  :   ,         */</span></span> @Lock <span class="hljs-comment"><span class="hljs-comment">/** * : *     ,     . * *  ,     :   ,   . */</span></span> @LockQueue <span class="hljs-comment"><span class="hljs-comment">/** *  LockQueue .  -         * *   ,       . ,   . */</span></span> @LockBetween <span class="hljs-comment"><span class="hljs-comment">/** * : *       ,   . *     . :     ,     300 .       . */</span></span> @LockDeferred(<span class="hljs-number"><span class="hljs-number">300</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ,    ,     : interface ILockTarget { /** * ,   View,   .   ,        ,     ,        */ GetControllerView?(): IView; /**  true     */ IsDestroyed: boolean; }</span></span></code> </pre><br><p>  Die Beschreibungen sind ziemlich abstrakt, aber sobald Sie ein Anwendungsbeispiel mit Erkl√§rungen sehen, wird alles klarer: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GraphController</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ILockTarget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** ,      .      */</span></span> private View: IView; public GetControllerView(): IView { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.View; } <span class="hljs-comment"><span class="hljs-comment">/**      . */</span></span> @Lock private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnClickRemoveNode(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**     . */</span></span> @Lock private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnClickRemoveLink(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**     */</span></span> @Lock private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnClickAddNewNode(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    " " */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerUpdateNode(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    " " */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerAddLink(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    " " */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerAddNode(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    -   */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerRemoveNode(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    -       */</span></span> @LockBetween private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerSynchronize(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    -    (/warning/error/...) */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerUpdateNodeStatus(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**       */</span></span> @LockDeferred(<span class="hljs-number"><span class="hljs-number">300</span></span>) private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnSearchFieldChange(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } }</code> </pre><br><p>  Jetzt werden wir einige typische Szenarien m√∂glicher Fehler und deren Beseitigung durch Dekorateure analysieren: </p><br><ol><li>  Der Benutzer initiiert eine Aktion: <code>OnClickRemoveNode</code> , <code>OnClickRemoveLink</code> .  F√ºr eine ordnungsgem√§√üe Verarbeitung m√ºssen sich keine anderen ausf√ºhrenden Handler in der Warteschlange befinden (weder Client noch Server).  Andernfalls ist beispielsweise ein solcher Fehler m√∂glich: <br><ul><li>  Das Modell auf dem Client wird weiterhin auf den aktuellen Serverstatus aktualisiert </li><li>  Wir initiieren das L√∂schen des Objekts, bevor die Aktualisierung abgeschlossen ist (in der <code>OnServerSynchronize</code> wird ein <code>OnServerSynchronize</code> Handler ausgef√ºhrt).  Dieses Objekt ist jedoch nicht mehr vorhanden - nur die vollst√§ndige Synchronisierung ist noch nicht abgeschlossen und wird weiterhin auf dem Client angezeigt. <br>  Daher sollte der <code>Lock</code> Decorator alle vom Benutzer initiierten Aktionen ablehnen, wenn sich andere Handler in der Warteschlange mit demselben Warteschlangenkontext befinden.  Da der Server asynchron ist, ist dies besonders wichtig.  Ja, Websocket sendet Anforderungen nacheinander, aber wenn der Client die Sequenz unterbricht, wird auf dem Server ein Fehler angezeigt. </li></ul></li><li>  Wir initiieren das Hinzuf√ºgen eines Knotens: <code>OnClickAddNewNode</code> .  <code>OnServerSynchronize</code> , <code>OnServerAddNode</code> Ereignisse kommen vom Server. <br><ul><li>  <code>OnClickAddNewNode</code> nahm die Warteschlange (wenn sich etwas darin befand, lehnte der <code>Lock</code> Dekorator dieser Methode den Aufruf ab). </li><li>  <code>OnServerSynchronize</code> , <code>OnServerAddNode</code> , wird nach <code>OnClickAddNewNode</code> nacheinander <code>OnClickAddNewNode</code> und konkurriert nicht damit. </li></ul></li><li>  Die Warteschlange enth√§lt <code>OnServerSynchronize</code> und <code>OnServerUpdateNode</code> .  Angenommen, der Benutzer schlie√üt w√§hrend der Ausf√ºhrung des ersten den <code>GraphController</code> .  Dann sollte der zweite Aufruf von <code>OnServerUpdateNode</code> nicht automatisch ausgef√ºhrt werden, um keine Ma√ünahmen auf dem zerst√∂rten Controller zu ergreifen, was garantiert zu einem Fehler f√ºhrt.  Zu diesem <code>ILockTarget</code> verf√ºgt die <code>ILockTarget</code> Schnittstelle √ºber <code>IsDestroyed</code> - der Dekorateur √ºberpr√ºft das Flag, ohne den n√§chsten Handler aus der Warteschlange auszuf√ºhren. <br>  Gewinn: Sie m√ºssen nicht schreiben, <code>if (!this.IsDestroyed())</code> nach jedem <code>if (!this.IsDestroyed())</code> . </li><li>  √Ñnderungen an mehreren Knoten werden gestartet.  <code>OnServerSynchronize</code> , <code>OnServerUpdateNode</code> Ereignisse kommen vom Server.  Ihre wettbewerbsf√§hige Ausf√ºhrung f√ºhrt zu nicht reproduzierbaren Fehlern.  Aber seitdem  <code>LockQueue</code> sie von <code>LockQueue</code> und <code>LockBetween</code> markiert sind, werden sie nacheinander ausgef√ºhrt. </li><li>  Stellen Sie sich vor, dass Knoten verschachtelte Knotendiagramme enthalten k√∂nnen.  <code>GraphController #1</code> ,       ‚Äî   <code>GraphController #2</code> . , <code>GraphController</code> -    ,   (  ‚Äî         ), ..     .  : <br><ul><li>  </li><li>    </li><li>    <code>GraphController #2</code> ,     ,    . </li></ul></li><li> <code>OnSearchFieldChange</code>   ,       .         -  .  <code>@LockDeferred(300)</code>     300 :         ,     ,    300 .  ,       .  : <br><ul><li>   ,   500 ,         .     ‚Äî        <code>OnSearchFieldChange</code> ,     . </li><li>      <code>OnSearchFieldChange</code>    ‚Äî        ,   . </li></ul></li></ol><br><h2 id="chto-nuzhno-znat-pri-ispolzovanii-dekoratorov">       </h2><br><ol><li>  Deadlock:     <code>Handler1</code> ,    ,   <code>await</code>   <code>Handler2</code> ,  <code>LockQueue</code> ,    <code>Handler2</code> ‚Äî <code>Handler1</code>    . </li><li>  ,     View      . :            ,      ‚Äî                . </li></ol><br><h2 id="profilirovanie-zaprosov-k-serveru">     </h2><br><p>    ,     ,        .  : </p><br><ul><li>       - <code>&lt;Class&gt;</code> . <code>&lt;Method&gt;</code> =&gt; <code>&lt;Time&gt;</code> (  ). </li><li>       . </li><li>        . </li></ul><br><h2 id="desert">  </h2><br><p> ,    ,           ,    .        ?         ?  : </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GraphController</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ILockTarget</span></span></span><span class="hljs-class"> </span></span>{ private View: IView; public GetControllerView(): IView { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.View; } <span class="hljs-comment"><span class="hljs-comment">/**     . */</span></span> @Lock private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> RunBigDataCalculations(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Start(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UpdateSmth(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> End(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> CleanUp(); } <span class="hljs-comment"><span class="hljs-comment">/**   . */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnChangeNodeState(node: INode): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> GetNodeData(node); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UpdateNode(node); } }</code> </pre><br><p>   : </p><br><ol><li>  <code>RunBigDataCalculations</code> . </li><li>  <code>await Start();</code> </li><li>   /  (  ) </li><li>   <code>await Start();</code> ,   <code>await UpdateSmth();</code>      . </li></ol><br><p>  Oder: </p><br><ol><li>  <code>RunBigDataCalculations</code> . </li><li>    <code>OnChangeNodeState</code> ,          (..  ). </li><li>   <code>await GetNodeData(node);</code> </li><li>   /  (  ) </li><li>   <code>await GetNodeData(node);</code> ,   <code>await UpdateNode(node);</code>      . </li></ol><br><p>      - .  : </p><br><ul><li>   : </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *       ,      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface IQueuedDisposableLockTarget extends ILockTarget { <span class="hljs-comment"><span class="hljs-comment">/**     . Lock          IsDisposing() === true */</span></span> IsDisposing(): boolean; SetDisposing(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; }</code> </pre> <br><ul><li>        : </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QueuedDispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">controller: IQueuedDisposableLockTarget</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      let xQueue = GetQueue(controller); // 1. ,     -,   -   if (xQueue.Empty) { controller.Dispose(); return; } // 2.  ,     " ",     ,   . controller.SetDisposing(); // 3.   finally   xQueue.finally(() =&gt; { debug.assert(!IsDisposed(controller), "-      ,  "); controller.Dispose(); }); }</span></span></code> </pre><br><p>  ,          .    <code>QueuedDispose</code>     : </p><br><ul><li>         .       . </li><li>   <code>QueuedDispose</code>     <code>controller</code> .         ‚Äî  ExtJS     . </li></ul><br><p> <strong></strong> </p><br><p>  ,          , ..         . ,      ?    ,  . </p><br><p>    ,      : </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    vk.com</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    Telegram</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464773/">https://habr.com/ru/post/de464773/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464759/index.html">Dutzende agiler B√ºcher, die der Projektmanager 2020 ben√∂tigen wird</a></li>
<li><a href="../de464761/index.html">Ein kleiner Mod verwandelt Tesla in eine Video√ºberwachungsstation</a></li>
<li><a href="../de464763/index.html">Benchmarks f√ºr Server unter Linux: eine Auswahl offener Tools</a></li>
<li><a href="../de464765/index.html">FreePBX + GoIP konfigurieren</a></li>
<li><a href="../de464769/index.html">Wie Badoo es m√∂glich machte, 200.000 Fotos pro Sekunde auszugeben</a></li>
<li><a href="../de464775/index.html">21. September Badoo PHP Meetup # 3: Leistung</a></li>
<li><a href="../de464777/index.html">Warum beschleunigt const C / C ++ - Code nicht?</a></li>
<li><a href="../de464779/index.html">√úber hedonistische Bienen, die Art und Weise, wie Menschen sie arbeiten lassen, und Drohnen</a></li>
<li><a href="../de464781/index.html">Smart-TVs: CRT zu HDR</a></li>
<li><a href="../de464785/index.html">Nicht wettbewerbsf√§hige Beeline-Vorteile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>