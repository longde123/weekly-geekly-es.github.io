<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úä üëäüèª ü§º Kenalan dengan elemen lit-dan komponen web berdasarkan itu üî∞ üßëüèø‚Äçü§ù‚Äçüßëüèæ üë®‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada satu titik saya harus segera berkenalan dengan komponen web dan menemukan cara untuk mengembangkannya dengan mudah. Saya berencana untuk menulis ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kenalan dengan elemen lit-dan komponen web berdasarkan itu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445438/"><p>  Pada satu titik saya harus segera berkenalan dengan komponen web dan menemukan cara untuk mengembangkannya dengan mudah.  Saya berencana untuk menulis serangkaian artikel yang akan <br>  entah bagaimana mengatur pengetahuan komponen web, elemen lit dan memberikan pengantar singkat tentang teknologi ini untuk orang lain. <a name="habracut"></a>  Saya bukan ahli dalam teknologi ini dan dengan senang hati akan menerima umpan balik. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lit-element</a> adalah pembungkus (template dasar) untuk komponen web asli.  Ini mengimplementasikan banyak metode mudah yang tidak ada dalam spesifikasi.  Karena kedekatannya dengan implementasi asli, lit-elemen menunjukkan hasil yang sangat baik dalam berbagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tolok ukur</a> relatif terhadap pendekatan lain (pada 02/06/2019). </p><br><p>  Bonus yang saya lihat dari penggunaan elemen-lit sebagai kelas dasar komponen web: </p><br><ol><li>  Teknologi ini sudah mengimplementasikan versi kedua dan "sakit dengan penyakit anak-anak", yang khas pada instrumen yang baru saja muncul. </li><li>  Perakitan dapat dilakukan baik polimer, dan webpack, naskah, rollup, dll., Ini memungkinkan Anda untuk menanamkan elemen lit dalam setiap proyek modern tanpa masalah. </li><li>  Elemen lit memiliki sistem yang sangat nyaman untuk bekerja dengan properti dalam hal mengetik, menginisiasi dan mengonversi nilai. </li><li>  elemen lit mengimplementasikan logika yang hampir sama dengan reaksi, mis.  ia menyediakan sangat minimum - satu templat untuk membangun komponen dan renderingnya dan tidak membatasi pengembang dalam memilih ekosistem dan perpustakaan tambahan. </li></ol><br><p>  Buat komponen web sederhana pada elemen-lit.  Mari kita beralih ke dokumentasi.  Kami membutuhkan yang berikut: </p><br><ol><li>  Tambahkan paket npm dengan elemen lit ke perakitan kami <br><br><pre><code class="plaintext hljs">npm install --save lit-element</code> </pre> </li><li>  Buat komponen kami. </li></ol><br><p>  Sebagai contoh, kita perlu membuat komponen web yang diinisialisasi dalam tag <code>my-component</code> .  Untuk melakukan ini, buat file js <code>my-component.js</code> dan tentukan template dasarnya: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       lit-element import { } from ''; //      class MyComponent { } //      customElements.define();</span></span></code> </pre><br><p>  Pertama, kami mengimpor template dasar kami: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LitElement, html } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// LitElement -    ()   - // html -  lit-html,     ,  //    html   </span></span></code> </pre><br><p>  Kedua, buat komponen web itu sendiri menggunakan <code>LitElement</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    //  LitElement    HTMLElement class MyComponent extends LitElement { //    LitElement   //      constructor  connectedCallback //           //    ,       // shadowDOM   {mode: 'open'} render() { return html`&lt;p&gt;Hello World!&lt;/p&gt;` } }</span></span></code> </pre><br><p>  Dan yang terakhir adalah mendaftarkan komponen web di browser </p><br><pre> <code class="javascript hljs">customElements.define(<span class="hljs-string"><span class="hljs-string">'my-component'</span></span>, MyComponent);</code> </pre><br><p>  Hasilnya, kami mendapatkan yang berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LitElement, html } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">`&lt;p&gt;Hello World!&lt;/p&gt;`</span></span> } } customElements.define(<span class="hljs-string"><span class="hljs-string">'my-component'</span></span>, MyComponent);</code> </pre><br><p>  Jika Anda mengecualikan kebutuhan untuk menghubungkan <code>my-component.js</code> ke html, maka itu saja.  Komponen paling sederhana sudah siap. </p><br><p>  Saya mengusulkan untuk tidak menemukan kembali roda dan mengambil perakitan selesai lit-elemen-build-rollup.  Ikuti instruksi: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/PolymerLabs/lit-element-build-rollup.git cd lit-element-build-rollup npm install npm run build npm run start</code> </pre><br><p>  Setelah semua perintah selesai, kita pergi ke halaman di browser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http: // localhost: 5000 /</a> . </p><br><p>  Jika kita melihat dalam html, kita akan melihat bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">webcomponents-loader.js</a> ada di depan tag penutup.  Ini adalah seperangkat polyfill untuk komponen web, dan untuk operasi lintas-browser dari komponen web itu diinginkan bahwa polyfill ini ada.  Mari kita lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tabel browser</a> yang menerapkan semua standar untuk bekerja dengan komponen web, ia mengatakan bahwa EDGE masih belum sepenuhnya menerapkan standar (saya diam tentang IE11, yang masih harus didukung). </p><br><img src="https://habrastorage.org/webt/q1/g2/6w/q1g26wcj65en1zl0z0d4d2ar67c.png"><br><p>  Diimplementasikan 2 opsi untuk polyfill ini: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">webcomponents-bundle.js</a> - versi ini berisi semua opsi yang memungkinkan untuk polyfill, semuanya dimulai, tetapi setiap polyfill hanya akan bekerja berdasarkan tanda-tanda yang terdeteksi. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">webcomponents-loader.js</a> adalah bootloader minimal yang, berdasarkan gejala yang terdeteksi, memuat polyfill yang diperlukan </li></ol><br><p>  Saya juga meminta Anda untuk memperhatikan polyfill lain - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">custom-elements-es5-adapter.js</a> .  Menurut spesifikasi, hanya kelas ES6 yang dapat ditambahkan ke customElements.define asli.  Untuk kinerja terbaik, kode ES6 harus diteruskan hanya ke browser yang mendukungnya, dan ES5 untuk semua orang.  Ini tidak selalu mungkin dilakukan, oleh karena itu, untuk kompatibilitas lintas-browser yang lebih baik, disarankan agar semua kode ES6 dikonversi ke ES5.  Tetapi dalam hal ini, komponen web pada ES5 tidak akan dapat bekerja di browser.  Untuk mengatasi masalah ini, ada custom-elements-es5-adapter.js. </p><br><p>  Sekarang mari kita buka file <code>./src/my-element.js</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html, LitElement, property} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// @property - ,    babel  ts //         //  ,   @property({type: String}) myProp = 'stuff'; render() { return html` &lt;p&gt;Hello World&lt;/p&gt; ${this.myProp} `; } } customElements.define('my-element', MyElement);</span></span></code> </pre><br><p>  Mesin template lit-html dapat memproses string secara berbeda.  Saya akan memberi Anda beberapa opsi: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  : html`&lt;div&gt;Hi&lt;/div&gt;` // : html`&lt;div&gt;${this.disabled ? 'Off' : 'On'}&lt;/div&gt;` // : html`&lt;x-foo .bar="${this.bar}"&gt;&lt;/x-foo&gt;` // : html`&lt;div class="${this.color} special"&gt;&lt;/div&gt;` //   boolean,  checked === false, //        HTML: html`&lt;input type="checkbox" ?checked=${checked}&gt;` //  : html`&lt;button @click="${this._clickHandler}"&gt;&lt;/button&gt;`</span></span></code> </pre><br><p>  Kiat untuk mengoptimalkan fungsi render (): </p><br><ul><li>  tidak boleh mengubah status elemen, </li><li>  seharusnya tidak memiliki efek samping, </li><li>  seharusnya hanya bergantung pada properti elemen, </li><li>  harus mengembalikan hasil yang sama saat mentransmisikan nilai yang sama. </li></ul><br><p>  Jangan perbarui DOM di luar fungsi render (). </p><br><p>  Lit-html bertanggung jawab untuk merender elemen-lit - ini adalah cara deklaratif untuk menggambarkan bagaimana komponen web harus ditampilkan.  lit-html menjamin pembaruan cepat dengan hanya mengubah bagian-bagian DOM yang perlu diubah. </p><br><p>  Hampir semua kode ini dalam contoh sederhana, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dekorator</a> <code>@property</code> properti ditambahkan untuk properti <code>myProp</code> .  Dekorator ini menunjukkan bahwa kami mengharapkan atribut bernama <code>myprop</code> di <code>my-element</code> .  Jika tidak ada atribut yang ditetapkan, nilai string diatur ke <code>stuff</code> secara default. </p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--  myProp  ,       -   'stuff' --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  myprop         lowerCamelCase .. myProp   -      'else' --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">myprop</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"else"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><p>  elemen lit menyediakan 2 cara untuk bekerja dengan <code>property</code> : </p><br><ol><li>  Melalui dekorator. </li><li>  Melalui <code>properties</code> pengambil statis. </li></ol><br><p>  Opsi pertama memungkinkan untuk menentukan setiap properti secara terpisah: </p><br><pre> <code class="javascript hljs">@property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}) prop1 = <span class="hljs-string"><span class="hljs-string">''</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>}) prop2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>}) prop3 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>}) prop4 = []; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>}) prop5 = {};</code> </pre><br><p>  Yang kedua adalah menentukan segalanya di satu tempat, tetapi dalam kasus ini, jika properti memiliki nilai default, itu harus ditulis dalam metode konstruktor kelas: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get properties() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">prop1</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop2</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop3</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop4</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop5</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>} }; } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop1 = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop3 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop4 = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop5 = {}; }</code> </pre><br><p>  API untuk bekerja dengan properti dalam elemen lit cukup luas: </p><br><ul><li>  <b>atribut</b> : apakah suatu properti dapat menjadi atribut yang dapat diamati.  Jika <code>false</code> , maka atribut akan dikeluarkan dari pengamatan, tidak ada pengambil akan dibuat untuk itu.  Jika <code>true</code> atau <code>attribute</code> ada, maka properti yang ditentukan dalam pengambil dalam format lowerCamelCase akan sesuai dengan atribut dalam format string.  Jika sebuah string ditentukan, misalnya <code>my-prop</code> , maka string tersebut akan sesuai dengan nama yang sama dalam atribut. </li><li>  <b>konverter</b> : berisi deskripsi tentang cara mengkonversi nilai dari / ke atribut / properti.  Nilai dapat berupa fungsi yang berfungsi untuk membuat cerita bersambung dan membatalkan nilai, atau dapat berupa objek dengan kunci <code>toAttribute</code> dan <code>toAttribute</code> , kunci ini berisi fungsi terpisah untuk mengonversi nilai.  Secara default, properti berisi konversi ke tipe dasar <code>Boolean</code> , <code>String</code> , <code>Number</code> , <code>Object</code> dan <code>Array</code> .  Aturan konversi tercantum di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </li><li>  <b>type</b> : menunjukkan salah satu tipe dasar yang akan dimiliki properti ini.  Ini digunakan sebagai "petunjuk" untuk konverter tentang jenis properti yang seharusnya mengandung. </li><li>  <b>mencerminkan</b> : menunjukkan apakah atribut harus dikaitkan dengan properti ( <code>true</code> ) dan diubah sesuai dengan aturan dari <code>type</code> dan <code>converter</code> . </li><li>  <b>hasChanged</b> : masing-masing properti memilikinya, berisi fungsi yang menentukan apakah ada perubahan antara nilai lama dan baru, masing-masing mengembalikan <code>Boolean</code> .  Jika <code>true</code> , itu mulai memperbarui item. </li><li>  <b>noAccessor</b> : properti ini menerima <code>Boolean</code> dan default ke <code>false</code> .  Ini melarang generasi getter dan setter untuk setiap properti untuk mengaksesnya dari kelas.  Ini tidak membatalkan konversi. </li></ul><br><p>  Mari kita membuat contoh hipotetis: kita akan menulis komponen web yang berisi parameter yang berisi string, kata ini harus digambar di layar, di mana setiap huruf lebih besar dari yang sebelumnya. <br></p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- index.html --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ladder-of-letters</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">letters</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">""</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ladder-of-letters</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//ladder-of-letters.js import {html, LitElement, property} from 'lit-element'; class LadderOfLetters extends LitElement { @property({ type: Array, converter: { fromAttribute: (val) =&gt; { // console.log('in fromAttribute', val); return val.split(''); } }, hasChanged: (value, oldValue) =&gt; { if(value === undefined || oldValue === undefined) { return false; } // console.log('in hasChanged', value, oldValue.join('')); return value !== oldValue; }, reflect: true }) letters = []; changeLetter() { this.letters = ['','','','','']; } render() { // console.log('in render', this.letters); //    ,    //        return html` &lt;div&gt;${this.letters.map((i, idx) =&gt; html`&lt;span style="font-size: ${idx + 2}em"&gt;${i}&lt;/span&gt;`)}&lt;/div&gt; // @click     ,     //   'click'    &lt;button @click=${this.changeLetter}&gt;  ''&lt;/button&gt; `; } } customElements.define('ladder-of-letters', LadderOfLetters);</span></span></code> </pre><br><p>  pada akhirnya kita dapatkan: </p><br><img src="https://habrastorage.org/webt/fu/jt/ka/fujtka5wih6jghe9wfdwktv8pqw.png"><br><p>  ketika tombol diklik, properti diubah, yang menyebabkan cek pertama, dan kemudian dikirim untuk menggambar ulang. </p><br><img src="https://habrastorage.org/webt/sx/wi/bs/sxwibswpdvdynof2p9adjxt2ysq.png"><br><p>  dan menggunakan <code>reflect</code> kita juga bisa melihat perubahan html </p><br><img src="https://habrastorage.org/webt/z1/oy/i9/z1oyi9lbcznkigdcmr7acffgsca.png"><br><p>  Jika Anda mengubah atribut ini dengan kode di luar komponen web ini, kami juga akan menyebabkan redraw komponen web. </p><br><p>  Sekarang perhatikan styling komponen.  Kami memiliki 2 cara untuk gaya elemen lit: </p><br><ol><li>  Styling dengan menambahkan tag gaya ke metode render <br><br><pre> <code class="javascript hljs">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">` &lt;style&gt; p { color: green; } &lt;/style&gt; &lt;p&gt;Hello World&lt;/p&gt; `</span></span>; }</code> </pre><br><img src="https://habrastorage.org/webt/6r/70/ba/6r70bawofzxkhbtbx8pif2fu_au.png"><br></li><li>  Melalui <code>styles</code> pengambil statis <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html, LitElement, css} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get styles() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ css<span class="hljs-string"><span class="hljs-string">` p { color: red; } `</span></span> ]; } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">` &lt;p&gt;Hello World&lt;/p&gt; `</span></span>; } } customElements.define(<span class="hljs-string"><span class="hljs-string">'my-element'</span></span>, MyElement);</code> </pre><br></li></ol><br><p>  Akibatnya, kami mendapatkan bahwa tag dengan gaya tidak dibuat, tetapi ditulis ( <code>&gt;= Chrome 73</code> ) di <code>Shadow DOM</code> elemen sesuai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi</a> .  Ini meningkatkan kinerja dengan sejumlah besar elemen, karena  ketika mendaftarkan komponen baru, dia sudah tahu sifat apa yang ditentukan gayanya, mereka tidak perlu didaftarkan setiap waktu dan diceritakan kembali. </p><br><img src="https://habrastorage.org/webt/tc/ew/rs/tcewrs9bnnmopzuprmi3kgapbam.png"><br><br><p>  Selain itu, jika spesifikasi ini tidak didukung, maka tag <code>style</code> reguler dibuat di komponen. </p><br><img src="https://habrastorage.org/webt/ah/kl/9h/ahkl9hm7c8wmkevk8fctarpkdao.png"><br><br><p>  Plus, jangan lupa bahwa dengan cara ini kita juga dapat memisahkan gaya mana yang akan ditambahkan dan dihitung pada halaman.  Misalnya, untuk menggunakan kueri media tidak dalam css, tetapi di JS dan hanya menerapkan gaya yang diinginkan, misalnya (ini liar, tetapi harus): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get styles() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mobileStyle = css<span class="hljs-string"><span class="hljs-string">`p { color: red; }`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> desktopStyle = css<span class="hljs-string"><span class="hljs-string">`p { color: green; }`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.matchMedia(<span class="hljs-string"><span class="hljs-string">"(min-width: 400px)"</span></span>).matches ? desktopStyle : mobileStyle ]; }</code> </pre><br><p>  Dengan demikian, kita akan melihat ini jika pengguna masuk ke perangkat dengan lebar layar lebih dari 400px. </p><br><img src="https://habrastorage.org/webt/k5/cu/it/k5cuitrmqpwb-76qid-1qamtpuw.png"><br><p>  Dan ini adalah jika pengguna mengunjungi situs dari perangkat dengan lebar kurang dari 400px. </p><br><img src="https://habrastorage.org/webt/z-/jy/jw/z-jyjw7canilafm3cmsjfuxtv6g.png"><br><p>  Pendapat saya: praktis tidak ada kasus yang memadai ketika pengguna, bekerja pada perangkat mobile, tiba-tiba menghadapi monitor penuh dengan lebar layar 1920px.  Tambahkan ke ini pemuatan komponen yang malas.  Hasilnya, kami mendapatkan bagian depan yang sangat optimal dengan rendering komponen yang cepat.  Satu-satunya masalah adalah kesulitan dalam mendukung. </p><br><p>  Sekarang saya mengusulkan untuk berkenalan dengan metode siklus hidup elemen lit: </p><br><ul><li>  <b>render ()</b> : mengimplementasikan deskripsi elemen DOM menggunakan <code>lit-html</code> .  Idealnya, fungsi <code>render</code> adalah fungsi murni yang hanya menggunakan properti elemen saat ini.  Metode <code>render()</code> dipanggil oleh fungsi <code>update()</code> . </li><li>  <b>shouldUpdate (changedProperties)</b> : diimplementasikan jika perlu untuk mengontrol pembaruan dan rendering, ketika properti diubah atau <code>requestUpdate()</code> dipanggil.  Argumen ke fungsi <code>changedProperties</code> adalah <code>Map</code> berisi kunci untuk properti yang diubah.  Secara default, metode ini selalu mengembalikan <code>true</code> , tetapi logika metode ini dapat diubah untuk mengontrol pembaruan komponen. </li><li>  <b>performUpdate ()</b> : diterapkan untuk mengontrol waktu pembaruan, misalnya, untuk berintegrasi dengan penjadwal. </li><li>  <b>pembaruan (ubahProperti)</b> : metode ini memanggil <code>render()</code> .  Itu juga memperbarui atribut elemen sesuai dengan nilai properti.  Mengatur properti di dalam metode ini tidak akan menyebabkan pembaruan lain. </li><li>  <b>firstUpdated (changedProperties)</b> : dipanggil setelah pembaruan pertama elemen DOM segera sebelum panggilan yang <code>updated()</code> .  Metode ini dapat berguna untuk mengambil tautan ke simpul statis yang divisualisasikan yang perlu Anda kerjakan secara langsung, misalnya, dalam <code>updated()</code> . </li><li>  <b>updated (changedProperties)</b> : dipanggil setiap kali DOM item diperbarui dan ditampilkan.  Implementasi untuk melakukan tugas setelah memperbarui melalui DOM API, misalnya, berfokus pada elemen. </li><li>  <b>requestUpdate (name, oldValue)</b> : <b>mengaktifkan</b> permintaan pembaruan asinkron untuk suatu item.  Ini harus dipanggil ketika item perlu diperbarui berdasarkan beberapa negara bukan disebabkan oleh pengaturan properti. </li><li>  <b>createRenderRoot ()</b> : secara default membuat Shadow Root untuk item.  Jika penggunaan Shadow DOM tidak diperlukan, maka metode harus mengembalikan <code>this</code> . </li></ul><br><p>  Bagaimana cara pembaruan elemen: </p><br><ul><li>  Properti diberi nilai baru. </li><li>  Jika properti <code>hasChanged(value, oldValue)</code> mengembalikan <code>false</code> , item tidak diperbarui.  Kalau tidak, pembaruan direncanakan dengan memanggil <code>requestUpdate()</code> . </li><li>  <b>requestUpdate ()</b> : memperbarui elemen setelah microtask (di akhir loop acara dan sebelum redraw berikutnya). </li><li>  <b>performUpdate ()</b> : pembaruan sedang berlangsung, dan berlanjut dengan sisa pembaruan API. </li><li>  <b>shouldUpdate (changedProperties)</b> : pembaruan berlanjut jika <code>true</code> dikembalikan. </li><li>  <b>firstUpdated (berubahProperti)</b> : dipanggil saat item diperbarui untuk pertama kalinya, segera sebelum menelepon <code>updated()</code> . </li><li>  <b>perbarui (ubahProperti)</b> : memperbarui item.  Mengubah properti dalam metode ini tidak menyebabkan pembaruan lain. <br><ul><li>  <b>render ()</b> : mengembalikan template <code>lit-html</code> untuk merender elemen dalam DOM.  Mengubah properti dalam metode ini tidak menyebabkan pembaruan lain. </li></ul><br></li><li>  <b>updated (changedProperties)</b> : dipanggil setiap kali suatu item diperbarui. </li></ul><br><p>  Untuk memahami semua nuansa siklus hidup komponen, saya sarankan Anda untuk membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . </p><br><p>  Di tempat kerja, saya memiliki proyek pada adobe experience manager (AEM), dalam pembuatannya pengguna dapat menyeret dan melepaskan komponen ke halaman, dan menurut ideologi AEM, komponen ini berisi tag <code>script</code> yang berisi semua yang diperlukan untuk mengimplementasikan logika komponen ini.  Namun pada kenyataannya, pendekatan ini memunculkan banyak sumber daya yang menghalangi dan kesulitan dengan implementasi front dalam sistem ini.  Untuk mengimplementasikan bagian depan, komponen web dipilih sebagai cara untuk tidak mengubah rendering sisi server (yang ia lakukan dengan sangat baik), serta untuk memperkaya implementasi lama dengan pendekatan baru dengan lembut, bitwise.  Menurut pendapat saya, ada beberapa opsi untuk menerapkan pemuatan komponen web untuk sistem ini: kumpulkan bundel (dapat menjadi sangat besar) atau pecah menjadi beberapa bagian (banyak file kecil, pemuatan dinamis diperlukan), atau gunakan pendekatan saat ini dengan menyematkan skrip di setiap komponen yang diberikan di sisi server (saya benar-benar tidak ingin kembali ke ini).  Menurut saya, opsi pertama dan ketiga bukanlah opsi.  Untuk yang kedua, Anda memerlukan bootloader dinamis, seperti pada stensil.  Tetapi untuk elemen lit dalam "kotak" ini tidak disediakan.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">upaya</a> dari pengembang elemen lit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk membuat loader dinamis</a> , tetapi ini adalah percobaan, dan tidak disarankan untuk menggunakannya dalam produksi.  Juga dari pengembang elemen lit ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah</a> dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori spesifikasi komponen web</a> dengan proposal untuk menambah spesifikasi kemampuan untuk secara dinamis memuat js yang diperlukan untuk komponen web berdasarkan markup html pada halaman.  Dan, menurut pendapat saya, alat asli ini adalah ide yang sangat bagus yang akan memungkinkan Anda untuk membuat satu titik inisialisasi komponen web dan cukup menambahkannya ke semua halaman situs. </p><br><p>  Untuk memuat komponen web elemen lit secara dinamis dengan orang-orang PolymerLabs, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">elemen-split</a> dikembangkan.  Ini adalah solusi eksperimental.  Ini bekerja dengan cara berikut: </p><br><ul><li>  Untuk membuat SplitElement, Anda menulis dua definisi elemen dalam dua modul. </li><li>  Salah satunya adalah sebuah rintisan, yang mendefinisikan bagian-bagian yang dimuat dari suatu elemen: biasanya ini adalah nama dan properti.  Properti harus didefinisikan dengan sebuah rintisan sehingga elemen-lit dapat menghasilkan atribut yang dapat diamati secara tepat waktu untuk memanggil <code>customElements.define()</code> . </li><li>  Stub juga harus memiliki metode beban asinkron statis yang mengembalikan kelas implementasi. </li><li>  Kelas lain adalah "implementasi", yang berisi segalanya. </li><li>  Konstruktor <code>SplitElement</code> memuat kelas implementasi dan menjalankan <code>upgrade()</code> . </li></ul><br><p>  Contoh rintisan: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SplitElement, property} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../split-element.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// MyElement    load   //      connectedCallback()   static async load() { //        //      MyElement return (await import('./my-element-impl.js')).MyElementImpl; } //      //   - @property() message: string; } customElements.define('my-element', MyElement);</span></span></code> </pre><br><p>  Contoh Implementasi: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {MyElement} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./my-element.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../split-element.js'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// MyElementImpl  render    - export class MyElementImpl extends MyElement { render() { return html` &lt;h1&gt;I've been upgraded&lt;/h1&gt; My message is ${this.message}. `; } }</span></span></code> </pre><br><p>  Contoh SplitElement pada ES6: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {LitElement, html} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    LitElement  SplitElement //       export class SplitElement extends LitElement { static load; static _resolveLoaded; static _rejectLoaded; static _loadedPromise; static implClass; static loaded() { if (!this.hasOwnProperty('_loadedPromise')) { this._loadedPromise = new Promise((resolve, reject) =&gt; { this._resolveLoaded = resolve; this._rejectLoaded = reject; }); } return this._loadedPromise; } //      - //      static _upgrade(element, klass) { SplitElement._upgradingElement = element; Object.setPrototypeOf(element, klass.prototype); new klass(); SplitElement._upgradingElement = undefined; element.requestUpdate(); if (element.isConnected) { element.connectedCallback(); } } static _upgradingElement; constructor() { if (SplitElement._upgradingElement !== undefined) { return SplitElement._upgradingElement; } super(); const ctor = this.constructor; if (ctor.hasOwnProperty('implClass')) { //   ,   ctor._upgrade(this, ctor.implClass); } else { //    if (typeof ctor.load !== 'function') { throw new Error('A SplitElement must have a static `load` method'); } (async () =&gt; { ctor.implClass = await ctor.load(); ctor._upgrade(this, ctor.implClass); })(); } } //       render() { return html``; } }</span></span></code> </pre><br><p>  Jika Anda masih menggunakan rakitan yang disarankan di atas pada Rollup, pastikan untuk mengatur babel agar dapat menangani impor dinamis </p><br><pre> <code class="plaintext hljs">npm install @babel/plugin-syntax-dynamic-import</code> </pre> <br><p>  Dan dalam pengaturan .babelrc tambahkan </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"plugins"</span></span>: [<span class="hljs-string"><span class="hljs-string">"@babel/plugin-syntax-dynamic-import"</span></span>] }</code> </pre><br><p>  Di sini saya membuat contoh kecil implementasi komponen web dengan pemuatan yang tertunda: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/malay76a/elbrus-split-litelement-web-components</a> </p><br><p>  Saya mencoba menerapkan pendekatan pemuatan dinamis komponen web, sampai pada kesimpulan berikut: alat ini cukup berfungsi, Anda perlu mengumpulkan semua definisi komponen web dalam satu file, dan menghubungkan deskripsi komponen itu sendiri melalui potongan secara terpisah.  Tanpa http2, pendekatan ini tidak berfungsi, karena  Kumpulan besar file-file kecil yang menggambarkan komponen terbentuk.  Berdasarkan prinsip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">desain atom</a> , impor atom harus ditentukan dalam tubuh, tetapi tubuh harus sudah terhubung sebagai komponen terpisah.  Salah satu hambatannya adalah bahwa pengguna akan menerima banyak definisi elemen pengguna di browser yang akan diinisialisasi dengan satu atau lain cara di browser dan keadaan awal akan ditentukan.  Solusi semacam itu berlebihan.  Salah satu opsi untuk solusi sederhana untuk pemuat komponen adalah algoritma berikut: </p><br><ol><li>  memuat utilitas yang diperlukan, </li><li>  memuat polyfill, </li><li>  merakit elemen khusus dari DOM cahaya: <br><ol><li>  semua elemen DOM yang mengandung tanda hubung dalam nama tag dipilih </li><li>  daftar disaring dan daftar dibentuk dari elemen pertama. </li></ol></li><li>       : <br><ol><li>    Intersection Observer, </li><li>        +- 100px      import. </li></ol></li><li><ol><li>     3       shadowDOM, </li><li>  ,   shadowDOM  ,     ,  import   JS. </li></ol><br></li></ol><br><p>      -  lit-element        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">open-wc.org</a> .        webpack  rollup,    -      storybook,          IDE. </p><br><h2>  : </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Let's Build Web Components! Part 5: LitElement</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Web Component Essentials</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">A night experimenting with Lit-HTML‚Ä¶</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LitElement To Do App</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LitElement app tutorial part 1: Getting started</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LitElement tutorial part 2: Templating, properties, and events</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LitElement tutorial part 3: State management with Redux</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LitElement tutorial part 4: Navigation and code splitting</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LitElement tutorial part 5: PWA and offline</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lit-html workshop</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Awesome lit-html</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445438/">https://habr.com/ru/post/id445438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445426/index.html">Optimalisasi untuk aplikasi Rails yang melayani PostgreSQL</a></li>
<li><a href="../id445428/index.html">Wi-Fi berkualitas tinggi - dasar keramahtamahan modern dan mesin bisnis</a></li>
<li><a href="../id445432/index.html">Manajer Paket Persatuan</a></li>
<li><a href="../id445434/index.html">Pekerjaan Terburuk Terbaik di Dunia: Mencari Habraautor</a></li>
<li><a href="../id445436/index.html">Pelatihan ulang di DevOps - untuk apa Anda mempersiapkan diri</a></li>
<li><a href="../id445440/index.html">Ulasan kode: tips buruk untuk kontributor dan peninjau</a></li>
<li><a href="../id445444/index.html">Pembaruan Modul Surya Berkinerja Tinggi dari REC dan Trina (Solar)</a></li>
<li><a href="../id445446/index.html">Bagaimana kami menggunakan replikasi yang ditangguhkan untuk pemulihan bencana dengan PostgreSQL</a></li>
<li><a href="../id445448/index.html">Mengkonfigurasi penerimaan otomatis sertifikat allowencrypt menggunakan buruh pelabuhan di linux</a></li>
<li><a href="../id445450/index.html">Ekstensi browser untuk toster.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>