<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§í üçû üë®‚Äçüë®‚Äçüëß‚Äçüëß Compreendendo a assincronia em JavaScript [Tradu√ß√£o de Sukhjinder Arora] üí± üçµ ‚ñ´Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Apresento a voc√™ a tradu√ß√£o do artigo ‚ÄúEntendendo o JavaScript Ass√≠ncrono‚Äù de Sukhjinder Arora. 



 Do autor da tradu√ß√£o: Espero que a trad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compreendendo a assincronia em JavaScript [Tradu√ß√£o de Sukhjinder Arora]</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439620/">  Ol√° Habr!  Apresento a voc√™ a tradu√ß√£o do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúEntendendo o JavaScript Ass√≠ncrono‚Äù</a> de Sukhjinder Arora. <br><br><img src="https://habrastorage.org/webt/78/ss/a1/78ssa15sg7wxe0nukoyfnjgopao.jpeg"><br><a name="habracut"></a><br>  <i>Do autor da tradu√ß√£o: Espero que a tradu√ß√£o deste artigo ajude voc√™ a se familiarizar com algo novo e √∫til.</i>  <i>Se o artigo o ajudou, n√£o seja pregui√ßoso e agrade√ßa ao autor do original.</i>  <i>N√£o pretendo ser um tradutor profissional, estou apenas come√ßando a traduzir artigos e ficarei feliz em receber algum feedback significativo.</i> <br><br>  JavaScript √© uma linguagem de programa√ß√£o de thread √∫nico na qual apenas uma coisa pode ser executada por vez.  Ou seja, em um √∫nico encadeamento, o mecanismo JavaScript pode processar apenas uma instru√ß√£o por vez. <br><br>  Embora os idiomas de thread √∫nico facilitem a escrita do c√≥digo, j√° que voc√™ n√£o precisa se preocupar com problemas de simultaneidade, isso tamb√©m significa que voc√™ n√£o poder√° executar opera√ß√µes longas, como acessar a rede sem bloquear o segmento principal. <br><br>  Envie uma solicita√ß√£o de API para alguns dados.  Dependendo da situa√ß√£o, o servidor pode levar algum tempo para processar sua solicita√ß√£o, enquanto a execu√ß√£o do fluxo principal ser√° bloqueada, devido ao qual sua p√°gina da web deixar√° de responder √†s solicita√ß√µes. <br><br>  √â aqui que a assincronia do JavaScript entra em cena.  Usando a assincronia JavaScript (retornos de chamada, promessas e ass√≠ncrono / espera), voc√™ pode executar solicita√ß√µes de rede longas sem bloquear o segmento principal. <br><br>  Embora n√£o seja necess√°rio aprender todos esses conceitos para ser um bom desenvolvedor de JavaScript, √© √∫til conhec√™-los. <br><br>  Ent√£o, sem mais delongas, vamos come√ßar. <br><br><h2>  Como funciona o javascript s√≠ncrono? </h2><br>  Antes de come√ßarmos o trabalho do JavaScript ass√≠ncrono, vamos primeiro entender como o c√≥digo s√≠ncrono √© executado dentro do mecanismo JavaScript.  Por exemplo: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello there!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hi there!'</span></span>); second(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The End'</span></span>); } first();</code> </pre> <br>  Para entender como o c√≥digo acima √© executado dentro do mecanismo JavaScript, precisamos entender o conceito do contexto de execu√ß√£o e a pilha de chamadas (tamb√©m conhecida como pilha de execu√ß√£o). <br><br><h3>  Contexto de execu√ß√£o </h3><br>  O contexto de execu√ß√£o √© um conceito abstrato do ambiente no qual o c√≥digo √© avaliado e executado.  Sempre que qualquer c√≥digo √© executado em JavaScript, ele √© executado no contexto de execu√ß√£o. <br><br>  O c√≥digo da fun√ß√£o √© executado dentro do contexto de execu√ß√£o da fun√ß√£o e o c√≥digo global, por sua vez, √© executado dentro do contexto de execu√ß√£o global.  Cada fun√ß√£o tem seu pr√≥prio contexto de execu√ß√£o. <br><br><h3>  Pilha de chamadas </h3><br>  Uma pilha de chamadas √© uma pilha com uma estrutura LIFO (Last in, First Out, first used), usada para armazenar todos os contextos de execu√ß√£o criados durante a execu√ß√£o do c√≥digo. <br><br>  O JavaScript possui apenas uma pilha de chamadas, pois √© uma linguagem de programa√ß√£o de thread √∫nico.  A estrutura LIFO significa que os elementos s√≥ podem ser adicionados e removidos da parte superior da pilha. <br><br>  Vamos agora voltar ao snippet de c√≥digo acima e tentar entender como o mecanismo JavaScript o executa. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello there!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hi there!'</span></span>); second(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The End'</span></span>); } first();</code> </pre> <br><img src="https://habrastorage.org/webt/mq/bn/_d/mqbn_dfda1fmgpqrdq48jk7zhcy.png"><br><br><h3>  Ent√£o o que aconteceu aqui? </h3><br>  Quando o c√≥digo come√ßou a ser executado, um contexto de execu√ß√£o global foi criado (representado como <i>main ()</i> ) e adicionado √† parte superior da pilha de chamadas.  Quando a chamada para a <i>primeira</i> fun√ß√£o <i>()</i> √© encontrada, ela tamb√©m √© adicionada ao topo da pilha. <br><br>  Em seguida, <i>console.log ('Ol√°!') √â</i> colocado na parte superior da pilha de chamadas, ap√≥s a execu√ß√£o √© removido da pilha.  Depois disso, chamamos a <i>segunda</i> fun√ß√£o <i>()</i> , para que ela seja colocada no topo da pilha. <br><br>  <i>O console.log ('Ol√°!') √©</i> adicionado ao topo da pilha e √© removido ap√≥s a conclus√£o da execu√ß√£o.  A <i>segunda</i> fun√ß√£o <i>()</i> √© conclu√≠da, tamb√©m √© removida da pilha. <br><br>  <i>console.log ('The End') foi</i> adicionado ao topo da pilha e removido no final.  Depois disso, a <i>primeira</i> fun√ß√£o <i>()</i> termina e tamb√©m √© removida da pilha. <br><br>  A execu√ß√£o do programa termina, portanto, o contexto de chamada global ( <i>main ()</i> ) √© removido da pilha. <br><br><h2>  Como o JavaScript ass√≠ncrono funciona? </h2><br>  Agora que temos um entendimento b√°sico da pilha de chamadas e como funciona o JavaScript s√≠ncrono, voltemos ao JavaScript ass√≠ncrono. <br><br><h3>  O que est√° bloqueando? </h3><br>  Vamos supor que estamos processando o processamento de imagem ou a solicita√ß√£o de rede de forma s√≠ncrona.  Por exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processImage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">image</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">/** *    **/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Image processed'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> networkRequest = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">/** *      **/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> someData; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); } processImage(logo.jpg); networkRequest(<span class="hljs-string"><span class="hljs-string">'www.somerandomurl.com'</span></span>); greeting();</code> </pre> <br>  O processamento da imagem e a solicita√ß√£o de rede levam tempo.  Quando a fun√ß√£o <i>processImage ()</i> √© chamada, sua execu√ß√£o leva algum tempo, dependendo do tamanho da imagem. <br><br>  Quando a fun√ß√£o <i>processImage ()</i> √© conclu√≠da, ela √© removida da pilha.  Depois disso, a fun√ß√£o <i>networkRequest ()</i> √© chamada e adicionada √† pilha.  Isso novamente levar√° algum tempo antes de concluir a execu√ß√£o. <br><br>  No final, quando a fun√ß√£o <i>networkRequest ()</i> √© executada, a fun√ß√£o <i>greeting ()</i> √© chamada, pois cont√©m apenas o m√©todo <i>console.log</i> , e esse m√©todo geralmente √© r√°pido, e a fun√ß√£o <i>greeting ()</i> ser√° executada e finalizada instantaneamente. <br><br>  Como voc√™ pode ver, precisamos aguardar a <i>conclus√£o</i> da fun√ß√£o (como <i>processImage ()</i> ou <i>networkRequest ()</i> ).  Isso significa que essas fun√ß√µes bloqueiam a pilha de chamadas ou o encadeamento principal.  Como resultado, n√£o podemos executar outras opera√ß√µes at√© que o c√≥digo acima seja executado. <br><br><h3>  Ent√£o, qual √© a solu√ß√£o? </h3><br>  A solu√ß√£o mais simples s√£o as fun√ß√µes de retorno de chamada ass√≠ncronas.  N√≥s os usamos para tornar nosso c√≥digo sem bloqueio.  Por exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> networkRequest = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Async Code'</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); networkRequest();</code> </pre> <br>  Aqui eu usei o m√©todo <i>setTimeout</i> para simular uma solicita√ß√£o de rede.  Lembre-se de que <i>setTimeout</i> n√£o faz parte do mecanismo JavaScript, faz parte da chamada API da Web (no navegador) e APIs do C / C ++ (no node.js). <br><br>  Para entender como esse c√≥digo √© executado, precisamos lidar com mais alguns conceitos, como o loop de eventos e a fila de retorno de chamada (tamb√©m conhecida como fila de tarefas ou fila de mensagens). <br><br><img src="https://habrastorage.org/webt/fd/u7/jx/fdu7jxtawrvjmrptsnumrtidceg.png"><br><br>  O loop de eventos, a API da Web e a fila de mensagens / fila de tarefas n√£o fazem parte do mecanismo JavaScript; eles fazem parte do tempo de execu√ß√£o JavaScript JavaScript ou do tempo de execu√ß√£o JavaScript no Nodejs (no caso do Nodejs).  No Nodejs, as APIs da web s√£o substitu√≠das pelas APIs de C / C ++. <br><br>  Agora, vamos voltar ao c√≥digo acima e ver o que acontece no caso de execu√ß√£o ass√≠ncrona. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> networkRequest = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Async Code'</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); networkRequest(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The End'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/pc/zt/e5/pczte5tqprl18tltgiurc75m50g.gif"><br><br>  Quando o c√≥digo acima √© carregado no navegador, o <i>console.log ('Hello World') √©</i> adicionado √† pilha e removido da mesma ap√≥s a conclus√£o da execu√ß√£o.  Em seguida, √© encontrada uma chamada para a fun√ß√£o <i>networkRequest ()</i> , que √© adicionada ao topo da pilha. <br><br>  Em seguida, a fun√ß√£o <i>setTimeout ()</i> √© chamada e colocada na parte superior da pilha.  A fun√ß√£o <i>setTimeout ()</i> possui 2 argumentos: 1) uma fun√ß√£o de retorno de chamada e 2) tempo em milissegundos. <br><br>  <i>setTimeout ()</i> inicia um timer por 2 segundos em um ambiente de API da web.  Nesse ponto, <i>setTimeout () √©</i> conclu√≠do e √© removido da pilha.  Depois disso, <i>console.log ('The End')</i> √© adicionado √† pilha, executado e removido dela ap√≥s a conclus√£o. <br><br>  Enquanto isso, o cron√¥metro expirou, agora o retorno de chamada √© adicionado √† fila de mensagens.  Mas o retorno de chamada n√£o pode ser executado imediatamente e √© aqui que o ciclo de processamento de eventos entra no processo. <br><br><h3>  Loop de eventos </h3><br>  A tarefa do loop de eventos √© acompanhar a pilha de chamadas e determinar se est√° vazia ou n√£o.  Se a pilha de chamadas estiver vazia, o loop de eventos procurar√° na fila de mensagens para ver se h√° retornos de chamada que est√£o aguardando para serem conclu√≠dos. <br><br>  No nosso caso, a fila de mensagens cont√©m um retorno de chamada e a pilha de execu√ß√£o est√° vazia.  Portanto, o loop de eventos adiciona um retorno de chamada √† parte superior da pilha. <br><br>  Ap√≥s o <i>console.log ('C√≥digo ass√≠ncrono') ser</i> adicionado √† parte superior da pilha, executado e removido dela.  Nesse ponto, o retorno de chamada √© conclu√≠do e removido da pilha e o programa est√° completamente conclu√≠do. <br><br><h3>  Eventos DOM </h3><br>  A fila de mensagens tamb√©m cont√©m retornos de chamada de eventos DOM, como cliques e eventos de teclado.  Por exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.btn'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>,(event) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Button Clicked'</span></span>); });</code> </pre> <br>  No caso de eventos DOM, o manipulador de eventos √© cercado pela API da web, aguardando um evento espec√≠fico (neste caso, um clique) e, quando esse evento ocorre, a fun√ß√£o de retorno de chamada √© colocada na fila de mensagens, aguardando sua execu√ß√£o. <br><br>  Aprendemos como s√£o executados retornos de chamada ass√≠ncronos e eventos DOM, que usam uma fila de mensagens para armazenar retornos de chamada que aguardam execu√ß√£o. <br><br><h3>  Fila do ES6 MicroTask </h3><br>  <i>Nota</i>  <i>autor da tradu√ß√£o: no artigo, o autor usou a fila de mensagens / tarefas e a fila de tarefas / micro-tarefas, mas se voc√™ traduzir a fila de tarefas e a fila de tarefas, em teoria, acontece a mesma coisa.</i>  <i>Conversei com o autor da tradu√ß√£o e decidi simplesmente omitir o conceito de fila de empregos.</i>  <i>Se voc√™ tem alguma opini√£o sobre isso, estou esperando por voc√™ nos coment√°rios</i> <i><br><br></i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link para a tradu√ß√£o do artigo por promessas do mesmo autor</a></i> <i><br></i> <br><br>  O ES6 introduziu o conceito de fila de microtask, usada pelo Promises em JavaScript.  A diferen√ßa entre a fila de mensagens e a fila de microtask √© que a fila de microtask tem uma prioridade mais alta que a fila de mensagens, o que significa que ‚Äúpromessas‚Äù dentro da fila de microtask ser√£o executadas antes dos retornos de chamada na fila de mensagens. <br><br>  Por exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script start'</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'setTimeout'</span></span>); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise resolved'</span></span>); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script End'</span></span>);</code> </pre> <br>  Conclus√£o: <br><br><pre> <code class="javascript hljs">Script start Script End <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> resolved setTimeout</code> </pre> <br>  Como voc√™ pode ver, a ‚Äúpromessa‚Äù foi executada antes do <i>setTimeout</i> , tudo isso porque a resposta da ‚Äúpromessa‚Äù √© armazenada dentro da fila de microstase, que tem uma prioridade mais alta que a fila de mensagens. <br><br>  Vejamos o exemplo a seguir, desta vez 2 "promessas" e 2 <i>setTimeout</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script start'</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'setTimeout 1'</span></span>); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'setTimeout 2'</span></span>); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise 1 resolved'</span></span>); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise 2 resolved'</span></span>); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script End'</span></span>);</code> </pre> <br>  Conclus√£o: <br><br><pre> <code class="javascript hljs">Script start Script End <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> resolved <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> resolved setTimeout <span class="hljs-number"><span class="hljs-number">1</span></span> setTimeout <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  E, novamente, nossas duas "promessas" foram executadas antes dos retornos de chamada no <i>setTimeout</i> , pois o loop de processamento de eventos considera as tarefas da fila de microtask mais importantes do que as tarefas da fila de mensagens / fila de tarefas. <br><br>  Se outro "Promise" aparecer na fila de microtask durante a execu√ß√£o das tarefas, ele ser√° adicionado ao final dessa fila e executado antes dos retornos de chamada da fila de mensagens, e n√£o importa quanto tempo eles esperem pela execu√ß√£o. <br><br>  Por exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script start'</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'setTimeout'</span></span>); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise 1 resolved'</span></span>); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res)); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise 2 resolved'</span></span>); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise 3 resolved'</span></span>); }) }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script End'</span></span>);</code> </pre> <br>  Conclus√£o: <br><br><pre> <code class="javascript hljs">Script start Script End <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> resolved <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> resolved <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> resolved setTimeout</code> </pre> <br>  Portanto, todas as tarefas da fila de microtask ser√£o conclu√≠das antes das tarefas da fila de mensagens.  Ou seja, o loop de processamento de eventos limpar√° primeiro a fila de microtask e s√≥ ent√£o come√ßar√° a executar retornos de chamada da fila de mensagens. <br><br><h2>  Conclus√£o </h2><br>  Assim, aprendemos como o JavaScript ass√≠ncrono funciona e conceitos: pilha de chamadas, loop de eventos, fila de mensagens / fila de tarefas e fila de microtask que comp√µem o tempo de execu√ß√£o do JavaScript </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439620/">https://habr.com/ru/post/pt439620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439610/index.html">Como no meu ve√≠culo el√©trico Chevrolet Bolt, na garantia, dois m√≥dulos de bateria foram substitu√≠dos e o terceiro sob monitoramento</a></li>
<li><a href="../pt439612/index.html">JavaScript robusto: perseguindo um mito</a></li>
<li><a href="../pt439614/index.html">Como distinguir um reparo bom de um reparo ruim, ou como no SRG criamos uma biblioteca Java multiencadeada a partir do analisador Tomit</a></li>
<li><a href="../pt439616/index.html">O resumo de projetos de TI interessantes no Kickstarter No. 7</a></li>
<li><a href="../pt439618/index.html">PHP para iniciantes. Conex√£o de arquivo</a></li>
<li><a href="../pt439624/index.html">Por que armazenar dados em √≥rbita</a></li>
<li><a href="../pt439626/index.html">Experi√™ncia no desenvolvimento de um aplicativo gratuito para coletores OpenNumismat</a></li>
<li><a href="../pt439628/index.html">Atualiza√ß√£o de dados paralelos na API da Web do ASP.NET</a></li>
<li><a href="../pt439632/index.html">Como configurar a Implanta√ß√£o Cont√≠nua para o seu projeto: experi√™ncia pessoal</a></li>
<li><a href="../pt439636/index.html">A crise de conceitos para melhorar a seguran√ßa rodovi√°ria e um novo conceito para resolv√™-la</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>