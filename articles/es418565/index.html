<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕔 🚣🏻 ⛸️ En el camino al 100% de cobertura de código con pruebas en Go usando sql-dumper como ejemplo 🤤 👌🏻 💪🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En esta publicación, hablaré sobre cómo escribí un programa de consola en lenguaje Go para cargar datos de una base de datos a archivos, tratando de c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>En el camino al 100% de cobertura de código con pruebas en Go usando sql-dumper como ejemplo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418565/"><p><img src="https://habrastorage.org/getpro/habr/post_images/cc4/3fe/2c1/cc43fe2c1f16d831ccbf66843bded446.png" alt="imagen"></p><br><p>  En esta publicación, hablaré sobre cómo escribí un programa de consola en lenguaje Go para cargar datos de una base de datos a archivos, tratando de cubrir todo el código con 100% de pruebas.  Comenzaré con una descripción de por qué necesitaba este programa.  Continuaré describiendo las primeras dificultades, algunas de las cuales son causadas por las características del lenguaje Go.  A continuación, mencionaré una pequeña compilación en Travis CI, y luego hablaré sobre cómo escribí las pruebas, tratando de cubrir el código al 100%.  Tocaré un poco para probar el trabajo con la base de datos y el sistema de archivos.  En conclusión, diré a qué conduce el deseo de cubrir el código con pruebas y qué dice este indicador.  Proporcionaré material con enlaces a documentación y ejemplos de confirmaciones de mi proyecto. </p><a name="habracut"></a><br><h1 id="naznachenie-programmy">  Propósito del programa </h1><br><p>  El programa debe iniciarse desde la línea de comandos con una indicación de la lista de tablas y algunas de sus columnas, un rango de datos para la primera columna especificada, una enumeración de las relaciones de las tablas seleccionadas entre sí, con la capacidad de especificar un archivo con la configuración de conexión de la base de datos.  El resultado del trabajo debe ser un archivo que describa las solicitudes para crear las tablas especificadas con las columnas especificadas y las expresiones de inserción de los datos seleccionados.  Se supuso que el uso de dicho programa simplificaría el escenario de extraer una porción de datos de una gran base de datos y desplegar esta porción localmente.  Además, se suponía que estos archivos sql de descarga debían ser procesados ​​por otro programa, que reemplaza parte de los datos de acuerdo con una plantilla específica. </p><br><p>  Se puede lograr el mismo resultado utilizando cualquiera de los clientes populares en la base de datos y una cantidad suficientemente grande de trabajo manual.  Se suponía que la aplicación simplificaría este proceso y automatizaría tanto como fuera posible. </p><br><p>  Este programa debería haber sido desarrollado por mis pasantes con el propósito de capacitación y uso posterior en su capacitación adicional.  Pero la situación resultó tal que rechazaron esta idea.  Pero decidí intentar escribir dicho programa en mi tiempo libre con el propósito de desarrollar mi práctica en el lenguaje Go. </p><br><p>  La solución está incompleta, tiene una serie de limitaciones que se describen en README.  En cualquier caso, este no es un proyecto de combate. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplos de uso y código fuente</a> . </p><br><h1 id="pervye-trudnosti">  Primeras dificultades </h1><br><p> La lista de tablas y sus columnas se pasa al programa como un argumento en forma de cadena, es decir, no se conoce de antemano.  La mayoría de los ejemplos de trabajo con una base de datos en Go implican que la estructura de la base de datos se conoce de antemano, simplemente creamos una <code>struct</code> indica los tipos de cada columna.  Pero en este caso no funciona de esa manera. </p><br><p>  La solución a esto fue utilizar el método <code>MapScan</code> de <code>github.com/jmoiron/sqlx</code> , que creó un segmento de interfaz en el tamaño igual al número de columnas de muestra.  La siguiente pregunta era cómo obtener un tipo de datos real de estas interfaces.  La solución es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">caso de cambio por tipo</a> .  Tal solución no se ve muy hermosa, porque todos los tipos necesitarán ser convertidos en la cadena: enteros como son, cadenas para escapar y encerrar entre comillas, pero al mismo tiempo para describir todos los tipos que pueden provenir de la base de datos.  No encontré una forma más elegante de resolver este problema. </p><br><p>  Con los tipos, también se manifestó una función de lenguaje Go: una variable de tipo string no puede tomar el valor <code>nil</code> , pero tanto una cadena vacía como <code>NULL</code> pueden provenir de la base de datos.  Para resolver este problema, hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solución</a> en el paquete de la <code>database/sql</code> : use una <code>strut</code> especial, que almacena el valor y el signo, ya sea <code>NULL</code> o no. </p><br><h1 id="sborka-i-vychislenie-procenta-pokrytiya-koda-testami">  Ensamblaje y cálculo del porcentaje de cobertura de código por pruebas </h1><br><p>  Para el ensamblaje, uso Travis CI, para obtener el porcentaje de cobertura de código con pruebas: Overoles.  El archivo <code>.travis.yml</code> para el ensamblado es bastante simple: </p><br><pre> <code class="hljs powershell">language: go go: - <span class="hljs-number"><span class="hljs-number">1.9</span></span> script: - go get <span class="hljs-literal"><span class="hljs-literal">-t</span></span> <span class="hljs-literal"><span class="hljs-literal">-v</span></span> ./... - go get golang.org/x/tools/cmd/cover - go get github.com/mattn/goveralls - go test <span class="hljs-literal"><span class="hljs-literal">-v</span></span> <span class="hljs-literal"><span class="hljs-literal">-covermode</span></span>=count <span class="hljs-literal"><span class="hljs-literal">-coverprofile</span></span>=coverage.out ./... - <span class="hljs-variable"><span class="hljs-variable">$HOME</span></span>/gopath/bin/goveralls <span class="hljs-literal"><span class="hljs-literal">-coverprofile</span></span>=coverage.out <span class="hljs-literal"><span class="hljs-literal">-service</span></span>=travis<span class="hljs-literal"><span class="hljs-literal">-ci</span></span> <span class="hljs-literal"><span class="hljs-literal">-repotoken</span></span> <span class="hljs-variable"><span class="hljs-variable">$COVERALLS_TOKEN</span></span></code> </pre> <br><p>  En la configuración de Travis CI, solo necesita especificar la variable de entorno <code>COVERALLS_TOKEN</code> , <code>COVERALLS_TOKEN</code> valor debe tomarse en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio</a> . </p><br><p>  Overol le permite averiguar convenientemente qué porcentaje del proyecto completo, para cada archivo, resalta una línea de código fuente que resultó ser una prueba descubierta.  Por ejemplo, en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera compilación</a> está claro que no escribí pruebas para algunos casos de errores al analizar una solicitud de usuario. </p><br><p>  La cobertura del 100% del código significa que se escriben pruebas que, entre otras cosas, ejecutan código para cada rama en <code>if</code> .  Este es el trabajo más voluminoso al escribir pruebas y, en general, al desarrollar una aplicación. </p><br><p>  Puede calcular la cobertura con pruebas localmente, por ejemplo, con la misma <code>go test -v -covermode=count -coverprofile=coverage.out ./...</code> , pero puede hacerlo mejor en CI, puede colocar una placa en Github. </p><br><p>  Dado que estamos hablando de dados, entonces encuentro útiles los dados de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://goreportcard.com</a> , que analiza los siguientes indicadores: </p><br><ul><li>  gofmt: formato de código, incluida la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">simplificación de construcciones</a> </li><li>  go_vet - comprueba construcciones sospechosas </li><li>  gocyclo - muestra problemas en la complejidad ciclomática </li><li>  golint - para mí está verificando la disponibilidad de todos los comentarios necesarios </li><li>  licencia: el proyecto debe tener una licencia </li><li>  ineffassign - verifica asignaciones ineficaces </li><li>  error ortográfico: verifica los errores tipográficos </li></ul><br><h1 id="trudnosti-pokrytiya-koda-testami-na-100">  Dificultades para cubrir el código con pruebas 100% </h1><br><p>  Si analizar una solicitud de componentes de un usuario pequeño funciona principalmente con la conversión de cadenas a algunas estructuras a partir de cadenas y se cubre con bastante facilidad mediante pruebas, entonces para probar el código que funciona con una base de datos, la solución no es tan obvia. </p><br><p>  Alternativamente, conéctese a un servidor de base de datos real, rellene previamente con datos en cada prueba, realice selecciones y borre.  Pero esta es una solución difícil, lejos de las pruebas unitarias e impone sus requisitos en el entorno, incluido el servidor CI. </p><br><p>  Otra opción podría ser utilizar una base de datos en la memoria, por ejemplo, sqlite ( <code>sqlx.Open("sqlite3", ":memory:")</code> ), pero esto implica que el código debe estar tan débilmente ligado al motor de la base de datos como sea posible, lo que complica enormemente el proyecto. pero para la prueba de integración es bastante buena. </p><br><p>  Para pruebas unitarias, es adecuado usar simulacro para la base de datos.  Encontré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> .  Con este paquete, puede probar el comportamiento tanto en el caso de un resultado normal como en el caso de errores, indicando qué solicitud debe devolver qué error. </p><br><p>  Las pruebas de escritura mostraron que la función que se conecta a la base de datos real debe moverse a main.go, por lo que puede redefinirse en las pruebas para la que devolverá la instancia simulada. </p><br><p>  Además de trabajar con la base de datos, es necesario hacer que el trabajo con el sistema de archivos sea una dependencia separada.  Esto permitirá reemplazar la grabación de archivos reales con escritura en la memoria para facilitar las pruebas y reducir el acoplamiento.  Así es como apareció la interfaz <code>FileWriter</code> , y con ella la interfaz del archivo que devuelve.  Para probar los escenarios de error, se crearon implementaciones auxiliares de estas interfaces y se colocaron en el archivo <code>filewriter_test.go</code> , por lo que no entran en la compilación general, pero se pueden usar en las pruebas. </p><br><p>  Después de un tiempo, tuve una pregunta sobre cómo cubrir <code>main()</code> pruebas.  En ese momento, tenía suficiente código allí.  Como mostraron los resultados de búsqueda, esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no se hace</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Go</a> .  En cambio, todo el código que se puede extraer de <code>main()</code> debe extraerse.  En mi código, dejé solo opciones de análisis y argumentos de línea de comando (paquete de marca), conectándome a la base de datos, creando instancias de un objeto que escribirá archivos y llamando a un método que hará el resto del trabajo.  Pero estas líneas no le permiten obtener exactamente el 100% de cobertura. </p><br><p>  Al probar Go, existe algo así como " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones de ejemplo</a> ".  Estas son funciones de prueba que comparan la salida con lo que se describe en el comentario dentro de dicha función.  Se pueden encontrar ejemplos de tales pruebas en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">código fuente de los paquetes go</a> .  Si dichos archivos no contienen pruebas y puntos de referencia, se nombran con el prefijo <code>example_</code> y terminan con <code>_test.go</code> .  El nombre de cada función de prueba debe comenzar con <code>Example</code> .  Sobre esto, escribí una prueba para un objeto que escribe sql en un archivo, reemplazando el registro real en el archivo con un simulacro, desde el cual puede obtener el contenido y la salida.  Esta conclusión se compara con el estándar.  Convenientemente, no necesita escribir una comparación con sus manos, y es conveniente escribir algunas líneas en los comentarios.  Pero cuando se trataba de probar un objeto que escribe datos en un archivo csv, surgieron dificultades.  De acuerdo con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RFC4180, las</a> líneas en CSV deben estar separadas por CRLF, e <code>go fmt</code> reemplaza todas las líneas con LF, lo que lleva al hecho de que el estándar del comentario no coincide con la salida real debido a los diferentes separadores de línea.  Tuve que escribir una prueba regular para este objeto, al mismo tiempo que cambiaba el nombre del archivo eliminando <code>example_</code> de él. </p><br><p>  La pregunta sigue siendo, si el archivo, por ejemplo, <code>query.go</code> prueba usando tanto ejemplos como pruebas convencionales, ¿debería haber dos archivos <code>example_query_test.go</code> y <code>query_test.go</code> ?  Aquí, por ejemplo, solo hay un <code>example_test.go</code> .  Usar la búsqueda de "ir ejemplo de prueba" sigue siendo divertido. </p><br><p>  Aprendí a escribir pruebas en Go de acuerdo con las guías que Google da para "ir a escribir pruebas".  La mayoría de los que encontré ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3</a> , <a href="">4</a> ) sugieren comparar el resultado con el diseño esperado del formulario </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v != <span class="hljs-number"><span class="hljs-number">1.5</span></span> { t.<span class="hljs-keyword"><span class="hljs-keyword">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Expected 1.5, got "</span></span>, v) }</code> </pre> <br><p>  Pero cuando se trata de comparar tipos, una construcción familiar evoluciona evolutivamente en un montón de uso de "reflexión" o afirmación de tipo.  O otro ejemplo, cuando necesita verificar que el segmento o mapa tiene el valor necesario.  El código se vuelve engorroso.  Entonces quiero escribir mis <a href="">funciones auxiliares</a> para la prueba.  Aunque una buena solución aquí es usar una biblioteca para realizar pruebas.  Encontré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/stretchr/testify</a> .  Le permite hacer <a href="">comparaciones en una sola línea</a> .  Esta solución reduce la cantidad de código y simplifica la lectura y el soporte de las pruebas. </p><br><h1 id="droblenie-koda-i-testirovanie">  Código de fragmentación y pruebas </h1><br><p>  Escribir una prueba para una función de alto nivel que funciona con varios objetos le permite aumentar significativamente el valor de la cobertura de código mediante pruebas a la vez, porque durante esta prueba se ejecutan muchas líneas de código de objetos individuales.  Si se establece el objetivo de solo el 100% de cobertura, la motivación para escribir pruebas unitarias en componentes pequeños del sistema desaparece, ya que esto no afecta el valor de la cobertura del código. </p><br><p>  Además, si no verifica el resultado en la función de prueba, esto tampoco afectará el valor de la cobertura del código.  Puede obtener un alto valor de cobertura, pero no puede detectar errores graves en la aplicación. </p><br><p>  Por otro lado, si tiene un <a href="">código con muchas ramas</a> , después de lo cual se llama una función voluminosa, será difícil cubrirlo con pruebas.  Y aquí tiene un incentivo para mejorar este código, por ejemplo, <a href="">para tomar</a> todas las ramas en una función separada y escribir una <a href="">prueba separada</a> en ella.  Esto afectará positivamente la legibilidad del código. </p><br><p>  Si el código tiene un fuerte acoplamiento, lo más probable es que no pueda escribir una prueba en él, lo que significa que tendrá que hacer cambios en él, lo que afectará positivamente la calidad del código. </p><br><h1 id="zaklyuchenie">  Conclusión </h1><br><p>  Antes de este proyecto, no tenía que establecer una meta de cobertura del 100% del código con las pruebas.  Pude obtener una aplicación que funcionara en 10 horas de desarrollo, pero me llevó entre 20 y 30 horas alcanzar el 95% de cobertura.  Usando un pequeño ejemplo, tuve una idea de cómo el valor de la cobertura del código afecta su calidad y cuánto esfuerzo se necesita para mantenerlo. </p><br><p>  Mi conclusión es que si ve un tablero con un valor de cobertura de código alto para alguien, no dice casi nada sobre qué tan bien se ha probado esta aplicación.  De todos modos, debes ver las pruebas ellos mismos.  Pero si usted mismo ha establecido un curso para un 100% honesto, esto le ayudará a escribir mejor una solicitud. </p><br><p>  Puede leer más sobre esto en los siguientes materiales y comentarios sobre ellos: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La tragedia de la cobertura del código al 100%</a> , está en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Habré</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Acerca de cómo puede tener una cobertura del 100%, pero no marque nada</a> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  La palabra "recubrimiento" se usa aproximadamente 20 veces.  Lo siento </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418565/">https://habr.com/ru/post/es418565/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418553/index.html">Kotlin + React vs Javasript + React</a></li>
<li><a href="../es418557/index.html">Cálculo de procesos ondulatorios en una línea hidráulica utilizando el método de características.</a></li>
<li><a href="../es418559/index.html">NL2API: Creación de interfaces de lenguaje natural para la API web</a></li>
<li><a href="../es418561/index.html">Máquinas de estado al servicio de MVP. Conferencia de Yandex</a></li>
<li><a href="../es418563/index.html">El resumen de materiales interesantes para el desarrollador móvil # 263 (23 de julio - 29 de julio)</a></li>
<li><a href="../es418567/index.html">Dell dejará de ser una empresa privada y, por primera vez en 5 años, colocará acciones en la bolsa de valores.</a></li>
<li><a href="../es418569/index.html">Nuevos satélites - nuevos errores: el sensor infrarrojo satelital GOES-17 no se enfría bien</a></li>
<li><a href="../es418573/index.html">Waterius: transfiera las lecturas de agua a un teléfono a través de Wi-Fi (4 años con batería)</a></li>
<li><a href="../es418575/index.html">"No despegar": 6 aparatos de audio inusuales</a></li>
<li><a href="../es418577/index.html">Administre sus marcadores con etiquetas, para el deleite de usted y sus colegas.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>