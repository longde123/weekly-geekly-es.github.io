<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí≤ üôèüèΩ üêû ¬øPor qu√© Rust lidera el marco de referencia TechEmpower Framework? üëì üßëüèª‚Äçü§ù‚Äçüßëüèª üôà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En realidad, no ten√≠a la intenci√≥n de ver de qu√© color eran las tripas de Rust. Recog√≠ un proyecto de pasatiempo en Go, fui a GitHub para ver el estad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øPor qu√© Rust lidera el marco de referencia TechEmpower Framework?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485452/"><p>  En realidad, no ten√≠a la intenci√≥n de ver de qu√© color eran las tripas de Rust.  Recog√≠ un proyecto de pasatiempo en Go, fui a GitHub para ver el estado de fasthttp: ¬øse est√° desarrollando?  Bueno, al menos compatible?  Creci√≥  Fui, mir√© d√≥nde se encuentra <a href="https://www.techempower.com/benchmarks/" rel="nofollow">fasthttp</a> en los <a href="https://www.techempower.com/benchmarks/" rel="nofollow">puntos de</a> referencia <a href="https://www.techempower.com/benchmarks/" rel="nofollow">TechEmpower</a> .  Miro: y all√≠ el fasthttp apenas muestra la mitad de lo que el l√≠der tiene √©xito, a algunos actix en algunos Rust.  Que dolor </p><br><p>  Aqu√≠ doblaba los brazos, me golpeaba la cabeza contra el suelo (tres veces) y gritaba: "¬°Aleluya, en verdad Rust es un dios verdadero, qu√© ciego estaba antes!".  Pero o las asas no funcionaron, o la frente se arrepinti√≥ ... En cambio, me met√≠ en el c√≥digo de las pruebas escritas en Go y en las pruebas de web actix en Rust.  Para solucionarlo. </p><br><p>  Despu√©s de un par de horas descubr√≠: </p><br><ol><li>  por qu√© el marco actix-web Rust ocupa el primer lugar en todas las pruebas de TechEmpower, </li><li>  C√≥mo Java inicia Script. </li></ol><br><p>  Ahora te dir√© todo en orden. </p><a name="habracut"></a><br><h2 id="chto-za-techempower-framework-benchmark">  ¬øQu√© es el marco de referencia de TechEmpower Framework? </h2><br><p>  Si un marco web demuestra si va a funcionar o, por ejemplo, a veces piensa en susurrarle a sus amigos "Soy r√°pido", seguramente entrar√° en el marco de referencia del marco TechEmpower.  Un lugar popular para medir el rendimiento. </p><br><p>  El sitio tiene un dise√±o peculiar: las pesta√±as de filtros, rondas, condiciones y resultados para diferentes tipos de pruebas est√°n dispersas en la p√°gina con una mano generosa.  Tan generoso y amplio que simplemente no los notas.  Pero vale la pena hacer clic en las pesta√±as, la informaci√≥n detr√°s de ellas es √∫til. </p><br><p>  La forma m√°s f√°cil es obtener los resultados de la prueba de texto sin formato, "¬°Hola, mundo!"  para servidores web.  Los autores del marco generalmente le dan un enlace: supuestamente nos estamos quedando en los primeros cien.  El caso es correcto y √∫til.  En general, regalar texto sin formato es bueno para muchos, y los l√≠deres van en un grupo apretado. </p><br><p>  Cerca, en esas pesta√±as, se encuentran los resultados de pruebas de otros tipos (escenarios).  Hay siete de ellos, m√°s detalles se pueden encontrar <a href="https://github.com/TechEmpower/FrameworkBenchmarks/wiki/Project-Information-Framework-Tests-Overview" rel="nofollow">aqu√≠</a> .  Estos scripts prueban no solo c√≥mo el marco / plataforma maneja el procesamiento de una solicitud http simple, sino tambi√©n una combinaci√≥n con un cliente de base de datos, un motor de plantillas o un serializador JSON. </p><br><p>  Hay datos de prueba en un entorno virtual, en un hardware f√≠sico.  Adem√°s de los gr√°ficos, hay datos tabulares.  En general, vale la pena investigar muchas cosas interesantes, no solo mirar la posici√≥n de "su" plataforma. </p><br><p>  Lo primero que me vino a la mente despu√©s de revisar los resultados de la prueba: "¬øPor qu√© todo es TAN TAN diferente del texto sin formato?".  En texto plano, los l√≠deres van en un grupo ajustado, pero cuando se trata de trabajar con la base de datos, actix-web lidera por un margen significativo.  Al mismo tiempo, muestra un tiempo de procesamiento de solicitud estable.  Shaitan </p><br><p>  Otra anomal√≠a: una soluci√≥n JavaScript incre√≠blemente poderosa.  Se llama ex4x.  Result√≥ que su c√≥digo estaba ligeramente menos que completamente escrito en Java.  Utilizado por Java Runtime, JDBC.  El c√≥digo JavaScript se traduce en bytecode y pega las bibliotecas Java.  Literalmente lo tomaron y adjuntaron Script a Java.  Los trucos de las caras p√°lidas no tienen l√≠mites. </p><br><h2 id="kak-posmotret-kod-i-chto-tam-vnutri">  C√≥mo mirar el c√≥digo y lo que hay dentro </h2><br><p>  El c√≥digo para todas las pruebas est√° en GitHub.  Todo est√° en un √∫nico repositorio, lo cual es muy conveniente.  Puedes clonar y mirar, puedes mirar directamente en GitHub.  La prueba involucra m√°s de 300 combinaciones diferentes del marco con serializadores, motores de plantillas y el cliente de la base de datos.  En diferentes lenguajes de programaci√≥n, con un enfoque diferente para el desarrollo.  Las implementaciones en un idioma est√°n cerca, se puede comparar con la implementaci√≥n en otros idiomas.  El c√≥digo es mantenido por la comunidad, no es el trabajo de una persona o equipo. </p><br><p>  El c√≥digo de referencia es un gran lugar para ampliar sus horizontes.  Es interesante analizar c√≥mo diferentes personas resuelven los mismos problemas.  No hay mucho c√≥digo, las bibliotecas y las soluciones utilizadas son f√°ciles de distinguir.  No me arrepiento de todo lo que llegu√© all√≠.  Aprend√≠ mucho  Primero que nada sobre Rust. </p><br><p>  Antes de Rust, tuve una idea muy vaga.  Cualquier art√≠culo sobre C, C ++, D y especialmente Go seguramente tendr√° un par de comentaristas que explicar√°n en detalle y con angustia que la vanidad, el sinsentido y la estupidez est√°n escritos en otra cosa, siempre que haya <del>  Gascu√±a </del>  √ìxido.  A veces se dejan llevar tanto que dan ejemplos de c√≥digo que una persona no preparada <del>  o pocos aceptan </del>  llevado a un estupor: "¬øPor qu√©, por qu√©, por qu√© todos estos s√≠mbolos?" </p><br><p>  Por lo tanto, abrir el c√≥digo daba miedo. </p><br><p>  Yo mir√©  Result√≥ que los programas en Rust se pueden leer.  Adem√°s, el c√≥digo se lee tan bien que incluso instal√© Rust, intent√© compilar la prueba y jugar un poco con ella. </p><br><p>  Aqu√≠ casi abandon√© este negocio, porque la compilaci√≥n dura mucho tiempo.  Mucho tiempo  Si yo fuera D'Artagnan, o incluso un col√©rico, habr√≠a corrido a Gascu√±a, y mil demonios se arrastrar√≠an abatidos.  Pero lo hice  Beb√≠ t√© de nuevo.  Parece que ni siquiera una taza: en mi computadora port√°til, la primera compilaci√≥n tard√≥ unos 20 minutos. Luego, sin embargo, todo se vuelve m√°s divertido.  Tal vez hasta la pr√≥xima gran actualizaci√≥n de cajas. </p><br><h2 id="a-razve-delo-ne-v-samom-rust">  ¬øPero no es el √≥xido mismo? </h2><br><p>  No  No es un lenguaje de programaci√≥n. </p><br><p>  Por supuesto, Rust es un lenguaje maravilloso.  Potente, flexible, aunque fuera de h√°bito y detallado.  Pero el lenguaje en s√≠ no escribir√° c√≥digo r√°pido.  El lenguaje es una de las herramientas, una de las decisiones tomadas por el programador. </p><br><p>  Como dije, muchos usuarios obtienen r√°pidamente el texto sin formato.  El rendimiento de los marcos actix-web, fasthttp y una docena de otros cuando se procesa una solicitud simple es bastante comparable, es decir, otros lenguajes tienen la capacidad t√©cnica de competir con Rust. </p><br><p>  Actix-web en s√≠, por supuesto, es ‚Äúculpable‚Äù: un producto r√°pido, pragm√°tico y excelente.  La serializaci√≥n es conveniente, el motor de plantillas es bueno, tambi√©n ayuda mucho. </p><br><p>  En particular, los resultados de las pruebas que trabajan con la base de datos difieren. </p><br><p>  Despu√©s de profundizar un poco en el c√≥digo, destaqu√© tres diferencias principales que (me parece) ayudaron a las pruebas de Actix a separarse de los competidores en las pruebas sint√©ticas: </p><br><ol><li>  Modo de operaci√≥n de canalizado tokio-postgres canalizado; </li><li>  Usar una sola conexi√≥n con una prueba de Rust en lugar de un grupo de conexiones con una prueba escrita en Go; </li><li>  Actualizaci√≥n de los puntos de referencia de Actix con un solo comando enviado a trav√©s de una consulta simple en lugar de enviar m√∫ltiples comandos de ACTUALIZACI√ìN. </li></ol><br><h2 id="chto-esche-za-konveyernyy-rezhim">  ¬øQu√© tipo de modo transportador? </h2><br><p>  Aqu√≠ hay un fragmento de la documentaci√≥n de tokio-postgres (utilizado en el punto de referencia de la biblioteca del cliente PostgreSQL) que explica lo que quieren decir sus desarrolladores: </p><br><pre><code class="plaintext hljs">Sequential Pipelined | Client | PostgreSQL | | Client | PostgreSQL | |----------------|-----------------| |----------------|-----------------| | send query 1 | | | send query 1 | | | | process query 1 | | send query 2 | process query 1 | | receive rows 1 | | | send query 3 | process query 2 | | send query 2 | | | receive rows 1 | process query 3 | | | process query 2 | | receive rows 2 | | | receive rows 2 | | | receive rows 3 | | | send query 3 | | | | process query 3 | | receive rows 3 | |</code> </pre> <br><p>  El cliente en modo canalizado (canalizado) no espera una respuesta de PostgreSQL, sino que env√≠a la siguiente consulta mientras PostgreSQL procesa la anterior.  Se puede ver que de esta manera puede procesar la misma secuencia de consultas a la base de datos significativamente m√°s r√°pido. </p><br><p>  Si la conexi√≥n en modo canalizado es d√∫plex (brindando la posibilidad de obtener resultados en paralelo con el env√≠o), este tiempo puede reducirse ligeramente.  Parece que ya hay una versi√≥n experimental de tokio-postgres donde se abre una conexi√≥n d√∫plex. </p><br><p>  Dado que el cliente PostgreSQL env√≠a varios mensajes (Parse, Bind, Execute y Sync) a cada consulta SQL enviada para su ejecuci√≥n, y recibe una respuesta a ellos, el modo canalizado ser√° m√°s efectivo incluso al procesar consultas individuales. </p><br><h2 id="a-pochemu-v-go-ne-tak">  ¬øY por qu√© no est√° en Go? </h2><br><p>  Debido a que Go generalmente usa grupos de conexi√≥n de base de datos.  Las conexiones no est√°n dise√±adas para usarse en paralelo. </p><br><p>  Si ejecuta las mismas consultas SQL a trav√©s de un grupo, en lugar de una conexi√≥n, te√≥ricamente puede obtener un tiempo de ejecuci√≥n a√∫n m√°s corto con un cliente serie ordinario que cuando trabaja a trav√©s de una sola conexi√≥n, ya sea tres veces canalizado: </p><br><pre> <code class="plaintext hljs">| Connection | Connection 2 | Connection 3 | PostgreSQL | |----------------|----------------|----------------|-----------------| | send query 1 | | | | | | send query 2 | | process query 1 | | receive rows 1 | | send query 3 | process query 2 | | | receive rows 2 | | process query 3 | | | receive rows 3 | |</code> </pre><br><p>  Parece que la piel de oveja (modo transportador) no vale la pena. </p><br><p>  Solo bajo una carga alta, el n√∫mero de conexiones al servidor PostgreSQL puede ser un problema. </p><br><h2 id="a-pri-chyom-tut-voobsche-kolichestvo-soedineniy">  ¬øY qu√© tiene que ver el n√∫mero de conexiones con √©l? </h2><br><p>  El punto aqu√≠ es c√≥mo el servidor PostgreSQL responde a un aumento en el n√∫mero de conexiones. </p><br><p>  El grupo izquierdo de columnas muestra el aumento y la ca√≠da del rendimiento de PostgreSQL en funci√≥n del n√∫mero de conexiones abiertas: </p><br><p><img src="https://habrastorage.org/webt/nj/rl/io/njrlior5dxzdovhnxrv4spx8q_w.png"></p><br><p>  <em>( <a href="https://www.percona.com/blog/2018/06/27/scaling-postgresql-with-pgbouncer-you-may-need-a-connection-pooler-sooner-than-you-expect/" rel="nofollow">Adaptado de la publicaci√≥n de Percona</a> )</em> </p><br><p>  Se puede ver que con un aumento en el n√∫mero de conexiones abiertas, el rendimiento del servidor PostgreSQL est√° disminuyendo r√°pidamente. </p><br><p>  Adem√°s, abrir una conexi√≥n directa no es "gratis".  Inmediatamente despu√©s de abrir, el cliente env√≠a informaci√≥n de servicio, "est√° de acuerdo" con el servidor PostgreSQL sobre c√≥mo se procesar√°n las solicitudes. </p><br><p>  Por lo tanto, en la pr√°ctica, debe limitar el n√∫mero de conexiones activas con PostgreSQL, a menudo pas√°ndolas adicionalmente a trav√©s de pgbouncer u otra odisea. </p><br><h2 id="tak-pochemu-actix-web-okazalsya-bystree">  Entonces, ¬øpor qu√© actix-web fue m√°s r√°pido? </h2><br><p>  En primer lugar, actix-web en s√≠ es bastante r√°pido.  Es √©l quien establece el "techo", y es un poco m√°s alto que el de los dem√°s.  Otras bibliotecas utilizadas (serde, yarde) tambi√©n son muy, muy productivas.  Pero me parece que en las pruebas de trabajo con PostgreSQL fue posible salir porque el servidor web actix inicia un hilo en el n√∫cleo del procesador.  Cada hilo abre solo una conexi√≥n a PostgreSQL. </p><br><p>  Cuantas menos conexiones activas, m√°s r√°pido funciona PostgreSQL (consulte los gr√°ficos anteriores). </p><br><p>  El cliente que opera en modo canalizado (tokio-postgres) le permite utilizar efectivamente una conexi√≥n con PostgreSQL para el procesamiento paralelo de consultas de usuarios.  Los manejadores de solicitudes HTTP vuelcan sus comandos SQL en una cola y se alinean en otra para recibir resultados.  Los resultados son divertidos, los retrasos son m√≠nimos, todos est√°n contentos.  El rendimiento general es m√°s alto que un sistema con un grupo de conexiones. </p><br><p>  ¬øEntonces necesita abandonar el grupo, escribir un cliente de canalizaci√≥n PostgreSQL y la felicidad y la velocidad incre√≠ble vendr√°n de inmediato? </p><br><p>  Posiblemente  Pero no todo a la vez. </p><br><h2 id="kogda-konveyernyy-rezhim-vryad-li-spaset-i-uzh-tochno-ne-sohranit">  Cuando es poco probable que se guarde el modo de transportador y ciertamente no se guardar√° </h2><br><p>  El esquema utilizado en el c√≥digo de referencia no funcionar√° con las transacciones de PostgreSQL. </p><br><p>  En el punto de referencia, no se necesitan transacciones y el c√≥digo est√° escrito teniendo en cuenta que no habr√° transacciones.  En la pr√°ctica, suceden. </p><br><p>  Si el c√≥digo de back-end abre una transacci√≥n PostgreSQL (por ejemplo, para realizar un cambio en dos tablas at√≥micas diferentes), todos los comandos enviados a trav√©s de esta conexi√≥n se ejecutar√°n dentro de esta transacci√≥n. </p><br><p>  Dado que la conexi√≥n con PostgreSQL se usa en paralelo, todo se mezcla.  Los comandos que deben ejecutarse en una transacci√≥n seg√∫n lo dise√±ado por el desarrollador se mezclan con los comandos sql iniciados por los controladores de solicitud http paralelos.  Recibiremos p√©rdida de datos aleatoria y problemas con su integridad. </p><br><p>  As√≠ que hola transacci√≥n: adi√≥s uso paralelo de una conexi√≥n.  Deber√° asegurarse de que la conexi√≥n no sea utilizada por otros manejadores de solicitudes http.  Deber√° detener el procesamiento de las solicitudes HTTP entrantes antes de cerrar la transacci√≥n, o utilizar un grupo para las transacciones, abriendo varias conexiones al servidor de la base de datos.  Hay varias implementaciones de grupo para Rust, y ninguna.  Adem√°s, existen en Rust por separado de la implementaci√≥n del cliente de la base de datos.  Puede elegir seg√∫n el gusto, el color, el olor o al azar.  Ir no funciona de esa manera.  El poder de los gen√©ricos, s√≠. </p><br><p>  Un punto importante: en la prueba, cuyo c√≥digo busqu√©, las transacciones no se abren.  Esta pregunta simplemente no vale la pena.  El c√≥digo de referencia est√° optimizado para una tarea espec√≠fica y condiciones de operaci√≥n de aplicaciones muy espec√≠ficas.  La decisi√≥n de usar una conexi√≥n por flujo de servidor probablemente se hizo conscientemente y result√≥ ser muy efectiva. </p><br><h2 id="est-v-kode-benchmarka-esche-chto-to-interesnoe">  ¬øHay algo m√°s interesante en el c√≥digo de referencia? </h2><br><p>  Si </p><br><p>  El escenario para medir el rendimiento se explica con gran detalle.  Adem√°s de los criterios que debe cumplir el c√≥digo que participa en las pruebas.  Una de ellas es que todas las consultas al servidor de la base de datos deben ejecutarse secuencialmente. </p><br><p>  Parece que el siguiente fragmento de c√≥digo (ligeramente abreviado) no cumple con los criterios: </p><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> worlds = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::with_capacity(num); <span class="hljs-comment"><span class="hljs-comment">//  num    PostgreSQL for _ in 0..num { let w_id: i32 = self.rng.gen_range(1, 10_001); worlds.push( self.cl .query(&amp;self.world, &amp;[&amp;w_id]) .into_future() .map(move |(row, _)| { // ... }), ); } //     stream::futures_unordered(worlds) .collect() .and_then(move |worlds| { // ... })</span></span></code> </pre> <br><p>  Todo parece un lanzamiento t√≠pico de procesos paralelos.  Pero, dado que se usa una conexi√≥n a PostgreSQL, las consultas al servidor de la base de datos se env√≠an secuencialmente.  Uno por uno.  Seg√∫n sea necesario.  Sin crimen </p><br><p>  Por qu√©  Bueno, en primer lugar, en el c√≥digo (se dio en la oficina editorial, que funcion√≥ en la ronda 18) async / wait todav√≠a no se usa, apareci√≥ en Rust m√°s tarde.  Y a trav√©s de futuros <code>num</code> es m√°s f√°cil enviar consultas SQL "en paralelo", como en el c√≥digo anterior.  Esto le permite obtener un aumento de rendimiento adicional: mientras PostgreSQL acepta y procesa la primera consulta SQL, el resto se le env√≠a.  El servidor web no espera el resultado de cada uno, sino que cambia a otras tareas y vuelve a procesar la solicitud http solo cuando se completan todas las consultas SQL. </p><br><p>  Para PostgreSQL, la ventaja es que el mismo tipo de consulta en el mismo contexto (conexi√≥n) va en una fila.  La probabilidad de que el plan de consulta no se reconstruya aumenta. </p><br><p>  Resulta que las ventajas del modo de canalizaci√≥n (ver el diagrama de la documentaci√≥n de tokio-postgres) se explotan por completo incluso cuando se procesa una √∫nica solicitud http. </p><br><p>  Que mas </p><br><h2 id="ispolzovanie-uproschennogo-protokola-simple-query-dlya-paketnogo-obnovleniya">  Usando el protocolo de consulta simple para actualizaciones por lotes </h2><br><p>  El protocolo de comunicaci√≥n entre el cliente y el servidor PostgreSQL permite m√©todos alternativos para ejecutar comandos SQL.  El protocolo habitual (consulta extendida) implica enviar al cliente varios mensajes: analizar, vincular, ejecutar y sincronizar.  Una alternativa es el protocolo Simple Query, seg√∫n el cual un solo mensaje es suficiente para ejecutar un comando y obtener resultados: Consulta. </p><br><p>  La diferencia clave entre el protocolo habitual es la transferencia de par√°metros de solicitud: se transmiten por separado del comando en s√≠.  Es m√°s seguro  El protocolo simplificado supone que todos los par√°metros de la consulta SQL se convertir√°n en una cadena y se incluir√°n en el cuerpo de la consulta. </p><br><p>  Una soluci√≥n interesante utilizada en los puntos de referencia de actix-web fue actualizar varias entradas de la tabla con un solo comando enviado a trav√©s del protocolo Simple Query. </p><br><p>  Seg√∫n el punto de referencia, al procesar una solicitud de usuario, el servidor web debe actualizar varios registros en la tabla, escribir n√∫meros aleatorios.  Obviamente, la actualizaci√≥n de registros en sucesi√≥n con consultas secuenciales lleva m√°s tiempo que una sola consulta que actualiza todos los registros a la vez. </p><br><p>  La solicitud generada en el c√≥digo de prueba se ve as√≠: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> world <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> randomnumber = temp.randomnumber <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> temp(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, randomnumber) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> temp.id = world.id</code> </pre> <br><p>  Donde <code>(1, 2), (2, 3)</code> son los pares de identificador de l√≠nea / nuevo valor del campo de n√∫mero aleatorio. </p><br><p>  El n√∫mero de registros actualizados es variable, preparar la solicitud (PREPARAR) por adelantado no tiene sentido.  Dado que los datos para la actualizaci√≥n son num√©ricos y se puede confiar en la fuente (el c√≥digo de prueba en s√≠), no hay riesgo de inyecci√≥n de SQL, los datos simplemente se incluyen en el cuerpo de SQL y todo se env√≠a utilizando el protocolo Simple Query. </p><br><p>  Se rumorea simple consulta.  Cumpl√≠ con una recomendaci√≥n: "Trabaje solo en el protocolo de consulta simple, y todo ser√° r√°pido y bueno".  La percibo con mucho escepticismo.  Simple Query le permite reducir la cantidad de mensajes enviados al servidor PostgreSQL moviendo el procesamiento de los par√°metros de consulta al lado del cliente.  Puede ver la ganancia de las consultas generadas din√°micamente con un n√∫mero variable de par√°metros.  Para el mismo tipo de consultas SQL (que son m√°s comunes), la ganancia no es obvia.  Bueno, y qu√© tan seguro resultar√° el procesamiento de los par√°metros de consulta, en el caso de Simple Query determina la implementaci√≥n de la biblioteca del cliente. </p><br><p>  Como escrib√≠ anteriormente, en este caso, el cuerpo de la consulta SQL se genera din√°micamente, los datos son num√©ricos y los genera el propio servidor.  La combinaci√≥n perfecta para Simple Query.  Pero incluso en este caso, vale la pena probar otras opciones.  Las alternativas dependen de la plataforma y el cliente de PostgreSQL: pgx (el cliente para Go) permite enviar un paquete de comandos, JDBC, para ejecutar un comando varias veces seguidas con diferentes par√°metros.  Ambas soluciones pueden funcionar a la misma velocidad o incluso ser m√°s r√°pidas. </p><br><h2 id="tak-pochemu-rust-lidiruet">  Entonces, ¬øpor qu√© lidera Rust? </h2><br><p>  El l√≠der, por supuesto, no es Rust.  Las pruebas basadas en actix-web son l√≠deres: es √©l quien establece el "techo" del rendimiento.  Hay, por ejemplo, cohetes y hierro, que ocupan posiciones modestas.  Pero por el momento, es actix-web que determina el potencial para usar Rust en el desarrollo web.  En cuanto a m√≠, el potencial es muy alto. </p><br><p>  Otro servidor "secreto" no obvio, pero importante basado en actix-web, que permiti√≥ ocupar el primer lugar en todos los puntos de referencia de TechEmpower, en c√≥mo funciona con PostgreSQL: </p><br><ol><li>  Solo se abre una conexi√≥n con PostgreSQL por flujo de servidor web.  Esta conexi√≥n utiliza el modo canalizado, lo que le permite ser utilizado efectivamente para el procesamiento paralelo de las solicitudes de los usuarios. </li><li>  Cuantas menos conexiones activas, m√°s r√°pido responde PostgreSQL.  La velocidad de procesamiento de las solicitudes de los usuarios aumenta.  Al mismo tiempo, bajo carga, todo el sistema funciona m√°s estable (los retrasos en el procesamiento de las solicitudes entrantes son menores, crecen m√°s lentamente). </li></ol><br><p>  Donde la velocidad es importante, esta opci√≥n probablemente ser√° m√°s r√°pida que usar multiplexores (como pgbouncer y odyssey).  Y ciertamente fue m√°s r√°pido en los puntos de referencia. </p><br><p>  Es muy interesante c√≥mo async / wait, que apareci√≥ en Rust, y el drama reciente con actix-web afectar√° la popularidad de Rust en el desarrollo web.  Tambi√©n es interesante c√≥mo cambiar√°n los resultados de la prueba despu√©s de procesarlos en as√≠ncrono / espera. </p></div></div><p>Source: <a href="https://habr.com/ru/post/485452/">https://habr.com/ru/post/485452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../485428/index.html">El misterioso programa LyX. Parte 5</a></li>
<li><a href="../485430/index.html">Editor de texto simple para m√∫ltiples usuarios con encriptaci√≥n de extremo a extremo</a></li>
<li><a href="../485438/index.html">Prueba de componentes de la interfaz de usuario de React</a></li>
<li><a href="../485448/index.html">Otra radio FM en el RDA5807 con Arduino</a></li>
<li><a href="../485450/index.html">¬øQu√© hay de nuevo en SObjectizer-5.7.0 y qu√© espera para este proyecto?</a></li>
<li><a href="../485454/index.html">Comenzando con las devoluciones de usuarios: consejos para el modelo enganchado</a></li>
<li><a href="../485458/index.html">Silenciador ob√∫s</a></li>
<li><a href="../485460/index.html">20 bibliotecas para una espectacular aplicaci√≥n de iOS</a></li>
<li><a href="../485462/index.html">Nos ocupamos de eSIM (+ entrevista con un experto)</a></li>
<li><a href="../485464/index.html">Mi primer juego html5, desde Alice Yandex y victorias de premios hasta aplicaciones m√≥viles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>