<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😪 🍅 🤱🏽 Solo otro contenedor Qt para gRPC y protobuf 🤱🏾 ⏹️ 💕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No hace mucho tiempo, me sorprendió el hecho de que no hay suficientes envoltorios y generadores simples y convenientes para protobuf y gRPC, basados ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Solo otro contenedor Qt para gRPC y protobuf</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467893/"><img src="https://habrastorage.org/webt/5l/o2/cn/5lo2cnubwwz2llx4ufpcbm2g_-m.png"><br><br>  No hace mucho tiempo, me sorprendió el hecho de que no hay suficientes envoltorios y generadores simples y convenientes para protobuf y gRPC, basados ​​y totalmente compatibles con Qt.  Encontré artículos, incluyendo  aquí sobre envoltorios, pero su uso me pareció mucho menos práctico que incluso la API C ++ existente. <br><a name="habracut"></a><br><h2>  Un poco sobre gRPC y protobuf </h2><br>  Simulemos una situación: vas a escribir un proyecto multiplataforma y debes elegir un marco RPC para comunicarte con tus servicios.  Siempre puedes golpearte en el pecho y decir "Soy mi propio marco", pero me parece que estamos viviendo en una era de soluciones listas para usar.  Una de esas soluciones nos fue presentada por una empresa reconocida durante mucho tiempo.  No pretendo comparar marcos RPC, este no es el propósito de este artículo.  Solo para enumerar lo que me gusta de gRPC: <br><br><ul><li>  IDL conciso y claro </li><li>  La presencia de una gran cantidad de generadores para varias plataformas. </li><li>  Código de cliente / servidor generado para la creación rápida y sencilla de prototipos y aplicaciones de prueba de escritura </li></ul><br><h2>  Al punto </h2><br>  Debido a que a Qt le está yendo bastante bien con la reflexión de tipo, y la cantidad de metainformación generalmente está en el nivel más alto, se dio cuenta de que necesita su propio generador que generaría un código Qt "puro", sin intercalar bibliotecas de terceros.  Así nació qtprotobufgen. <br><br><h3>  qtprotobufgen </h3><br>  qtprotobufgen es el generador inherentemente más simple, que se basa en la API proporcionada por libprotoc.  En caso de que quieras hacer algo así para tus necesidades, te dejaré un poco de trampa. <br><br><ul><li>  Tiene un único punto de entrada a la clase de complemento :: google :: protobuf :: compilador :: CodeGenerator, del cual necesita heredar </li><li>  Generar método virtual determina la generación cuando se trabaja con un archivo .proto separado </li><li>  El método virtual GenerateAll determina la generación cuando se trabaja con una matriz completa de archivos .proto proporcionados para generar o ser dependencias. </li><li>  El método virtual HasGenerateAll es esencialmente una reliquia que sobrevive de versiones anteriores.  Volver verdadero </li></ul><br>  Debo decir de inmediato que no había ningún deseo de escribir mi propio analizador / generador desde cero, ya que existe una solución preparada por los desarrolladores de protobuf.  Pero si lo desea, puede leer la secuencia binaria que emite el protocolo o escribir su propio analizador de protoarchivos. <br><br>  Durante el desarrollo, surgió un inconveniente significativo de un generador escrito en un lenguaje compilado: era difícil poner la generación y la compilación en una pila CMake.  Debido al hecho de que Qt genera información de metaobjetos, basándose en los archivos de encabezado que tienen la macro Q_OBJECT en el cuerpo de las clases declaradas en el archivo de encabezado, es necesario en la etapa de configuración (leer cmake) tener una idea de los archivos que moc proporcionará para la generación de código adicional.  Como solución, tuve que recurrir al lenguaje interpretado Go (Lang), que no creó dependencias adicionales e hizo su trabajo perfectamente, pero no pasó suficientes pruebas. <br><br>  El generador está sujeto a las reglas de protocolo existentes y, al momento de escribir, no presenta ninguna opción de generación adicional: <br><br><pre><code class="bash hljs">protoc --plugin=protoc-gen-qtprotobuf=&lt;path/to/bin&gt;/qtprotobufgen --qtprotobuf_out=&lt;output_dir&gt; &lt;protofile&gt;.proto [--qtprotobuf_opt=out=&lt;output_dir&gt;]</code> </pre> <br>  Por simplicidad y facilidad de uso, puede usar rutinas cmake especialmente preparadas para generar código e incrustarlas en un proyecto cmake.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Más detalles ...</a> <br><br><h3>  Sobre bibliotecas </h3><br>  No veo mucho sentido describir la API en detalle.  Aquellos que lo deseen pueden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">generar</a> documentación y leer un poco más sobre la API disponible actualmente. <br><br>  El proyecto se divide en 2 partes lógicas qtprotobuf y qtgrpc.  Por los nombres, creo que el propósito de cada componente es claro.  Intentamos hacer el uso lo más conveniente posible, porque hay opciones de integración con la biblioteca preensamblada e instalada en el sistema, y ​​la integración del subproyecto en su proyecto cmake. <br><br>  El código generado se exporta <font color="#ff0000"><b>*</b></font> completamente a QML, lo que hace que trabajar con la API gRPC sea mucho más fácil. <br><br><h3>  Uso </h3><br>  Después de integrarse con el proyecto y realizar la generación, recibirá un conjunto de archivos fuente, que luego se recopilarán en una biblioteca estática y se vincularán a su archivo binario.  Los cambios recientes excluyeron la posibilidad de registro estático de generados y prototipos.  Por lo tanto, debe encargarse de su registro en el proyecto: <br><br><pre> <code class="cpp hljs">... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QtProtobufTypes&gt; ... int main(int argc, char *argv[]) { QtProtobuf::registerProtoTypes(); ... //   Qt  }</span></span></span></span></code> </pre><br>  En el momento de la escritura, no existe un método único para registrar todos los tipos generados para un paquete prototipo, por lo que debe llamar al método qRegisterProtobufType para todos los tipos utilizados en la aplicación: <br><br><pre> <code class="cpp hljs">... qRegisterProtobufType&lt;MyProtoType&gt;(); ...</code> </pre><br>  El uso de bibliotecas y un generador se describe en README, y un par de ejemplos acompañan el proyecto.  Para aquellos que no están familiarizados con gRPC / protobuf, les sugiero que lean la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">documentación oficial</a> <br><br><h3>  Para desarrolladores </h3><br>  Intentamos adherirnos a TDD durante el desarrollo, y no queremos desviarnos de él.  Como ha demostrado nuestra experiencia, TDD le ahorra al refactorizar o actualizar la API, ayuda a detectar problemas ocultos.  Por lo tanto, si desea contribuir, prepárese para escribir unidades, pruebas unitarias y funcionales. <br><br><h3>  <font color="#ff0000"><b>*</b></font> Problemas conocidos </h3><br>  Actualmente hay una serie de problemas relacionados con Qt.  Algunos de ellos se resolvieron, con la nuestra o sin nuestra participación, pero no todos se incluyeron en las versiones actuales de Qt.  El principal es la inaccesibilidad de algunos tipos básicos de protobuf del código qml.  Creo que no es ningún secreto para nadie que el conjunto de tipos disponibles en QML es muy limitado, en parte debido al uso de V8 como motor JS.  Un intento de hacer que QML sea un poco más amigable con los tipos personalizados (por ejemplo, fixed32, sint32) falló, pero resultó solucionar el origen del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">problema</a> .  La implementación actual de QtNetwork también tiene varios problemas, pero el equipo de Qt los soluciona rápidamente. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">QTBUG-77852</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">QTBUG-76303</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">QTBUG-78310</a> <br><br><h3>  Planes </h3><br>  Todas las actividades actuales están relacionadas con la resolución de problemas en el código del proyecto o en el código Qt.  Pero hay una gran cantidad de trabajo asociado con la nueva funcionalidad: <br><br><ol><li>  <s>Transición a un solo par de archivos .h / .cpp para el código generado</s> </li><li>  Implementación del servidor GRPC </li><li>  <s>API de reciclaje para credenciales gRPC</s> </li><li>  Distribución del código generado en directorios y creación de complementos de subproyectos para cargar por separado los paquetes y módulos generados </li><li>  <s>Integración Qmake</s> </li><li>  <s>Implementación de CI</s> </li></ol><br>  Hay algunos trabajos pendientes, que todavía se almacenan en su propio repositorio de proyectos. <br><br>  En lugar de una conclusión, me gustaría dar las gracias a los camaradas de PVS-Studio por la clave proporcionada para los proyectos de OSS.  Con su ayuda, encontraron un error bastante crítico en el código generado. <br><br>  Descargar, ver el proyecto y jugar con ejemplos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">aquí</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467893/">https://habr.com/ru/post/467893/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467881/index.html">Tutu.ru reunión de fondo</a></li>
<li><a href="../467883/index.html">Kubernetes 1.16: cómo actualizar y no romper nada</a></li>
<li><a href="../467885/index.html">Producto y minas segmentadas</a></li>
<li><a href="../467887/index.html">Reflexiones cáusticas realistas</a></li>
<li><a href="../467891/index.html">Preguntas frecuentes sobre la firma en la nube [electrónica]</a></li>
<li><a href="../467895/index.html">¿Qué patrones encuentran las redes neuronales?</a></li>
<li><a href="../467897/index.html">Herramientas de prueba automática, integración Yandex Mapkit 3, diseño atractivo y enfoque de interfaz de usuario impulsada por el servidor: anuncio de mitap de Android</a></li>
<li><a href="../467903/index.html">Las 20 mejores funciones de navegación en IntelliJ IDEA. Parte 1</a></li>
<li><a href="../467905/index.html">Cómo hicimos un reconocimiento histórico en Cloud Mail.ru y por qué</a></li>
<li><a href="../467907/index.html">Pros y contras de la subcontratación</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>