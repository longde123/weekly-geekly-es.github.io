<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈷️ 🏟️ 👩🏾‍⚖️ Gehen Sie zur Software-Konfiguration 🛄 👩🏻‍🎓 ➰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Nach fünf Jahren des Programmierens auf Go fand ich mich ganz 
 ein begeisterter Befürworter einer bestimmten Herangehensweise an di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gehen Sie zur Software-Konfiguration</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479882/"><p><img src="https://habrastorage.org/webt/8g/-t/pl/8g-tplxpugbs2hslzi5n0rxri_i.jpeg" alt="Gopher mit Fahne"></p><br><p>  Hallo allerseits!  Nach fünf Jahren des Programmierens auf Go fand ich mich ganz <br>  ein begeisterter Befürworter einer bestimmten Herangehensweise an die Programmkonfiguration.  In diesem <br>  Ich werde versuchen, seine Hauptideen in dem Artikel zu enthüllen, sowie einen kleinen zu teilen <br>  eine Bibliothek, die diese Ideen umsetzt. </p><br><p>  Offensichtlich ist der Artikel sehr subjektiv und gibt nicht vor, objektiv zu sein <br>  wahrheiten.  Ich hoffe jedoch, dass es für die Community nützlich sein und zur Reduzierung beitragen kann <br>  Zeit, die für eine so einfache Aufgabe aufgewendet wurde. </p><a name="habracut"></a><br><h2 id="o-chem-rech">  Wovon redest du </h2><br><p>  Generell ist die Konfiguration meiner Meinung nach die Definition der Variablen unserer <br>  Programme, deren Werte wir schon zur Laufzeit von außen bekommen können. <br>  Dies können Argumente oder Befehlszeilenparameter, Umgebungsvariablen, <br>  Konfigurationsdateien, die auf der Festplatte oder irgendwo im Netzwerk gespeichert sind, Datenbanktabellen <br>  Daten und so weiter. </p><br><p> Da Go eine stark statisch getippte Sprache ist, möchten wir dies tun <br>  Ermitteln und Abrufen von Werten für solche Variablen unter Berücksichtigung ihres Typs. </p><br><p>  Es gibt eine große Anzahl von Open-Source-Bibliotheken oder sogar Frameworks, <br>  Lösen solcher Probleme.  Die meisten von ihnen repräsentieren ihre eigene Vision. <br>  wie es geht. </p><br><p>  Ich möchte über einen weniger verbreiteten Ansatz zur Programmkonfiguration sprechen. <br>  Außerdem scheint mir dieser Ansatz der einfachste zu sein. </p><br>
<h2 id="paket-flag">  Paket kennzeichnen </h2><br><p>  Ja, das ist kein Scherz und ich möchte wirklich Ihre Aufmerksamkeit auf alles lenken <br>  Das berühmte Go-Standardbibliothekspaket. </p><br><p>  Auf den ersten Blick ist <code>flag</code> ein Werkzeug zum Arbeiten mit Befehlsparametern <br>  Linien und nicht mehr.  Dieses Paket kann aber auch als <strong>Schnittstelle verwendet werden.</strong> <strong><br></strong>  <strong>Bestimmung der</strong> Parameter unseres Programms.  Und im Kontext des diskutierten Ansatzes <br>  <code>flag</code> hauptsächlich so verwendet. </p><br><p>  Wie oben erwähnt, möchten wir typisierte Parameter haben. <br>  Das <code>flag</code> Paket bietet die Möglichkeit, dies für die meisten Basistypen zu tun. <br>  - <code>flag.String()</code> , <code>flag.Int()</code> und sogar <code>flag.Duration()</code> . </p><br><p>  Für komplexere Typen wie <code>[]string</code> oder <code>time.Time</code> gibt es eine Schnittstelle <br>  <code>flag.Value</code> , mit dem Sie beschreiben können, <code>flag.Value</code> Sie den Wert eines Parameters daraus <code>flag.Value</code> <br>  <em>String-Darstellung</em> . </p><br><p>  Beispielsweise kann ein Parameter vom Typ <code>time.Time</code> folgendermaßen implementiert werden: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// TimeValue is an implementation of flag.Value interface. type TimeValue struct { P *time.Time Layout string } func (t *TimeValue) Set(s string) error { v, err := time.Parse(t.Layout, s) if err == nil { (*tP) = v } return err } func (t *TimeValue) String() string { return tPFormat(t.Layout) }</span></span></code> </pre> <br><p>  Eine wichtige Eigenschaft eines Pakets ist das Vorhandensein in der <strong>Standardbibliothek</strong> - <code>flag</code> is <br>  <em>Standard Weg, um Programme zu konfigurieren</em> , was seine Wahrscheinlichkeit bedeutet <br>  Die Nutzung zwischen verschiedenen Projekten und Bibliotheken ist höher als bei anderen <br>  Bibliotheken in der Gemeinde. </p><br><h2 id="pochemu-ne-ispolzuyut-flag">  Warum nicht <code>flag</code> benutzen? </h2><br><p>  Es scheint mir, dass andere Bibliotheken verwendet werden und aus zwei Gründen existieren: </p><br><ul><li>  Parameter werden nicht nur von der Kommandozeile gelesen </li><li>  Ich möchte die Parameter strukturieren </li></ul><br><p>  Wenn Sie zum Beispiel Parameter aus Dateien lesen, ist alles mehr oder weniger klar <br>  Dies später), dann über strukturelle Parameter lohnt es sich, ein paar Worte direkt zu sagen <br>  jetzt. </p><br><p>  Es gibt meiner Meinung nach nicht die beste Möglichkeit, die Konfiguration zu bestimmen <br>  Programme als Strukturen, deren Felder andere Strukturen sein könnten und so <br>  weiter: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> AppConfig <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Port <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Database <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Endpoint <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Timeout time.Duration } ... }</code> </pre> <br><p>  Aus diesem Grund werden Bibliotheken genutzt und existieren <br>  Frameworks, mit denen Sie auf diese Weise mit der Konfiguration arbeiten können. </p><br><p>  Ich denke, <code>flag</code> sollte keine strukturellen Konfigurationsmöglichkeiten bieten. <br>  Dies kann leicht mit ein paar Codezeilen (oder einer Bibliothek) erreicht werden <br>  <code>flagutil</code> , das weiter unten besprochen wird). </p><br><p>  Wenn Sie darüber nachdenken, führt die Existenz einer solchen Struktur zu einer starken <br>  Konnektivität zwischen den verwendeten Komponenten. </p><br><h2 id="strukturnaya-konfiguraciya">  Strukturelle Konfiguration </h2><br><p>  Die Idee ist, Parameter unabhängig von der Struktur zu definieren <br>  Programme und so nah wie möglich an dem Ort, an dem sie verwendet werden - das heißt, <br>  direkt auf Paketebene. </p><br><p>  Angenommen, wir haben eine Client-Implementierung für einen Dienst (Datenbank, <br>  API oder was auch immer) namens <code>yoogle</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> yoogle <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Endpoint <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Timeout time.Duration } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Config)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Client</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Um die <code>yoogle.Config</code> Struktur zu <code>yoogle.Config</code> , benötigen wir eine Funktion, die <br>  registriert die Strukturfelder im empfangenen <code>*flag.FlagSet</code> . </p><br><p>  Eine solche Funktion kann auf <code>yoogle</code> oder in einem Paket deklariert werden <br>  <code>yooglecfg</code> (im Falle einer Drittanbieter-Bibliothek können wir eine solche Funktion schreiben <br>  an anderer Stelle): </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> yooglecfg <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"flag"</span></span> <span class="hljs-string"><span class="hljs-string">"app/yoogle"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Export</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(flag *flag.FlagSet)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yoogle</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c yoogle.Config flag.StringVar(&amp;c.Endpoint, <span class="hljs-string"><span class="hljs-string">"endpoint"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://example.com"</span></span>, <span class="hljs-string"><span class="hljs-string">"endpoint for our API"</span></span>, ) flag.DurationVar(&amp;c.Timeout, <span class="hljs-string"><span class="hljs-string">"timeout"</span></span>, time.Second, <span class="hljs-string"><span class="hljs-string">"timeout for operations"</span></span>, ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;c }</code> </pre> <br><p>  Um die Abhängigkeit vom <code>flag</code> Paket zu beseitigen, können Sie eine Schnittstelle mit definieren <br>  erforderliche <code>flag.FlagSet</code> Methoden: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> yooglecfg <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"app/yoogle"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> FlagSet <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { StringVar(p *<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, name, value, desc <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Export</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(flag FlagSet)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yoogle</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c yoogle.Config flag.StringVar(&amp;c.Endpoint, <span class="hljs-string"><span class="hljs-string">"endpoint"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://example.com"</span></span>, <span class="hljs-string"><span class="hljs-string">"endpoint for our API"</span></span>, ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;c }</code> </pre> <br><p>  Und ob die Konfiguration von den Parameterwerten abhängt (zB unter den Parametern <br>  Der Algorithmus von etwas wird angezeigt), die Funktion <code>yooglecfg.Export()</code> kann zurückgeben <br>  Konstruktorfunktion, die <strong>nach dem</strong> Parsen aller Werte aufgerufen wird <br>  Konfigurationen: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> yooglecfg <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"app/yoogle"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> FlagSet <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { StringVar(p *<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, name, value, desc <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Export</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(flag FlagSet)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yoogle</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> algorithm <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> flag.StringVar(&amp;algorithm, <span class="hljs-string"><span class="hljs-string">"algorithm"</span></span>, <span class="hljs-string"><span class="hljs-string">"quick"</span></span>, <span class="hljs-string"><span class="hljs-string">"algorithm used to do something"</span></span>, ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c yoogle.Config <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yoogle</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> algorithm { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"quick"</span></span>: c.Impl = quick.New() <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"merge"</span></span>: c.Impl = merge.New() <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"bubble"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(...) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c } }</code> </pre> <br><blockquote>  Mit Exportfunktionen können Sie Paketparameter definieren, ohne die Struktur zu kennen <br>  Programmkonfiguration und wie man ihre Werte erhält. </blockquote><br><h2 id="githubcomgobwasflagutilflagutil">  <a href="https://github.com/gobwas/flagutil">github.com/gobwas/flagutil</a> </h2><br><p>  Wir haben eine große Konfigurationsstruktur herausgefunden und unsere Parameter festgelegt <br>  unabhängig, aber es ist noch nicht klar, wie man sie alle zusammenbringt und <br>  werte. </p><br><p>  <code>flagutil</code> dieses Problem zu lösen, wurde das Paket <code>flagutil</code> geschrieben. </p><br><h3 id="sobiraem-parametry-vmeste">  Zusammenstellen der Parameter </h3><br><p>  Alle Parameter des Programms, seiner Pakete und Bibliotheken von Drittanbietern erhalten ihr Präfix <br>  und werden auf der Paketebene <code>main</code> gesammelt: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"flag"</span></span> <span class="hljs-string"><span class="hljs-string">"app/yoogle"</span></span> <span class="hljs-string"><span class="hljs-string">"app/yooglecfg"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gobwas/flagutil"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { flags := flag.NewFlagSet(<span class="hljs-string"><span class="hljs-string">"my-app"</span></span>, flag.ExitOnError) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> port <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> flag.IntVar(&amp;port, <span class="hljs-string"><span class="hljs-string">"port"</span></span>, <span class="hljs-number"><span class="hljs-number">4050</span></span>, <span class="hljs-string"><span class="hljs-string">"port to bind to"</span></span>, ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> config *yoogle.Config flagutil.Subset(flags, <span class="hljs-string"><span class="hljs-string">"yoogle"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sub *flag.FlagSet)</span></span></span></span> { config = yooglecfg.Export(sub) }) }</code> </pre> <br><p>  Die Funktion <code>flagutil.Subset()</code> macht eine einfache Sache: Sie fügt ein Präfix hinzu <br>  ( <code>"yoogle"</code> ) zu allen Parametern, die in <code>sub</code> innerhalb des Rückrufs registriert sind. </p><br><p>  Das Ausführen des Programms könnte nun so aussehen: </p><br><pre> <code class="bash hljs">app -port 4050 -yoogle.endpoint https://example.com -yoogle.timeout 10s</code> </pre> <br><h3 id="poluchaem-znacheniya-parametrov">  Parameterwerte abrufen </h3><br><p>  Alle Parameter in <code>flag.FlagSet</code> enthalten die Implementierung von <code>flag.Value</code> , <br>  Das hat eine <code>Set(string) error</code> - das heißt, es bietet eine Gelegenheit <br>  Festlegen der <em>Zeichenfolgendarstellung des Werts</em> . </p><br><p>  Es bleiben Werte aus jeder Quelle in Form von Schlüssel-Wert-Paaren und auszulesen <br>  <code>flag.Set(key, value)</code> aufrufen. </p><br><blockquote>  Dies gibt uns die Möglichkeit, die Syntax der Befehlsparameter nicht einmal zu verwenden <br>  Zeilen im <code>flag</code> Paket beschrieben.  Sie können die Argumente in beliebiger Weise analysieren, <br>  B. wie <a href="https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html">posix-Programmargumente</a> . </blockquote><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { flags := flag.NewFlagSet(<span class="hljs-string"><span class="hljs-string">"my-app"</span></span>, flag.ExitOnError) <span class="hljs-comment"><span class="hljs-comment">// ... flags.String( "config", "/etc/app/config.json", "path to configuration file", ) flagutil.Parse(flags, // First, use posix arguments syntax instead of `flag`. // Just to illustrate that it is possible. flagutil.WithParser(&amp;pargs.Parser{ Args: os.Args[1:], }), // Then lookup for "config" flag value and try to // parse its value as a json configuration file. flagutil.WithParser(&amp;file.Parser{ PathFlag: "config", Syntax: &amp;json.Syntax{}, }), ) }</span></span></code> </pre> <br><p>  Dementsprechend könnte die Datei <code>config.json</code> aussehen: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"port"</span></span>: <span class="hljs-number"><span class="hljs-number">4050</span></span>, <span class="hljs-attr"><span class="hljs-attr">"yoogle"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"endpoint"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://example.com"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"timeout"</span></span>: <span class="hljs-string"><span class="hljs-string">"10s"</span></span> ... } }</code> </pre> <br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Natürlich bin ich nicht der erste, der von einem solchen Ansatz spricht.  Viele von <br>  Die oben beschriebenen Ideen wurden bereits vor einigen Jahren auf die eine oder andere Weise verwendet <br>  Ich habe bei MailRu gearbeitet. </p><br><p>  Also, um die Konfiguration unserer Anwendung zu vereinfachen und keine Zeit zu verschwenden <br>  Es wird vorgeschlagen, das nächste Konfigurationsframework zu studieren (oder sogar zu schreiben) <br>  das Folgende: </p><br><ul><li>  Verwenden Sie <code>flag</code> als <strong>Schnittstelle für die</strong> Parameterdefinition <br>  das Programm </li><li>  Exportieren Sie die Parameter jedes Pakets separat, ohne Kenntnis der Struktur und <br>  eine Möglichkeit, später Werte zu erhalten </li><li>  Definieren Sie, wie Werte, Präfixe und Konfigurationsstrukturen in <code>main</code> gelesen werden sollen </li></ul><br><p>  Die <code>flagutil</code> Bibliothek wurde <code>flagutil</code> meiner Bekanntschaft mit der Bibliothek <code>flagutil</code> <br>  <a href="https://github.com/peterbourgon/ff">Peterbourgon / ff</a> - und ich würde kein <code>flagutil</code> schreiben, wenn nicht für einige <br>  Unstimmigkeiten in Gebrauch. </p><br><p>  Vielen Dank für Ihre Aufmerksamkeit! </p><br><h2 id="ssylki">  Referenzen </h2><br><ul><li>  <a href="https://gbws.io/articles/configuration-in-go/">Englische Version des Artikels</a> </li><li>  <a href="https://golang.org/pkg/flag/">golang.org/pkg/flag</a> </li><li>  <a href="https://github.com/gobwas/flagutil">github.com/gobwas/flagutil</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479882/">https://habr.com/ru/post/de479882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479870/index.html">Wir ändern unterwegs den Rahmen und das Arbeitsprofil - und das nicht nur. Was wird auf der zweiten mitap von PHP NN passieren</a></li>
<li><a href="../de479874/index.html">Wie bin ich zu ThoughtWorks oder einem beispielhaften Interview gekommen?</a></li>
<li><a href="../de479876/index.html">Werden im Rechenzentrum Kissen benötigt?</a></li>
<li><a href="../de479878/index.html">Universal TK für Wi-Fi, mit Erläuterungen</a></li>
<li><a href="../de479880/index.html">Erstellen Sie mit Blueprint wunderschöne Behandlungsgebäude</a></li>
<li><a href="../de479884/index.html">Benutzerdefiniertes CI / CD für Unity</a></li>
<li><a href="../de479886/index.html">Hören statt Sehen: Gehirnneuronen neu konfigurieren, um sie an die Dunkelheit anzupassen</a></li>
<li><a href="../de479888/index.html">Elastische Hochgeschwindigkeitskomprimierung (Fortsetzung)</a></li>
<li><a href="../de479890/index.html">Probleme und Aufgaben bei der Umsetzung des Konzepts des Internet der Dinge</a></li>
<li><a href="../de479892/index.html">Über Gradle-Plugins, Multithreading in verteilten Systemen und Überwachungsautomatisierung: Video von Yandex.Money Metap</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>