<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèΩ ‚ôèÔ∏è üë®üèø‚Äçüé§ Apache Kafka e RabbitMQ: sem√¢ntica e garantia de entrega de mensagens üíÇüèº üÜé üóûÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Preparamos a tradu√ß√£o da pr√≥xima parte do artigo em s√©rie, que compara a funcionalidade do Apache Kafka e RabbitMQ. Esta publica√ß√£o trata de sem√¢ntica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Kafka e RabbitMQ: sem√¢ntica e garantia de entrega de mensagens</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/437446/"><img src="https://habrastorage.org/webt/9w/ar/yb/9warybopprmxno4cvxzuvswgexu.jpeg"><br><br>  Preparamos a tradu√ß√£o da pr√≥xima parte do artigo em s√©rie, que compara a funcionalidade do Apache Kafka e RabbitMQ.  Esta publica√ß√£o trata de sem√¢ntica e garantias de entrega de mensagens.  Observe que o autor levou em conta o Kafka at√© a vers√£o 0.10 inclusive, e na vers√£o 0.11 apareceu exatamente uma vez.  No entanto, o artigo permanece relevante e √© cheio de pontos √∫teis do ponto de vista pr√°tico. <br>  Pe√ßas anteriores: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segundo</a> . <br><a name="habracut"></a><br>  O RabbitMQ e o Kafka oferecem garantias confi√°veis ‚Äã‚Äãde entrega de mensagens.  Ambas as plataformas oferecem garantias nos princ√≠pios de "entrega no m√°ximo √∫nica" e "pelo menos entrega √∫nica", mas com o princ√≠pio de "entrega √∫nica e rigorosa", as garantias da Kafka se aplicam de acordo com um cen√°rio muito limitado. <br><br>  Primeiro, vamos descobrir o que essas garantias significam: <br><br><ul><li>  Entrega no m√°ximo.  Isso significa que a mensagem n√£o pode ser entregue mais de uma vez.  No entanto, a mensagem pode ser perdida. </li><li>  Pelo menos uma vez entrega.  Isso significa que a mensagem nunca ser√° perdida.  Nesse caso, a mensagem pode ser entregue mais de uma vez. </li><li>  Entrega exatamente uma vez.  O Santo Graal dos sistemas de mensagens.  Todas as mensagens s√£o entregues estritamente uma vez. </li></ul><br>  A palavra "entrega" aqui provavelmente n√£o ser√° um termo exato.  Seria mais preciso dizer "processamento".  De qualquer forma, o que nos interessa agora √© se o consumidor pode processar mensagens e por que princ√≠pio isso acontece: ‚Äún√£o mais que um‚Äù, ‚Äúpelo menos um‚Äù ou ‚Äúestritamente uma vez‚Äù.  Mas a palavra ‚Äúprocessamento‚Äù complica a percep√ß√£o, e a express√£o ‚Äúentrega pelo princ√≠pio de 'estritamente uma vez'‚Äù neste caso n√£o ser√° uma defini√ß√£o precisa, porque pode ser necess√°rio entregar a mensagem duas vezes para process√°-la adequadamente uma vez.  Se o destinat√°rio desconectado durante o processamento, a mensagem dever√° ser enviada novamente para o novo destinat√°rio. <br><br>  O segundo  Discutindo a quest√£o do processamento de mensagens, chegamos ao t√≥pico de falhas parciais, que √© uma dor de cabe√ßa para os desenvolvedores.  No processo de processamento da mensagem, h√° v√°rias etapas.  Consiste em sess√µes de comunica√ß√£o entre o aplicativo e o sistema de mensagens no in√≠cio e no final e o pr√≥prio aplicativo trabalhando com os dados no meio.  Os cen√°rios de falha parcial do aplicativo devem ser tratados pelo pr√≥prio aplicativo.  Se as opera√ß√µes executadas forem completamente transacionais e os resultados forem formulados com base no princ√≠pio de "tudo ou nada", poder√£o ser evitadas falhas parciais na l√≥gica do aplicativo.  Mas muitas vezes, muitos est√°gios incluem intera√ß√£o com outros sistemas, onde a transacionalidade √© imposs√≠vel.  Se incluirmos na intera√ß√£o os relacionamentos entre sistemas de mensagens, aplicativos, cache e banco de dados, podemos garantir o processamento ‚Äúapenas uma vez‚Äù?  A resposta √© n√£o. <br><br>  A estrat√©gia "estritamente uma vez" √© limitada a um cen√°rio em que o √∫nico destinat√°rio das mensagens processadas √© a pr√≥pria plataforma de mensagens, e essa plataforma fornece transa√ß√µes completas.  Nesse cen√°rio limitado, voc√™ pode processar mensagens, grav√°-las, enviar sinais de que foram processadas como parte de uma transa√ß√£o feita com base no princ√≠pio de "tudo ou nada".  √â fornecido pela biblioteca Kafka Streams. <br><br>  Mas se o processamento de mensagens for sempre idempotente, voc√™ poder√° evitar a necessidade de implementar a estrat√©gia "estritamente uma vez" por meio de transa√ß√µes.  Se o processamento final de mensagens for idempotente, voc√™ pode se preocupar em aceitar duplicatas.  Mas nem todas as a√ß√µes podem ser implementadas idempotentemente. <br><br>  <b>Alerta de ponta a ponta</b> <br><br>  O que n√£o est√° representado em nenhum dispositivo de todos os sistemas de mensagens com os quais trabalhei √© a confirma√ß√£o de ponta a ponta.  Dado que uma mensagem pode ser enfileirada no RabbitMQ, a notifica√ß√£o de ponta a ponta n√£o faz sentido.  No Kafka, da mesma forma, v√°rios grupos diferentes de destinat√°rios podem ler informa√ß√µes simultaneamente de um t√≥pico.  Na minha experi√™ncia, alertas de ponta a ponta s√£o o que as pessoas que s√£o novas no conceito de mensagens geralmente pedem.  Nesses casos, √© melhor explicar imediatamente que isso n√£o √© poss√≠vel. <br><br>  <b>Cadeia de responsabilidade</b> <br><br>  Em geral, as fontes de mensagens n√£o podem saber que suas mensagens s√£o entregues aos destinat√°rios.  Eles s√≥ podem saber que o sistema de mensagens recebeu suas mensagens e assumiu a responsabilidade de garantir seu armazenamento e entrega seguros.  H√° uma cadeia de responsabilidades, que come√ßa com a fonte, passa pelo sistema de mensagens e termina no destinat√°rio.  Todos devem cumprir corretamente seus deveres e transmitir claramente a mensagem para a pr√≥xima.  Isso significa que voc√™, como desenvolvedor, deve projetar corretamente seus aplicativos para evitar a perda ou uso indevido de mensagens enquanto elas est√£o sob seu controle. <br><br>  <b>Procedimento de transfer√™ncia de mensagens</b> <br><br>  Este artigo √© dedicado principalmente a como cada plataforma fornece estrat√©gias de envio ‚Äúpelo menos uma‚Äù e ‚Äún√£o mais que uma‚Äù.  Mas ainda h√° uma ordem de mensagens.  Nas partes anteriores desta s√©rie, escrevi sobre a ordem em que as mensagens s√£o enviadas e a ordem em que s√£o processadas, e aconselho que voc√™ consulte essas partes. <br><br>  Em suma, o RabbitMQ e o Kafka fornecem uma garantia de primeiro a entrar, primeiro a sair (FIFO).  O RabbitMQ mant√©m esse pedido no n√≠vel da fila e Kafka no n√≠vel de segmenta√ß√£o.  As implica√ß√µes de tais decis√µes de design foram discutidas em artigos anteriores. <br><br>  <b>Garantias de entrega no RabbitMQ</b> <br><br>  As garantias de entrega s√£o fornecidas: <br><br><ul><li>  confiabilidade da mensagem - eles n√£o desaparecer√£o enquanto armazenados no RabbitMQ; </li><li>  notifica√ß√µes de mensagem - o RabbitMQ troca sinais com remetentes e destinat√°rios. </li></ul><br><h4>  Elementos de confiabilidade </h4><br>  <b>Espelhamento de Filas</b> <br><br>  As filas podem ser espelhadas (replicadas) em muitos n√≥s (servidores).  Cada fila possui uma fila principal em um dos n√≥s.  Por exemplo, existem tr√™s n√≥s, 10 filas e duas r√©plicas por fila.  10 filas de controle e 20 r√©plicas ser√£o distribu√≠das por tr√™s n√≥s.  A distribui√ß√£o das filas de controle por n√≥s pode ser configurada.  No caso de um n√≥ congelar: <br><br><ul><li>  em vez de cada fila principal no n√≥ travado, uma r√©plica dessa fila √© fornecida em outro n√≥; </li><li>  novas r√©plicas s√£o criadas em outros n√≥s para substituir as r√©plicas perdidas no n√≥ de sa√≠da, dando suporte ao fator de replica√ß√£o. </li></ul><br>  A quest√£o da toler√¢ncia a falhas ser√° discutida na pr√≥xima parte do artigo. <br><br>  <b>Filas confi√°veis</b> <br><br>  Existem dois tipos de filas no RabbitMQ: confi√°veis ‚Äã‚Äãe n√£o confi√°veis.  Filas confi√°veis ‚Äã‚Äãs√£o gravadas no disco e salvas no caso de uma reinicializa√ß√£o do n√≥.  Quando o n√≥ inicia, eles s√£o substitu√≠dos. <br><br>  <b>Postagens persistentes</b> <br><br>  Se a fila for confi√°vel, isso n√£o significa que suas mensagens ser√£o salvas quando o n√≥ for reinicializado.  Somente as mensagens marcadas como persistentes pelo remetente ser√£o recuperadas. <br><br>  Ao trabalhar no RabbitMQ, quanto mais confi√°vel a mensagem, menor o desempenho poss√≠vel.  Se houver um fluxo de eventos em tempo real e n√£o for cr√≠tico perder v√°rios deles ou um pequeno intervalo de tempo do fluxo, √© melhor n√£o usar a replica√ß√£o de fila e transmitir todas as mensagens como inst√°veis.  Por√©m, se n√£o for desej√°vel perder mensagens devido ao mau funcionamento de um n√≥, √© melhor usar filas confi√°veis ‚Äã‚Äãcom replica√ß√£o e mensagens est√°veis. <br><br><h4>  Notifica√ß√µes de mensagem </h4><br>  <b>Mensagens</b> <br><br>  As mensagens podem ser perdidas ou duplicadas durante a transmiss√£o.  Depende do comportamento do remetente. <br><br>  <i>‚ÄúAtirou e esqueceu‚Äù</i> <br><br>  A fonte pode decidir n√£o solicitar a confirma√ß√£o do destinat√°rio (notifica√ß√£o de recebimento de uma mensagem ao remetente) e simplesmente enviar a mensagem automaticamente.  As mensagens n√£o ser√£o duplicadas, mas poder√£o ser perdidas (o que satisfaz a estrat√©gia de "entrega √∫nica m√°xima"). <br><br>  <i>Confirma√ß√µes ao remetente</i> <br><br>  Quando o remetente abre um canal para o broker de filas, ele pode usar o mesmo canal para enviar confirma√ß√µes.  Agora, em resposta √† mensagem recebida, o broker da fila deve fornecer uma das duas coisas: <br><br><ul><li>  basic.ack.  Confirma√ß√£o positiva.  A mensagem √© recebida, a responsabilidade por ela agora cabe ao RabbitMQ; </li><li>  basic.nack.  Confirma√ß√£o negativa.  Algo aconteceu e a mensagem n√£o foi processada.  A responsabilidade por isso permanece na fonte.  Se desejar, ele pode enviar uma mensagem uma segunda vez. </li></ul><br>  Al√©m das notifica√ß√µes de entrega positiva e negativa, √© fornecida uma mensagem basic.return.  √Äs vezes, o remetente precisa saber n√£o apenas que a mensagem chegou no RabbitMQ, mas tamb√©m que realmente caiu em uma ou mais filas.  Pode acontecer que a origem envie uma mensagem para o sistema de troca de t√≥picos, no qual a mensagem n√£o √© roteada para nenhuma das filas de entrega.  Nessa situa√ß√£o, o broker simplesmente descarta a mensagem.  Em alguns cen√°rios, isso √© normal; em outros, a fonte deve saber se a mensagem foi descartada e prosseguir de acordo com isso.  Voc√™ pode definir o sinalizador "Obrigat√≥rio" para mensagens individuais e, se a mensagem n√£o tiver sido definida em nenhuma fila de entrega, o basic.return ser√° retornado ao remetente. <br><br>  A fonte pode aguardar confirma√ß√£o ap√≥s o envio de cada mensagem, mas isso reduzir√° bastante seu desempenho.  Em vez disso, as fontes podem enviar um fluxo constante de mensagens, definindo um limite para o n√∫mero de mensagens n√£o reconhecidas.  Quando o limite de mensagens provis√≥rias for atingido, o envio ser√° interrompido at√© que todas as confirma√ß√µes sejam recebidas. <br><br>  Agora que existem muitas mensagens em tr√¢nsito do remetente para o RabbitMQ, as confirma√ß√µes s√£o agrupadas usando o sinalizador m√∫ltiplo para melhorar o desempenho.  Todas as mensagens enviadas pelo canal recebem um valor inteiro monotonicamente crescente, o ‚ÄúN√∫mero de Sequ√™ncia‚Äù.  A notifica√ß√£o de uma mensagem inclui o n√∫mero de sequ√™ncia da mensagem correspondente.  E se, ao mesmo tempo, o valor for m√∫ltiplo = verdadeiro, o remetente dever√° rastrear os n√∫meros de sequ√™ncia de suas mensagens para saber quais mensagens foram entregues com √™xito e quais n√£o.  Eu escrevi um artigo detalhado sobre este t√≥pico. <br><br>  Gra√ßas √†s confirma√ß√µes, evitamos a perda de mensagens das seguintes maneiras: <br><br><ul><li>  reenviar mensagens em caso de notifica√ß√£o negativa; </li><li>  armazenamento cont√≠nuo de mensagens em algum lugar em caso de notifica√ß√£o negativa ou retorno b√°sico. </li></ul><br>  <i>Transa√ß√µes</i> <br><br>  As transa√ß√µes raramente s√£o usadas no RabbitMQ pelos seguintes motivos: <br><br><ul><li>  Fracas garantias.  Se as mensagens forem roteadas para v√°rias filas ou tiverem um √≠cone obrigat√≥rio, a continuidade da transa√ß√£o n√£o ser√° suportada; </li><li>  Baixa produtividade. </li></ul><br>  Sinceramente, nunca as usei, elas n√£o d√£o garantias adicionais, exceto as confirma√ß√µes ao remetente, e apenas aumentam a incerteza na quest√£o de como interpretar o aviso de recebimento de mensagens decorrentes da conclus√£o das transa√ß√µes. <br><br>  <i>Erros de comunica√ß√£o / canal</i> <br><br>  Al√©m das notifica√ß√µes de recebimento de mensagens, o remetente deve ter em mente as falhas das ferramentas de comunica√ß√£o e dos intermedi√°rios.  Ambos esses fatores levam √† perda do canal de comunica√ß√£o.  Com a perda de canais, a oportunidade de receber notifica√ß√µes ainda n√£o recebidas de recebimento de mensagens desaparece.  Aqui, o remetente deve escolher entre o risco de perda de mensagem e o risco de duplica√ß√£o. <br><br>  A falha do intermedi√°rio pode ocorrer quando a mensagem estava no buffer do sistema operacional ou pr√©-processada e a mensagem ser√° perdida.  Ou, talvez a mensagem estivesse na fila, mas o intermedi√°rio da mensagem morreu antes de enviar uma confirma√ß√£o.  Nesse caso, a mensagem ser√° entregue com sucesso. <br><br>  Da mesma forma, a falha dos meios de comunica√ß√£o afeta a situa√ß√£o.  Ocorreu uma falha durante a transmiss√£o da mensagem?  Ou depois que a mensagem foi colocada na fila, mas antes de receber uma notifica√ß√£o positiva? <br><br>  O remetente n√£o pode determinar isso; portanto, ele deve escolher uma das seguintes op√ß√µes: <br><br><ul><li>  N√£o encaminhe a mensagem, criando um risco de perda; </li><li>  reenvie a mensagem e crie um risco de duplica√ß√£o. </li></ul><br>  Se muitas mensagens de remetente estiverem em tr√¢nsito, o problema ficar√° mais complicado.  A √∫nica coisa que o remetente pode fazer √© dar uma dica aos destinat√°rios adicionando um cabe√ßalho especial √† mensagem, indicando que a mensagem est√° sendo enviada pela segunda vez.  Os destinat√°rios podem decidir verificar as mensagens quanto √† presen√ßa desses cabe√ßalhos e, se forem encontrados, verificar adicionalmente as mensagens recebidas em busca de duplicatas (se essa verifica√ß√£o n√£o tiver sido executada anteriormente). <br><br><h4>  Destinat√°rios </h4><br>  Existem duas op√ß√µes dispon√≠veis para os destinat√°rios para receber notifica√ß√µes: <br><br><ul><li>  sem modo de notifica√ß√£o; </li><li>  modo de notifica√ß√£o manual. </li></ul><br>  <i>Sem modo de notifica√ß√£o</i> <br><br>  Ele √© um modo de notifica√ß√µes autom√°ticas.  E ele √© perigoso.  Primeiro de tudo, porque quando uma mensagem entra no seu aplicativo, ela √© removida da fila.  Isso pode levar √† perda de mensagens se: <br><br><ul><li>  a conex√£o foi interrompida antes que a mensagem fosse recebida; </li><li>  a mensagem ainda est√° no buffer interno e o aplicativo foi desativado; </li><li>  O processamento da mensagem falhou. </li></ul><br>  Al√©m disso, estamos perdendo mecanismos de contrapress√£o como forma de monitorar a qualidade da entrega de mensagens.  Ao definir o modo de envio de notifica√ß√µes manualmente, voc√™ pode definir uma pr√©-busca (ou definir o n√≠vel de servi√ßos fornecidos, QoS) para limitar o n√∫mero √∫nico de mensagens que o sistema ainda n√£o confirmou o recebimento.  Sem isso, o RabbitMQ envia mensagens o mais r√°pido que a conex√£o permite, e isso pode ser mais r√°pido do que o receptor pode process√°-las.  Como resultado, os buffers est√£o cheios e ocorrem erros de mem√≥ria. <br><br>  <i>Modo de notifica√ß√£o manual</i> <br><br>  O destinat√°rio deve enviar manualmente uma notifica√ß√£o de recebimento de cada mensagem.  Ele pode definir uma pr√©-busca caso o n√∫mero de mensagens seja mais de uma e processar muitas mensagens ao mesmo tempo.  Ele pode decidir enviar uma notifica√ß√£o para cada mensagem ou aplicar o sinalizador m√∫ltiplo e enviar v√°rias notifica√ß√µes por vez.  O agrupamento de notifica√ß√µes melhora o desempenho. <br><br>  Quando o destinat√°rio abre o canal, as mensagens que passam por ele cont√™m o par√¢metro Tag de entrega, cujo valor √© um n√∫mero inteiro, aumentando monotonicamente.  Ele est√° inclu√≠do em todas as notifica√ß√µes de recebimento e √© usado como identificador da mensagem. <br><br>  As notifica√ß√µes podem ser as seguintes: <br><br><ul><li>  basic.ack.  Depois disso, o RabbitMQ remove a mensagem da fila.  O sinalizador m√∫ltiplo pode ser aplicado aqui. </li><li>  basic.nack.  O destinat√°rio deve definir um sinalizador para informar ao RabbitMQ se deve enfileirar a mensagem novamente.  Ao redefinir a mensagem vai para o in√≠cio da fila.  A partir da√≠, ele √© enviado ao destinat√°rio novamente (mesmo para o mesmo destinat√°rio).  A notifica√ß√£o basic.nack suporta o sinalizador m√∫ltiplo. </li><li>  basic.reject.  O mesmo que basic.nack, mas n√£o suporta o sinalizador m√∫ltiplo. </li></ul><br>  Assim, semanticamente basic.ack e basic.nack com requeue = false s√£o os mesmos.  Ambos os operadores significam remover uma mensagem da fila. <br><br>  A pr√≥xima pergunta √© quando enviar notifica√ß√µes de recebimento.  Se a mensagem foi processada rapidamente, conv√©m enviar uma notifica√ß√£o imediatamente ap√≥s a conclus√£o desta opera√ß√£o (com ou sem √™xito).  Mas se a mensagem estava na fila RabbitMQ e o processamento leva muitos minutos?  Enviar uma notifica√ß√£o depois disso ser√° problem√°tico, porque se o canal fechar, todas as mensagens para as quais n√£o houve notifica√ß√µes ser√£o retornadas para a fila e o envio ser√° feito uma segunda vez. <br><br>  <b>Erro de conex√£o / agente de mensagens</b> <br><br>  Se a conex√£o foi desconectada ou ocorreu um erro no broker, ap√≥s o qual o canal deixa de funcionar, todas as mensagens cujo recebimento n√£o foi confirmado ser√£o novamente enfileiradas e encaminhadas.  Isso √© bom porque evita a perda de dados, mas ruim porque causa duplica√ß√£o excessiva. <br><br>  Quanto mais tempo o destinat√°rio receber mensagens por um longo per√≠odo, cuja confirma√ß√£o ele n√£o confirmou, maior ser√° o risco de encaminhamento.  Quando uma mensagem √© reenviada, RabbitMQ para o sinalizador de encaminhamento √© definido como true.  Por esse motivo, o destinat√°rio tem pelo menos uma indica√ß√£o de que a mensagem j√° pode ter sido processada. <br><br>  <b>Idempot√™ncia</b> <br><br>  Se a idempot√™ncia for necess√°ria e garantir que nenhuma mensagem seja perdida, alguma verifica√ß√£o duplicada ou outros esquemas idempotentes devem ser incorporados.  Se a verifica√ß√£o de mensagens duplicadas for muito cara, voc√™ poder√° aplicar uma estrat√©gia na qual o remetente sempre adicione um cabe√ßalho especial para reenviar mensagens e o destinat√°rio verificar√° as mensagens recebidas quanto √† presen√ßa de um cabe√ßalho e um sinalizador de reenvio. <br><br><h4>  Conclus√£o </h4><br>  O RabbitMQ fornece garantias confi√°veis ‚Äã‚Äãe de longo prazo para mensagens, mas h√° muitas situa√ß√µes em que elas n√£o ajudam. <br><br>  Aqui est√° uma lista de pontos a serem lembrados: <br><br><ul><li>  Voc√™ deve usar espelhamento de fila, filas confi√°veis, mensagens persistentes, confirma√ß√µes para o remetente, um sinalizador de confirma√ß√£o e notifica√ß√£o for√ßada do destinat√°rio se forem necess√°rias garantias confi√°veis ‚Äã‚Äãna estrat√©gia de "pelo menos entrega √∫nica". </li><li>  Se o envio for realizado como parte da estrat√©gia de "pelo menos entrega √∫nica", pode ser necess√°rio adicionar um mecanismo para deduplica√ß√£o ou idempot√™ncia ao duplicar os dados que est√£o sendo enviados. </li><li>  Se o problema da perda de mensagens n√£o for t√£o importante quanto o da velocidade de entrega e alta escalabilidade, pense em sistemas sem redund√¢ncia, sem mensagens persistentes e sem reconhecimento no lado da fonte.  No entanto, eu preferiria deixar notifica√ß√µes for√ßadas do destinat√°rio para controlar o fluxo de mensagens recebidas alterando as restri√ß√µes de pr√©-busca.  Nesse caso, voc√™ precisar√° enviar notifica√ß√µes em lotes e usar o sinalizador "m√∫ltiplo". </li></ul><br>  <b>Garantias de entrega em Kafka</b> <br><br>  As garantias de entrega s√£o fornecidas: <br><br><ul><li>  durabilidade da mensagem - as mensagens armazenadas em um segmento n√£o s√£o perdidas; </li><li>  Notifica√ß√µes de mensagens - a troca de sinais entre o Kafka (e possivelmente o reposit√≥rio Apache Zookeeper), por um lado, e a fonte / receptor, por outro. </li></ul><br>  <b>Duas palavras sobre o empacotamento de mensagens</b> <br><br>  Uma das diferen√ßas entre o RabbitMQ e o Kafka √© o uso de pacotes para mensagens. <br><br>  O RabbitMQ fornece algo semelhante √† embalagem, gra√ßas a: <br><br><ul><li>  Suspenda o envio de todas as mensagens X at√© que todas as notifica√ß√µes sejam recebidas.  O RabbitMQ geralmente agrupa notifica√ß√µes usando o sinalizador "m√∫ltiplo". </li><li>    ¬´prefetch¬ª      ¬´multiple¬ª. </li></ul><br>       .                  ‚Äúmultiple‚Äù.     TCP. <br><br> Kafka     .    ,           .     RabbitMQ,      ,    ,      .         ,         . <br><br> Kafka        ,      ,     .      ,          .     RabbitMQ   API    ,                  . RabbitMQ         . <br><br> <b>,  </b> <br><br> <i> </i> <br><br>      Kafka   -    ,       ,      .       .   ,   ,  , ,        ,      . <br><br> Kafka     (In Sync Replicas, ISR).          .        ,   ,     (   10 ).    ,      .    -  ,       ..               .        . <br><br> <i>      </i> <br><br>  ,  Kafka  ,  ,    , Kafka               . <br><br> <i>     </i> <br><br>    ,     Kafka,      ,    : <br><br><ul><li>  ,  . Acks=0. </li><li>     . Acks=1 </li><li>           . Acks=All </li></ul><br>          ,    RabbitMQ.         ,      ,        (   ,    ).   ,          . <br><br>   Kafka       .        : <br><br><ul><li>  enable.idempotence   ‚Äútrue‚Äù, </li><li>  max.in.flight.requests.per.connection   5  , </li><li>  retries   1  , </li><li>  acks   ‚Äúall‚Äù. </li></ul><br> ,          acks=0/1   ,     . <br><br> <i>  </i> <br><br>        ,           ,   .       ZooKeeper    Kafka. <br><br>        (),       ,       : <br><br><ul><li> .          .                 .          .         ,      . </li><li> ,    .      ‚Äú   ‚Äù.    ,      ;     ,    . ,  10         ,    4 ,   ,      ,     ; </li><li>  ,    .      ‚Äú   ‚Äù.  ,      ,      ,           . ,  10         ,       ,  4    ; </li><li> .    ,     . </li></ul><br>  ‚Äú  ‚Äù  Kafka Streams,    Java.   Java      .    ‚Äú  ‚Äù,      ,    ,           . ,         ,      ‚Äú  ‚Äù  .           ,       ,   ()      . <br><br> ,  Kafka Streams,          ,       ,      ‚Äú  ‚Äù.       Kafka:             .    ,    .    ,    ,   ,        (   ),   . <br><br> <b>    </b> <br><br>      Kafka     ‚Äú--‚Äù.         .   ,   ,  . <br><br>        ‚Äú ‚Äù,    ,      (,  , ).      ‚Äú ‚Äù,    ,      .       . <br><br>   :    ‚Äú  ‚Äù      ?    .        ,     ,    .     .     (Last Stable Offset, LSO) ‚Äî      ;     ‚Äú  ‚Äù      . <br><br>  <b>Conclus√µes</b> <br><br>         .   ,    ,      .   ,     Kafka      ,                . <br><br><h4>  Resumir </h4><br><ul><li>      ‚Äú   ‚Äù  ‚Äú   ‚Äù. </li><li>     . </li><li>      ,              . Kafka    ,      . </li><li>       ,   ,        . </li><li>        . </li><li> Kafka   ,      ‚Äú--‚Äù.          . </li><li>  Kafka,       -         ,        (   ).  RabbitMQ    . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O Kafka pode aumentar os benef√≠cios da pacote devido aos seus recursos de distribui√ß√£o de pacotes, e o RabbitMQ n√£o possui pacote devido a um modelo de recebimento passivo que n√£o impede conflitos de destinat√°rios. </font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437446/">https://habr.com/ru/post/pt437446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437436/index.html">Executando o visualizador de imagens do Windows XP no Windows moderno</a></li>
<li><a href="../pt437438/index.html">Audiotecnologia: como os peda√ßos de pl√°stico s√£o movidos usando o ultra-som e por que √© necess√°rio</a></li>
<li><a href="../pt437440/index.html">Feliz dia do aluno, programador</a></li>
<li><a href="../pt437442/index.html">Respostas de suporte t√©cnico da 3CX: configure o roteador para o servidor PBX VoIP</a></li>
<li><a href="../pt437444/index.html">Um balde de alcatr√£o em um barril de mel ou Sobre um potencial choque cultural para propriet√°rios de tratores</a></li>
<li><a href="../pt437448/index.html">28 de janeiro na R√∫ssia, o sistema de pagamentos r√°pidos sem comiss√£o (por n√∫mero de telefone)</a></li>
<li><a href="../pt437450/index.html">Como conheci o OpenCV ou em busca do ColorChecker</a></li>
<li><a href="../pt437454/index.html">Revis√£o do aritm√¥metro Felix M</a></li>
<li><a href="../pt437456/index.html">Mais jovem: Revis√£o dos telefones IP Snom D315 e D305</a></li>
<li><a href="../pt437458/index.html">Registro obrigat√≥rio pela oferta do IMEI para efetuar pagamentos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>