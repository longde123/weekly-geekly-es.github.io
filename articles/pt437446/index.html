<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏽 ♏️ 👨🏿‍🎤 Apache Kafka e RabbitMQ: semântica e garantia de entrega de mensagens 💂🏼 🆎 🗞️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Preparamos a tradução da próxima parte do artigo em série, que compara a funcionalidade do Apache Kafka e RabbitMQ. Esta publicação trata de semântica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Kafka e RabbitMQ: semântica e garantia de entrega de mensagens</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/437446/"><img src="https://habrastorage.org/webt/9w/ar/yb/9warybopprmxno4cvxzuvswgexu.jpeg"><br><br>  Preparamos a tradução da próxima parte do artigo em série, que compara a funcionalidade do Apache Kafka e RabbitMQ.  Esta publicação trata de semântica e garantias de entrega de mensagens.  Observe que o autor levou em conta o Kafka até a versão 0.10 inclusive, e na versão 0.11 apareceu exatamente uma vez.  No entanto, o artigo permanece relevante e é cheio de pontos úteis do ponto de vista prático. <br>  Peças anteriores: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segundo</a> . <br><a name="habracut"></a><br>  O RabbitMQ e o Kafka oferecem garantias confiáveis ​​de entrega de mensagens.  Ambas as plataformas oferecem garantias nos princípios de "entrega no máximo única" e "pelo menos entrega única", mas com o princípio de "entrega única e rigorosa", as garantias da Kafka se aplicam de acordo com um cenário muito limitado. <br><br>  Primeiro, vamos descobrir o que essas garantias significam: <br><br><ul><li>  Entrega no máximo.  Isso significa que a mensagem não pode ser entregue mais de uma vez.  No entanto, a mensagem pode ser perdida. </li><li>  Pelo menos uma vez entrega.  Isso significa que a mensagem nunca será perdida.  Nesse caso, a mensagem pode ser entregue mais de uma vez. </li><li>  Entrega exatamente uma vez.  O Santo Graal dos sistemas de mensagens.  Todas as mensagens são entregues estritamente uma vez. </li></ul><br>  A palavra "entrega" aqui provavelmente não será um termo exato.  Seria mais preciso dizer "processamento".  De qualquer forma, o que nos interessa agora é se o consumidor pode processar mensagens e por que princípio isso acontece: “não mais que um”, “pelo menos um” ou “estritamente uma vez”.  Mas a palavra “processamento” complica a percepção, e a expressão “entrega pelo princípio de 'estritamente uma vez'” neste caso não será uma definição precisa, porque pode ser necessário entregar a mensagem duas vezes para processá-la adequadamente uma vez.  Se o destinatário desconectado durante o processamento, a mensagem deverá ser enviada novamente para o novo destinatário. <br><br>  O segundo  Discutindo a questão do processamento de mensagens, chegamos ao tópico de falhas parciais, que é uma dor de cabeça para os desenvolvedores.  No processo de processamento da mensagem, há várias etapas.  Consiste em sessões de comunicação entre o aplicativo e o sistema de mensagens no início e no final e o próprio aplicativo trabalhando com os dados no meio.  Os cenários de falha parcial do aplicativo devem ser tratados pelo próprio aplicativo.  Se as operações executadas forem completamente transacionais e os resultados forem formulados com base no princípio de "tudo ou nada", poderão ser evitadas falhas parciais na lógica do aplicativo.  Mas muitas vezes, muitos estágios incluem interação com outros sistemas, onde a transacionalidade é impossível.  Se incluirmos na interação os relacionamentos entre sistemas de mensagens, aplicativos, cache e banco de dados, podemos garantir o processamento “apenas uma vez”?  A resposta é não. <br><br>  A estratégia "estritamente uma vez" é limitada a um cenário em que o único destinatário das mensagens processadas é a própria plataforma de mensagens, e essa plataforma fornece transações completas.  Nesse cenário limitado, você pode processar mensagens, gravá-las, enviar sinais de que foram processadas como parte de uma transação feita com base no princípio de "tudo ou nada".  É fornecido pela biblioteca Kafka Streams. <br><br>  Mas se o processamento de mensagens for sempre idempotente, você poderá evitar a necessidade de implementar a estratégia "estritamente uma vez" por meio de transações.  Se o processamento final de mensagens for idempotente, você pode se preocupar em aceitar duplicatas.  Mas nem todas as ações podem ser implementadas idempotentemente. <br><br>  <b>Alerta de ponta a ponta</b> <br><br>  O que não está representado em nenhum dispositivo de todos os sistemas de mensagens com os quais trabalhei é a confirmação de ponta a ponta.  Dado que uma mensagem pode ser enfileirada no RabbitMQ, a notificação de ponta a ponta não faz sentido.  No Kafka, da mesma forma, vários grupos diferentes de destinatários podem ler informações simultaneamente de um tópico.  Na minha experiência, alertas de ponta a ponta são o que as pessoas que são novas no conceito de mensagens geralmente pedem.  Nesses casos, é melhor explicar imediatamente que isso não é possível. <br><br>  <b>Cadeia de responsabilidade</b> <br><br>  Em geral, as fontes de mensagens não podem saber que suas mensagens são entregues aos destinatários.  Eles só podem saber que o sistema de mensagens recebeu suas mensagens e assumiu a responsabilidade de garantir seu armazenamento e entrega seguros.  Há uma cadeia de responsabilidades, que começa com a fonte, passa pelo sistema de mensagens e termina no destinatário.  Todos devem cumprir corretamente seus deveres e transmitir claramente a mensagem para a próxima.  Isso significa que você, como desenvolvedor, deve projetar corretamente seus aplicativos para evitar a perda ou uso indevido de mensagens enquanto elas estão sob seu controle. <br><br>  <b>Procedimento de transferência de mensagens</b> <br><br>  Este artigo é dedicado principalmente a como cada plataforma fornece estratégias de envio “pelo menos uma” e “não mais que uma”.  Mas ainda há uma ordem de mensagens.  Nas partes anteriores desta série, escrevi sobre a ordem em que as mensagens são enviadas e a ordem em que são processadas, e aconselho que você consulte essas partes. <br><br>  Em suma, o RabbitMQ e o Kafka fornecem uma garantia de primeiro a entrar, primeiro a sair (FIFO).  O RabbitMQ mantém esse pedido no nível da fila e Kafka no nível de segmentação.  As implicações de tais decisões de design foram discutidas em artigos anteriores. <br><br>  <b>Garantias de entrega no RabbitMQ</b> <br><br>  As garantias de entrega são fornecidas: <br><br><ul><li>  confiabilidade da mensagem - eles não desaparecerão enquanto armazenados no RabbitMQ; </li><li>  notificações de mensagem - o RabbitMQ troca sinais com remetentes e destinatários. </li></ul><br><h4>  Elementos de confiabilidade </h4><br>  <b>Espelhamento de Filas</b> <br><br>  As filas podem ser espelhadas (replicadas) em muitos nós (servidores).  Cada fila possui uma fila principal em um dos nós.  Por exemplo, existem três nós, 10 filas e duas réplicas por fila.  10 filas de controle e 20 réplicas serão distribuídas por três nós.  A distribuição das filas de controle por nós pode ser configurada.  No caso de um nó congelar: <br><br><ul><li>  em vez de cada fila principal no nó travado, uma réplica dessa fila é fornecida em outro nó; </li><li>  novas réplicas são criadas em outros nós para substituir as réplicas perdidas no nó de saída, dando suporte ao fator de replicação. </li></ul><br>  A questão da tolerância a falhas será discutida na próxima parte do artigo. <br><br>  <b>Filas confiáveis</b> <br><br>  Existem dois tipos de filas no RabbitMQ: confiáveis ​​e não confiáveis.  Filas confiáveis ​​são gravadas no disco e salvas no caso de uma reinicialização do nó.  Quando o nó inicia, eles são substituídos. <br><br>  <b>Postagens persistentes</b> <br><br>  Se a fila for confiável, isso não significa que suas mensagens serão salvas quando o nó for reinicializado.  Somente as mensagens marcadas como persistentes pelo remetente serão recuperadas. <br><br>  Ao trabalhar no RabbitMQ, quanto mais confiável a mensagem, menor o desempenho possível.  Se houver um fluxo de eventos em tempo real e não for crítico perder vários deles ou um pequeno intervalo de tempo do fluxo, é melhor não usar a replicação de fila e transmitir todas as mensagens como instáveis.  Porém, se não for desejável perder mensagens devido ao mau funcionamento de um nó, é melhor usar filas confiáveis ​​com replicação e mensagens estáveis. <br><br><h4>  Notificações de mensagem </h4><br>  <b>Mensagens</b> <br><br>  As mensagens podem ser perdidas ou duplicadas durante a transmissão.  Depende do comportamento do remetente. <br><br>  <i>“Atirou e esqueceu”</i> <br><br>  A fonte pode decidir não solicitar a confirmação do destinatário (notificação de recebimento de uma mensagem ao remetente) e simplesmente enviar a mensagem automaticamente.  As mensagens não serão duplicadas, mas poderão ser perdidas (o que satisfaz a estratégia de "entrega única máxima"). <br><br>  <i>Confirmações ao remetente</i> <br><br>  Quando o remetente abre um canal para o broker de filas, ele pode usar o mesmo canal para enviar confirmações.  Agora, em resposta à mensagem recebida, o broker da fila deve fornecer uma das duas coisas: <br><br><ul><li>  basic.ack.  Confirmação positiva.  A mensagem é recebida, a responsabilidade por ela agora cabe ao RabbitMQ; </li><li>  basic.nack.  Confirmação negativa.  Algo aconteceu e a mensagem não foi processada.  A responsabilidade por isso permanece na fonte.  Se desejar, ele pode enviar uma mensagem uma segunda vez. </li></ul><br>  Além das notificações de entrega positiva e negativa, é fornecida uma mensagem basic.return.  Às vezes, o remetente precisa saber não apenas que a mensagem chegou no RabbitMQ, mas também que realmente caiu em uma ou mais filas.  Pode acontecer que a origem envie uma mensagem para o sistema de troca de tópicos, no qual a mensagem não é roteada para nenhuma das filas de entrega.  Nessa situação, o broker simplesmente descarta a mensagem.  Em alguns cenários, isso é normal; em outros, a fonte deve saber se a mensagem foi descartada e prosseguir de acordo com isso.  Você pode definir o sinalizador "Obrigatório" para mensagens individuais e, se a mensagem não tiver sido definida em nenhuma fila de entrega, o basic.return será retornado ao remetente. <br><br>  A fonte pode aguardar confirmação após o envio de cada mensagem, mas isso reduzirá bastante seu desempenho.  Em vez disso, as fontes podem enviar um fluxo constante de mensagens, definindo um limite para o número de mensagens não reconhecidas.  Quando o limite de mensagens provisórias for atingido, o envio será interrompido até que todas as confirmações sejam recebidas. <br><br>  Agora que existem muitas mensagens em trânsito do remetente para o RabbitMQ, as confirmações são agrupadas usando o sinalizador múltiplo para melhorar o desempenho.  Todas as mensagens enviadas pelo canal recebem um valor inteiro monotonicamente crescente, o “Número de Sequência”.  A notificação de uma mensagem inclui o número de sequência da mensagem correspondente.  E se, ao mesmo tempo, o valor for múltiplo = verdadeiro, o remetente deverá rastrear os números de sequência de suas mensagens para saber quais mensagens foram entregues com êxito e quais não.  Eu escrevi um artigo detalhado sobre este tópico. <br><br>  Graças às confirmações, evitamos a perda de mensagens das seguintes maneiras: <br><br><ul><li>  reenviar mensagens em caso de notificação negativa; </li><li>  armazenamento contínuo de mensagens em algum lugar em caso de notificação negativa ou retorno básico. </li></ul><br>  <i>Transações</i> <br><br>  As transações raramente são usadas no RabbitMQ pelos seguintes motivos: <br><br><ul><li>  Fracas garantias.  Se as mensagens forem roteadas para várias filas ou tiverem um ícone obrigatório, a continuidade da transação não será suportada; </li><li>  Baixa produtividade. </li></ul><br>  Sinceramente, nunca as usei, elas não dão garantias adicionais, exceto as confirmações ao remetente, e apenas aumentam a incerteza na questão de como interpretar o aviso de recebimento de mensagens decorrentes da conclusão das transações. <br><br>  <i>Erros de comunicação / canal</i> <br><br>  Além das notificações de recebimento de mensagens, o remetente deve ter em mente as falhas das ferramentas de comunicação e dos intermediários.  Ambos esses fatores levam à perda do canal de comunicação.  Com a perda de canais, a oportunidade de receber notificações ainda não recebidas de recebimento de mensagens desaparece.  Aqui, o remetente deve escolher entre o risco de perda de mensagem e o risco de duplicação. <br><br>  A falha do intermediário pode ocorrer quando a mensagem estava no buffer do sistema operacional ou pré-processada e a mensagem será perdida.  Ou, talvez a mensagem estivesse na fila, mas o intermediário da mensagem morreu antes de enviar uma confirmação.  Nesse caso, a mensagem será entregue com sucesso. <br><br>  Da mesma forma, a falha dos meios de comunicação afeta a situação.  Ocorreu uma falha durante a transmissão da mensagem?  Ou depois que a mensagem foi colocada na fila, mas antes de receber uma notificação positiva? <br><br>  O remetente não pode determinar isso; portanto, ele deve escolher uma das seguintes opções: <br><br><ul><li>  Não encaminhe a mensagem, criando um risco de perda; </li><li>  reenvie a mensagem e crie um risco de duplicação. </li></ul><br>  Se muitas mensagens de remetente estiverem em trânsito, o problema ficará mais complicado.  A única coisa que o remetente pode fazer é dar uma dica aos destinatários adicionando um cabeçalho especial à mensagem, indicando que a mensagem está sendo enviada pela segunda vez.  Os destinatários podem decidir verificar as mensagens quanto à presença desses cabeçalhos e, se forem encontrados, verificar adicionalmente as mensagens recebidas em busca de duplicatas (se essa verificação não tiver sido executada anteriormente). <br><br><h4>  Destinatários </h4><br>  Existem duas opções disponíveis para os destinatários para receber notificações: <br><br><ul><li>  sem modo de notificação; </li><li>  modo de notificação manual. </li></ul><br>  <i>Sem modo de notificação</i> <br><br>  Ele é um modo de notificações automáticas.  E ele é perigoso.  Primeiro de tudo, porque quando uma mensagem entra no seu aplicativo, ela é removida da fila.  Isso pode levar à perda de mensagens se: <br><br><ul><li>  a conexão foi interrompida antes que a mensagem fosse recebida; </li><li>  a mensagem ainda está no buffer interno e o aplicativo foi desativado; </li><li>  O processamento da mensagem falhou. </li></ul><br>  Além disso, estamos perdendo mecanismos de contrapressão como forma de monitorar a qualidade da entrega de mensagens.  Ao definir o modo de envio de notificações manualmente, você pode definir uma pré-busca (ou definir o nível de serviços fornecidos, QoS) para limitar o número único de mensagens que o sistema ainda não confirmou o recebimento.  Sem isso, o RabbitMQ envia mensagens o mais rápido que a conexão permite, e isso pode ser mais rápido do que o receptor pode processá-las.  Como resultado, os buffers estão cheios e ocorrem erros de memória. <br><br>  <i>Modo de notificação manual</i> <br><br>  O destinatário deve enviar manualmente uma notificação de recebimento de cada mensagem.  Ele pode definir uma pré-busca caso o número de mensagens seja mais de uma e processar muitas mensagens ao mesmo tempo.  Ele pode decidir enviar uma notificação para cada mensagem ou aplicar o sinalizador múltiplo e enviar várias notificações por vez.  O agrupamento de notificações melhora o desempenho. <br><br>  Quando o destinatário abre o canal, as mensagens que passam por ele contêm o parâmetro Tag de entrega, cujo valor é um número inteiro, aumentando monotonicamente.  Ele está incluído em todas as notificações de recebimento e é usado como identificador da mensagem. <br><br>  As notificações podem ser as seguintes: <br><br><ul><li>  basic.ack.  Depois disso, o RabbitMQ remove a mensagem da fila.  O sinalizador múltiplo pode ser aplicado aqui. </li><li>  basic.nack.  O destinatário deve definir um sinalizador para informar ao RabbitMQ se deve enfileirar a mensagem novamente.  Ao redefinir a mensagem vai para o início da fila.  A partir daí, ele é enviado ao destinatário novamente (mesmo para o mesmo destinatário).  A notificação basic.nack suporta o sinalizador múltiplo. </li><li>  basic.reject.  O mesmo que basic.nack, mas não suporta o sinalizador múltiplo. </li></ul><br>  Assim, semanticamente basic.ack e basic.nack com requeue = false são os mesmos.  Ambos os operadores significam remover uma mensagem da fila. <br><br>  A próxima pergunta é quando enviar notificações de recebimento.  Se a mensagem foi processada rapidamente, convém enviar uma notificação imediatamente após a conclusão desta operação (com ou sem êxito).  Mas se a mensagem estava na fila RabbitMQ e o processamento leva muitos minutos?  Enviar uma notificação depois disso será problemático, porque se o canal fechar, todas as mensagens para as quais não houve notificações serão retornadas para a fila e o envio será feito uma segunda vez. <br><br>  <b>Erro de conexão / agente de mensagens</b> <br><br>  Se a conexão foi desconectada ou ocorreu um erro no broker, após o qual o canal deixa de funcionar, todas as mensagens cujo recebimento não foi confirmado serão novamente enfileiradas e encaminhadas.  Isso é bom porque evita a perda de dados, mas ruim porque causa duplicação excessiva. <br><br>  Quanto mais tempo o destinatário receber mensagens por um longo período, cuja confirmação ele não confirmou, maior será o risco de encaminhamento.  Quando uma mensagem é reenviada, RabbitMQ para o sinalizador de encaminhamento é definido como true.  Por esse motivo, o destinatário tem pelo menos uma indicação de que a mensagem já pode ter sido processada. <br><br>  <b>Idempotência</b> <br><br>  Se a idempotência for necessária e garantir que nenhuma mensagem seja perdida, alguma verificação duplicada ou outros esquemas idempotentes devem ser incorporados.  Se a verificação de mensagens duplicadas for muito cara, você poderá aplicar uma estratégia na qual o remetente sempre adicione um cabeçalho especial para reenviar mensagens e o destinatário verificará as mensagens recebidas quanto à presença de um cabeçalho e um sinalizador de reenvio. <br><br><h4>  Conclusão </h4><br>  O RabbitMQ fornece garantias confiáveis ​​e de longo prazo para mensagens, mas há muitas situações em que elas não ajudam. <br><br>  Aqui está uma lista de pontos a serem lembrados: <br><br><ul><li>  Você deve usar espelhamento de fila, filas confiáveis, mensagens persistentes, confirmações para o remetente, um sinalizador de confirmação e notificação forçada do destinatário se forem necessárias garantias confiáveis ​​na estratégia de "pelo menos entrega única". </li><li>  Se o envio for realizado como parte da estratégia de "pelo menos entrega única", pode ser necessário adicionar um mecanismo para deduplicação ou idempotência ao duplicar os dados que estão sendo enviados. </li><li>  Se o problema da perda de mensagens não for tão importante quanto o da velocidade de entrega e alta escalabilidade, pense em sistemas sem redundância, sem mensagens persistentes e sem reconhecimento no lado da fonte.  No entanto, eu preferiria deixar notificações forçadas do destinatário para controlar o fluxo de mensagens recebidas alterando as restrições de pré-busca.  Nesse caso, você precisará enviar notificações em lotes e usar o sinalizador "múltiplo". </li></ul><br>  <b>Garantias de entrega em Kafka</b> <br><br>  As garantias de entrega são fornecidas: <br><br><ul><li>  durabilidade da mensagem - as mensagens armazenadas em um segmento não são perdidas; </li><li>  Notificações de mensagens - a troca de sinais entre o Kafka (e possivelmente o repositório Apache Zookeeper), por um lado, e a fonte / receptor, por outro. </li></ul><br>  <b>Duas palavras sobre o empacotamento de mensagens</b> <br><br>  Uma das diferenças entre o RabbitMQ e o Kafka é o uso de pacotes para mensagens. <br><br>  O RabbitMQ fornece algo semelhante à embalagem, graças a: <br><br><ul><li>  Suspenda o envio de todas as mensagens X até que todas as notificações sejam recebidas.  O RabbitMQ geralmente agrupa notificações usando o sinalizador "múltiplo". </li><li>    «prefetch»      «multiple». </li></ul><br>       .                  “multiple”.     TCP. <br><br> Kafka     .    ,           .     RabbitMQ,      ,    ,      .         ,         . <br><br> Kafka        ,      ,     .      ,          .     RabbitMQ   API    ,                  . RabbitMQ         . <br><br> <b>,  </b> <br><br> <i> </i> <br><br>      Kafka   -    ,       ,      .       .   ,   ,  , ,        ,      . <br><br> Kafka     (In Sync Replicas, ISR).          .        ,   ,     (   10 ).    ,      .    -  ,       ..               .        . <br><br> <i>      </i> <br><br>  ,  Kafka  ,  ,    , Kafka               . <br><br> <i>     </i> <br><br>    ,     Kafka,      ,    : <br><br><ul><li>  ,  . Acks=0. </li><li>     . Acks=1 </li><li>           . Acks=All </li></ul><br>          ,    RabbitMQ.         ,      ,        (   ,    ).   ,          . <br><br>   Kafka       .        : <br><br><ul><li>  enable.idempotence   “true”, </li><li>  max.in.flight.requests.per.connection   5  , </li><li>  retries   1  , </li><li>  acks   “all”. </li></ul><br> ,          acks=0/1   ,     . <br><br> <i>  </i> <br><br>        ,           ,   .       ZooKeeper    Kafka. <br><br>        (),       ,       : <br><br><ul><li> .          .                 .          .         ,      . </li><li> ,    .      “   ”.    ,      ;     ,    . ,  10         ,    4 ,   ,      ,     ; </li><li>  ,    .      “   ”.  ,      ,      ,           . ,  10         ,       ,  4    ; </li><li> .    ,     . </li></ul><br>  “  ”  Kafka Streams,    Java.   Java      .    “  ”,      ,    ,           . ,         ,      “  ”  .           ,       ,   ()      . <br><br> ,  Kafka Streams,          ,       ,      “  ”.       Kafka:             .    ,    .    ,    ,   ,        (   ),   . <br><br> <b>    </b> <br><br>      Kafka     “--”.         .   ,   ,  . <br><br>        “ ”,    ,      (,  , ).      “ ”,    ,      .       . <br><br>   :    “  ”      ?    .        ,     ,    .     .     (Last Stable Offset, LSO) —      ;     “  ”      . <br><br>  <b>Conclusões</b> <br><br>         .   ,    ,      .   ,     Kafka      ,                . <br><br><h4>  Resumir </h4><br><ul><li>      “   ”  “   ”. </li><li>     . </li><li>      ,              . Kafka    ,      . </li><li>       ,   ,        . </li><li>        . </li><li> Kafka   ,      “--”.          . </li><li>  Kafka,       -         ,        (   ).  RabbitMQ    . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O Kafka pode aumentar os benefícios da pacote devido aos seus recursos de distribuição de pacotes, e o RabbitMQ não possui pacote devido a um modelo de recebimento passivo que não impede conflitos de destinatários. </font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437446/">https://habr.com/ru/post/pt437446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437436/index.html">Executando o visualizador de imagens do Windows XP no Windows moderno</a></li>
<li><a href="../pt437438/index.html">Audiotecnologia: como os pedaços de plástico são movidos usando o ultra-som e por que é necessário</a></li>
<li><a href="../pt437440/index.html">Feliz dia do aluno, programador</a></li>
<li><a href="../pt437442/index.html">Respostas de suporte técnico da 3CX: configure o roteador para o servidor PBX VoIP</a></li>
<li><a href="../pt437444/index.html">Um balde de alcatrão em um barril de mel ou Sobre um potencial choque cultural para proprietários de tratores</a></li>
<li><a href="../pt437448/index.html">28 de janeiro na Rússia, o sistema de pagamentos rápidos sem comissão (por número de telefone)</a></li>
<li><a href="../pt437450/index.html">Como conheci o OpenCV ou em busca do ColorChecker</a></li>
<li><a href="../pt437454/index.html">Revisão do aritmômetro Felix M</a></li>
<li><a href="../pt437456/index.html">Mais jovem: Revisão dos telefones IP Snom D315 e D305</a></li>
<li><a href="../pt437458/index.html">Registro obrigatório pela oferta do IMEI para efetuar pagamentos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>