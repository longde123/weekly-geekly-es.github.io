<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😱 👩🏿‍⚕️ 👇 Distribution de billets de faveur: fils non freinés en Java. Métier à projet 🧑🏼 👨🏾‍🤝‍👨🏻 👩🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Voulez-vous dans les threads Java qui ne mangent pas de mémoire comme s'ils n'étaient pas en eux-mêmes et ne ralentissent pas? Bon crédit, et ce probl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Distribution de billets de faveur: fils non freinés en Java. Métier à projet</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/422519/"><p>  Voulez-vous dans les threads Java qui ne mangent pas de mémoire comme s'ils n'étaient pas en eux-mêmes et ne ralentissent pas?  Bon crédit, et ce problème répond à cette question. </p><br><p>  Nous expliquons le travail de Project Loom sur les boîtes à pizza!  Allez! </p><br><p>  Tout cela est supprimé et écrit <b>spécifiquement pour Habr</b> . </p><br><br><p><br clear="all"></p><a name="habracut"></a><br><h1 id="pozyvnye">  Indicatifs d'appel </h1><br><p>  Voyez-vous souvent cette image sur votre service Web: au début, tout allait bien, puis un million de Chinois sont venus vers vous, le service a fait un million de fils et s'est noyé en enfer? </p><br><p><img src="https://habrastorage.org/webt/ym/_-/3r/ym_-3rq8a8g56hsmrvjhprnih8y.png"><br><br></p><br><p>  Voulez-vous une si belle photo? </p><br><p><img src="https://habrastorage.org/webt/38/s-/04/38s-04z5nak6trs_p2lei9chjku.png"><br><br></p><br><p>  En d'autres termes, voulez-vous dans les threads Java qui ne mangent pas de mémoire mais ne sont pas en eux-mêmes et ne ralentissent pas?  Bon crédit, et ce problème répond à cette question. </p><br><p>  Nous allons, en fait, <em>déballer le nouveau cadre</em> .  Rappelez-vous comment Wylsacom a déballé les iPhones?  Certains ne se souviennent pas déjà des anciens commentateurs, mais pourquoi?  Parce que Habr est un bastion traditionnel, et les vidéos payantes sont, désolées, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rayons de la diarrhée</a> .  Dans cet article, nous traiterons exclusivement du hardcore technique. </p><br><p>  Tout d'abord, deux minutes pour les globes oculaires, l'avertissement et les autres déchets, qui doivent être dit.  Vous pouvez l'ignorer si vous êtes trop paresseux. </p><br><p>  Tout d'abord, tout ce qui est dit dans la vidéo est ma pensée personnelle, et cela n'a rien à voir avec l'employeur ou la glorieuse société Oracle, le gouvernement mondial des lézards et une fichue chose dans un mortier.  J'écris même ceci à trois heures du matin pour qu'il soit clair que c'est mon initiative personnelle, mes ordures personnelles.  <em>Tous les matchs sont purement aléatoires.</em> </p><br><p>  Mais il y a un autre objectif bonus.  Nous parlons constamment de coroutines à Kotlin.  Récemment, il y a eu des entretiens avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Roma Elizarov</a> , le dieu de Corutin, et avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pasha Finkelstein</a> , qui va leur écrire des backends.  Bientôt, il y aura une interview d'Andrei Breslav - qui est le père de Kotlin.  Et partout, le projet Loom est mentionné d'une manière ou d'une autre, car il s'agit d'un analogue de la coroutine.  Et si vous ne savez pas ce qu'est Loom, vous pourriez devenir stupide en lisant ces interviews.  Il y a des mecs sympas, ils discutent de choses sympas.  Et vous y êtes, et vous n'êtes pas avec eux, schmuck.  C'est vraiment stupide. </p><br><p>  Ne faites pas ça, lisez ce qu'est Loom dans cet article, ou regardez cette vidéo plus loin, je vais tout vous expliquer. </p><br><p>  Alors, quelle est la complication.  Il y a un tel mec, Ron Presler. </p><br><br><p><img src="https://habrastorage.org/webt/w-/tq/ut/w-tqutfyx33olnhdavtq_asdv9u.png"><br><br></p><br><p>  L'année dernière, il <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est allé sur la liste de diffusion</a> , a déclaré que les threads en Java étaient nuls et lui a suggéré d'exécuter le runtime et de le corriger.  Et tout le monde se moquait de lui et jetait des pierres, de la merde, sinon pour le fait qu'il avait écrit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quasar</a> plus tôt, et c'est en fait très cool.  Vous pouvez jurer sur Quasar pendant longtemps, mais il semble être là et cela fonctionne, et dans l'ensemble, c'est probablement un exploit. </p><br><p>  Il y a beaucoup de govnokodery qui ne font rien, dites-le.  Eh bien, faites-le bien, je suis le même.  Ou il y a des gens qui semblent être des ingénieurs sympas, mais en général dans l'inconscient, ils disent ceci: "En Java, vous devez améliorer les threads."  Que faut-il améliorer?  Quels sont les fils? </p><br><p>  Les gens sont généralement trop paresseux pour penser. </p><br><p>  Comme dans une blague: <br>  Petka et Vasily Ivanovich volent dans un avion. <br>  Vasily Ivanovich demande: - Petka, appareils? <br>  Petka répond: - 200! <br>  Vasily Ivanovich: - Et qu'en est-il de 200? <br>  Petka: - Et les électroménagers? </p><br><p>  Je vais raconter une histoire.  J'étais en Ukraine ce printemps, nous avons pris l'avion depuis la Biélorussie (vous comprenez pourquoi c'est impossible directement depuis Saint-Pétersbourg).  Et à la douane, nous nous sommes assis pendant environ deux heures, rien de moins.  Les agents des douanes sont très gentils, ont demandé sérieusement si Java est une technologie obsolète.  Des gens assis à proximité qui volent vers le même konf.  Et je suis un type de conférencier, je dois jouer un coup de pied, me tenir debout et, comme prévu, parler sans vergogne de choses que je n'utilise pas du tout.  Et en cours de route, il a parlé de la distribution JDK appelée Liberica, c'est un tel JDK pour le Raspberry Pi. </p><br><p>  Et qu'en pensez-vous.  Pas même six mois ne s'écoulent avant que les gens frappent sur mon chariot et disent que, écoutez, nous avons déposé une solution dans Liber sur la prod, et j'ai déjà un rapport à ce sujet au jfuture.by konf biélorusse.  Telle est l'approche.  Ce n'est pas un mauvais évangéliste, mais un mec, un ingénieur normal. </p><br><blockquote>  Soit dit en passant, nous aurons bientôt une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conférence Joker 2018</a> , qui comprendra à la fois <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Andrei Breslav</a> (évidemment en fouillant dans les coroutines), et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pasha Finkelshtein</a> , et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Josh Long</a> peut être interrogé sur le soutien de Spring à Loom.  Eh bien, et un tas d'experts éminents cool, allez! </blockquote><p>  Et maintenant, revenons aux discussions.  Les gens essaient de se faire une idée à travers leurs deux neurones dégradés, comme la morve enroulée sur leur poing, et marmonnent: "En Java, les threads ne sont pas comme ça, en Java, les threads ne sont pas comme ça."  Appareils!  Quels appareils?  C'est généralement l'enfer. </p><br><p>  Et voici Presler, un mec normal et non dégradé, et au début, il fait une description sensée.  Un an plus tard, j'ai vu une démo de travail.  J'ai dit tout cela pour que vous compreniez qu'une description normale des problèmes, une documentation normale est un tel héroïsme d'un genre spécial.  Et la démo est généralement de l'espace.  C'est la première personne à avoir fait quoi que ce soit dans ce sens.  Il en a le plus besoin. </p><br><p>  Avec la démo, Presler a pris la parole lors de la conférence et a publié cette vidéo: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/J31o0ZMQEnI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  En fait, tout cet article est un examen de ce qui a été dit là-bas.  Je ne prétends pas du tout à l'unicité de ce matériau, tout ce qui se trouve dans cet article a été inventé par Ron. </p><br><p>  La discussion porte sur trois sujets douloureux: </p><br><ul><li>  Continations </li><li>  Les fibres </li><li>  Appels de queue </li></ul><br><p>  Probablement, il était tellement écoeuré en sciant Quasar et en se battant avec ses pépins qu'il n'y a pas de force - vous devez le mettre en phase d'exécution. </p><br><p>  C'était il y a un an, et depuis lors, ils ont scié un prototype.  Certains ont déjà perdu espoir de voir un jour une démo, mais il y a un mois, ils y ont donné naissance et ont montré ce qui est visible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur ce tweet</a> . </p><br><br><p><img src="https://habrastorage.org/webt/ck/hp/mc/ckhpmcchdv2k6_4vfbw733evg6c.png"><br><br></p><br><p>  Les trois sujets douloureux de cette démo sont soit directement dans le code, soit au moins moralement présents.  Eh bien, oui, ils n'ont pas encore maîtrisé les appels de queue, mais ils le veulent. </p><br><h1 id="problematika">  Problème </h1><br><p>  Les utilisateurs mécontents, les développeurs d'applications, lorsqu'ils créent une API, sont obligés de choisir entre deux chaises.  Les pics sont intégrés sur une chaise, les fleurs poussent sur l'autre.  Et ni l'un ni l'autre ne nous conviennent. </p><br><br><p><img src="https://habrastorage.org/webt/tn/nx/k-/tnnxk-iwzuj7sybfwllour9qozq.png"><br><br></p><br><p>  Par exemple, si vous écrivez un service qui fonctionne de manière synchrone, il fonctionne très bien avec le code hérité, il est facile de déboguer et de surveiller les performances.  Des problèmes surgiront avec la bande passante et l'évolutivité.  Tout simplement parce que le nombre de threads que vous pouvez désormais exécuter sur un simple matériel, sur du matériel de base - disons, deux mille.  C'est beaucoup moins que le nombre de connexions qui pourraient être ouvertes sur ce serveur.  Ce qui du point de vue du netcode peut être presque sans fin. </p><br><p>  (Eh bien, oui, cela a quelque chose à voir avec le fait que les sockets en Java sont arrangés idiotes, mais c'est un sujet pour une autre conversation) </p><br><p>  Imaginez que vous écrivez une sorte de MMO. </p><br><br><p><img src="https://habrastorage.org/webt/ye/mg/pm/yemgpm6on0pidozkhmco3epwapa.png"><br><br></p><br><p>  Par exemple, pendant la guerre du Nord dans EVE Online, deux mille quatre cents pilotes se sont rassemblés à un point dans l'espace, chacun d'eux - conditionnellement, s'il était écrit en Java - ne serait pas un fil, mais plusieurs.  Et le pilote, bien sûr, est une logique métier complexe, et non la publication d'un code HTML qui peut être exclu à la main dans une loupe. </p><br><p>  Le temps de réponse dans cette bataille a été si long que le joueur a dû attendre quelques minutes pour attendre le tir.  Pour autant que je sache, CCP spécifiquement pour cette bataille a jeté les énormes ressources matérielles de son cluster. </p><br><p>  Bien que, je cite probablement EVE comme exemple en vain, car, pour autant que je comprends, tout est écrit en Python, et en Python avec multithreading, il est encore pire que le nôtre - et nous pouvons considérer une mauvaise concurrence des fonctionnalités du langage.  Mais alors l'exemple est clair et avec des photos. </p><br><p>  Si vous êtes intéressé par le sujet de l'OMI en général et l'histoire de la «guerre du Nord» en particulier, récemment une très bonne vidéo sur ce sujet est apparue sur la chaîne Bulzhat (quel que soit son nom), regardez depuis mon horodatage. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AkAtiTNvjz8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Nous revenons au sujet. </p><br><p>  D'un autre côté, vous pouvez utiliser une sorte de framework asynchrone.  Il est évolutif.  Mais nous tomberons immédiatement dans un débogage très difficile, un profilage compliqué de la performance, nous ne pourrons pas l'intégrer de manière transparente avec l'héritage, vous devrez réécrire beaucoup de choses, les envelopper dans des emballages abominables et avoir généralement l'impression que nous venons d'être violés.  Plusieurs fois de suite.  Pendant des jours, en fait, tout le temps que nous écrivons ceci, vous devrez vous sentir comme ça. </p><br><p>  J'ai demandé à l'expert, le célèbre académicien Escobar, ce qu'il en pensait: </p><br><br><p><img width="300" src="https://habrastorage.org/webt/7g/hf/mg/7ghfmg3x8aqhdl0jcyrbpairqsc.png"><br><br></p><br><p>  Que faire?  Les soi-disant faybers se précipitent à la rescousse. </p><br><p>  Dans le cas général, les fibres sont de tels fils légers qui fouillent également dans l'espace d'adressage (car les miracles ne se produisent pas, vous comprenez).  Mais contrairement aux threads ordinaires, ils n'utilisent pas le multitâche préemptif, mais le multitâche coopératif.  En savoir plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur Wikipedia</a> . </p><br><p>  La fibre peut réaliser les avantages de la programmation synchrone et asynchrone.  Par conséquent, l'utilisation du fer est augmentée et nous utilisons moins de serveurs dans le cluster pour la même tâche.  Eh bien, dans notre poche pour cela, nous obtenons de la lavande.  Babos.  Lave.  L'argent.  Eh bien, vous obtenez le point.  Pour le serveur enregistré. </p><br><h1 id="na-raspute">  À la croisée des chemins </h1><br><p>  La première chose que je veux discuter.  Les gens ne comprennent pas la différence entre les continuations et la fibre. <br>  Maintenant, il y aura une illumination culte! </p><br><p>  Nous allons annoncer le fait: la poursuite et la fibre sont deux choses différentes. </p><br><h1 id="continuations">  Continuations </h1><br><p>  Les fibres sont construites au sommet d'un mécanicien appelé Continuations. </p><br><p>  Les continuations (plus précisément, les continuations délimitées) sont une sorte de calcul, d'exécution, un morceau de programme qui peut s'endormir, puis se réveiller et continuer l'exécution depuis l'endroit où il s'est endormi.  Il peut même parfois être cloné ou sérialisé, même pendant qu'il dort. </p><br><p>  J'utiliserai le mot «continuation», et non «continuation» (comme il est écrit sur Wikipédia), car nous communiquons tous en <em>anglais</em> .  En utilisant la terminologie russe normale, on peut facilement arriver à une situation où la différence entre le terme russe et l'anglais devient trop grande et personne d'autre ne comprend le sens de ce qui a été dit. </p><br><p>  J'utiliserai également parfois le mot «crowding out» au lieu de la version anglaise de «yield».  Juste le mot "céder" - c'est une sorte de vraiment méchant.  Il y aura donc «éviction». </p><br><p>  Alors voilà.  Il est très important qu'il n'y ait pas de concurrence dans le continuum.  C'est en soi la primitive minimale de ce processus. </p><br><p> Vous pouvez considérer la continuation comme un <code>Runnable</code> , à l'intérieur duquel vous pouvez appeler la méthode <code>pause()</code> .  C'est à l'intérieur et directement, car notre multitâche est coopératif.  Et puis vous pouvez l'exécuter à nouveau, et au lieu de tout recalculer, il continuera là où il s'était arrêté.  Ce genre de magie.  Nous reviendrons à la magie. </p><br><p>  Où obtenir une démo avec des suites de travail - nous discuterons à la toute fin.  Parlons maintenant de ce qui existe. </p><br><p>  La classe de continuation elle-même est située sur java.base, tous les liens seront dans la description.  ( <code>src/java.base/share/classes/java/lang/Continuation.java</code> ).  Mais cette classe est très grande, volumineuse, il est donc logique de ne regarder que quelque sorte de compression. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Continuation</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Continuation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContinuationScope scope, Runnable body)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yield</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContinuationScope scope)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPinned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Reason reason)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Pinned: "</span></span> + reason); } }</code> </pre> <br><p>  Notez qu'en fait ce fichier est en constante évolution.  Par exemple, à la veille, la poursuite n'a pas implémenté l'interface <code>Runnable</code> .  Traitez cela comme une sorte d'esquisse. </p><br><p>  Jetez un oeil au constructeur.  <code>body</code> - c'est le code que vous essayez d'exécuter, et <code>scope</code> - est une sorte de skop qui vous permet d'imbriquer des continuations dans des continuations. </p><br><p>  En conséquence, vous pouvez soit planifier ce code à la fin avec la méthode <code>run</code> , soit le remplacer par un tableau spécifique en utilisant la méthode <code>yield</code> (le tableau est nécessaire ici pour quelque chose comme le transfert d'actions aux gestionnaires imbriqués, mais nous ne nous soucions pas en tant qu'utilisateurs).  Vous pouvez demander à l'aide de la méthode <code>isDone</code> si tout est terminé jusqu'à la fin. </p><br><p>  Et pour des raisons dictées uniquement par les besoins de l'implémentation actuelle (mais très probablement, elle sera également incluse dans la version), il n'est pas toujours possible de faire du <code>yield</code> .  Par exemple, si à l'intérieur de la suite nous avons eu une transition vers le code natif et qu'un cadre natif est apparu sur la pile, alors il est impossible de se coincer.  Cela se produira également si vous essayez de vous évincer pendant qu'un moniteur natif, tel qu'une méthode synchronisée, est pris à l'intérieur du corps du continuum.  Par défaut, lorsque vous essayez de simuler cela, une exception est levée ... mais les fibres construites au-dessus des suites surchargent cette méthode et font autre chose.  Ce sera un peu plus tard. </p><br><p>  Vous pouvez l'utiliser de la manière suivante: </p><br><pre> <code class="java hljs">Continuation cont = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Continuation(SCOPE, () -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { System.out.println(<span class="hljs-string"><span class="hljs-string">"before"</span></span>); Continuation.yield(SCOPE); System.out.println(<span class="hljs-string"><span class="hljs-string">"after"</span></span>); } }); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cont.isDone()) { cont.run(); }</code> </pre> <br><p>  Ceci est un exemple de la présentation de Presler.  Encore une fois, ce n'est pas un code "trivial", c'est une sorte de croquis. </p><br><p>  Ceci est une esquisse de ce que nous faisons continuation, au milieu de cette continuation nous sommes évincés puis dans un cycle sans fin nous demandons si la continuation a fonctionné jusqu'au bout et si elle doit être poursuivie. </p><br><p>  Mais en général, il n'est pas prévu que les programmeurs d'applications ordinaires se rapportent à cette API.  Il est destiné aux créateurs de frameworks système.  Les frameworks de formation de systèmes comme le Spring Framework adopteront immédiatement cette fonctionnalité dès sa sortie.  Tu verras.  Considérez ceci comme une prédiction.  Une telle prédiction légère, car tout est assez évident ici.  Toutes les données de prédiction sont.  Cette fonctionnalité est trop importante pour ne pas s'adapter.  Par conséquent, il n'est pas nécessaire de s'inquiéter à l'avance que quelqu'un vous torture avec l'encodage sous cette forme.  Eh bien, si vous êtes un développeur Spring, vous saviez ce que vous faisiez. </p><br><p>  Et maintenant, en plus des suites, des fibres sont construites. </p><br><h1 id="fibers">  Les fibres </h1><br><p>  Alors, ce qui dans notre cas signifie fibre. <br><br>  C'est une sorte d'abstraction, qui est: </p><br><ul><li>  Threads légers traités dans la JVM elle-même, et non dans le système d'exploitation; </li><li>  Avec des frais généraux extrêmement bas pour créer, maintenir la vie, changer de tâche; </li><li>  Qui peut être exécuté des millions de fois. </li></ul><br><p>  De nombreuses technologies tentent de fabriquer la fibre d'une manière ou d'une autre.  Par exemple, dans Kotlin, il existe des coroutines implémentées sur une génération de bytecode très intelligente.  <em>TRÈS INTELLIGENT</em> .  Mais le runtime est un meilleur endroit pour implémenter de telles choses. </p><br><p>  Au minimum, la JVM sait déjà bien gérer les threads, et tout ce que nous devons faire est de rationaliser le processus de codage pour le multithreading.  Vous pouvez utiliser des API asynchrones, mais cela peut difficilement être appelé «simplification»: même en utilisant des choses comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reactor</a> , Spring Project Reactor, qui permettent d'écrire du code apparemment linéaire, ne vous sera d'aucune utilité si vous devez déboguer des problèmes complexes. </p><br><p>  Donc fibre. </p><br><p>  La fibre se compose de deux composants.  C’est: </p><br><ul><li>  Continuation </li><li>  Planificateur </li></ul><br><p>  Soit: </p><br><ul><li>  Continuation </li><li>  Planificateur </li></ul><br><br><p><img src="https://habrastorage.org/webt/ga/wc/yk/gawcykupqgqwqjwfxcpccyltenu.jpeg"><br><br></p><br><p>  Vous pouvez décider qui est le planificateur ici.  Je pense que le planificateur ici est Jay. </p><br><ul><li>  Fibre encapsule le code que vous souhaitez exécuter dans une continuation </li><li>  Le planificateur les lance sur un pool de threads de support </li></ul><br><p>  <em>Je les appellerai des fils de support.</em> </p><br><br><br><p><img src="https://habrastorage.org/webt/j4/hc/gw/j4hcgwglzzsi6qe-cxczwcewohy.jpeg"><br><br></p><br><p>  Le prototype actuel utilise <code>java.util.concurrent.Executor</code> et le planificateur <code>ForkJoinPool</code> .  Nous avons tout.  À l'avenir, quelque chose de plus intelligent pourrait y apparaître, mais pour l'instant, comme ça. </p><br><p>  Comment se comporte la suite: </p><br><ul><li>  Il est évincé (rendement) lorsqu'un verrouillage se produit (par exemple, sur IO); </li><li>  Continue lorsque vous êtes prêt à continuer (par exemple, l'opération d'E / S est terminée et vous pouvez continuer). </li></ul><br><p>  État actuel des travaux: </p><br><ul><li>  L'accent principal sur la philosophie, les concepts; </li><li>  L'API n'est pas fixe, c'est "pour le show".  Ceci est un prototype de recherche; </li><li>  Il existe un prototype de travail codé prêt à l'emploi de la classe <code>java.lang.Fiber</code> . </li></ul><br><p>  Il en sera question. </p><br><p>  Ce qui a déjà été scié dans la fibre: </p><br><ul><li>  Il exécute un lancement de tâche; </li><li>  Parking voiture non garé sur un transporteur; </li><li>  En attente de l'achèvement de la fibre. </li></ul><br><h1 id="principialnaya-shema">  Schéma du circuit </h1><br><pre> <code class="java hljs">mount(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { cont.run(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> () { unmount(); }</code> </pre> <br><ul><li>  Nous pouvons monter une fibre sur un porte-fil; </li><li>  Exécutez ensuite la suite; </li><li>  Et attendez qu'elle soit évincée ou qu'elle s'arrête honnêtement; </li><li>  Au final, on laisse toujours le fil. </li></ul><br><p>  Ce pseudo-code sera exécuté sur le <code>ForkJoinPool</code> ou sur un autre (qui finira par être dans la version finale). </p><br><h1 id="ispolzovanie-v-realnosti">  Utilisation en réalité </h1><br><pre> <code class="java hljs">Fiber f = Fiber.execute( () -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Good Morning!"</span></span>); readLock.lock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Good Afternoon"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { readLock.unlock(); } System.out.println(<span class="hljs-string"><span class="hljs-string">"Good Night"</span></span>); });</code> </pre> <br><p>  Regardez, nous créons une fibre dans laquelle: </p><br><ul><li>  bienvenue à tous; </li><li>  nous bloquons le loke réentrant; </li><li>  à votre retour, félicitations pour votre déjeuner; </li><li>  libérer enfin le verrou; </li><li>  et dis au revoir. </li></ul><br><p>  Tout est très simple. </p><br><p>  Nous n'engendrons pas directement le surpeuplement.  Project Loom lui-même sait que lorsque <code>readLock.lock();</code> déclenché <code>readLock.lock();</code>  il devrait intervenir et faire implicitement de la répression.  L'utilisateur ne voit pas cela, mais cela se produit là-bas. </p><br><h1 id="steki-povsyudu-steki">  Des piles, des piles partout! </h1><br><p>  Montrons ce qui se passe en utilisant la pile de pizza comme exemple. </p><br><p>  Au début, le thread porteur est dans un état d'attente et rien ne se produit. </p><br><p><img src="https://habrastorage.org/webt/8y/gw/mr/8ygwmr7dc_owazfdj-wa4trrs4g.png"><br><br></p><br><p>  Haut de la pile en haut, rappelez-vous. </p><br><p>  L'exécution de la fibre a ensuite été planifiée et la tâche de fibre a commencé à s'exécuter. </p><br><p><img src="https://habrastorage.org/webt/pd/ya/mn/pdyamn0chhcnelgtphtxeg6eniq.png"><br><br></p><br><p>  En lui-même, il lance évidemment une suite, dans laquelle le vrai code est déjà localisé. </p><br><p><img src="https://habrastorage.org/webt/33/nw/fb/33nwfb3dz0klj1oiog21iegsbuy.png"><br><br></p><br><p>  Du point de vue de l'utilisateur, nous n'avons encore rien lancé ici. </p><br><p>  Ce n'est que la première image du code utilisateur apparue sur la pile, et elle est marquée en violet. </p><br><p>  En outre, le code est exécuté, exécuté, à un moment donné, la tâche tente de capturer le verrou et de le bloquer, ce qui conduit à un éviction automatique. </p><br><p><img src="https://habrastorage.org/webt/vv/lk/ah/vvlkahftvyuefpupb4fyidb5gdq.png"><br><br></p><br><p>  Tout ce qui se trouve sur la pile de continuation est stocké dans un certain endroit magique.  Et disparaît. </p><br><p><img src="https://habrastorage.org/webt/hz/oq/6n/hzoq6nmzmezadhp8-ntn6_qerxk.png"><br><br></p><br><p>  Comme vous pouvez le voir, le flux revient à la fibre, à l'instruction qui suit <code>Continuation.run</code> .  Et c'est la fin du code fibre. </p><br><p>  La tâche de fibre se termine, le support média attend un nouveau travail. </p><br><p><img src="https://habrastorage.org/webt/l4/nt/k9/l4ntk9qfl8dpcamol4ufahy8sa0.png"><br><br></p><br><p>  La fibre est garée, quelque part se trouve, le continuum est complètement évincé. </p><br><p>  Tôt ou tard, le moment vient où celui qui possède la serrure la libère. <br>  Cela conduit au fait que la fibre, qui attendait la libération du verrou, est déballée.  La tâche de cette fibre recommence. </p><br><ul><li>  Reentrantlock.unlock </li><li>  Locksupport.unpark </li><li>  Fiber.unpark </li><li>  ForkJoinPool.execute </li></ul><br><p>  Et nous retournons rapidement à la pile, qui était récemment. </p><br><p><img src="https://habrastorage.org/webt/hz/oq/6n/hzoq6nmzmezadhp8-ntn6_qerxk.png"><br><br></p><br><p>  De plus, le fil porteur peut être complètement différent.  Et cela a du sens! </p><br><p>  Exécutez à nouveau la suite. </p><br><p><img src="https://habrastorage.org/webt/ll/c-/mx/llc-mxgfttlpleiqtprwm6igcju.png"><br><br></p><br><p>  Et voici la MAGIE !!!  La pile est restaurée et l'exécution se poursuit avec l'instruction après <code>Continuation.yield</code> . </p><br><p><img src="https://habrastorage.org/webt/la/4t/pp/la4tppjy2spiy4_auvwdikgm8nu.png"><br><br></p><br><p>  Nous rampons hors du verrou juste parqué et commençons à exécuter tout le code restant dans la suite: </p><br><p><img src="https://habrastorage.org/webt/yt/ce/ht/ytcehtff1fomwn5cehnzkegzpts.png"><br><br></p><br><p>  La tâche utilisateur se termine et le contrôle revient à la tâche fibre immédiatement après l'instruction continuation.run </p><br><p><img src="https://habrastorage.org/webt/sz/m8/cc/szm8ccxgwntcgjzwqcl_gcernqg.png"><br><br></p><br><p>  Dans le même temps, l'exécution de la fibre se termine, et nous nous retrouvons à nouveau en mode veille. </p><br><p><img src="https://habrastorage.org/webt/l4/nt/k9/l4ntk9qfl8dpcamol4ufahy8sa0.png"><br><br></p><br><p>  Le prochain lancement de la fibre amorce à nouveau tout le cycle de renaissances décrit ci-dessus. </p><br><p><img src="https://habrastorage.org/webt/c7/z9/wm/c7z9wmktfbsithnlvyuea4mtqki.jpeg"><br><br></p><br><h1 id="zhivye-primery">  Exemples en direct </h1><br><p>  Et qui a déjà dit que tout cela fonctionne?  S'agit-il de quelques microbenchmarks écrits au cours de la soirée? </p><br><p>  À titre d'exemple du fonctionnement des pétards, les Oraklovites ont écrit un petit serveur Web et l'ont alimenté en requêtes pour qu'il s'étouffe.  Ensuite, ils ont été transférés sur fibre.  Le serveur a cessé de s'étouffer et nous en avons conclu que les fibres fonctionnent. </p><br><p>  Je n'ai pas le code exact pour ce serveur, mais si cet article obtient suffisamment de likes et de commentaires, j'essaierai d'écrire un exemple moi-même et de créer de vrais graphiques. </p><br><h1 id="problemy">  Les problèmes </h1><br><p>  Y a-t-il des problèmes ici?  Oui bien sûr!  Toute l'histoire des faybers est une histoire de problèmes et de compromis continus. </p><br><h2 id="filosofskie-problemy">  Problèmes philosophiques </h2><br><ul><li>  Faut-il réinventer les fils? </li><li>  <em>Tout</em> le code existant devrait-il fonctionner correctement à l'intérieur de la fibre? </li></ul><br><p>  Le prototype actuel fonctionne avec des limitations.  Ce qui peut entrer dans la version, bien que je ne le veuille pas.  Pourtant, OpenJDK est une chose qui respecte la compatibilité sans fin. </p><br><p>  Quelles sont les limitations techniques?  Les limitations les plus évidentes sont 2 pièces. </p><br><h2 id="problema-raz--nelzya-vytesnit-nativnye-freymy">  Le problème est une fois - vous ne pouvez pas remplacer les cadres natifs </h2><br><pre> <code class="java hljs">PrivilegedAction&lt;Void&gt; pa = () -&gt; { readLock.lock(); <span class="hljs-comment"><span class="hljs-comment">// may park/yield try { // } finally { readLock.unlock(); } return null; } AccessController.doPrivileged(pa); //native method</span></span></code> </pre> <br><p>  Ici, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">doPrivileged</a> appelle la méthode native. </p><br><p>  Vous appelez <code>doPrivileged</code> , sautez hors de la machine virtuelle, un cadre natif apparaît sur votre pile, après quoi vous essayez de vous garer sur la ligne <code>readLock.lock()</code> .  Et à ce moment-là, le fil porteur sera taché jusqu'à ce qu'il soit décroché.  Autrement dit, le fil disparaît.  Dans ce cas, les fils porteurs peuvent se terminer, et en général, cela rompt toute l'idée de fibre. </p><br><p>  La manière de résoudre ce problème est déjà connue et des discussions sont en cours à ce sujet. </p><br><h2 id="problema-dva---synchronized-bloki">  Problème deux - blocs synchronisés </h2><br><p>  Ce sont des ordures beaucoup plus graves </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (object) { <span class="hljs-comment"><span class="hljs-comment">//may park object.wait(); //may park }</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (object) { <span class="hljs-comment"><span class="hljs-comment">//may park socket.getInputStream().read(); //may park }</span></span></code> </pre> <br><p>  En cas de capture du moniteur dans la fibre, les fils du support démarrent également. </p><br><p>  Il est clair que dans un code complètement nouveau, vous pouvez changer les moniteurs en verrous directs, au lieu d'attendre + de notifier, vous pouvez utiliser des objets de condition, mais que faire de l'héritage?  C'est un problème. </p><br><h1 id="thread-api-threadcurrentthread-thread-locals">  API de thread?  Thread.currentThread ()?  Thread locaux? </h1><br><p>  Dans le prototype actuel, <code>Thread</code> et <code>Fiber</code> ont créé une superclasse commune appelée <code>Strand</code> . </p><br><p>  Cela vous permet de transférer l'API de la manière la plus minimale. <br>  Que faire ensuite - comme toujours dans ce projet, est une question. </p><br><p>  Que se passe-t-il avec l'API Thread maintenant? </p><br><ul><li>  La première utilisation de <code>Thread.currentThread()</code> dans une fibre crée une sorte de thread fantôme, Shadow Thread; </li><li>  du point de vue du système, il s'agit d'un thread «non publié», et il n'y a aucune méta-information VM dedans; </li><li>  ST essaie d'imiter tout ce qu'il peut; </li><li>  mais vous devez comprendre que l'ancienne API a beaucoup de déchets; </li><li>  plus spécifiquement, Shadow Thread implémente l'API Thread pour tout sauf <code>stop</code> , <code>suspend</code> , <code>resume</code> et gérer les exceptions non interceptées. </li></ul><br><p>  Que faire des sections locales de threads? </p><br><ul><li>  maintenant les sections locales de fil se transforment en sections locales de fibre; </li><li>  il y a beaucoup de problèmes avec cela, tout cela est en discussion; </li><li>  un ensemble d'utilisations est particulièrement discuté; </li><li>  Les threads ont historiquement utilisé à la fois correctement et incorrectement (ceux qui utilisent incorrectement espèrent toujours quelque chose, et vous ne pouvez pas les décevoir complètement); </li><li>  en général, cela crée toute une gamme d'applications: <br><ul><li>  Haut niveau: cache des connexions ou des mots de passe dans le conteneur; </li><li>  Bas niveau: processeur dans les bibliothèques système. </li></ul></li></ul><br><h1 id="skolko-vse-eto-zhret">  Combien tout cela mange </h1><br><p><img src="https://habrastorage.org/webt/pl/7-/pi/pl7-pidz-d2o3l98qx2srbmezxi.png"><br><br></p><br><p>  Discussion: </p><br><ul><li>  Pile: 1 Mo et 16 Ko sur les structures de données du noyau; </li><li>  Par instance de thread: 2300 octets, y compris les méta-informations VM. </li></ul><br><p>  Fibre: </p><br><ul><li>  Pile de continuation: de centaines d'octets à kilo-octets; </li><li>  Par instance de fibre: 200-240 octets. </li></ul><br><p>  La différence est énorme! <br>  Et c’est exactement ce qui permet à des millions de personnes de s’activer. </p><br><h1 id="chto-mozhet-parkovatsya">  Que peut garer </h1><br><p>  Il est clair que la chose la plus magique est le stationnement automatique lorsque certains événements se produisent.  Qu'est-ce qui est actuellement pris en charge? </p><br><ul><li>  Thread.sleep, rejoignez; </li><li>  java.util.concurrent et LockSupport.lock; </li><li>  IO: réseau sur sockets (socket lire, écrire, connecter, accepter), fichiers, tubes; </li><li>  Tout cela n'est pas terminé, mais la lumière dans le tunnel est visible. </li></ul><br><h1 id="kommunikaciya-mezhdu-fayberami">  Communication entre fibre </h1><br><p>  Une autre question que tout le monde se pose est: comment échanger de manière compétitive des informations entre les fibres. </p><br><ul><li>  Le prototype actuel lance des tâches dans <code>Runnable</code> , peut être converti en <code>CompletableFuture</code> , si pour une raison quelconque vous en avez besoin; </li><li>  java.util.concurrent "fonctionne juste."  Vous pouvez tout tâtonner de manière standard; </li><li>  il peut y avoir de nouvelles API pour le multithreading, mais ce n'est pas exact; </li><li>  un tas de petites questions comme «les fibres devraient-elles renvoyer des valeurs?»;  tout est discuté, ils ne sont pas dans le prototype. </li></ul><br><h1 id="kak-realizovany-kontinuacii-v-prototipe">  Comment les suites sont-elles implémentées dans le prototype? </h1><br><p>  Des exigences évidentes sont imposées à la suite: vous devez utiliser le moins de RAM possible et vous devez basculer entre elles le plus rapidement possible.  Sinon, cela ne fonctionnera pas pour les garder par millions.  La tâche principale ici est en quelque sorte de ne pas faire une copie complète de la pile pour chaque parking-uppark.  Et il y a un tel schéma!  Essayons d'expliquer cela dans les images. </p><br><p>  La façon la plus cool serait, bien sûr, de simplement mettre toutes les piles sur une hanche java et de les utiliser directement.  Mais il n'est pas clair comment coder maintenant, donc le prototype utilise la copie.  Mais copier avec un petit mais important hack. </p><br><p>  Nous avons deux chaises ... Je veux dire, deux piles.  Deux tableaux java dans la hanche.  L'un est un tableau d'objets, où nous stockons les références aux objets.  Le second est primitif (par exemple, intime), qui gérera tout le reste. </p><br><p><img src="https://habrastorage.org/webt/33/tf/cj/33tfcj897awloqfisxfwwl-4ypy.png"><br><br></p><br><p>  Nous sommes maintenant dans un état où la poursuite est sur le point d'être effectuée pour la toute première fois. </p><br><p>  <code>run</code> appelle une méthode interne appelée <code>enter</code> : </p><br><p><img src="https://habrastorage.org/webt/j6/d5/ki/j6d5kioz8ygupanxditl3iaslbi.png"><br><br></p><br><p>  Et puis le code utilisateur est exécuté, jusqu'au premier éviction. </p><br><p><img src="https://habrastorage.org/webt/ab/on/6c/abon6cdsoepe-ts69pkmm9sk35i.png"><br><br></p><br><p>  À ce stade, un appel VM est effectué, ce qui <code>freeze</code> appels.  Dans ce prototype, cela se fait directement physiquement - en utilisant la copie. </p><br><p><img src="https://habrastorage.org/webt/iu/or/jv/iuorjvmb6xrjnycvx3nxbdcqxxc.png"><br><br></p><br><p>  Nous commençons le processus de copie séquentielle des images de la pile native vers java hip. </p><br><p><img src="https://habrastorage.org/webt/ln/nu/sm/lnnusmrix2hsqpwxmzkeemd_or0.png"><br><br></p><br><p>  Il est nécessaire de vérifier si les moniteurs y sont maintenus ou si le code natif est utilisé, ou autre chose qui ne nous permettra vraiment pas de continuer à travailler. </p><br><p><img src="https://habrastorage.org/webt/vl/5c/k0/vl5ck0i3jtouapded9snnl9brvy.png"><br><br></p><br><p>  Et si tout va bien, nous copions d'abord dans un tableau primitif: </p><br><p><img src="https://habrastorage.org/webt/ka/z_/gl/kaz_glkmthfyd1x8rzdprn3v8ym.png"><br><br></p><br><p>  Ensuite, nous isolons les références aux objets et les enregistrons dans le tableau d'objets: </p><br><p><img src="https://habrastorage.org/webt/xc/2q/nb/xc2qnbafy_2eybwzif-3s3vmaym.png"><br><br></p><br><p>  En fait, deux thés à tous ceux qui ont lu cet endroit! </p><br><p>  De plus, nous continuons cette procédure pour tous les autres éléments de la pile native. </p><br><p><img src="https://habrastorage.org/webt/6e/sp/-0/6esp-07i4dyasxj5esb9qu6fh5i.png"><br><br></p><br><p>  Hourra!  Nous avons tout copié dans le nid dans la hanche.  Vous pouvez sauter en toute sécurité sur le lieu de l'appel sans craindre que nous ayons perdu quelque chose.  Tout est branché. </p><br><p><img src="https://habrastorage.org/webt/bq/sz/ju/bqszjuffw-s4f14audafvzbmqzc.png"><br><br></p><br><p>  Tôt ou tard, le code appelant appellera à nouveau notre continuation.  Et elle doit continuer de l'endroit où elle a été laissée la dernière fois.  Telle est notre tâche. </p><br><p><img src="https://habrastorage.org/webt/8i/bg/x9/8ibgx9r_26wedxrahar1vfqdifi.png"><br><br></p><br><p>  Vérifier si la continuation était en cours, dit oui, elle était en cours.  Donc, vous devez appeler VM, nettoyer de l'espace sur la pile et appeler la fonction interne de <code>thaw</code> VM.  «Dégel» est traduit en russe par «dégel», «dégeler», ce qui semble assez logique.  Il est nécessaire de libérer les images de la pile de continuation dans notre pile native principale. </p><br><p>  Je ne suis pas sûr que le dégivrage du thé soit assez clair.  La mauvaise abstraction est comme un chaton avec une porte.  Mais cela fera l'affaire pour nous. </p><br><p><img src="https://habrastorage.org/webt/ra/sv/5v/rasv5v_5w8_dpegomn_omgtdiza.png"><br><br></p><br><p>  Nous faisons des copies assez évidentes. </p><br><p>  Tout d'abord avec un tableau primitif: </p><br><p><img src="https://habrastorage.org/webt/wc/he/vg/wchevg-fsflrnicy0itprkp0q2e.png"><br><br></p><br><p>  Puis à partir du lien: </p><br><p><img src="https://habrastorage.org/webt/o_/o2/6s/o_o26sakm0n5hyq9wisbo7vouge.png"><br><br></p><br><p>  Vous devez patcher un peu le copié pour obtenir la pile correcte: </p><br><p><img src="https://habrastorage.org/webt/sm/h7/0n/smh70naepp3kshxaa78zxv1g2du.png"><br><br></p><br><p>  Répétez l'obscénité pour toutes les images: </p><br><p><img src="https://habrastorage.org/webt/cg/dv/61/cgdv617uqeriqmuqcyc2jkjpnbe.png"><br><br></p><br><p>  Vous pouvez maintenant revenir en arrière et continuer comme si de rien n'était. </p><br><p><img src="https://habrastorage.org/webt/gn/dd/xw/gnddxwqqsrwuidc9ev2nxwmiwqc.png"><br><br></p><br><p>  Le problème est qu'une copie complète de la pile n'est pas du tout ce que nous aimerions avoir.  C'est très inhibiteur.  Tout cela est l'isolement des liens, vérifie l'épinglage, ce n'est pas rapide.  Et surtout - tout cela dépend linéairement de la taille de la pile!  En un mot, l'enfer.  Pas besoin de faire ça. </p><br><p>  Au lieu de cela, nous avons une autre idée - la copie paresseuse. </p><br><p>  Revenons à l'endroit où nous avons déjà une continuation figée. </p><br><p><img src="https://habrastorage.org/webt/5b/hw/tg/5bhwtgg8cfg-agcwu_kdtrqlify.png"><br><br></p><br><p>  Nous continuons le processus comme auparavant: </p><br><p><img src="https://habrastorage.org/webt/rj/ac/f9/rjacf9tmfekskko8jwojuocxixm.png"><br><br></p><br><p>  De la même manière que précédemment, nous nettoyons l'endroit sur la pile native: </p><br><p><img src="https://habrastorage.org/webt/nm/ol/ow/nmolowac-dkmdefuobd-kaijyeq.png"><br><br></p><br><p>  Mais nous ne copions pas tout de suite, mais seulement une ou deux images: </p><br><p><img src="https://habrastorage.org/webt/3a/ca/1x/3aca1xglgfbq8yzwxkjypelxpqy.png"><br><br></p><br><p>  Maintenant, le hack.  Vous devez patcher l'adresse de retour de la méthode <code>C</code> afin qu'elle pointe vers une certaine barrière de retour: </p><br><p><img src="https://habrastorage.org/webt/zs/si/3z/zssi3zgaadvvsrg883agxsmq3pc.png"><br><br></p><br><p>  Maintenant, vous pouvez revenir en toute sécurité au <code>yield</code> : </p><br><p><img src="https://habrastorage.org/webt/e1/f_/2s/e1f_2snf4bh-ggjcv5lrgabqkwk.png"><br><br></p><br><p>  Ce qui à son tour conduira à un appel au code utilisateur dans la méthode <code>C</code> : </p><br><p><img src="https://habrastorage.org/webt/y2/nl/rm/y2nlrmn9lczwhcaa3f41ii69nq0.png"><br><br></p><br><p>  Imaginez maintenant que <code>C</code> veut revenir au code qui l'a appelé.  Mais son invocateur est <code>B</code> , et il n'est pas sur la pile!  Par conséquent, lorsqu'il tentera de revenir, il ira à l'adresse de retour, et cette adresse est maintenant la barrière de retour.  Et, vous savez, cela attirera à nouveau un appel de <code>thaw</code> : </p><br><p><img src="https://habrastorage.org/webt/hb/6g/8d/hb6g8dfw35ujqntvi-y7lzyskis.png"><br><br></p><br><p>  Et le <code>thaw</code> libérera la prochaine image sur la pile de continuation, et c'est <code>B</code> : </p><br><p><img src="https://habrastorage.org/webt/cp/mp/ao/cpmpao3_arvnvgykenc9r4fgwsk.png"><br><br></p><br><p>  En fait, nous l'avons copié paresseusement, sur demande. </p><br><p>  Ensuite, nous supprimons <code>B</code> de la pile de continuation et définissons à nouveau la barrière (la barrière doit être définie car il reste quelque chose sur la pile de continuation).  Et ainsi de suite. </p><br><p><img src="https://habrastorage.org/webt/gv/yo/0u/gvyo0u4iwzunuqovy1yv_-jbutq.png"><br><br></p><br><p>  Mais supposons que <code>B</code> ne revienne pas au code appelant, mais appelle d'abord une autre méthode <code>D</code>  Et cette nouvelle méthode veut également être évincée. </p><br><p><img src="https://habrastorage.org/webt/f9/1i/t9/f91it9xn705zsxuzvvbqh5gdoqi.png"><br><br></p><br><p>  Dans ce cas, lorsque viendra le temps de <code>freeze</code> , nous n'aurons besoin de copier que le haut de la pile native sur la pile de continuation: </p><br><p><img src="https://habrastorage.org/webt/pt/8b/ul/pt8buljt77lsp-wj-rswobc4v_y.png"><br><br></p><br><p>  Ainsi, la quantité de travail effectuée ne dépend pas linéairement de la taille de la pile.  Cela dépend linéairement uniquement du nombre d'images que nous avons réellement utilisées dans le travail. </p><br><h1 id="chto-ostalos">  Que reste-t-il? </h1><br><p>  Les développeurs gardent à l'esprit certaines fonctionnalités, mais ils ne sont pas entrés dans le prototype. </p><br><ul><li>  Sérialisation et clonage.  La possibilité de continuer sur une autre machine, à un autre moment, etc. </li><li>  JVM TI et débogage, comme s'il s'agissait de threads normaux.  Si vous êtes bloqué à la lecture de la prise, vous ne verrez pas un beau saut de rendement, dans le prototype le fil sera simplement bloqué, comme tout autre fil ordinaire. </li><li>  La récursivité de la queue n'a même pas été touchée. </li></ul><br><p>  Prochaines étapes: </p><br><ul><li>  Créez une API humaine; </li><li>  Ajoutez toutes les fonctionnalités manquantes; </li><li>  Améliorez les performances. </li></ul><br><h1 id="gde-vzyat">  Où trouver </h1><br><p>  Le prototype est réalisé sous forme de brunch dans le référentiel OpenJDK.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vous pouvez télécharger le prototype ici</a> en passant aux <code>fibers</code> brunch. </p><br><p>  C'est fait comme ceci: </p><br><pre> <code class="bash hljs">$ hg <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> http://hg.openjdk.java.net/loom/loom $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> loom $ hg update -r fibers $ sh configure $ make images</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous le savez, tout cela va commencer l'assemblage de ce putain d'OpenJDK. </font><font style="vertical-align: inherit;">Par conséquent, premièrement, la prochaine demi-heure de votre vie devra faire autre chose, pendant que tout cela se passe.</font></font></p><br><p><img src="https://habrastorage.org/webt/gk/qz/3-/gkqz3-f8gmkcwkynnnrp4opp1rg.png"><br><br></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxièmement, vous devez disposer d'un ordinateur correctement configuré avec une chaîne d'outils C ++ et des bibliothèques GNU. </font><font style="vertical-align: inherit;">Je laisse entendre qu'il n'est pas recommandé de le faire sous Windows. </font><font style="vertical-align: inherit;">Sérieusement, même en téléchargeant VirtualBox et en y installant un nouvel Ubuntu, vous passerez des ordres de grandeur moins de temps que d'essayer de réaliser une autre erreur inhumaine lors de la construction à partir de Cygwin ou msys64. </font><font style="vertical-align: inherit;">C'est là que msys est encore pire que Cygwin.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que ce ne soit, bien sûr, qu'un mensonge, je me lasse de vous écrire </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des instructions de montage</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p><br><p>   -   ,   mercurial extension   fsmonitor. ,   ,   <code>hg help -e fsmonitor</code> . <br>      ~/.hgrc  : </p><br><pre> <code class="plaintext hljs">[fsmonitor] mode = on</code> </pre> <br><p>  -           .             -, <code>cp -R ./loom ./loom-backup</code> . </p><br><p>  ,          . ,   Java-    ,       . </p><br><p> <code>sh configure</code>    - . ,     Ubuntu,     Autoconf ( <code>sudo apt-get install autoconf</code> ).  —     OpenJDK   Ubuntu,     ,  .  Windows      ,   . </p><br><p> ,     ,   <code>hg diff --stat -r default:fibers</code> . </p><br><p>  ,          ,   ,     . </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>      «, ».   «», . «Loom» —  « ».  Project Loom         . </p><br><p>          ,        . ,      «»  ,  ,      —  , ,  , —  . </p><br><p> ,   ,          XIX    ,        . </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/305/64e/143/30564e14316852dd18d4235b3850e134.jpg"><br><p>      . -,  . </p><br><p> ,                 .        IDE   . </p><br><p>          ,       ,   ,    « », «», « »   . </p><br><p>       ?   .   . </p><br><p>  Je vous remercie </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422519/">https://habr.com/ru/post/fr422519/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422509/index.html">Résumé du livre "Never Eat Alone"</a></li>
<li><a href="../fr422511/index.html">Chargement des données dans Splunk: Universal Forwarder vs Heavy Forwarder. Quelle est la différence?</a></li>
<li><a href="../fr422513/index.html">7 conseils pour ne pas exaspérer un collègue testeur pendant ses vacances</a></li>
<li><a href="../fr422515/index.html">Deux mitaps Apache Ignite et webinaire sur l'informatique en mémoire en septembre</a></li>
<li><a href="../fr422517/index.html">TelegramBot dans le Wolfram Cloud</a></li>
<li><a href="../fr422521/index.html">Prédiction de l'inévitable</a></li>
<li><a href="../fr422525/index.html">"La matrice de l'amitié." Le graphique social le plus ancien pour le plus petit</a></li>
<li><a href="../fr422527/index.html">Résumé des nouvelles de PostgreSQL. Numéro 10</a></li>
<li><a href="../fr422529/index.html">Cours spécial Groupe-IB: «Sécurité des applications mobiles»</a></li>
<li><a href="../fr422531/index.html">Optimisation Web: le plus important</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>