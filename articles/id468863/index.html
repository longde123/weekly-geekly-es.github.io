<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📌 👺 👨🏿‍🍳 Internal Go: bungkus variabel loop dalam penutupan 🕹️ 🙃 🌪️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini saya memutuskan untuk menerjemahkan untuk Anda sebuah artikel pendek tentang bagian dalam implementasi yang disebut penutupan atau penutupan....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Internal Go: bungkus variabel loop dalam penutupan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/468863/"><p><img src="https://habrastorage.org/webt/a2/v0/es/a2v0es8qfgkdntuzeattfznxanq.jpeg"></p><br><p>  <em>Hari ini saya memutuskan untuk menerjemahkan untuk Anda sebuah artikel pendek tentang bagian dalam implementasi yang disebut penutupan atau penutupan.</em>  <em>Selain itu, Anda akan mempelajari cara Go mencoba menentukan secara otomatis apakah menggunakan pointer / tautan atau nilai dalam berbagai kasus.</em>  <em>Memahami hal-hal ini akan menghindari kesalahan.</em>  <em>Dan hanya saja semua bagian dalam ini sangat menarik, saya pikir!</em> </p><br><p>  <em>Dan saya juga ingin mengundang Anda ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Golang Conf 2019</a> , yang akan diselenggarakan pada 7 Oktober di Moskow.</em>  <em>Saya adalah anggota komite program konferensi, dan kolega saya dan saya telah memilih banyak laporan yang sama-sama hardcore dan sangat, sangat menarik.</em>  <em>Apa yang saya sukai!</em> </p><br><p>  <em>Di bawah potongan, saya menyampaikan kata itu kepada penulis.</em> </p><a name="habracut"></a><br><br><p>  Ada halaman di Go wiki berjudul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frequent Kesalahan</a> .  Anehnya, hanya ada satu contoh: penyalahgunaan variabel loop dengan goroutine: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, val := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> values { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(val) }() }</code> </pre> <br><p>  Kode ini akan menampilkan nilai terakhir dari array nilai len (values) kali.  Memperbaiki kodenya sangat sederhana: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// assume the type of each value is string for _, val := range values { go func(val string) { fmt.Println(val) }(val) }</span></span></code> </pre> <br><p>  Contoh ini cukup untuk memahami masalah dan tidak pernah lagi membuat kesalahan.  Tetapi jika Anda tertarik untuk mengetahui detail implementasi, artikel ini akan memberi Anda pemahaman yang mendalam tentang masalah dan solusinya. </p><br><h1 id="bazovye-veschi-peredacha-po-znacheniyu-i-peredacha-po-ssylke">  Hal-hal dasar: lewat nilai dan lewat referensi </h1><br><p>  Dalam Go, ada perbedaan dalam melewatkan objek berdasarkan nilai dan referensi [1].  Mari kita mulai dengan <strong>contoh 1</strong> [2]: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> foobyval(i) } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre><br><p>  Tidak seorang pun, kemungkinan besar, memiliki keraguan bahwa hasilnya akan ditampilkan nilai dari 0 hingga 4. Mungkin dalam semacam urutan acak. </p><br><p>  Mari kita lihat <strong>contoh 2</strong> . </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(*n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> foobyref(&amp;i) } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Akibatnya, berikut ini akan ditampilkan: </p><br><p>  5 <br>  5 <br>  5 <br>  5 <br>  5 </p><br><p>  Memahami mengapa hasilnya hanya itu akan memberi kita sudah 80% dari pemahaman tentang esensi masalah.  Karena itu, mari luangkan waktu untuk menemukan alasannya. </p><br><p>  Dan jawabannya ada di sana dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi bahasa Go</a> .  Spesifikasi berbunyi: </p><br><blockquote>  Variabel yang dideklarasikan dalam pernyataan inisialisasi digunakan kembali di setiap loop. </blockquote><p>  Ini berarti bahwa ketika program sedang berjalan, hanya ada satu objek atau sepotong memori untuk variabel i, dan bukan yang baru dibuat untuk setiap siklus.  Objek ini mengambil nilai baru di setiap iterasi. </p><br><p>  Mari kita lihat perbedaan dalam kode mesin yang dihasilkan [3] untuk loop dalam contoh 1 dan 2. Mari kita mulai dengan contoh 1. </p><br><pre> <code class="plaintext hljs">0x0026 00038 (go-func-byval.go:14) MOVL $8, (SP) 0x002d 00045 (go-func-byval.go:14) LEAQ "".foobyval·f(SB), CX 0x0034 00052 (go-func-byval.go:14) MOVQ CX, 8(SP) 0x0039 00057 (go-func-byval.go:14) MOVQ AX, 16(SP) 0x003e 00062 (go-func-byval.go:14) CALL runtime.newproc(SB) 0x0043 00067 (go-func-byval.go:13) MOVQ "".i+24(SP), AX 0x0048 00072 (go-func-byval.go:13) INCQ AX 0x004b 00075 (go-func-byval.go:13) CMPQ AX, $5 0x004f 00079 (go-func-byval.go:13) JLT 33</code> </pre> <br><p>  Pernyataan Go menjadi panggilan ke fungsi runtime.newproc.  Mekanisme dari proses ini sangat menarik, tetapi mari kita tinggalkan ini untuk artikel selanjutnya.  Sekarang kita lebih tertarik pada apa yang terjadi pada variabel i.  Ini disimpan dalam register AX, yang kemudian diteruskan oleh nilai melalui tumpukan ke fungsi foobyval [4] sebagai argumennya.  “Berdasarkan nilai” dalam hal ini seperti menyalin nilai register AX ke stack.  Dan mengubah AX di masa depan tidak mempengaruhi apa yang diteruskan ke fungsi foobyval. </p><br><p>  Dan berikut ini contohnya 2: </p><br><pre> <code class="plaintext hljs">0x0040 00064 (go-func-byref.go:14) LEAQ "".foobyref·f(SB), CX 0x0047 00071 (go-func-byref.go:14) MOVQ CX, 8(SP) 0x004c 00076 (go-func-byref.go:14) MOVQ AX, 16(SP) 0x0051 00081 (go-func-byref.go:14) CALL runtime.newproc(SB) 0x0056 00086 (go-func-byref.go:13) MOVQ "".&amp;i+24(SP), AX 0x005b 00091 (go-func-byref.go:13) INCQ (AX) 0x005e 00094 (go-func-byref.go:13) CMPQ (AX), $5 0x0062 00098 (go-func-byref.go:13) JLT 57</code> </pre> <br><p>  Kode ini sangat mirip - hanya dengan satu perbedaan, tetapi sangat penting.  Sekarang di AX adalah alamat i, dan bukan nilainya.  Perhatikan juga bahwa penambahan dan perbandingan untuk loop dilakukan pada (AX), bukan AX.  Dan kemudian, ketika kita menaruh AX di tumpukan, kita, ternyata, meneruskan alamat i ke fungsi.  Perubahan (AX) juga akan terlihat di goroutine. </p><br><p>  Tidak ada kejutan.  Pada akhirnya, kita meneruskan sebuah pointer ke angka dalam fungsi foobyref. <br>  Selama operasi, siklus berakhir lebih cepat daripada goroutine yang dibuat mulai bekerja.  Ketika mereka mulai bekerja, mereka akan memiliki pointer ke variabel i yang sama, dan bukan ke salinan.  Dan apa nilai saya saat ini?  Nilainya 5. Sangat di mana siklus berhenti.  Dan itulah sebabnya semua goroutine berasal dari 5. </p><br><h1 id="metody-so-znacheniem-vs-metody-s-ukazatelem">  Metode dengan metode nilai VS dengan pointer </h1><br><p>  Perilaku serupa dapat diamati ketika membuat goroutine yang menggunakan metode apa pun.  Ini ditunjukkan oleh halaman wiki yang sama.  Lihat <strong>contoh 3</strong> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mi MyInt)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(mi) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ms := []MyInt{<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, m := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ms { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> m.Show() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Contoh ini menampilkan elemen-elemen dari array ms.  Secara acak, seperti yang kami harapkan.  Contoh yang sangat mirip <strong>4</strong> menggunakan metode pointer untuk metode Show: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mi *MyInt)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(*mi) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ms := []MyInt{<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, m := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ms { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> m.Show() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Coba tebak kesimpulannya nanti: 90, dicetak lima kali.  Alasannya sama seperti pada contoh 2. Di sini masalahnya kurang terlihat karena gula sintaksis di Go saat menggunakan metode pointer.  Jika dalam contoh, ketika beralih dari contoh 1 ke contoh 2, kami mengubah i ke &amp; i, di sini panggilannya terlihat sama!  m.Tampilkan () dalam kedua contoh, dan perilaku berbeda. </p><br><p>  Bukan kombinasi yang sangat menyenangkan dari dua fitur Go, menurut saya.  Tidak ada di tempat panggilan yang menunjukkan transmisi dengan referensi.  Dan Anda perlu melihat implementasi dari metode Show untuk melihat dengan tepat bagaimana panggilan akan terjadi (dan metode ini, tentu saja, dapat berupa file atau paket yang sama sekali berbeda). </p><br><p>  Dalam kebanyakan kasus, fitur ini bermanfaat.  Kami menulis kode pembersih.  Tapi di sini, lewat referensi mengarah ke efek yang tidak terduga. </p><br><h1 id="zamykaniya">  Sirkuit pendek </h1><br><p>  Akhirnya kami sampai pada penutupan.  Mari kita lihat <strong>contoh 5</strong> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foobyval(i) }() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Dia akan mencetak yang berikut ini: </p><br><p>  5 <br>  5 <br>  5 <br>  5 <br>  5 </p><br><p>  Dan ini terlepas dari kenyataan bahwa saya diteruskan dengan nilai ke foobyval di penutupan.  Mirip dengan contoh 1. Tapi mengapa?  Mari kita lihat tampilan loop assembler: </p><br><pre> <code class="plaintext hljs">0x0040 00064 (go-closure.go:14) LEAQ "".main.func1·f(SB), CX 0x0047 00071 (go-closure.go:14) MOVQ CX, 8(SP) 0x004c 00076 (go-closure.go:14) MOVQ AX, 16(SP) 0x0051 00081 (go-closure.go:14) CALL runtime.newproc(SB) 0x0056 00086 (go-closure.go:13) MOVQ "".&amp;i+24(SP), AX 0x005b 00091 (go-closure.go:13) INCQ (AX) 0x005e 00094 (go-closure.go:13) CMPQ (AX), $5 0x0062 00098 (go-closure.go:13) JLT 57</code> </pre> <br><p>  Kode ini sangat mirip dengan Contoh 2: perhatikan bahwa saya diwakili oleh alamat dalam register AX.  Artinya, kami melewati saya dengan referensi.  Dan ini terlepas dari fakta bahwa foobyval dipanggil.  Tubuh loop memanggil fungsi menggunakan runtime.newproc, tetapi dari mana fungsi ini berasal? </p><br><p>  Func1 dibuat oleh kompiler, dan itu adalah penutup.  Kompiler telah mengalokasikan kode penutupan sebagai fungsi terpisah dan memanggilnya dari main.  Masalah utama dengan alokasi ini adalah bagaimana menangani variabel yang menggunakan penutupan, tetapi yang jelas bukan argumen. </p><br><p>  Seperti inilah bentuk tubuh func1: </p><br><pre> <code class="plaintext hljs">0x0000 00000 (go-closure.go:14) MOVQ (TLS), CX 0x0009 00009 (go-closure.go:14) CMPQ SP, 16(CX) 0x000d 00013 (go-closure.go:14) JLS 56 0x000f 00015 (go-closure.go:14) SUBQ $16, SP 0x0013 00019 (go-closure.go:14) MOVQ BP, 8(SP) 0x0018 00024 (go-closure.go:14) LEAQ 8(SP), BP 0x001d 00029 (go-closure.go:15) MOVQ "".&amp;i+24(SP), AX 0x0022 00034 (go-closure.go:15) MOVQ (AX), AX 0x0025 00037 (go-closure.go:15) MOVQ AX, (SP) 0x0029 00041 (go-closure.go:15) CALL "".foobyval(SB) 0x002e 00046 (go-closure.go:16) MOVQ 8(SP), BP 0x0033 00051 (go-closure.go:16) ADDQ $16, SP 0x0037 00055 (go-closure.go:16) RET</code> </pre> <br><p>  Sangat menarik di sini bahwa fungsi memiliki argumen dalam 24 (SP), yang merupakan pointer ke int: lihat garis MOVQ (AX), AX, yang mengambil nilai sebelum meneruskannya ke foobyval.  Bahkan, func1 terlihat seperti ini: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { foobyval(*i) }    main   - : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> func1(&amp;i) }</code> </pre><br><p>  Menerima yang setara dengan contoh 2, dan ini menjelaskan kesimpulannya.  Dalam bahasa teknis, kami akan mengatakan bahwa saya adalah variabel bebas di dalam penutupan dan variabel tersebut ditangkap dengan referensi di Go. </p><br><p>  Tetapi apakah ini selalu terjadi?  Anehnya, jawabannya adalah tidak.  Dalam beberapa kasus, variabel bebas ditangkap oleh nilai.  Berikut adalah variasi dari contoh kami: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { ii := i <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foobyval(ii) }() }</code> </pre> <br><p>  Contoh ini akan menampilkan 0, 1, 2, 3, 4 dalam urutan acak.  Tetapi mengapa perilaku di sini berbeda dari Contoh 5? </p><br><p>  Ternyata perilaku ini merupakan artefak heuristik yang digunakan kompilator Go ketika bekerja dengan penutupan. </p><br><h1 id="smotrim-pod-kapot">  Kami melihat di bawah tenda </h1><br><p>  Jika Anda tidak terbiasa dengan arsitektur kompiler Go, saya sarankan Anda membaca artikel awal saya tentang topik ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> . </p><br><p>  Pohon sintaksis spesifik (yang bertentangan dengan abstrak) yang diperoleh dengan menguraikan kode terlihat seperti ini: </p><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>: *syntax.CallStmt { . Tok: <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> . Call: *syntax.CallExpr { . . Fun: *syntax.FuncLit { . . . Type: *syntax.FuncType { . . . . ParamList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . . . ResultList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . . } . . . Body: *syntax.BlockStmt { . . . . List: []syntax.Stmt (<span class="hljs-number"><span class="hljs-number">1</span></span> entries) { . . . . . <span class="hljs-number"><span class="hljs-number">0</span></span>: *syntax.ExprStmt { . . . . . . X: *syntax.CallExpr { . . . . . . . Fun: foobyval @ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-closure.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span> . . . . . . . ArgList: []syntax.Expr (<span class="hljs-number"><span class="hljs-number">1</span></span> entries) { . . . . . . . . <span class="hljs-number"><span class="hljs-number">0</span></span>: i @ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-closure.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span> . . . . . . . } . . . . . . . HasDots: <span class="hljs-literal"><span class="hljs-literal">false</span></span> . . . . . . } . . . . . } . . . . } . . . . Rbrace: syntax.Pos {} . . . } . . } . . ArgList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . HasDots: <span class="hljs-literal"><span class="hljs-literal">false</span></span> . } }</code> </pre> <br><p>  Fungsi yang disebut diwakili oleh simpul FuncLit, fungsi konstan.  Ketika pohon ini dikonversi ke AST (pohon sintaksis abstrak), menyoroti fungsi konstan ini sebagai yang terpisah akan menjadi hasilnya.  Ini terjadi pada metode noder.funcLit, yang hidup di gc / closure.go. </p><br><p>  Kemudian pemeriksa tipe menyelesaikan transformasi, dan kami mendapatkan representasi berikut untuk fungsi di AST: </p><br><pre> <code class="go hljs">main.func1: . DCLFUNC l(<span class="hljs-number"><span class="hljs-number">14</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) FUNC-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DCLFUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-function"> . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CALLFUNC</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(15)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> . . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NAME</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(8)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(0)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PFUNC)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">used</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CALLFUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-function"> . . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NAME</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">il</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(15)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(0)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PAUTOHEAP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">used</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span></code> </pre> <br><p>  Perhatikan bahwa nilai yang diteruskan ke foobyval adalah NAME-main.i, yaitu, kami secara eksplisit menunjuk ke variabel dari fungsi yang membungkus penutupan. </p><br><p>  Pada tahap ini, tahap kompiler, yang disebut captvars, yaitu, "menangkap variabel", mulai beroperasi.  Tujuannya adalah untuk memutuskan bagaimana menangkap "variabel tertutup" (yaitu, variabel bebas yang digunakan dalam penutupan).  Berikut adalah komentar dari fungsi kompiler yang sesuai, yang juga menjelaskan heuristik: </p><br><p>  // capturevars dipanggil dalam fase terpisah setelah semua jenis dicek. <br>  // Ini memutuskan apakah akan menangkap variabel dengan nilai atau dengan referensi. <br>  // Kami menggunakan tangkapan oleh nilai untuk nilai &lt;= 128 byte yang tidak lagi mengubah nilai setelah penangkapan (pada dasarnya konstanta). </p><br><p>  Ketika capturevars disebut dalam Contoh 5, ia memutuskan bahwa variabel loop i harus ditangkap dengan referensi, dan menambahkan flag addrtaken yang sesuai dengannya.  Ini dapat dilihat pada output AST: </p><br><pre> <code class="go hljs">FOR l(<span class="hljs-number"><span class="hljs-number">13</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) . LT l(<span class="hljs-number"><span class="hljs-number">13</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> . . NAME-main.ia(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) g(<span class="hljs-number"><span class="hljs-number">1</span></span>) l(<span class="hljs-number"><span class="hljs-number">13</span></span>) x(<span class="hljs-number"><span class="hljs-number">0</span></span>) class(PAUTOHEAP) esc(h) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) addrtaken assigned used <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br><p>  Untuk variabel loop, heuristik pemilihan "oleh nilai" tidak berfungsi, karena variabel mengubah nilainya setelah panggilan (ingat kutipan dari spesifikasi bahwa variabel loop digunakan kembali pada setiap iterasi).  Oleh karena itu, variabel i ditangkap dengan referensi. <br>  Dalam variasi contoh kita, di mana kita memiliki ii: = i, ii tidak digunakan lagi dan oleh karena itu ditangkap oleh nilai [5]. </p><br><p>  Jadi, kita melihat contoh yang menakjubkan dari tumpang tindih dua fitur bahasa yang berbeda secara tak terduga.  Alih-alih menggunakan variabel baru di setiap iterasi loop, Go menggunakan yang sama.  Ini, pada gilirannya, mengarah pada pemicu heuristik dan pilihan penangkapan dengan referensi, dan ini mengarah pada hasil yang tidak terduga.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Go FAQ</a> mengatakan bahwa perilaku ini mungkin merupakan kesalahan desain. </p><br><blockquote>  Perilaku ini (jangan gunakan variabel baru) mungkin merupakan kesalahan saat merancang bahasa.  Mungkin kami akan memperbaikinya di versi mendatang, tetapi karena kompatibilitas ke belakang kami tidak dapat melakukan apa pun di Go versi 1. </blockquote><p>  Jika Anda mengetahui masalahnya, kemungkinan besar Anda tidak akan menginjak rake ini.  Namun perlu diingat bahwa variabel bebas selalu dapat ditangkap dengan referensi.  Untuk menghindari kesalahan, pastikan bahwa hanya variabel read-only yang ditangkap saat menggunakan goroutin.  Ini juga penting karena potensi masalah dengan penerbangan data. </p><br><hr><br><p>  [1] Beberapa pembaca telah memperhatikan bahwa, sesungguhnya, tidak ada konsep "lewat referensi" di Go, karena semuanya dilewatkan oleh nilai, termasuk petunjuk.  Dalam artikel ini, ketika Anda melihat "pass by reference", maksud saya "pass by address" dan itu eksplisit dalam beberapa kasus (seperti meneruskan &amp; n ke fungsi yang mengharapkan * int), dan dalam beberapa kasus implisit, seperti pada yang nanti bagian dari artikel. </p><br><p>  [2] Selanjutnya, saya menggunakan waktu. Tidur sebagai cara cepat dan kotor untuk menunggu semua goroutine selesai.  Tanpa ini, main akan berakhir sebelum goroutine mulai bekerja.  Cara yang tepat untuk melakukan ini adalah dengan menggunakan sesuatu seperti WaitGroup atau saluran yang dilakukan. </p><br><p>  [3] Representasi assembler untuk semua contoh dalam artikel ini diperoleh dengan menggunakan perintah go tool compile -l -S.  Flag -l menonaktifkan fungsi inlining dan membuat kode assembler lebih mudah dibaca. </p><br><p>  [4] Foobyval tidak dipanggil secara langsung, karena panggilannya melewati panggilan.  Sebaliknya, alamat dilewatkan sebagai argumen kedua (16 (SP)) ke fungsi runtime.newproc, dan argumen untuk foobyval (i dalam kasus ini) naik stack. </p><br><p>  [5] Sebagai latihan, tambahkan ii = 10 sebagai baris terakhir dari for loop (setelah memanggil go).  Apa kesimpulan Anda?  Mengapa </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468863/">https://habr.com/ru/post/id468863/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468849/index.html">Proses rekayasa balik prosesor tidak dikenal dalam satu program</a></li>
<li><a href="../id468851/index.html">Implementasi animasi dalam React Native</a></li>
<li><a href="../id468853/index.html">Kisah satu aplikasi sukses SPR dalam proyek Legacy</a></li>
<li><a href="../id468859/index.html">"Router untuk memompa": Tuning peralatan TP-Link untuk penyedia Internet</a></li>
<li><a href="../id468861/index.html">Teknologi Positif Membawa 'Kota Hackable' untuk Hidup di Siber Siaga Cyberbattle di HITB + CyberWeek</a></li>
<li><a href="../id468873/index.html">Kereta pribadi yang dulunya merusak kenyamanan</a></li>
<li><a href="../id468875/index.html">Episode Hashrate dan Depresiasi Runtuh</a></li>
<li><a href="../id468877/index.html">Pendekatan alternatif untuk menampilkan beban selama pagination</a></li>
<li><a href="../id468879/index.html">Di awal memori komputer</a></li>
<li><a href="../id468883/index.html">Natalia Kozlovskaya: "Siapa yang peduli siapa yang menggambar OpenStreetMap: pria atau wanita?"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>