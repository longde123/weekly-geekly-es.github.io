<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèæ ‚öîÔ∏è üñåÔ∏è Erstellen eines Spiels f√ºr Game Boy, Teil 2 üèΩ üîÜ üë®‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor ein paar Wochen habe ich beschlossen, an einem Spiel f√ºr Game Boy zu arbeiten, dessen Erstellung mir gro√üe Freude bereitete. Sein Arbeitsname ist ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines Spiels f√ºr Game Boy, Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436918/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/849/ccb/9b1/849ccb9b1062f45b917d8771b08bf2c0.png" alt="Bild"></div><br>  Vor ein paar Wochen habe ich beschlossen, an einem Spiel f√ºr Game Boy zu arbeiten, dessen Erstellung mir gro√üe Freude bereitete.  Sein Arbeitsname ist Aqua and Ashes.  Das Spiel hat Open Source und ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub ver√∂ffentlicht</a> .  Der vorherige Teil des Artikels ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  Fantastische Sprites und wo sie leben </h2><br>  Im letzten Teil habe ich mehrere Sprites auf dem Bildschirm gerendert.  Dies geschah auf sehr willk√ºrliche und chaotische Weise.  Tats√§chlich musste ich im Code angeben, was und wo ich anzeigen m√∂chte.  Dies machte die Erstellung von Animationen fast unm√∂glich, verbrachte viel CPU-Zeit und komplizierte Code-Unterst√ºtzung.  Ich brauchte einen besseren Weg. <br><br>  Insbesondere brauchte ich ein System, in dem ich einfach die Animationsnummer, die Bildnummer und den Timer f√ºr jede einzelne Animation iterieren konnte.  Wenn ich die Animation √§ndern m√ºsste, w√ºrde ich einfach die Animation √§ndern und den Frame-Z√§hler zur√ºcksetzen.  Das in jedem Frame durchgef√ºhrte Animationsverfahren sollte einfach die geeigneten Sprites ausw√§hlen, um sie anzuzeigen, und sie ohne mein Zutun auf den Bildschirm werfen. <br><a name="habracut"></a><br>  Und wie sich herausstellte, ist diese Aufgabe praktisch gel√∂st.  Was ich gesucht habe, hei√üt <em>Sprite-Mappings</em> .  Sprite-Maps sind Datenstrukturen, die (grob gesagt) eine Liste von Sprites enthalten.  Jede Sprite-Map enth√§lt alle Sprites zum Rendern eines einzelnen Objekts.  Mit ihnen sind auch <em>Animationskarten (Animationszuordnungen) verbunden</em> , bei denen es sich um Listen von Sprite-Karten mit Informationen zum Schleifen handelt. <br><br>  Es ist ziemlich lustig, dass ich im Mai dem vorgefertigten Sprite-Karteneditor f√ºr 16-Bit-Sonic-Spiele √ºber Sonic einen Animationskarten-Editor hinzugef√ºgt habe.  (Er ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> , Sie k√∂nnen lernen) Es ist noch nicht abgeschlossen, weil es ziemlich rau, schmerzhaft langsam und unpraktisch zu bedienen ist.  Aber aus technischer Sicht funktioniert es.  Und <em>es</em> scheint <em>mir</em> ziemlich cool zu sein ... (Einer der Gr√ºnde f√ºr die Rauheit war, dass ich buchst√§blich zuerst mit dem JavaScript-Framework gearbeitet habe.) Sonic ist ein altes Spiel, daher ist es ideal als Grundlage f√ºr mein neues und altes Spiel. <br><br><h2>  Sonic 2-Kartenformat </h2><br>  Ich wollte den Editor in Sonic 2 verwenden, weil ich einen Hack f√ºr Genesis erstellen wollte.  Sonic 1 und 3K sind im Grunde fast gleich, aber um es nicht zu komplizieren, werde ich mich auf die Geschichte √ºber den zweiten Teil beschr√§nken. <br><br>  Schauen wir uns zun√§chst die Sprite-Karten an.  Hier ist ein ziemlich typisches Tails-Sprite, das Teil der Blink-Animation ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a1/5c7/1a0/6a15c71a0607d906333fe5e189c3b223.png"></div><br>  Die Genesis-Konsole erstellt Sprites etwas anders.  Die Genesis-Kachel (die meisten Programmierer nennen sie ein "Muster") ist 8x8, genau wie beim Game Boy.  Das Sprite besteht aus einem Rechteck mit bis zu 4x4-Kacheln, √§hnlich wie der 8x16-Sprite-Modus in Game Boy, jedoch flexibler.  Der Trick dabei ist, dass diese Kacheln im Speicher nebeneinander liegen sollten.  Die Entwickler von Sonic 2 wollten so viele Kacheln wie m√∂glich f√ºr einen blinkenden Tails-Frame aus einem stehenden Tails-Frame wiederverwenden.  Daher ist Tails in 2 Hardware-Sprites unterteilt, die aus 3x2 Kacheln bestehen - eine f√ºr den Kopf, die andere f√ºr den K√∂rper.  Sie sind in der folgenden Abbildung dargestellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3c/f35/4fd/b3cf354fd7f9f482b3e04ca5ab6b7ad3.png"></div><br>  Am oberen Rand dieses Dialogfelds befinden sich die Hardware-Sprite-Attribute.  Es enth√§lt ihre Position relativ zum Startpunkt (negative Zahlen werden abgeschnitten; tats√§chlich sind dies -16 und -12 f√ºr das erste Sprite und -12 f√ºr das zweite), die im VRAM verwendete Anfangskachel, die Breite und H√∂he des Sprites sowie verschiedene Statusbits f√ºr Spiegelbild von Sprite und Palette. <br><br>  Kacheln werden unten angezeigt, wenn sie vom ROM in den VRAM geladen werden.  Es ist nicht gen√ºgend Speicherplatz vorhanden, um alle Tails-Sprites im VRAM zu speichern. Daher m√ºssen die erforderlichen Kacheln in jedem Frame in den Speicher kopiert werden.  Sie werden als <em>Dynamic Pattern Load Cues bezeichnet</em> .  Wir k√∂nnen sie jedoch √ºberspringen, da sie fast unabh√§ngig von Sprite-Maps sind und daher sp√§ter problemlos hinzugef√ºgt werden k√∂nnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e7/fc5/33b/8e7fc533b1b25a0ea1edcc785163f1ba.png"></div><br>  Was die Animation betrifft, ist hier alles etwas einfacher.  Eine Animationskarte in Sonic ist eine Liste von Sprite-Karten mit zwei Metadaten - dem Geschwindigkeitswert und der Aktion, die nach Abschluss der Animation ausgef√ºhrt werden soll.  Die drei am h√§ufigsten verwendeten Aktionen sind: eine Schleife √ºber alle Frames, eine Schleife √ºber die letzten N Frames oder ein √úbergang zu einer v√∂llig anderen Animation (z. B. beim Wechsel von einer Animation eines stehenden Sonic zu einer Animation seines eifrigen Tretens mit dem Fu√ü).  Es gibt einige Befehle, die interne Flags im Speicher von Objekten angeben, aber nicht viele Objekte verwenden sie.  (Jetzt ist mir der Gedanke gekommen, dass Sie das Bit im RAM des Objekts beim Schleifen der Animation auf einen Wert setzen k√∂nnen. Dies ist n√ºtzlich f√ºr Soundeffekte und andere Dinge.) <br><br>  Wenn Sie sich den <a href="">zerlegten Sonic 1-</a> Code ansehen (der Sonic 2-Code ist zu gro√ü, um ihn zu verkn√ºpfen), werden Sie feststellen, dass der Link zu den Animationen von keiner ID hergestellt wird.  Jedes Objekt erh√§lt eine Liste mit Animationen, und der Animationsindex wird gespeichert.  Um eine bestimmte Animation zu rendern, nimmt das Spiel einen Index, sucht ihn in der Liste der Animationen und rendert ihn dann.  Dies erleichtert die Arbeit ein wenig, da Sie keine Animationen scannen m√ºssen, um die gew√ºnschte zu finden. <br><br><h2>  Wir reinigen die Suppen von den Strukturen </h2><br>  Schauen wir uns die Kartentypen an: <br><br><ol><li>  Sprite-Karten: Eine Liste von Sprites, bestehend aus einer anf√§nglichen Kachel, der Anzahl der Kacheln, der Position, dem Reflexionsstatus (Sprite wird gespiegelt oder nicht) und einer Palette. </li><li>  DPLC: Eine Liste von ROM-Kacheln, die in VRAM geladen werden m√ºssen.  Jedes Element in einer DPLC besteht aus einer anf√§nglichen Kachel und einer L√§nge.  Jedes Element wird nach dem letzten in VRAM platziert. </li><li>  Animationskarten: Eine Liste von Animationen, die aus einer Liste von Sprite-Karten, Geschwindigkeitswerten und Zyklusaktionen besteht. </li><li>  Animationsliste: Eine Liste von Zeigern auf die Aktion jeder Animation. </li></ol><br>  Da wir mit Game Boy arbeiten, k√∂nnen einige Vereinfachungen vorgenommen werden.  Wir wissen, dass es in Sprite-Karten in einem 8x16-Sprite immer zwei Kacheln gibt.  Alles andere muss jedoch erhalten bleiben.  Im Moment k√∂nnen wir DPLC komplett aufgeben und einfach alles in VRAM speichern.  Dies ist eine vor√ºbergehende L√∂sung, aber wie gesagt, dieses Problem wird leicht zu l√∂sen sein.  Schlie√ülich k√∂nnen wir den Geschwindigkeitswert verwerfen, wenn wir davon ausgehen, dass jede Animation mit derselben Geschwindigkeit arbeitet. <br><br>  Beginnen wir damit, herauszufinden, wie ich ein √§hnliches System in meinem Spiel implementieren kann. <br><br>  √úberpr√ºfen Sie mit Commit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2e5e5b7</a> ! <br><br>  Beginnen wir mit Sprite-Karten.  Jedes Element in der Karte sollte OAM (Object Attribute Memory - Sprite VRAM) spiegeln. Daher reichen eine einfache Schleife und ein Memcpy aus, um das Objekt anzuzeigen.  Ich m√∂chte Sie daran erinnern, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Element in OAM aus Y, X, einer Anfangskachel und einem Attributbyte besteht</a> .  Ich muss nur eine Liste von ihnen erstellen.  Unter Verwendung des zusammengesetzten Pseudooperators EQU habe ich das Attributbyte im Voraus vorbereitet, sodass ich f√ºr jede m√∂gliche Kombination von Attributen einen lesbaren Namen hatte.  (Sie k√∂nnen sehen, dass ich beim vorherigen Festschreiben die Y / X-Kachel in den Karten ersetzt habe. Dies geschah, weil ich versehentlich die OAM-Spezifikationen gelesen habe. Ich habe auch einen Sprite-Z√§hler hinzugef√ºgt, um zu wissen, wie lange die Schleife dauern sollte.) <br><br>  Sie werden feststellen, dass K√∂rper und Schwanz des Polarfuchses getrennt aufbewahrt werden.  Wenn sie zusammen gespeichert w√ºrden, w√ºrde es <em>viel</em> Redundanz geben, da jede Animation f√ºr jeden Endzustand dupliziert werden m√ºsste.  Und das Ausma√ü der Redundanz w√ºrde schnell zunehmen.  In Sonic 2 trat das gleiche Problem bei Tails auf.  Sie haben es dort gel√∂st und Tails Tails zu einem separaten Objekt mit einem eigenen Animationsstatus und Timer gemacht.  Ich m√∂chte dies nicht tun, weil ich nicht versuche, das Problem der Beibehaltung der richtigen Schwanzposition relativ zum Fuchs zu l√∂sen. <br><br>  Ich habe das Problem durch Animationskarten gel√∂st.  Wenn Sie sich meine (einzelne) Animationskarte ansehen, enth√§lt sie drei Metadaten.  Es zeigt die Anzahl der Animationskarten, sodass ich wei√ü, wann sie enden werden.  (In Sonic wird √ºberpr√ºft, ob die folgende Animation ung√ºltig ist, √§hnlich dem Konzept des Null-Bytes in C-Zeilen. Eine L√∂sung von Sonic gibt den Fall frei, f√ºgt jedoch einen Vergleich hinzu, der gegen mich funktionieren w√ºrde.) Nat√ºrlich gibt es immer noch eine Schleifenaktion.  (Ich habe die 2-Byte-Sonic-Schaltung in eine 1-Byte-Zahl umgewandelt, in der Bit 7 das Modusbit ist.) Ich habe aber auch die Anzahl <em>der Sprite-Karten</em> , aber nicht in Sonic.  Wenn ich mehrere Sprite-Maps pro Animationsrahmen habe, kann ich Animationen in mehreren Animationen wiederverwenden, was meiner Meinung nach viel wertvollen Platz spart.  Sie k√∂nnen auch feststellen, dass die Animationen f√ºr jede Richtung dupliziert werden.  Dies liegt daran, dass die Karten f√ºr jede Richtung unterschiedlich sind und Sie sie hinzuf√ºgen m√ºssen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e9/e7d/240/8e9e7d2401e1a07d0c77e2f0c6c99e3d.png" alt="Bild"></div><br><h2>  Tanzen mit Registern </h2><br>  Siehe <a href="">diese Datei</a> unter 1713848. <br><br>  Beginnen wir mit dem Zeichnen eines einzelnen Sprites auf dem Bildschirm.  Also, ich gestehe, ich habe gelogen.  Ich m√∂chte Sie daran erinnern, dass wir au√üerhalb von VBlank nicht auf dem Bildschirm aufnehmen k√∂nnen.  Und dieser ganze Prozess ist zu lang, um in VBlank zu passen.  Daher m√ºssen wir den Speicherbereich aufzeichnen, den wir f√ºr DMA zuweisen.  Am Ende √§ndert sich nichts, es ist wichtig, an der richtigen Stelle aufzunehmen. <br><br>  Beginnen wir mit dem Z√§hlen der Register.  Der GBZ80-Prozessor verf√ºgt √ºber 6 Register, von A bis E, H und L. H und L sind spezielle Register, sodass sie sich gut f√ºr die Durchf√ºhrung von Iterationen aus dem Speicher eignen.  (Da sie zusammen verwendet werden, hei√üen sie HL.) In einem Opcode kann ich in die in HL enthaltene Speicheradresse schreiben und eine hinzuf√ºgen.  Das ist schwer zu handhaben.  Sie k√∂nnen es entweder als Quelle oder als Ziel verwenden.  Ich habe es als Adressen und die Kombination von BC-Registern als Quelle verwendet, weil es am bequemsten war.  Wir haben nur A, D und E. Ich brauche Register A f√ºr mathematische Operationen und dergleichen.  Wof√ºr kann DE verwendet werden?  Ich benutze D als Schleifenz√§hler und E als Arbeitsbereich.  Und hier endeten die Register. <br><br>  Nehmen wir an, wir haben 4 Sprites.  Wir setzen das D-Register (Zyklusz√§hler) auf 4, das HL-Register (Ziel) die OAM-Pufferadresse und BC (die Quelle) den Ort im ROM, an dem unsere Karten gespeichert sind.  Jetzt m√∂chte ich memcpy anrufen.  Es tritt jedoch ein kleines Problem auf.  Erinnern Sie sich an die X- und Y-Koordinaten?  Sie sind relativ zum Startpunkt angegeben, die Mitte des Objekts wird f√ºr Kollisionen und dergleichen verwendet.  Wenn wir sie so aufnehmen, wie sie sind, wird jedes Objekt in der oberen linken Ecke des Bildschirms angezeigt.  Das passt nicht zu uns.  Um dies zu beheben, m√ºssen wir die X- und Y-Koordinaten des Objekts zu X und Y des Sprites hinzuf√ºgen. <br><br>  Kurzer Hinweis: Ich spreche von ‚ÄûObjekten‚Äú, habe Ihnen dieses Konzept jedoch nicht erkl√§rt.  Ein Objekt ist einfach eine Reihe von Attributen, die einem Objekt in einem Spiel zugeordnet sind.  Attribute sind eine Position, Geschwindigkeit, Richtung.  Artikelbeschreibung usw.  Ich spreche dar√ºber, weil ich X- und Y-Daten aus diesen Objekten extrahieren muss. Dazu ben√∂tigen wir einen dritten Satz von Registern, die auf die Stelle im RAM der Objekte zeigen, an denen sich die Koordinaten befinden.  Und dann m√ºssen wir X und Y irgendwo speichern. Gleiches gilt f√ºr die Richtung, da es uns hilft zu bestimmen, in welche Richtung die Sprites schauen.  Au√üerdem m√ºssen wir <em>alle</em> Objekte rendern, sodass sie auch einen Schleifenz√§hler ben√∂tigen.  Und wir sind noch nicht zu den Animationen gekommen!  Alles ger√§t schnell au√üer Kontrolle ... <br><br><h2>  Entscheidungs√ºberpr√ºfung </h2><br>  Also renne ich zu weit voraus.  Lassen Sie uns zur√ºckgehen und √ºber jedes Datenelement nachdenken, das ich verfolgen muss, und wo ich es schreiben soll. <br><br>  Lassen Sie uns dies zun√§chst in ‚ÄûSchritte‚Äú unterteilen.  Jeder Schritt sollte nur Daten f√ºr den n√§chsten empfangen, mit Ausnahme des letzten, der die Kopie ausf√ºhrt. <br><br><ol><li>  Objekt (Schleife) - Findet heraus, ob das Objekt gerendert werden soll, und rendert es. </li><li>  Animationsliste - Legt fest, welche Animation angezeigt werden soll.  Ruft auch die Attribute eines Objekts ab. </li><li>  Animation (Schleife) - legt fest, welche Liste von Karten verwendet werden soll, und rendert jede Karte daraus. </li><li>  Karte (Zyklus) - Durchl√§uft iterativ jedes Sprite in der Liste der Sprites </li><li>  Sprite - kopiert Sprite-Attribute in den OAM-Puffer </li></ol><br>  F√ºr jede der Phasen habe ich die Variablen aufgelistet, die sie ben√∂tigen, die Rollen, die sie spielen, und die Orte, an denen sie gespeichert werden.  Diese Tabelle sieht ungef√§hr so ‚Äã‚Äãaus. <br><br><table><tbody><tr><th>  Beschreibung </th><th>  Gr√∂√üe </th><th>  B√ºhne </th><th>  Verwenden Sie </th><th>  Woher? </th><th>  Platzieren </th><th>  Wohin </th></tr><tr><td>  OAM-Puffer </td><td>  2 </td><td>  Sprite </td><td>  Zeiger </td><td>  Hl </td><td>  Hl </td><td></td></tr><tr><td>  Kartenquelle </td><td>  2 </td><td>  Sprite </td><td>  Zeiger </td><td>  BC </td><td>  BC </td><td></td></tr><tr><td>  Aktuelles Byte </td><td>  1 </td><td>  Sprite </td><td>  Arbeitsbereich </td><td>  Kartenquelle </td><td>  E. </td><td></td></tr><tr><td>  X. </td><td>  1 </td><td>  Sprite </td><td>  Variable </td><td>  Hiram </td><td>  A. </td><td></td></tr><tr><td>  Y. </td><td>  1 </td><td>  Sprite </td><td>  Variable </td><td>  Hiram </td><td>  A. </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  Start der Animationskarte </td><td>  2 </td><td>  Sprite-Karte </td><td>  Zeiger </td><td>  Stack3 </td><td>  DE </td><td></td></tr><tr><td>  Kartenquelle </td><td>  2 </td><td>  Sprite-Karte </td><td>  Zeiger </td><td>  [DE] </td><td>  BC </td><td></td></tr><tr><td>  Verbleibende Sprites </td><td>  1 </td><td>  Sprite-Karte </td><td>  Kratzer </td><td>  Kartenquelle </td><td>  D. </td><td></td></tr><tr><td>  OAM-Puffer </td><td>  1 </td><td>  Sprite-Karte </td><td>  Zeiger </td><td>  Hl </td><td>  Hl </td><td>  Stack1 </td></tr><tr><td colspan="7"></td></tr><tr><td>  Start der Animationskarte </td><td>  2 </td><td>  Animation </td><td>  Arbeitsbereich </td><td>  BC / Stack3 </td><td>  BC </td><td>  Stack3 </td></tr><tr><td>  Verbleibende Karten </td><td>  1 </td><td>  Animation </td><td>  Arbeitsbereich </td><td>  Animationsstart </td><td>  Hiram </td><td></td></tr><tr><td>  Gesamtzahl der Karten </td><td>  1 </td><td>  Animationen </td><td>  Variable </td><td>  Animationsstart </td><td>  Hiram </td><td></td></tr><tr><td>  Objektrichtung </td><td>  1 </td><td>  Animation </td><td>  Variable </td><td>  Hiram </td><td>  Hiram </td><td></td></tr><tr><td>  Karten pro Frame </td><td>  1 </td><td>  Animation </td><td>  Variable </td><td>  Animationsstart </td><td>  WIRD NICHT BENUTZT!!! </td><td></td></tr><tr><td>  Rahmennummer </td><td>  1 </td><td>  Animation </td><td>  Variable </td><td>  Hiram </td><td>  A. </td><td></td></tr><tr><td>  Kartenzeiger </td><td>  2 </td><td>  Animation </td><td>  Zeiger </td><td>  AnimStart + Dir * TMC + MpF * F # </td><td>  BC </td><td>  DE </td></tr><tr><td>  OAM-Puffer </td><td>  2 </td><td>  Animation </td><td>  Zeiger </td><td>  Stack1 </td><td>  Hl </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  Beginn der Animationstabelle </td><td>  2 </td><td>  Animationsliste </td><td>  Arbeitsbereich </td><td>  Harter Satz </td><td>  DE </td><td></td></tr><tr><td>  Objektquelle </td><td>  2 </td><td>  Animationsliste </td><td>  Zeiger </td><td>  Hl </td><td>  Hl </td><td>  Stack2 </td></tr><tr><td>  Rahmennummer </td><td>  1 </td><td>  Animationsliste </td><td>  Variable </td><td>  Objektquelle </td><td>  Hiram </td><td></td></tr><tr><td>  Animationsnummer </td><td>  1 </td><td>  Animationsliste </td><td>  Arbeitsbereich </td><td>  Objektquelle </td><td>  A. </td><td></td></tr><tr><td>  X Objekt </td><td>  1 </td><td>  Liste der Objekte </td><td>  Variable </td><td>  Objektquelle </td><td>  Hiram </td><td></td></tr><tr><td>  Y Objekt </td><td>  1 </td><td>  Animationsliste </td><td>  Variable </td><td>  Objektquelle </td><td>  Hiram </td><td></td></tr><tr><td>  Objektrichtung </td><td>  1 </td><td>  Animationsliste </td><td>  Variable </td><td>  Obj src </td><td>  Hiram </td><td></td></tr><tr><td>  Start der Animationskarte </td><td>  2 </td><td>  Animationsliste </td><td>  Zeiger </td><td>  [Anim Table + Anim #] </td><td>  BC </td><td></td></tr><tr><td>  OAM-Puffer </td><td>  2 </td><td>  Animationsliste </td><td>  Zeiger </td><td>  DE </td><td>  Stack1 </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  Objektquelle </td><td>  2 </td><td>  Objektzyklus </td><td>  Wegweiser </td><td>  Hard Set / Stack2 </td><td>  Hl </td><td></td></tr><tr><td>  Verbleibende Objekte </td><td>  1 </td><td>  Objektzyklus </td><td>  Variable </td><td>  Berechnet </td><td>  B. </td><td></td></tr><tr><td>  Aktives Bitfeld eines Objekts </td><td>  1 </td><td>  Objektzyklus </td><td>  Variable </td><td>  Berechnet </td><td>  C. </td><td></td></tr><tr><td>  OAM-Puffer </td><td>  2 </td><td>  Objektzyklus </td><td>  Zeiger </td><td>  Harter Satz </td><td>  DE </td><td></td></tr></tbody></table><br>  Ja, sehr verwirrend.  Um ganz ehrlich zu sein, habe ich diese Tabelle nur f√ºr den Beitrag erstellt, um sie klarer zu erkl√§ren, aber sie hat bereits begonnen, n√ºtzlich zu sein.  Ich werde versuchen, es zu erkl√§ren. Beginnen wir am Ende und kommen zum Anfang.  Sie sehen alle Daten, mit denen ich beginne: die Quelle des Objekts, den OAM-Puffer und die vorberechneten Schleifenvariablen.  In jedem Zyklus beginnen wir mit diesem und nur diesem, au√üer dass die Quelle des Objekts in jedem Zyklus aktualisiert wird. <br><br>  F√ºr jedes Objekt, das wir rendern, muss die angezeigte Animation definiert werden.  W√§hrenddessen k√∂nnen wir auch die Attribute X, Y, Frame # und Direction speichern, bevor wir den Objektzeiger auf das n√§chste Objekt erh√∂hen und sie auf dem Stapel speichern, um sie beim Beenden zur√ºckzunehmen.  Wir verwenden die Animationsnummer in Kombination mit der im Code fest codierten Animationstabelle, um zu bestimmen, wo die Animationskarte beginnt.  (Hier vereinfache ich, vorausgesetzt, jedes Objekt hat dieselbe Animationstabelle. Dies beschr√§nkt mich auf 256 Animationen pro Spiel, aber es ist unwahrscheinlich, dass ich diesen Wert √ºberschreite.) Wir k√∂nnen auch einen OAM-Puffer schreiben, um mehrere Register zu speichern. <br><br>  Nach dem Extrahieren der Animationskarte m√ºssen wir herausfinden, wo sich die Liste der Sprite-Karten f√ºr den angegebenen Frame und die Richtung befindet und wie viele Karten gerendert werden m√ºssen.  M√∂glicherweise stellen Sie fest, dass die Kartenvariable pro Frame nicht verwendet wird.  Es ist passiert, weil ich nicht nachgedacht und den konstanten Wert 2 eingestellt habe. Ich muss ihn reparieren.  Wir m√ºssen auch den OAM-Puffer aus dem Stapel extrahieren.  M√∂glicherweise stellen Sie auch einen v√∂lligen Mangel an Zykluskontrolle fest.  Es wird in einer separaten, viel einfacheren Unterprozedur ausgef√ºhrt, mit der Sie das Jonglieren mit Registern loswerden k√∂nnen. <br><br>  Danach wird alles ganz einfach.  Eine Karte besteht aus einer Reihe von Sprites, daher gehen wir in einer Schleife um sie herum und zeichnen basierend auf den gespeicherten X- und Y-Koordinaten. Wir speichern jedoch erneut den OAM-Zeiger am Ende der Sprite-Liste, sodass die n√§chste Karte dort beginnt, wo wir fertig sind. <br><br>  Was war das Endergebnis von all dem?  Genau das gleiche wie zuvor: Ein Polarfuchs schwenkt seinen Schwanz im Dunkeln.  Das Hinzuf√ºgen neuer Animationen oder Sprites ist jetzt viel einfacher.  Im n√§chsten Teil werde ich √ºber komplexe Hintergr√ºnde und Parallaxen-Scrollen sprechen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19f/cc5/431/19fcc54315854aa3dd7eafcad60c7c38.png" alt="Bild"></div><br><h2>  Teil 4. Parallaxenhintergrund </h2><br>  Ich m√∂chte Sie daran erinnern, dass wir zum gegenw√§rtigen Zeitpunkt Sprites auf einem festen schwarzen Hintergrund animiert haben.  Wenn ich nicht vorhabe, ein Arcade-Spiel der 70er Jahre zu machen, wird dies eindeutig nicht ausreichen.  Ich brauche eine Art Hintergrundbild. <br><br>  Im ersten Teil, als ich Grafiken zeichnete, habe ich auch mehrere Hintergrundkacheln erstellt.  Es ist Zeit, sie zu benutzen.  Wir werden drei "grundlegende" Arten von Kacheln (Himmel, Gras und Erde) und zwei √úbergangskacheln haben.  Alle von ihnen sind in VRAM geladen und einsatzbereit.  Jetzt m√ºssen wir sie nur noch im Hintergrund schreiben. <br><br><h2>  Hintergrund </h2><br>  Die Hintergr√ºnde des Game Boy werden in einem 32x32-Array von 8x8-Kacheln gespeichert.  Alle 32 Bytes entsprechen einer Kachelzeile. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d4/f70/972/3d4f70972bfc10421deaf1d18809e4f6.png"></div><br>  Bisher habe ich vor, dieselbe Kachelspalte im gesamten 32x32-Bereich zu wiederholen.  Das ist gro√üartig, aber es schafft ein kleines Problem: Ich muss <em>jede</em> Kachel 32 Mal hintereinander setzen.  Das Schreiben wird lange dauern. <br><br>  Instinktiv entschied ich mich, den Befehl REPT zu verwenden, um 32 Bytes / Zeile hinzuzuf√ºgen, und dann memcpy zu verwenden, um den Hintergrund in VRAM zu kopieren. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">REPT</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> db BG_SKY ENDR REPT <span class="hljs-number"><span class="hljs-number">32</span></span> db BG_GRASS ENDR ...</code> </pre> <br>  Dies bedeutet jedoch, dass Sie 256 Bytes nur f√ºr einen Hintergrund zuweisen m√ºssen, was ziemlich viel ist.  Dieses Problem wird noch versch√§rft, wenn Sie sich daran erinnern, dass Sie beim Kopieren einer zuvor erstellten Hintergrundkarte mit memcpy keine anderen Spaltentypen (z. B. Tore, Hindernisse) hinzuf√ºgen k√∂nnen, ohne dass eine erhebliche Komplexit√§t und eine Menge verschwendeter ROM-Kassetten erforderlich sind. <br><br>  Also habe ich stattdessen beschlossen, eine einzelne Spalte wie folgt einzurichten: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">db</span></span> BG_SKY, BG_SKY, BG_SKY, ..., BG_GRASS</code> </pre> <br>  Verwenden Sie dann eine einfache Schleife, um jedes Element in dieser Liste 32 Mal zu kopieren.  (Siehe <a href=""><code> LoadGFX</code> Datei <code> LoadGFX</code> von Commit 739986a</a> .) <br><br>  Der Vorteil dieses Ansatzes besteht darin, dass ich sp√§ter eine Warteschlange hinzuf√ºgen kann, um so etwas zu schreiben: <br><br><pre> <code class="hljs perl">BGCOL_Field: db BG_SKY, ... BGCOL_LeftGoal: db BG_SKY, ... BGCOL_RightGoal: db BG_SKY, ... ... BGMAP_overview: db <span class="hljs-number"><span class="hljs-number">1</span></span> dw BGCOL_LeftGoal db <span class="hljs-number"><span class="hljs-number">30</span></span> dw BGCOL_Field db <span class="hljs-number"><span class="hljs-number">1</span></span> dw BGCOL_RightGoal db $FF</code> </pre> <br>  Wenn ich mich entscheide, BGMAP_overview zu rendern, wird 1 Spalte von LeftGoal gezeichnet, danach werden 30 Spalten von Field und 1 Spalte von RightGoal angezeigt.  Wenn sich <code>BGMAP_overview</code> im RAM befindet, kann ich es abh√§ngig von der Kameraposition in X im <code>BGMAP_overview</code> √§ndern. <br><br><h2>  Kamera und Position </h2><br>  Oh ja, die Kamera.  Dies ist ein wichtiges Konzept, √ºber das ich noch nicht gesprochen habe.  Hier haben wir es mit einer Vielzahl von Koordinaten zu tun. Bevor wir also √ºber die Kamera sprechen, werden wir dies alles zun√§chst analysieren. <br><br>  Wir m√ºssen mit zwei Koordinatensystemen arbeiten.  Das erste sind die <em>Bildschirmkoordinaten</em> .  Dies ist ein Bereich von 256 x 256, der im VRAM der Game Boy-Konsole enthalten sein kann.  Wir k√∂nnen den sichtbaren Teil des Bildschirms innerhalb dieser 256x256 scrollen, aber wenn wir √ºber die Grenzen hinausgehen, kollabieren wir. <br><br>  In der Breite ben√∂tige ich mehr als 256 Pixel, also f√ºge ich <em>Weltkoordinaten hinzu</em> , die in diesem Spiel Abmessungen von 65536 x 256 haben.  (Ich brauche keine zus√§tzliche H√∂he in Y, da das Spiel auf einem flachen Feld stattfindet.) Dieses System ist vollst√§ndig vom Bildschirmkoordinatensystem getrennt.  Alle Physik und Kollisionen m√ºssen in Weltkoordinaten ausgef√ºhrt werden, da sonst die Objekte mit Objekten auf anderen Bildschirmen kollidieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56c/557/fd6/56c557fd66ec77707c4083b6f38565f4.png"></div><br>  <i>Vergleich von Bildschirm- und Weltkoordinaten</i> <br><br>  Da die Positionen aller Objekte in Weltkoordinaten dargestellt werden, m√ºssen sie vor dem Rendern in Bildschirmkoordinaten konvertiert werden.  Am √§u√üersten linken Rand der Welt stimmen die Weltkoordinaten mit den Bildschirmkoordinaten √ºberein.  Wenn wir die Dinge rechts auf dem Bildschirm anzeigen m√ºssen, m√ºssen wir alles in Weltkoordinaten nehmen und nach links verschieben, so dass sie in Bildschirmkoordinaten sind. <br><br>  Dazu setzen wir die Variable ‚ÄûKamera X‚Äú, die als linker Rand des Bildschirms in der Welt definiert ist.  Wenn beispielsweise <code>camera X</code> 1000 ist, k√∂nnen wir die Weltkoordinaten 1000-1192 sehen, da der sichtbare Bildschirm eine Breite von 192 Pixel hat. <br><br>  Um Objekte zu verarbeiten, nehmen wir einfach ihre Position in X (z. B. 1002), subtrahieren die Kameraposition gleich 1000 und zeichnen das Objekt an der durch die Differenz gegebenen Position (in unserem Fall 2).  F√ºr einen Hintergrund, der <em>nicht</em> in Weltkoordinaten angegeben ist, aber bereits in Bildschirmkoordinaten beschrieben ist, setzen wir die Position gleich dem unteren Byte der <code>camera X</code> Variablen.  Dank dessen wird der Hintergrund mit der Kamera nach links und rechts gescrollt. <br><br><h2>  Parallaxe </h2><br>  Das von uns erstellte System sieht ziemlich flach aus.  Jede Hintergrundebene bewegt sich mit der gleichen Geschwindigkeit.  Es f√ºhlt sich nicht dreidimensional an und wir m√ºssen es reparieren. <br><br>  Eine einfache M√∂glichkeit, eine 3D-Simulation hinzuzuf√ºgen, ist das Parallaxen-Scrollen.  Stellen Sie sich vor, Sie fahren auf einer Stra√üe und sind sehr m√ºde.  Dem Game Boy sind die Batterien ausgegangen und Sie m√ºssen aus dem Autofenster schauen.  Wenn Sie auf den Boden neben sich schauen, werden Sie sehen.  dass sie sich mit einer Geschwindigkeit von 70 Meilen pro Stunde bewegt.  Wenn Sie sich jedoch die Felder in der Ferne ansehen, scheinen sie sich viel langsamer zu bewegen.  Und wenn man sich die sehr fernen Berge ansieht, scheinen sie sich kaum zu bewegen. <br><br>  Wir k√∂nnen diesen Effekt mit drei Blatt Papier simulieren.  Wenn Sie eine Bergkette auf ein Blatt zeichnen, das Feld auf das zweite und die Stra√üe auf das dritte Blatt und legen Sie sie so √ºbereinander.  Damit jede Schicht sichtbar ist, ist sie eine Nachahmung dessen, was wir vom Autofenster aus sehen.  Wenn wir das ‚ÄûAuto‚Äú nach links bewegen wollen, bewegen wir das oberste Blatt (mit der Stra√üe) weit nach rechts, das n√§chste ist ein wenig nach rechts und das letzte ist ein wenig nach rechts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4d/b52/691/d4db5269121565e6eda63ce5e240d96e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce4/c39/8db/ce4c398dbae155b1da618016c83d440f.png"></div><br>  Bei der Implementierung eines solchen Systems auf Game Boy tritt jedoch ein kleines Problem auf.  Die Konsole hat nur eine Hintergrundebene.  Dies √§hnelt der Tatsache, dass wir nur ein Blatt Papier haben.  Sie k√∂nnen keinen Parallaxeeffekt mit nur einem Blatt Papier erzeugen.  Oder ist es m√∂glich? <br><br><h2>  H-blank </h2><br>  Der Game Boy-Bildschirm wird zeilenweise gerendert.  Aufgrund der Nachahmung des Verhaltens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">alter CRT-Fernseher kommt</a> es zwischen den einzelnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leitungen</a> zu einer leichten Verz√∂gerung.  Was ist, wenn wir es irgendwie benutzen k√∂nnen?  Es stellt sich heraus, dass Game Boy speziell f√ºr diesen Zweck einen speziellen Hardware-Interrupt hat. <br><br>  √Ñhnlich wie beim VBlank-Interrupt, bei dem wir st√§ndig bis zum Ende des Frames auf die Aufnahme im VRAM gewartet haben, gibt es einen HBlank-Interrupt.  Indem Sie Bit 6 des Registers auf <code>$FF41</code> , den <code>LCD STAT</code> Interrupt <code>$FF41</code> und die Zeilennummer auf <code>$FF45</code> , k√∂nnen Sie Game Boy <code>$FF45</code> , den <code>LCD STAT</code> Interrupt zu starten, wenn die angegebene Linie gezeichnet werden soll (und wenn sie sich in der HBlank befindet). <br><br>  W√§hrend dieser Zeit k√∂nnen wir alle VRAM-Variablen √§ndern.  Dies ist nicht <em>viel</em> Zeit, daher k√∂nnen wir nicht mehr als ein paar Register √§ndern, aber wir haben noch einige M√∂glichkeiten.  Wir wollen das horizontale <code>$FF43</code> bei <code>$FF43</code> .  In diesem Fall bewegt sich alles auf dem Bildschirm unterhalb der angegebenen Linie um eine bestimmte Verschiebung, wodurch ein Parallaxeeffekt entsteht. <br><br>  Wenn Sie zum Bergbeispiel zur√ºckkehren, k√∂nnen Sie ein potenzielles Problem feststellen.  Berge, Wolken und Blumen sind keine flachen Linien!  Wir k√∂nnen die ausgew√§hlte Zeile w√§hrend des Rendervorgangs nicht nach oben und unten verschieben.  Wenn wir es w√§hlen, bleibt es mindestens bis zum n√§chsten HBlank gleich.  Das hei√üt, wir k√∂nnen nur in geraden Linien schneiden. <br><br>  Um dieses Problem zu l√∂sen, m√ºssen wir etwas schlauer vorgehen.  Wir k√∂nnen eine Linie im Hintergrund als eine Linie deklarieren, die nichts kreuzen kann, was bedeutet, dass die Modi von Objekten dar√ºber und darunter ge√§ndert werden und der Spieler nichts bemerken kann.  Hier befinden sich beispielsweise diese Linien in der Szene mit dem Berg. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f3/371/46a/7f337146a97de76d1c7647ec0d0d78db.png"></div><br>  Hier habe ich direkt √ºber und unter dem Berg Scheiben gemacht.  Alles von der oberen bis zur ersten Linie bewegt sich langsam, alles bis zur zweiten Linie bewegt sich mit einer Durchschnittsgeschwindigkeit und alles unterhalb dieser Linie bewegt sich schnell.  Dies ist ein einfacher, aber kluger Trick.  Und wenn Sie davon erfahren, k√∂nnen Sie es in vielen Retro-Spielen bemerken, haupts√§chlich f√ºr Genesis / Mega Drive, aber auch auf anderen Konsolen.  Eines der offensichtlichsten Beispiele ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil der H√∂hle</a> von Mickey Mania.  Sie k√∂nnen feststellen, dass die Stalagmiten und Stalaktiten im Hintergrund <em>genau</em> entlang einer horizontalen Linie mit einem offensichtlichen schwarzen Rand zwischen den Schichten getrennt sind. <br><br>  In meinem Hintergrund wurde mir dasselbe klar.  Es gibt jedoch einen Trick.  Angenommen, der Vordergrund bewegt sich mit einer Geschwindigkeit eins zu eins, die mit der Bewegung der Kamera zusammenf√§llt, und die Hintergrundgeschwindigkeit betr√§gt ein Drittel der Pixelbewegung der Kamera, dh der Hintergrund bewegt sich wie ein Drittel des Vordergrunds.  Aber nat√ºrlich existiert ein Drittel des Pixels nicht.  Daher muss ich den Hintergrund f√ºr jeweils drei Pixel Bewegung um ein Pixel verschieben. <br><br>  Wenn Sie mit Computern arbeiten, die mathematische Berechnungen ausf√ºhren k√∂nnen, nehmen Sie die Kameraposition, teilen Sie sie durch 3 und machen Sie diesen Wert zu einem Hintergrundversatz.  Leider ist der Game Boy nicht in der Lage, die Teilung durchzuf√ºhren, ganz zu schweigen von der Tatsache, dass die Programmteilung ein sehr langsamer und schmerzhafter Prozess ist.  Das Hinzuf√ºgen eines Ger√§ts zum Teilen (oder Multiplizieren) einer schwachen CPU f√ºr eine tragbare Unterhaltungskonsole in den 80er Jahren schien kein kosteng√ºnstiger Schritt zu sein, daher m√ºssen wir einen anderen Weg erfinden. <br><br>  Im Code habe ich Folgendes getan: Anstatt die Kameraposition aus einer Variablen zu lesen, habe ich verlangt, dass sie zunimmt oder abnimmt.  Dank dessen kann ich mit jedem dritten Inkrement ein Inkrement der Hintergrundposition und mit jedem ersten Inkrement ein Inkrement der Vordergrundposition durchf√ºhren.  Dies erschwert ein wenig das Scrollen zu einer Position vom anderen Rand des Feldes (der einfachste Weg besteht darin, die Positionen der Ebenen nach einem bestimmten √úbergang einfach zur√ºckzusetzen), erspart uns jedoch das Teilen. <br><br><h2>  Ergebnis </h2><br>  Nach <em>all dem habe</em> ich folgendes bekommen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47d/f64/3a2/47df643a2bd620cf8899b3601162748b.gif"></div><br>  F√ºr ein Spiel auf Game Boy ist das eigentlich ziemlich cool.  Soweit ich wei√ü, haben nicht alle das Parallaxen-Scrollen so implementiert. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436918/">https://habr.com/ru/post/de436918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436908/index.html">6 M√∂glichkeiten, Daten in einer Android-Anwendung auszublenden</a></li>
<li><a href="../de436910/index.html">Tipps zum Erstellen benutzerdefinierter Workflows in GitLab CI</a></li>
<li><a href="../de436912/index.html">2019 CRM-Trends: Spa√ü beim Lesen, gef√§hrlich zu glauben</a></li>
<li><a href="../de436914/index.html">Probleme mit dem Startwachstum - √úberwachung</a></li>
<li><a href="../de436916/index.html">VShard - horizontale Skalierung in Tarantool</a></li>
<li><a href="../de436920/index.html">PAS2JS-Transpiler von Pascal nach JavaScript: Inkompatibel mit Delphi und Problemumgehungen</a></li>
<li><a href="../de436922/index.html">Optimieren der Startzeit von Prometheus 2.6.0 mit pprof</a></li>
<li><a href="../de436924/index.html">Ein paar Worte zur Organisation von Roboterwettbewerben</a></li>
<li><a href="../de436926/index.html">Helden der Zwei-Faktor-Authentifizierung oder wie man "in den Schuhen anderer l√§uft"</a></li>
<li><a href="../de436928/index.html">WebRTC - noch einfacher (EasyRTC)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>