<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍❤️‍💋‍👨 👨🏻‍🌾 💧 Kondisi ras dalam aplikasi web 🍷 💪🏽 🎸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR Artikel ini menjelaskan tentang trik kondisi lomba yang tidak populer yang tidak biasa digunakan dalam serangan jenis ini. Berdasarkan hasil pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kondisi ras dalam aplikasi web</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460339/">  <b>TL; DR</b> Artikel ini menjelaskan tentang trik kondisi lomba yang tidak populer yang tidak biasa digunakan dalam serangan jenis ini.  Berdasarkan hasil penelitian kami, kami membuat kerangka kerja kami sendiri untuk serangan racepwn. <br><br>  Vasya ingin mentransfer 100 dolar yang dia miliki di akunnya, Petya.  Dia pergi ke tab transfer, mengarahkan nama panggilan Petin ke dalam bidang dengan jumlah dana yang perlu ditransfer - angka 100. Selanjutnya, klik pada tombol transfer.  Data kepada siapa dan berapa banyak yang dikirim ke aplikasi web.  Apa yang bisa terjadi di dalam?  Apa yang perlu dilakukan oleh programmer agar semuanya berfungsi dengan benar? <br><a name="habracut"></a><br><ul><li>  Anda perlu memastikan bahwa jumlahnya tersedia untuk Vasya untuk transfer. </li></ul><br>  Penting untuk mendapatkan nilai saldo pengguna saat ini, jika kurang dari jumlah yang ingin ditransfer, beri tahu dia tentang hal itu.  Mengingat fakta bahwa situs kami tidak memberikan pinjaman dan tidak boleh masuk ke saldo minus. <br><br><ul><li>  Kurangi jumlah yang akan ditransfer dari saldo pengguna </li></ul><br>  Penting untuk menuliskan saldo pengguna saat ini dengan pengurangan jumlah yang ditransfer.  Itu 100, menjadi 100-100 = 0. <br><br><ul><li>  Tambahkan ke saldo pengguna, Petya, jumlah yang ditransfer. </li></ul><br>  Petya, sebaliknya, adalah 0, menjadi 0 + 100 = 100. <br><br><ul><li> Tampilkan pesan kepada pengguna bahwa ia berhasil! </li></ul><br>  Saat menulis program, seseorang menggunakan algoritma paling sederhana, yang ia gabungkan menjadi satu plot, yang akan menjadi skrip program.  Dalam kasus kami, tugas programmer adalah menulis logika transfer uang (poin, kredit) dari satu orang ke orang lain dalam aplikasi web.  Dipandu oleh logika, Anda dapat membuat algoritma yang terdiri dari beberapa pemeriksaan.  Bayangkan kita baru saja menghapus semua yang tidak perlu dan menyusun kodesemu. <br><br><pre><code class="plaintext hljs"> (. &gt;= _)  .=.-_ .=.+_ ()  ()</code> </pre> <br>  Tetapi semuanya akan baik-baik saja jika semuanya terjadi secara bergantian.  Tetapi sebuah situs dapat melayani banyak pengguna secara bersamaan, dan ini tidak terjadi dalam satu utas, karena aplikasi web modern menggunakan multiprosesing dan multithreading untuk pemrosesan data paralel.  Dengan munculnya multithreading, program memiliki kerentanan arsitektur lucu - kondisi ras (atau kondisi ras). <br><br>  Sekarang bayangkan algoritma kami bekerja secara bersamaan 3 kali. <br><br>  Vasya masih memiliki 100 poin pada keseimbangannya, hanya saja entah bagaimana ia beralih ke aplikasi web dalam tiga utas pada saat yang sama (dengan jumlah waktu minimum di antara permintaan).  Ketiga aliran memeriksa apakah pengguna adalah Petya, dan memeriksa apakah Vasya memiliki saldo yang cukup untuk transfer.  Pada saat itu ketika algoritma memeriksa saldo, itu masih sama dengan 100. Setelah verifikasi selesai, 100 dikurangkan dari saldo saat ini 3 kali dan Pete ditambahkan. <br><br>  Apa yang kita miliki  Vasya memiliki saldo negatif di akunnya (100 - 300 = -200 poin).  Sementara itu, Petya memiliki 300 poin, meskipun pada kenyataannya, itu harus 100. Ini adalah contoh khas dari eksploitasi kondisi ras.  Ini sebanding dengan kenyataan bahwa beberapa orang lulus sekaligus.  Di bawah ini adalah screenshot dari situasi ini dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">4lemon</a> <br><br><img src="https://habrastorage.org/webt/qp/px/l2/qppxl2frreqvbhf6ehxgt0it-vi.png"><br><br>  Kondisi balapan dapat di aplikasi multi-utas, serta di basis data di mana mereka bekerja.  Tidak harus dalam aplikasi web, misalnya, ini adalah kriteria umum untuk peningkatan hak istimewa dalam sistem operasi.  Meskipun aplikasi web memiliki karakteristik sendiri untuk operasi yang sukses, yang ingin saya bicarakan. <br><br><h2>  Operasi Kondisi Balap Khas </h2><br><blockquote>  Seorang hacker memasuki hookah, pencarian dan bar, dan kepadanya - Anda memiliki kondisi balapan!  Omar Ganiev </blockquote><br>  Dalam kebanyakan kasus, perangkat lunak multithreaded digunakan sebagai klien untuk memeriksa / mengoperasikan kondisi balapan.  Misalnya, Burp Suite dan alat Penyusupnya.  Mereka menempatkan satu permintaan HTTP untuk pengulangan, menginstal banyak aliran dan menghidupkan banjir.  Seperti misalnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di artikel ini</a> .  Atau yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> .  Ini adalah cara yang cukup berhasil, jika server memungkinkan penggunaan beberapa utas ke sumber dayanya, dan seperti yang mereka katakan dalam artikel di atas, jika tidak berhasil, coba lagi.  Tetapi kenyataannya adalah bahwa dalam beberapa situasi, ini mungkin tidak efektif.  Terutama jika Anda ingat bagaimana aplikasi tersebut mengakses server. <br><br><h4>  Apa yang ada di server </h4><br>  Setiap utas membuat koneksi TCP, mengirim data, menunggu respons, menutup koneksi, membuka lagi, mengirim data, dan sebagainya.  Pada pandangan pertama, semua data dikirim secara bersamaan, tetapi permintaan HTTP itu sendiri mungkin tidak tiba secara serentak dan tidak konsisten karena sifat lapisan transport, kebutuhan untuk membuat koneksi aman (HTTPS) dan menyelesaikan DNS (tidak dalam kasus sendawa) dan banyak lapisan abstraksi yang meneruskan data sebelum dikirim ke perangkat jaringan.  Ketika datang ke milidetik, ini bisa memainkan peran kunci. <br><br><h2>  Pemipaan HTTP </h2><br>  Anda dapat mengingat HTTP-Pipelining, di mana Anda dapat mengirim data menggunakan soket tunggal.  Anda dapat melihat sendiri bagaimana cara kerjanya menggunakan utilitas netcat (Anda memiliki GNU / Linux, kan?). <br><br>  <i>Bahkan, Anda perlu menggunakan linux karena berbagai alasan, karena ada tumpukan TCP / IP yang lebih modern, yang didukung oleh kernel sistem operasi.</i>  <i>Server kemungkinan besar juga ada di sana.</i> <br><br>  Misalnya, jalankan <i>nc google.com 80</i> dan masukkan baris di sana <br><br><pre> <code class="markdown hljs">GET / HTTP/1.1 Host: google.com GET / HTTP/1.1 Host: google.com GET / HTTP/1.1 Host: google.com</code> </pre><br>  Dengan demikian, dalam satu koneksi, tiga permintaan HTTP akan dikirim, dan Anda akan menerima tiga respons HTTP.  Fitur ini dapat digunakan untuk meminimalkan waktu antar permintaan. <br><br><h4>  Apa yang ada di server </h4><br>  Server web akan menerima permintaan secara berurutan (kata kunci), dan memproses respons sesuai urutan prioritas.  Fitur ini dapat digunakan untuk menyerang dalam beberapa langkah (bila perlu secara berurutan melakukan dua tindakan dalam jumlah waktu minimum) atau, misalnya, untuk memperlambat server pada permintaan pertama untuk meningkatkan keberhasilan serangan. <br>  Trik - Anda dapat mencegah server memproses permintaan Anda dengan memuat DBMS-nya, terutama jika INSERT / UPDATE digunakan.  Permintaan yang lebih berat dapat "memperlambat" muatan Anda, dengan demikian, kemungkinan besar Anda akan memenangkan perlombaan ini. <br><br><h2>  Membagi permintaan HTTP menjadi dua bagian </h2><br>  Pertama, ingat bagaimana permintaan HTTP dihasilkan.  Seperti yang Anda ketahui, baris pertama adalah versi metode, jalur dan protokol: <br><br> <code>GET / HTTP/1.1</code> <br> <br>  Berikutnya adalah tajuk sebelum jeda baris: <br><br> <code>Host: google.com <br> Cookie: a=1</code> <br>  Tetapi bagaimana server web tahu bahwa permintaan HTTP telah berakhir? <br><br>  Mari kita lihat sebuah contoh, masukkan <i>nc google.com 80</i> , dan di sana <br><br> <code>GET / HTTP/1.1 <br> Host: google.com</code>  <code>GET / HTTP/1.1 <br> Host: google.com</code> , setelah Anda menekan ENTER, tidak ada yang terjadi.  Klik lagi - Anda akan melihat jawabannya. <br><br>  Yaitu, agar server web menerima permintaan HTTP, dua umpan baris diperlukan.  Kueri yang valid terlihat seperti ini: <br><br> <code>GET / HTTP/1.1\r\nHost: google.com\r\n\r\n</code> <br> <br>  Jika ini adalah metode POST (jangan lupa tentang Panjang Konten), maka permintaan HTTP yang benar adalah seperti ini: <br><br> <code>POST / HTTP/1.1 <br> Host: google.com <br> Content-Length: 3 <br> <br> a=1</code> <br> <br>  atau <br><br> <code>POST / HTTP/1.1\r\nHost: google.com\r\nContent-Length: 3\r\n\r\na=1</code> <br> <br>  Coba kirim permintaan serupa dari baris perintah: <br><br><pre> <code class="markdown hljs">echo -ne "GET / HTTP/1.1\r\nHost: google.com\r\n\r\n" | nc google.com 80</code> </pre> <br>  Akibatnya, Anda akan menerima respons, karena permintaan HTTP kami selesai.  Tetapi jika Anda menghapus karakter terakhir, Anda tidak akan mendapatkan jawaban. <br><br>  Faktanya, banyak server web hanya perlu menggunakan \ n sebagai transfer, jadi penting untuk tidak menukar \ r dan \ n, jika tidak, trik lebih lanjut mungkin tidak berfungsi. <br><br>  Apa yang diberikannya?  Anda dapat secara bersamaan membuka banyak koneksi ke sumber daya, mengirim 99% dari permintaan HTTP Anda dan membiarkan byte terakhir tidak terkirim.  Server akan menunggu sampai Anda mencapai umpan baris terakhir.  Setelah itu jelas bahwa bagian utama dari data telah dikirim, kirim byte terakhir (atau beberapa). <br><br>  Ini sangat penting ketika menyangkut permintaan POST yang besar, misalnya, saat pengunggahan file diperlukan.  Tetapi bahkan dalam permintaan kecil ini masuk akal, karena memberikan beberapa byte jauh lebih cepat daripada kilobyte informasi secara bersamaan. <br><br><h2>  Tunda sebelum mengirim bagian kedua dari permintaan </h2><br>  Menurut penelitian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vlad Roskov</a> , perlu tidak hanya untuk membagi permintaan, tetapi juga masuk akal untuk membuat penundaan beberapa detik antara mengirim bagian utama dari data dan yang terakhir.  Dan semua karena server web mulai menguraikan permintaan bahkan sebelum mereka menerimanya secara keseluruhan. <br><br><img src="https://habrastorage.org/webt/ey/cy/pm/eycypmp2hxca1gxe_-xee3zeeh8.png"><br><br><h4>  Apa yang ada di server </h4><br>  Misalnya, saat menerima tajuk permintaan HTTP, nginx akan mulai menguraikannya, meng-cache permintaan yang rusak.  Ketika byte terakhir tiba, server web akan mengambil permintaan yang diproses sebagian dan mengirimkannya langsung ke aplikasi, sehingga mengurangi waktu pemrosesan permintaan, yang meningkatkan kemungkinan serangan. <br><br><h2>  Bagaimana menghadapinya </h2><br>  Pertama-tama, ini tentu saja merupakan masalah arsitektur, jika Anda mendesain aplikasi web dengan benar, Anda dapat menghindari balapan semacam itu. <br><br>  Biasanya, metode kontrol serangan berikut digunakan: <br><br><ul><li>  Gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kunci</a> . </li></ul><br>  Operasi memblokir akses ke objek yang terkunci di DBMS sampai tidak diblokir.  Yang lain berdiri dan menunggu di sela-sela.  Penting untuk bekerja dengan kunci dengan benar, bukan untuk memblokir sesuatu yang berlebihan. <br><br><ul><li>  Mereka mengatur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">isolasi transaksi</a> . </li></ul><br>  Transaksi tertib (serializable) - memastikan bahwa transaksi akan dilakukan secara berurutan, namun, ini dapat memengaruhi kinerja. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mutaph semaphores</a> (hehe) digunakan. </li></ul><br>  Ambil sesuatu (mis. Dlld).  Pada saat memanggil fungsi, entri dengan kunci dibuat, jika itu tidak mungkin untuk membuat entri, maka sudah ada dan kemudian permintaan terputus.  Di akhir pemrosesan permintaan, catatan dihapus. <br><br>  Dan secara umum, saya menyukai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video karya Ivan the Hard worker</a> tentang kunci dan transaksi, sangat informatif. <br><br><h2>  Fitur sesi dalam kondisi balapan </h2><br>  Salah satu fitur sesi mungkin itu sendiri mengganggu eksploitasi ras.  Misalnya, dalam PHP, setelah session_start (), file sesi terkunci, dan pembukaan kunci hanya terjadi di akhir skrip (jika tidak ada panggilan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">session_write_close</a> ).  Jika skrip lain yang menggunakan sesi dipanggil saat ini, ia akan menunggu. <br><br>  Untuk menghindari fitur ini, Anda dapat menggunakan trik sederhana - untuk mengautentikasi sebanyak yang diperlukan.  Jika aplikasi web memungkinkan Anda membuat banyak sesi untuk satu pengguna, kumpulkan saja PHPSESSID dan buat setiap permintaan sebagai pengidentifikasi sendiri. <br><br><h2>  Jarak ke server </h2><br>  Jika situs tempat Anda ingin beroperasi, kondisi balapan di-host di AWS - bawa mobil dalam AWS.  Jika di DigitalOcean - bawa ke sana. <br><br>  Ketika tugasnya adalah untuk mengirim permintaan dan meminimalkan interval pengiriman di antara mereka, kedekatan langsung ke server web tidak diragukan lagi akan menjadi nilai tambah. <br><br>  Lagi pula, ada perbedaan ketika melakukan ping ke server 200 dan 10 ms.  Dan jika Anda beruntung, Anda bahkan dapat berakhir di server fisik yang sama, maka itu akan sedikit lebih mudah untuk terbang :) <br><br><h3>  Untuk meringkas </h3><br>  Untuk kondisi balapan yang sukses, Anda dapat menerapkan berbagai trik untuk meningkatkan kemungkinan sukses.  Kirim beberapa permintaan tetap hidup dalam satu, memperlambat server web.  Pecah permintaan menjadi beberapa bagian dan buat penundaan sebelum mengirim.  Kurangi jarak ke server dan jumlah abstraksi ke antarmuka jaringan. <br><br>  Sebagai hasil dari analisis ini, bersama dengan Michail Badin, kami mengembangkan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RacePWN</a> <br><br>  Ini terdiri dari dua komponen: <br><br><ul><li>  Pustaka perpustakaan, yang mengirimkan banyak permintaan HTTP ke server dalam waktu singkat dan menggunakan sebagian besar fitur dari artikel </li></ul><br><ul><li>  Utilitas racepwn, yang menerima konfigurasi json dan biasanya mengarahkan perpustakaan ini </li></ul><br>  RacePWN dapat diintegrasikan ke utilitas lain (misalnya, di Burp Suite), atau Anda dapat membuat antarmuka web untuk mengelola penerbangan (Anda masih belum bisa mendapatkannya).  Selamat menikmati! <br><br>  Namun pada kenyataannya masih ada ruang untuk tumbuh dan Anda dapat mengingat HTTP / 2 dan prospek serangannya.  Tetapi saat ini HTTP / 2, sebagian besar sumber daya hanya memiliki permintaan proxy depan untuk HTTP / 1.1 tua yang baik. <br><br>  Mungkin Anda tahu beberapa seluk beluk lainnya? <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Asli</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460339/">https://habr.com/ru/post/id460339/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460313/index.html">Apakah lagu hit yang berbeda memiliki kesamaan?</a></li>
<li><a href="../id460319/index.html">Perburuan Inspektur Luar Angkasa</a></li>
<li><a href="../id460321/index.html">Galeri notebook ML dan Data Science terbaik</a></li>
<li><a href="../id460329/index.html">Bukan FEDOR, tetapi Skybot F-850 akan terbang ke ISS</a></li>
<li><a href="../id460335/index.html">Apakah Google Chrome berhenti melindungi dari serangan XSS?</a></li>
<li><a href="../id460341/index.html">Melanjutkan ASO: tren, peringkat, dan sedikit umpan balik</a></li>
<li><a href="../id460343/index.html">Kisah bagaimana pengembangan game telah menjadi bagian dari hidup saya</a></li>
<li><a href="../id460345/index.html">Instal dan konfigurasikan Sonata Admin di Symfony 4</a></li>
<li><a href="../id460347/index.html">Manajemen perangkat seluler dan banyak lagi dengan solusi UEM Sophos</a></li>
<li><a href="../id460349/index.html">Periksa Kartu Akselerasi Point Falcon - Mempercepat Pemrosesan Lalu Lintas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>