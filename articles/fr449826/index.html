<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôá üêí üïë [Fran√ßais] Mod√®le de filetage Envoy üí∑ ‚òùüèæ ü§úüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous pr√©sente la traduction de l'article ¬´Envoy threading model¬ª de Matt Klein. 

 Cet article m'a sembl√© assez int√©ressant, et comm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[Fran√ßais] Mod√®le de filetage Envoy</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449826/">  Bonjour, Habr!  Je vous pr√©sente la traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Envoy threading model¬ª</a> de Matt Klein. <br><br>  Cet article m'a sembl√© assez int√©ressant, et comme Envoy est le plus souvent utilis√© dans le cadre de kubernetes ¬´istio¬ª ou simplement ¬´contr√¥leur d'entr√©e¬ª, la plupart des gens n'ont donc pas la m√™me interaction directe avec lui que par exemple avec les installations typiques de Nginx ou Haproxy.  Cependant, si quelque chose se casse, il serait bon de comprendre comment cela fonctionne de l'int√©rieur.  J'ai essay√© de traduire autant de texte que possible en russe, y compris des mots sp√©ciaux, pour ceux qui sont p√©nibles √† regarder, j'ai laiss√© les originaux entre crochets.  Bienvenue au chat. <br><a name="habracut"></a><br>  La documentation technique de bas niveau sur la base de code Envoy est actuellement assez rare.  Pour r√©soudre ce probl√®me, je pr√©vois de cr√©er une s√©rie d'articles de blog sur les diff√©rents sous-syst√®mes Envoy.  Comme il s'agit du premier article, faites-moi savoir ce que vous pensez et ce qui pourrait vous int√©resser dans les articles suivants. <br><br>  L'une des questions techniques les plus courantes que j'obtiens √† propos d'Envoy est une demande de description de bas niveau du mod√®le de filetage utilis√©.  Dans cet article, je d√©crirai comment Envoy mappe les connexions aux threads, ainsi qu'une description du syst√®me de stockage local de threads, qui est utilis√© en interne pour rendre le code plus parall√®le et plus performant. <br><br><h1>  Aper√ßu du filetage </h1><br><img src="https://habrastorage.org/webt/jy/46/yw/jy46ywgcjdk8zvrpwyeisan8hzm.png"><br><br>  <b>Envoy utilise trois types de flux diff√©rents:</b> <br><br><ul><li>  <b>Principal:</b> ce fil contr√¥le le d√©but et la fin du processus, tout le traitement de l'API XDS (xDiscovery Service), y compris le DNS, la v√©rification de l'int√©grit√©, la gestion g√©n√©rale du cluster et des services (runtime), la r√©initialisation des statistiques, l'administration et la gestion g√©n√©rale processus - signaux Linux, red√©marrage √† chaud, etc. Tout ce qui se passe dans ce fil est asynchrone et non bloquant.  En g√©n√©ral, le thread principal coordonne tous les processus critiques de fonctionnalit√©, qui ne n√©cessitent pas un grand nombre de CPU pour terminer.  Cela permet d'√©crire la plupart du code de contr√¥le comme s'il s'agissait d'un seul thread. </li><li>  <b>Worker:</b> Par d√©faut, Envoy cr√©e un thread de travail pour chaque thread mat√©riel du syst√®me, ce qui peut √™tre contr√¥l√© √† l'aide de l'option <code>--concurrency</code> .  Chaque thread de travail d√©marre une boucle d'√©v√©nement ¬´non bloquante¬ª, qui est responsable de l'√©coute de chaque √©couteur, au moment de la r√©daction (29 juillet 2017) il n'y a pas de partitionnement de l'auditeur, en recevant de nouveaux connexions, cr√©ation d'une instance de la pile de filtres √† connecter et traitement de toutes les op√©rations d'E / S pendant la dur√©e de vie de la connexion.  Encore une fois, cela permet √† la plupart du code de traitement de connexion d'√™tre √©crit comme s'il s'agissait d'un seul thread. </li><li>  <b>Nettoyeur de fichiers:</b> chaque fichier √©crit par Envoy, principalement les journaux d'acc√®s, poss√®de actuellement un flux de blocage ind√©pendant.  Cela est d√ª au fait que l'√©criture dans des fichiers mis en cache par le syst√®me de fichiers, m√™me lors de l'utilisation de <code>O_NONBLOCK</code> , peut parfois √™tre bloqu√©e (soupir).  Lorsque les threads de travail doivent √©crire dans un fichier, les donn√©es sont en fait d√©plac√©es vers un tampon en m√©moire, o√π elles sont finalement vid√©es via le flux de <b>vidage de fichier</b> .  Il s'agit d'un domaine de code o√π techniquement tous les threads de travail peuvent bloquer le m√™me verrou tout en essayant de remplir la m√©moire tampon. </li></ul><br><h1>  Gestion des connexions </h1><br>  Comme expliqu√© bri√®vement ci-dessus, tous les threads de travail √©coutent tous les √©couteurs sans aucune segmentation.  Ainsi, le noyau est utilis√© pour envoyer correctement les sockets re√ßues aux threads de travail.  Les c≈ìurs modernes sont g√©n√©ralement tr√®s bons dans ce domaine, ils utilisent des fonctionnalit√©s telles que l'augmentation de la priorit√© des entr√©es-sorties (IO) pour essayer de remplir le thread avec du travail, avant de commencer √† utiliser d'autres threads qui √©coutent √©galement sur le m√™me socket, et n'utilisent pas non plus le verrouillage circulaire (Spinlock) pour g√©rer chaque demande. <br><br>  Une fois qu'une connexion est accept√©e sur un thread de travail, elle ne quitte jamais ce thread.  Tous les autres traitements de la connexion sont enti√®rement trait√©s dans le thread de travail, y compris tout comportement de transfert. <br><br>  <b>Cela a plusieurs cons√©quences importantes:</b> <br><br><ul><li>  <u>Tous les pools de connexions dans Envoy sont dans un flux de travail.</u>  <u>Ainsi, bien que les pools de connexions HTTP / 2 √©tablissent une seule connexion √† chaque h√¥te en amont √† la fois, s'il y a quatre threads de travail, il y aura quatre connexions HTTP / 2 √† l'h√¥te en amont dans un √©tat stable.</u> </li><li>  La raison pour laquelle Envoy fonctionne de cette fa√ßon est qu'en stockant tout dans un m√™me flux de travail, presque tout le code peut √™tre √©crit sans blocage et comme s'il √©tait √† un seul thread.  Cette conception facilite l'√©criture de beaucoup de code et √©volue incroyablement bien pour un nombre presque illimit√© de workflows. </li><li>  Cependant, l'une des principales conclusions est que du point de vue du pool de m√©moire et de l'efficacit√© de la connexion, il est en fait tr√®s important de configurer le param√®tre <code>--concurrency</code> .  Le fait d'avoir plus de threads de travail que n√©cessaire entra√Ænera une perte de m√©moire, cr√©ant plus de connexions inactives et ralentissant la vitesse d'acc√®s au pool de connexions.  Chez Lyft, nos conteneurs sidecar envoy√©s fonctionnent avec une concurrence tr√®s faible, de sorte que les performances sont √† peu pr√®s √©quivalentes aux services √† c√¥t√© desquels ils se trouvent.  Nous ex√©cutons Envoy en tant que proxy Edge (Edge) uniquement avec une concurrence maximale. </li></ul><br><h1>  Que signifie non bloquant? </h1><br>  Le terme "non bloquant" a jusqu'√† pr√©sent √©t√© utilis√© √† plusieurs reprises pour discuter du fonctionnement des threads principal et de travail.  Tout le code est √©crit √† condition que rien ne soit jamais bloqu√©.  Cependant, ce n'est pas enti√®rement vrai (ce qui n'est pas enti√®rement vrai?). <br><br>  <b>Envoy utilise plusieurs verrous de processus longs:</b> <br><br><ul><li>  Comme d√©j√† mentionn√©, lors de l'√©criture des journaux d'acc√®s, tous les threads de travail obtiennent le m√™me verrou avant de remplir le tampon de journal en m√©moire.  Le temps de maintien du verrou doit √™tre tr√®s faible, mais il est possible que ce verrou soit mis √† l'√©preuve avec une concurrence √©lev√©e et un d√©bit √©lev√©. </li><li>  Envoy utilise un syst√®me tr√®s sophistiqu√© pour traiter les statistiques locales au flux.  Ce sera le sujet d'un article s√©par√©.  Cependant, je mentionnerai bri√®vement que dans le cadre du traitement local des statistiques de flux, il est parfois n√©cessaire d'obtenir un verrou pour le ¬´magasin de statistiques¬ª central.  Ce verrou ne devrait jamais √™tre n√©cessaire. </li><li>  Le thread principal a p√©riodiquement besoin d'une coordination avec tous les workflows.  Cela se fait en ¬´publiant¬ª du thread principal vers les threads de travail, et parfois depuis les threads de travail vers le thread principal.  Pour l'envoi, le blocage est n√©cessaire afin que le message publi√© puisse √™tre mis en file d'attente pour une remise ult√©rieure.  Ces serrures ne doivent jamais √™tre soumises √† une concurrence s√©rieuse, mais elles peuvent toujours √™tre bloqu√©es techniquement. </li><li>  Lorsque Envoy √©crit un journal dans le flux d'erreurs syst√®me (erreur standard), il re√ßoit un verrou sur l'ensemble du processus.  Dans l'ensemble, la journalisation locale d'Envoy est consid√©r√©e comme terrible en termes de performances, il n'y a donc pas beaucoup d'attention port√©e √† son am√©lioration. </li><li>  Il existe plusieurs autres verrous al√©atoires, mais aucun d'entre eux n'est critique pour les performances et ne doit jamais √™tre contest√©. </li></ul><br><h1>  Thread stockage local </h1><br>  En raison de la fa√ßon dont Envoy s√©pare les responsabilit√©s du thread principal des t√¢ches de workflow, il est n√©cessaire qu'un traitement complexe puisse √™tre effectu√© sur le thread principal, puis fourni √† chaque workflow avec un degr√© √©lev√© de concurrence.  Cette section d√©crit le syst√®me Envoy Thread Local Storage (TLS) √† un niveau √©lev√©.  Dans la section suivante, je d√©crirai comment il est utilis√© pour g√©rer le cluster. <br><br><img src="https://habrastorage.org/webt/hc/e4/bs/hce4bsjgfljckbekacfilceotyq.png"><br><br>  Comme d√©j√† d√©crit, le thread principal traite presque toutes les fonctions de gestion et la fonctionnalit√© du plan de contr√¥le dans le processus Envoy.  Le plan de contr√¥le est un peu surcharg√© ici, mais si vous le regardez dans le processus Envoy lui-m√™me et le comparez avec le transfert que les threads de travail effectuent, cela semble appropri√©.  En r√®gle g√©n√©rale, le processus de thread principal effectue un certain travail, puis il doit mettre √† jour chaque thread de travail conform√©ment au r√©sultat de ce travail, <u>tandis que le thread de travail n'a pas besoin de d√©finir un verrou sur chaque acc√®s</u> . <br><br>  <b>Le syst√®me Envoy TLS (Thread local storage) fonctionne comme suit:</b> <br><br><ul><li>  Le code ex√©cut√© dans le thread principal peut allouer un emplacement TLS pour l'ensemble du processus.  Bien que cela soit abstrait, en pratique c'est un index dans un vecteur qui fournit un acc√®s O (1). </li><li>  Le flux principal peut d√©finir des donn√©es arbitraires dans son emplacement.  Lorsque cela est fait, les donn√©es sont publi√©es dans chaque flux de travail en tant qu'√©v√©nement de boucle d'√©v√©nement normal. </li><li>  Les threads de travail peuvent lire √† partir de leur emplacement TLS et r√©cup√©rer toutes les donn√©es de thread local qui y sont disponibles. </li></ul><br>  Bien qu'il s'agisse d'un paradigme tr√®s simple et incroyablement puissant, il est tr√®s similaire au concept de blocage de RCU (lecture-copie-mise √† jour).  En substance, les workflows ne voient jamais de modifications de donn√©es dans les emplacements TLS au moment de l'ex√©cution.  Le changement ne se produit que pendant la p√©riode de repos entre les √©v√©nements professionnels. <br><br>  <b>Envoy utilise cela de deux mani√®res diff√©rentes:</b> <br><br><ul><li>  En stockant diff√©rentes donn√©es sur chaque workflow, l'acc√®s √† ces donn√©es se fait sans aucun blocage. </li><li>  En stockant un pointeur global sur des donn√©es globales en lecture seule sur chaque thread de travail.  Ainsi, chaque thread de travail poss√®de un compteur de r√©f√©rence de donn√©es, qui ne peut pas √™tre r√©duit pendant l'ex√©cution du travail.  Ce n'est que lorsque tous les employ√©s se calmeront et t√©l√©chargeront de nouvelles donn√©es partag√©es que les anciennes donn√©es seront d√©truites.  Il est identique au RCU. </li></ul><br><h1>  Filetage de mise √† jour de cluster </h1><br>  Dans cette section, je d√©crirai comment TLS (Thread local storage) est utilis√© pour g√©rer un cluster.  La gestion des clusters comprend le traitement de l'API xDS et / ou DNS, ainsi que la v√©rification de l'int√©grit√©. <br><br><img src="https://habrastorage.org/webt/by/jw/4q/byjw4qhlo9xjsprdu9ngi9dop_y.png"><br><br>  <b>La gestion des flux de cluster comprend les composants et √©tapes suivants:</b> <br><br><ol><li>  Cluster Manager est un composant d'Envoy qui g√®re tous les clusters connus en amont, les API CDS (Cluster Discovery Service), SDS (Secret Discovery Service) et EDS (Endpoint Discovery Service), DNS et les v√©rifications externes actives. sant√© (bilan de sant√©).  Il est responsable de la cr√©ation d'une repr√©sentation ¬´finalement coh√©rente¬ª de chaque cluster en amont qui inclut les h√¥tes d√©couverts, ainsi que l'√©tat de sant√©. </li><li>  Le v√©rificateur d'int√©grit√© effectue une v√©rification d'int√©grit√© active et rend compte des modifications de l'√©tat d'int√©grit√© au gestionnaire de cluster. </li><li>  CDS (Cluster Discovery Service) / SDS (Secret Discovery Service) / EDS (Endpoint Discovery Service) / DNS sont effectu√©s pour d√©terminer l'appartenance au cluster.  Le changement d'√©tat est renvoy√© au gestionnaire de cluster. </li><li>  Chaque flux de travail ex√©cute constamment une boucle d'√©v√©nements. </li><li>  Lorsque le gestionnaire de cluster d√©termine que l'√©tat du cluster a chang√©, il cr√©e un nouvel instantan√© de cluster en lecture seule et l'envoie √† chaque thread de travail. </li><li>  Au cours de la prochaine p√©riode de dormance, le flux de travail mettra √† jour l'instantan√© dans l'emplacement TLS d√©di√©. </li><li>  Lors d'un √©v√©nement d'E / S que l'h√¥te doit d√©terminer pour l'√©quilibrage de charge, l'√©quilibreur de charge demandera un emplacement TLS (Thread local storage) pour obtenir les informations d'h√¥te.  Aucun verrou n'est requis pour cela.  Notez √©galement que TLS peut √©galement d√©clencher des √©v√©nements pendant la mise √† niveau, de sorte que les √©quilibreurs de charge et d'autres composants puissent recompter les caches, les structures de donn√©es, etc.  Cela d√©passe le cadre de cet article, mais est utilis√© √† divers endroits dans le code. </li></ol><br>  En utilisant la proc√©dure ci-dessus, Envoy peut traiter chaque demande sans aucun verrou (autre que ceux d√©crits pr√©c√©demment).  Outre la complexit√© du code TLS lui-m√™me, la plupart du code n'a pas besoin de comprendre comment fonctionne le multithreading, et il peut √™tre √©crit en mode monothread.  Cela facilite l'√©criture de la plupart du code en plus de performances sup√©rieures. <br><br><h1>  Autres sous-syst√®mes utilisant TLS </h1><br>  TLS (Thread local storage) et RCU (Read Copy Update) sont largement utilis√©s dans Envoy. <br><br>  <b>Exemples d'utilisation:</b> <br><br><ul><li>  <b>Le m√©canisme de modification des fonctionnalit√©s pendant l'ex√©cution:</b> la liste actuelle des fonctionnalit√©s activ√©es est calcul√©e dans le thread principal.  Chaque flux de travail est ensuite fourni avec un instantan√© en lecture seule √† l'aide de la s√©mantique RCU. </li><li>  <b>Remplacement des tables de routage</b> : pour les tables de routage fournies par le RDS (Route Discovery Service), les tables de routage sont cr√©√©es dans le thread principal.  Un instantan√© en lecture seule sera fourni ult√©rieurement √† chaque flux de travail √† l'aide de la s√©mantique RCU (Read Copy Update).  Cela rend la modification des tables de routage atomiquement efficace. </li><li>  <b>Mise en cache d'en-t√™te HTTP:</b> Il s'av√®re que le calcul de l'en-t√™te HTTP pour chaque demande (lors de l'ex√©cution de ~ 25K + RPS par c≈ìur) est assez co√ªteux.  Envoy calcule l'en-t√™te de mani√®re centralis√©e environ toutes les demi-secondes et le fournit √† chaque employ√© via TLS et RCU. </li></ul><br>  Il existe d'autres cas, mais les exemples pr√©c√©dents devraient permettre de bien comprendre √† quoi sert TLS. <br><br><h1>  Pi√®ges de performance connus </h1><br>  Bien qu'Envoy fonctionne assez bien dans l'ensemble, il existe quelques domaines bien connus qui n√©cessitent une attention lorsqu'ils sont utilis√©s avec une concurrence et une bande passante tr√®s √©lev√©es: <br><br><ul><li>  Comme d√©j√† d√©crit dans cet article, actuellement tous les threads de travail sont verrouill√©s lorsqu'ils √©crivent dans le tampon de m√©moire du journal d'acc√®s.  Avec une concurrence √©lev√©e et un d√©bit √©lev√©, il sera n√©cessaire de regrouper les journaux d'acc√®s pour chaque flux de travail en raison d'une livraison non ordonn√©e lors de l'√©criture dans le fichier final.  Vous pouvez √©galement cr√©er un journal d'acc√®s distinct pour chaque flux de travail. </li><li>  Bien que les statistiques soient tr√®s optimis√©es, avec une concurrence et un d√©bit tr√®s √©lev√©s, il y aura probablement une concurrence atomique sur les statistiques individuelles.  La solution √† ce probl√®me consiste en des compteurs pour un flux de travail avec une r√©initialisation p√©riodique des compteurs centraux.  Cela sera discut√© dans un prochain post. </li><li>  L'architecture existante ne fonctionnera pas correctement si Envoy est d√©ploy√© dans un sc√©nario dans lequel il y a tr√®s peu de connexions qui n√©cessitent des ressources de traitement importantes.  Il n'y a aucune garantie que les communications seront r√©parties √©galement entre les workflows.  Cela peut √™tre r√©solu en √©quilibrant les connexions de travail, dans lequel la capacit√© √† √©changer des connexions entre les flux de travail sera r√©alis√©e. </li></ul><br><h1>  Conclusion </h1><br>  Le mod√®le de filetage Envoy est con√ßu pour fournir une facilit√© de programmation et une concurrence massive en raison de l'utilisation potentiellement inutile de la m√©moire et des connexions si elles ne sont pas configur√©es correctement.  Ce mod√®le lui permet de fonctionner tr√®s bien avec un nombre tr√®s √©lev√© de threads et de d√©bit. <br><br>  Comme je l'ai bri√®vement mentionn√© sur Twitter, une conception peut √©galement s'ex√©cuter au-dessus d'une pile r√©seau enti√®rement fonctionnelle en mode utilisateur, comme le DPDK (Data Plane Development Kit), ce qui peut entra√Æner des serveurs r√©guliers √† traiter des millions de demandes par seconde avec un traitement L7 complet.  Il sera tr√®s int√©ressant de voir ce qui sera construit dans les prochaines ann√©es. <br><br>  Un dernier petit commentaire: on m'a souvent demand√© pourquoi nous avions choisi C ++ pour Envoy.  La raison, comme pr√©c√©demment, est qu'il est toujours le seul langage de niveau industriel largement parl√© sur lequel construire l'architecture d√©crite dans cet article.  C ++ n'est certainement pas adapt√© √† tous ou m√™me √† de nombreux projets, mais pour certains cas d'utilisation, il reste le seul outil pour faire le travail (pour faire le travail). <br><br><h1>  Liens vers le code </h1><br>  <b>Liens vers des fichiers avec des interfaces et des impl√©mentations d'en-t√™te discut√©s dans cet article:</b> <br><br><ul><li>  <a href="">github.com/lyft/envoy/blob/master/include/envoy/thread_local/thread_local.h</a> </li><li>  <a href="">github.com/lyft/envoy/blob/master/source/common/thread_local/thread_local_impl.h</a> </li><li>  <a href="">github.com/lyft/envoy/blob/master/include/envoy/upstream/cluster_manager.h</a> </li><li>  <a href="">github.com/lyft/envoy/blob/master/source/common/upstream/cluster_manager_impl.h</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr449826/">https://habr.com/ru/post/fr449826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr449808/index.html">Exp√©rience Positive Hack Days 9: comment la pens√©e critique aide dans la vie et le travail</a></li>
<li><a href="../fr449814/index.html">Windows XP est officiellement mort, enfin enfin</a></li>
<li><a href="../fr449818/index.html">Statistiques et suivi des scripts PHP en temps r√©el. ClickHouse et Grafana vont √† Pinba pour obtenir de l'aide</a></li>
<li><a href="../fr449820/index.html">Personnalisez instantan√©ment les associations de fichiers famili√®res</a></li>
<li><a href="../fr449824/index.html">Les aventures de Iron Startup en Russie: Team Building</a></li>
<li><a href="../fr449828/index.html">"Des souris pleuraient et piquaient .." La substitution des importations dans la pratique. Partie 4 (th√©orique, finale). Syst√®mes et services</a></li>
<li><a href="../fr449830/index.html">Commande de ligne √©lectrique HD44780</a></li>
<li><a href="../fr449832/index.html">L'avenir quantique</a></li>
<li><a href="../fr449836/index.html">Dell U2419HC: √©l√©gant moniteur 24 pouces avec Full HD et USB-C</a></li>
<li><a href="../fr449840/index.html">Barre de cr√©ation: une nouvelle m√©thode de phishing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>