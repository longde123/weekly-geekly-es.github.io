<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèæ ‚ú® ü•á Voll funktionsf√§higes dynamisches Tracing unter Linux mit eBPF und bpftrace üíß üôåüèæ ü§ûüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄûIm Trace-Modus sieht der Programmierer in diesem Schritt der Programmausf√ºhrung die Reihenfolge der Befehlsausf√ºhrung und die Werte der Variablen, wo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Voll funktionsf√§higes dynamisches Tracing unter Linux mit eBPF und bpftrace</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/441258/"><img src="https://habrastorage.org/webt/gd/t6/e_/gdt6e_wwaanx1prvqkhdhj5ptss.jpeg"><br><br>  ‚ÄûIm Trace-Modus sieht der Programmierer in diesem Schritt der Programmausf√ºhrung die Reihenfolge der Befehlsausf√ºhrung und die Werte der Variablen, wodurch Fehler leichter erkannt werden k√∂nnen‚Äú, sagt Wikipedia.  Als Linux-Fans sto√üen wir regelm√§√üig auf die Frage, welche spezifischen Tools am besten f√ºr die Implementierung geeignet sind.  Und wir m√∂chten die √úbersetzung eines Artikels des Programmierers Hongley Lai teilen, der bpftrace empfiehlt.  Mit Blick auf die Zukunft werde ich sagen, dass der Artikel kurz und b√ºndig endet: "bpftrace ist die Zukunft".  Warum hat er Lais Kollegen so beeindruckt?  Eine ausf√ºhrliche Antwort unter dem Schnitt. <br><a name="habracut"></a><br>  Unter Linux gibt es zwei Haupt-Trace-Tools: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit strace</a> k√∂nnen Sie sehen, welche Systemaufrufe get√§tigt werden. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit ltrace</a> k√∂nnen Sie sehen, welche dynamischen Bibliotheken aufgerufen werden. <br><br>  Trotz ihrer N√ºtzlichkeit sind diese Werkzeuge begrenzt.  Und wenn Sie herausfinden m√∂chten, was in einem System- oder Bibliotheksaufruf passiert?  Und wenn Sie nicht nur eine Liste von Anrufen erstellen, sondern beispielsweise auch Statistiken zu bestimmten Verhaltensweisen sammeln m√ºssen?  Und wenn Sie mehrere Prozesse verfolgen und Daten aus mehreren Quellen vergleichen m√ºssen? <br><br>  Im Jahr 2019 haben wir endlich eine anst√§ndige Antwort auf diese Fragen unter Linux erhalten: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bpftrace</a> basierend auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eBPF-</a> Technologie.  Mit Bpftrace k√∂nnen Sie kleine Programme schreiben, die jedes Mal ausgef√ºhrt werden, wenn ein Ereignis auftritt. <br><br>  In diesem Artikel werde ich beschreiben, wie man bpftrace installiert und seine grundlegende Anwendung lehrt.  Ich werde auch einen √úberblick dar√ºber geben, wie das Spuren-√ñkosystem aussieht (zum Beispiel ‚ÄûWas ist eBPF?‚Äú) Und wie es sich zu dem entwickelt hat, was wir heute haben. <br><br><img src="https://habrastorage.org/webt/v9/vp/di/v9vpdivpv8a6roolw_kiz7wtnfs.png"><br><br><h3>  Was ist eine Spur? </h3><br>  Wie bereits erw√§hnt, k√∂nnen Sie mit bpftrace kleine Programme schreiben, die jedes Mal ausgef√ºhrt werden, wenn ein Ereignis auftritt. <br><br>  Was ist eine Veranstaltung?  Es kann sich um einen Systemaufruf, einen Funktionsaufruf oder sogar um etwas handeln, das in solchen Anforderungen geschieht.  Es kann sich auch um einen Timer oder ein Hardware-Ereignis handeln, z. B. "50 ms sind seit dem letzten der gleichen Ereignisse vergangen", "Seitenfehler aufgetreten", "Kontextwechsel aufgetreten" oder "Cashe-Miss-Prozessor aufgetreten". <br><br>  Was kann als Reaktion auf ein Ereignis getan werden?  Sie k√∂nnen etwas verpf√§nden, Statistiken sammeln und beliebige Shell-Befehle ausf√ºhren.  Sie haben Zugriff auf verschiedene Kontextinformationen wie die aktuelle PID, die Stapelverfolgung, die Zeit, Aufrufargumente, R√ºckgabewerte usw. <br><br>  Wann verwenden?  In vielen.  Sie k√∂nnen herausfinden, warum die Anwendung langsam ist, indem Sie eine Liste der langsamsten Aufrufe zusammenstellen.  Sie k√∂nnen feststellen, ob und wo Speicherlecks in der Anwendung vorhanden sind.  Ich benutze es, um zu verstehen, warum Ruby so viel Speicher verwendet. <br><br>  Das gro√üe Plus von bpftrace ist, dass Sie die Anwendung nicht neu kompilieren m√ºssen.  Es ist nicht erforderlich, Druckaufrufe oder anderen Debugging-Code manuell in die Quellen der untersuchten Anwendung zu schreiben.  Es ist nicht einmal erforderlich, Anwendungen neu zu starten.  Und das alles mit sehr geringem Overhead.  Dies macht bpftrace besonders n√ºtzlich f√ºr das Debuggen von Systemen direkt auf dem Produkt oder in einer anderen Situation, in der es Schwierigkeiten bei der Neukompilierung gibt. <br><br><h3>  DTrace: Vater der Spur </h3><br>  Das beste Tracing-Tool war lange Zeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DTrace</a> , ein vollst√§ndiges dynamisches Tracing-Framework, das urspr√ºnglich von Sun Microsystems (den Herstellern von Java) entwickelt wurde.  Wie bei bpftrace k√∂nnen Sie mit DTrace kleine Programme schreiben, die als Reaktion auf Ereignisse ausgef√ºhrt werden.  Tats√§chlich werden viele der Schl√ºsselelemente des √ñkosystems gr√∂√ütenteils von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Brendan Gregg entwickelt</a> , einem renommierten DTrace-Experten, der derzeit bei Netflix arbeitet.  Das erkl√§rt die √Ñhnlichkeiten zwischen DTrace und bpftrace. <br><br><img src="https://habrastorage.org/webt/2p/wc/4w/2pwc4wawnfzibvlwt7ia0xibodc.jpeg"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Solaris DTrace (2009)</a> von S. Tripathi, Sun Microsystems</i> <br><br>  Irgendwann √∂ffnete Sun die Quelle f√ºr DTrace.  Heute ist DTrace unter Solaris, FreeBSD und macOS verf√ºgbar (obwohl die macOS-Version im Allgemeinen nicht funktionsf√§hig ist, da der System Integrity Protection, SIP, gegen viele der Prinzipien versto√üen hat, nach denen DTrace ausgef√ºhrt wird). <br><br>  Ja, Sie haben richtig bemerkt ... Linux ist nicht in dieser Liste.  Dies ist kein technisches Problem, sondern ein Lizenzproblem.  DTrace wurde unter der CDDL anstelle der GPL ge√∂ffnet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Linux DTrace-Port ist</a> seit 2011 verf√ºgbar, wurde jedoch von gro√üen Linux-Entwicklern nie unterst√ºtzt.  Anfang 2018 er√∂ffnete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oracle DTrace unter der GPL wieder</a> , aber zu diesem Zeitpunkt war es bereits zu sp√§t. <br><br><h3>  Linux-Tracing-√ñkosystem </h3><br>  Zweifellos ist die Ablaufverfolgung sehr n√ºtzlich, und die Linux-Community hat versucht, eigene L√∂sungen f√ºr dieses Thema zu entwickeln.  Im Gegensatz zu Solaris wird Linux jedoch nicht von einem bestimmten Anbieter reguliert, und daher wurden keine absichtlichen Anstrengungen unternommen, um einen voll funktionsf√§higen Ersatz f√ºr DTrace zu entwickeln.  Das Linux-Trace-√ñkosystem hat sich langsam und nat√ºrlich entwickelt und auftretende Probleme gel√∂st.  Und erst vor kurzem ist dieses √ñkosystem so gewachsen, dass es ernsthaft mit DTrace konkurrieren kann. <br><br>  Aufgrund des nat√ºrlichen Wachstums wirkt dieses √ñkosystem m√∂glicherweise etwas chaotisch und besteht aus vielen verschiedenen Komponenten.  Gl√ºcklicherweise schrieb Julia Evans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Rezension dieses √ñkosystems</a> (Aufmerksamkeit, Ver√∂ffentlichungsdatum - 2017, vor dem Aufkommen von bpftrace). <br><br><img src="https://habrastorage.org/webt/io/km/zq/iokmzq2fmqyechm1boqeks-w2za.png"><br>  <i>Linux-Trace-√ñkosystem von Julia Evans beschrieben</i> <br><br>  Nicht alle Elemente sind gleich wichtig.  Lassen Sie mich kurz zusammenfassen, welche Elemente ich f√ºr am wichtigsten halte. <br><br>  <b>Ereignisquellen</b> <br><br>  Ereignisdaten k√∂nnen entweder aus dem Kernel oder aus dem Benutzerbereich (Anwendungen und Bibliotheken) stammen.  Einige von ihnen sind automatisch ohne zus√§tzlichen Entwickleraufwand verf√ºgbar, w√§hrend andere eine manuelle Ank√ºndigung erfordern. <br><br><img src="https://habrastorage.org/webt/2t/xm/mm/2txmmm6rz5xfcwcglsxy8zopr6q.jpeg"><br>  <i>√úbersicht √ºber die wichtigsten Quellen f√ºr verfolgte Ereignisse unter Linux</i> <br><br>  Auf der Kernelseite gibt es K- <i>Sonden</i> ( <i>von ‚ÄûKernel-Sonden‚Äú, ‚ÄûKernel-Sensor‚Äú, ca. Per.</i> ) - ein Mechanismus, mit dem Sie jeden Funktionsaufruf im Kernel verfolgen k√∂nnen.  Damit k√∂nnen Sie nicht nur die Systemaufrufe selbst verfolgen, sondern auch, was in ihnen geschieht (da die Einstiegspunkte von Systemaufrufen andere interne Funktionen aufrufen).  Sie k√∂nnen kprobes auch verwenden, um Kernelereignisse zu verfolgen, bei denen es sich nicht um Systemaufrufe handelt, z. B. "Gepufferte Daten werden auf die Festplatte geschrieben", "TCP-Paket wird √ºber das Netzwerk gesendet" oder "Kontextumschaltung wird ausgef√ºhrt". <br><br>  Kernel-Tracepoints erm√∂glichen die Verfolgung von nicht standardm√§√üigen Ereignissen, die von Kernel-Entwicklern definiert wurden.  Diese Ereignisse befinden sich nicht auf der Ebene von Funktionsaufrufen.  Um solche Punkte zu erstellen, platzieren Kernelentwickler das Makro TRACE_EVENT manuell im Kernelcode. <br><br>  Beide Quellen haben Vor- und Nachteile.  Kprobes arbeitet "automatisch", weil  Kernel-Entwickler m√ºssen den Code nicht manuell codieren.  Kprobe-Ereignisse k√∂nnen sich jedoch willk√ºrlich von einer Version des Kernels zur anderen √§ndern, da sich die Funktionen st√§ndig √§ndern - sie werden hinzugef√ºgt, gel√∂scht und umbenannt. <br><br>  Kernel-Trace-Punkte sind im Allgemeinen √ºber die Zeit stabiler und bieten m√∂glicherweise n√ºtzliche Kontextinformationen, die m√∂glicherweise nicht verf√ºgbar sind, wenn kprobes verwendet wird.  Mit kprobes k√∂nnen Sie auf Funktionsaufrufargumente zugreifen.  Mithilfe von Ablaufverfolgungspunkten k√∂nnen Sie jedoch alle Informationen abrufen, die der Kernelentwickler manuell beschreiben m√∂chte. <br><br>  Im Benutzerraum gibt es ein Analogon von kprobes - uprobes.  Es wurde entwickelt, um Funktionsaufrufe im Benutzerbereich zu verfolgen. <br><br>  Die USDT-Sensoren (‚ÄûStatisch definierte User Space-Traces‚Äú) sind ein Analogon zu Kernel-Trace-Punkten im User Space.  Anwendungsentwickler m√ºssen ihrem Code manuell USDT-Sensoren hinzuf√ºgen. <br><br>  Interessante Tatsache: DTrace bietet seit langem die C-API zur Definition eines eigenen Analogons von USDT-Sensoren (mithilfe des Makros DTRACE_PROBE).  Entwickler von Trace-√ñkosystemen unter Linux haben beschlossen, den Quellcode mit dieser API kompatibel zu lassen, sodass alle DTRACE_PROBE-Makros automatisch in USDT-Sensoren konvertiert werden! <br><br>  Daher kann theoretisch strace unter Verwendung von kprobes implementiert werden, und ltrace kann unter Verwendung von uprobes implementiert werden.  Ich bin mir nicht sicher, ob dies bereits praktiziert wird oder nicht. <br><br>  <b>Schnittstellen</b> <br><br>  Schnittstellen sind Anwendungen, mit denen Benutzer Ereignisquellen einfach verwenden k√∂nnen. <br><br>  Schauen wir uns an, wie Ereignisquellen funktionieren.  Der Workflow ist wie folgt: <br><br><ol><li>  Der Kernel stellt einen Mechanismus dar - normalerweise eine / proc- oder / sys-Datei, die zum Schreiben ge√∂ffnet ist -, der sowohl die Absicht aufzeichnet, das Ereignis zu verfolgen, als auch, was dem Ereignis folgen soll. </li><li>  Nach der Registrierung lokalisiert der Kernel den Kernel / die Funktion im User Space / Trace Points / USDT-Sensoren im Speicher und √§ndert ihren Code, sodass etwas anderes passiert. </li><li>  Das Ergebnis dieses ‚Äûetwas anderen‚Äú kann sp√§ter mithilfe eines Mechanismus erfasst werden. </li></ol><br>  Ich w√ºrde das alles nicht manuell machen wollen!  Daher helfen Schnittstellen: Sie erledigen das alles f√ºr Sie. <br><br>  Es gibt Schnittstellen f√ºr jeden Geschmack und jede Farbe.  Im Bereich der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eBPF-basierten Schnittstellen</a> gibt es Low-Level- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstellen,</a> die ein tiefes Verst√§ndnis der Interaktion mit Ereignisquellen und der Funktionsweise des eBPF-Bytecodes erfordern.  Und es gibt hochrangige und einfach zu bedienende, obwohl sie w√§hrend ihrer Existenz keine gro√üe Flexibilit√§t zeigten. <br><br>  Deshalb ist bpftrace - das neueste Interface - mein Favorit.  Es ist benutzerfreundlich und flexibel wie DTrace.  Aber es ist ziemlich neu und muss poliert werden. <br><br><h3>  eBPF </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eBPF</a> ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neue Linux-Trace-Star,</a> auf dem bpftrace basiert.  Wenn Sie ein Ereignis verfolgen, m√∂chten Sie, dass im Kernel etwas passiert.  Wie flexibel kann man feststellen, was dieses "Etwas" ist?  Nat√ºrlich mit einer Programmiersprache (oder mit Maschinencode). <br><br>  eBPF (erweiterte Version des Berkeley Packet Filters).  Dies ist eine virtuelle Hochleistungsmaschine, die im Kernel ausgef√ºhrt wird und die folgenden Eigenschaften / Einschr√§nkungen aufweist: <br><br><ul><li>  Alle Benutzerbereichsinteraktionen erfolgen √ºber eBPF-Karten, bei denen es sich um Schl√ºsselwertspeicher handelt. </li><li>  Es gibt keine Zyklen, sodass jedes eBPF-Programm zu einem bestimmten Zeitpunkt beendet wird. </li><li>  Warten Sie, wir sagten Batch Filter?  Sie haben Recht: Sie wurden urspr√ºnglich zum Filtern von Netzwerkpaketen entwickelt.  Dies ist eine √§hnliche Aufgabe: Wenn Sie Pakete weiterleiten (das Auftreten eines Ereignisses), m√ºssen Sie eine Verwaltungsaktion ausf√ºhren (ein Paket akzeptieren, verwerfen, protokollieren oder umleiten usw.). Eine virtuelle Maschine wurde erfunden, um solche Aktionen zu beschleunigen (mit JIT-Funktion). Zusammenstellung).  Eine "erweiterte" Version wird in Betracht gezogen, da eBPF im Vergleich zur Originalversion des Berkeley-Paketfilters au√üerhalb des Netzwerkkontexts verwendet werden kann. </li></ul><br>  So.  Mit bpftrace k√∂nnen Sie festlegen, welche Ereignisse verfolgt werden sollen und was als Reaktion darauf geschehen soll.  Bpftrace kompiliert Ihr √ºbergeordnetes bpftrace-Programm in eBPF-Bytecode, verfolgt Ereignisse und l√§dt den Bytecode in den Kernel. <br><br><h3>  Dunkle Tage vor eBPF </h3><br>  Vor eBPF waren L√∂sungsoptionen, gelinde gesagt, umst√§ndlich.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SystemTap</a> ist ein bisschen der "ernsteste" Vorg√§nger von bpftrace in der Linux-Familie.  SystemTap-Skripte werden in die Sprache C √ºbersetzt und als Module in den Kernel geladen.  Das resultierende Kernelmodul wird dann geladen. <br><br>  Dieser Ansatz war au√üerhalb von Red Hat Enterprise Linux sehr fragil und wurde nur unzureichend unterst√ºtzt.  F√ºr mich hat es unter Ubuntu nie gut funktioniert, was dazu f√ºhrte, dass SystemTap bei jedem Kernel-Update aufgrund einer √Ñnderung der Kernel-Datenstruktur besch√§digt wurde.  Es wird auch gesagt, dass SystemTap in den fr√ºhen Tagen seiner Existenz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">leicht zu Kernel-Panik f√ºhrte</a> . <br><br><h3>  Bpftrace-Installation </h3><br>  Es ist Zeit, die √Ñrmel hochzukrempeln!  In diesem Handbuch werden wir uns mit der Installation von bpftrace unter Ubuntu 18.04 befassen.  Neuere Versionen der Distribution sind unerw√ºnscht, weil  W√§hrend der Installation ben√∂tigen wir Pakete, die noch nicht f√ºr sie kompiliert wurden. <br><br>  <b>Abh√§ngigkeitsinstallation</b> <br><br>  Installieren Sie zun√§chst Clang 5.0, lbclang 5.0 und LLVM 5.0, einschlie√ülich aller Header-Dateien.  Wir werden die von llvm.org bereitgestellten Pakete verwenden, da die in den Ubuntu-Repositorys <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">problematisch sind</a> . <br><br><pre><code class="plaintext hljs">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add - cat &lt;&lt;EOF | sudo tee -a /etc/apt/sources.list deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial main deb-src http://apt.llvm.org/xenial/ llvm-toolchain-xenial main deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial-5.0 main deb-src http://apt.llvm.org/xenial/ llvm-toolchain-xenial-5.0 main EOF sudo apt update sudo apt install clang-5.0 libclang-5.0-dev llvm-5.0 llvm-5.0-dev</code> </pre> <br>  Weiter: <br><br><pre> <code class="plaintext hljs">sudo apt install bison cmake flex g++ git libelf-dev zlib1g-dev libfl-dev</code> </pre> <br>  Und schlie√ülich installieren Sie libbfcc-dev vom Upstream, nicht vom Ubuntu-Repository.  Das Paket in Ubuntu enth√§lt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">keine Header-Dateien</a> .  Und dieses Problem wurde auch um 18.10 Uhr nicht gel√∂st. <br><br><pre> <code class="plaintext hljs">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD echo "deb https://repo.iovisor.org/apt/$(lsb_release -cs) $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/iovisor.list sudo apt update sudo apt install bcc-tools libbcc-examples linux-headers-$(uname -r)</code> </pre> <br>  <b>Bpftrace Hauptinstallation</b> <br><br>  Es ist Zeit, bpftrace selbst von der Quelle zu installieren!  Lassen Sie es uns klonen, zusammenbauen und in / usr / local installieren: <br><br><pre> <code class="plaintext hljs">git clone https://github.com/iovisor/bpftrace cd bpftrace mkdir build &amp;&amp; cd build cmake -DCMAKE_BUILD_TYPE=DEBUG .. make -j4 sudo make install</code> </pre> <br>  Und du bist fertig!  Die ausf√ºhrbare Datei wird in / usr / local / bin / bpftrace installiert.  Sie k√∂nnen das Ziel mit dem Argument cmake √§ndern, das standardm√§√üig folgenderma√üen aussieht: <br><br><pre> <code class="plaintext hljs">DCMAKE_INSTALL_PREFIX=/usr/local.</code> </pre> <br>  <b>Einzeilige Beispiele</b> <br><br>  Lassen Sie uns ein paar bpftrace-Single-Liner ausf√ºhren, um unsere F√§higkeiten zu verstehen.  Ich habe diese aus <a href="">Brendan Greggs F√ºhrer genommen</a> , der eine detaillierte Beschreibung von jedem von ihnen enth√§lt. <br><br>  # 1. Zeigen Sie eine Liste der Sensoren an <br><br><pre> <code class="plaintext hljs">bpftrace -l 'tracepoint:syscalls:sys_enter_*'</code> </pre> <br>  # 2. Gr√º√üe <br><br><pre> <code class="plaintext hljs">bpftrace -e 'BEGIN { printf("hello world\n"); }'</code> </pre> <br>  # 3. Eine Datei √∂ffnen <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:syscalls:sys_enter_open { printf("%s %s\n", comm, str(args-&gt;filename)); }'</code> </pre> <br>  # 4. Die Anzahl der Systemaufrufe pro Prozess <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }'</code> </pre> <br>  # 5. Verteilung der read () -Aufrufe nach Anzahl der Bytes <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:syscalls:sys_exit_read /pid == 18644/ { @bytes = hist(args-&gt;retval); }'</code> </pre> <br>  # 6. Dynamische Verfolgung von read () - Inhalten <br><br><pre> <code class="plaintext hljs">bpftrace -e 'kretprobe:vfs_read { @bytes = lhist(retval, 0, 2000, 200); }'</code> </pre> <br>  # 7. Zeitaufwand f√ºr read () -Aufrufe <br><br><pre> <code class="plaintext hljs">bpftrace -e 'kprobe:vfs_read { @start[tid] = nsecs; } kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); }'</code> </pre> <br>  # 8. Ereignisse auf Prozessebene z√§hlen <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:sched:sched* { @[name] = count(); } interval:s:5 { exit(); }'</code> </pre> <br>  # 9. Profiling Kernel Working Stacks <br><br><pre> <code class="plaintext hljs">bpftrace -e 'profile:hz:99 { @[stack] = count(); }'</code> </pre> <br>  # 10. Trace-Planer <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:sched:sched_switch { @[stack] = count(); }'</code> </pre> <br>  # 11. Trace Blocking I / O. <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:block:block_rq_complete { @ = hist(args-&gt;nr_sector * 512); }'</code> </pre> <br>  Besuchen Sie die Website von Brendan Gregg, um herauszufinden, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">welche Art von Output die oben genannten Teams generieren k√∂nnen</a> . <br><br>  <b>Beispiel f√ºr Skriptsyntax und E / A-Timing</b> <br><br>  Die Zeichenfolge, die √ºber den Schalter '-e' √ºbergeben wird, ist der Inhalt des bpftrace-Skripts.  Die Syntax ist in diesem Fall bedingt eine Reihe von Konstruktionen: <br><br><pre> <code class="plaintext hljs">&lt;event source&gt; /&lt;optional filter&gt;/ { &lt;program body&gt; }</code> </pre> <br>  Schauen wir uns das siebte Beispiel √ºber die Zeitabl√§ufe von Dateisystem-Lesevorg√§ngen an: <br><br><pre> <code class="plaintext hljs">kprobe:vfs_read { @start[tid] = nsecs; } &lt;- 1 -&gt;&lt;-- 2 -&gt; &lt;---------- 3 ---------&gt;</code> </pre> <br>  Wir verfolgen das Ereignis vom <i>kprobe-</i> Mechanismus, d. H. Wir verfolgen den Beginn der Kernelfunktion. <br>  Die Kernelfunktion f√ºr die Ablaufverfolgung lautet <i>vfs_read</i> . Diese Funktion wird aufgerufen, wenn der Kernel eine Leseoperation aus dem Dateisystem ausf√ºhrt (VFS aus ‚ÄûVirtual FileSystem‚Äú, Abstraktion des Dateisystems im Kernel). <br><br>  Wenn die <i>Ausf√ºhrung von vfs_read</i> beginnt (d. H. Bevor die Funktion n√ºtzliche Arbeit geleistet hat), wird das Programm bpftrace gestartet.  Es speichert den aktuellen Zeitstempel (in Nanosekunden) in einem globalen assoziativen Array namens <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">st</a> art</i> .  Der Schl√ºssel ist <i>tid</i> , ein Verweis auf die aktuelle Thread-ID. <br><br><pre> <code class="plaintext hljs">kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); } &lt;-- 1 --&gt; &lt;-- 2 -&gt; &lt;---- 3 ----&gt; &lt;----------------------------- 4 -----------------------------&gt;</code> </pre> <br>  1. Wir verfolgen das Ereignis vom <i>kretprobe-</i> Mechanismus, der <i>kprobe</i> √§hnlich <i>ist</i> , au√üer dass es aufgerufen wird, wenn die Funktion das Ergebnis ihrer Ausf√ºhrung zur√ºckgibt. <br><br>  2. Die Kernelfunktion f√ºr die Ablaufverfolgung lautet <i>vfs_read</i> . <br><br>  3. Dies ist ein optionaler Filter.  Es wird gepr√ºft, ob die Startzeit zuvor aufgezeichnet wurde.  Ohne diesen Filter kann das Programm beim Lesen gestartet werden und nur das Ende abfangen, was zu einer <i>gesch√§tzten</i> Zeit von <i>nsecs - 0</i> anstelle von <i>nsecs - start f√ºhrt</i> . <br><br>  4. Der Hauptteil des Programms. <br><br>  <i>nsecs - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">st</a> art [tid]</i> berechnet, wie viel Zeit seit dem Start der Funktion vfs_read vergangen ist. <br>  <i>@ns [comm] = hist (...)</i> f√ºgt die angegebenen Daten dem in <i>@ns</i> gespeicherten zweidimensionalen Histogramm <i>hinzu</i> .  Der <i>Kommunikationsschl√ºssel</i> bezieht sich auf den Namen der aktuellen Anwendung.  Wir werden also Befehl f√ºr Befehl ein Histogramm haben. <br><br>  <i>delete (...)</i> l√∂scht die Startzeit aus dem assoziativen Array, da wir sie nicht mehr ben√∂tigen. <br><br>  Dies ist die endg√ºltige Schlussfolgerung.  Bitte beachten Sie, dass alle Histogramme automatisch angezeigt werden.  Eine explizite Verwendung des Druckhistogrammbefehls ist nicht erforderlich.  <i>@ns</i> ist keine spezielle Variable, daher wird das Histogramm deswegen nicht angezeigt. <br><br><pre> <code class="plaintext hljs">@ns[snmp-pass]: [0, 1] 0 | | [2, 4) 0 | | [4, 8) 0 | | [8, 16) 0 | | [16, 32) 0 | | [32, 64) 0 | | [64, 128) 0 | | [128, 256) 0 | | [256, 512) 27 |@@@@@@@@@ | [512, 1k) 125 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ | [1k, 2k) 22 |@@@@@@@ | [2k, 4k) 1 | | [4k, 8k) 10 |@@@ | [8k, 16k) 1 | | [16k, 32k) 3 |@ | [32k, 64k) 144 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@| [64k, 128k) 7 |@@ | [128k, 256k) 28 |@@@@@@@@@@ | [256k, 512k) 2 | | [512k, 1M) 3 |@ | [1M, 2M) 1 | |</code> </pre> <br><br>  <b>Beispiel f√ºr einen USDT-Sensor</b> <br><br>  Nehmen wir diesen C-Code und speichern ihn in der Datei <i>tracetest.c</i> : <br><br><pre> <code class="plaintext hljs">#include &lt;sys/sdt.h&gt; #include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; static long myclock() { struct timeval tv; gettimeofday(&amp;tv, NULL); DTRACE_PROBE1(tracetest, testprobe, tv.tv_sec); return tv.tv_sec; } int main(int argc, char **argv) { while (1) { myclock(); sleep(1); } return 0; }</code> </pre> <br>  Dieses Programm wird endlos ausgef√ºhrt, indem <i>myclock ()</i> einmal pro Sekunde <i>aufgerufen wird</i> .  <i>myclock ()</i> fragt die aktuelle Uhrzeit ab und gibt die Anzahl der Sekunden seit Beginn der √Ñra zur√ºck. <br><br>  Der Aufruf von <i>DTRACE_PROBE1</i> definiert hier einen statischen USDT- <i>Tracepunkt</i> . <br><br><ul><li>  Das Makro <i>DTRACE_PROBE1</i> stammt aus <i>sys / sdt.h.</i>  Das offizielle USDT-Makro, das dasselbe tut, hei√üt <i>STAP_PROBE1</i> (STAP von SystemTap, dem ersten in USDT unterst√ºtzten Linux-Mechanismus).  Da USDT jedoch mit DTrace-Benutzerbereichssensoren kompatibel ist, ist <i>DTRACE_PROBE1</i> nur eine Referenz auf <i>STAP_PROBE1</i> . </li><li>  Der erste Parameter ist der Name des Anbieters.  Ich glaube, dies ist ein √úberbleibsel von DTrace, da bpftrace nichts N√ºtzliches damit zu tun scheint.  Es gibt jedoch eine Nuance ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die ich beim Debuggen des Problems auf Anforderung 328 entdeckt habe</a> ): Der Anbietername muss mit dem Bin√§rdateinamen der Anwendung identisch sein, andernfalls kann bpftrace den Tracepunkt nicht finden. </li><li>  Der zweite Parameter ist der Name des Trace-Punkts. </li><li>  Alle zus√§tzlichen Parameter sind der von den Entwicklern bereitgestellte Kontext.  Die Nummer <i>1</i> in <i>DTRACE_PROBE1</i> bedeutet, dass wir einen zus√§tzlichen Parameter √ºbergeben m√∂chten. </li></ul><br>  Stellen wir sicher, dass sys / sdt.h f√ºr uns verf√ºgbar ist, und stellen Sie das Programm zusammen: <br><br><pre> <code class="plaintext hljs">sudo apt install systemtap-sdt-dev gcc tracetest.c -o tracetest -Wall -g</code> </pre> <br>  Wir weisen bpftrace an, die PID auszugeben und "time is [number]", wenn die <i>Testsonde</i> erreicht ist: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'usdt:/full-path-to/tracetest:testprobe { printf("%d: time is %d\n", pid, arg0); }'</code> </pre> <br>  Bpftrace funktioniert weiter, w√§hrend wir Strg-C dr√ºcken.  √ñffnen Sie daher ein neues Terminal und f√ºhren <i>Sie</i> dort den <i>Tracetest</i> aus: <br><br>  # Im neuen Terminal <br>  ./tracetest <br><br>  Gehen Sie zur√ºck zum ersten Terminal mit bpftrace, dort sollten Sie etwas sehen wie: <br><br><pre> <code class="plaintext hljs">Attaching 1 probe... 30909: time is 1549023215 30909: time is 1549023216 30909: time is 1549023217 ... ^C</code> </pre> <br>  <b>Beispiel f√ºr eine Speicherzuordnung mit glibc ptmalloc</b> <br><br>  Ich benutze bpftrace, um zu verstehen, warum Ruby so viel Speicher verwendet.  Und im Rahmen meiner Forschung muss ich verstehen, wie der Speicherzuweiser von glibc Speicherbereiche verwendet. <br><br>  Um die Multi-Core-Leistung zu optimieren, weist der glibc-Speicherzuweiser mehrere ‚ÄûBereiche‚Äú des Betriebssystems zu.  Wenn die Anwendung nach einer Speicherzuweisung fragt, w√§hlt der Zuweiser einen Bereich aus, der nicht verwendet wird, und markiert einen Teil dieses Bereichs als "verwendet".  Da Threads unterschiedliche Bereiche verwenden, wird die Anzahl der Sperren verringert, was zu einer verbesserten Multithread-Leistung f√ºhrt. <br><br>  Dieser Ansatz erzeugt jedoch viel M√ºll, und es scheint, dass ein derart hoher Speicherverbrauch in Ruby genau darauf zur√ºckzuf√ºhren ist.  Um die Natur dieses M√ºlls besser zu verstehen, fragte ich mich: Was bedeutet es, ‚Äûeinen Bereich auszuw√§hlen, der nicht genutzt wird‚Äú?  Dies kann Folgendes bedeuten: <br><br><ul><li>  Bei jedem Aufruf von <i>malloc ()</i> durchl√§uft der Allokator alle Bereiche und findet den Bereich, der derzeit nicht gesperrt ist.  Und nur wenn sie alle blockiert sind, wird er versuchen, eine neue zu erstellen. </li><li>  Wenn <i>malloc () zum</i> ersten Mal f√ºr einen bestimmten Thread aufgerufen wird (oder wenn der Thread gestartet wird), w√§hlt der Allokator den Thread aus, der derzeit nicht blockiert ist.  Und wenn sie alle blockiert sind, wird er versuchen, eine neue zu erstellen. </li><li>  Wenn <i>malloc () zum</i> ersten Mal f√ºr einen bestimmten Thread aufgerufen wird (oder wenn der Thread gestartet wird), versucht der Allokator, eine neue Region zu erstellen, unabh√§ngig davon, ob nicht gesperrte Regionen vorhanden sind.  Nur wenn kein neuer Bereich erstellt werden kann (z. B. wenn das Limit ersch√∂pft ist), wird der vorhandene Bereich wiederverwendet. </li><li>  Es gibt wahrscheinlich mehr Optionen, die ich nicht in Betracht gezogen habe. </li></ul><br>  In der Dokumentation gibt es keine spezifische Antwort. Mit dieser Funktion k√∂nnen Sie einen Bereich ausw√§hlen, der nicht verwendet wird.  Ich habe den Quellcode f√ºr glibc studiert, was darauf hindeutete, dass Option 3 dies tun k√∂nnte.  Ich wollte jedoch experimentell √ºberpr√ºfen, ob ich den Quellcode richtig interpretiert habe, ohne dass Code in glibc debuggt werden muss. <br><br>  Hier ist die Glibc-Speicherzuweisungsfunktion, die einen neuen Bereich erstellt.  Sie k√∂nnen es jedoch erst nach √úberpr√ºfung des Limits aufrufen. <br><br><pre> <code class="plaintext hljs">static mstate _int_new_arena(size_t size) { mstate arena; size = calculate_how_much_memory_to_ask_from_os(size); arena = do_some_stuff_to_allocate_memory_from_os(); LIBC_PROBE(memory_arena_new, 2, arena, size); do_more_stuff(); return arena; }</code> </pre> <br>  Kann ich <i>Uprobes verwenden</i> , um die Funktion <i>_int_new_arena</i> zu verfolgen?  Leider gibt es keine.  Aus irgendeinem Grund ist dieses Symbol in glibc Ubuntu 18.04 nicht verf√ºgbar.  Auch nach der Installation von Debugging-Symbolen. <br><br>  Gl√ºcklicherweise gibt es in dieser Funktion einen USDT-Sensor.  <i>LIBC_PROBE</i> ist ein <i>Makroalias</i> f√ºr <i>STAP_PROBE</i> . <br>  Der Anbietername lautet libc. <br>  Der Sensorname lautet memory_arena_new. <br>  Die Zahl 2 bedeutet, dass vom Entwickler zwei zus√§tzliche Argumente angegeben wurden. <br>  Arena ist die Adresse des Bereichs, der aus dem Betriebssystem extrahiert wurde, und Gr√∂√üe ist seine Gr√∂√üe. <br><br>  Bevor wir diesen Sensor verwenden k√∂nnen, m√ºssen wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problem 328 umgehen</a> .  Wir m√ºssen irgendwo mit dem Namen <i>libc</i> eine symbolische Verkn√ºpfung mit glibc erstellen, da bpftrace erwartet, dass der Bibliotheksname (der sonst <i>libc-2.27.so w√§re</i> ) mit dem Anbieternamen <i>(libc)</i> identisch ist. <br><br><pre> <code class="plaintext hljs">ln -s /lib/x86_64-linux-gnu/libc-2.27.so /tmp/libc</code> </pre> <br>  Jetzt weisen wir bpftrace an, sich an den USDT memory_arena_new-Sensor anzuschlie√üen, dessen Herstellername <i>libc</i> lautet: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'usdt:/tmp/libc:memory_arena_new { printf("PID %d: created new arena at %p, size %d\n", pid, arg0, arg1); }'</code> </pre> <br>  In einem anderen Terminal f√ºhren wir Ruby aus, wodurch drei Threads erstellt werden, die nichts bewirken und in einer Sekunde enden.  Aufgrund der globalen Blockierung des Interpreters sollte Ruby <i>malloc ()</i> nicht von verschiedenen Threads parallel aufgerufen werden. <br><br><pre> <code class="plaintext hljs">ruby -e '3.times { Thread.new { } }; sleep 1'</code> </pre> <br>  Wenn wir mit bpftrace zum Terminal zur√ºckkehren, werden wir sehen: <br><br><pre> <code class="plaintext hljs">Attaching 1 probe... PID 431: created new arena at 0x7f40e8000020, size 576 PID 431: created new arena at 0x7f40e0000020, size 576 PID 431: created new arena at 0x7f40e4000020, size 576</code> </pre> <br>  Hier ist die Antwort auf unsere Frage!  Jedes Mal, wenn Sie in Ruby einen neuen Thread erstellen, hebt glibc unabh√§ngig von der Wettbewerbsf√§higkeit einen neuen Bereich hervor. <br><br>  <b>Welche Tracepunkte sind verf√ºgbar?</b>  <b>Was soll ich verfolgen?</b> <br><br>  Sie k√∂nnen alle Hardware-, Timer-, kprobe- und statischen Kernel-Tracepunkte auflisten, indem Sie den folgenden Befehl ausf√ºhren: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -l</code> </pre> <br>  Sie k√∂nnen alle Uprobe-Trace-Punkte (Funktionszeichen) einer Anwendung oder Bibliothek auflisten, indem Sie Folgendes tun: <br><br><pre> <code class="plaintext hljs">nm /path-to-binary</code> </pre> <br>  Sie k√∂nnen alle Ablaufverfolgungspunkte der USDT-Anwendung oder -Bibliothek auflisten, indem Sie den folgenden Befehl ausf√ºhren: <br><br><pre> <code class="plaintext hljs">/usr/share/bcc/tools/tplist -l /path-to/binary</code> </pre> <br>  In Bezug auf die zu verwendenden Ablaufverfolgungspunkte: Es w√ºrde nicht schaden, den Quellcode dessen zu verstehen, was Sie verfolgen werden.  Ich empfehle Ihnen, den Quellcode zu studieren. <br><br>  <b>Tipp: Ein Strukturformat f√ºr Tracepunkte im Kernel</b> <br><br>  Hier ist ein hilfreicher Tipp zu Kernel-Trace-Punkten.  Sie k√∂nnen √ºberpr√ºfen, welche Argumentfelder verf√ºgbar sind, indem Sie die Datei / sys / kernel / debug / tracing / events lesen! <br><br>  Angenommen, Sie m√∂chten Anrufe an <i>madvise (..., MADV_DONTNEED) verfolgen</i> : <br><br><pre> <code class="plaintext hljs">sudo bpftrace -l | grep madvise</code> </pre> <br>  - wird uns mitteilen, dass wir tracepoint verwenden k√∂nnen: syscalls: sys_enter_madvise. <br><br><pre> <code class="plaintext hljs">sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_madvise/format</code> </pre> <br>  - gibt uns folgende Informationen: <br><br><pre> <code class="plaintext hljs">name: sys_enter_madvise ID: 569 format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:unsigned long start; offset:16; size:8; signed:0; field:size_t len_in; offset:24; size:8; signed:0; field:int behavior; offset:32; size:8; signed:0; print fmt: "start: 0x%08lx, len_in: 0x%08lx, behavior: 0x%08lx", ((unsigned long)(REC-&gt;start)), ((unsigned long)(REC-&gt;len_in)), ((unsigned long)(REC-&gt;behavior))</code> </pre> <br>  Madvise-Signatur gem√§√ü Handbuch: <i>(void * addr, size_t length, int Beratung)</i> .  Die letzten drei Felder dieser Struktur entsprechen diesen Parametern! <br><br>  Was bedeutet MADV_DONTNEED?  Nach grep MADV_DONTNEED / usr / include zu urteilen, entspricht dies 4: <br><br><pre> <code class="plaintext hljs">/usr/include/x86_64-linux-gnu/bits/mman-linux.h:80:# define MADV_DONTNEED 4 /* Don't need these pages. */</code> </pre> <br>  So wird unser bpftrace-Team: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'tracepoint:syscalls:sys_enter_madvise /args-&gt;behavior == 4/ { printf("madvise DONTNEED called\n"); }'</code> </pre> <br><h3>  Fazit </h3><br>  Bpftrace ist wunderbar!  Bpftrace ist die Zukunft! <br><br>  Wenn Sie mehr √ºber ihn erfahren m√∂chten, empfehle ich Ihnen, sich mit <a href="">seiner F√ºhrung</a> sowie dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Beitrag von 2019</a> auf Brendan Greggs Blog vertraut zu machen. <br><br>  Gutes Debuggen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441258/">https://habr.com/ru/post/de441258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441244/index.html">Mit der seit 19 Jahren unbekannten Sicherheitsl√ºcke in WinRar k√∂nnen Sie die entpackte Datei an einem beliebigen Ort ablegen</a></li>
<li><a href="../de441248/index.html">Russland belegte im globalen SSL-Rating den 9. Platz vor China, D√§nemark und der Schweiz</a></li>
<li><a href="../de441250/index.html">Schnellstart: Los + Apache Kafka + Redis</a></li>
<li><a href="../de441252/index.html">‚ÄûBlowjob-Artikel‚Äú: Wissenschaftler verarbeiteten 109 Stunden Oralsex, um eine KI zu entwickeln, die einen Schwanz lutscht</a></li>
<li><a href="../de441254/index.html">Seminar ‚ÄûWarum wir mit Kubernetes in Kontakt getreten sind und was wir davon haben‚Äú, 28. Februar, Moskau</a></li>
<li><a href="../de441260/index.html">Wie neuronale Netzwerkgrafiken geholfen haben</a></li>
<li><a href="../de441262/index.html">Einfache und lange Aufgaben beseitigen Kandidaten besser als kurze und komplexe</a></li>
<li><a href="../de441264/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 2</a></li>
<li><a href="../de441266/index.html">Wie das tiOPF-Framework f√ºr Delphi / Lazarus funktioniert. Besuchervorlage</a></li>
<li><a href="../de441268/index.html">Ceedling + Eclipse oder Unit-Tests f√ºr Mikrocontroller</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>