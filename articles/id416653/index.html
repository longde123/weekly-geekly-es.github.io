<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛕 🔌 🎤 Jenis perpustakaan 🧒 🍕 🌎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ambil susunan terbalik dan terapkan penyortiran dengan sisipan sederhana . 



 Lihat dengan derit apa elemen berikutnya dimasukkan di tempat yang tep...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jenis perpustakaan</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416653/"><div style="text-align:center;"><img width="700" height="394" src="https://habrastorage.org/webt/8i/bj/do/8ibjdoxetlxsby3qiaj5seokxxa.jpeg"></div><br><br><a name="habracut"></a><br>  Ambil susunan terbalik dan terapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyortiran dengan sisipan sederhana</a> . <br><br><img width="684" height="95" src="https://habrastorage.org/webt/il/qa/vz/ilqavzmmhgxwuhcityv7wuqqqig.gif"><br><br>  Lihat dengan derit apa elemen berikutnya dimasukkan di tempat yang tepat.  Untuk itu, Anda perlu membebaskan tempat penyisipan, karena itu Anda harus menggeser semua elemen yang dimasukkan sebelumnya. <br><br>  Dan betapa bagusnya jika ada ruang kosong antara elemen yang dimasukkan sebelumnya!  Maka seseorang tidak perlu menyeret barisan elemen hanya demi memasukkan satu. <br><br>  Pada tahun 2004, tiga ahli ilmu komputer - Michael Bender, Martin Farah-Colton dan Miguel Mostiro - memutuskan untuk memodifikasi penyortiran dengan sisipan sederhana dengan cara ini.  Mereka menyarankan untuk membentuk bagian terurut dari array, meninggalkan celah di antara elemen yang dimasukkan. <br><blockquote>  Pustakawan membutuhkan buku-buku yang disusun secara alfabetis di rak yang panjang: mulai dari kiri huruf "A", buku-buku itu berada tepat di sebelah satu sama lain hingga sangat "aku".  Jika perpustakaan menerima buku baru yang terkait dengan bagian "B", maka untuk meletakkannya di rak di tempat yang tepat, Anda harus memindahkan setiap buku, mulai dari tengah bagian "B" hingga "I" terakhir.  Ini disortir berdasarkan sisipan sederhana.  Namun, jika pustakawan menyediakan ruang kosong di setiap bagian, itu cukup baginya untuk memindahkan hanya beberapa buku untuk memberikan ruang bagi buku baru.  Ini adalah prinsip dasar pemilahan perpustakaan. </blockquote><h2>  Algoritma </h2><br><img width="693" height="168" src="https://habrastorage.org/webt/jl/-l/wc/jl-lwclcowy6aohvc82uksordtg.gif"><br><br><ul><li>  <strong>1. Buat array bantu kosong, beberapa kali lebih besar dari yang utama.</strong> </li><li>  <strong>2. Untuk elemen selanjutnya, kita mencari tempat penyisipan dalam array bantu.</strong> <ul><li>  <strong>2.1.</strong>  <strong>Jika Anda menemukan tempat untuk disisipkan, maka transfer item dan kembali ke langkah 2.</strong> </li><li>  <strong>2.2.</strong>  <strong>Jika tidak ada tempat untuk penyisipan, seimbangkan kembali array bantu dan kembali ke poin 2.</strong> </li></ul></li><li>  <strong>3. Setelah memproses semua elemen, transfer kembali ke array utama.</strong> </li></ul><br>  Sekilas, sepertinya penyortiran itu mudah dan sederhana.  Untuk menghilangkan ilusi ini, kami mempertimbangkan poin-poin kunci dari algoritma secara lebih rinci. <br><br><h2>  Ukuran Array Bantu </h2><br>  Meskipun tidak ada pendapat yang ditetapkan, berapa kali array bantu harus lebih besar dari yang utama. <br><br>  Jika Anda mengambil terlalu banyak, maka akan ada banyak ruang di antara elemen, namun, pencarian untuk situs penyisipan dan penyeimbangan kembali akan lebih lambat, karena jarak yang besar antara elemen.  Penyeimbangan ulang akan terjadi lebih jarang, tetapi mereka harus menghabiskan lebih banyak sumber daya untuk mereka.  Jika Anda mengambil terlalu sedikit, maka pencarian dan penyeimbangan kembali akan lebih murah, tetapi Anda harus memformat ulang array lebih sering.  Secara umum, masih perlu diuji dengan nilai yang berbeda dan metode poking ilmiah menentukan pilihan terbaik. <br><br>  Jika kami memutuskan berapa kali array bantu lebih besar dari yang utama, maka rumus untuk menentukan jumlah pasti elemen untuk tampilannya seperti ini: <br><br>  <b>NewSize = ε × (Ukuran + 1) - 1</b> <br><br>  <i>NewSize - jumlah elemen dalam array bantu</i> <i><br></i>  <i>ε - berapa kali array bantu lebih besar dari yang utama</i> <i><br></i>  <i>Ukuran - jumlah elemen dalam array utama</i> <br><br>  Jika kita cukup mengalikan ukuran dengan faktor: <b>NewSize = Ukuran × ε</b> , maka untuk distribusi yang seragam kita tidak akan memiliki cukup sel dalam jumlah <b>ε - 1</b> buah.  Artinya, dimungkinkan untuk mengaturnya secara merata, tetapi sel yang terisi pertama atau yang terakhir akan terletak dekat dengan tepi susunan bantu.  Dan kita perlu tempat-tempat kosong di sel yang diisi untuk dicadangkan dari semua sisi - termasuk sebelum elemen pertama dan setelah yang terakhir. <br><br><img width="692" height="312" src="https://habrastorage.org/webt/am/np/py/amnppyndj34-6az2hiyjakiakbk.png"><br><br>  Tampaknya menjadi hal yang sepele, tetapi sebenarnya penting untuk menyeimbangkan kembali, untuk menjamin tempat bebas untuk penyisipan di mana saja, termasuk saat memproses elemen terakhir dari array utama. <br><br><h2>  Cari tempat penyisipan dalam array bantu </h2><br>  Tentu saja, di sini Anda memerlukan pencarian biner.  Namun, implementasi klasik tidak akan bekerja untuk kita. <br><br>  Pertama, array bantu sebagian besar terdiri dari void.  Oleh karena itu, secara mendikotomikan struktur, kita akan sebagian besar menemukan sel yang tidak terisi.  Dalam kasus ini, Anda perlu sedikit ke kiri atau kanan, ke sel non-kosong terdekat.  Kemudian pada akhir segmen akan ada elemen signifikan yang memungkinkan Anda untuk menghitung rata-rata aritmatika dan melanjutkan pencarian biner secara mendalam. <br><br>  Kedua, jangan lupa tentang tepinya.  Jika Anda perlu memasukkan elemen minimum atau maksimum, maka pencarian biner di antara yang dimasukkan sebelumnya tidak akan menghasilkan apa-apa.  Oleh karena itu, ada baiknya mempertimbangkan kasus batas - pertama periksa apakah perlu untuk menempatkan elemen di dekat batas kiri atau kanan array dan jika tidak, maka gunakan pencarian biner. <br><br>  Ketiga, dengan mempertimbangkan spesifik aplikasi, ada baiknya membuat amandemen tambahan untuk meminimalkan jumlah penyeimbangan array.  Jika elemen yang dimasukkan sama dengan nilai di salah satu ujung segmen, maka mungkin Anda tidak harus memasukkannya di tengah segmen.  Lebih logis untuk menempatkan di sebelah elemen yang nilainya setara dengannya.  Ini akan lebih efisien mengisi ruang kosong dari array bantu. <br><br>  Keempat, kelima, dan seterusnya.  Kualitas pencarian untuk lokasi penyisipan secara langsung mempengaruhi kecepatan penyortiran, karena pemilihan lokasi penyisipan yang gagal menyebabkan penyeimbangan kembali yang tidak perlu.  Misalnya, mungkin ada baiknya membagi segmen tidak tepat di tengah, tetapi lebih dekat ke tepi kiri atau kanan segmen, tergantung pada tepi mana elemen penyisipan lebih dekat nilainya? <br><br>  Algoritma pencarian biner itu sendiri penuh dengan jebakan, dan dengan mempertimbangkan nuansa tambahan yang disebutkan di atas, akhirnya menjadi tugas yang tidak sepele. <br><br><h2>  Array penyeimbangan ulang </h2><br>  Pencarian biner bukan hal tersulit untuk diterapkan dalam penyortiran ini.  Masih ada penyeimbangan kembali. <br><br>  Ketika tidak ada tempat untuk penyisipan (elemen serupa ditemukan, tetapi tidak ada sel bebas di antara mereka), Anda perlu mengguncang susunan bantu sehingga tempat penyisipan dibebaskan.  Guncangan array ini menyeimbangkan kembali. <br><br>  Selain itu, penyeimbangan kembali bersifat <i>lokal</i> atau <i>lengkap</i> . <br><br><h3>  Penyeimbangan ulang lokal </h3><br>  Kami menggeser elemen sebanyak yang diperlukan untuk membebaskan titik penyisipan.  Penerapan penyeimbangan seperti ini sangat sederhana, Anda hanya perlu mengetahui sel kosong terdekat dari titik penyisipan dan menggunakannya untuk memindahkan beberapa elemen. <br><br>  Mungkin ada nuansa.  Misalnya, ke mana mencari tempat kosong terdekat?  Untuk menghindari situasi ketika pergeseran tidak mungkin (yaitu, jika di beberapa sisi semua sel ditempati ke tepi array), Anda dapat fokus pada posisi titik penyisipan relatif ke tengah array.  Jika Anda perlu menyisipkan di sisi kiri array, maka bergeser ke kanan, jika di kanan - ke kiri.  Jika <b>ε</b> ≥ 2, maka pendekatan ini menghilangkan situasi di mana pergeseran tidak mungkin (karena dalam setengah dari array bantu ada lebih dari cukup ruang untuk semua elemen). <br><br>  Dalam interpretasi penulis tentang algoritma, penyeimbangan lokal tersirat. <br><br><h3>  Menyeimbangkan lengkap </h3><br>  Alternatif yang menarik untuk lokal adalah penyeimbangan kembali total.  Artinya, dalam array bantu, geser semua elemen yang tersedia sehingga ada (hampir) ruang yang sama di antara mereka. <br><br><img width="693" height="168" src="https://habrastorage.org/webt/xg/yi/nr/xgyinrhnartyvwhdgqvmucrmx7m.gif"><br><br>  Saya mencoba kedua opsi dan sejauh ini saya mengamati bahwa dengan penyeimbangan lokal algoritma bekerja 1,5-2 kali lebih cepat daripada yang penuh.  Namun, penyeimbangan ulang lengkap masih bisa digunakan.  Sebagai contoh, jika Anda harus melakukan penyeimbangan lokal terlalu sering, maka ini berarti bahwa dalam susunan di beberapa daerah banyak "gumpalan darah" telah menumpuk yang menghambat seluruh proses.  Penyeimbangan ulang lengkap dilakukan sekali, memungkinkan Anda untuk menyingkirkan semua kemacetan lokal dalam satu gerakan. <br><br>  Mari kita cari tahu cara menyeimbangkan kembali sepenuhnya. <br><br>  Pertama, Anda perlu menghitung berapa banyak sel maksimum yang dapat kami alokasikan untuk setiap elemen dalam array bantu.  Harus diingat bahwa sel-sel kosong harus ada sebelum sel pertama dan setelah sel terisi terakhir.  Rumusnya adalah: <br><br><img width="186" height="52" src="https://habrastorage.org/webt/9n/he/da/9nhedamesorkojp6daccahjow2q.png"><br><br>  <i>M - jumlah sel yang dapat dialokasikan untuk setiap elemen</i> <i><br></i>  <i>NewSize - ukuran array bantu</i> <i><br></i>  <i>Hitung - jumlah elemen non-kosong saat ini dalam array bantu</i> <br><br>  Fraksi ini harus dikurangi menjadi nilai integer (yaitu, dibulatkan ke bawah).  Jelas dari rumus bahwa semakin banyak elemen yang telah ditransfer ke array bantu, semakin sedikit sel yang dapat kita pilih untuk lingkungan masing-masing elemen. <br><br>  Mengetahui <b>M</b> , kita dengan mudah mendapatkan posisi yang tepat untuk setiap elemen yang tidak kosong dalam array bantu di mana ia harus ditempatkan setelah penyeimbangan ulang selesai. <br><br>  <b>NewPos = Nomor × M</b> <br><br>  <i>NewPos - posisi item baru setelah penyeimbangan ulang</i> <i><br></i>  <i>Nomor - apa elemen non-kosong dalam array bantu <nobr>(1 ≤ Jumlah ≤ Jumlah)</nobr></i> <i><br></i>  <i>M - jumlah sel yang dialokasikan untuk setiap elemen</i> <br><br>  Posisi-posisi baru diketahui, dapatkah Anda memilah elemen-elemen yang tidak kosong dalam susunan bantu dan memindahkannya ke tempat lain?  Oh tidak, jangan buru-buru.  Tidak hanya diperlukan untuk mentransfer elemen, penting untuk menjaga ketertiban mereka.  Dan sebagai hasil pencarian dan penyisipan biner, elemen dapat berubah menjadi jauh ke kiri dan ke kanan posisi di mana mereka seharusnya setelah menyeimbangkan kembali.  Dan di tempat di mana Anda ingin pindah, mungkin ada elemen lain yang juga perlu dipasang di suatu tempat.  Selain itu, Anda tidak dapat mentransfer elemen jika ada elemen lain di antara posisi lama dan barunya di array bantu - jika tidak, elemen tersebut akan bercampur, dan sangat penting bagi kami untuk tidak mencampuradukkan pesanan. <br><br>  Oleh karena itu, untuk menyeimbangkan kembali itu tidak akan cukup untuk melalui siklus yang biasa dan hanya menggeser setiap elemen dari satu kantong ke yang lain.  Masih perlu untuk menggunakan rekursi.  Jika suatu elemen tidak dapat dipindahkan ke tempat baru (elemen lain muncul di antara posisi lama dan baru), maka pertama-tama Anda perlu mencari tahu (secara rekursif) tamu tak diundang ini.  Dan kemudian semuanya akan diatur dengan benar. <br><br><h2>  Kasus degenerasi </h2><br>  Untuk sebagian besar penyortiran berdasarkan sisipan, susunan urutan terbalik adalah situasi terburuk.  Dan menyortir seorang pustakawan, sayangnya, tidak terkecuali. <br><br><img width="693" height="168" src="https://habrastorage.org/webt/mm/zm/_c/mmzm_cvt2fvcawbrkkswtav0huo.gif"><br><br>  Elemen cenderung ke tepi kiri array bantu, akibatnya bintik-bintik kosong cepat habis.  Anda harus menyeimbangkan kembali array sangat sering. <br><br>  By the way, jika kita mengambil array yang hampir teratur (kasus terbaik untuk menyortir dengan menyisipkan sederhana), maka kita mendapatkan masalah yang sama.  Elemen yang baru tiba tidak akan menyumbat sisi kiri, tetapi sisi kanan susunan bantu, yang juga akan menyebabkan penyeimbangan kembali yang terlalu sering. <br><br>  Sortir perpustakaan menangani set data acak secara efisien.  Pemesanan sebagian (baik langsung maupun mundur) merusak kinerja kecepatan. <br><br><h2>  Kompleksitas Algoritma </h2><br>  Pada set besar data acak, algoritma memberikan kompleksitas waktu O ( <b>n</b> log <b>n</b> ).  Tidak buruk sama sekali! <br><br>  Pada set data acak unik (atau sebagian besar unik) dengan pemilihan koefisien <strong>ε yang benar</strong> dan keberhasilan implementasi pencarian biner, jumlah penyeimbangan kembali dapat diminimalkan, atau bahkan dihindari.  Dapat dikatakan bahwa algoritma ini memiliki kompleksitas waktu O ( <b>n</b> ) terbaik. <br><br>  Persentase besar data yang berulang dalam nilai, serta kehadiran dalam susunan yang dipesan (dalam urutan langsung atau terbalik) menyebabkan seringnya penyeimbangan susunan bantu dan, sebagai akibatnya, degradasi kompleksitas waktu menjadi O <b>(n <sup>2</sup></b> ) dalam kasus yang paling merugikan. <br><br>  Yang minus dari algoritma, tentu saja, adalah bahwa array tambahan memerlukan O ( <b>n</b> ) memori tambahan. <br><br><h2>  Kemungkinan cara untuk meningkatkan </h2><br>  Meskipun algoritma itu sendiri adalah instruktif dan efisien pada data acak, dalam satu setengah dekade, beberapa menunjukkan minat di dalamnya. <br><br>  Jika Anda mencari di "perpustakaan semacam" permintaan, Anda akan menemukan artikel sepintas di Wikipedia bahasa Inggris, PDF penulis (yang sedikit dipahami) dan posting ulang jarang informasi ini.  Plus ada visualisasi yang baik di YouTube, di mana array utama dan tambahan awalnya digabungkan.  Semua tautan ada di akhir artikel. <br><br>  Mencari "pemilahan perpustakaan" bahkan lebih menyenangkan - dalam sampel Anda akan menemukan berbagai pemilahan yang termasuk dalam perpustakaan yang berbeda, namun, algoritma ini tidak akan terkait dengan <i>pemilahan perpustakaan yang asli</i> . <br><br>  Dan ada sesuatu untuk diperbaiki: <br><br><ol><li>  Seleksi empiris dari koefisien optimal <strong>ε</strong> . </li><li>  Modifikasi (dengan mempertimbangkan spesifikasi algoritma umum) dari pencarian biner untuk penentuan titik penyisipan yang paling efisien. </li><li>  Meminimalkan biaya penyeimbangan kembali. </li></ol><br>  Jika Anda memoles tempat-tempat ini, maka mungkin perpustakaan mengurutkan dalam kecepatan bahkan sama dengan mengurutkan cepat? <br><br><h2>  Kode sumber </h2><br>  Saya tidak berhasil mempersiapkan implementasi dengan Python, ada versi yang berfungsi di PHP. <br><br><div class="spoiler">  <b class="spoiler_title">Algoritma dasar</b> <div class="spoiler_text"><pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LibrarySort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($arr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> $arr_new;<span class="hljs-comment"><span class="hljs-comment">//  $e = 3;//     $rebalance_local = true;// (true)   (false)  //   $newSize = $e * (count($arr) + 1) - 1; $arr_new = array_fill(0, $newSize, null); //       $arr_new[LibrarySort_Pos(1, 1, $newSize)] = $arr[0]; //    -    //     $start = 0; $finish = $newSize - 1; $i = 1; //      while($i &lt; count($arr)) { //        $pos = LibrarySort_BinarySearch($arr[$i], $start, $finish, $newSize); if($pos === false) {//        //    LibrarySort_Rebalance_Total($i, $newSize); } else {//  ,   ,    if($arr_new[$pos] !== null) {//   if($rebalance_local) {//  (+ ) LibrarySort_Rebalance_Local($arr[$i++], $pos, $newSize); } else {//  LibrarySort_Rebalance_Total($i, $newSize); } } else {//   ,   $arr_new[$pos] = $arr[$i++]; } } } //      $pos = 0; for($i = 0; $i &lt;= $newSize - 1; $i++) { if($arr_new[$i] !== null) $arr[$pos++] = $arr_new[$i]; } return $arr; }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Posisi baru elemen dalam array tambahan setelah penyeimbangan lengkap</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// $number-    $count //     //$number -      ( )  //$count -       //$newSize -     //$number &lt;= $count &lt;= count($arr) &lt;= $newSize) function LibrarySort_Pos($number, $count, $newSize) { return $number * floor(($newSize + 1) / ($count + 1)) - 1; }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Pencarian biner tempat penyisipan dalam array tambahan</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//       //$search -     ,      //($start, $finish) -   ,     //$newSize -     function LibrarySort_BinarySearch($search, $start, $finish, $newSize) { global $arr_new;//  //      //      ,     //  ,       while($arr_new[$start] === null &amp;&amp; $start &lt; $newSize - 1) { ++$start; } //         , //         if($search == $arr_new[$start]) { return LibrarySort_PosNearby($start, $newSize); //  ,        } elseif($search &lt; $arr_new[$start]) { //      //     if($start &gt; 0) {// $start    $finish = $start; $start = 0; return floor(($start + $finish) / 2); } else {//$start == 0,      return $start;//    ,    } } //      ,     //  ,       while($arr_new[$finish] === null &amp;&amp; $finish &gt; 0) { --$finish; } //         , //         if($search == $arr_new[$finish]) { return LibrarySort_PosNearby($finish, $newSize); //  ,        } elseif($search &gt; $arr_new[$finish]) { //      //     if($finish &lt; $newSize - 1) {// $finish    $start = $finish; $finish = $newSize - 1; return ceil(($start + $finish) / 2); } else {//$finish == $newSize - 1,      return $finish;//    ,    } } //     , //,    -   //   ,       If($finish - $start &gt; 1) {//   ,    3  $middle = ceil(($start + $finish) / 2); //   $middle_Pos = 0; // ""     $offset = 0; //         //,    /,      while($middle - $offset &gt; $start &amp;&amp; $middle_Pos == 0){ if($arr_new[$middle - $offset] !== null) { $middle_Pos = $middle - $offset; } elseif($middle + $offset &lt; $finish &amp;&amp; $arr_new[$middle + $offset] !== null) { $middle_Pos = $middle + $offset; } ++$offset; } //    , ,     , //              If($middle_Pos) { if($arr_new[$middle_Pos] == $search) { return LibrarySort_PosNearby($middle_Pos, $newSize); } else { if($arr_new[$middle_Pos] &gt; $search) { $finish = $middle_Pos; } else {//$arr_new[$middle_Pos] &lt; $search $start = $middle_Pos; } return LibrarySort_BinarySearch($search, $start, $finish, $newSize); } } else {//$middle_Pos == 0 -   (   )     return $middle;//   - ,     } } else {//  ,       return floor(($start + $finish) / 2); } return false;//  ,       }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Jika selama pencarian elemen tersebut sama dengan salah satu ujung segmen</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,        //$start - ,        //$newSize -     function LibrarySort_PosNearby($start, $newSize) { global $arr_new;//  //       for($left = $start - 1; $left &gt;= 0; $left--) { if($arr_new[$left] === null) {//  return $left;//   } elseif($arr_new[$left] &lt;&gt; $arr_new[$start]) {//     break; //   ,      } } //     ,    for($right = $start + 1; $right &lt;= $newSize - 1; $right++) { if($arr_new[$right] === null) {//  return $right; //   } elseif($arr_new[$right] &lt;&gt; $arr_new[$start]) {//     break; //   ,      } } return $start; //          .      ,     }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Penyeimbangan ulang lokal dari array tambahan</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    //$insert - ,    //$pos -            //$newSize -     function LibrarySort_Rebalance_Local($insert, $pos, $newSize) { global $arr_new;//  // $pos  $insert,       while($pos - 1 &gt;= 0 &amp;&amp; $arr_new[$pos - 1] !== null &amp;&amp; $arr_new[$pos - 1] &gt; $insert) {--$pos;} while($pos + 1 &lt;= $newSize - 1 &amp;&amp; $arr_new[$pos + 1] !== null &amp;&amp; $arr_new[$pos + 1] &lt; $insert) {++$pos;} $middle = (integer) $newSize / 2;//  if($pos &lt;= $middle) {//      if($arr_new[$pos] !== null &amp;&amp; $arr_new[$pos] &lt; $insert) ++$pos; //  $right = $pos; while($arr_new[++$right] !== null) {} for($i = $right; $i &gt; $pos; $i--) { $arr_new[$i] = $arr_new[$i - 1]; } } else {//      if($arr_new[$pos] !== null &amp;&amp; $insert &lt; $arr_new[$pos]) --$pos; //  $left = $pos; while($arr_new[--$left] !== null) {} for($i = $left; $i &lt; $pos; $i++) { $arr_new[$i] = $arr_new[$i + 1]; } } $arr_new[$pos] = $insert; }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Menyetel ulang penuh array tambahan</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    //$count -        //$newSize -     function LibrarySort_Rebalance_Total($count, $newSize) { global $arr_new;//  global $library_Number;//     global $library_LeftPos;//        $library_Number = $count; //        $library_LeftPos = $newSize - 1;// ,     //         $i = $newSize - 1; while($i &gt;= 0) { if($arr_new[$i] !== null) {//   $pos = LibrarySort_Pos($library_Number, $count, $newSize);//   newSize=$newSize"); if($i == $pos) {//      --$i;//      } elseif($i &lt; $pos) {//    $arr_new[$pos] = $arr_new[$i]; $arr_new[$i] = null; --$i;//      } else {//$i &gt; $pos -     //      LibrarySort_RemoveLeft($i, $pos, $count, $newSize); $i = ($i &gt; $library_LeftPos) ? $library_LeftPos - 1 : --$i; } --$library_Number;//      } else {// ,   --$i;//      } } }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Gerakan elemen ke kiri dengan penyeimbangan penuh</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//     . //    ,   //$i -     ,    //$pos -       //$count -        //$newSize -     function LibrarySort_RemoveLeft($i, $pos, $count, $newSize) { global $arr_new;//  global $library_Number;//     global $library_LeftPos;//        $left = false; $left_Pos = false;//      $j = $i;//      //     while($j &gt; 0 &amp;&amp; $left === false) {//            --$j; //     if($arr_new[$j] !== null) $left = $j;//    } if($left === false || $left &lt; $pos) {//   (  )    //     } else { //$left &gt;= $pos,     --$library_Number;//,       $left_Pos = LibrarySort_Pos($library_Number, $count, $newSize);//     //        LibrarySort_RemoveLeft($left, $left_Pos, $count, $newSize); //  ,     } //    ,   $arr_new[$pos] = $arr_new[$i]; $arr_new[$i] = null; //,         if($pos &lt; $library_LeftPos) $library_LeftPos = $pos; }</span></span></code> </pre> </div></div><br>  Saya harus kode dari awal sendiri, berdasarkan pada deskripsi umum dari metode ini.  Saya tidak melihat kecepatan mendekati penyortiran cepat, opsi penyortiran perpustakaan saya menyortir 10-20 kali lebih lambat daripada penyortiran cepat.  Tetapi alasannya, tentu saja, adalah karena implementasi saya terlalu kasar, banyak yang belum diperhitungkan. <br><br>  Saya ingin melihat versi dari pencipta algoritme.  Saya akan menulis hari ini kepada penulis (dan melemparkan mereka tautan ke habrastatu ini), mereka tiba-tiba akan menjawab.  Meskipun ... saya ingat, saya mencoba menghubungi Allen Beachich ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sorting ABC</a> ) dan Jason Morrison ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sorting J</a> ), tetapi hasilnya sama seperti jika saya menulis di Sportloto. <br><br>  <b>UPD</b>  <b>Martin Farah-Colton menjawab saya bahwa mereka tidak pernah melakukan implementasi:</b> <blockquote>  Saya khawatir kami tidak pernah mengimplementasikan algoritma itu. </blockquote>  <b>Yang utama adalah Ide :)</b> <br><br><h2>  Karakteristik Algoritma </h2><div class="scrollable-table"><table><tbody><tr><th align="left">  Judul </th><td align="left" colspan="2">  Jenis perpustakaan, Jenis perpustakaan </td></tr><tr><th align="left">  Nama lain </th><td align="left" colspan="2">  Jenis Penyisipan yang Dipetakan </td></tr><tr><th align="left">  Penulis </th><td align="left" colspan="2">  Michael A. Bender, Martín Farach-Colton, Miguel Mosteiro </td></tr><tr><th align="left">  Tahun </th><td align="left" colspan="2">  2004 </td></tr><tr><th align="left">  Kelas </th><td align="left" colspan="2">  Urutan Penyisipan </td></tr><tr><th align="left">  Perbandingan </th><td align="left" colspan="2">  Ada </td></tr><tr><th align="left" rowspan="3">  Kompleksitas waktu </th><th align="left">  yang terbaik </th><td align="left">  O ( <b>n</b> ) </td></tr><tr><th align="left">  rata-rata </th><td align="left">  O ( <b>n</b> log <b>n</b> ) </td></tr><tr><th align="left">  yang terburuk </th><td align="left">  O ( <b>n <sup>2</sup></b> ) </td></tr><tr><th align="left">  Kompleksitas memori ekstra </th><td align="left" colspan="2">  O ( <b>n</b> ) </td></tr></tbody></table></div><br><h2>  Referensi </h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Jenis perpustakaan</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><img width="30" height="30" src="https://habrastorage.org/webt/sb/ln/dw/sblndwenhewoyoas_n3xp7tyuuu.png"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Visualisasi semacam algoritma perpustakaan</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><img width="84" height="30" src="https://habrastorage.org/webt/yv/lm/2t/yvlm2t2kl5affkpm0hzqh7qw5ly.png"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Jenis penyisipan adalah O (n log n)</a> <br><br><h3>  Penulis algoritma: </h3><br><img align="right" width="392" height="120" src="https://habrastorage.org/webt/il/dh/l9/ildhl9tnc4alqaexulf-kw2rmt0.png"><br clear="left"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Michael A. Bender</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Martin Farah-Colton</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Miguel Mostiro</a> </p><br><br><h3>  Artikel Seri: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi Excel AlgoLab.xlsm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertukaran macam</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Urutan Penyisipan</a> <ul><li>  <b>Sortir Pustakawan</b> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sortir Solitaire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sortir "Menara Hanoi"</a> </li><li>  Penyortiran meja muda </li><li>  Balikkan Sortir </li><li>  Masukkan Sortir Perbandingan </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sortir berdasarkan pilihan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gabungkan Urusan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Urutkan berdasarkan distribusi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sortasi Hibrid</a> </li></ul><br><br><img align="right" width="364" height="192" src="https://habrastorage.org/webt/9y/1b/d5/9y1bd57yvcw4rt65o3ztjb59xum.png"><br clear="left"><p>  Sortir ditambahkan ke AlgoLab.  Jadi Anda bisa bereksperimen dengan set data kecil. <br><br>  Dalam hal ini, Anda dapat memutuskan berapa kali array bantu lebih besar dari yang utama.  Untuk memilih koefisien <strong>ε,</strong> Anda dapat mengklik kanan sel dengan “Sortasi perpustakaan” dan pilih “Ubah Catatan”.  Dan dalam catatan itu, hati-hati mengatur nilai integer untuk <b>e</b> dari 2 hingga 5. Jika Anda memasukkan sesuatu yang lain daripada angka-angka ini, nilai default = 2 akan digunakan. <br><br>  Anda juga dapat memilih jenis penyeimbangan kembali.  Jika Anda menetapkan lokal = 1, maka penyeimbangan kembali lokal akan digunakan.  Jika lokal = 0 - penuh. <br><br>  Dan jangan lupa untuk mengatur skala optimal untuk lembar proses sebelum memulai visualisasi, jika array tambahan tidak akan muat di layar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416653/">https://habr.com/ru/post/id416653/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416641/index.html">8 tahap proses pengembangan antarmuka aplikasi seluler</a></li>
<li><a href="../id416643/index.html">Menyebarkan Elasticsearch di AWS dengan Kubernetes dalam 10 Langkah</a></li>
<li><a href="../id416645/index.html">MIS. Pola penelitian</a></li>
<li><a href="../id416647/index.html">Apakah lembaga pemerintah memimpikan risiko listrik?</a></li>
<li><a href="../id416651/index.html">1M HTTP rps pada 1 cpu core. DPDK bukannya nginx + linux kernel TCP / IP</a></li>
<li><a href="../id416657/index.html">Dua pertiga kartu memori bekas berisi data pribadi pemilik sebelumnya</a></li>
<li><a href="../id416659/index.html">Karena apa volume pembayaran digital untuk ekonomi pertunjukan akan mencapai $ 1,2 triliun dolar</a></li>
<li><a href="../id416661/index.html">Tren apa yang harus dipertimbangkan oleh pengguna dan penyedia mobile banking</a></li>
<li><a href="../id416665/index.html">Menggunakan kembali Perpustakaan Android Pribadi dengan Sonatype Nexus Repository OSS</a></li>
<li><a href="../id416667/index.html">Isolasi debu dan kebisingan dari unit sistem lama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>