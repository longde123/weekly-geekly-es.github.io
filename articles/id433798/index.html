<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⬅️ 💺 🗣️ HomeKit dan ioBroker Mari berteman di rumah ⛹🏿 🗣️ 👩🏿‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tidak diragukan lagi, Apple iOS tetap menjadi salah satu OS seluler paling populer, yang berarti bahwa sistem otomasi modern harus dapat berintegrasi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>HomeKit dan ioBroker Mari berteman di rumah</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/iobroker/blog/433798/"><p><img src="https://habrastorage.org/webt/r6/5c/kp/r65ckpg2b-xatrgqefbyo7lflxa.png"></p><br><p>  Tidak diragukan lagi, Apple iOS tetap menjadi salah satu OS seluler paling populer, yang berarti bahwa sistem otomasi modern harus dapat berintegrasi ke dalam ekosistem ini dan menyediakan interoperabilitas.  Inilah yang dirancang untuk kerangka Homekit, yang memungkinkan Anda untuk bekerja dengan perangkat pintar dari layar iPhone / iPad / iWatch, dan yang terbaru, Mac (macOS Mojave). </p><br><p>  Sebagian besar sistem otomasi (saya tidak suka nama pemasaran "rumah pintar") telah lama menyertakan modul untuk diintegrasikan dengan Homekit, tetapi bahkan pengguna yang terlatih tidak dapat selalu mencari tahu bagaimana membuat perangkat mereka tersedia di aplikasi Rumah (atau Hawa). </p><br><p>  Hari ini saya akan memberi tahu Anda cara melakukan manipulasi ini dalam sistem ioBroker (ini adalah sistem otomasi terbuka dan gratis).  Tetapi agar tidak secara bodoh memberikan banyak contoh perangkat, saya ingin menjelaskan beberapa prinsip dan menunjukkan pendekatan, mengetahui yang mana, Anda dapat dengan mudah menerapkan contoh lain. </p><br><p>  <em>"Mengetahui beberapa prinsip dengan mudah mengimbangi ketidaktahuan tentang beberapa fakta."</em> <em><br></em>  <em>Claude Adrian Helvetius</em> </p><a name="habracut"></a><br><h3 id="iobroker-drayvery-ustroystva-i-sostoyaniya">  ioBroker.  Driver, Perangkat, dan Status </h3><br><p>  Pertama-tama, saya ingin menjelaskan apa itu perangkat dalam sistem ioBroker, dan bagaimana perangkat itu disajikan. </p><br><p>  Biarkan saya mengingatkan Anda bahwa sistem ioBroker adalah modular, dan modul ekstensi disebut driver (atau adaptor).  Driver adalah modul integrasi dengan beberapa perangkat atau grup perangkat, disatukan oleh fungsionalitas umum, protokol atau pabrikan, dan karenanya dapat "menyeret" satu atau beberapa perangkat ke dalam sistem ioBroker.  Fitur lain adalah kemampuan untuk membuat banyak instance dari driver yang sama, berbeda dalam pengaturan apa pun. </p><br><p>  Tetapi setiap perangkat unik dan tak dapat ditiru, memiliki karakteristik dan kemampuan yang berbeda.  Berdasarkan ini, ioBroker berfokus terutama bukan pada perangkat itu sendiri, tetapi pada karakteristiknya, yang diwakili oleh negara.  <strong>Status</strong> adalah objek ioBroker internal yang menerima dan menyimpan nilai.  Sinonim dari negara dapat dipertimbangkan: tanda, atribut, karakteristik, properti, peristiwa.  Contoh kondisi: "suhu", "level kecerahan", "level baterai", "power-on flag", "flag kesalahan", "flag yang menekan", "flag yang menekan dua kali", dll.  Dengan demikian, setiap perangkat diwakili oleh banyak negara yang berbeda. </p><br><p><img src="https://habrastorage.org/webt/oc/mn/q_/ocmnq_d-zdyhjj7bflfxaa3dxb8.png" alt="Struktur Objek" title="Struktur objek"></p><br><p>  Negara dapat dibagi menjadi yang informatif - mereka menampilkan informasi dari perangkat, dan yang bisa berubah - mereka dapat diubah oleh pengguna atau skrip dan mengirimkan perubahan ini ke perangkat.  Dengan demikian, ketika sesuatu berubah pada perangkat - data ini ditampilkan di negara-negara, dan ketika negara berubah dari ioBroker (oleh pengguna atau skrip) - perangkat menerima sinyal tentang perubahan dan harus merespons sesuai (itu tergantung pada perangkat itu sendiri dan driver dengan itu. bekerja). </p><br><p>  Semua status perangkat digabungkan menjadi satu pohon (registri) status.  Mereka dikelompokkan pertama berdasarkan perangkat (dalam beberapa kasus, penyaluran masih digunakan), dan kemudian oleh instans driver. </p><br><p>  Konsep topik protokol MQTT dengan mudah masuk ke pohon negara tersebut.  Dengan cara ini, Anda dapat menghubungkan peralatan tambahan atau sistem pihak ketiga yang mendukung protokol MQTT.  Cukup menginstal driver MQTT - cabang yang sesuai akan muncul di pohon negara. </p><br><p>  Dan ada semua jenis layanan online yang dapat memberikan informasi yang berguna dan / atau memungkinkan untuk mengendalikan peralatan lain (misalnya alarm mobil).  Hasil interaksi dengan layanan ini juga direpresentasikan sebagai seperangkat negara. </p><br><p><img src="https://habrastorage.org/webt/xi/qk/ay/xiqkay8bgotkcb7qjhouj5-zln4.png" alt="Pohon negara" title="Pohon negara"></p><br><p>  Secara total, perangkat di ioBroker diwakili oleh serangkaian status yang mencirikan perangkat dan memungkinkan untuk berinteraksi dengannya. </p><br><h3 id="homekit-aksessuary-servisy-i-harakteristiki">  Homekit  Aksesori, layanan, dan spesifikasi </h3><br><p>  Sekarang buka Homekit.  Di sini klasifikasi perangkat, fungsi dan karakteristiknya diterapkan. </p><br><p><img src="https://habrastorage.org/webt/xk/ch/8m/xkch8mdj6gv4zxw5g-kapazvuyy.png" alt="Kategori Perangkat Homekit" title="Kategori Perangkat Homekit"></p><br><p>  <strong>Aksesori</strong> setara dengan perangkat fisik.  Aksesori memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kategori</a> untuk menetapkannya ke grup tertentu. </p><br><p>  <strong>Layanan</strong> setara dengan fungsionalitas yang dimiliki aksesori.  Satu aksesori dapat memiliki beberapa layanan. </p><br><p>  Layanan menunjukkan kemampuan perangkat: lampu, baterai, tombol, sensor kualitas udara, pintu, pembersih udara, kamera .. </p><br><p>  Ini adalah layanan yang menentukan tampilan, perilaku perangkat, dan serangkaian karakteristik. </p><br><p>  <strong>Karakteristik</strong> adalah padanan dari atribut / properti yang menjadi ciri suatu layanan.  Ini adalah karakteristik yang menentukan apakah perangkat dihidupkan, tingkat kecerahan lampu, atau berapa kali tombol ditekan.  Satu layanan dapat memiliki banyak karakteristik. </p><br><p><img src="https://habrastorage.org/webt/2f/rl/io/2frliotkqesh2zanlhpfiaskmaq.png" alt="Struktur Objek" title="Struktur objek"></p><br><p>  Aplikasi yang bekerja dengan Homekit membaca layanan dan karakteristik aksesori, lalu menampilkan dan membiarkan Anda mengubah nilai karakteristik melalui antarmuka pengguna.  Nilai yang diubah dikirim ke perangkat Homekit untuk menerapkannya, dan dari perangkat Homekit, masing-masing, juga nilai karakteristik dikirim dengan beberapa perubahan dari sisi perangkat. </p><br><p>  Secara total, perangkat di HomeKit tampaknya menjadi aksesori dengan serangkaian layanan dan fitur. </p><br><h3 id="yahka-stykuem-koncepcii">  Yahka.  Kami bergabung dengan konsep </h3><br><p>  Untuk bekerja dengan Homekit, ioBroker menggunakan driver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yahka</a> (Anda harus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menginstal modul tambahan</a> sebelum menginstal) - add-on ke perpustakaan terkenal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/KhaosT/HAP-NodeJS</a> , yang juga membangun proyek HomeBridge yang populer.  Pustaka ini dirancang untuk membuat gateway / jembatan virtual yang menyediakan satu set perangkat virtual di HomeKit.  Mengkonfigurasi perangkat virtual dan layanan yang sesuai, mengatur nilai-nilai karakteristik, kita mendapatkan perangkat jadi di Homekit dan aplikasi Home, dan kita juga dapat meminta Siri untuk mengelolanya. </p><br><p>  Driver Yahka hanya dirancang untuk mengonfigurasi aksesori, menambahkan layanan kepadanya dan menunjukkan korespondensi karakteristik (HomeKit) dan status (ioBroker). </p><br><p>  Tetapi pertama-tama, setelah instalasi, Anda perlu mengkonfigurasi gateway dan memasukkannya ke aplikasi Home.  Setelah konfigurasi, semua perangkat yang ditambahkan ke gateway akan secara otomatis ditambahkan ke Home.  Untuk melakukan ini, tentukan "Nama Perangkat" (diinginkan untuk menentukan hanya huruf Latin) dan ingat kode pin (atau atur sendiri). </p><br><p><img src="https://habrastorage.org/webt/mj/b9/lf/mjb9lfsfvknvbjjmec9x0nexnns.png" alt="Pengaturan gerbang" title="Pengaturan gerbang"></p><br><div class="spoiler">  <b class="spoiler_title">Kami pergi ke aplikasi Home dan menambahkan aksesori baru.</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/5k/m1/hr/5km1hrkrxh6whzmb8dn5zcvqtm4.png"><br><img src="https://habrastorage.org/webt/fo/p-/oz/fop-oz-o99nnegmciq7drkxjdyu.png"></p></div></div><br><p>  Sekarang mari kita turun ke perangkat.  Semuanya akan baik-baik saja jika set negara untuk perangkat di ioBroker jelas terkait dengan set layanan dan fitur di HomeKit.  Dan akan lebih baik lagi jika nilai-nilai di negara-negara cocok untuk nilai-nilai karakteristik.  Tetapi sering kali tidak demikian, dan Anda harus menemukan cara yang tidak biasa untuk berlabuh.  Saya akan berbicara tentang beberapa di bawah ini, dan Anda harus menerapkan semua opsi lain sendiri, "dalam gambar dan rupa." </p><br><p>  Untuk kenyamanan, saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membuat dokumen</a> dengan terjemahan layanan dan jenis, serta kemungkinan nilai karakteristik.  Semua jenis dan layanan yang digunakan sesuai dengan <a href="">perpustakaan HAP-NodeJS</a> . </p><br><h3 id="datchik-temperatury">  Sensor suhu </h3><br>  Ini adalah contoh paling sederhana - yang harus Anda lakukan adalah memiliki satu negara yang berisi nilai numerik suhu.  Ini dapat diperoleh dari mana saja: dari sensor atau dari layanan Internet (cuaca). <br><p>  Anda perlu menambahkan perangkat dari kategori Sensor, dan menambahkan layanan TemperatureSensor ke perangkat, dan memberi nama untuk layanan ini.  Ada 5 karakteristik dalam layanan ini, yang terpenting bagi kami adalah CurrentTemperature. </p><br><p><img src="https://habrastorage.org/webt/xn/yr/k7/xnyrk7hwwcmtwhiy_kcbub-nlms.png" alt="Aksesori termometer" title="Aksesori termometer"></p><br><p><img src="https://habrastorage.org/webt/j4/bj/bn/j4bjbnuijam7qadtoq9r9eh16ns.png" alt="Layanan Sensor Suhu" title="Layanan Sensor Suhu"></p><br><p>  Cukup untuk menunjukkan nama negara yang sesuai dengan suhu dalam karakteristik CurrentTemperature. </p><br><p>  Tambahkan juga layanan kelembaban Sensor Kelembaban di sini, dan ikon aksesori terpisah akan dibuat di Homekit. </p><br><p><img src="https://habrastorage.org/webt/ag/na/90/agna90qhvaz84v3qutrvu4dltei.png" alt="Layanan Sensor Kelembaban" title="Layanan Sensor Kelembaban"></p><br><p>  Simpan, dan Anda selesai.  Sekarang Anda dapat beralih ke Siri, dan bertanya kepadanya tentang suhu dan kelembaban. </p><br><p><img src="https://habrastorage.org/webt/s4/cx/kg/s4cxkg72-7ycfuaentktjrhpdjy.png"></p><br><div class="spoiler">  <b class="spoiler_title">Percakapan dengan Siri</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ff/p9/tt/ffp9ttfpcj3_wcbt4ztgisnwxzi.png"><br><img src="https://habrastorage.org/webt/ax/7z/1i/ax7z1ioiynurem96c3gof_2gnha.png"></p></div></div><br><h3 id="batareyka">  Baterai </h3><br><p>  Layanan sederhana lainnya.  Triknya adalah ia dapat ditambahkan ke hampir semua aksesori.  Tambahkan layanan BatteryService dan tunjukkan dalam karakteristik BatteryLevel status yang berisi persentase pengisian daya baterai.  Setelah itu, data biaya akan muncul di data tambahan tentang perangkat. </p><br><p><img src="https://habrastorage.org/webt/pd/4p/ib/pd4pibwilwjymthk2g30ldqneey.png" alt="Layanan Baterai" title="Layanan baterai"></p><br><p>  Anda dapat segera mengatur tanda “muatan rendah” (karakteristik StatusLowBattery), jika nilai negara yang ditentukan sama dengan 1, ikon yang sesuai akan ditampilkan pada gambar perangkat. </p><br><p>  Tetapi bagaimana jika Anda tidak memiliki status seperti itu, tetapi ingin melihat ikon hemat daya?  Anda perlu membuat status ini secara manual atau menggunakan skrip, dan menunjukkan status yang dibuat dalam karakteristik. </p><br><p>  Sekarang tinggal menetapkan nilai yang benar dengan benar dalam kondisi ini.  Untuk melakukan ini, kita akan menggunakan skrip - itu akan menjadi kenyataan ketika baterai mencapai 30 persen. </p><br><pre><code class="javascript hljs">createState(<span class="hljs-string"><span class="hljs-string">""</span></span>); on({<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">"zigbee.0.00158d0001f41725.battery"</span></span>, <span class="hljs-attr"><span class="hljs-attr">change</span></span>: <span class="hljs-string"><span class="hljs-string">"ne"</span></span>}, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = obj.state.val; setState(<span class="hljs-string"><span class="hljs-string">"javascript.0."</span></span>, (value &lt;= <span class="hljs-number"><span class="hljs-number">30</span></span>)); });</code> </pre> <br><p>  Setelah dijalankan pertama kali, skrip akan membuat status, dan itu dapat dipilih dalam karakteristik. </p><br><p><img src="https://habrastorage.org/webt/tx/2z/6r/tx2z6r4deofbbram-k_muwaxut0.png"></p><br><p>  Tanda ini akan ditampilkan pada gambar aksesori </p><br><p><img src="https://habrastorage.org/webt/9o/nu/it/9onuitzmxs8exjofr7cfkwtwrqi.png"></p><br><div class="spoiler">  <b class="spoiler_title">dan detail perangkat</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/fx/jg/av/fxjgavhu-spu27lskbzkmvb_dh8.png"></p></div></div><br><h3 id="lampy">  Lampu </h3><br><p>  Bola lampu berbeda - terang, hangat, merah.  Ada 4 kasus: </p><br><ul><li>  Sederhana - dikendalikan oleh on dan off </li><li>  Dimmable - juga dikendalikan oleh tingkat kecerahan </li><li>  Dengan suhu - dimungkinkan untuk mengontrol suhu cahaya </li><li>  Warna - Anda dapat mengontrol warna cahaya </li></ul><br><p>  Untuk masing-masing kasus ini, ada karakteristik terkait dalam layanan Bola Lampu: </p><br><ul><li>  Nyala / mati </li><li>  Brightness - tingkat kecerahan </li><li>  Hue - teduh </li><li>  Kejenuhan - Kejenuhan </li><li>  ColorTemperature - suhu warna </li></ul><br><p>  Dalam kasus sederhana, dalam karakteristik "Aktif", kami menunjukkan status yang bertanggung jawab untuk menghidupkan dan mematikan. </p><br><p><img src="https://habrastorage.org/webt/7p/2j/l2/7p2jl2cqi7q8rbw98d_ytedxwke.png"></p><br><p>  Jika lampu ini dapat diredupkan, maka kami juga menunjukkan status dengan tingkat kecerahan. </p><br><p><img src="https://habrastorage.org/webt/b6/da/n1/b6dan1fjltcn8sry8doex2hl6ck.png"></p><br><p>  Selain menetapkan status yang benar, penting untuk mengamati interval nilai yang dapat diterima! </p><br><p>  Contoh: dalam beberapa kasus, negara yang bertanggung jawab atas kecerahan lampu dapat mengambil nilai dari 0 hingga 255, tetapi dalam Homekit nilai-nilai ini terbatas pada interval dari 0 hingga 100. Untuk kasus ini, Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi konversi</a> driver Yahka.  Fungsi "level255" hanya mengubah interval nilai 0..255 ke interval 0..100 (dan sebaliknya). </p><br><p>  Kesulitan berikut mungkin muncul jika lampu Anda berwarna, tetapi warna yang digunakan adalah RGB.  Ini dapat berupa tiga status berbeda, atau satu angka (atau string).  Dalam hal ini, Anda perlu mengkonversi dari satu ruang warna RGB ke ruang XYB lain (ruang ini digunakan oleh HomeKit), atau ke bidang XY. </p><br><p>  Untuk melakukan ini, Anda perlu membuat 2 status baru (Hue dan Saturation), di mana kami akan mengonversi nilai dari status RGB dan sebaliknya. </p><br><div class="spoiler">  <b class="spoiler_title">Script yang dihasilkan untuk warna adalah</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       createState("Hue"); createState("Sat"); //      RGB- on({id: "Hue", ack: false, change: 'any'}, function (obj) {  var hue = parseInt(obj.state.val);  var sat = parseInt(getState('Sat').val);  var res = hsvToRgb(hue, sat, 100);  setRGB(parseInt(res[0]), parseInt(res[1]), parseInt(res[2])); }); //    RGB- function setRGB(r, g, b){  var val = ('00'+r.toString(16)).slice(-2)+('00'+g.toString(16)).slice(-2)+('00'+b.toString(16)).slice(-2);  // RGB-   setState('zigbee.0.00124b0014d016ab.color', val, false); } //   HSV   RGB function hsvToRgb(h, s, v) {  var r, g, b;  var i;  var f, p, q, t;   h = Math.max(0, Math.min(360, h));  s = Math.max(0, Math.min(100, s));  v = Math.max(0, Math.min(100, v));  s /= 100;  v /= 100;   if(s == 0) {      r = g = b = v;      return [          Math.round(r * 255),          Math.round(g * 255),          Math.round(b * 255)      ];  }   h /= 60;  i = Math.floor(h);  f = h - i;  p = v * (1 - s);  q = v * (1 - s * f);  t = v * (1 - s * (1 - f));   switch(i) {      case 0:          r = v;          g = t;          b = p;          break;       case 1:          r = q;          g = v;          b = p;          break;       case 2:          r = p;          g = v;          b = t;          break;       case 3:          r = p;          g = q;          b = v;          break;       case 4:          r = t;          g = p;          b = v;          break;       default: // case 5:          r = v;          g = p;          b = q;  }   return [      Math.round(r * 255),      Math.round(g * 255),      Math.round(b * 255)  ]; }</span></span></code> </pre> </div></div><br><p>  Temperatur warna dapat dilakukan dengan lebih mudah - jika rentang nilai yang tersedia untuk lampu Anda diketahui, maka dapat dikonversi ke interval yang tersedia untuk HomeKit (melalui fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">scaleInt</a> ). </p><br><p><img src="https://habrastorage.org/webt/f0/vm/xh/f0vmxhpcndendf_efjf9xrmjxke.png" alt="Layanan Bola Lampu" title="Layanan bola lampu"></p><br><p><img src="https://habrastorage.org/webt/et/sp/fg/etspfg0idwn5v-cun2hh2y9xmm0.png"></p><br><div class="spoiler">  <b class="spoiler_title">Lebih dalam di lampu</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/w_/q8/8p/w_q88pboeca8hl0fygtssrjegim.png"><br><img src="https://habrastorage.org/webt/bt/5c/bc/bt5cbc59jttu8ibjev1hfnnwkdm.png"></p></div></div><br><h3 id="termostat">  Termostat </h3><br><p>  Thermostat - perangkat untuk mempertahankan suhu yang disetel (layanan Thermostat).  Dengan demikian, karakteristik utama dari termostat adalah suhu yang diinginkan (TargetTemperature).  Selain suhu yang disetel, suhu saat ini (CurrentTemperature) dapat ditunjukkan, yang bersifat informasi (karena perangkat hanya membacanya dari sensor). </p><br><p>  Dari aplikasi Rumah, suhu target diatur dalam termostat dan suhu saat ini dipantau.  Di termostat saya (Zont) hanya ada dua negara ini - mereka tersedia melalui layanan cloud api. </p><br><p>  Untuk keindahan menampilkan perangkat di HomeKit, saya harus menambahkan beberapa konstanta: kondisi pemanasan saat ini aktif (1), kondisi target pemanasan adalah otomatis (3). </p><br><p><img src="https://habrastorage.org/webt/vn/dd/ey/vnddeyypjlofn2jkxrqwe5ybwuw.png" alt="Layanan Termostat" title="Layanan termostat"></p><br><p><img src="https://habrastorage.org/webt/pk/9u/k3/pk9uk3vfurepl1kfgow5lrp66dc.png"></p><br><div class="spoiler">  <b class="spoiler_title">Pemilihan suhu</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/_4/g8/co/_4g8coln1rlsodscr8sah8p_h9o.png"></p></div></div><br><h3 id="vorota">  Gates </h3><br><p>  Dengan pintu garasi (layanan GarageDoorOpener), semuanya lebih rumit daripada dengan termostat. </p><br><p>  Dari karakteristik yang tersedia, gerbang memiliki status target (TargetDoorState), yang menunjukkan keinginan kita untuk gerbang menjadi "terbuka" atau "ditutup".  Tetapi Anda juga harus menampilkan dengan benar keadaan gerbang saat ini (CurrentDoorState): apakah mereka membuka atau menutup, atau mungkin mereka membuka atau menutup? </p><br><p>  Dalam kasus saya, gerbang dibuka melalui mqtt di ioBroker dengan beberapa status informasi: </p><br><ul><li>  tanda keterbukaan gerbang (OB) </li><li>  tanda pergerakan gerbang (LW) </li></ul><br><p><img src="https://habrastorage.org/webt/aw/b3/ip/awb3ipo5vz8qrn8jawhcfunuouc.png" alt="Status Kontrol Pintu Garasi" title="Status Kontrol Pintu Garasi"></p><br><p>  Berkat status ini, Anda dapat menghitung status gerbang saat ini: </p><br><ul><li>  jika tidak ada OB dan tidak ada DV, maka gerbang ditutup </li><li>  jika tidak ada OB dan ada DV, maka gerbang akan terbuka </li><li>  jika ada OB dan tidak ada DV, maka gerbang terbuka </li><li>  jika ada OB dan ada DV, maka gerbang ditutup </li></ul><br><p>  Untuk mengirim sinyal untuk membuka dan menutup gerbang, saya memiliki dua keadaan terpisah (akan mungkin untuk mengelola dengan satu keadaan, tetapi saya memiliki dua keadaan), yang mengirim pesan melalui mqtt ke pengontrol kontrol gerbang: </p><br><ul><li>  sinyal pembuka </li><li>  sinyal penutupan </li></ul><br><p>  Untuk mengirim sinyal, Anda perlu mensimulasikan tombol "klik": atur nilainya menjadi true, dan setelah beberapa saat atur ulang ke false.  Dalam hal ini, untuk berintegrasi dengan HomeKit, perlu untuk membuat negara lain - "negara tujuan gerbang", ketika diubah, sinyal yang sesuai akan dikirim. </p><br><p>  Tanda keterbukaan gerbang dapat digantikan oleh status target (mis. Tujuan apa yang akan dituju): </p><br><ul><li>  jika CA "ditutup" dan tidak ada DV, maka gerbang ditutup </li><li>  jika CA "tertutup" dan ada DV, maka gerbang terbuka </li><li>  jika CA "terbuka" dan tidak ada DV, maka gerbang terbuka </li><li>  jika CA "terbuka" dan ada DV, maka gerbang ditutup </li></ul><br><p>  Kami juga akan membuat keadaan terpisah "gerbang saat ini", dan kami akan mengisinya dalam skrip tergantung pada nilai tanda dan pada negara target. </p><br><div class="spoiler">  <b class="spoiler_title">Sebutkan naskah perubahan untuk pintu garasi</b> <div class="spoiler_text"><pre> <code class="javascript hljs">createState(<span class="hljs-string"><span class="hljs-string">"gate_0.current"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   createState("gate_0.target"); //   //    0,   300 on({id: "mqtt.0.gate.gpio.13", ack: false, val: 1}, function (obj) {  setStateDelayed("mqtt.0.gate.gpio.13", 0,  300); }); on({id: "mqtt.0.gate.gpio.12", ack: false, val: 1}, function (obj) {  setStateDelayed("mqtt.0.gate.gpio.12", 0,  300); }); //     on({id: "mqtt.0.gate.is_open", ack: false, val: 1}, function (obj) {  // ""  setState("javascript.0.gate_0.current", 0, true); }); on({id: "mqtt.0.gate.is_open", ack: false, val: 0}, function (obj) {  // ""  setState("javascript.0.gate_0.current", 1, true); }); //    - ,      on({id: "javascript.0.gate_0.target", ack: false, val: 0}, function (obj) {  setState("mqtt.0.gate.gpio.12", 1); }); //    - ,      on({id: "javascript.0.gate_0.target", ack: false, val: 1}, function (obj) {  setState("mqtt.0.gate.gpio.13", 1); }); on({id: "mqtt.0.gate.in_progress", ack: true, change: 'any'}, function (obj) {  //    " ",      if (obj.state.val === 1) {      //    "",         const target = getState("javascript.0.gate_0.target");      if (target.val === 0) {          // ""          setState("javascript.0.gate_0.current", 2, true);      } else {          // ""          setState("javascript.0.gate_0.current", 3, true);      }  }  //    " ",      if (obj.state.val === 0) {      //    "",         const target = getState("javascript.0.gate_0.target");      if (target.val === 0) {          // ""          setState("javascript.0.gate_0.current", 0, true);      } else {          // ""          setState("javascript.0.gate_0.current", 1, true);      }  } });</span></span></code> </pre> </div></div><br><p>  Setelah menjalankan skrip, Anda dapat mengonfigurasi karakteristik layanan pintu garasi: </p><br><p><img src="https://habrastorage.org/webt/lb/cm/t5/lbcmt51du7vnivrjbj2o_h_u28u.png" alt="Layanan GarageDoorOpener" title="Layanan GarageDoorOpener"></p><br><p><img src="https://habrastorage.org/webt/pg/rh/ey/pgrhey_qs-cxm8rg6yj_lufgmgs.png"></p><br><h3 id="kamera">  Kamera </h3><br><p>  Untuk menambahkan kamera ke HomeKit, metode "klasik" akan digunakan.  Penyiaran gambar dari kamera melalui modul ffmpeg diatur.  Melalui itu, aliran input akan dikodekan, dienkripsi, dan diberikan ke Homekit. </p><br><p>  Pertama-tama, Anda perlu menginstal ffmpeg di server tempat ioBroker berada. </p><br><p>  Untuk setiap platform, diinstal dengan cara yang berbeda, Anda dapat mengumpulkannya dari sumber, atau mencari perakitan yang sudah jadi, misalnya, di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.johnvansickle.com/ffmpeg/</a> Harus memiliki enkoder libx264.  Anda dapat memeriksa pembuat enkode setelah menginstal ffmpeg dengan perintah: </p><br><pre> <code class="plaintext hljs">ffmpeg -codecs | grep 264</code> </pre> <br><p>  Hasilnya harus berisi garis formulir: </p><br><pre> <code class="plaintext hljs">DEV.LS h264                 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (decoders: h264 h264_v4l2m2m h264_vdpau ) (encoders: libx264 libx264rgb h264_v4l2m2m )</code> </pre> <br><p>  Untuk Raspberry Pi 3, Anda dapat menggunakan <a href="">rakitan siap pakai</a> , yang memiliki codec dengan dukungan untuk penyandian perangkat keras GPU (h264_omx, lebih sedikit sumber daya).  Letakkan seperti ini: </p><br><pre> <code class="plaintext hljs">wget https://github.com/legotheboss/YouTube-files/raw/master/ffmpeg_3.1.4-1_armhf.deb sudo dpkg -i ffmpeg_3.1.4-1_armhf.deb</code> </pre> <br><p>  Kedua codec hadir dalam majelis ini: libx264 dan h264_omx </p><br><p>  Selanjutnya, Anda perlu mendapatkan alamat aliran kamera yang perlu disiarkan (langkah ini di luar cakupan artikel ini).  Misalnya, Anda dapat mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aliran publik yang sudah jadi</a> . </p><br><p>  Sekarang tambahkan kamera ke Yahka, tunjukkan alamat aliran, dan jika perlu ubah parameter codec, ukuran gambar, kecepatan bingkai. </p><br><p>  <strong>Penting: kombinasi parameter sangat penting untuk tampilan kamera yang benar di Homekit dan bergantung pada kamera dan streaming.</strong>  <strong>Ini juga mempengaruhi kinerja sistem, seperti</strong>  <strong>Proses berjalan ffmpeg menghabiskan banyak sumber daya.</strong> </p><br><p><img src="https://habrastorage.org/webt/zh/uj/6g/zhuj6gv7alolh2nfvmpyxgmnoju.png" alt="Menambahkan Kamera" title="Berbicara kamera"></p><br><p><img src="https://habrastorage.org/webt/w7/_z/pl/w7_zplfretbtbw0v66nb9ip9ira.png" alt="Pengaturan aliran" title="Pengaturan aliran"></p><br><div class="spoiler">  <b class="spoiler_title">Kamera ditambahkan sebagai perangkat terpisah di luar gateway, dan mereka harus ditambahkan dengan cara yang sama seperti gateway</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ib/8v/s9/ib8vs9ksuw5mk4ese_-gg6rnrv4.png"></p></div></div><br><p><img src="https://habrastorage.org/webt/0d/hp/qd/0dhpqdbfe_hgez4u7x2edcu92za.png" alt="Thumbnail kamera" title="Kamera thumbnail"></p><br><p><img src="https://habrastorage.org/webt/ue/tj/o4/uetjo4rqvi-fsae2rlkt56cmaji.png" alt="Siaran dari kamera" title="Siaran dari kamera"></p><br><h3 id="bonus">  Bonus </h3><br><p>  Sebagai bonus, saya akan berbicara tentang penggunaan siaran kamera yang tidak biasa. </p><br><p>  Dengan menggunakan ffmpeg yang sama, alih-alih kamera, Anda dapat mencoba menyiarkan gambar, gambar apa pun.  Gambar-gambar ini juga dapat dikombinasikan dengan aliran video.  Anda dapat menampilkan teks, grafik, dan informasi lain pada gambar. </p><br><p><img src="https://habrastorage.org/webt/sg/cl/f7/sgclf7ssws1pkm_rlf3qy_avmhi.png" alt="Cast Overlay Teks" title="Keluarkan teks hamparan"></p><br><p>  Hasilnya, Anda bisa mendapatkan dasbor yang menarik.  Dan jika Anda memperbarui gambar secara berkala, Anda mendapatkan data dinamis. </p><br><p>  Sebagai contoh, saya mengeluarkan grafik perubahan dalam beberapa indikator dalam bentuk gambar (file pada disk).  Grafik ini diperbarui satu menit sekali dan menimpa gambar dalam file. </p><br><div class="spoiler">  <b class="spoiler_title">(fungsi createImage1, createImage2, pembentukan grafik dan pengenaan teks pada gambar berada di luar ruang lingkup artikel ini, tapi saya akan memberikan petunjuk).</b> <div class="spoiler_text"><p>  Saya akan memberi tahu Anda bagaimana Anda bisa mendapatkan grafik dalam bentuk gambar. </p><br><p>  IoBroker memiliki cara standar untuk membuat grafik - driver Flot.  Driver ini dipasangkan dengan driver web dan menampilkan hasilnya di browser.  Tetapi untuk mendapatkan grafik yang dibuat di server (dalam skrip) sebagai gambar, diperlukan driver PhantomJS tambahan, yang mengambil "tangkapan layar" halaman (di mana kita akan menggambar grafik Flot). </p><br><p>  Tetapi saya akan berbicara tentang cara alternatif untuk membuat grafik di server dalam sebuah skrip. </p><br><p>  Ada perpustakaan Chart.js <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.chartjs.org/</a> yang memungkinkan Anda menggambar grafik yang tampak bagus di peramban (contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.chartjs.org/samples/latest/</a> ). </p><br><p>  Untuk menggambar, ia menggunakan "kanvas" (kanvas, kanvas) browser.  Oleh karena itu, untuk menggambar menggunakan perpustakaan ini di server, Anda perlu menggunakan versi "server" dari "kanvas" dan objek DOM.  Inilah yang dilakukan oleh paket chartjs-node ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/vmpowerio/chartjs-node</a> ). </p><br><p>  Ketergantungan utama untuk paket ini adalah paket kanvas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/Automattic/node-canvas</a> ), yang harus diinstal secara global (atau dalam folder iobroker).  Penting untuk menginstal semua dependensi untuk platform tempat Anda meletakkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/Automattic/node-canvas#compiling</a> . </p><br><p>  Setelah itu, Anda dapat menambahkan modul chart.js, chartjs-node dalam pengaturan driver javascript.  Mereka harus menginstal dengan benar, tanpa kesalahan.  Jika tidak, atasi kesalahan dan selesaikan. </p><br><p>  Dan kemudian, Anda dapat menulis skrip. </p><br><p>  Di bawah ini adalah skrip untuk contoh, sebagai  itu termasuk penggunaan driver Sejarah dan menggunakan nama negara tertentu. </p><br><p>  Perhatian!  Script memiliki konstruksi yang rumit untuk pemula - Janji.  Ini adalah cara yang mudah untuk tidak menulis fungsi dengan callback, tetapi untuk membuat rantai langkah.  Jadi, misalnya, mudah untuk melakukan ini untuk mendapatkan data dari sejarah negara. </p><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ChartjsNode = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chartjs-node'</span></span>); <span class="hljs-comment"><span class="hljs-comment">/** *  sendTo  Promise,      */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendToPromise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">adapter, cmd, params</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { sendTo(adapter, cmd, params, (result) =&gt; { resolve(result); }); }); } <span class="hljs-comment"><span class="hljs-comment">//    const chartColors = { black: 'rgb(0, 0, 0)', red: 'rgb(255, 99, 132)', orange: 'rgb(255, 159, 64)', yellow: 'rgb(255, 205, 86)', green: 'rgb(75, 192, 192)', blue: 'rgb(54, 162, 235)', purple: 'rgb(153, 102, 255)', grey: 'rgb(201, 203, 207)' }; /** *        * : * @param config -     * @param filename -     * : * @param Promise -    */ function doDraw(config, filename) { //     640x480  var chartNode = new ChartjsNode(640, 480); return chartNode.drawChart(config) .then(() =&gt; { //     return chartNode.writeImageToFile('image/png', filename); }); } /** *     ChartJS. * : * @param Promise -    */ function prepareDraw0(){ // ,    var ; //  Promise     return new Promise((resolve, reject)=&gt;{resolve()}) //       ,      .then(()=&gt;{ //  ,   ,      = [ {"val":3,"ack":1,"ts":1539063874301}, {"val":5,"ack":1,"ts":1539063884299}, {"val":5.3,"ack":1,"ts":1539063894299}, {"val":3.39,"ack":1,"ts":1539063904301}, {"val":5.6,"ack":1,"ts":1539063914300}, {"val":-1.3,"ack":1,"ts":1539063924300}, {"val":-6.3,"ack":1,"ts":1539063934302}, {"val":1.23,"ack":1,"ts":1539063944301}, ]; }) //   -    .then(()=&gt;{ const chartJsOptions = { //   -  type: 'line', data: { //    datasets: [ { //   label: '', //  backgroundColor: chartColors.black, borderColor: chartColors.black, //   pointRadius: 3, //    borderWidth: 3, //     ''        data: .map((item) =&gt; { return {y: item.val, t: new Date(item.ts)} }), //   -  fill: false, } ] }, options: { //   legend: { labels: { //   fontSize: 20, }, }, //   scales: { //  X xAxes: [{ //  -   type: 'time', display: true, //   scaleLabel: { display: true, labelString: '' }, }], //  Y yAxes: [{ //  -  type: 'linear', display: true, //   scaleLabel: { display: true, labelString: '' }, }] } } }; return chartJsOptions; }); } /** *     ChartJS. *         , *     . * * : * @param hours -  ,     * : * @param Promise -    */ function prepareDraw1(hours){ //   ,      const end = new Date().getTime(), start = end - 3600000*(hours || 1); // 1 =   //  ,       //   var , 2, 1, 2, 2; //  Promise     return new Promise((resolve, reject)=&gt;{resolve()}) //       'mqtt.0.ESP_Easy..Temperature' .then(() =&gt; { return sendToPromise('history.0', 'getHistory', { id: 'mqtt.0.ESP_Easy..Temperature', options: { start: start, end: end, aggregate: 'onchange' } } ).then((result) =&gt; { //     ''  = result.result; }); }) //       'sonoff.0.chicken2.DS18B20_Temperature' .then(() =&gt; { return sendToPromise('history.0', 'getHistory', { id: 'sonoff.0.chicken2.DS18B20_Temperature', options: { start: start, end: end, aggregate: 'onchange' } }).then((result)=&gt;{ //     '2' 2 = result.result; }); }) .then(() =&gt; { return sendToPromise('history.0', 'getHistory', { id: 'sonoff.0.sonoff_chicken_vent.DS18B20_Temperature', options: { start: start, end: end, aggregate: 'onchange' } }).then((result)=&gt;{ 1 = result.result; }); }) .then(() =&gt; { return sendToPromise('history.0', 'getHistory', { id: 'sonoff.0.chicken2.POWER1', options: { start: start, end: end, aggregate: 'onchange' } }).then((result)=&gt;{ 2 = result.result; }); }) .then(() =&gt; { return sendToPromise('history.0', 'getHistory', { id: 'sonoff.0.chicken2.POWER2', options: { start: start, end: end, aggregate: 'onchange' } }).then((result)=&gt;{ 2 = result.result; }); }) //   -    .then(()=&gt;{ const chartJsOptions = { //   -  type: 'line', data: { //    datasets: [ { //           label: ' ('+[.length - 1].val+')', //  backgroundColor: chartColors.blue, borderColor: chartColors.blue, //  . 0 -   pointRadius: 0, //    borderWidth: 3, //     ''        data: .map((item) =&gt; { return {y: item.val, t: new Date(item.ts)} }), //   -  fill: false, //   Y yAxisID: 'y-axis-1', },{ label: ' 1 ('+1[1.length - 1].val+')', backgroundColor: chartColors.green, borderColor: chartColors.green, pointRadius: 0, borderWidth: 3, data: 1.map((item) =&gt; { return {y: item.val, t: new Date(item.ts)} }), fill: false, yAxisID: 'y-axis-1', },{ label: ' 2 ('+2[2.length - 1].val+')', backgroundColor: chartColors.red, borderColor: chartColors.red, pointRadius: 0, borderWidth: 3, data: 2.map((item) =&gt; { return {y: item.val, t: new Date(item.ts)} }), fill: false, yAxisID: 'y-axis-1', },{ label: ' 2  ('+2[2.length - 1].val+')', backgroundColor: chartColors.yellow, borderColor: chartColors.yellow, pointRadius: 0, borderWidth: 1, data: 2.map((item) =&gt; { return {y: (item.val) ? 1 : 0, t: new Date(item.ts)} }), fill: true, lineTension: 0, steppedLine: true, yAxisID: 'y-axis-2', },{ label: ' 2  ('+2[2.length - 1].val+')', backgroundColor: chartColors.grey, borderColor: chartColors.grey, pointRadius: 0, borderWidth: 1, data: 2.map((item) =&gt; { return {y: (item.val) ? -1 : 0, t: new Date(item.ts)} }), fill: true, lineTension: 0, steppedLine: true, yAxisID: 'y-axis-2', } ] }, options: { //   legend: { labels: { //   fontSize: 20, }, }, //   scales: { //  X xAxes: [{ //  -   type: 'time', display: true, //   scaleLabel: { display: true, labelString: '' }, //    () time: { unit: 'minute', displayFormats: { minute: 'HH:mm' } }, }], //  Y yAxes: [{ //  -  type: 'linear', display: true, //   scaleLabel: { display: true, labelString: '' }, //   -  position: 'left', //   id: 'y-axis-1', },{ type: 'linear', display: true, scaleLabel: { display: true, labelString: '  ' }, ticks: { min: -4, max: 2 }, //   -  position: 'right', id: 'y-axis-2', }] } } }; return chartJsOptions; }); } function createImage(filename, callback){ // filename -  ,       //    prepareDraw1(2) //     .then((result) =&gt; { //        return doDraw(result, filename); }) .then(()=&gt;{ if (callback) callback(); }) .catch((err)=&gt;{ console.error(err); }); }</span></span></code> </pre> </div></div><br><p><img src="https://habrastorage.org/webt/4c/d5/bs/4cd5bslfzniznrd16qfmqu0tuly.png" alt="Siarkan gambar alih-alih streaming" title="Siarkan gambar alih-alih streaming"></p><br><p>  Gambar kecil diperbarui kira-kira satu kali per menit, jadi kami menetapkan gambar untuk diperbarui setiap 10 detik: </p><br><pre> <code class="plaintext hljs">var fs = require('fs'); //  10    schedule("*/10 * * * * *", () =&gt; {  createImage1('/tmp/1_new.jpg', ()=&gt; {      fs.renameSync('/tmp/1_new.jpg', '/tmp/1.jpg');  });  createImage2('/tmp/2_new.jpg', ()=&gt; {      fs.renameSync('/tmp/2_new.jpg', '/tmp/2.jpg');  }); });</code> </pre> <br><p>  Keunikannya adalah bahwa dalam proses penyiaran gambar, perlu untuk mengganti gambar dengan cukup cepat sehingga ffmpeg tidak crash :) Oleh karena itu, gambar dibentuk pertama menjadi satu file, dan kemudian file tersebut diubah namanya menjadi yang digunakan untuk terjemahan. </p><br><p>  Sekarang, dalam pengaturan kamera, tentukan nama file yang dihasilkan alih-alih alamat streaming, dan tambahkan pengaturan bahwa gambar itu "diperbarui" (parameter "-loop 1").  Ini dikonfigurasikan dalam properti kamera tingkat lanjut.  Properti ini tidak lebih dari opsi baris perintah untuk menjalankan ffmpeg.  Oleh karena itu, kombinasi parameter harus ditemukan dalam dokumentasi dan contoh ffmpeg. </p><br><p>  Properti dibagi menjadi 2 jenis: untuk mendapatkan "pratinjau" (gambar kamera kecil) dan untuk penyiaran.  Oleh karena itu, Anda dapat menentukan file sumber gambar yang berbeda, misalnya dengan detail berbeda. </p><br><p><img src="https://habrastorage.org/webt/zy/30/b4/zy30b4wc2zud54wr-px_ezovdgu.png" alt="Opsi mulai ffmpeg" title="Opsi mulai ffmpeg"></p><br><p><img src="https://habrastorage.org/webt/mk/l5/qi/mkl5qizqb41if_youa62qrgm9hc.png" alt="Gambar Siaran Langsung" title="Gambar siaran langsung"></p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>         ioBroker     .       ,       . ,   ,        . </p><br><p>  ,    Yahka       ,      Material.           ,            HomeKit. </p><br><p>       Yahka,    HomeKit     —  Ham,     HomeBridge         .       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433798/">https://habr.com/ru/post/id433798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433786/index.html">Fintech Digest: cryptocurrency adalah properti, sejumlah rekor kartu kredit telah dikeluarkan di Federasi Rusia</a></li>
<li><a href="../id433788/index.html">Transaksi Aman dan Ulasan Freelance Baru</a></li>
<li><a href="../id433790/index.html">Templat bangun multi tahap tingkat lanjut</a></li>
<li><a href="../id433792/index.html">Skrip shell dalam Ansible</a></li>
<li><a href="../id433796/index.html">Bagaimana Homo Sapiens menaklukkan dunia. Keterampilan komunikasi dan negosiasi</a></li>
<li><a href="../id433800/index.html">Menggunakan pengontrol PSBC UDB Cypress untuk mengurangi interupsi pada printer 3D</a></li>
<li><a href="../id433802/index.html">Bagaimana dan mengapa kami memenangkan jalur Big Data di Urban Tech Challenge Hackathon</a></li>
<li><a href="../id433804/index.html">Jaringan kerapatan campuran</a></li>
<li><a href="../id433806/index.html">Ketika arsip online lupa</a></li>
<li><a href="../id433808/index.html">5 kesalahan paling umum yang dilakukan programmer pada saat wawancara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>